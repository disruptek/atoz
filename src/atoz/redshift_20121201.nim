
import
  json, options, hashes, uri, strutils, tables, rest, os, uri, strutils, httpcore, sigv4

## auto-generated via openapi macro
## title: Amazon Redshift
## version: 2012-12-01
## termsOfService: https://aws.amazon.com/service-terms/
## license:
##     name: Apache 2.0 License
##     url: http://www.apache.org/licenses/
## 
## <fullname>Amazon Redshift</fullname> <p> <b>Overview</b> </p> <p>This is an interface reference for Amazon Redshift. It contains documentation for one of the programming or command line interfaces you can use to manage Amazon Redshift clusters. Note that Amazon Redshift is asynchronous, which means that some interfaces may require techniques, such as polling or asynchronous callback handlers, to determine when a command has been applied. In this reference, the parameter descriptions indicate whether a change is applied immediately, on the next instance reboot, or during the next maintenance window. For a summary of the Amazon Redshift cluster management interfaces, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/using-aws-sdk.html">Using the Amazon Redshift Management Interfaces</a>.</p> <p>Amazon Redshift manages all the work of setting up, operating, and scaling a data warehouse: provisioning capacity, monitoring and backing up the cluster, and applying patches and upgrades to the Amazon Redshift engine. You can focus on using your data to acquire new insights for your business and customers.</p> <p>If you are a first-time user of Amazon Redshift, we recommend that you begin by reading the <a href="https://docs.aws.amazon.com/redshift/latest/gsg/getting-started.html">Amazon Redshift Getting Started Guide</a>.</p> <p>If you are a database developer, the <a href="https://docs.aws.amazon.com/redshift/latest/dg/welcome.html">Amazon Redshift Database Developer Guide</a> explains how to design, build, query, and maintain the databases that make up your data warehouse. </p>
## 
## Amazon Web Services documentation
## https://docs.aws.amazon.com/redshift/
type
  Scheme {.pure.} = enum
    Https = "https", Http = "http", Wss = "wss", Ws = "ws"
  ValidatorSignature = proc (query: JsonNode = nil; body: JsonNode = nil;
                          header: JsonNode = nil; path: JsonNode = nil;
                          formData: JsonNode = nil): JsonNode
  OpenApiRestCall = ref object of RestCall
    validator*: ValidatorSignature
    route*: string
    base*: string
    host*: string
    schemes*: set[Scheme]
    url*: proc (protocol: Scheme; host: string; base: string; route: string;
              path: JsonNode; query: JsonNode): Uri

  OpenApiRestCall_610642 = ref object of OpenApiRestCall
proc hash(scheme: Scheme): Hash {.used.} =
  result = hash(ord(scheme))

proc clone[T: OpenApiRestCall_610642](t: T): T {.used.} =
  result = T(name: t.name, meth: t.meth, host: t.host, base: t.base, route: t.route,
           schemes: t.schemes, validator: t.validator, url: t.url)

proc pickScheme(t: OpenApiRestCall_610642): Option[Scheme] {.used.} =
  ## select a supported scheme from a set of candidates
  for scheme in Scheme.low .. Scheme.high:
    if scheme notin t.schemes:
      continue
    if scheme in [Scheme.Https, Scheme.Wss]:
      when defined(ssl):
        return some(scheme)
      else:
        continue
    return some(scheme)

proc validateParameter(js: JsonNode; kind: JsonNodeKind; required: bool;
                      default: JsonNode = nil): JsonNode =
  ## ensure an input is of the correct json type and yield
  ## a suitable default value when appropriate
  if js == nil:
    if default != nil:
      return validateParameter(default, kind, required = required)
  result = js
  if result == nil:
    assert not required, $kind & " expected; received nil"
    if required:
      result = newJNull()
  else:
    assert js.kind == kind, $kind & " expected; received " & $js.kind

type
  KeyVal {.used.} = tuple[key: string, val: string]
  PathTokenKind = enum
    ConstantSegment, VariableSegment
  PathToken = tuple[kind: PathTokenKind, value: string]
proc queryString(query: JsonNode): string {.used.} =
  var qs: seq[KeyVal]
  if query == nil:
    return ""
  for k, v in query.pairs:
    qs.add (key: k, val: v.getStr)
  result = encodeQuery(qs)

proc hydratePath(input: JsonNode; segments: seq[PathToken]): Option[string] {.used.} =
  ## reconstitute a path with constants and variable values taken from json
  var head: string
  if segments.len == 0:
    return some("")
  head = segments[0].value
  case segments[0].kind
  of ConstantSegment:
    discard
  of VariableSegment:
    if head notin input:
      return
    let js = input[head]
    case js.kind
    of JInt, JFloat, JNull, JBool:
      head = $js
    of JString:
      head = js.getStr
    else:
      return
  var remainder = input.hydratePath(segments[1 ..^ 1])
  if remainder.isNone:
    return
  result = some(head & remainder.get)

const
  awsServers = {Scheme.Http: {"ap-northeast-1": "redshift.ap-northeast-1.amazonaws.com", "ap-southeast-1": "redshift.ap-southeast-1.amazonaws.com",
                           "us-west-2": "redshift.us-west-2.amazonaws.com",
                           "eu-west-2": "redshift.eu-west-2.amazonaws.com", "ap-northeast-3": "redshift.ap-northeast-3.amazonaws.com", "eu-central-1": "redshift.eu-central-1.amazonaws.com",
                           "us-east-2": "redshift.us-east-2.amazonaws.com",
                           "us-east-1": "redshift.us-east-1.amazonaws.com", "cn-northwest-1": "redshift.cn-northwest-1.amazonaws.com.cn",
                           "ap-south-1": "redshift.ap-south-1.amazonaws.com",
                           "eu-north-1": "redshift.eu-north-1.amazonaws.com", "ap-northeast-2": "redshift.ap-northeast-2.amazonaws.com",
                           "us-west-1": "redshift.us-west-1.amazonaws.com", "us-gov-east-1": "redshift.us-gov-east-1.amazonaws.com",
                           "eu-west-3": "redshift.eu-west-3.amazonaws.com", "cn-north-1": "redshift.cn-north-1.amazonaws.com.cn",
                           "sa-east-1": "redshift.sa-east-1.amazonaws.com",
                           "eu-west-1": "redshift.eu-west-1.amazonaws.com", "us-gov-west-1": "redshift.us-gov-west-1.amazonaws.com", "ap-southeast-2": "redshift.ap-southeast-2.amazonaws.com", "ca-central-1": "redshift.ca-central-1.amazonaws.com"}.toTable, Scheme.Https: {
      "ap-northeast-1": "redshift.ap-northeast-1.amazonaws.com",
      "ap-southeast-1": "redshift.ap-southeast-1.amazonaws.com",
      "us-west-2": "redshift.us-west-2.amazonaws.com",
      "eu-west-2": "redshift.eu-west-2.amazonaws.com",
      "ap-northeast-3": "redshift.ap-northeast-3.amazonaws.com",
      "eu-central-1": "redshift.eu-central-1.amazonaws.com",
      "us-east-2": "redshift.us-east-2.amazonaws.com",
      "us-east-1": "redshift.us-east-1.amazonaws.com",
      "cn-northwest-1": "redshift.cn-northwest-1.amazonaws.com.cn",
      "ap-south-1": "redshift.ap-south-1.amazonaws.com",
      "eu-north-1": "redshift.eu-north-1.amazonaws.com",
      "ap-northeast-2": "redshift.ap-northeast-2.amazonaws.com",
      "us-west-1": "redshift.us-west-1.amazonaws.com",
      "us-gov-east-1": "redshift.us-gov-east-1.amazonaws.com",
      "eu-west-3": "redshift.eu-west-3.amazonaws.com",
      "cn-north-1": "redshift.cn-north-1.amazonaws.com.cn",
      "sa-east-1": "redshift.sa-east-1.amazonaws.com",
      "eu-west-1": "redshift.eu-west-1.amazonaws.com",
      "us-gov-west-1": "redshift.us-gov-west-1.amazonaws.com",
      "ap-southeast-2": "redshift.ap-southeast-2.amazonaws.com",
      "ca-central-1": "redshift.ca-central-1.amazonaws.com"}.toTable}.toTable
const
  awsServiceName = "redshift"
method atozHook(call: OpenApiRestCall; url: Uri; input: JsonNode): Recallable {.base.}
type
  Call_PostAcceptReservedNodeExchange_611252 = ref object of OpenApiRestCall_610642
proc url_PostAcceptReservedNodeExchange_611254(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostAcceptReservedNodeExchange_611253(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Exchanges a DC1 Reserved Node for a DC2 Reserved Node with no changes to the configuration (term, payment type, or number of nodes) and no additional costs. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_611255 = query.getOrDefault("Action")
  valid_611255 = validateParameter(valid_611255, JString, required = true, default = newJString(
      "AcceptReservedNodeExchange"))
  if valid_611255 != nil:
    section.add "Action", valid_611255
  var valid_611256 = query.getOrDefault("Version")
  valid_611256 = validateParameter(valid_611256, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_611256 != nil:
    section.add "Version", valid_611256
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_611257 = header.getOrDefault("X-Amz-Signature")
  valid_611257 = validateParameter(valid_611257, JString, required = false,
                                 default = nil)
  if valid_611257 != nil:
    section.add "X-Amz-Signature", valid_611257
  var valid_611258 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_611258 = validateParameter(valid_611258, JString, required = false,
                                 default = nil)
  if valid_611258 != nil:
    section.add "X-Amz-Content-Sha256", valid_611258
  var valid_611259 = header.getOrDefault("X-Amz-Date")
  valid_611259 = validateParameter(valid_611259, JString, required = false,
                                 default = nil)
  if valid_611259 != nil:
    section.add "X-Amz-Date", valid_611259
  var valid_611260 = header.getOrDefault("X-Amz-Credential")
  valid_611260 = validateParameter(valid_611260, JString, required = false,
                                 default = nil)
  if valid_611260 != nil:
    section.add "X-Amz-Credential", valid_611260
  var valid_611261 = header.getOrDefault("X-Amz-Security-Token")
  valid_611261 = validateParameter(valid_611261, JString, required = false,
                                 default = nil)
  if valid_611261 != nil:
    section.add "X-Amz-Security-Token", valid_611261
  var valid_611262 = header.getOrDefault("X-Amz-Algorithm")
  valid_611262 = validateParameter(valid_611262, JString, required = false,
                                 default = nil)
  if valid_611262 != nil:
    section.add "X-Amz-Algorithm", valid_611262
  var valid_611263 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_611263 = validateParameter(valid_611263, JString, required = false,
                                 default = nil)
  if valid_611263 != nil:
    section.add "X-Amz-SignedHeaders", valid_611263
  result.add "header", section
  ## parameters in `formData` object:
  ##   ReservedNodeId: JString (required)
  ##                 : A string representing the node identifier of the DC1 Reserved Node to be exchanged.
  ##   TargetReservedNodeOfferingId: JString (required)
  ##                               : The unique identifier of the DC2 Reserved Node offering to be used for the exchange. You can obtain the value for the parameter by calling <a>GetReservedNodeExchangeOfferings</a> 
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `ReservedNodeId` field"
  var valid_611264 = formData.getOrDefault("ReservedNodeId")
  valid_611264 = validateParameter(valid_611264, JString, required = true,
                                 default = nil)
  if valid_611264 != nil:
    section.add "ReservedNodeId", valid_611264
  var valid_611265 = formData.getOrDefault("TargetReservedNodeOfferingId")
  valid_611265 = validateParameter(valid_611265, JString, required = true,
                                 default = nil)
  if valid_611265 != nil:
    section.add "TargetReservedNodeOfferingId", valid_611265
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_611266: Call_PostAcceptReservedNodeExchange_611252; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Exchanges a DC1 Reserved Node for a DC2 Reserved Node with no changes to the configuration (term, payment type, or number of nodes) and no additional costs. 
  ## 
  let valid = call_611266.validator(path, query, header, formData, body)
  let scheme = call_611266.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_611266.url(scheme.get, call_611266.host, call_611266.base,
                         call_611266.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_611266, url, valid)

proc call*(call_611267: Call_PostAcceptReservedNodeExchange_611252;
          ReservedNodeId: string; TargetReservedNodeOfferingId: string;
          Action: string = "AcceptReservedNodeExchange";
          Version: string = "2012-12-01"): Recallable =
  ## postAcceptReservedNodeExchange
  ## Exchanges a DC1 Reserved Node for a DC2 Reserved Node with no changes to the configuration (term, payment type, or number of nodes) and no additional costs. 
  ##   ReservedNodeId: string (required)
  ##                 : A string representing the node identifier of the DC1 Reserved Node to be exchanged.
  ##   TargetReservedNodeOfferingId: string (required)
  ##                               : The unique identifier of the DC2 Reserved Node offering to be used for the exchange. You can obtain the value for the parameter by calling <a>GetReservedNodeExchangeOfferings</a> 
  ##   Action: string (required)
  ##   Version: string (required)
  var query_611268 = newJObject()
  var formData_611269 = newJObject()
  add(formData_611269, "ReservedNodeId", newJString(ReservedNodeId))
  add(formData_611269, "TargetReservedNodeOfferingId",
      newJString(TargetReservedNodeOfferingId))
  add(query_611268, "Action", newJString(Action))
  add(query_611268, "Version", newJString(Version))
  result = call_611267.call(nil, query_611268, nil, formData_611269, nil)

var postAcceptReservedNodeExchange* = Call_PostAcceptReservedNodeExchange_611252(
    name: "postAcceptReservedNodeExchange", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=AcceptReservedNodeExchange",
    validator: validate_PostAcceptReservedNodeExchange_611253, base: "/",
    url: url_PostAcceptReservedNodeExchange_611254,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetAcceptReservedNodeExchange_610980 = ref object of OpenApiRestCall_610642
proc url_GetAcceptReservedNodeExchange_610982(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetAcceptReservedNodeExchange_610981(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Exchanges a DC1 Reserved Node for a DC2 Reserved Node with no changes to the configuration (term, payment type, or number of nodes) and no additional costs. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   ReservedNodeId: JString (required)
  ##                 : A string representing the node identifier of the DC1 Reserved Node to be exchanged.
  ##   Version: JString (required)
  ##   TargetReservedNodeOfferingId: JString (required)
  ##                               : The unique identifier of the DC2 Reserved Node offering to be used for the exchange. You can obtain the value for the parameter by calling <a>GetReservedNodeExchangeOfferings</a> 
  section = newJObject()
  var valid_611107 = query.getOrDefault("Action")
  valid_611107 = validateParameter(valid_611107, JString, required = true, default = newJString(
      "AcceptReservedNodeExchange"))
  if valid_611107 != nil:
    section.add "Action", valid_611107
  var valid_611108 = query.getOrDefault("ReservedNodeId")
  valid_611108 = validateParameter(valid_611108, JString, required = true,
                                 default = nil)
  if valid_611108 != nil:
    section.add "ReservedNodeId", valid_611108
  var valid_611109 = query.getOrDefault("Version")
  valid_611109 = validateParameter(valid_611109, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_611109 != nil:
    section.add "Version", valid_611109
  var valid_611110 = query.getOrDefault("TargetReservedNodeOfferingId")
  valid_611110 = validateParameter(valid_611110, JString, required = true,
                                 default = nil)
  if valid_611110 != nil:
    section.add "TargetReservedNodeOfferingId", valid_611110
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_611111 = header.getOrDefault("X-Amz-Signature")
  valid_611111 = validateParameter(valid_611111, JString, required = false,
                                 default = nil)
  if valid_611111 != nil:
    section.add "X-Amz-Signature", valid_611111
  var valid_611112 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_611112 = validateParameter(valid_611112, JString, required = false,
                                 default = nil)
  if valid_611112 != nil:
    section.add "X-Amz-Content-Sha256", valid_611112
  var valid_611113 = header.getOrDefault("X-Amz-Date")
  valid_611113 = validateParameter(valid_611113, JString, required = false,
                                 default = nil)
  if valid_611113 != nil:
    section.add "X-Amz-Date", valid_611113
  var valid_611114 = header.getOrDefault("X-Amz-Credential")
  valid_611114 = validateParameter(valid_611114, JString, required = false,
                                 default = nil)
  if valid_611114 != nil:
    section.add "X-Amz-Credential", valid_611114
  var valid_611115 = header.getOrDefault("X-Amz-Security-Token")
  valid_611115 = validateParameter(valid_611115, JString, required = false,
                                 default = nil)
  if valid_611115 != nil:
    section.add "X-Amz-Security-Token", valid_611115
  var valid_611116 = header.getOrDefault("X-Amz-Algorithm")
  valid_611116 = validateParameter(valid_611116, JString, required = false,
                                 default = nil)
  if valid_611116 != nil:
    section.add "X-Amz-Algorithm", valid_611116
  var valid_611117 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_611117 = validateParameter(valid_611117, JString, required = false,
                                 default = nil)
  if valid_611117 != nil:
    section.add "X-Amz-SignedHeaders", valid_611117
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_611140: Call_GetAcceptReservedNodeExchange_610980; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Exchanges a DC1 Reserved Node for a DC2 Reserved Node with no changes to the configuration (term, payment type, or number of nodes) and no additional costs. 
  ## 
  let valid = call_611140.validator(path, query, header, formData, body)
  let scheme = call_611140.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_611140.url(scheme.get, call_611140.host, call_611140.base,
                         call_611140.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_611140, url, valid)

proc call*(call_611211: Call_GetAcceptReservedNodeExchange_610980;
          ReservedNodeId: string; TargetReservedNodeOfferingId: string;
          Action: string = "AcceptReservedNodeExchange";
          Version: string = "2012-12-01"): Recallable =
  ## getAcceptReservedNodeExchange
  ## Exchanges a DC1 Reserved Node for a DC2 Reserved Node with no changes to the configuration (term, payment type, or number of nodes) and no additional costs. 
  ##   Action: string (required)
  ##   ReservedNodeId: string (required)
  ##                 : A string representing the node identifier of the DC1 Reserved Node to be exchanged.
  ##   Version: string (required)
  ##   TargetReservedNodeOfferingId: string (required)
  ##                               : The unique identifier of the DC2 Reserved Node offering to be used for the exchange. You can obtain the value for the parameter by calling <a>GetReservedNodeExchangeOfferings</a> 
  var query_611212 = newJObject()
  add(query_611212, "Action", newJString(Action))
  add(query_611212, "ReservedNodeId", newJString(ReservedNodeId))
  add(query_611212, "Version", newJString(Version))
  add(query_611212, "TargetReservedNodeOfferingId",
      newJString(TargetReservedNodeOfferingId))
  result = call_611211.call(nil, query_611212, nil, nil, nil)

var getAcceptReservedNodeExchange* = Call_GetAcceptReservedNodeExchange_610980(
    name: "getAcceptReservedNodeExchange", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=AcceptReservedNodeExchange",
    validator: validate_GetAcceptReservedNodeExchange_610981, base: "/",
    url: url_GetAcceptReservedNodeExchange_610982,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostAuthorizeClusterSecurityGroupIngress_611289 = ref object of OpenApiRestCall_610642
proc url_PostAuthorizeClusterSecurityGroupIngress_611291(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostAuthorizeClusterSecurityGroupIngress_611290(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Adds an inbound (ingress) rule to an Amazon Redshift security group. Depending on whether the application accessing your cluster is running on the Internet or an Amazon EC2 instance, you can authorize inbound access to either a Classless Interdomain Routing (CIDR)/Internet Protocol (IP) range or to an Amazon EC2 security group. You can add as many as 20 ingress rules to an Amazon Redshift security group.</p> <p>If you authorize access to an Amazon EC2 security group, specify <i>EC2SecurityGroupName</i> and <i>EC2SecurityGroupOwnerId</i>. The Amazon EC2 security group and Amazon Redshift cluster must be in the same AWS Region. </p> <p>If you authorize access to a CIDR/IP address range, specify <i>CIDRIP</i>. For an overview of CIDR blocks, see the Wikipedia article on <a href="http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing">Classless Inter-Domain Routing</a>. </p> <p>You must also associate the security group with a cluster so that clients running on these IP addresses or the EC2 instance are authorized to connect to the cluster. For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Working with Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_611292 = query.getOrDefault("Action")
  valid_611292 = validateParameter(valid_611292, JString, required = true, default = newJString(
      "AuthorizeClusterSecurityGroupIngress"))
  if valid_611292 != nil:
    section.add "Action", valid_611292
  var valid_611293 = query.getOrDefault("Version")
  valid_611293 = validateParameter(valid_611293, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_611293 != nil:
    section.add "Version", valid_611293
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_611294 = header.getOrDefault("X-Amz-Signature")
  valid_611294 = validateParameter(valid_611294, JString, required = false,
                                 default = nil)
  if valid_611294 != nil:
    section.add "X-Amz-Signature", valid_611294
  var valid_611295 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_611295 = validateParameter(valid_611295, JString, required = false,
                                 default = nil)
  if valid_611295 != nil:
    section.add "X-Amz-Content-Sha256", valid_611295
  var valid_611296 = header.getOrDefault("X-Amz-Date")
  valid_611296 = validateParameter(valid_611296, JString, required = false,
                                 default = nil)
  if valid_611296 != nil:
    section.add "X-Amz-Date", valid_611296
  var valid_611297 = header.getOrDefault("X-Amz-Credential")
  valid_611297 = validateParameter(valid_611297, JString, required = false,
                                 default = nil)
  if valid_611297 != nil:
    section.add "X-Amz-Credential", valid_611297
  var valid_611298 = header.getOrDefault("X-Amz-Security-Token")
  valid_611298 = validateParameter(valid_611298, JString, required = false,
                                 default = nil)
  if valid_611298 != nil:
    section.add "X-Amz-Security-Token", valid_611298
  var valid_611299 = header.getOrDefault("X-Amz-Algorithm")
  valid_611299 = validateParameter(valid_611299, JString, required = false,
                                 default = nil)
  if valid_611299 != nil:
    section.add "X-Amz-Algorithm", valid_611299
  var valid_611300 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_611300 = validateParameter(valid_611300, JString, required = false,
                                 default = nil)
  if valid_611300 != nil:
    section.add "X-Amz-SignedHeaders", valid_611300
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterSecurityGroupName: JString (required)
  ##                           : The name of the security group to which the ingress rule is added.
  ##   EC2SecurityGroupName: JString
  ##                       : The EC2 security group to be added the Amazon Redshift security group.
  ##   EC2SecurityGroupOwnerId: JString
  ##                          : <p>The AWS account number of the owner of the security group specified by the <i>EC2SecurityGroupName</i> parameter. The AWS Access Key ID is not an acceptable value. </p> <p>Example: <code>111122223333</code> </p>
  ##   CIDRIP: JString
  ##         : The IP range to be added the Amazon Redshift security group.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterSecurityGroupName` field"
  var valid_611301 = formData.getOrDefault("ClusterSecurityGroupName")
  valid_611301 = validateParameter(valid_611301, JString, required = true,
                                 default = nil)
  if valid_611301 != nil:
    section.add "ClusterSecurityGroupName", valid_611301
  var valid_611302 = formData.getOrDefault("EC2SecurityGroupName")
  valid_611302 = validateParameter(valid_611302, JString, required = false,
                                 default = nil)
  if valid_611302 != nil:
    section.add "EC2SecurityGroupName", valid_611302
  var valid_611303 = formData.getOrDefault("EC2SecurityGroupOwnerId")
  valid_611303 = validateParameter(valid_611303, JString, required = false,
                                 default = nil)
  if valid_611303 != nil:
    section.add "EC2SecurityGroupOwnerId", valid_611303
  var valid_611304 = formData.getOrDefault("CIDRIP")
  valid_611304 = validateParameter(valid_611304, JString, required = false,
                                 default = nil)
  if valid_611304 != nil:
    section.add "CIDRIP", valid_611304
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_611305: Call_PostAuthorizeClusterSecurityGroupIngress_611289;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Adds an inbound (ingress) rule to an Amazon Redshift security group. Depending on whether the application accessing your cluster is running on the Internet or an Amazon EC2 instance, you can authorize inbound access to either a Classless Interdomain Routing (CIDR)/Internet Protocol (IP) range or to an Amazon EC2 security group. You can add as many as 20 ingress rules to an Amazon Redshift security group.</p> <p>If you authorize access to an Amazon EC2 security group, specify <i>EC2SecurityGroupName</i> and <i>EC2SecurityGroupOwnerId</i>. The Amazon EC2 security group and Amazon Redshift cluster must be in the same AWS Region. </p> <p>If you authorize access to a CIDR/IP address range, specify <i>CIDRIP</i>. For an overview of CIDR blocks, see the Wikipedia article on <a href="http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing">Classless Inter-Domain Routing</a>. </p> <p>You must also associate the security group with a cluster so that clients running on these IP addresses or the EC2 instance are authorized to connect to the cluster. For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Working with Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_611305.validator(path, query, header, formData, body)
  let scheme = call_611305.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_611305.url(scheme.get, call_611305.host, call_611305.base,
                         call_611305.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_611305, url, valid)

proc call*(call_611306: Call_PostAuthorizeClusterSecurityGroupIngress_611289;
          ClusterSecurityGroupName: string; EC2SecurityGroupName: string = "";
          EC2SecurityGroupOwnerId: string = ""; CIDRIP: string = "";
          Action: string = "AuthorizeClusterSecurityGroupIngress";
          Version: string = "2012-12-01"): Recallable =
  ## postAuthorizeClusterSecurityGroupIngress
  ## <p>Adds an inbound (ingress) rule to an Amazon Redshift security group. Depending on whether the application accessing your cluster is running on the Internet or an Amazon EC2 instance, you can authorize inbound access to either a Classless Interdomain Routing (CIDR)/Internet Protocol (IP) range or to an Amazon EC2 security group. You can add as many as 20 ingress rules to an Amazon Redshift security group.</p> <p>If you authorize access to an Amazon EC2 security group, specify <i>EC2SecurityGroupName</i> and <i>EC2SecurityGroupOwnerId</i>. The Amazon EC2 security group and Amazon Redshift cluster must be in the same AWS Region. </p> <p>If you authorize access to a CIDR/IP address range, specify <i>CIDRIP</i>. For an overview of CIDR blocks, see the Wikipedia article on <a href="http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing">Classless Inter-Domain Routing</a>. </p> <p>You must also associate the security group with a cluster so that clients running on these IP addresses or the EC2 instance are authorized to connect to the cluster. For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Working with Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   ClusterSecurityGroupName: string (required)
  ##                           : The name of the security group to which the ingress rule is added.
  ##   EC2SecurityGroupName: string
  ##                       : The EC2 security group to be added the Amazon Redshift security group.
  ##   EC2SecurityGroupOwnerId: string
  ##                          : <p>The AWS account number of the owner of the security group specified by the <i>EC2SecurityGroupName</i> parameter. The AWS Access Key ID is not an acceptable value. </p> <p>Example: <code>111122223333</code> </p>
  ##   CIDRIP: string
  ##         : The IP range to be added the Amazon Redshift security group.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_611307 = newJObject()
  var formData_611308 = newJObject()
  add(formData_611308, "ClusterSecurityGroupName",
      newJString(ClusterSecurityGroupName))
  add(formData_611308, "EC2SecurityGroupName", newJString(EC2SecurityGroupName))
  add(formData_611308, "EC2SecurityGroupOwnerId",
      newJString(EC2SecurityGroupOwnerId))
  add(formData_611308, "CIDRIP", newJString(CIDRIP))
  add(query_611307, "Action", newJString(Action))
  add(query_611307, "Version", newJString(Version))
  result = call_611306.call(nil, query_611307, nil, formData_611308, nil)

var postAuthorizeClusterSecurityGroupIngress* = Call_PostAuthorizeClusterSecurityGroupIngress_611289(
    name: "postAuthorizeClusterSecurityGroupIngress", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=AuthorizeClusterSecurityGroupIngress",
    validator: validate_PostAuthorizeClusterSecurityGroupIngress_611290,
    base: "/", url: url_PostAuthorizeClusterSecurityGroupIngress_611291,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetAuthorizeClusterSecurityGroupIngress_611270 = ref object of OpenApiRestCall_610642
proc url_GetAuthorizeClusterSecurityGroupIngress_611272(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetAuthorizeClusterSecurityGroupIngress_611271(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Adds an inbound (ingress) rule to an Amazon Redshift security group. Depending on whether the application accessing your cluster is running on the Internet or an Amazon EC2 instance, you can authorize inbound access to either a Classless Interdomain Routing (CIDR)/Internet Protocol (IP) range or to an Amazon EC2 security group. You can add as many as 20 ingress rules to an Amazon Redshift security group.</p> <p>If you authorize access to an Amazon EC2 security group, specify <i>EC2SecurityGroupName</i> and <i>EC2SecurityGroupOwnerId</i>. The Amazon EC2 security group and Amazon Redshift cluster must be in the same AWS Region. </p> <p>If you authorize access to a CIDR/IP address range, specify <i>CIDRIP</i>. For an overview of CIDR blocks, see the Wikipedia article on <a href="http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing">Classless Inter-Domain Routing</a>. </p> <p>You must also associate the security group with a cluster so that clients running on these IP addresses or the EC2 instance are authorized to connect to the cluster. For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Working with Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   EC2SecurityGroupName: JString
  ##                       : The EC2 security group to be added the Amazon Redshift security group.
  ##   EC2SecurityGroupOwnerId: JString
  ##                          : <p>The AWS account number of the owner of the security group specified by the <i>EC2SecurityGroupName</i> parameter. The AWS Access Key ID is not an acceptable value. </p> <p>Example: <code>111122223333</code> </p>
  ##   ClusterSecurityGroupName: JString (required)
  ##                           : The name of the security group to which the ingress rule is added.
  ##   Action: JString (required)
  ##   Version: JString (required)
  ##   CIDRIP: JString
  ##         : The IP range to be added the Amazon Redshift security group.
  section = newJObject()
  var valid_611273 = query.getOrDefault("EC2SecurityGroupName")
  valid_611273 = validateParameter(valid_611273, JString, required = false,
                                 default = nil)
  if valid_611273 != nil:
    section.add "EC2SecurityGroupName", valid_611273
  var valid_611274 = query.getOrDefault("EC2SecurityGroupOwnerId")
  valid_611274 = validateParameter(valid_611274, JString, required = false,
                                 default = nil)
  if valid_611274 != nil:
    section.add "EC2SecurityGroupOwnerId", valid_611274
  assert query != nil, "query argument is necessary due to required `ClusterSecurityGroupName` field"
  var valid_611275 = query.getOrDefault("ClusterSecurityGroupName")
  valid_611275 = validateParameter(valid_611275, JString, required = true,
                                 default = nil)
  if valid_611275 != nil:
    section.add "ClusterSecurityGroupName", valid_611275
  var valid_611276 = query.getOrDefault("Action")
  valid_611276 = validateParameter(valid_611276, JString, required = true, default = newJString(
      "AuthorizeClusterSecurityGroupIngress"))
  if valid_611276 != nil:
    section.add "Action", valid_611276
  var valid_611277 = query.getOrDefault("Version")
  valid_611277 = validateParameter(valid_611277, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_611277 != nil:
    section.add "Version", valid_611277
  var valid_611278 = query.getOrDefault("CIDRIP")
  valid_611278 = validateParameter(valid_611278, JString, required = false,
                                 default = nil)
  if valid_611278 != nil:
    section.add "CIDRIP", valid_611278
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_611279 = header.getOrDefault("X-Amz-Signature")
  valid_611279 = validateParameter(valid_611279, JString, required = false,
                                 default = nil)
  if valid_611279 != nil:
    section.add "X-Amz-Signature", valid_611279
  var valid_611280 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_611280 = validateParameter(valid_611280, JString, required = false,
                                 default = nil)
  if valid_611280 != nil:
    section.add "X-Amz-Content-Sha256", valid_611280
  var valid_611281 = header.getOrDefault("X-Amz-Date")
  valid_611281 = validateParameter(valid_611281, JString, required = false,
                                 default = nil)
  if valid_611281 != nil:
    section.add "X-Amz-Date", valid_611281
  var valid_611282 = header.getOrDefault("X-Amz-Credential")
  valid_611282 = validateParameter(valid_611282, JString, required = false,
                                 default = nil)
  if valid_611282 != nil:
    section.add "X-Amz-Credential", valid_611282
  var valid_611283 = header.getOrDefault("X-Amz-Security-Token")
  valid_611283 = validateParameter(valid_611283, JString, required = false,
                                 default = nil)
  if valid_611283 != nil:
    section.add "X-Amz-Security-Token", valid_611283
  var valid_611284 = header.getOrDefault("X-Amz-Algorithm")
  valid_611284 = validateParameter(valid_611284, JString, required = false,
                                 default = nil)
  if valid_611284 != nil:
    section.add "X-Amz-Algorithm", valid_611284
  var valid_611285 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_611285 = validateParameter(valid_611285, JString, required = false,
                                 default = nil)
  if valid_611285 != nil:
    section.add "X-Amz-SignedHeaders", valid_611285
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_611286: Call_GetAuthorizeClusterSecurityGroupIngress_611270;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Adds an inbound (ingress) rule to an Amazon Redshift security group. Depending on whether the application accessing your cluster is running on the Internet or an Amazon EC2 instance, you can authorize inbound access to either a Classless Interdomain Routing (CIDR)/Internet Protocol (IP) range or to an Amazon EC2 security group. You can add as many as 20 ingress rules to an Amazon Redshift security group.</p> <p>If you authorize access to an Amazon EC2 security group, specify <i>EC2SecurityGroupName</i> and <i>EC2SecurityGroupOwnerId</i>. The Amazon EC2 security group and Amazon Redshift cluster must be in the same AWS Region. </p> <p>If you authorize access to a CIDR/IP address range, specify <i>CIDRIP</i>. For an overview of CIDR blocks, see the Wikipedia article on <a href="http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing">Classless Inter-Domain Routing</a>. </p> <p>You must also associate the security group with a cluster so that clients running on these IP addresses or the EC2 instance are authorized to connect to the cluster. For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Working with Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_611286.validator(path, query, header, formData, body)
  let scheme = call_611286.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_611286.url(scheme.get, call_611286.host, call_611286.base,
                         call_611286.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_611286, url, valid)

proc call*(call_611287: Call_GetAuthorizeClusterSecurityGroupIngress_611270;
          ClusterSecurityGroupName: string; EC2SecurityGroupName: string = "";
          EC2SecurityGroupOwnerId: string = "";
          Action: string = "AuthorizeClusterSecurityGroupIngress";
          Version: string = "2012-12-01"; CIDRIP: string = ""): Recallable =
  ## getAuthorizeClusterSecurityGroupIngress
  ## <p>Adds an inbound (ingress) rule to an Amazon Redshift security group. Depending on whether the application accessing your cluster is running on the Internet or an Amazon EC2 instance, you can authorize inbound access to either a Classless Interdomain Routing (CIDR)/Internet Protocol (IP) range or to an Amazon EC2 security group. You can add as many as 20 ingress rules to an Amazon Redshift security group.</p> <p>If you authorize access to an Amazon EC2 security group, specify <i>EC2SecurityGroupName</i> and <i>EC2SecurityGroupOwnerId</i>. The Amazon EC2 security group and Amazon Redshift cluster must be in the same AWS Region. </p> <p>If you authorize access to a CIDR/IP address range, specify <i>CIDRIP</i>. For an overview of CIDR blocks, see the Wikipedia article on <a href="http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing">Classless Inter-Domain Routing</a>. </p> <p>You must also associate the security group with a cluster so that clients running on these IP addresses or the EC2 instance are authorized to connect to the cluster. For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Working with Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   EC2SecurityGroupName: string
  ##                       : The EC2 security group to be added the Amazon Redshift security group.
  ##   EC2SecurityGroupOwnerId: string
  ##                          : <p>The AWS account number of the owner of the security group specified by the <i>EC2SecurityGroupName</i> parameter. The AWS Access Key ID is not an acceptable value. </p> <p>Example: <code>111122223333</code> </p>
  ##   ClusterSecurityGroupName: string (required)
  ##                           : The name of the security group to which the ingress rule is added.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   CIDRIP: string
  ##         : The IP range to be added the Amazon Redshift security group.
  var query_611288 = newJObject()
  add(query_611288, "EC2SecurityGroupName", newJString(EC2SecurityGroupName))
  add(query_611288, "EC2SecurityGroupOwnerId", newJString(EC2SecurityGroupOwnerId))
  add(query_611288, "ClusterSecurityGroupName",
      newJString(ClusterSecurityGroupName))
  add(query_611288, "Action", newJString(Action))
  add(query_611288, "Version", newJString(Version))
  add(query_611288, "CIDRIP", newJString(CIDRIP))
  result = call_611287.call(nil, query_611288, nil, nil, nil)

var getAuthorizeClusterSecurityGroupIngress* = Call_GetAuthorizeClusterSecurityGroupIngress_611270(
    name: "getAuthorizeClusterSecurityGroupIngress", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=AuthorizeClusterSecurityGroupIngress",
    validator: validate_GetAuthorizeClusterSecurityGroupIngress_611271, base: "/",
    url: url_GetAuthorizeClusterSecurityGroupIngress_611272,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostAuthorizeSnapshotAccess_611327 = ref object of OpenApiRestCall_610642
proc url_PostAuthorizeSnapshotAccess_611329(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostAuthorizeSnapshotAccess_611328(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Authorizes the specified AWS customer account to restore the specified snapshot.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_611330 = query.getOrDefault("Action")
  valid_611330 = validateParameter(valid_611330, JString, required = true, default = newJString(
      "AuthorizeSnapshotAccess"))
  if valid_611330 != nil:
    section.add "Action", valid_611330
  var valid_611331 = query.getOrDefault("Version")
  valid_611331 = validateParameter(valid_611331, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_611331 != nil:
    section.add "Version", valid_611331
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_611332 = header.getOrDefault("X-Amz-Signature")
  valid_611332 = validateParameter(valid_611332, JString, required = false,
                                 default = nil)
  if valid_611332 != nil:
    section.add "X-Amz-Signature", valid_611332
  var valid_611333 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_611333 = validateParameter(valid_611333, JString, required = false,
                                 default = nil)
  if valid_611333 != nil:
    section.add "X-Amz-Content-Sha256", valid_611333
  var valid_611334 = header.getOrDefault("X-Amz-Date")
  valid_611334 = validateParameter(valid_611334, JString, required = false,
                                 default = nil)
  if valid_611334 != nil:
    section.add "X-Amz-Date", valid_611334
  var valid_611335 = header.getOrDefault("X-Amz-Credential")
  valid_611335 = validateParameter(valid_611335, JString, required = false,
                                 default = nil)
  if valid_611335 != nil:
    section.add "X-Amz-Credential", valid_611335
  var valid_611336 = header.getOrDefault("X-Amz-Security-Token")
  valid_611336 = validateParameter(valid_611336, JString, required = false,
                                 default = nil)
  if valid_611336 != nil:
    section.add "X-Amz-Security-Token", valid_611336
  var valid_611337 = header.getOrDefault("X-Amz-Algorithm")
  valid_611337 = validateParameter(valid_611337, JString, required = false,
                                 default = nil)
  if valid_611337 != nil:
    section.add "X-Amz-Algorithm", valid_611337
  var valid_611338 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_611338 = validateParameter(valid_611338, JString, required = false,
                                 default = nil)
  if valid_611338 != nil:
    section.add "X-Amz-SignedHeaders", valid_611338
  result.add "header", section
  ## parameters in `formData` object:
  ##   SnapshotIdentifier: JString (required)
  ##                     : The identifier of the snapshot the account is authorized to restore.
  ##   AccountWithRestoreAccess: JString (required)
  ##                           : <p>The identifier of the AWS customer account authorized to restore the specified snapshot.</p> <p>To share a snapshot with AWS support, specify amazon-redshift-support.</p>
  ##   SnapshotClusterIdentifier: JString
  ##                            : The identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `SnapshotIdentifier` field"
  var valid_611339 = formData.getOrDefault("SnapshotIdentifier")
  valid_611339 = validateParameter(valid_611339, JString, required = true,
                                 default = nil)
  if valid_611339 != nil:
    section.add "SnapshotIdentifier", valid_611339
  var valid_611340 = formData.getOrDefault("AccountWithRestoreAccess")
  valid_611340 = validateParameter(valid_611340, JString, required = true,
                                 default = nil)
  if valid_611340 != nil:
    section.add "AccountWithRestoreAccess", valid_611340
  var valid_611341 = formData.getOrDefault("SnapshotClusterIdentifier")
  valid_611341 = validateParameter(valid_611341, JString, required = false,
                                 default = nil)
  if valid_611341 != nil:
    section.add "SnapshotClusterIdentifier", valid_611341
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_611342: Call_PostAuthorizeSnapshotAccess_611327; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Authorizes the specified AWS customer account to restore the specified snapshot.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_611342.validator(path, query, header, formData, body)
  let scheme = call_611342.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_611342.url(scheme.get, call_611342.host, call_611342.base,
                         call_611342.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_611342, url, valid)

proc call*(call_611343: Call_PostAuthorizeSnapshotAccess_611327;
          SnapshotIdentifier: string; AccountWithRestoreAccess: string;
          Action: string = "AuthorizeSnapshotAccess";
          SnapshotClusterIdentifier: string = ""; Version: string = "2012-12-01"): Recallable =
  ## postAuthorizeSnapshotAccess
  ## <p>Authorizes the specified AWS customer account to restore the specified snapshot.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   SnapshotIdentifier: string (required)
  ##                     : The identifier of the snapshot the account is authorized to restore.
  ##   Action: string (required)
  ##   AccountWithRestoreAccess: string (required)
  ##                           : <p>The identifier of the AWS customer account authorized to restore the specified snapshot.</p> <p>To share a snapshot with AWS support, specify amazon-redshift-support.</p>
  ##   SnapshotClusterIdentifier: string
  ##                            : The identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.
  ##   Version: string (required)
  var query_611344 = newJObject()
  var formData_611345 = newJObject()
  add(formData_611345, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_611344, "Action", newJString(Action))
  add(formData_611345, "AccountWithRestoreAccess",
      newJString(AccountWithRestoreAccess))
  add(formData_611345, "SnapshotClusterIdentifier",
      newJString(SnapshotClusterIdentifier))
  add(query_611344, "Version", newJString(Version))
  result = call_611343.call(nil, query_611344, nil, formData_611345, nil)

var postAuthorizeSnapshotAccess* = Call_PostAuthorizeSnapshotAccess_611327(
    name: "postAuthorizeSnapshotAccess", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=AuthorizeSnapshotAccess",
    validator: validate_PostAuthorizeSnapshotAccess_611328, base: "/",
    url: url_PostAuthorizeSnapshotAccess_611329,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetAuthorizeSnapshotAccess_611309 = ref object of OpenApiRestCall_610642
proc url_GetAuthorizeSnapshotAccess_611311(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetAuthorizeSnapshotAccess_611310(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Authorizes the specified AWS customer account to restore the specified snapshot.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   SnapshotIdentifier: JString (required)
  ##                     : The identifier of the snapshot the account is authorized to restore.
  ##   SnapshotClusterIdentifier: JString
  ##                            : The identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.
  ##   Action: JString (required)
  ##   Version: JString (required)
  ##   AccountWithRestoreAccess: JString (required)
  ##                           : <p>The identifier of the AWS customer account authorized to restore the specified snapshot.</p> <p>To share a snapshot with AWS support, specify amazon-redshift-support.</p>
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `SnapshotIdentifier` field"
  var valid_611312 = query.getOrDefault("SnapshotIdentifier")
  valid_611312 = validateParameter(valid_611312, JString, required = true,
                                 default = nil)
  if valid_611312 != nil:
    section.add "SnapshotIdentifier", valid_611312
  var valid_611313 = query.getOrDefault("SnapshotClusterIdentifier")
  valid_611313 = validateParameter(valid_611313, JString, required = false,
                                 default = nil)
  if valid_611313 != nil:
    section.add "SnapshotClusterIdentifier", valid_611313
  var valid_611314 = query.getOrDefault("Action")
  valid_611314 = validateParameter(valid_611314, JString, required = true, default = newJString(
      "AuthorizeSnapshotAccess"))
  if valid_611314 != nil:
    section.add "Action", valid_611314
  var valid_611315 = query.getOrDefault("Version")
  valid_611315 = validateParameter(valid_611315, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_611315 != nil:
    section.add "Version", valid_611315
  var valid_611316 = query.getOrDefault("AccountWithRestoreAccess")
  valid_611316 = validateParameter(valid_611316, JString, required = true,
                                 default = nil)
  if valid_611316 != nil:
    section.add "AccountWithRestoreAccess", valid_611316
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_611317 = header.getOrDefault("X-Amz-Signature")
  valid_611317 = validateParameter(valid_611317, JString, required = false,
                                 default = nil)
  if valid_611317 != nil:
    section.add "X-Amz-Signature", valid_611317
  var valid_611318 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_611318 = validateParameter(valid_611318, JString, required = false,
                                 default = nil)
  if valid_611318 != nil:
    section.add "X-Amz-Content-Sha256", valid_611318
  var valid_611319 = header.getOrDefault("X-Amz-Date")
  valid_611319 = validateParameter(valid_611319, JString, required = false,
                                 default = nil)
  if valid_611319 != nil:
    section.add "X-Amz-Date", valid_611319
  var valid_611320 = header.getOrDefault("X-Amz-Credential")
  valid_611320 = validateParameter(valid_611320, JString, required = false,
                                 default = nil)
  if valid_611320 != nil:
    section.add "X-Amz-Credential", valid_611320
  var valid_611321 = header.getOrDefault("X-Amz-Security-Token")
  valid_611321 = validateParameter(valid_611321, JString, required = false,
                                 default = nil)
  if valid_611321 != nil:
    section.add "X-Amz-Security-Token", valid_611321
  var valid_611322 = header.getOrDefault("X-Amz-Algorithm")
  valid_611322 = validateParameter(valid_611322, JString, required = false,
                                 default = nil)
  if valid_611322 != nil:
    section.add "X-Amz-Algorithm", valid_611322
  var valid_611323 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_611323 = validateParameter(valid_611323, JString, required = false,
                                 default = nil)
  if valid_611323 != nil:
    section.add "X-Amz-SignedHeaders", valid_611323
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_611324: Call_GetAuthorizeSnapshotAccess_611309; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Authorizes the specified AWS customer account to restore the specified snapshot.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_611324.validator(path, query, header, formData, body)
  let scheme = call_611324.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_611324.url(scheme.get, call_611324.host, call_611324.base,
                         call_611324.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_611324, url, valid)

proc call*(call_611325: Call_GetAuthorizeSnapshotAccess_611309;
          SnapshotIdentifier: string; AccountWithRestoreAccess: string;
          SnapshotClusterIdentifier: string = "";
          Action: string = "AuthorizeSnapshotAccess"; Version: string = "2012-12-01"): Recallable =
  ## getAuthorizeSnapshotAccess
  ## <p>Authorizes the specified AWS customer account to restore the specified snapshot.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   SnapshotIdentifier: string (required)
  ##                     : The identifier of the snapshot the account is authorized to restore.
  ##   SnapshotClusterIdentifier: string
  ##                            : The identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   AccountWithRestoreAccess: string (required)
  ##                           : <p>The identifier of the AWS customer account authorized to restore the specified snapshot.</p> <p>To share a snapshot with AWS support, specify amazon-redshift-support.</p>
  var query_611326 = newJObject()
  add(query_611326, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_611326, "SnapshotClusterIdentifier",
      newJString(SnapshotClusterIdentifier))
  add(query_611326, "Action", newJString(Action))
  add(query_611326, "Version", newJString(Version))
  add(query_611326, "AccountWithRestoreAccess",
      newJString(AccountWithRestoreAccess))
  result = call_611325.call(nil, query_611326, nil, nil, nil)

var getAuthorizeSnapshotAccess* = Call_GetAuthorizeSnapshotAccess_611309(
    name: "getAuthorizeSnapshotAccess", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=AuthorizeSnapshotAccess",
    validator: validate_GetAuthorizeSnapshotAccess_611310, base: "/",
    url: url_GetAuthorizeSnapshotAccess_611311,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostBatchDeleteClusterSnapshots_611362 = ref object of OpenApiRestCall_610642
proc url_PostBatchDeleteClusterSnapshots_611364(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostBatchDeleteClusterSnapshots_611363(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a set of cluster snapshots.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_611365 = query.getOrDefault("Action")
  valid_611365 = validateParameter(valid_611365, JString, required = true, default = newJString(
      "BatchDeleteClusterSnapshots"))
  if valid_611365 != nil:
    section.add "Action", valid_611365
  var valid_611366 = query.getOrDefault("Version")
  valid_611366 = validateParameter(valid_611366, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_611366 != nil:
    section.add "Version", valid_611366
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_611367 = header.getOrDefault("X-Amz-Signature")
  valid_611367 = validateParameter(valid_611367, JString, required = false,
                                 default = nil)
  if valid_611367 != nil:
    section.add "X-Amz-Signature", valid_611367
  var valid_611368 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_611368 = validateParameter(valid_611368, JString, required = false,
                                 default = nil)
  if valid_611368 != nil:
    section.add "X-Amz-Content-Sha256", valid_611368
  var valid_611369 = header.getOrDefault("X-Amz-Date")
  valid_611369 = validateParameter(valid_611369, JString, required = false,
                                 default = nil)
  if valid_611369 != nil:
    section.add "X-Amz-Date", valid_611369
  var valid_611370 = header.getOrDefault("X-Amz-Credential")
  valid_611370 = validateParameter(valid_611370, JString, required = false,
                                 default = nil)
  if valid_611370 != nil:
    section.add "X-Amz-Credential", valid_611370
  var valid_611371 = header.getOrDefault("X-Amz-Security-Token")
  valid_611371 = validateParameter(valid_611371, JString, required = false,
                                 default = nil)
  if valid_611371 != nil:
    section.add "X-Amz-Security-Token", valid_611371
  var valid_611372 = header.getOrDefault("X-Amz-Algorithm")
  valid_611372 = validateParameter(valid_611372, JString, required = false,
                                 default = nil)
  if valid_611372 != nil:
    section.add "X-Amz-Algorithm", valid_611372
  var valid_611373 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_611373 = validateParameter(valid_611373, JString, required = false,
                                 default = nil)
  if valid_611373 != nil:
    section.add "X-Amz-SignedHeaders", valid_611373
  result.add "header", section
  ## parameters in `formData` object:
  ##   Identifiers: JArray (required)
  ##              : A list of identifiers for the snapshots that you want to delete.
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `Identifiers` field"
  var valid_611374 = formData.getOrDefault("Identifiers")
  valid_611374 = validateParameter(valid_611374, JArray, required = true, default = nil)
  if valid_611374 != nil:
    section.add "Identifiers", valid_611374
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_611375: Call_PostBatchDeleteClusterSnapshots_611362;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Deletes a set of cluster snapshots.
  ## 
  let valid = call_611375.validator(path, query, header, formData, body)
  let scheme = call_611375.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_611375.url(scheme.get, call_611375.host, call_611375.base,
                         call_611375.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_611375, url, valid)

proc call*(call_611376: Call_PostBatchDeleteClusterSnapshots_611362;
          Identifiers: JsonNode; Action: string = "BatchDeleteClusterSnapshots";
          Version: string = "2012-12-01"): Recallable =
  ## postBatchDeleteClusterSnapshots
  ## Deletes a set of cluster snapshots.
  ##   Identifiers: JArray (required)
  ##              : A list of identifiers for the snapshots that you want to delete.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_611377 = newJObject()
  var formData_611378 = newJObject()
  if Identifiers != nil:
    formData_611378.add "Identifiers", Identifiers
  add(query_611377, "Action", newJString(Action))
  add(query_611377, "Version", newJString(Version))
  result = call_611376.call(nil, query_611377, nil, formData_611378, nil)

var postBatchDeleteClusterSnapshots* = Call_PostBatchDeleteClusterSnapshots_611362(
    name: "postBatchDeleteClusterSnapshots", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=BatchDeleteClusterSnapshots",
    validator: validate_PostBatchDeleteClusterSnapshots_611363, base: "/",
    url: url_PostBatchDeleteClusterSnapshots_611364,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetBatchDeleteClusterSnapshots_611346 = ref object of OpenApiRestCall_610642
proc url_GetBatchDeleteClusterSnapshots_611348(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetBatchDeleteClusterSnapshots_611347(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a set of cluster snapshots.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Identifiers: JArray (required)
  ##              : A list of identifiers for the snapshots that you want to delete.
  ##   Version: JString (required)
  section = newJObject()
  var valid_611349 = query.getOrDefault("Action")
  valid_611349 = validateParameter(valid_611349, JString, required = true, default = newJString(
      "BatchDeleteClusterSnapshots"))
  if valid_611349 != nil:
    section.add "Action", valid_611349
  var valid_611350 = query.getOrDefault("Identifiers")
  valid_611350 = validateParameter(valid_611350, JArray, required = true, default = nil)
  if valid_611350 != nil:
    section.add "Identifiers", valid_611350
  var valid_611351 = query.getOrDefault("Version")
  valid_611351 = validateParameter(valid_611351, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_611351 != nil:
    section.add "Version", valid_611351
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_611352 = header.getOrDefault("X-Amz-Signature")
  valid_611352 = validateParameter(valid_611352, JString, required = false,
                                 default = nil)
  if valid_611352 != nil:
    section.add "X-Amz-Signature", valid_611352
  var valid_611353 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_611353 = validateParameter(valid_611353, JString, required = false,
                                 default = nil)
  if valid_611353 != nil:
    section.add "X-Amz-Content-Sha256", valid_611353
  var valid_611354 = header.getOrDefault("X-Amz-Date")
  valid_611354 = validateParameter(valid_611354, JString, required = false,
                                 default = nil)
  if valid_611354 != nil:
    section.add "X-Amz-Date", valid_611354
  var valid_611355 = header.getOrDefault("X-Amz-Credential")
  valid_611355 = validateParameter(valid_611355, JString, required = false,
                                 default = nil)
  if valid_611355 != nil:
    section.add "X-Amz-Credential", valid_611355
  var valid_611356 = header.getOrDefault("X-Amz-Security-Token")
  valid_611356 = validateParameter(valid_611356, JString, required = false,
                                 default = nil)
  if valid_611356 != nil:
    section.add "X-Amz-Security-Token", valid_611356
  var valid_611357 = header.getOrDefault("X-Amz-Algorithm")
  valid_611357 = validateParameter(valid_611357, JString, required = false,
                                 default = nil)
  if valid_611357 != nil:
    section.add "X-Amz-Algorithm", valid_611357
  var valid_611358 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_611358 = validateParameter(valid_611358, JString, required = false,
                                 default = nil)
  if valid_611358 != nil:
    section.add "X-Amz-SignedHeaders", valid_611358
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_611359: Call_GetBatchDeleteClusterSnapshots_611346; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a set of cluster snapshots.
  ## 
  let valid = call_611359.validator(path, query, header, formData, body)
  let scheme = call_611359.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_611359.url(scheme.get, call_611359.host, call_611359.base,
                         call_611359.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_611359, url, valid)

proc call*(call_611360: Call_GetBatchDeleteClusterSnapshots_611346;
          Identifiers: JsonNode; Action: string = "BatchDeleteClusterSnapshots";
          Version: string = "2012-12-01"): Recallable =
  ## getBatchDeleteClusterSnapshots
  ## Deletes a set of cluster snapshots.
  ##   Action: string (required)
  ##   Identifiers: JArray (required)
  ##              : A list of identifiers for the snapshots that you want to delete.
  ##   Version: string (required)
  var query_611361 = newJObject()
  add(query_611361, "Action", newJString(Action))
  if Identifiers != nil:
    query_611361.add "Identifiers", Identifiers
  add(query_611361, "Version", newJString(Version))
  result = call_611360.call(nil, query_611361, nil, nil, nil)

var getBatchDeleteClusterSnapshots* = Call_GetBatchDeleteClusterSnapshots_611346(
    name: "getBatchDeleteClusterSnapshots", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=BatchDeleteClusterSnapshots",
    validator: validate_GetBatchDeleteClusterSnapshots_611347, base: "/",
    url: url_GetBatchDeleteClusterSnapshots_611348,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostBatchModifyClusterSnapshots_611397 = ref object of OpenApiRestCall_610642
proc url_PostBatchModifyClusterSnapshots_611399(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostBatchModifyClusterSnapshots_611398(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies the settings for a set of cluster snapshots.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_611400 = query.getOrDefault("Action")
  valid_611400 = validateParameter(valid_611400, JString, required = true, default = newJString(
      "BatchModifyClusterSnapshots"))
  if valid_611400 != nil:
    section.add "Action", valid_611400
  var valid_611401 = query.getOrDefault("Version")
  valid_611401 = validateParameter(valid_611401, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_611401 != nil:
    section.add "Version", valid_611401
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_611402 = header.getOrDefault("X-Amz-Signature")
  valid_611402 = validateParameter(valid_611402, JString, required = false,
                                 default = nil)
  if valid_611402 != nil:
    section.add "X-Amz-Signature", valid_611402
  var valid_611403 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_611403 = validateParameter(valid_611403, JString, required = false,
                                 default = nil)
  if valid_611403 != nil:
    section.add "X-Amz-Content-Sha256", valid_611403
  var valid_611404 = header.getOrDefault("X-Amz-Date")
  valid_611404 = validateParameter(valid_611404, JString, required = false,
                                 default = nil)
  if valid_611404 != nil:
    section.add "X-Amz-Date", valid_611404
  var valid_611405 = header.getOrDefault("X-Amz-Credential")
  valid_611405 = validateParameter(valid_611405, JString, required = false,
                                 default = nil)
  if valid_611405 != nil:
    section.add "X-Amz-Credential", valid_611405
  var valid_611406 = header.getOrDefault("X-Amz-Security-Token")
  valid_611406 = validateParameter(valid_611406, JString, required = false,
                                 default = nil)
  if valid_611406 != nil:
    section.add "X-Amz-Security-Token", valid_611406
  var valid_611407 = header.getOrDefault("X-Amz-Algorithm")
  valid_611407 = validateParameter(valid_611407, JString, required = false,
                                 default = nil)
  if valid_611407 != nil:
    section.add "X-Amz-Algorithm", valid_611407
  var valid_611408 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_611408 = validateParameter(valid_611408, JString, required = false,
                                 default = nil)
  if valid_611408 != nil:
    section.add "X-Amz-SignedHeaders", valid_611408
  result.add "header", section
  ## parameters in `formData` object:
  ##   Force: JBool
  ##        : A boolean value indicating whether to override an exception if the retention period has passed. 
  ##   SnapshotIdentifierList: JArray (required)
  ##                         : A list of snapshot identifiers you want to modify.
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The number of days that a manual snapshot is retained. If you specify the value -1, the manual snapshot is retained indefinitely.</p> <p>The number must be either -1 or an integer between 1 and 3,653.</p> <p>If you decrease the manual snapshot retention period from its current value, existing manual snapshots that fall outside of the new retention period will return an error. If you want to suppress the errors and delete the snapshots, use the force option. </p>
  section = newJObject()
  var valid_611409 = formData.getOrDefault("Force")
  valid_611409 = validateParameter(valid_611409, JBool, required = false, default = nil)
  if valid_611409 != nil:
    section.add "Force", valid_611409
  assert formData != nil, "formData argument is necessary due to required `SnapshotIdentifierList` field"
  var valid_611410 = formData.getOrDefault("SnapshotIdentifierList")
  valid_611410 = validateParameter(valid_611410, JArray, required = true, default = nil)
  if valid_611410 != nil:
    section.add "SnapshotIdentifierList", valid_611410
  var valid_611411 = formData.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_611411 = validateParameter(valid_611411, JInt, required = false, default = nil)
  if valid_611411 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_611411
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_611412: Call_PostBatchModifyClusterSnapshots_611397;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Modifies the settings for a set of cluster snapshots.
  ## 
  let valid = call_611412.validator(path, query, header, formData, body)
  let scheme = call_611412.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_611412.url(scheme.get, call_611412.host, call_611412.base,
                         call_611412.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_611412, url, valid)

proc call*(call_611413: Call_PostBatchModifyClusterSnapshots_611397;
          SnapshotIdentifierList: JsonNode; Force: bool = false;
          Action: string = "BatchModifyClusterSnapshots";
          Version: string = "2012-12-01"; ManualSnapshotRetentionPeriod: int = 0): Recallable =
  ## postBatchModifyClusterSnapshots
  ## Modifies the settings for a set of cluster snapshots.
  ##   Force: bool
  ##        : A boolean value indicating whether to override an exception if the retention period has passed. 
  ##   SnapshotIdentifierList: JArray (required)
  ##                         : A list of snapshot identifiers you want to modify.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The number of days that a manual snapshot is retained. If you specify the value -1, the manual snapshot is retained indefinitely.</p> <p>The number must be either -1 or an integer between 1 and 3,653.</p> <p>If you decrease the manual snapshot retention period from its current value, existing manual snapshots that fall outside of the new retention period will return an error. If you want to suppress the errors and delete the snapshots, use the force option. </p>
  var query_611414 = newJObject()
  var formData_611415 = newJObject()
  add(formData_611415, "Force", newJBool(Force))
  if SnapshotIdentifierList != nil:
    formData_611415.add "SnapshotIdentifierList", SnapshotIdentifierList
  add(query_611414, "Action", newJString(Action))
  add(query_611414, "Version", newJString(Version))
  add(formData_611415, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  result = call_611413.call(nil, query_611414, nil, formData_611415, nil)

var postBatchModifyClusterSnapshots* = Call_PostBatchModifyClusterSnapshots_611397(
    name: "postBatchModifyClusterSnapshots", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=BatchModifyClusterSnapshots",
    validator: validate_PostBatchModifyClusterSnapshots_611398, base: "/",
    url: url_PostBatchModifyClusterSnapshots_611399,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetBatchModifyClusterSnapshots_611379 = ref object of OpenApiRestCall_610642
proc url_GetBatchModifyClusterSnapshots_611381(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetBatchModifyClusterSnapshots_611380(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies the settings for a set of cluster snapshots.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The number of days that a manual snapshot is retained. If you specify the value -1, the manual snapshot is retained indefinitely.</p> <p>The number must be either -1 or an integer between 1 and 3,653.</p> <p>If you decrease the manual snapshot retention period from its current value, existing manual snapshots that fall outside of the new retention period will return an error. If you want to suppress the errors and delete the snapshots, use the force option. </p>
  ##   Force: JBool
  ##        : A boolean value indicating whether to override an exception if the retention period has passed. 
  ##   Action: JString (required)
  ##   SnapshotIdentifierList: JArray (required)
  ##                         : A list of snapshot identifiers you want to modify.
  ##   Version: JString (required)
  section = newJObject()
  var valid_611382 = query.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_611382 = validateParameter(valid_611382, JInt, required = false, default = nil)
  if valid_611382 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_611382
  var valid_611383 = query.getOrDefault("Force")
  valid_611383 = validateParameter(valid_611383, JBool, required = false, default = nil)
  if valid_611383 != nil:
    section.add "Force", valid_611383
  var valid_611384 = query.getOrDefault("Action")
  valid_611384 = validateParameter(valid_611384, JString, required = true, default = newJString(
      "BatchModifyClusterSnapshots"))
  if valid_611384 != nil:
    section.add "Action", valid_611384
  var valid_611385 = query.getOrDefault("SnapshotIdentifierList")
  valid_611385 = validateParameter(valid_611385, JArray, required = true, default = nil)
  if valid_611385 != nil:
    section.add "SnapshotIdentifierList", valid_611385
  var valid_611386 = query.getOrDefault("Version")
  valid_611386 = validateParameter(valid_611386, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_611386 != nil:
    section.add "Version", valid_611386
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_611387 = header.getOrDefault("X-Amz-Signature")
  valid_611387 = validateParameter(valid_611387, JString, required = false,
                                 default = nil)
  if valid_611387 != nil:
    section.add "X-Amz-Signature", valid_611387
  var valid_611388 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_611388 = validateParameter(valid_611388, JString, required = false,
                                 default = nil)
  if valid_611388 != nil:
    section.add "X-Amz-Content-Sha256", valid_611388
  var valid_611389 = header.getOrDefault("X-Amz-Date")
  valid_611389 = validateParameter(valid_611389, JString, required = false,
                                 default = nil)
  if valid_611389 != nil:
    section.add "X-Amz-Date", valid_611389
  var valid_611390 = header.getOrDefault("X-Amz-Credential")
  valid_611390 = validateParameter(valid_611390, JString, required = false,
                                 default = nil)
  if valid_611390 != nil:
    section.add "X-Amz-Credential", valid_611390
  var valid_611391 = header.getOrDefault("X-Amz-Security-Token")
  valid_611391 = validateParameter(valid_611391, JString, required = false,
                                 default = nil)
  if valid_611391 != nil:
    section.add "X-Amz-Security-Token", valid_611391
  var valid_611392 = header.getOrDefault("X-Amz-Algorithm")
  valid_611392 = validateParameter(valid_611392, JString, required = false,
                                 default = nil)
  if valid_611392 != nil:
    section.add "X-Amz-Algorithm", valid_611392
  var valid_611393 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_611393 = validateParameter(valid_611393, JString, required = false,
                                 default = nil)
  if valid_611393 != nil:
    section.add "X-Amz-SignedHeaders", valid_611393
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_611394: Call_GetBatchModifyClusterSnapshots_611379; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Modifies the settings for a set of cluster snapshots.
  ## 
  let valid = call_611394.validator(path, query, header, formData, body)
  let scheme = call_611394.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_611394.url(scheme.get, call_611394.host, call_611394.base,
                         call_611394.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_611394, url, valid)

proc call*(call_611395: Call_GetBatchModifyClusterSnapshots_611379;
          SnapshotIdentifierList: JsonNode;
          ManualSnapshotRetentionPeriod: int = 0; Force: bool = false;
          Action: string = "BatchModifyClusterSnapshots";
          Version: string = "2012-12-01"): Recallable =
  ## getBatchModifyClusterSnapshots
  ## Modifies the settings for a set of cluster snapshots.
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The number of days that a manual snapshot is retained. If you specify the value -1, the manual snapshot is retained indefinitely.</p> <p>The number must be either -1 or an integer between 1 and 3,653.</p> <p>If you decrease the manual snapshot retention period from its current value, existing manual snapshots that fall outside of the new retention period will return an error. If you want to suppress the errors and delete the snapshots, use the force option. </p>
  ##   Force: bool
  ##        : A boolean value indicating whether to override an exception if the retention period has passed. 
  ##   Action: string (required)
  ##   SnapshotIdentifierList: JArray (required)
  ##                         : A list of snapshot identifiers you want to modify.
  ##   Version: string (required)
  var query_611396 = newJObject()
  add(query_611396, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  add(query_611396, "Force", newJBool(Force))
  add(query_611396, "Action", newJString(Action))
  if SnapshotIdentifierList != nil:
    query_611396.add "SnapshotIdentifierList", SnapshotIdentifierList
  add(query_611396, "Version", newJString(Version))
  result = call_611395.call(nil, query_611396, nil, nil, nil)

var getBatchModifyClusterSnapshots* = Call_GetBatchModifyClusterSnapshots_611379(
    name: "getBatchModifyClusterSnapshots", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=BatchModifyClusterSnapshots",
    validator: validate_GetBatchModifyClusterSnapshots_611380, base: "/",
    url: url_GetBatchModifyClusterSnapshots_611381,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCancelResize_611432 = ref object of OpenApiRestCall_610642
proc url_PostCancelResize_611434(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostCancelResize_611433(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Cancels a resize operation for a cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_611435 = query.getOrDefault("Action")
  valid_611435 = validateParameter(valid_611435, JString, required = true,
                                 default = newJString("CancelResize"))
  if valid_611435 != nil:
    section.add "Action", valid_611435
  var valid_611436 = query.getOrDefault("Version")
  valid_611436 = validateParameter(valid_611436, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_611436 != nil:
    section.add "Version", valid_611436
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_611437 = header.getOrDefault("X-Amz-Signature")
  valid_611437 = validateParameter(valid_611437, JString, required = false,
                                 default = nil)
  if valid_611437 != nil:
    section.add "X-Amz-Signature", valid_611437
  var valid_611438 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_611438 = validateParameter(valid_611438, JString, required = false,
                                 default = nil)
  if valid_611438 != nil:
    section.add "X-Amz-Content-Sha256", valid_611438
  var valid_611439 = header.getOrDefault("X-Amz-Date")
  valid_611439 = validateParameter(valid_611439, JString, required = false,
                                 default = nil)
  if valid_611439 != nil:
    section.add "X-Amz-Date", valid_611439
  var valid_611440 = header.getOrDefault("X-Amz-Credential")
  valid_611440 = validateParameter(valid_611440, JString, required = false,
                                 default = nil)
  if valid_611440 != nil:
    section.add "X-Amz-Credential", valid_611440
  var valid_611441 = header.getOrDefault("X-Amz-Security-Token")
  valid_611441 = validateParameter(valid_611441, JString, required = false,
                                 default = nil)
  if valid_611441 != nil:
    section.add "X-Amz-Security-Token", valid_611441
  var valid_611442 = header.getOrDefault("X-Amz-Algorithm")
  valid_611442 = validateParameter(valid_611442, JString, required = false,
                                 default = nil)
  if valid_611442 != nil:
    section.add "X-Amz-Algorithm", valid_611442
  var valid_611443 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_611443 = validateParameter(valid_611443, JString, required = false,
                                 default = nil)
  if valid_611443 != nil:
    section.add "X-Amz-SignedHeaders", valid_611443
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : The unique identifier for the cluster that you want to cancel a resize operation for.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_611444 = formData.getOrDefault("ClusterIdentifier")
  valid_611444 = validateParameter(valid_611444, JString, required = true,
                                 default = nil)
  if valid_611444 != nil:
    section.add "ClusterIdentifier", valid_611444
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_611445: Call_PostCancelResize_611432; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Cancels a resize operation for a cluster.
  ## 
  let valid = call_611445.validator(path, query, header, formData, body)
  let scheme = call_611445.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_611445.url(scheme.get, call_611445.host, call_611445.base,
                         call_611445.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_611445, url, valid)

proc call*(call_611446: Call_PostCancelResize_611432; ClusterIdentifier: string;
          Action: string = "CancelResize"; Version: string = "2012-12-01"): Recallable =
  ## postCancelResize
  ## Cancels a resize operation for a cluster.
  ##   ClusterIdentifier: string (required)
  ##                    : The unique identifier for the cluster that you want to cancel a resize operation for.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_611447 = newJObject()
  var formData_611448 = newJObject()
  add(formData_611448, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_611447, "Action", newJString(Action))
  add(query_611447, "Version", newJString(Version))
  result = call_611446.call(nil, query_611447, nil, formData_611448, nil)

var postCancelResize* = Call_PostCancelResize_611432(name: "postCancelResize",
    meth: HttpMethod.HttpPost, host: "redshift.amazonaws.com",
    route: "/#Action=CancelResize", validator: validate_PostCancelResize_611433,
    base: "/", url: url_PostCancelResize_611434,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCancelResize_611416 = ref object of OpenApiRestCall_610642
proc url_GetCancelResize_611418(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetCancelResize_611417(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Cancels a resize operation for a cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : The unique identifier for the cluster that you want to cancel a resize operation for.
  ##   Version: JString (required)
  section = newJObject()
  var valid_611419 = query.getOrDefault("Action")
  valid_611419 = validateParameter(valid_611419, JString, required = true,
                                 default = newJString("CancelResize"))
  if valid_611419 != nil:
    section.add "Action", valid_611419
  var valid_611420 = query.getOrDefault("ClusterIdentifier")
  valid_611420 = validateParameter(valid_611420, JString, required = true,
                                 default = nil)
  if valid_611420 != nil:
    section.add "ClusterIdentifier", valid_611420
  var valid_611421 = query.getOrDefault("Version")
  valid_611421 = validateParameter(valid_611421, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_611421 != nil:
    section.add "Version", valid_611421
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_611422 = header.getOrDefault("X-Amz-Signature")
  valid_611422 = validateParameter(valid_611422, JString, required = false,
                                 default = nil)
  if valid_611422 != nil:
    section.add "X-Amz-Signature", valid_611422
  var valid_611423 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_611423 = validateParameter(valid_611423, JString, required = false,
                                 default = nil)
  if valid_611423 != nil:
    section.add "X-Amz-Content-Sha256", valid_611423
  var valid_611424 = header.getOrDefault("X-Amz-Date")
  valid_611424 = validateParameter(valid_611424, JString, required = false,
                                 default = nil)
  if valid_611424 != nil:
    section.add "X-Amz-Date", valid_611424
  var valid_611425 = header.getOrDefault("X-Amz-Credential")
  valid_611425 = validateParameter(valid_611425, JString, required = false,
                                 default = nil)
  if valid_611425 != nil:
    section.add "X-Amz-Credential", valid_611425
  var valid_611426 = header.getOrDefault("X-Amz-Security-Token")
  valid_611426 = validateParameter(valid_611426, JString, required = false,
                                 default = nil)
  if valid_611426 != nil:
    section.add "X-Amz-Security-Token", valid_611426
  var valid_611427 = header.getOrDefault("X-Amz-Algorithm")
  valid_611427 = validateParameter(valid_611427, JString, required = false,
                                 default = nil)
  if valid_611427 != nil:
    section.add "X-Amz-Algorithm", valid_611427
  var valid_611428 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_611428 = validateParameter(valid_611428, JString, required = false,
                                 default = nil)
  if valid_611428 != nil:
    section.add "X-Amz-SignedHeaders", valid_611428
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_611429: Call_GetCancelResize_611416; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Cancels a resize operation for a cluster.
  ## 
  let valid = call_611429.validator(path, query, header, formData, body)
  let scheme = call_611429.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_611429.url(scheme.get, call_611429.host, call_611429.base,
                         call_611429.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_611429, url, valid)

proc call*(call_611430: Call_GetCancelResize_611416; ClusterIdentifier: string;
          Action: string = "CancelResize"; Version: string = "2012-12-01"): Recallable =
  ## getCancelResize
  ## Cancels a resize operation for a cluster.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : The unique identifier for the cluster that you want to cancel a resize operation for.
  ##   Version: string (required)
  var query_611431 = newJObject()
  add(query_611431, "Action", newJString(Action))
  add(query_611431, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_611431, "Version", newJString(Version))
  result = call_611430.call(nil, query_611431, nil, nil, nil)

var getCancelResize* = Call_GetCancelResize_611416(name: "getCancelResize",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=CancelResize", validator: validate_GetCancelResize_611417,
    base: "/", url: url_GetCancelResize_611418, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCopyClusterSnapshot_611468 = ref object of OpenApiRestCall_610642
proc url_PostCopyClusterSnapshot_611470(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostCopyClusterSnapshot_611469(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Copies the specified automated cluster snapshot to a new manual cluster snapshot. The source must be an automated snapshot and it must be in the available state.</p> <p>When you delete a cluster, Amazon Redshift deletes any automated snapshots of the cluster. Also, when the retention period of the snapshot expires, Amazon Redshift automatically deletes it. If you want to keep an automated snapshot for a longer period, you can make a manual copy of the snapshot. Manual snapshots are retained until you delete them.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_611471 = query.getOrDefault("Action")
  valid_611471 = validateParameter(valid_611471, JString, required = true,
                                 default = newJString("CopyClusterSnapshot"))
  if valid_611471 != nil:
    section.add "Action", valid_611471
  var valid_611472 = query.getOrDefault("Version")
  valid_611472 = validateParameter(valid_611472, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_611472 != nil:
    section.add "Version", valid_611472
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_611473 = header.getOrDefault("X-Amz-Signature")
  valid_611473 = validateParameter(valid_611473, JString, required = false,
                                 default = nil)
  if valid_611473 != nil:
    section.add "X-Amz-Signature", valid_611473
  var valid_611474 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_611474 = validateParameter(valid_611474, JString, required = false,
                                 default = nil)
  if valid_611474 != nil:
    section.add "X-Amz-Content-Sha256", valid_611474
  var valid_611475 = header.getOrDefault("X-Amz-Date")
  valid_611475 = validateParameter(valid_611475, JString, required = false,
                                 default = nil)
  if valid_611475 != nil:
    section.add "X-Amz-Date", valid_611475
  var valid_611476 = header.getOrDefault("X-Amz-Credential")
  valid_611476 = validateParameter(valid_611476, JString, required = false,
                                 default = nil)
  if valid_611476 != nil:
    section.add "X-Amz-Credential", valid_611476
  var valid_611477 = header.getOrDefault("X-Amz-Security-Token")
  valid_611477 = validateParameter(valid_611477, JString, required = false,
                                 default = nil)
  if valid_611477 != nil:
    section.add "X-Amz-Security-Token", valid_611477
  var valid_611478 = header.getOrDefault("X-Amz-Algorithm")
  valid_611478 = validateParameter(valid_611478, JString, required = false,
                                 default = nil)
  if valid_611478 != nil:
    section.add "X-Amz-Algorithm", valid_611478
  var valid_611479 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_611479 = validateParameter(valid_611479, JString, required = false,
                                 default = nil)
  if valid_611479 != nil:
    section.add "X-Amz-SignedHeaders", valid_611479
  result.add "header", section
  ## parameters in `formData` object:
  ##   SourceSnapshotIdentifier: JString (required)
  ##                           : <p>The identifier for the source snapshot.</p> <p>Constraints:</p> <ul> <li> <p>Must be the identifier for a valid automated snapshot whose state is <code>available</code>.</p> </li> </ul>
  ##   SourceSnapshotClusterIdentifier: JString
  ##                                  : <p>The identifier of the cluster the source snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.</p> <p>Constraints:</p> <ul> <li> <p>Must be the identifier for a valid cluster.</p> </li> </ul>
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. </p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  ##   TargetSnapshotIdentifier: JString (required)
  ##                           : <p>The identifier given to the new manual snapshot.</p> <p>Constraints:</p> <ul> <li> <p>Cannot be null, empty, or blank.</p> </li> <li> <p>Must contain from 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for the AWS account that is making the request.</p> </li> </ul>
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `SourceSnapshotIdentifier` field"
  var valid_611480 = formData.getOrDefault("SourceSnapshotIdentifier")
  valid_611480 = validateParameter(valid_611480, JString, required = true,
                                 default = nil)
  if valid_611480 != nil:
    section.add "SourceSnapshotIdentifier", valid_611480
  var valid_611481 = formData.getOrDefault("SourceSnapshotClusterIdentifier")
  valid_611481 = validateParameter(valid_611481, JString, required = false,
                                 default = nil)
  if valid_611481 != nil:
    section.add "SourceSnapshotClusterIdentifier", valid_611481
  var valid_611482 = formData.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_611482 = validateParameter(valid_611482, JInt, required = false, default = nil)
  if valid_611482 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_611482
  var valid_611483 = formData.getOrDefault("TargetSnapshotIdentifier")
  valid_611483 = validateParameter(valid_611483, JString, required = true,
                                 default = nil)
  if valid_611483 != nil:
    section.add "TargetSnapshotIdentifier", valid_611483
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_611484: Call_PostCopyClusterSnapshot_611468; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Copies the specified automated cluster snapshot to a new manual cluster snapshot. The source must be an automated snapshot and it must be in the available state.</p> <p>When you delete a cluster, Amazon Redshift deletes any automated snapshots of the cluster. Also, when the retention period of the snapshot expires, Amazon Redshift automatically deletes it. If you want to keep an automated snapshot for a longer period, you can make a manual copy of the snapshot. Manual snapshots are retained until you delete them.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_611484.validator(path, query, header, formData, body)
  let scheme = call_611484.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_611484.url(scheme.get, call_611484.host, call_611484.base,
                         call_611484.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_611484, url, valid)

proc call*(call_611485: Call_PostCopyClusterSnapshot_611468;
          SourceSnapshotIdentifier: string; TargetSnapshotIdentifier: string;
          SourceSnapshotClusterIdentifier: string = "";
          Action: string = "CopyClusterSnapshot"; Version: string = "2012-12-01";
          ManualSnapshotRetentionPeriod: int = 0): Recallable =
  ## postCopyClusterSnapshot
  ## <p>Copies the specified automated cluster snapshot to a new manual cluster snapshot. The source must be an automated snapshot and it must be in the available state.</p> <p>When you delete a cluster, Amazon Redshift deletes any automated snapshots of the cluster. Also, when the retention period of the snapshot expires, Amazon Redshift automatically deletes it. If you want to keep an automated snapshot for a longer period, you can make a manual copy of the snapshot. Manual snapshots are retained until you delete them.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   SourceSnapshotIdentifier: string (required)
  ##                           : <p>The identifier for the source snapshot.</p> <p>Constraints:</p> <ul> <li> <p>Must be the identifier for a valid automated snapshot whose state is <code>available</code>.</p> </li> </ul>
  ##   SourceSnapshotClusterIdentifier: string
  ##                                  : <p>The identifier of the cluster the source snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.</p> <p>Constraints:</p> <ul> <li> <p>Must be the identifier for a valid cluster.</p> </li> </ul>
  ##   Action: string (required)
  ##   Version: string (required)
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. </p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  ##   TargetSnapshotIdentifier: string (required)
  ##                           : <p>The identifier given to the new manual snapshot.</p> <p>Constraints:</p> <ul> <li> <p>Cannot be null, empty, or blank.</p> </li> <li> <p>Must contain from 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for the AWS account that is making the request.</p> </li> </ul>
  var query_611486 = newJObject()
  var formData_611487 = newJObject()
  add(formData_611487, "SourceSnapshotIdentifier",
      newJString(SourceSnapshotIdentifier))
  add(formData_611487, "SourceSnapshotClusterIdentifier",
      newJString(SourceSnapshotClusterIdentifier))
  add(query_611486, "Action", newJString(Action))
  add(query_611486, "Version", newJString(Version))
  add(formData_611487, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  add(formData_611487, "TargetSnapshotIdentifier",
      newJString(TargetSnapshotIdentifier))
  result = call_611485.call(nil, query_611486, nil, formData_611487, nil)

var postCopyClusterSnapshot* = Call_PostCopyClusterSnapshot_611468(
    name: "postCopyClusterSnapshot", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=CopyClusterSnapshot",
    validator: validate_PostCopyClusterSnapshot_611469, base: "/",
    url: url_PostCopyClusterSnapshot_611470, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCopyClusterSnapshot_611449 = ref object of OpenApiRestCall_610642
proc url_GetCopyClusterSnapshot_611451(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetCopyClusterSnapshot_611450(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Copies the specified automated cluster snapshot to a new manual cluster snapshot. The source must be an automated snapshot and it must be in the available state.</p> <p>When you delete a cluster, Amazon Redshift deletes any automated snapshots of the cluster. Also, when the retention period of the snapshot expires, Amazon Redshift automatically deletes it. If you want to keep an automated snapshot for a longer period, you can make a manual copy of the snapshot. Manual snapshots are retained until you delete them.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. </p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  ##   SourceSnapshotIdentifier: JString (required)
  ##                           : <p>The identifier for the source snapshot.</p> <p>Constraints:</p> <ul> <li> <p>Must be the identifier for a valid automated snapshot whose state is <code>available</code>.</p> </li> </ul>
  ##   TargetSnapshotIdentifier: JString (required)
  ##                           : <p>The identifier given to the new manual snapshot.</p> <p>Constraints:</p> <ul> <li> <p>Cannot be null, empty, or blank.</p> </li> <li> <p>Must contain from 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for the AWS account that is making the request.</p> </li> </ul>
  ##   Action: JString (required)
  ##   Version: JString (required)
  ##   SourceSnapshotClusterIdentifier: JString
  ##                                  : <p>The identifier of the cluster the source snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.</p> <p>Constraints:</p> <ul> <li> <p>Must be the identifier for a valid cluster.</p> </li> </ul>
  section = newJObject()
  var valid_611452 = query.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_611452 = validateParameter(valid_611452, JInt, required = false, default = nil)
  if valid_611452 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_611452
  assert query != nil, "query argument is necessary due to required `SourceSnapshotIdentifier` field"
  var valid_611453 = query.getOrDefault("SourceSnapshotIdentifier")
  valid_611453 = validateParameter(valid_611453, JString, required = true,
                                 default = nil)
  if valid_611453 != nil:
    section.add "SourceSnapshotIdentifier", valid_611453
  var valid_611454 = query.getOrDefault("TargetSnapshotIdentifier")
  valid_611454 = validateParameter(valid_611454, JString, required = true,
                                 default = nil)
  if valid_611454 != nil:
    section.add "TargetSnapshotIdentifier", valid_611454
  var valid_611455 = query.getOrDefault("Action")
  valid_611455 = validateParameter(valid_611455, JString, required = true,
                                 default = newJString("CopyClusterSnapshot"))
  if valid_611455 != nil:
    section.add "Action", valid_611455
  var valid_611456 = query.getOrDefault("Version")
  valid_611456 = validateParameter(valid_611456, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_611456 != nil:
    section.add "Version", valid_611456
  var valid_611457 = query.getOrDefault("SourceSnapshotClusterIdentifier")
  valid_611457 = validateParameter(valid_611457, JString, required = false,
                                 default = nil)
  if valid_611457 != nil:
    section.add "SourceSnapshotClusterIdentifier", valid_611457
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_611458 = header.getOrDefault("X-Amz-Signature")
  valid_611458 = validateParameter(valid_611458, JString, required = false,
                                 default = nil)
  if valid_611458 != nil:
    section.add "X-Amz-Signature", valid_611458
  var valid_611459 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_611459 = validateParameter(valid_611459, JString, required = false,
                                 default = nil)
  if valid_611459 != nil:
    section.add "X-Amz-Content-Sha256", valid_611459
  var valid_611460 = header.getOrDefault("X-Amz-Date")
  valid_611460 = validateParameter(valid_611460, JString, required = false,
                                 default = nil)
  if valid_611460 != nil:
    section.add "X-Amz-Date", valid_611460
  var valid_611461 = header.getOrDefault("X-Amz-Credential")
  valid_611461 = validateParameter(valid_611461, JString, required = false,
                                 default = nil)
  if valid_611461 != nil:
    section.add "X-Amz-Credential", valid_611461
  var valid_611462 = header.getOrDefault("X-Amz-Security-Token")
  valid_611462 = validateParameter(valid_611462, JString, required = false,
                                 default = nil)
  if valid_611462 != nil:
    section.add "X-Amz-Security-Token", valid_611462
  var valid_611463 = header.getOrDefault("X-Amz-Algorithm")
  valid_611463 = validateParameter(valid_611463, JString, required = false,
                                 default = nil)
  if valid_611463 != nil:
    section.add "X-Amz-Algorithm", valid_611463
  var valid_611464 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_611464 = validateParameter(valid_611464, JString, required = false,
                                 default = nil)
  if valid_611464 != nil:
    section.add "X-Amz-SignedHeaders", valid_611464
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_611465: Call_GetCopyClusterSnapshot_611449; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Copies the specified automated cluster snapshot to a new manual cluster snapshot. The source must be an automated snapshot and it must be in the available state.</p> <p>When you delete a cluster, Amazon Redshift deletes any automated snapshots of the cluster. Also, when the retention period of the snapshot expires, Amazon Redshift automatically deletes it. If you want to keep an automated snapshot for a longer period, you can make a manual copy of the snapshot. Manual snapshots are retained until you delete them.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_611465.validator(path, query, header, formData, body)
  let scheme = call_611465.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_611465.url(scheme.get, call_611465.host, call_611465.base,
                         call_611465.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_611465, url, valid)

proc call*(call_611466: Call_GetCopyClusterSnapshot_611449;
          SourceSnapshotIdentifier: string; TargetSnapshotIdentifier: string;
          ManualSnapshotRetentionPeriod: int = 0;
          Action: string = "CopyClusterSnapshot"; Version: string = "2012-12-01";
          SourceSnapshotClusterIdentifier: string = ""): Recallable =
  ## getCopyClusterSnapshot
  ## <p>Copies the specified automated cluster snapshot to a new manual cluster snapshot. The source must be an automated snapshot and it must be in the available state.</p> <p>When you delete a cluster, Amazon Redshift deletes any automated snapshots of the cluster. Also, when the retention period of the snapshot expires, Amazon Redshift automatically deletes it. If you want to keep an automated snapshot for a longer period, you can make a manual copy of the snapshot. Manual snapshots are retained until you delete them.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. </p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  ##   SourceSnapshotIdentifier: string (required)
  ##                           : <p>The identifier for the source snapshot.</p> <p>Constraints:</p> <ul> <li> <p>Must be the identifier for a valid automated snapshot whose state is <code>available</code>.</p> </li> </ul>
  ##   TargetSnapshotIdentifier: string (required)
  ##                           : <p>The identifier given to the new manual snapshot.</p> <p>Constraints:</p> <ul> <li> <p>Cannot be null, empty, or blank.</p> </li> <li> <p>Must contain from 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for the AWS account that is making the request.</p> </li> </ul>
  ##   Action: string (required)
  ##   Version: string (required)
  ##   SourceSnapshotClusterIdentifier: string
  ##                                  : <p>The identifier of the cluster the source snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.</p> <p>Constraints:</p> <ul> <li> <p>Must be the identifier for a valid cluster.</p> </li> </ul>
  var query_611467 = newJObject()
  add(query_611467, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  add(query_611467, "SourceSnapshotIdentifier",
      newJString(SourceSnapshotIdentifier))
  add(query_611467, "TargetSnapshotIdentifier",
      newJString(TargetSnapshotIdentifier))
  add(query_611467, "Action", newJString(Action))
  add(query_611467, "Version", newJString(Version))
  add(query_611467, "SourceSnapshotClusterIdentifier",
      newJString(SourceSnapshotClusterIdentifier))
  result = call_611466.call(nil, query_611467, nil, nil, nil)

var getCopyClusterSnapshot* = Call_GetCopyClusterSnapshot_611449(
    name: "getCopyClusterSnapshot", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=CopyClusterSnapshot",
    validator: validate_GetCopyClusterSnapshot_611450, base: "/",
    url: url_GetCopyClusterSnapshot_611451, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCreateCluster_611533 = ref object of OpenApiRestCall_610642
proc url_PostCreateCluster_611535(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostCreateCluster_611534(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## <p>Creates a new cluster with the specified parameters.</p> <p>To create a cluster in Virtual Private Cloud (VPC), you must provide a cluster subnet group name. The cluster subnet group identifies the subnets of your VPC that Amazon Redshift uses when creating the cluster. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_611536 = query.getOrDefault("Action")
  valid_611536 = validateParameter(valid_611536, JString, required = true,
                                 default = newJString("CreateCluster"))
  if valid_611536 != nil:
    section.add "Action", valid_611536
  var valid_611537 = query.getOrDefault("Version")
  valid_611537 = validateParameter(valid_611537, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_611537 != nil:
    section.add "Version", valid_611537
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_611538 = header.getOrDefault("X-Amz-Signature")
  valid_611538 = validateParameter(valid_611538, JString, required = false,
                                 default = nil)
  if valid_611538 != nil:
    section.add "X-Amz-Signature", valid_611538
  var valid_611539 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_611539 = validateParameter(valid_611539, JString, required = false,
                                 default = nil)
  if valid_611539 != nil:
    section.add "X-Amz-Content-Sha256", valid_611539
  var valid_611540 = header.getOrDefault("X-Amz-Date")
  valid_611540 = validateParameter(valid_611540, JString, required = false,
                                 default = nil)
  if valid_611540 != nil:
    section.add "X-Amz-Date", valid_611540
  var valid_611541 = header.getOrDefault("X-Amz-Credential")
  valid_611541 = validateParameter(valid_611541, JString, required = false,
                                 default = nil)
  if valid_611541 != nil:
    section.add "X-Amz-Credential", valid_611541
  var valid_611542 = header.getOrDefault("X-Amz-Security-Token")
  valid_611542 = validateParameter(valid_611542, JString, required = false,
                                 default = nil)
  if valid_611542 != nil:
    section.add "X-Amz-Security-Token", valid_611542
  var valid_611543 = header.getOrDefault("X-Amz-Algorithm")
  valid_611543 = validateParameter(valid_611543, JString, required = false,
                                 default = nil)
  if valid_611543 != nil:
    section.add "X-Amz-Algorithm", valid_611543
  var valid_611544 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_611544 = validateParameter(valid_611544, JString, required = false,
                                 default = nil)
  if valid_611544 != nil:
    section.add "X-Amz-SignedHeaders", valid_611544
  result.add "header", section
  ## parameters in `formData` object:
  ##   PreferredMaintenanceWindow: JString
  ##                             : <p>The weekly time range (in UTC) during which automated cluster maintenance can occur.</p> <p> Format: <code>ddd:hh24:mi-ddd:hh24:mi</code> </p> <p> Default: A 30-minute window selected at random from an 8-hour block of time per region, occurring on a random day of the week. For more information about the time blocks for each region, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-maintenance-windows">Maintenance Windows</a> in Amazon Redshift Cluster Management Guide.</p> <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p> <p>Constraints: Minimum 30-minute window.</p>
  ##   Port: JInt
  ##       : <p>The port number on which the cluster accepts incoming connections.</p> <p>The cluster is accessible only via the JDBC and ODBC connection strings. Part of the connection string requires the port on which the cluster will listen for incoming connections.</p> <p>Default: <code>5439</code> </p> <p>Valid Values: <code>1150-65535</code> </p>
  ##   NodeType: JString (required)
  ##           : <p>The node type to be provisioned for the cluster. For information about node types, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#how-many-nodes"> Working with Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p> <p>Valid Values: <code>ds2.xlarge</code> | <code>ds2.8xlarge</code> | <code>dc1.large</code> | <code>dc1.8xlarge</code> | <code>dc2.large</code> | <code>dc2.8xlarge</code> | <code>ra3.16xlarge</code> </p>
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>A unique identifier for the cluster. You use this identifier to refer to the cluster for any subsequent cluster operations such as deleting or modifying. The identifier also appears in the Amazon Redshift console.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul> <p>Example: <code>myexamplecluster</code> </p>
  ##   MasterUserPassword: JString (required)
  ##                     : <p>The password associated with the master user account for the cluster that is being created.</p> <p>Constraints:</p> <ul> <li> <p>Must be between 8 and 64 characters in length.</p> </li> <li> <p>Must contain at least one uppercase letter.</p> </li> <li> <p>Must contain at least one lowercase letter.</p> </li> <li> <p>Must contain one number.</p> </li> <li> <p>Can be any printable ASCII character (ASCII code 33 to 126) except ' (single quote), " (double quote), \, /, @, or space.</p> </li> </ul>
  ##   MaintenanceTrackName: JString
  ##                       : An optional parameter for the name of the maintenance track for the cluster. If you don't provide a maintenance track name, the cluster is assigned to the <code>current</code> track.
  ##   MasterUsername: JString (required)
  ##                 : <p>The user name associated with the master user account for the cluster that is being created.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 - 128 alphanumeric characters. The user name can't be <code>PUBLIC</code>.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide. </p> </li> </ul>
  ##   ClusterSecurityGroups: JArray
  ##                        : <p>A list of security groups to be associated with this cluster.</p> <p>Default: The default cluster security group for Amazon Redshift.</p>
  ##   IamRoles: JArray
  ##           : <p>A list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services. You must supply the IAM roles in their Amazon Resource Name (ARN) format. You can supply up to 10 IAM roles in a single request.</p> <p>A cluster can have up to 10 IAM roles associated with it at any time.</p>
  ##   VpcSecurityGroupIds: JArray
  ##                      : <p>A list of Virtual Private Cloud (VPC) security groups to be associated with the cluster.</p> <p>Default: The default VPC security group is associated with the cluster.</p>
  ##   AutomatedSnapshotRetentionPeriod: JInt
  ##                                   : <p>The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p> <p>Default: <code>1</code> </p> <p>Constraints: Must be a value from 0 to 35.</p>
  ##   AvailabilityZone: JString
  ##                   : <p>The EC2 Availability Zone (AZ) in which you want Amazon Redshift to provision the cluster. For example, if you have several EC2 instances running in a specific Availability Zone, then you might want the cluster to be provisioned in the same zone in order to decrease network latency.</p> <p>Default: A random, system-chosen Availability Zone in the region that is specified by the endpoint.</p> <p>Example: <code>us-east-2d</code> </p> <p>Constraint: The specified Availability Zone must be in the same region as the current endpoint.</p>
  ##   NumberOfNodes: JInt
  ##                : <p>The number of compute nodes in the cluster. This parameter is required when the <b>ClusterType</b> parameter is specified as <code>multi-node</code>. </p> <p>For information about determining how many nodes you need, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#how-many-nodes"> Working with Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p> <p>If you don't specify this parameter, you get a single-node cluster. When requesting a multi-node cluster, you must specify the number of nodes that you want in the cluster.</p> <p>Default: <code>1</code> </p> <p>Constraints: Value must be at least 1 and no more than 100.</p>
  ##   KmsKeyId: JString
  ##           : The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster.
  ##   EnhancedVpcRouting: JBool
  ##                     : <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p> <p>Default: false</p>
  ##   ClusterSubnetGroupName: JString
  ##                         : <p>The name of a cluster subnet group to be associated with this cluster.</p> <p>If this parameter is not provided the resulting cluster will be deployed outside virtual private cloud (VPC).</p>
  ##   AllowVersionUpgrade: JBool
  ##                      : <p>If <code>true</code>, major version upgrades can be applied during the maintenance window to the Amazon Redshift engine that is running on the cluster.</p> <p>When a new major version of the Amazon Redshift engine is released, you can request that the service automatically apply upgrades during the maintenance window to the Amazon Redshift engine that is running on your cluster.</p> <p>Default: <code>true</code> </p>
  ##   DBName: JString
  ##         : <p>The name of the first database to be created when the cluster is created.</p> <p>To create additional databases after the cluster is created, connect to the cluster with a SQL client and use SQL commands to create a database. For more information, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/t_creating_database.html">Create a Database</a> in the Amazon Redshift Database Developer Guide. </p> <p>Default: <code>dev</code> </p> <p>Constraints:</p> <ul> <li> <p>Must contain 1 to 64 alphanumeric characters.</p> </li> <li> <p>Must contain only lowercase letters.</p> </li> <li> <p>Cannot be a word that is reserved by the service. A list of reserved words can be found in <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide. </p> </li> </ul>
  ##   PubliclyAccessible: JBool
  ##                     : If <code>true</code>, the cluster can be accessed from a public network. 
  ##   ClusterParameterGroupName: JString
  ##                            : <p>The name of the parameter group to be associated with this cluster.</p> <p>Default: The default Amazon Redshift cluster parameter group. For information about the default parameter group, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Working with Amazon Redshift Parameter Groups</a> </p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   ClusterVersion: JString
  ##                 : <p>The version of the Amazon Redshift engine software that you want to deploy on the cluster.</p> <p>The version selected runs on all the nodes in the cluster.</p> <p>Constraints: Only version 1.0 is currently available.</p> <p>Example: <code>1.0</code> </p>
  ##   ClusterType: JString
  ##              : <p>The type of the cluster. When cluster type is specified as</p> <ul> <li> <p> <code>single-node</code>, the <b>NumberOfNodes</b> parameter is not required.</p> </li> <li> <p> <code>multi-node</code>, the <b>NumberOfNodes</b> parameter is required.</p> </li> </ul> <p>Valid Values: <code>multi-node</code> | <code>single-node</code> </p> <p>Default: <code>multi-node</code> </p>
  ##   Encrypted: JBool
  ##            : <p>If <code>true</code>, the data in the cluster is encrypted at rest. </p> <p>Default: false</p>
  ##   HsmClientCertificateIdentifier: JString
  ##                                 : Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM.
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   AdditionalInfo: JString
  ##                 : Reserved.
  ##   SnapshotScheduleIdentifier: JString
  ##                             : A unique identifier for the snapshot schedule.
  ##   ElasticIp: JString
  ##            : <p>The Elastic IP (EIP) address for the cluster.</p> <p>Constraints: The cluster must be provisioned in EC2-VPC and publicly-accessible through an Internet gateway. For more information about provisioning clusters in EC2-VPC, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#cluster-platforms">Supported Platforms to Launch Your Cluster</a> in the Amazon Redshift Cluster Management Guide.</p>
  ##   HsmConfigurationIdentifier: JString
  ##                             : Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The default number of days to retain a manual snapshot. If the value is -1, the snapshot is retained indefinitely. This setting doesn't change the retention period of existing snapshots.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  section = newJObject()
  var valid_611545 = formData.getOrDefault("PreferredMaintenanceWindow")
  valid_611545 = validateParameter(valid_611545, JString, required = false,
                                 default = nil)
  if valid_611545 != nil:
    section.add "PreferredMaintenanceWindow", valid_611545
  var valid_611546 = formData.getOrDefault("Port")
  valid_611546 = validateParameter(valid_611546, JInt, required = false, default = nil)
  if valid_611546 != nil:
    section.add "Port", valid_611546
  assert formData != nil,
        "formData argument is necessary due to required `NodeType` field"
  var valid_611547 = formData.getOrDefault("NodeType")
  valid_611547 = validateParameter(valid_611547, JString, required = true,
                                 default = nil)
  if valid_611547 != nil:
    section.add "NodeType", valid_611547
  var valid_611548 = formData.getOrDefault("ClusterIdentifier")
  valid_611548 = validateParameter(valid_611548, JString, required = true,
                                 default = nil)
  if valid_611548 != nil:
    section.add "ClusterIdentifier", valid_611548
  var valid_611549 = formData.getOrDefault("MasterUserPassword")
  valid_611549 = validateParameter(valid_611549, JString, required = true,
                                 default = nil)
  if valid_611549 != nil:
    section.add "MasterUserPassword", valid_611549
  var valid_611550 = formData.getOrDefault("MaintenanceTrackName")
  valid_611550 = validateParameter(valid_611550, JString, required = false,
                                 default = nil)
  if valid_611550 != nil:
    section.add "MaintenanceTrackName", valid_611550
  var valid_611551 = formData.getOrDefault("MasterUsername")
  valid_611551 = validateParameter(valid_611551, JString, required = true,
                                 default = nil)
  if valid_611551 != nil:
    section.add "MasterUsername", valid_611551
  var valid_611552 = formData.getOrDefault("ClusterSecurityGroups")
  valid_611552 = validateParameter(valid_611552, JArray, required = false,
                                 default = nil)
  if valid_611552 != nil:
    section.add "ClusterSecurityGroups", valid_611552
  var valid_611553 = formData.getOrDefault("IamRoles")
  valid_611553 = validateParameter(valid_611553, JArray, required = false,
                                 default = nil)
  if valid_611553 != nil:
    section.add "IamRoles", valid_611553
  var valid_611554 = formData.getOrDefault("VpcSecurityGroupIds")
  valid_611554 = validateParameter(valid_611554, JArray, required = false,
                                 default = nil)
  if valid_611554 != nil:
    section.add "VpcSecurityGroupIds", valid_611554
  var valid_611555 = formData.getOrDefault("AutomatedSnapshotRetentionPeriod")
  valid_611555 = validateParameter(valid_611555, JInt, required = false, default = nil)
  if valid_611555 != nil:
    section.add "AutomatedSnapshotRetentionPeriod", valid_611555
  var valid_611556 = formData.getOrDefault("AvailabilityZone")
  valid_611556 = validateParameter(valid_611556, JString, required = false,
                                 default = nil)
  if valid_611556 != nil:
    section.add "AvailabilityZone", valid_611556
  var valid_611557 = formData.getOrDefault("NumberOfNodes")
  valid_611557 = validateParameter(valid_611557, JInt, required = false, default = nil)
  if valid_611557 != nil:
    section.add "NumberOfNodes", valid_611557
  var valid_611558 = formData.getOrDefault("KmsKeyId")
  valid_611558 = validateParameter(valid_611558, JString, required = false,
                                 default = nil)
  if valid_611558 != nil:
    section.add "KmsKeyId", valid_611558
  var valid_611559 = formData.getOrDefault("EnhancedVpcRouting")
  valid_611559 = validateParameter(valid_611559, JBool, required = false, default = nil)
  if valid_611559 != nil:
    section.add "EnhancedVpcRouting", valid_611559
  var valid_611560 = formData.getOrDefault("ClusterSubnetGroupName")
  valid_611560 = validateParameter(valid_611560, JString, required = false,
                                 default = nil)
  if valid_611560 != nil:
    section.add "ClusterSubnetGroupName", valid_611560
  var valid_611561 = formData.getOrDefault("AllowVersionUpgrade")
  valid_611561 = validateParameter(valid_611561, JBool, required = false, default = nil)
  if valid_611561 != nil:
    section.add "AllowVersionUpgrade", valid_611561
  var valid_611562 = formData.getOrDefault("DBName")
  valid_611562 = validateParameter(valid_611562, JString, required = false,
                                 default = nil)
  if valid_611562 != nil:
    section.add "DBName", valid_611562
  var valid_611563 = formData.getOrDefault("PubliclyAccessible")
  valid_611563 = validateParameter(valid_611563, JBool, required = false, default = nil)
  if valid_611563 != nil:
    section.add "PubliclyAccessible", valid_611563
  var valid_611564 = formData.getOrDefault("ClusterParameterGroupName")
  valid_611564 = validateParameter(valid_611564, JString, required = false,
                                 default = nil)
  if valid_611564 != nil:
    section.add "ClusterParameterGroupName", valid_611564
  var valid_611565 = formData.getOrDefault("ClusterVersion")
  valid_611565 = validateParameter(valid_611565, JString, required = false,
                                 default = nil)
  if valid_611565 != nil:
    section.add "ClusterVersion", valid_611565
  var valid_611566 = formData.getOrDefault("ClusterType")
  valid_611566 = validateParameter(valid_611566, JString, required = false,
                                 default = nil)
  if valid_611566 != nil:
    section.add "ClusterType", valid_611566
  var valid_611567 = formData.getOrDefault("Encrypted")
  valid_611567 = validateParameter(valid_611567, JBool, required = false, default = nil)
  if valid_611567 != nil:
    section.add "Encrypted", valid_611567
  var valid_611568 = formData.getOrDefault("HsmClientCertificateIdentifier")
  valid_611568 = validateParameter(valid_611568, JString, required = false,
                                 default = nil)
  if valid_611568 != nil:
    section.add "HsmClientCertificateIdentifier", valid_611568
  var valid_611569 = formData.getOrDefault("Tags")
  valid_611569 = validateParameter(valid_611569, JArray, required = false,
                                 default = nil)
  if valid_611569 != nil:
    section.add "Tags", valid_611569
  var valid_611570 = formData.getOrDefault("AdditionalInfo")
  valid_611570 = validateParameter(valid_611570, JString, required = false,
                                 default = nil)
  if valid_611570 != nil:
    section.add "AdditionalInfo", valid_611570
  var valid_611571 = formData.getOrDefault("SnapshotScheduleIdentifier")
  valid_611571 = validateParameter(valid_611571, JString, required = false,
                                 default = nil)
  if valid_611571 != nil:
    section.add "SnapshotScheduleIdentifier", valid_611571
  var valid_611572 = formData.getOrDefault("ElasticIp")
  valid_611572 = validateParameter(valid_611572, JString, required = false,
                                 default = nil)
  if valid_611572 != nil:
    section.add "ElasticIp", valid_611572
  var valid_611573 = formData.getOrDefault("HsmConfigurationIdentifier")
  valid_611573 = validateParameter(valid_611573, JString, required = false,
                                 default = nil)
  if valid_611573 != nil:
    section.add "HsmConfigurationIdentifier", valid_611573
  var valid_611574 = formData.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_611574 = validateParameter(valid_611574, JInt, required = false, default = nil)
  if valid_611574 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_611574
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_611575: Call_PostCreateCluster_611533; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a new cluster with the specified parameters.</p> <p>To create a cluster in Virtual Private Cloud (VPC), you must provide a cluster subnet group name. The cluster subnet group identifies the subnets of your VPC that Amazon Redshift uses when creating the cluster. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_611575.validator(path, query, header, formData, body)
  let scheme = call_611575.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_611575.url(scheme.get, call_611575.host, call_611575.base,
                         call_611575.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_611575, url, valid)

proc call*(call_611576: Call_PostCreateCluster_611533; NodeType: string;
          ClusterIdentifier: string; MasterUserPassword: string;
          MasterUsername: string; PreferredMaintenanceWindow: string = "";
          Port: int = 0; MaintenanceTrackName: string = "";
          ClusterSecurityGroups: JsonNode = nil; IamRoles: JsonNode = nil;
          VpcSecurityGroupIds: JsonNode = nil;
          AutomatedSnapshotRetentionPeriod: int = 0; AvailabilityZone: string = "";
          NumberOfNodes: int = 0; KmsKeyId: string = "";
          EnhancedVpcRouting: bool = false; ClusterSubnetGroupName: string = "";
          AllowVersionUpgrade: bool = false; DBName: string = "";
          PubliclyAccessible: bool = false; Action: string = "CreateCluster";
          ClusterParameterGroupName: string = ""; ClusterVersion: string = "";
          ClusterType: string = ""; Encrypted: bool = false;
          HsmClientCertificateIdentifier: string = ""; Tags: JsonNode = nil;
          AdditionalInfo: string = ""; SnapshotScheduleIdentifier: string = "";
          Version: string = "2012-12-01"; ElasticIp: string = "";
          HsmConfigurationIdentifier: string = "";
          ManualSnapshotRetentionPeriod: int = 0): Recallable =
  ## postCreateCluster
  ## <p>Creates a new cluster with the specified parameters.</p> <p>To create a cluster in Virtual Private Cloud (VPC), you must provide a cluster subnet group name. The cluster subnet group identifies the subnets of your VPC that Amazon Redshift uses when creating the cluster. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   PreferredMaintenanceWindow: string
  ##                             : <p>The weekly time range (in UTC) during which automated cluster maintenance can occur.</p> <p> Format: <code>ddd:hh24:mi-ddd:hh24:mi</code> </p> <p> Default: A 30-minute window selected at random from an 8-hour block of time per region, occurring on a random day of the week. For more information about the time blocks for each region, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-maintenance-windows">Maintenance Windows</a> in Amazon Redshift Cluster Management Guide.</p> <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p> <p>Constraints: Minimum 30-minute window.</p>
  ##   Port: int
  ##       : <p>The port number on which the cluster accepts incoming connections.</p> <p>The cluster is accessible only via the JDBC and ODBC connection strings. Part of the connection string requires the port on which the cluster will listen for incoming connections.</p> <p>Default: <code>5439</code> </p> <p>Valid Values: <code>1150-65535</code> </p>
  ##   NodeType: string (required)
  ##           : <p>The node type to be provisioned for the cluster. For information about node types, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#how-many-nodes"> Working with Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p> <p>Valid Values: <code>ds2.xlarge</code> | <code>ds2.8xlarge</code> | <code>dc1.large</code> | <code>dc1.8xlarge</code> | <code>dc2.large</code> | <code>dc2.8xlarge</code> | <code>ra3.16xlarge</code> </p>
  ##   ClusterIdentifier: string (required)
  ##                    : <p>A unique identifier for the cluster. You use this identifier to refer to the cluster for any subsequent cluster operations such as deleting or modifying. The identifier also appears in the Amazon Redshift console.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul> <p>Example: <code>myexamplecluster</code> </p>
  ##   MasterUserPassword: string (required)
  ##                     : <p>The password associated with the master user account for the cluster that is being created.</p> <p>Constraints:</p> <ul> <li> <p>Must be between 8 and 64 characters in length.</p> </li> <li> <p>Must contain at least one uppercase letter.</p> </li> <li> <p>Must contain at least one lowercase letter.</p> </li> <li> <p>Must contain one number.</p> </li> <li> <p>Can be any printable ASCII character (ASCII code 33 to 126) except ' (single quote), " (double quote), \, /, @, or space.</p> </li> </ul>
  ##   MaintenanceTrackName: string
  ##                       : An optional parameter for the name of the maintenance track for the cluster. If you don't provide a maintenance track name, the cluster is assigned to the <code>current</code> track.
  ##   MasterUsername: string (required)
  ##                 : <p>The user name associated with the master user account for the cluster that is being created.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 - 128 alphanumeric characters. The user name can't be <code>PUBLIC</code>.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide. </p> </li> </ul>
  ##   ClusterSecurityGroups: JArray
  ##                        : <p>A list of security groups to be associated with this cluster.</p> <p>Default: The default cluster security group for Amazon Redshift.</p>
  ##   IamRoles: JArray
  ##           : <p>A list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services. You must supply the IAM roles in their Amazon Resource Name (ARN) format. You can supply up to 10 IAM roles in a single request.</p> <p>A cluster can have up to 10 IAM roles associated with it at any time.</p>
  ##   VpcSecurityGroupIds: JArray
  ##                      : <p>A list of Virtual Private Cloud (VPC) security groups to be associated with the cluster.</p> <p>Default: The default VPC security group is associated with the cluster.</p>
  ##   AutomatedSnapshotRetentionPeriod: int
  ##                                   : <p>The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p> <p>Default: <code>1</code> </p> <p>Constraints: Must be a value from 0 to 35.</p>
  ##   AvailabilityZone: string
  ##                   : <p>The EC2 Availability Zone (AZ) in which you want Amazon Redshift to provision the cluster. For example, if you have several EC2 instances running in a specific Availability Zone, then you might want the cluster to be provisioned in the same zone in order to decrease network latency.</p> <p>Default: A random, system-chosen Availability Zone in the region that is specified by the endpoint.</p> <p>Example: <code>us-east-2d</code> </p> <p>Constraint: The specified Availability Zone must be in the same region as the current endpoint.</p>
  ##   NumberOfNodes: int
  ##                : <p>The number of compute nodes in the cluster. This parameter is required when the <b>ClusterType</b> parameter is specified as <code>multi-node</code>. </p> <p>For information about determining how many nodes you need, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#how-many-nodes"> Working with Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p> <p>If you don't specify this parameter, you get a single-node cluster. When requesting a multi-node cluster, you must specify the number of nodes that you want in the cluster.</p> <p>Default: <code>1</code> </p> <p>Constraints: Value must be at least 1 and no more than 100.</p>
  ##   KmsKeyId: string
  ##           : The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster.
  ##   EnhancedVpcRouting: bool
  ##                     : <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p> <p>Default: false</p>
  ##   ClusterSubnetGroupName: string
  ##                         : <p>The name of a cluster subnet group to be associated with this cluster.</p> <p>If this parameter is not provided the resulting cluster will be deployed outside virtual private cloud (VPC).</p>
  ##   AllowVersionUpgrade: bool
  ##                      : <p>If <code>true</code>, major version upgrades can be applied during the maintenance window to the Amazon Redshift engine that is running on the cluster.</p> <p>When a new major version of the Amazon Redshift engine is released, you can request that the service automatically apply upgrades during the maintenance window to the Amazon Redshift engine that is running on your cluster.</p> <p>Default: <code>true</code> </p>
  ##   DBName: string
  ##         : <p>The name of the first database to be created when the cluster is created.</p> <p>To create additional databases after the cluster is created, connect to the cluster with a SQL client and use SQL commands to create a database. For more information, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/t_creating_database.html">Create a Database</a> in the Amazon Redshift Database Developer Guide. </p> <p>Default: <code>dev</code> </p> <p>Constraints:</p> <ul> <li> <p>Must contain 1 to 64 alphanumeric characters.</p> </li> <li> <p>Must contain only lowercase letters.</p> </li> <li> <p>Cannot be a word that is reserved by the service. A list of reserved words can be found in <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide. </p> </li> </ul>
  ##   PubliclyAccessible: bool
  ##                     : If <code>true</code>, the cluster can be accessed from a public network. 
  ##   Action: string (required)
  ##   ClusterParameterGroupName: string
  ##                            : <p>The name of the parameter group to be associated with this cluster.</p> <p>Default: The default Amazon Redshift cluster parameter group. For information about the default parameter group, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Working with Amazon Redshift Parameter Groups</a> </p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   ClusterVersion: string
  ##                 : <p>The version of the Amazon Redshift engine software that you want to deploy on the cluster.</p> <p>The version selected runs on all the nodes in the cluster.</p> <p>Constraints: Only version 1.0 is currently available.</p> <p>Example: <code>1.0</code> </p>
  ##   ClusterType: string
  ##              : <p>The type of the cluster. When cluster type is specified as</p> <ul> <li> <p> <code>single-node</code>, the <b>NumberOfNodes</b> parameter is not required.</p> </li> <li> <p> <code>multi-node</code>, the <b>NumberOfNodes</b> parameter is required.</p> </li> </ul> <p>Valid Values: <code>multi-node</code> | <code>single-node</code> </p> <p>Default: <code>multi-node</code> </p>
  ##   Encrypted: bool
  ##            : <p>If <code>true</code>, the data in the cluster is encrypted at rest. </p> <p>Default: false</p>
  ##   HsmClientCertificateIdentifier: string
  ##                                 : Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM.
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   AdditionalInfo: string
  ##                 : Reserved.
  ##   SnapshotScheduleIdentifier: string
  ##                             : A unique identifier for the snapshot schedule.
  ##   Version: string (required)
  ##   ElasticIp: string
  ##            : <p>The Elastic IP (EIP) address for the cluster.</p> <p>Constraints: The cluster must be provisioned in EC2-VPC and publicly-accessible through an Internet gateway. For more information about provisioning clusters in EC2-VPC, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#cluster-platforms">Supported Platforms to Launch Your Cluster</a> in the Amazon Redshift Cluster Management Guide.</p>
  ##   HsmConfigurationIdentifier: string
  ##                             : Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The default number of days to retain a manual snapshot. If the value is -1, the snapshot is retained indefinitely. This setting doesn't change the retention period of existing snapshots.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  var query_611577 = newJObject()
  var formData_611578 = newJObject()
  add(formData_611578, "PreferredMaintenanceWindow",
      newJString(PreferredMaintenanceWindow))
  add(formData_611578, "Port", newJInt(Port))
  add(formData_611578, "NodeType", newJString(NodeType))
  add(formData_611578, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_611578, "MasterUserPassword", newJString(MasterUserPassword))
  add(formData_611578, "MaintenanceTrackName", newJString(MaintenanceTrackName))
  add(formData_611578, "MasterUsername", newJString(MasterUsername))
  if ClusterSecurityGroups != nil:
    formData_611578.add "ClusterSecurityGroups", ClusterSecurityGroups
  if IamRoles != nil:
    formData_611578.add "IamRoles", IamRoles
  if VpcSecurityGroupIds != nil:
    formData_611578.add "VpcSecurityGroupIds", VpcSecurityGroupIds
  add(formData_611578, "AutomatedSnapshotRetentionPeriod",
      newJInt(AutomatedSnapshotRetentionPeriod))
  add(formData_611578, "AvailabilityZone", newJString(AvailabilityZone))
  add(formData_611578, "NumberOfNodes", newJInt(NumberOfNodes))
  add(formData_611578, "KmsKeyId", newJString(KmsKeyId))
  add(formData_611578, "EnhancedVpcRouting", newJBool(EnhancedVpcRouting))
  add(formData_611578, "ClusterSubnetGroupName",
      newJString(ClusterSubnetGroupName))
  add(formData_611578, "AllowVersionUpgrade", newJBool(AllowVersionUpgrade))
  add(formData_611578, "DBName", newJString(DBName))
  add(formData_611578, "PubliclyAccessible", newJBool(PubliclyAccessible))
  add(query_611577, "Action", newJString(Action))
  add(formData_611578, "ClusterParameterGroupName",
      newJString(ClusterParameterGroupName))
  add(formData_611578, "ClusterVersion", newJString(ClusterVersion))
  add(formData_611578, "ClusterType", newJString(ClusterType))
  add(formData_611578, "Encrypted", newJBool(Encrypted))
  add(formData_611578, "HsmClientCertificateIdentifier",
      newJString(HsmClientCertificateIdentifier))
  if Tags != nil:
    formData_611578.add "Tags", Tags
  add(formData_611578, "AdditionalInfo", newJString(AdditionalInfo))
  add(formData_611578, "SnapshotScheduleIdentifier",
      newJString(SnapshotScheduleIdentifier))
  add(query_611577, "Version", newJString(Version))
  add(formData_611578, "ElasticIp", newJString(ElasticIp))
  add(formData_611578, "HsmConfigurationIdentifier",
      newJString(HsmConfigurationIdentifier))
  add(formData_611578, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  result = call_611576.call(nil, query_611577, nil, formData_611578, nil)

var postCreateCluster* = Call_PostCreateCluster_611533(name: "postCreateCluster",
    meth: HttpMethod.HttpPost, host: "redshift.amazonaws.com",
    route: "/#Action=CreateCluster", validator: validate_PostCreateCluster_611534,
    base: "/", url: url_PostCreateCluster_611535,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCreateCluster_611488 = ref object of OpenApiRestCall_610642
proc url_GetCreateCluster_611490(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetCreateCluster_611489(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## <p>Creates a new cluster with the specified parameters.</p> <p>To create a cluster in Virtual Private Cloud (VPC), you must provide a cluster subnet group name. The cluster subnet group identifies the subnets of your VPC that Amazon Redshift uses when creating the cluster. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ClusterSubnetGroupName: JString
  ##                         : <p>The name of a cluster subnet group to be associated with this cluster.</p> <p>If this parameter is not provided the resulting cluster will be deployed outside virtual private cloud (VPC).</p>
  ##   MaintenanceTrackName: JString
  ##                       : An optional parameter for the name of the maintenance track for the cluster. If you don't provide a maintenance track name, the cluster is assigned to the <code>current</code> track.
  ##   DBName: JString
  ##         : <p>The name of the first database to be created when the cluster is created.</p> <p>To create additional databases after the cluster is created, connect to the cluster with a SQL client and use SQL commands to create a database. For more information, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/t_creating_database.html">Create a Database</a> in the Amazon Redshift Database Developer Guide. </p> <p>Default: <code>dev</code> </p> <p>Constraints:</p> <ul> <li> <p>Must contain 1 to 64 alphanumeric characters.</p> </li> <li> <p>Must contain only lowercase letters.</p> </li> <li> <p>Cannot be a word that is reserved by the service. A list of reserved words can be found in <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide. </p> </li> </ul>
  ##   Encrypted: JBool
  ##            : <p>If <code>true</code>, the data in the cluster is encrypted at rest. </p> <p>Default: false</p>
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The default number of days to retain a manual snapshot. If the value is -1, the snapshot is retained indefinitely. This setting doesn't change the retention period of existing snapshots.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  ##   HsmClientCertificateIdentifier: JString
  ##                                 : Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM.
  ##   ClusterSecurityGroups: JArray
  ##                        : <p>A list of security groups to be associated with this cluster.</p> <p>Default: The default cluster security group for Amazon Redshift.</p>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   KmsKeyId: JString
  ##           : The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster.
  ##   ClusterParameterGroupName: JString
  ##                            : <p>The name of the parameter group to be associated with this cluster.</p> <p>Default: The default Amazon Redshift cluster parameter group. For information about the default parameter group, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Working with Amazon Redshift Parameter Groups</a> </p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   NodeType: JString (required)
  ##           : <p>The node type to be provisioned for the cluster. For information about node types, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#how-many-nodes"> Working with Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p> <p>Valid Values: <code>ds2.xlarge</code> | <code>ds2.8xlarge</code> | <code>dc1.large</code> | <code>dc1.8xlarge</code> | <code>dc2.large</code> | <code>dc2.8xlarge</code> | <code>ra3.16xlarge</code> </p>
  ##   ClusterVersion: JString
  ##                 : <p>The version of the Amazon Redshift engine software that you want to deploy on the cluster.</p> <p>The version selected runs on all the nodes in the cluster.</p> <p>Constraints: Only version 1.0 is currently available.</p> <p>Example: <code>1.0</code> </p>
  ##   IamRoles: JArray
  ##           : <p>A list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services. You must supply the IAM roles in their Amazon Resource Name (ARN) format. You can supply up to 10 IAM roles in a single request.</p> <p>A cluster can have up to 10 IAM roles associated with it at any time.</p>
  ##   SnapshotScheduleIdentifier: JString
  ##                             : A unique identifier for the snapshot schedule.
  ##   ClusterType: JString
  ##              : <p>The type of the cluster. When cluster type is specified as</p> <ul> <li> <p> <code>single-node</code>, the <b>NumberOfNodes</b> parameter is not required.</p> </li> <li> <p> <code>multi-node</code>, the <b>NumberOfNodes</b> parameter is required.</p> </li> </ul> <p>Valid Values: <code>multi-node</code> | <code>single-node</code> </p> <p>Default: <code>multi-node</code> </p>
  ##   NumberOfNodes: JInt
  ##                : <p>The number of compute nodes in the cluster. This parameter is required when the <b>ClusterType</b> parameter is specified as <code>multi-node</code>. </p> <p>For information about determining how many nodes you need, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#how-many-nodes"> Working with Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p> <p>If you don't specify this parameter, you get a single-node cluster. When requesting a multi-node cluster, you must specify the number of nodes that you want in the cluster.</p> <p>Default: <code>1</code> </p> <p>Constraints: Value must be at least 1 and no more than 100.</p>
  ##   MasterUsername: JString (required)
  ##                 : <p>The user name associated with the master user account for the cluster that is being created.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 - 128 alphanumeric characters. The user name can't be <code>PUBLIC</code>.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide. </p> </li> </ul>
  ##   AdditionalInfo: JString
  ##                 : Reserved.
  ##   AllowVersionUpgrade: JBool
  ##                      : <p>If <code>true</code>, major version upgrades can be applied during the maintenance window to the Amazon Redshift engine that is running on the cluster.</p> <p>When a new major version of the Amazon Redshift engine is released, you can request that the service automatically apply upgrades during the maintenance window to the Amazon Redshift engine that is running on your cluster.</p> <p>Default: <code>true</code> </p>
  ##   ElasticIp: JString
  ##            : <p>The Elastic IP (EIP) address for the cluster.</p> <p>Constraints: The cluster must be provisioned in EC2-VPC and publicly-accessible through an Internet gateway. For more information about provisioning clusters in EC2-VPC, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#cluster-platforms">Supported Platforms to Launch Your Cluster</a> in the Amazon Redshift Cluster Management Guide.</p>
  ##   AutomatedSnapshotRetentionPeriod: JInt
  ##                                   : <p>The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p> <p>Default: <code>1</code> </p> <p>Constraints: Must be a value from 0 to 35.</p>
  ##   EnhancedVpcRouting: JBool
  ##                     : <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p> <p>Default: false</p>
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>A unique identifier for the cluster. You use this identifier to refer to the cluster for any subsequent cluster operations such as deleting or modifying. The identifier also appears in the Amazon Redshift console.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul> <p>Example: <code>myexamplecluster</code> </p>
  ##   Port: JInt
  ##       : <p>The port number on which the cluster accepts incoming connections.</p> <p>The cluster is accessible only via the JDBC and ODBC connection strings. Part of the connection string requires the port on which the cluster will listen for incoming connections.</p> <p>Default: <code>5439</code> </p> <p>Valid Values: <code>1150-65535</code> </p>
  ##   VpcSecurityGroupIds: JArray
  ##                      : <p>A list of Virtual Private Cloud (VPC) security groups to be associated with the cluster.</p> <p>Default: The default VPC security group is associated with the cluster.</p>
  ##   MasterUserPassword: JString (required)
  ##                     : <p>The password associated with the master user account for the cluster that is being created.</p> <p>Constraints:</p> <ul> <li> <p>Must be between 8 and 64 characters in length.</p> </li> <li> <p>Must contain at least one uppercase letter.</p> </li> <li> <p>Must contain at least one lowercase letter.</p> </li> <li> <p>Must contain one number.</p> </li> <li> <p>Can be any printable ASCII character (ASCII code 33 to 126) except ' (single quote), " (double quote), \, /, @, or space.</p> </li> </ul>
  ##   AvailabilityZone: JString
  ##                   : <p>The EC2 Availability Zone (AZ) in which you want Amazon Redshift to provision the cluster. For example, if you have several EC2 instances running in a specific Availability Zone, then you might want the cluster to be provisioned in the same zone in order to decrease network latency.</p> <p>Default: A random, system-chosen Availability Zone in the region that is specified by the endpoint.</p> <p>Example: <code>us-east-2d</code> </p> <p>Constraint: The specified Availability Zone must be in the same region as the current endpoint.</p>
  ##   HsmConfigurationIdentifier: JString
  ##                             : Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
  ##   Version: JString (required)
  ##   PreferredMaintenanceWindow: JString
  ##                             : <p>The weekly time range (in UTC) during which automated cluster maintenance can occur.</p> <p> Format: <code>ddd:hh24:mi-ddd:hh24:mi</code> </p> <p> Default: A 30-minute window selected at random from an 8-hour block of time per region, occurring on a random day of the week. For more information about the time blocks for each region, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-maintenance-windows">Maintenance Windows</a> in Amazon Redshift Cluster Management Guide.</p> <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p> <p>Constraints: Minimum 30-minute window.</p>
  ##   PubliclyAccessible: JBool
  ##                     : If <code>true</code>, the cluster can be accessed from a public network. 
  section = newJObject()
  var valid_611491 = query.getOrDefault("ClusterSubnetGroupName")
  valid_611491 = validateParameter(valid_611491, JString, required = false,
                                 default = nil)
  if valid_611491 != nil:
    section.add "ClusterSubnetGroupName", valid_611491
  var valid_611492 = query.getOrDefault("MaintenanceTrackName")
  valid_611492 = validateParameter(valid_611492, JString, required = false,
                                 default = nil)
  if valid_611492 != nil:
    section.add "MaintenanceTrackName", valid_611492
  var valid_611493 = query.getOrDefault("DBName")
  valid_611493 = validateParameter(valid_611493, JString, required = false,
                                 default = nil)
  if valid_611493 != nil:
    section.add "DBName", valid_611493
  var valid_611494 = query.getOrDefault("Encrypted")
  valid_611494 = validateParameter(valid_611494, JBool, required = false, default = nil)
  if valid_611494 != nil:
    section.add "Encrypted", valid_611494
  var valid_611495 = query.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_611495 = validateParameter(valid_611495, JInt, required = false, default = nil)
  if valid_611495 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_611495
  var valid_611496 = query.getOrDefault("HsmClientCertificateIdentifier")
  valid_611496 = validateParameter(valid_611496, JString, required = false,
                                 default = nil)
  if valid_611496 != nil:
    section.add "HsmClientCertificateIdentifier", valid_611496
  var valid_611497 = query.getOrDefault("ClusterSecurityGroups")
  valid_611497 = validateParameter(valid_611497, JArray, required = false,
                                 default = nil)
  if valid_611497 != nil:
    section.add "ClusterSecurityGroups", valid_611497
  var valid_611498 = query.getOrDefault("Tags")
  valid_611498 = validateParameter(valid_611498, JArray, required = false,
                                 default = nil)
  if valid_611498 != nil:
    section.add "Tags", valid_611498
  var valid_611499 = query.getOrDefault("KmsKeyId")
  valid_611499 = validateParameter(valid_611499, JString, required = false,
                                 default = nil)
  if valid_611499 != nil:
    section.add "KmsKeyId", valid_611499
  var valid_611500 = query.getOrDefault("ClusterParameterGroupName")
  valid_611500 = validateParameter(valid_611500, JString, required = false,
                                 default = nil)
  if valid_611500 != nil:
    section.add "ClusterParameterGroupName", valid_611500
  assert query != nil,
        "query argument is necessary due to required `NodeType` field"
  var valid_611501 = query.getOrDefault("NodeType")
  valid_611501 = validateParameter(valid_611501, JString, required = true,
                                 default = nil)
  if valid_611501 != nil:
    section.add "NodeType", valid_611501
  var valid_611502 = query.getOrDefault("ClusterVersion")
  valid_611502 = validateParameter(valid_611502, JString, required = false,
                                 default = nil)
  if valid_611502 != nil:
    section.add "ClusterVersion", valid_611502
  var valid_611503 = query.getOrDefault("IamRoles")
  valid_611503 = validateParameter(valid_611503, JArray, required = false,
                                 default = nil)
  if valid_611503 != nil:
    section.add "IamRoles", valid_611503
  var valid_611504 = query.getOrDefault("SnapshotScheduleIdentifier")
  valid_611504 = validateParameter(valid_611504, JString, required = false,
                                 default = nil)
  if valid_611504 != nil:
    section.add "SnapshotScheduleIdentifier", valid_611504
  var valid_611505 = query.getOrDefault("ClusterType")
  valid_611505 = validateParameter(valid_611505, JString, required = false,
                                 default = nil)
  if valid_611505 != nil:
    section.add "ClusterType", valid_611505
  var valid_611506 = query.getOrDefault("NumberOfNodes")
  valid_611506 = validateParameter(valid_611506, JInt, required = false, default = nil)
  if valid_611506 != nil:
    section.add "NumberOfNodes", valid_611506
  var valid_611507 = query.getOrDefault("MasterUsername")
  valid_611507 = validateParameter(valid_611507, JString, required = true,
                                 default = nil)
  if valid_611507 != nil:
    section.add "MasterUsername", valid_611507
  var valid_611508 = query.getOrDefault("AdditionalInfo")
  valid_611508 = validateParameter(valid_611508, JString, required = false,
                                 default = nil)
  if valid_611508 != nil:
    section.add "AdditionalInfo", valid_611508
  var valid_611509 = query.getOrDefault("AllowVersionUpgrade")
  valid_611509 = validateParameter(valid_611509, JBool, required = false, default = nil)
  if valid_611509 != nil:
    section.add "AllowVersionUpgrade", valid_611509
  var valid_611510 = query.getOrDefault("ElasticIp")
  valid_611510 = validateParameter(valid_611510, JString, required = false,
                                 default = nil)
  if valid_611510 != nil:
    section.add "ElasticIp", valid_611510
  var valid_611511 = query.getOrDefault("AutomatedSnapshotRetentionPeriod")
  valid_611511 = validateParameter(valid_611511, JInt, required = false, default = nil)
  if valid_611511 != nil:
    section.add "AutomatedSnapshotRetentionPeriod", valid_611511
  var valid_611512 = query.getOrDefault("EnhancedVpcRouting")
  valid_611512 = validateParameter(valid_611512, JBool, required = false, default = nil)
  if valid_611512 != nil:
    section.add "EnhancedVpcRouting", valid_611512
  var valid_611513 = query.getOrDefault("Action")
  valid_611513 = validateParameter(valid_611513, JString, required = true,
                                 default = newJString("CreateCluster"))
  if valid_611513 != nil:
    section.add "Action", valid_611513
  var valid_611514 = query.getOrDefault("ClusterIdentifier")
  valid_611514 = validateParameter(valid_611514, JString, required = true,
                                 default = nil)
  if valid_611514 != nil:
    section.add "ClusterIdentifier", valid_611514
  var valid_611515 = query.getOrDefault("Port")
  valid_611515 = validateParameter(valid_611515, JInt, required = false, default = nil)
  if valid_611515 != nil:
    section.add "Port", valid_611515
  var valid_611516 = query.getOrDefault("VpcSecurityGroupIds")
  valid_611516 = validateParameter(valid_611516, JArray, required = false,
                                 default = nil)
  if valid_611516 != nil:
    section.add "VpcSecurityGroupIds", valid_611516
  var valid_611517 = query.getOrDefault("MasterUserPassword")
  valid_611517 = validateParameter(valid_611517, JString, required = true,
                                 default = nil)
  if valid_611517 != nil:
    section.add "MasterUserPassword", valid_611517
  var valid_611518 = query.getOrDefault("AvailabilityZone")
  valid_611518 = validateParameter(valid_611518, JString, required = false,
                                 default = nil)
  if valid_611518 != nil:
    section.add "AvailabilityZone", valid_611518
  var valid_611519 = query.getOrDefault("HsmConfigurationIdentifier")
  valid_611519 = validateParameter(valid_611519, JString, required = false,
                                 default = nil)
  if valid_611519 != nil:
    section.add "HsmConfigurationIdentifier", valid_611519
  var valid_611520 = query.getOrDefault("Version")
  valid_611520 = validateParameter(valid_611520, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_611520 != nil:
    section.add "Version", valid_611520
  var valid_611521 = query.getOrDefault("PreferredMaintenanceWindow")
  valid_611521 = validateParameter(valid_611521, JString, required = false,
                                 default = nil)
  if valid_611521 != nil:
    section.add "PreferredMaintenanceWindow", valid_611521
  var valid_611522 = query.getOrDefault("PubliclyAccessible")
  valid_611522 = validateParameter(valid_611522, JBool, required = false, default = nil)
  if valid_611522 != nil:
    section.add "PubliclyAccessible", valid_611522
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_611523 = header.getOrDefault("X-Amz-Signature")
  valid_611523 = validateParameter(valid_611523, JString, required = false,
                                 default = nil)
  if valid_611523 != nil:
    section.add "X-Amz-Signature", valid_611523
  var valid_611524 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_611524 = validateParameter(valid_611524, JString, required = false,
                                 default = nil)
  if valid_611524 != nil:
    section.add "X-Amz-Content-Sha256", valid_611524
  var valid_611525 = header.getOrDefault("X-Amz-Date")
  valid_611525 = validateParameter(valid_611525, JString, required = false,
                                 default = nil)
  if valid_611525 != nil:
    section.add "X-Amz-Date", valid_611525
  var valid_611526 = header.getOrDefault("X-Amz-Credential")
  valid_611526 = validateParameter(valid_611526, JString, required = false,
                                 default = nil)
  if valid_611526 != nil:
    section.add "X-Amz-Credential", valid_611526
  var valid_611527 = header.getOrDefault("X-Amz-Security-Token")
  valid_611527 = validateParameter(valid_611527, JString, required = false,
                                 default = nil)
  if valid_611527 != nil:
    section.add "X-Amz-Security-Token", valid_611527
  var valid_611528 = header.getOrDefault("X-Amz-Algorithm")
  valid_611528 = validateParameter(valid_611528, JString, required = false,
                                 default = nil)
  if valid_611528 != nil:
    section.add "X-Amz-Algorithm", valid_611528
  var valid_611529 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_611529 = validateParameter(valid_611529, JString, required = false,
                                 default = nil)
  if valid_611529 != nil:
    section.add "X-Amz-SignedHeaders", valid_611529
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_611530: Call_GetCreateCluster_611488; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a new cluster with the specified parameters.</p> <p>To create a cluster in Virtual Private Cloud (VPC), you must provide a cluster subnet group name. The cluster subnet group identifies the subnets of your VPC that Amazon Redshift uses when creating the cluster. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_611530.validator(path, query, header, formData, body)
  let scheme = call_611530.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_611530.url(scheme.get, call_611530.host, call_611530.base,
                         call_611530.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_611530, url, valid)

proc call*(call_611531: Call_GetCreateCluster_611488; NodeType: string;
          MasterUsername: string; ClusterIdentifier: string;
          MasterUserPassword: string; ClusterSubnetGroupName: string = "";
          MaintenanceTrackName: string = ""; DBName: string = "";
          Encrypted: bool = false; ManualSnapshotRetentionPeriod: int = 0;
          HsmClientCertificateIdentifier: string = "";
          ClusterSecurityGroups: JsonNode = nil; Tags: JsonNode = nil;
          KmsKeyId: string = ""; ClusterParameterGroupName: string = "";
          ClusterVersion: string = ""; IamRoles: JsonNode = nil;
          SnapshotScheduleIdentifier: string = ""; ClusterType: string = "";
          NumberOfNodes: int = 0; AdditionalInfo: string = "";
          AllowVersionUpgrade: bool = false; ElasticIp: string = "";
          AutomatedSnapshotRetentionPeriod: int = 0;
          EnhancedVpcRouting: bool = false; Action: string = "CreateCluster";
          Port: int = 0; VpcSecurityGroupIds: JsonNode = nil;
          AvailabilityZone: string = ""; HsmConfigurationIdentifier: string = "";
          Version: string = "2012-12-01"; PreferredMaintenanceWindow: string = "";
          PubliclyAccessible: bool = false): Recallable =
  ## getCreateCluster
  ## <p>Creates a new cluster with the specified parameters.</p> <p>To create a cluster in Virtual Private Cloud (VPC), you must provide a cluster subnet group name. The cluster subnet group identifies the subnets of your VPC that Amazon Redshift uses when creating the cluster. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   ClusterSubnetGroupName: string
  ##                         : <p>The name of a cluster subnet group to be associated with this cluster.</p> <p>If this parameter is not provided the resulting cluster will be deployed outside virtual private cloud (VPC).</p>
  ##   MaintenanceTrackName: string
  ##                       : An optional parameter for the name of the maintenance track for the cluster. If you don't provide a maintenance track name, the cluster is assigned to the <code>current</code> track.
  ##   DBName: string
  ##         : <p>The name of the first database to be created when the cluster is created.</p> <p>To create additional databases after the cluster is created, connect to the cluster with a SQL client and use SQL commands to create a database. For more information, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/t_creating_database.html">Create a Database</a> in the Amazon Redshift Database Developer Guide. </p> <p>Default: <code>dev</code> </p> <p>Constraints:</p> <ul> <li> <p>Must contain 1 to 64 alphanumeric characters.</p> </li> <li> <p>Must contain only lowercase letters.</p> </li> <li> <p>Cannot be a word that is reserved by the service. A list of reserved words can be found in <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide. </p> </li> </ul>
  ##   Encrypted: bool
  ##            : <p>If <code>true</code>, the data in the cluster is encrypted at rest. </p> <p>Default: false</p>
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The default number of days to retain a manual snapshot. If the value is -1, the snapshot is retained indefinitely. This setting doesn't change the retention period of existing snapshots.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  ##   HsmClientCertificateIdentifier: string
  ##                                 : Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM.
  ##   ClusterSecurityGroups: JArray
  ##                        : <p>A list of security groups to be associated with this cluster.</p> <p>Default: The default cluster security group for Amazon Redshift.</p>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   KmsKeyId: string
  ##           : The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster.
  ##   ClusterParameterGroupName: string
  ##                            : <p>The name of the parameter group to be associated with this cluster.</p> <p>Default: The default Amazon Redshift cluster parameter group. For information about the default parameter group, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Working with Amazon Redshift Parameter Groups</a> </p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   NodeType: string (required)
  ##           : <p>The node type to be provisioned for the cluster. For information about node types, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#how-many-nodes"> Working with Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p> <p>Valid Values: <code>ds2.xlarge</code> | <code>ds2.8xlarge</code> | <code>dc1.large</code> | <code>dc1.8xlarge</code> | <code>dc2.large</code> | <code>dc2.8xlarge</code> | <code>ra3.16xlarge</code> </p>
  ##   ClusterVersion: string
  ##                 : <p>The version of the Amazon Redshift engine software that you want to deploy on the cluster.</p> <p>The version selected runs on all the nodes in the cluster.</p> <p>Constraints: Only version 1.0 is currently available.</p> <p>Example: <code>1.0</code> </p>
  ##   IamRoles: JArray
  ##           : <p>A list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services. You must supply the IAM roles in their Amazon Resource Name (ARN) format. You can supply up to 10 IAM roles in a single request.</p> <p>A cluster can have up to 10 IAM roles associated with it at any time.</p>
  ##   SnapshotScheduleIdentifier: string
  ##                             : A unique identifier for the snapshot schedule.
  ##   ClusterType: string
  ##              : <p>The type of the cluster. When cluster type is specified as</p> <ul> <li> <p> <code>single-node</code>, the <b>NumberOfNodes</b> parameter is not required.</p> </li> <li> <p> <code>multi-node</code>, the <b>NumberOfNodes</b> parameter is required.</p> </li> </ul> <p>Valid Values: <code>multi-node</code> | <code>single-node</code> </p> <p>Default: <code>multi-node</code> </p>
  ##   NumberOfNodes: int
  ##                : <p>The number of compute nodes in the cluster. This parameter is required when the <b>ClusterType</b> parameter is specified as <code>multi-node</code>. </p> <p>For information about determining how many nodes you need, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#how-many-nodes"> Working with Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p> <p>If you don't specify this parameter, you get a single-node cluster. When requesting a multi-node cluster, you must specify the number of nodes that you want in the cluster.</p> <p>Default: <code>1</code> </p> <p>Constraints: Value must be at least 1 and no more than 100.</p>
  ##   MasterUsername: string (required)
  ##                 : <p>The user name associated with the master user account for the cluster that is being created.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 - 128 alphanumeric characters. The user name can't be <code>PUBLIC</code>.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide. </p> </li> </ul>
  ##   AdditionalInfo: string
  ##                 : Reserved.
  ##   AllowVersionUpgrade: bool
  ##                      : <p>If <code>true</code>, major version upgrades can be applied during the maintenance window to the Amazon Redshift engine that is running on the cluster.</p> <p>When a new major version of the Amazon Redshift engine is released, you can request that the service automatically apply upgrades during the maintenance window to the Amazon Redshift engine that is running on your cluster.</p> <p>Default: <code>true</code> </p>
  ##   ElasticIp: string
  ##            : <p>The Elastic IP (EIP) address for the cluster.</p> <p>Constraints: The cluster must be provisioned in EC2-VPC and publicly-accessible through an Internet gateway. For more information about provisioning clusters in EC2-VPC, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#cluster-platforms">Supported Platforms to Launch Your Cluster</a> in the Amazon Redshift Cluster Management Guide.</p>
  ##   AutomatedSnapshotRetentionPeriod: int
  ##                                   : <p>The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p> <p>Default: <code>1</code> </p> <p>Constraints: Must be a value from 0 to 35.</p>
  ##   EnhancedVpcRouting: bool
  ##                     : <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p> <p>Default: false</p>
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>A unique identifier for the cluster. You use this identifier to refer to the cluster for any subsequent cluster operations such as deleting or modifying. The identifier also appears in the Amazon Redshift console.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul> <p>Example: <code>myexamplecluster</code> </p>
  ##   Port: int
  ##       : <p>The port number on which the cluster accepts incoming connections.</p> <p>The cluster is accessible only via the JDBC and ODBC connection strings. Part of the connection string requires the port on which the cluster will listen for incoming connections.</p> <p>Default: <code>5439</code> </p> <p>Valid Values: <code>1150-65535</code> </p>
  ##   VpcSecurityGroupIds: JArray
  ##                      : <p>A list of Virtual Private Cloud (VPC) security groups to be associated with the cluster.</p> <p>Default: The default VPC security group is associated with the cluster.</p>
  ##   MasterUserPassword: string (required)
  ##                     : <p>The password associated with the master user account for the cluster that is being created.</p> <p>Constraints:</p> <ul> <li> <p>Must be between 8 and 64 characters in length.</p> </li> <li> <p>Must contain at least one uppercase letter.</p> </li> <li> <p>Must contain at least one lowercase letter.</p> </li> <li> <p>Must contain one number.</p> </li> <li> <p>Can be any printable ASCII character (ASCII code 33 to 126) except ' (single quote), " (double quote), \, /, @, or space.</p> </li> </ul>
  ##   AvailabilityZone: string
  ##                   : <p>The EC2 Availability Zone (AZ) in which you want Amazon Redshift to provision the cluster. For example, if you have several EC2 instances running in a specific Availability Zone, then you might want the cluster to be provisioned in the same zone in order to decrease network latency.</p> <p>Default: A random, system-chosen Availability Zone in the region that is specified by the endpoint.</p> <p>Example: <code>us-east-2d</code> </p> <p>Constraint: The specified Availability Zone must be in the same region as the current endpoint.</p>
  ##   HsmConfigurationIdentifier: string
  ##                             : Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
  ##   Version: string (required)
  ##   PreferredMaintenanceWindow: string
  ##                             : <p>The weekly time range (in UTC) during which automated cluster maintenance can occur.</p> <p> Format: <code>ddd:hh24:mi-ddd:hh24:mi</code> </p> <p> Default: A 30-minute window selected at random from an 8-hour block of time per region, occurring on a random day of the week. For more information about the time blocks for each region, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-maintenance-windows">Maintenance Windows</a> in Amazon Redshift Cluster Management Guide.</p> <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p> <p>Constraints: Minimum 30-minute window.</p>
  ##   PubliclyAccessible: bool
  ##                     : If <code>true</code>, the cluster can be accessed from a public network. 
  var query_611532 = newJObject()
  add(query_611532, "ClusterSubnetGroupName", newJString(ClusterSubnetGroupName))
  add(query_611532, "MaintenanceTrackName", newJString(MaintenanceTrackName))
  add(query_611532, "DBName", newJString(DBName))
  add(query_611532, "Encrypted", newJBool(Encrypted))
  add(query_611532, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  add(query_611532, "HsmClientCertificateIdentifier",
      newJString(HsmClientCertificateIdentifier))
  if ClusterSecurityGroups != nil:
    query_611532.add "ClusterSecurityGroups", ClusterSecurityGroups
  if Tags != nil:
    query_611532.add "Tags", Tags
  add(query_611532, "KmsKeyId", newJString(KmsKeyId))
  add(query_611532, "ClusterParameterGroupName",
      newJString(ClusterParameterGroupName))
  add(query_611532, "NodeType", newJString(NodeType))
  add(query_611532, "ClusterVersion", newJString(ClusterVersion))
  if IamRoles != nil:
    query_611532.add "IamRoles", IamRoles
  add(query_611532, "SnapshotScheduleIdentifier",
      newJString(SnapshotScheduleIdentifier))
  add(query_611532, "ClusterType", newJString(ClusterType))
  add(query_611532, "NumberOfNodes", newJInt(NumberOfNodes))
  add(query_611532, "MasterUsername", newJString(MasterUsername))
  add(query_611532, "AdditionalInfo", newJString(AdditionalInfo))
  add(query_611532, "AllowVersionUpgrade", newJBool(AllowVersionUpgrade))
  add(query_611532, "ElasticIp", newJString(ElasticIp))
  add(query_611532, "AutomatedSnapshotRetentionPeriod",
      newJInt(AutomatedSnapshotRetentionPeriod))
  add(query_611532, "EnhancedVpcRouting", newJBool(EnhancedVpcRouting))
  add(query_611532, "Action", newJString(Action))
  add(query_611532, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_611532, "Port", newJInt(Port))
  if VpcSecurityGroupIds != nil:
    query_611532.add "VpcSecurityGroupIds", VpcSecurityGroupIds
  add(query_611532, "MasterUserPassword", newJString(MasterUserPassword))
  add(query_611532, "AvailabilityZone", newJString(AvailabilityZone))
  add(query_611532, "HsmConfigurationIdentifier",
      newJString(HsmConfigurationIdentifier))
  add(query_611532, "Version", newJString(Version))
  add(query_611532, "PreferredMaintenanceWindow",
      newJString(PreferredMaintenanceWindow))
  add(query_611532, "PubliclyAccessible", newJBool(PubliclyAccessible))
  result = call_611531.call(nil, query_611532, nil, nil, nil)

var getCreateCluster* = Call_GetCreateCluster_611488(name: "getCreateCluster",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=CreateCluster", validator: validate_GetCreateCluster_611489,
    base: "/", url: url_GetCreateCluster_611490,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCreateClusterParameterGroup_611598 = ref object of OpenApiRestCall_610642
proc url_PostCreateClusterParameterGroup_611600(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostCreateClusterParameterGroup_611599(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates an Amazon Redshift parameter group.</p> <p>Creating parameter groups is independent of creating clusters. You can associate a cluster with a parameter group when you create the cluster. You can also associate an existing cluster with a parameter group after the cluster is created by using <a>ModifyCluster</a>. </p> <p>Parameters in the parameter group define specific behavior that applies to the databases you create on the cluster. For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_611601 = query.getOrDefault("Action")
  valid_611601 = validateParameter(valid_611601, JString, required = true, default = newJString(
      "CreateClusterParameterGroup"))
  if valid_611601 != nil:
    section.add "Action", valid_611601
  var valid_611602 = query.getOrDefault("Version")
  valid_611602 = validateParameter(valid_611602, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_611602 != nil:
    section.add "Version", valid_611602
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_611603 = header.getOrDefault("X-Amz-Signature")
  valid_611603 = validateParameter(valid_611603, JString, required = false,
                                 default = nil)
  if valid_611603 != nil:
    section.add "X-Amz-Signature", valid_611603
  var valid_611604 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_611604 = validateParameter(valid_611604, JString, required = false,
                                 default = nil)
  if valid_611604 != nil:
    section.add "X-Amz-Content-Sha256", valid_611604
  var valid_611605 = header.getOrDefault("X-Amz-Date")
  valid_611605 = validateParameter(valid_611605, JString, required = false,
                                 default = nil)
  if valid_611605 != nil:
    section.add "X-Amz-Date", valid_611605
  var valid_611606 = header.getOrDefault("X-Amz-Credential")
  valid_611606 = validateParameter(valid_611606, JString, required = false,
                                 default = nil)
  if valid_611606 != nil:
    section.add "X-Amz-Credential", valid_611606
  var valid_611607 = header.getOrDefault("X-Amz-Security-Token")
  valid_611607 = validateParameter(valid_611607, JString, required = false,
                                 default = nil)
  if valid_611607 != nil:
    section.add "X-Amz-Security-Token", valid_611607
  var valid_611608 = header.getOrDefault("X-Amz-Algorithm")
  valid_611608 = validateParameter(valid_611608, JString, required = false,
                                 default = nil)
  if valid_611608 != nil:
    section.add "X-Amz-Algorithm", valid_611608
  var valid_611609 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_611609 = validateParameter(valid_611609, JString, required = false,
                                 default = nil)
  if valid_611609 != nil:
    section.add "X-Amz-SignedHeaders", valid_611609
  result.add "header", section
  ## parameters in `formData` object:
  ##   Description: JString (required)
  ##              : A description of the parameter group.
  ##   ParameterGroupFamily: JString (required)
  ##                       : <p>The Amazon Redshift engine version to which the cluster parameter group applies. The cluster engine version determines the set of parameters.</p> <p>To get a list of valid parameter group family names, you can call <a>DescribeClusterParameterGroups</a>. By default, Amazon Redshift returns a list of all the parameter groups that are owned by your AWS account, including the default parameter groups for each Amazon Redshift engine version. The parameter group family names associated with the default parameter groups provide you the valid values. For example, a valid family name is "redshift-1.0". </p>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   ParameterGroupName: JString (required)
  ##                     : <p>The name of the cluster parameter group.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique withing your AWS account.</p> </li> </ul> <note> <p>This value is stored as a lower-case string.</p> </note>
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `Description` field"
  var valid_611610 = formData.getOrDefault("Description")
  valid_611610 = validateParameter(valid_611610, JString, required = true,
                                 default = nil)
  if valid_611610 != nil:
    section.add "Description", valid_611610
  var valid_611611 = formData.getOrDefault("ParameterGroupFamily")
  valid_611611 = validateParameter(valid_611611, JString, required = true,
                                 default = nil)
  if valid_611611 != nil:
    section.add "ParameterGroupFamily", valid_611611
  var valid_611612 = formData.getOrDefault("Tags")
  valid_611612 = validateParameter(valid_611612, JArray, required = false,
                                 default = nil)
  if valid_611612 != nil:
    section.add "Tags", valid_611612
  var valid_611613 = formData.getOrDefault("ParameterGroupName")
  valid_611613 = validateParameter(valid_611613, JString, required = true,
                                 default = nil)
  if valid_611613 != nil:
    section.add "ParameterGroupName", valid_611613
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_611614: Call_PostCreateClusterParameterGroup_611598;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Creates an Amazon Redshift parameter group.</p> <p>Creating parameter groups is independent of creating clusters. You can associate a cluster with a parameter group when you create the cluster. You can also associate an existing cluster with a parameter group after the cluster is created by using <a>ModifyCluster</a>. </p> <p>Parameters in the parameter group define specific behavior that applies to the databases you create on the cluster. For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_611614.validator(path, query, header, formData, body)
  let scheme = call_611614.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_611614.url(scheme.get, call_611614.host, call_611614.base,
                         call_611614.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_611614, url, valid)

proc call*(call_611615: Call_PostCreateClusterParameterGroup_611598;
          Description: string; ParameterGroupFamily: string;
          ParameterGroupName: string;
          Action: string = "CreateClusterParameterGroup"; Tags: JsonNode = nil;
          Version: string = "2012-12-01"): Recallable =
  ## postCreateClusterParameterGroup
  ## <p>Creates an Amazon Redshift parameter group.</p> <p>Creating parameter groups is independent of creating clusters. You can associate a cluster with a parameter group when you create the cluster. You can also associate an existing cluster with a parameter group after the cluster is created by using <a>ModifyCluster</a>. </p> <p>Parameters in the parameter group define specific behavior that applies to the databases you create on the cluster. For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   Description: string (required)
  ##              : A description of the parameter group.
  ##   ParameterGroupFamily: string (required)
  ##                       : <p>The Amazon Redshift engine version to which the cluster parameter group applies. The cluster engine version determines the set of parameters.</p> <p>To get a list of valid parameter group family names, you can call <a>DescribeClusterParameterGroups</a>. By default, Amazon Redshift returns a list of all the parameter groups that are owned by your AWS account, including the default parameter groups for each Amazon Redshift engine version. The parameter group family names associated with the default parameter groups provide you the valid values. For example, a valid family name is "redshift-1.0". </p>
  ##   Action: string (required)
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   ParameterGroupName: string (required)
  ##                     : <p>The name of the cluster parameter group.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique withing your AWS account.</p> </li> </ul> <note> <p>This value is stored as a lower-case string.</p> </note>
  ##   Version: string (required)
  var query_611616 = newJObject()
  var formData_611617 = newJObject()
  add(formData_611617, "Description", newJString(Description))
  add(formData_611617, "ParameterGroupFamily", newJString(ParameterGroupFamily))
  add(query_611616, "Action", newJString(Action))
  if Tags != nil:
    formData_611617.add "Tags", Tags
  add(formData_611617, "ParameterGroupName", newJString(ParameterGroupName))
  add(query_611616, "Version", newJString(Version))
  result = call_611615.call(nil, query_611616, nil, formData_611617, nil)

var postCreateClusterParameterGroup* = Call_PostCreateClusterParameterGroup_611598(
    name: "postCreateClusterParameterGroup", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=CreateClusterParameterGroup",
    validator: validate_PostCreateClusterParameterGroup_611599, base: "/",
    url: url_PostCreateClusterParameterGroup_611600,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCreateClusterParameterGroup_611579 = ref object of OpenApiRestCall_610642
proc url_GetCreateClusterParameterGroup_611581(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetCreateClusterParameterGroup_611580(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates an Amazon Redshift parameter group.</p> <p>Creating parameter groups is independent of creating clusters. You can associate a cluster with a parameter group when you create the cluster. You can also associate an existing cluster with a parameter group after the cluster is created by using <a>ModifyCluster</a>. </p> <p>Parameters in the parameter group define specific behavior that applies to the databases you create on the cluster. For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   ParameterGroupFamily: JString (required)
  ##                       : <p>The Amazon Redshift engine version to which the cluster parameter group applies. The cluster engine version determines the set of parameters.</p> <p>To get a list of valid parameter group family names, you can call <a>DescribeClusterParameterGroups</a>. By default, Amazon Redshift returns a list of all the parameter groups that are owned by your AWS account, including the default parameter groups for each Amazon Redshift engine version. The parameter group family names associated with the default parameter groups provide you the valid values. For example, a valid family name is "redshift-1.0". </p>
  ##   Action: JString (required)
  ##   Description: JString (required)
  ##              : A description of the parameter group.
  ##   ParameterGroupName: JString (required)
  ##                     : <p>The name of the cluster parameter group.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique withing your AWS account.</p> </li> </ul> <note> <p>This value is stored as a lower-case string.</p> </note>
  ##   Version: JString (required)
  section = newJObject()
  var valid_611582 = query.getOrDefault("Tags")
  valid_611582 = validateParameter(valid_611582, JArray, required = false,
                                 default = nil)
  if valid_611582 != nil:
    section.add "Tags", valid_611582
  assert query != nil, "query argument is necessary due to required `ParameterGroupFamily` field"
  var valid_611583 = query.getOrDefault("ParameterGroupFamily")
  valid_611583 = validateParameter(valid_611583, JString, required = true,
                                 default = nil)
  if valid_611583 != nil:
    section.add "ParameterGroupFamily", valid_611583
  var valid_611584 = query.getOrDefault("Action")
  valid_611584 = validateParameter(valid_611584, JString, required = true, default = newJString(
      "CreateClusterParameterGroup"))
  if valid_611584 != nil:
    section.add "Action", valid_611584
  var valid_611585 = query.getOrDefault("Description")
  valid_611585 = validateParameter(valid_611585, JString, required = true,
                                 default = nil)
  if valid_611585 != nil:
    section.add "Description", valid_611585
  var valid_611586 = query.getOrDefault("ParameterGroupName")
  valid_611586 = validateParameter(valid_611586, JString, required = true,
                                 default = nil)
  if valid_611586 != nil:
    section.add "ParameterGroupName", valid_611586
  var valid_611587 = query.getOrDefault("Version")
  valid_611587 = validateParameter(valid_611587, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_611587 != nil:
    section.add "Version", valid_611587
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_611588 = header.getOrDefault("X-Amz-Signature")
  valid_611588 = validateParameter(valid_611588, JString, required = false,
                                 default = nil)
  if valid_611588 != nil:
    section.add "X-Amz-Signature", valid_611588
  var valid_611589 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_611589 = validateParameter(valid_611589, JString, required = false,
                                 default = nil)
  if valid_611589 != nil:
    section.add "X-Amz-Content-Sha256", valid_611589
  var valid_611590 = header.getOrDefault("X-Amz-Date")
  valid_611590 = validateParameter(valid_611590, JString, required = false,
                                 default = nil)
  if valid_611590 != nil:
    section.add "X-Amz-Date", valid_611590
  var valid_611591 = header.getOrDefault("X-Amz-Credential")
  valid_611591 = validateParameter(valid_611591, JString, required = false,
                                 default = nil)
  if valid_611591 != nil:
    section.add "X-Amz-Credential", valid_611591
  var valid_611592 = header.getOrDefault("X-Amz-Security-Token")
  valid_611592 = validateParameter(valid_611592, JString, required = false,
                                 default = nil)
  if valid_611592 != nil:
    section.add "X-Amz-Security-Token", valid_611592
  var valid_611593 = header.getOrDefault("X-Amz-Algorithm")
  valid_611593 = validateParameter(valid_611593, JString, required = false,
                                 default = nil)
  if valid_611593 != nil:
    section.add "X-Amz-Algorithm", valid_611593
  var valid_611594 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_611594 = validateParameter(valid_611594, JString, required = false,
                                 default = nil)
  if valid_611594 != nil:
    section.add "X-Amz-SignedHeaders", valid_611594
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_611595: Call_GetCreateClusterParameterGroup_611579; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates an Amazon Redshift parameter group.</p> <p>Creating parameter groups is independent of creating clusters. You can associate a cluster with a parameter group when you create the cluster. You can also associate an existing cluster with a parameter group after the cluster is created by using <a>ModifyCluster</a>. </p> <p>Parameters in the parameter group define specific behavior that applies to the databases you create on the cluster. For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_611595.validator(path, query, header, formData, body)
  let scheme = call_611595.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_611595.url(scheme.get, call_611595.host, call_611595.base,
                         call_611595.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_611595, url, valid)

proc call*(call_611596: Call_GetCreateClusterParameterGroup_611579;
          ParameterGroupFamily: string; Description: string;
          ParameterGroupName: string; Tags: JsonNode = nil;
          Action: string = "CreateClusterParameterGroup";
          Version: string = "2012-12-01"): Recallable =
  ## getCreateClusterParameterGroup
  ## <p>Creates an Amazon Redshift parameter group.</p> <p>Creating parameter groups is independent of creating clusters. You can associate a cluster with a parameter group when you create the cluster. You can also associate an existing cluster with a parameter group after the cluster is created by using <a>ModifyCluster</a>. </p> <p>Parameters in the parameter group define specific behavior that applies to the databases you create on the cluster. For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   ParameterGroupFamily: string (required)
  ##                       : <p>The Amazon Redshift engine version to which the cluster parameter group applies. The cluster engine version determines the set of parameters.</p> <p>To get a list of valid parameter group family names, you can call <a>DescribeClusterParameterGroups</a>. By default, Amazon Redshift returns a list of all the parameter groups that are owned by your AWS account, including the default parameter groups for each Amazon Redshift engine version. The parameter group family names associated with the default parameter groups provide you the valid values. For example, a valid family name is "redshift-1.0". </p>
  ##   Action: string (required)
  ##   Description: string (required)
  ##              : A description of the parameter group.
  ##   ParameterGroupName: string (required)
  ##                     : <p>The name of the cluster parameter group.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique withing your AWS account.</p> </li> </ul> <note> <p>This value is stored as a lower-case string.</p> </note>
  ##   Version: string (required)
  var query_611597 = newJObject()
  if Tags != nil:
    query_611597.add "Tags", Tags
  add(query_611597, "ParameterGroupFamily", newJString(ParameterGroupFamily))
  add(query_611597, "Action", newJString(Action))
  add(query_611597, "Description", newJString(Description))
  add(query_611597, "ParameterGroupName", newJString(ParameterGroupName))
  add(query_611597, "Version", newJString(Version))
  result = call_611596.call(nil, query_611597, nil, nil, nil)

var getCreateClusterParameterGroup* = Call_GetCreateClusterParameterGroup_611579(
    name: "getCreateClusterParameterGroup", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=CreateClusterParameterGroup",
    validator: validate_GetCreateClusterParameterGroup_611580, base: "/",
    url: url_GetCreateClusterParameterGroup_611581,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCreateClusterSecurityGroup_611636 = ref object of OpenApiRestCall_610642
proc url_PostCreateClusterSecurityGroup_611638(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostCreateClusterSecurityGroup_611637(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a new Amazon Redshift security group. You use security groups to control access to non-VPC clusters.</p> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_611639 = query.getOrDefault("Action")
  valid_611639 = validateParameter(valid_611639, JString, required = true, default = newJString(
      "CreateClusterSecurityGroup"))
  if valid_611639 != nil:
    section.add "Action", valid_611639
  var valid_611640 = query.getOrDefault("Version")
  valid_611640 = validateParameter(valid_611640, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_611640 != nil:
    section.add "Version", valid_611640
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_611641 = header.getOrDefault("X-Amz-Signature")
  valid_611641 = validateParameter(valid_611641, JString, required = false,
                                 default = nil)
  if valid_611641 != nil:
    section.add "X-Amz-Signature", valid_611641
  var valid_611642 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_611642 = validateParameter(valid_611642, JString, required = false,
                                 default = nil)
  if valid_611642 != nil:
    section.add "X-Amz-Content-Sha256", valid_611642
  var valid_611643 = header.getOrDefault("X-Amz-Date")
  valid_611643 = validateParameter(valid_611643, JString, required = false,
                                 default = nil)
  if valid_611643 != nil:
    section.add "X-Amz-Date", valid_611643
  var valid_611644 = header.getOrDefault("X-Amz-Credential")
  valid_611644 = validateParameter(valid_611644, JString, required = false,
                                 default = nil)
  if valid_611644 != nil:
    section.add "X-Amz-Credential", valid_611644
  var valid_611645 = header.getOrDefault("X-Amz-Security-Token")
  valid_611645 = validateParameter(valid_611645, JString, required = false,
                                 default = nil)
  if valid_611645 != nil:
    section.add "X-Amz-Security-Token", valid_611645
  var valid_611646 = header.getOrDefault("X-Amz-Algorithm")
  valid_611646 = validateParameter(valid_611646, JString, required = false,
                                 default = nil)
  if valid_611646 != nil:
    section.add "X-Amz-Algorithm", valid_611646
  var valid_611647 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_611647 = validateParameter(valid_611647, JString, required = false,
                                 default = nil)
  if valid_611647 != nil:
    section.add "X-Amz-SignedHeaders", valid_611647
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterSecurityGroupName: JString (required)
  ##                           : <p>The name for the security group. Amazon Redshift stores the value as a lowercase string.</p> <p>Constraints:</p> <ul> <li> <p>Must contain no more than 255 alphanumeric characters or hyphens.</p> </li> <li> <p>Must not be "Default".</p> </li> <li> <p>Must be unique for all security groups that are created by your AWS account.</p> </li> </ul> <p>Example: <code>examplesecuritygroup</code> </p>
  ##   Description: JString (required)
  ##              : A description for the security group.
  ##   Tags: JArray
  ##       : A list of tag instances.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterSecurityGroupName` field"
  var valid_611648 = formData.getOrDefault("ClusterSecurityGroupName")
  valid_611648 = validateParameter(valid_611648, JString, required = true,
                                 default = nil)
  if valid_611648 != nil:
    section.add "ClusterSecurityGroupName", valid_611648
  var valid_611649 = formData.getOrDefault("Description")
  valid_611649 = validateParameter(valid_611649, JString, required = true,
                                 default = nil)
  if valid_611649 != nil:
    section.add "Description", valid_611649
  var valid_611650 = formData.getOrDefault("Tags")
  valid_611650 = validateParameter(valid_611650, JArray, required = false,
                                 default = nil)
  if valid_611650 != nil:
    section.add "Tags", valid_611650
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_611651: Call_PostCreateClusterSecurityGroup_611636; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a new Amazon Redshift security group. You use security groups to control access to non-VPC clusters.</p> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_611651.validator(path, query, header, formData, body)
  let scheme = call_611651.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_611651.url(scheme.get, call_611651.host, call_611651.base,
                         call_611651.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_611651, url, valid)

proc call*(call_611652: Call_PostCreateClusterSecurityGroup_611636;
          ClusterSecurityGroupName: string; Description: string;
          Action: string = "CreateClusterSecurityGroup"; Tags: JsonNode = nil;
          Version: string = "2012-12-01"): Recallable =
  ## postCreateClusterSecurityGroup
  ## <p>Creates a new Amazon Redshift security group. You use security groups to control access to non-VPC clusters.</p> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   ClusterSecurityGroupName: string (required)
  ##                           : <p>The name for the security group. Amazon Redshift stores the value as a lowercase string.</p> <p>Constraints:</p> <ul> <li> <p>Must contain no more than 255 alphanumeric characters or hyphens.</p> </li> <li> <p>Must not be "Default".</p> </li> <li> <p>Must be unique for all security groups that are created by your AWS account.</p> </li> </ul> <p>Example: <code>examplesecuritygroup</code> </p>
  ##   Description: string (required)
  ##              : A description for the security group.
  ##   Action: string (required)
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Version: string (required)
  var query_611653 = newJObject()
  var formData_611654 = newJObject()
  add(formData_611654, "ClusterSecurityGroupName",
      newJString(ClusterSecurityGroupName))
  add(formData_611654, "Description", newJString(Description))
  add(query_611653, "Action", newJString(Action))
  if Tags != nil:
    formData_611654.add "Tags", Tags
  add(query_611653, "Version", newJString(Version))
  result = call_611652.call(nil, query_611653, nil, formData_611654, nil)

var postCreateClusterSecurityGroup* = Call_PostCreateClusterSecurityGroup_611636(
    name: "postCreateClusterSecurityGroup", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=CreateClusterSecurityGroup",
    validator: validate_PostCreateClusterSecurityGroup_611637, base: "/",
    url: url_PostCreateClusterSecurityGroup_611638,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCreateClusterSecurityGroup_611618 = ref object of OpenApiRestCall_610642
proc url_GetCreateClusterSecurityGroup_611620(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetCreateClusterSecurityGroup_611619(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a new Amazon Redshift security group. You use security groups to control access to non-VPC clusters.</p> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   ClusterSecurityGroupName: JString (required)
  ##                           : <p>The name for the security group. Amazon Redshift stores the value as a lowercase string.</p> <p>Constraints:</p> <ul> <li> <p>Must contain no more than 255 alphanumeric characters or hyphens.</p> </li> <li> <p>Must not be "Default".</p> </li> <li> <p>Must be unique for all security groups that are created by your AWS account.</p> </li> </ul> <p>Example: <code>examplesecuritygroup</code> </p>
  ##   Action: JString (required)
  ##   Description: JString (required)
  ##              : A description for the security group.
  ##   Version: JString (required)
  section = newJObject()
  var valid_611621 = query.getOrDefault("Tags")
  valid_611621 = validateParameter(valid_611621, JArray, required = false,
                                 default = nil)
  if valid_611621 != nil:
    section.add "Tags", valid_611621
  assert query != nil, "query argument is necessary due to required `ClusterSecurityGroupName` field"
  var valid_611622 = query.getOrDefault("ClusterSecurityGroupName")
  valid_611622 = validateParameter(valid_611622, JString, required = true,
                                 default = nil)
  if valid_611622 != nil:
    section.add "ClusterSecurityGroupName", valid_611622
  var valid_611623 = query.getOrDefault("Action")
  valid_611623 = validateParameter(valid_611623, JString, required = true, default = newJString(
      "CreateClusterSecurityGroup"))
  if valid_611623 != nil:
    section.add "Action", valid_611623
  var valid_611624 = query.getOrDefault("Description")
  valid_611624 = validateParameter(valid_611624, JString, required = true,
                                 default = nil)
  if valid_611624 != nil:
    section.add "Description", valid_611624
  var valid_611625 = query.getOrDefault("Version")
  valid_611625 = validateParameter(valid_611625, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_611625 != nil:
    section.add "Version", valid_611625
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_611626 = header.getOrDefault("X-Amz-Signature")
  valid_611626 = validateParameter(valid_611626, JString, required = false,
                                 default = nil)
  if valid_611626 != nil:
    section.add "X-Amz-Signature", valid_611626
  var valid_611627 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_611627 = validateParameter(valid_611627, JString, required = false,
                                 default = nil)
  if valid_611627 != nil:
    section.add "X-Amz-Content-Sha256", valid_611627
  var valid_611628 = header.getOrDefault("X-Amz-Date")
  valid_611628 = validateParameter(valid_611628, JString, required = false,
                                 default = nil)
  if valid_611628 != nil:
    section.add "X-Amz-Date", valid_611628
  var valid_611629 = header.getOrDefault("X-Amz-Credential")
  valid_611629 = validateParameter(valid_611629, JString, required = false,
                                 default = nil)
  if valid_611629 != nil:
    section.add "X-Amz-Credential", valid_611629
  var valid_611630 = header.getOrDefault("X-Amz-Security-Token")
  valid_611630 = validateParameter(valid_611630, JString, required = false,
                                 default = nil)
  if valid_611630 != nil:
    section.add "X-Amz-Security-Token", valid_611630
  var valid_611631 = header.getOrDefault("X-Amz-Algorithm")
  valid_611631 = validateParameter(valid_611631, JString, required = false,
                                 default = nil)
  if valid_611631 != nil:
    section.add "X-Amz-Algorithm", valid_611631
  var valid_611632 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_611632 = validateParameter(valid_611632, JString, required = false,
                                 default = nil)
  if valid_611632 != nil:
    section.add "X-Amz-SignedHeaders", valid_611632
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_611633: Call_GetCreateClusterSecurityGroup_611618; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a new Amazon Redshift security group. You use security groups to control access to non-VPC clusters.</p> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_611633.validator(path, query, header, formData, body)
  let scheme = call_611633.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_611633.url(scheme.get, call_611633.host, call_611633.base,
                         call_611633.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_611633, url, valid)

proc call*(call_611634: Call_GetCreateClusterSecurityGroup_611618;
          ClusterSecurityGroupName: string; Description: string;
          Tags: JsonNode = nil; Action: string = "CreateClusterSecurityGroup";
          Version: string = "2012-12-01"): Recallable =
  ## getCreateClusterSecurityGroup
  ## <p>Creates a new Amazon Redshift security group. You use security groups to control access to non-VPC clusters.</p> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   ClusterSecurityGroupName: string (required)
  ##                           : <p>The name for the security group. Amazon Redshift stores the value as a lowercase string.</p> <p>Constraints:</p> <ul> <li> <p>Must contain no more than 255 alphanumeric characters or hyphens.</p> </li> <li> <p>Must not be "Default".</p> </li> <li> <p>Must be unique for all security groups that are created by your AWS account.</p> </li> </ul> <p>Example: <code>examplesecuritygroup</code> </p>
  ##   Action: string (required)
  ##   Description: string (required)
  ##              : A description for the security group.
  ##   Version: string (required)
  var query_611635 = newJObject()
  if Tags != nil:
    query_611635.add "Tags", Tags
  add(query_611635, "ClusterSecurityGroupName",
      newJString(ClusterSecurityGroupName))
  add(query_611635, "Action", newJString(Action))
  add(query_611635, "Description", newJString(Description))
  add(query_611635, "Version", newJString(Version))
  result = call_611634.call(nil, query_611635, nil, nil, nil)

var getCreateClusterSecurityGroup* = Call_GetCreateClusterSecurityGroup_611618(
    name: "getCreateClusterSecurityGroup", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=CreateClusterSecurityGroup",
    validator: validate_GetCreateClusterSecurityGroup_611619, base: "/",
    url: url_GetCreateClusterSecurityGroup_611620,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCreateClusterSnapshot_611674 = ref object of OpenApiRestCall_610642
proc url_PostCreateClusterSnapshot_611676(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostCreateClusterSnapshot_611675(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a manual snapshot of the specified cluster. The cluster must be in the <code>available</code> state. </p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_611677 = query.getOrDefault("Action")
  valid_611677 = validateParameter(valid_611677, JString, required = true,
                                 default = newJString("CreateClusterSnapshot"))
  if valid_611677 != nil:
    section.add "Action", valid_611677
  var valid_611678 = query.getOrDefault("Version")
  valid_611678 = validateParameter(valid_611678, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_611678 != nil:
    section.add "Version", valid_611678
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_611679 = header.getOrDefault("X-Amz-Signature")
  valid_611679 = validateParameter(valid_611679, JString, required = false,
                                 default = nil)
  if valid_611679 != nil:
    section.add "X-Amz-Signature", valid_611679
  var valid_611680 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_611680 = validateParameter(valid_611680, JString, required = false,
                                 default = nil)
  if valid_611680 != nil:
    section.add "X-Amz-Content-Sha256", valid_611680
  var valid_611681 = header.getOrDefault("X-Amz-Date")
  valid_611681 = validateParameter(valid_611681, JString, required = false,
                                 default = nil)
  if valid_611681 != nil:
    section.add "X-Amz-Date", valid_611681
  var valid_611682 = header.getOrDefault("X-Amz-Credential")
  valid_611682 = validateParameter(valid_611682, JString, required = false,
                                 default = nil)
  if valid_611682 != nil:
    section.add "X-Amz-Credential", valid_611682
  var valid_611683 = header.getOrDefault("X-Amz-Security-Token")
  valid_611683 = validateParameter(valid_611683, JString, required = false,
                                 default = nil)
  if valid_611683 != nil:
    section.add "X-Amz-Security-Token", valid_611683
  var valid_611684 = header.getOrDefault("X-Amz-Algorithm")
  valid_611684 = validateParameter(valid_611684, JString, required = false,
                                 default = nil)
  if valid_611684 != nil:
    section.add "X-Amz-Algorithm", valid_611684
  var valid_611685 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_611685 = validateParameter(valid_611685, JString, required = false,
                                 default = nil)
  if valid_611685 != nil:
    section.add "X-Amz-SignedHeaders", valid_611685
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : The cluster identifier for which you want a snapshot.
  ##   SnapshotIdentifier: JString (required)
  ##                     : <p>A unique identifier for the snapshot that you are requesting. This identifier must be unique for all snapshots within the AWS account.</p> <p>Constraints:</p> <ul> <li> <p>Cannot be null, empty, or blank</p> </li> <li> <p>Must contain from 1 to 255 alphanumeric characters or hyphens</p> </li> <li> <p>First character must be a letter</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens</p> </li> </ul> <p>Example: <code>my-snapshot-id</code> </p>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. </p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_611686 = formData.getOrDefault("ClusterIdentifier")
  valid_611686 = validateParameter(valid_611686, JString, required = true,
                                 default = nil)
  if valid_611686 != nil:
    section.add "ClusterIdentifier", valid_611686
  var valid_611687 = formData.getOrDefault("SnapshotIdentifier")
  valid_611687 = validateParameter(valid_611687, JString, required = true,
                                 default = nil)
  if valid_611687 != nil:
    section.add "SnapshotIdentifier", valid_611687
  var valid_611688 = formData.getOrDefault("Tags")
  valid_611688 = validateParameter(valid_611688, JArray, required = false,
                                 default = nil)
  if valid_611688 != nil:
    section.add "Tags", valid_611688
  var valid_611689 = formData.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_611689 = validateParameter(valid_611689, JInt, required = false, default = nil)
  if valid_611689 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_611689
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_611690: Call_PostCreateClusterSnapshot_611674; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a manual snapshot of the specified cluster. The cluster must be in the <code>available</code> state. </p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_611690.validator(path, query, header, formData, body)
  let scheme = call_611690.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_611690.url(scheme.get, call_611690.host, call_611690.base,
                         call_611690.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_611690, url, valid)

proc call*(call_611691: Call_PostCreateClusterSnapshot_611674;
          ClusterIdentifier: string; SnapshotIdentifier: string;
          Action: string = "CreateClusterSnapshot"; Tags: JsonNode = nil;
          Version: string = "2012-12-01"; ManualSnapshotRetentionPeriod: int = 0): Recallable =
  ## postCreateClusterSnapshot
  ## <p>Creates a manual snapshot of the specified cluster. The cluster must be in the <code>available</code> state. </p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   ClusterIdentifier: string (required)
  ##                    : The cluster identifier for which you want a snapshot.
  ##   SnapshotIdentifier: string (required)
  ##                     : <p>A unique identifier for the snapshot that you are requesting. This identifier must be unique for all snapshots within the AWS account.</p> <p>Constraints:</p> <ul> <li> <p>Cannot be null, empty, or blank</p> </li> <li> <p>Must contain from 1 to 255 alphanumeric characters or hyphens</p> </li> <li> <p>First character must be a letter</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens</p> </li> </ul> <p>Example: <code>my-snapshot-id</code> </p>
  ##   Action: string (required)
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Version: string (required)
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. </p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  var query_611692 = newJObject()
  var formData_611693 = newJObject()
  add(formData_611693, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_611693, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_611692, "Action", newJString(Action))
  if Tags != nil:
    formData_611693.add "Tags", Tags
  add(query_611692, "Version", newJString(Version))
  add(formData_611693, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  result = call_611691.call(nil, query_611692, nil, formData_611693, nil)

var postCreateClusterSnapshot* = Call_PostCreateClusterSnapshot_611674(
    name: "postCreateClusterSnapshot", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=CreateClusterSnapshot",
    validator: validate_PostCreateClusterSnapshot_611675, base: "/",
    url: url_PostCreateClusterSnapshot_611676,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCreateClusterSnapshot_611655 = ref object of OpenApiRestCall_610642
proc url_GetCreateClusterSnapshot_611657(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetCreateClusterSnapshot_611656(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a manual snapshot of the specified cluster. The cluster must be in the <code>available</code> state. </p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   SnapshotIdentifier: JString (required)
  ##                     : <p>A unique identifier for the snapshot that you are requesting. This identifier must be unique for all snapshots within the AWS account.</p> <p>Constraints:</p> <ul> <li> <p>Cannot be null, empty, or blank</p> </li> <li> <p>Must contain from 1 to 255 alphanumeric characters or hyphens</p> </li> <li> <p>First character must be a letter</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens</p> </li> </ul> <p>Example: <code>my-snapshot-id</code> </p>
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. </p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : The cluster identifier for which you want a snapshot.
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `SnapshotIdentifier` field"
  var valid_611658 = query.getOrDefault("SnapshotIdentifier")
  valid_611658 = validateParameter(valid_611658, JString, required = true,
                                 default = nil)
  if valid_611658 != nil:
    section.add "SnapshotIdentifier", valid_611658
  var valid_611659 = query.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_611659 = validateParameter(valid_611659, JInt, required = false, default = nil)
  if valid_611659 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_611659
  var valid_611660 = query.getOrDefault("Tags")
  valid_611660 = validateParameter(valid_611660, JArray, required = false,
                                 default = nil)
  if valid_611660 != nil:
    section.add "Tags", valid_611660
  var valid_611661 = query.getOrDefault("Action")
  valid_611661 = validateParameter(valid_611661, JString, required = true,
                                 default = newJString("CreateClusterSnapshot"))
  if valid_611661 != nil:
    section.add "Action", valid_611661
  var valid_611662 = query.getOrDefault("ClusterIdentifier")
  valid_611662 = validateParameter(valid_611662, JString, required = true,
                                 default = nil)
  if valid_611662 != nil:
    section.add "ClusterIdentifier", valid_611662
  var valid_611663 = query.getOrDefault("Version")
  valid_611663 = validateParameter(valid_611663, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_611663 != nil:
    section.add "Version", valid_611663
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_611664 = header.getOrDefault("X-Amz-Signature")
  valid_611664 = validateParameter(valid_611664, JString, required = false,
                                 default = nil)
  if valid_611664 != nil:
    section.add "X-Amz-Signature", valid_611664
  var valid_611665 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_611665 = validateParameter(valid_611665, JString, required = false,
                                 default = nil)
  if valid_611665 != nil:
    section.add "X-Amz-Content-Sha256", valid_611665
  var valid_611666 = header.getOrDefault("X-Amz-Date")
  valid_611666 = validateParameter(valid_611666, JString, required = false,
                                 default = nil)
  if valid_611666 != nil:
    section.add "X-Amz-Date", valid_611666
  var valid_611667 = header.getOrDefault("X-Amz-Credential")
  valid_611667 = validateParameter(valid_611667, JString, required = false,
                                 default = nil)
  if valid_611667 != nil:
    section.add "X-Amz-Credential", valid_611667
  var valid_611668 = header.getOrDefault("X-Amz-Security-Token")
  valid_611668 = validateParameter(valid_611668, JString, required = false,
                                 default = nil)
  if valid_611668 != nil:
    section.add "X-Amz-Security-Token", valid_611668
  var valid_611669 = header.getOrDefault("X-Amz-Algorithm")
  valid_611669 = validateParameter(valid_611669, JString, required = false,
                                 default = nil)
  if valid_611669 != nil:
    section.add "X-Amz-Algorithm", valid_611669
  var valid_611670 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_611670 = validateParameter(valid_611670, JString, required = false,
                                 default = nil)
  if valid_611670 != nil:
    section.add "X-Amz-SignedHeaders", valid_611670
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_611671: Call_GetCreateClusterSnapshot_611655; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a manual snapshot of the specified cluster. The cluster must be in the <code>available</code> state. </p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_611671.validator(path, query, header, formData, body)
  let scheme = call_611671.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_611671.url(scheme.get, call_611671.host, call_611671.base,
                         call_611671.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_611671, url, valid)

proc call*(call_611672: Call_GetCreateClusterSnapshot_611655;
          SnapshotIdentifier: string; ClusterIdentifier: string;
          ManualSnapshotRetentionPeriod: int = 0; Tags: JsonNode = nil;
          Action: string = "CreateClusterSnapshot"; Version: string = "2012-12-01"): Recallable =
  ## getCreateClusterSnapshot
  ## <p>Creates a manual snapshot of the specified cluster. The cluster must be in the <code>available</code> state. </p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   SnapshotIdentifier: string (required)
  ##                     : <p>A unique identifier for the snapshot that you are requesting. This identifier must be unique for all snapshots within the AWS account.</p> <p>Constraints:</p> <ul> <li> <p>Cannot be null, empty, or blank</p> </li> <li> <p>Must contain from 1 to 255 alphanumeric characters or hyphens</p> </li> <li> <p>First character must be a letter</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens</p> </li> </ul> <p>Example: <code>my-snapshot-id</code> </p>
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. </p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : The cluster identifier for which you want a snapshot.
  ##   Version: string (required)
  var query_611673 = newJObject()
  add(query_611673, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_611673, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  if Tags != nil:
    query_611673.add "Tags", Tags
  add(query_611673, "Action", newJString(Action))
  add(query_611673, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_611673, "Version", newJString(Version))
  result = call_611672.call(nil, query_611673, nil, nil, nil)

var getCreateClusterSnapshot* = Call_GetCreateClusterSnapshot_611655(
    name: "getCreateClusterSnapshot", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=CreateClusterSnapshot",
    validator: validate_GetCreateClusterSnapshot_611656, base: "/",
    url: url_GetCreateClusterSnapshot_611657, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCreateClusterSubnetGroup_611713 = ref object of OpenApiRestCall_610642
proc url_PostCreateClusterSubnetGroup_611715(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostCreateClusterSubnetGroup_611714(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a new Amazon Redshift subnet group. You must provide a list of one or more subnets in your existing Amazon Virtual Private Cloud (Amazon VPC) when creating Amazon Redshift subnet group.</p> <p> For information about subnet groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-cluster-subnet-groups.html">Amazon Redshift Cluster Subnet Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_611716 = query.getOrDefault("Action")
  valid_611716 = validateParameter(valid_611716, JString, required = true, default = newJString(
      "CreateClusterSubnetGroup"))
  if valid_611716 != nil:
    section.add "Action", valid_611716
  var valid_611717 = query.getOrDefault("Version")
  valid_611717 = validateParameter(valid_611717, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_611717 != nil:
    section.add "Version", valid_611717
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_611718 = header.getOrDefault("X-Amz-Signature")
  valid_611718 = validateParameter(valid_611718, JString, required = false,
                                 default = nil)
  if valid_611718 != nil:
    section.add "X-Amz-Signature", valid_611718
  var valid_611719 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_611719 = validateParameter(valid_611719, JString, required = false,
                                 default = nil)
  if valid_611719 != nil:
    section.add "X-Amz-Content-Sha256", valid_611719
  var valid_611720 = header.getOrDefault("X-Amz-Date")
  valid_611720 = validateParameter(valid_611720, JString, required = false,
                                 default = nil)
  if valid_611720 != nil:
    section.add "X-Amz-Date", valid_611720
  var valid_611721 = header.getOrDefault("X-Amz-Credential")
  valid_611721 = validateParameter(valid_611721, JString, required = false,
                                 default = nil)
  if valid_611721 != nil:
    section.add "X-Amz-Credential", valid_611721
  var valid_611722 = header.getOrDefault("X-Amz-Security-Token")
  valid_611722 = validateParameter(valid_611722, JString, required = false,
                                 default = nil)
  if valid_611722 != nil:
    section.add "X-Amz-Security-Token", valid_611722
  var valid_611723 = header.getOrDefault("X-Amz-Algorithm")
  valid_611723 = validateParameter(valid_611723, JString, required = false,
                                 default = nil)
  if valid_611723 != nil:
    section.add "X-Amz-Algorithm", valid_611723
  var valid_611724 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_611724 = validateParameter(valid_611724, JString, required = false,
                                 default = nil)
  if valid_611724 != nil:
    section.add "X-Amz-SignedHeaders", valid_611724
  result.add "header", section
  ## parameters in `formData` object:
  ##   Description: JString (required)
  ##              : A description for the subnet group.
  ##   ClusterSubnetGroupName: JString (required)
  ##                         : <p>The name for the subnet group. Amazon Redshift stores the value as a lowercase string.</p> <p>Constraints:</p> <ul> <li> <p>Must contain no more than 255 alphanumeric characters or hyphens.</p> </li> <li> <p>Must not be "Default".</p> </li> <li> <p>Must be unique for all subnet groups that are created by your AWS account.</p> </li> </ul> <p>Example: <code>examplesubnetgroup</code> </p>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   SubnetIds: JArray (required)
  ##            : An array of VPC subnet IDs. A maximum of 20 subnets can be modified in a single request.
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `Description` field"
  var valid_611725 = formData.getOrDefault("Description")
  valid_611725 = validateParameter(valid_611725, JString, required = true,
                                 default = nil)
  if valid_611725 != nil:
    section.add "Description", valid_611725
  var valid_611726 = formData.getOrDefault("ClusterSubnetGroupName")
  valid_611726 = validateParameter(valid_611726, JString, required = true,
                                 default = nil)
  if valid_611726 != nil:
    section.add "ClusterSubnetGroupName", valid_611726
  var valid_611727 = formData.getOrDefault("Tags")
  valid_611727 = validateParameter(valid_611727, JArray, required = false,
                                 default = nil)
  if valid_611727 != nil:
    section.add "Tags", valid_611727
  var valid_611728 = formData.getOrDefault("SubnetIds")
  valid_611728 = validateParameter(valid_611728, JArray, required = true, default = nil)
  if valid_611728 != nil:
    section.add "SubnetIds", valid_611728
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_611729: Call_PostCreateClusterSubnetGroup_611713; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a new Amazon Redshift subnet group. You must provide a list of one or more subnets in your existing Amazon Virtual Private Cloud (Amazon VPC) when creating Amazon Redshift subnet group.</p> <p> For information about subnet groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-cluster-subnet-groups.html">Amazon Redshift Cluster Subnet Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_611729.validator(path, query, header, formData, body)
  let scheme = call_611729.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_611729.url(scheme.get, call_611729.host, call_611729.base,
                         call_611729.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_611729, url, valid)

proc call*(call_611730: Call_PostCreateClusterSubnetGroup_611713;
          Description: string; ClusterSubnetGroupName: string; SubnetIds: JsonNode;
          Action: string = "CreateClusterSubnetGroup"; Tags: JsonNode = nil;
          Version: string = "2012-12-01"): Recallable =
  ## postCreateClusterSubnetGroup
  ## <p>Creates a new Amazon Redshift subnet group. You must provide a list of one or more subnets in your existing Amazon Virtual Private Cloud (Amazon VPC) when creating Amazon Redshift subnet group.</p> <p> For information about subnet groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-cluster-subnet-groups.html">Amazon Redshift Cluster Subnet Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   Description: string (required)
  ##              : A description for the subnet group.
  ##   ClusterSubnetGroupName: string (required)
  ##                         : <p>The name for the subnet group. Amazon Redshift stores the value as a lowercase string.</p> <p>Constraints:</p> <ul> <li> <p>Must contain no more than 255 alphanumeric characters or hyphens.</p> </li> <li> <p>Must not be "Default".</p> </li> <li> <p>Must be unique for all subnet groups that are created by your AWS account.</p> </li> </ul> <p>Example: <code>examplesubnetgroup</code> </p>
  ##   Action: string (required)
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Version: string (required)
  ##   SubnetIds: JArray (required)
  ##            : An array of VPC subnet IDs. A maximum of 20 subnets can be modified in a single request.
  var query_611731 = newJObject()
  var formData_611732 = newJObject()
  add(formData_611732, "Description", newJString(Description))
  add(formData_611732, "ClusterSubnetGroupName",
      newJString(ClusterSubnetGroupName))
  add(query_611731, "Action", newJString(Action))
  if Tags != nil:
    formData_611732.add "Tags", Tags
  add(query_611731, "Version", newJString(Version))
  if SubnetIds != nil:
    formData_611732.add "SubnetIds", SubnetIds
  result = call_611730.call(nil, query_611731, nil, formData_611732, nil)

var postCreateClusterSubnetGroup* = Call_PostCreateClusterSubnetGroup_611713(
    name: "postCreateClusterSubnetGroup", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=CreateClusterSubnetGroup",
    validator: validate_PostCreateClusterSubnetGroup_611714, base: "/",
    url: url_PostCreateClusterSubnetGroup_611715,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCreateClusterSubnetGroup_611694 = ref object of OpenApiRestCall_610642
proc url_GetCreateClusterSubnetGroup_611696(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetCreateClusterSubnetGroup_611695(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a new Amazon Redshift subnet group. You must provide a list of one or more subnets in your existing Amazon Virtual Private Cloud (Amazon VPC) when creating Amazon Redshift subnet group.</p> <p> For information about subnet groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-cluster-subnet-groups.html">Amazon Redshift Cluster Subnet Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ClusterSubnetGroupName: JString (required)
  ##                         : <p>The name for the subnet group. Amazon Redshift stores the value as a lowercase string.</p> <p>Constraints:</p> <ul> <li> <p>Must contain no more than 255 alphanumeric characters or hyphens.</p> </li> <li> <p>Must not be "Default".</p> </li> <li> <p>Must be unique for all subnet groups that are created by your AWS account.</p> </li> </ul> <p>Example: <code>examplesubnetgroup</code> </p>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   SubnetIds: JArray (required)
  ##            : An array of VPC subnet IDs. A maximum of 20 subnets can be modified in a single request.
  ##   Action: JString (required)
  ##   Description: JString (required)
  ##              : A description for the subnet group.
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `ClusterSubnetGroupName` field"
  var valid_611697 = query.getOrDefault("ClusterSubnetGroupName")
  valid_611697 = validateParameter(valid_611697, JString, required = true,
                                 default = nil)
  if valid_611697 != nil:
    section.add "ClusterSubnetGroupName", valid_611697
  var valid_611698 = query.getOrDefault("Tags")
  valid_611698 = validateParameter(valid_611698, JArray, required = false,
                                 default = nil)
  if valid_611698 != nil:
    section.add "Tags", valid_611698
  var valid_611699 = query.getOrDefault("SubnetIds")
  valid_611699 = validateParameter(valid_611699, JArray, required = true, default = nil)
  if valid_611699 != nil:
    section.add "SubnetIds", valid_611699
  var valid_611700 = query.getOrDefault("Action")
  valid_611700 = validateParameter(valid_611700, JString, required = true, default = newJString(
      "CreateClusterSubnetGroup"))
  if valid_611700 != nil:
    section.add "Action", valid_611700
  var valid_611701 = query.getOrDefault("Description")
  valid_611701 = validateParameter(valid_611701, JString, required = true,
                                 default = nil)
  if valid_611701 != nil:
    section.add "Description", valid_611701
  var valid_611702 = query.getOrDefault("Version")
  valid_611702 = validateParameter(valid_611702, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_611702 != nil:
    section.add "Version", valid_611702
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_611703 = header.getOrDefault("X-Amz-Signature")
  valid_611703 = validateParameter(valid_611703, JString, required = false,
                                 default = nil)
  if valid_611703 != nil:
    section.add "X-Amz-Signature", valid_611703
  var valid_611704 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_611704 = validateParameter(valid_611704, JString, required = false,
                                 default = nil)
  if valid_611704 != nil:
    section.add "X-Amz-Content-Sha256", valid_611704
  var valid_611705 = header.getOrDefault("X-Amz-Date")
  valid_611705 = validateParameter(valid_611705, JString, required = false,
                                 default = nil)
  if valid_611705 != nil:
    section.add "X-Amz-Date", valid_611705
  var valid_611706 = header.getOrDefault("X-Amz-Credential")
  valid_611706 = validateParameter(valid_611706, JString, required = false,
                                 default = nil)
  if valid_611706 != nil:
    section.add "X-Amz-Credential", valid_611706
  var valid_611707 = header.getOrDefault("X-Amz-Security-Token")
  valid_611707 = validateParameter(valid_611707, JString, required = false,
                                 default = nil)
  if valid_611707 != nil:
    section.add "X-Amz-Security-Token", valid_611707
  var valid_611708 = header.getOrDefault("X-Amz-Algorithm")
  valid_611708 = validateParameter(valid_611708, JString, required = false,
                                 default = nil)
  if valid_611708 != nil:
    section.add "X-Amz-Algorithm", valid_611708
  var valid_611709 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_611709 = validateParameter(valid_611709, JString, required = false,
                                 default = nil)
  if valid_611709 != nil:
    section.add "X-Amz-SignedHeaders", valid_611709
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_611710: Call_GetCreateClusterSubnetGroup_611694; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a new Amazon Redshift subnet group. You must provide a list of one or more subnets in your existing Amazon Virtual Private Cloud (Amazon VPC) when creating Amazon Redshift subnet group.</p> <p> For information about subnet groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-cluster-subnet-groups.html">Amazon Redshift Cluster Subnet Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_611710.validator(path, query, header, formData, body)
  let scheme = call_611710.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_611710.url(scheme.get, call_611710.host, call_611710.base,
                         call_611710.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_611710, url, valid)

proc call*(call_611711: Call_GetCreateClusterSubnetGroup_611694;
          ClusterSubnetGroupName: string; SubnetIds: JsonNode; Description: string;
          Tags: JsonNode = nil; Action: string = "CreateClusterSubnetGroup";
          Version: string = "2012-12-01"): Recallable =
  ## getCreateClusterSubnetGroup
  ## <p>Creates a new Amazon Redshift subnet group. You must provide a list of one or more subnets in your existing Amazon Virtual Private Cloud (Amazon VPC) when creating Amazon Redshift subnet group.</p> <p> For information about subnet groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-cluster-subnet-groups.html">Amazon Redshift Cluster Subnet Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   ClusterSubnetGroupName: string (required)
  ##                         : <p>The name for the subnet group. Amazon Redshift stores the value as a lowercase string.</p> <p>Constraints:</p> <ul> <li> <p>Must contain no more than 255 alphanumeric characters or hyphens.</p> </li> <li> <p>Must not be "Default".</p> </li> <li> <p>Must be unique for all subnet groups that are created by your AWS account.</p> </li> </ul> <p>Example: <code>examplesubnetgroup</code> </p>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   SubnetIds: JArray (required)
  ##            : An array of VPC subnet IDs. A maximum of 20 subnets can be modified in a single request.
  ##   Action: string (required)
  ##   Description: string (required)
  ##              : A description for the subnet group.
  ##   Version: string (required)
  var query_611712 = newJObject()
  add(query_611712, "ClusterSubnetGroupName", newJString(ClusterSubnetGroupName))
  if Tags != nil:
    query_611712.add "Tags", Tags
  if SubnetIds != nil:
    query_611712.add "SubnetIds", SubnetIds
  add(query_611712, "Action", newJString(Action))
  add(query_611712, "Description", newJString(Description))
  add(query_611712, "Version", newJString(Version))
  result = call_611711.call(nil, query_611712, nil, nil, nil)

var getCreateClusterSubnetGroup* = Call_GetCreateClusterSubnetGroup_611694(
    name: "getCreateClusterSubnetGroup", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=CreateClusterSubnetGroup",
    validator: validate_GetCreateClusterSubnetGroup_611695, base: "/",
    url: url_GetCreateClusterSubnetGroup_611696,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCreateEventSubscription_611756 = ref object of OpenApiRestCall_610642
proc url_PostCreateEventSubscription_611758(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostCreateEventSubscription_611757(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates an Amazon Redshift event notification subscription. This action requires an ARN (Amazon Resource Name) of an Amazon SNS topic created by either the Amazon Redshift console, the Amazon SNS console, or the Amazon SNS API. To obtain an ARN with Amazon SNS, you must create a topic in Amazon SNS and subscribe to the topic. The ARN is displayed in the SNS console.</p> <p>You can specify the source type, and lists of Amazon Redshift source IDs, event categories, and event severities. Notifications will be sent for all events you want that match those criteria. For example, you can specify source type = cluster, source ID = my-cluster-1 and mycluster2, event categories = Availability, Backup, and severity = ERROR. The subscription will only send notifications for those ERROR events in the Availability and Backup categories for the specified clusters.</p> <p>If you specify both the source type and source IDs, such as source type = cluster and source identifier = my-cluster-1, notifications will be sent for all the cluster events for my-cluster-1. If you specify a source type but do not specify a source identifier, you will receive notice of the events for the objects of that type in your AWS account. If you do not specify either the SourceType nor the SourceIdentifier, you will be notified of events generated from all Amazon Redshift sources belonging to your AWS account. You must specify a source type if you specify a source ID.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_611759 = query.getOrDefault("Action")
  valid_611759 = validateParameter(valid_611759, JString, required = true, default = newJString(
      "CreateEventSubscription"))
  if valid_611759 != nil:
    section.add "Action", valid_611759
  var valid_611760 = query.getOrDefault("Version")
  valid_611760 = validateParameter(valid_611760, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_611760 != nil:
    section.add "Version", valid_611760
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_611761 = header.getOrDefault("X-Amz-Signature")
  valid_611761 = validateParameter(valid_611761, JString, required = false,
                                 default = nil)
  if valid_611761 != nil:
    section.add "X-Amz-Signature", valid_611761
  var valid_611762 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_611762 = validateParameter(valid_611762, JString, required = false,
                                 default = nil)
  if valid_611762 != nil:
    section.add "X-Amz-Content-Sha256", valid_611762
  var valid_611763 = header.getOrDefault("X-Amz-Date")
  valid_611763 = validateParameter(valid_611763, JString, required = false,
                                 default = nil)
  if valid_611763 != nil:
    section.add "X-Amz-Date", valid_611763
  var valid_611764 = header.getOrDefault("X-Amz-Credential")
  valid_611764 = validateParameter(valid_611764, JString, required = false,
                                 default = nil)
  if valid_611764 != nil:
    section.add "X-Amz-Credential", valid_611764
  var valid_611765 = header.getOrDefault("X-Amz-Security-Token")
  valid_611765 = validateParameter(valid_611765, JString, required = false,
                                 default = nil)
  if valid_611765 != nil:
    section.add "X-Amz-Security-Token", valid_611765
  var valid_611766 = header.getOrDefault("X-Amz-Algorithm")
  valid_611766 = validateParameter(valid_611766, JString, required = false,
                                 default = nil)
  if valid_611766 != nil:
    section.add "X-Amz-Algorithm", valid_611766
  var valid_611767 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_611767 = validateParameter(valid_611767, JString, required = false,
                                 default = nil)
  if valid_611767 != nil:
    section.add "X-Amz-SignedHeaders", valid_611767
  result.add "header", section
  ## parameters in `formData` object:
  ##   SourceIds: JArray
  ##            : <p>A list of one or more identifiers of Amazon Redshift source objects. All of the objects must be of the same type as was specified in the source type parameter. The event subscription will return only events generated by the specified objects. If not specified, then events are returned for all objects within the source type specified.</p> <p>Example: my-cluster-1, my-cluster-2</p> <p>Example: my-snapshot-20131010</p>
  ##   SnsTopicArn: JString (required)
  ##              : The Amazon Resource Name (ARN) of the Amazon SNS topic used to transmit the event notifications. The ARN is created by Amazon SNS when you create a topic and subscribe to it.
  ##   Enabled: JBool
  ##          : A boolean value; set to <code>true</code> to activate the subscription, and set to <code>false</code> to create the subscription but not activate it. 
  ##   SubscriptionName: JString (required)
  ##                   : <p>The name of the event subscription to be created.</p> <p>Constraints:</p> <ul> <li> <p>Cannot be null, empty, or blank.</p> </li> <li> <p>Must contain from 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   SourceType: JString
  ##             : <p>The type of source that will be generating the events. For example, if you want to be notified of events generated by a cluster, you would set this parameter to cluster. If this value is not specified, events are returned for all Amazon Redshift objects in your AWS account. You must specify a source type in order to specify source IDs.</p> <p>Valid values: cluster, cluster-parameter-group, cluster-security-group, cluster-snapshot, and scheduled-action.</p>
  ##   Severity: JString
  ##           : <p>Specifies the Amazon Redshift event severity to be published by the event notification subscription.</p> <p>Values: ERROR, INFO</p>
  ##   EventCategories: JArray
  ##                  : <p>Specifies the Amazon Redshift event categories to be published by the event notification subscription.</p> <p>Values: configuration, management, monitoring, security</p>
  ##   Tags: JArray
  ##       : A list of tag instances.
  section = newJObject()
  var valid_611768 = formData.getOrDefault("SourceIds")
  valid_611768 = validateParameter(valid_611768, JArray, required = false,
                                 default = nil)
  if valid_611768 != nil:
    section.add "SourceIds", valid_611768
  assert formData != nil,
        "formData argument is necessary due to required `SnsTopicArn` field"
  var valid_611769 = formData.getOrDefault("SnsTopicArn")
  valid_611769 = validateParameter(valid_611769, JString, required = true,
                                 default = nil)
  if valid_611769 != nil:
    section.add "SnsTopicArn", valid_611769
  var valid_611770 = formData.getOrDefault("Enabled")
  valid_611770 = validateParameter(valid_611770, JBool, required = false, default = nil)
  if valid_611770 != nil:
    section.add "Enabled", valid_611770
  var valid_611771 = formData.getOrDefault("SubscriptionName")
  valid_611771 = validateParameter(valid_611771, JString, required = true,
                                 default = nil)
  if valid_611771 != nil:
    section.add "SubscriptionName", valid_611771
  var valid_611772 = formData.getOrDefault("SourceType")
  valid_611772 = validateParameter(valid_611772, JString, required = false,
                                 default = nil)
  if valid_611772 != nil:
    section.add "SourceType", valid_611772
  var valid_611773 = formData.getOrDefault("Severity")
  valid_611773 = validateParameter(valid_611773, JString, required = false,
                                 default = nil)
  if valid_611773 != nil:
    section.add "Severity", valid_611773
  var valid_611774 = formData.getOrDefault("EventCategories")
  valid_611774 = validateParameter(valid_611774, JArray, required = false,
                                 default = nil)
  if valid_611774 != nil:
    section.add "EventCategories", valid_611774
  var valid_611775 = formData.getOrDefault("Tags")
  valid_611775 = validateParameter(valid_611775, JArray, required = false,
                                 default = nil)
  if valid_611775 != nil:
    section.add "Tags", valid_611775
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_611776: Call_PostCreateEventSubscription_611756; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates an Amazon Redshift event notification subscription. This action requires an ARN (Amazon Resource Name) of an Amazon SNS topic created by either the Amazon Redshift console, the Amazon SNS console, or the Amazon SNS API. To obtain an ARN with Amazon SNS, you must create a topic in Amazon SNS and subscribe to the topic. The ARN is displayed in the SNS console.</p> <p>You can specify the source type, and lists of Amazon Redshift source IDs, event categories, and event severities. Notifications will be sent for all events you want that match those criteria. For example, you can specify source type = cluster, source ID = my-cluster-1 and mycluster2, event categories = Availability, Backup, and severity = ERROR. The subscription will only send notifications for those ERROR events in the Availability and Backup categories for the specified clusters.</p> <p>If you specify both the source type and source IDs, such as source type = cluster and source identifier = my-cluster-1, notifications will be sent for all the cluster events for my-cluster-1. If you specify a source type but do not specify a source identifier, you will receive notice of the events for the objects of that type in your AWS account. If you do not specify either the SourceType nor the SourceIdentifier, you will be notified of events generated from all Amazon Redshift sources belonging to your AWS account. You must specify a source type if you specify a source ID.</p>
  ## 
  let valid = call_611776.validator(path, query, header, formData, body)
  let scheme = call_611776.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_611776.url(scheme.get, call_611776.host, call_611776.base,
                         call_611776.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_611776, url, valid)

proc call*(call_611777: Call_PostCreateEventSubscription_611756;
          SnsTopicArn: string; SubscriptionName: string; SourceIds: JsonNode = nil;
          Enabled: bool = false; SourceType: string = ""; Severity: string = "";
          EventCategories: JsonNode = nil;
          Action: string = "CreateEventSubscription"; Tags: JsonNode = nil;
          Version: string = "2012-12-01"): Recallable =
  ## postCreateEventSubscription
  ## <p>Creates an Amazon Redshift event notification subscription. This action requires an ARN (Amazon Resource Name) of an Amazon SNS topic created by either the Amazon Redshift console, the Amazon SNS console, or the Amazon SNS API. To obtain an ARN with Amazon SNS, you must create a topic in Amazon SNS and subscribe to the topic. The ARN is displayed in the SNS console.</p> <p>You can specify the source type, and lists of Amazon Redshift source IDs, event categories, and event severities. Notifications will be sent for all events you want that match those criteria. For example, you can specify source type = cluster, source ID = my-cluster-1 and mycluster2, event categories = Availability, Backup, and severity = ERROR. The subscription will only send notifications for those ERROR events in the Availability and Backup categories for the specified clusters.</p> <p>If you specify both the source type and source IDs, such as source type = cluster and source identifier = my-cluster-1, notifications will be sent for all the cluster events for my-cluster-1. If you specify a source type but do not specify a source identifier, you will receive notice of the events for the objects of that type in your AWS account. If you do not specify either the SourceType nor the SourceIdentifier, you will be notified of events generated from all Amazon Redshift sources belonging to your AWS account. You must specify a source type if you specify a source ID.</p>
  ##   SourceIds: JArray
  ##            : <p>A list of one or more identifiers of Amazon Redshift source objects. All of the objects must be of the same type as was specified in the source type parameter. The event subscription will return only events generated by the specified objects. If not specified, then events are returned for all objects within the source type specified.</p> <p>Example: my-cluster-1, my-cluster-2</p> <p>Example: my-snapshot-20131010</p>
  ##   SnsTopicArn: string (required)
  ##              : The Amazon Resource Name (ARN) of the Amazon SNS topic used to transmit the event notifications. The ARN is created by Amazon SNS when you create a topic and subscribe to it.
  ##   Enabled: bool
  ##          : A boolean value; set to <code>true</code> to activate the subscription, and set to <code>false</code> to create the subscription but not activate it. 
  ##   SubscriptionName: string (required)
  ##                   : <p>The name of the event subscription to be created.</p> <p>Constraints:</p> <ul> <li> <p>Cannot be null, empty, or blank.</p> </li> <li> <p>Must contain from 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   SourceType: string
  ##             : <p>The type of source that will be generating the events. For example, if you want to be notified of events generated by a cluster, you would set this parameter to cluster. If this value is not specified, events are returned for all Amazon Redshift objects in your AWS account. You must specify a source type in order to specify source IDs.</p> <p>Valid values: cluster, cluster-parameter-group, cluster-security-group, cluster-snapshot, and scheduled-action.</p>
  ##   Severity: string
  ##           : <p>Specifies the Amazon Redshift event severity to be published by the event notification subscription.</p> <p>Values: ERROR, INFO</p>
  ##   EventCategories: JArray
  ##                  : <p>Specifies the Amazon Redshift event categories to be published by the event notification subscription.</p> <p>Values: configuration, management, monitoring, security</p>
  ##   Action: string (required)
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Version: string (required)
  var query_611778 = newJObject()
  var formData_611779 = newJObject()
  if SourceIds != nil:
    formData_611779.add "SourceIds", SourceIds
  add(formData_611779, "SnsTopicArn", newJString(SnsTopicArn))
  add(formData_611779, "Enabled", newJBool(Enabled))
  add(formData_611779, "SubscriptionName", newJString(SubscriptionName))
  add(formData_611779, "SourceType", newJString(SourceType))
  add(formData_611779, "Severity", newJString(Severity))
  if EventCategories != nil:
    formData_611779.add "EventCategories", EventCategories
  add(query_611778, "Action", newJString(Action))
  if Tags != nil:
    formData_611779.add "Tags", Tags
  add(query_611778, "Version", newJString(Version))
  result = call_611777.call(nil, query_611778, nil, formData_611779, nil)

var postCreateEventSubscription* = Call_PostCreateEventSubscription_611756(
    name: "postCreateEventSubscription", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=CreateEventSubscription",
    validator: validate_PostCreateEventSubscription_611757, base: "/",
    url: url_PostCreateEventSubscription_611758,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCreateEventSubscription_611733 = ref object of OpenApiRestCall_610642
proc url_GetCreateEventSubscription_611735(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetCreateEventSubscription_611734(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates an Amazon Redshift event notification subscription. This action requires an ARN (Amazon Resource Name) of an Amazon SNS topic created by either the Amazon Redshift console, the Amazon SNS console, or the Amazon SNS API. To obtain an ARN with Amazon SNS, you must create a topic in Amazon SNS and subscribe to the topic. The ARN is displayed in the SNS console.</p> <p>You can specify the source type, and lists of Amazon Redshift source IDs, event categories, and event severities. Notifications will be sent for all events you want that match those criteria. For example, you can specify source type = cluster, source ID = my-cluster-1 and mycluster2, event categories = Availability, Backup, and severity = ERROR. The subscription will only send notifications for those ERROR events in the Availability and Backup categories for the specified clusters.</p> <p>If you specify both the source type and source IDs, such as source type = cluster and source identifier = my-cluster-1, notifications will be sent for all the cluster events for my-cluster-1. If you specify a source type but do not specify a source identifier, you will receive notice of the events for the objects of that type in your AWS account. If you do not specify either the SourceType nor the SourceIdentifier, you will be notified of events generated from all Amazon Redshift sources belonging to your AWS account. You must specify a source type if you specify a source ID.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   SourceType: JString
  ##             : <p>The type of source that will be generating the events. For example, if you want to be notified of events generated by a cluster, you would set this parameter to cluster. If this value is not specified, events are returned for all Amazon Redshift objects in your AWS account. You must specify a source type in order to specify source IDs.</p> <p>Valid values: cluster, cluster-parameter-group, cluster-security-group, cluster-snapshot, and scheduled-action.</p>
  ##   Enabled: JBool
  ##          : A boolean value; set to <code>true</code> to activate the subscription, and set to <code>false</code> to create the subscription but not activate it. 
  ##   Severity: JString
  ##           : <p>Specifies the Amazon Redshift event severity to be published by the event notification subscription.</p> <p>Values: ERROR, INFO</p>
  ##   SubscriptionName: JString (required)
  ##                   : <p>The name of the event subscription to be created.</p> <p>Constraints:</p> <ul> <li> <p>Cannot be null, empty, or blank.</p> </li> <li> <p>Must contain from 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   EventCategories: JArray
  ##                  : <p>Specifies the Amazon Redshift event categories to be published by the event notification subscription.</p> <p>Values: configuration, management, monitoring, security</p>
  ##   SourceIds: JArray
  ##            : <p>A list of one or more identifiers of Amazon Redshift source objects. All of the objects must be of the same type as was specified in the source type parameter. The event subscription will return only events generated by the specified objects. If not specified, then events are returned for all objects within the source type specified.</p> <p>Example: my-cluster-1, my-cluster-2</p> <p>Example: my-snapshot-20131010</p>
  ##   Action: JString (required)
  ##   SnsTopicArn: JString (required)
  ##              : The Amazon Resource Name (ARN) of the Amazon SNS topic used to transmit the event notifications. The ARN is created by Amazon SNS when you create a topic and subscribe to it.
  ##   Version: JString (required)
  section = newJObject()
  var valid_611736 = query.getOrDefault("Tags")
  valid_611736 = validateParameter(valid_611736, JArray, required = false,
                                 default = nil)
  if valid_611736 != nil:
    section.add "Tags", valid_611736
  var valid_611737 = query.getOrDefault("SourceType")
  valid_611737 = validateParameter(valid_611737, JString, required = false,
                                 default = nil)
  if valid_611737 != nil:
    section.add "SourceType", valid_611737
  var valid_611738 = query.getOrDefault("Enabled")
  valid_611738 = validateParameter(valid_611738, JBool, required = false, default = nil)
  if valid_611738 != nil:
    section.add "Enabled", valid_611738
  var valid_611739 = query.getOrDefault("Severity")
  valid_611739 = validateParameter(valid_611739, JString, required = false,
                                 default = nil)
  if valid_611739 != nil:
    section.add "Severity", valid_611739
  assert query != nil,
        "query argument is necessary due to required `SubscriptionName` field"
  var valid_611740 = query.getOrDefault("SubscriptionName")
  valid_611740 = validateParameter(valid_611740, JString, required = true,
                                 default = nil)
  if valid_611740 != nil:
    section.add "SubscriptionName", valid_611740
  var valid_611741 = query.getOrDefault("EventCategories")
  valid_611741 = validateParameter(valid_611741, JArray, required = false,
                                 default = nil)
  if valid_611741 != nil:
    section.add "EventCategories", valid_611741
  var valid_611742 = query.getOrDefault("SourceIds")
  valid_611742 = validateParameter(valid_611742, JArray, required = false,
                                 default = nil)
  if valid_611742 != nil:
    section.add "SourceIds", valid_611742
  var valid_611743 = query.getOrDefault("Action")
  valid_611743 = validateParameter(valid_611743, JString, required = true, default = newJString(
      "CreateEventSubscription"))
  if valid_611743 != nil:
    section.add "Action", valid_611743
  var valid_611744 = query.getOrDefault("SnsTopicArn")
  valid_611744 = validateParameter(valid_611744, JString, required = true,
                                 default = nil)
  if valid_611744 != nil:
    section.add "SnsTopicArn", valid_611744
  var valid_611745 = query.getOrDefault("Version")
  valid_611745 = validateParameter(valid_611745, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_611745 != nil:
    section.add "Version", valid_611745
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_611746 = header.getOrDefault("X-Amz-Signature")
  valid_611746 = validateParameter(valid_611746, JString, required = false,
                                 default = nil)
  if valid_611746 != nil:
    section.add "X-Amz-Signature", valid_611746
  var valid_611747 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_611747 = validateParameter(valid_611747, JString, required = false,
                                 default = nil)
  if valid_611747 != nil:
    section.add "X-Amz-Content-Sha256", valid_611747
  var valid_611748 = header.getOrDefault("X-Amz-Date")
  valid_611748 = validateParameter(valid_611748, JString, required = false,
                                 default = nil)
  if valid_611748 != nil:
    section.add "X-Amz-Date", valid_611748
  var valid_611749 = header.getOrDefault("X-Amz-Credential")
  valid_611749 = validateParameter(valid_611749, JString, required = false,
                                 default = nil)
  if valid_611749 != nil:
    section.add "X-Amz-Credential", valid_611749
  var valid_611750 = header.getOrDefault("X-Amz-Security-Token")
  valid_611750 = validateParameter(valid_611750, JString, required = false,
                                 default = nil)
  if valid_611750 != nil:
    section.add "X-Amz-Security-Token", valid_611750
  var valid_611751 = header.getOrDefault("X-Amz-Algorithm")
  valid_611751 = validateParameter(valid_611751, JString, required = false,
                                 default = nil)
  if valid_611751 != nil:
    section.add "X-Amz-Algorithm", valid_611751
  var valid_611752 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_611752 = validateParameter(valid_611752, JString, required = false,
                                 default = nil)
  if valid_611752 != nil:
    section.add "X-Amz-SignedHeaders", valid_611752
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_611753: Call_GetCreateEventSubscription_611733; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates an Amazon Redshift event notification subscription. This action requires an ARN (Amazon Resource Name) of an Amazon SNS topic created by either the Amazon Redshift console, the Amazon SNS console, or the Amazon SNS API. To obtain an ARN with Amazon SNS, you must create a topic in Amazon SNS and subscribe to the topic. The ARN is displayed in the SNS console.</p> <p>You can specify the source type, and lists of Amazon Redshift source IDs, event categories, and event severities. Notifications will be sent for all events you want that match those criteria. For example, you can specify source type = cluster, source ID = my-cluster-1 and mycluster2, event categories = Availability, Backup, and severity = ERROR. The subscription will only send notifications for those ERROR events in the Availability and Backup categories for the specified clusters.</p> <p>If you specify both the source type and source IDs, such as source type = cluster and source identifier = my-cluster-1, notifications will be sent for all the cluster events for my-cluster-1. If you specify a source type but do not specify a source identifier, you will receive notice of the events for the objects of that type in your AWS account. If you do not specify either the SourceType nor the SourceIdentifier, you will be notified of events generated from all Amazon Redshift sources belonging to your AWS account. You must specify a source type if you specify a source ID.</p>
  ## 
  let valid = call_611753.validator(path, query, header, formData, body)
  let scheme = call_611753.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_611753.url(scheme.get, call_611753.host, call_611753.base,
                         call_611753.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_611753, url, valid)

proc call*(call_611754: Call_GetCreateEventSubscription_611733;
          SubscriptionName: string; SnsTopicArn: string; Tags: JsonNode = nil;
          SourceType: string = ""; Enabled: bool = false; Severity: string = "";
          EventCategories: JsonNode = nil; SourceIds: JsonNode = nil;
          Action: string = "CreateEventSubscription"; Version: string = "2012-12-01"): Recallable =
  ## getCreateEventSubscription
  ## <p>Creates an Amazon Redshift event notification subscription. This action requires an ARN (Amazon Resource Name) of an Amazon SNS topic created by either the Amazon Redshift console, the Amazon SNS console, or the Amazon SNS API. To obtain an ARN with Amazon SNS, you must create a topic in Amazon SNS and subscribe to the topic. The ARN is displayed in the SNS console.</p> <p>You can specify the source type, and lists of Amazon Redshift source IDs, event categories, and event severities. Notifications will be sent for all events you want that match those criteria. For example, you can specify source type = cluster, source ID = my-cluster-1 and mycluster2, event categories = Availability, Backup, and severity = ERROR. The subscription will only send notifications for those ERROR events in the Availability and Backup categories for the specified clusters.</p> <p>If you specify both the source type and source IDs, such as source type = cluster and source identifier = my-cluster-1, notifications will be sent for all the cluster events for my-cluster-1. If you specify a source type but do not specify a source identifier, you will receive notice of the events for the objects of that type in your AWS account. If you do not specify either the SourceType nor the SourceIdentifier, you will be notified of events generated from all Amazon Redshift sources belonging to your AWS account. You must specify a source type if you specify a source ID.</p>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   SourceType: string
  ##             : <p>The type of source that will be generating the events. For example, if you want to be notified of events generated by a cluster, you would set this parameter to cluster. If this value is not specified, events are returned for all Amazon Redshift objects in your AWS account. You must specify a source type in order to specify source IDs.</p> <p>Valid values: cluster, cluster-parameter-group, cluster-security-group, cluster-snapshot, and scheduled-action.</p>
  ##   Enabled: bool
  ##          : A boolean value; set to <code>true</code> to activate the subscription, and set to <code>false</code> to create the subscription but not activate it. 
  ##   Severity: string
  ##           : <p>Specifies the Amazon Redshift event severity to be published by the event notification subscription.</p> <p>Values: ERROR, INFO</p>
  ##   SubscriptionName: string (required)
  ##                   : <p>The name of the event subscription to be created.</p> <p>Constraints:</p> <ul> <li> <p>Cannot be null, empty, or blank.</p> </li> <li> <p>Must contain from 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   EventCategories: JArray
  ##                  : <p>Specifies the Amazon Redshift event categories to be published by the event notification subscription.</p> <p>Values: configuration, management, monitoring, security</p>
  ##   SourceIds: JArray
  ##            : <p>A list of one or more identifiers of Amazon Redshift source objects. All of the objects must be of the same type as was specified in the source type parameter. The event subscription will return only events generated by the specified objects. If not specified, then events are returned for all objects within the source type specified.</p> <p>Example: my-cluster-1, my-cluster-2</p> <p>Example: my-snapshot-20131010</p>
  ##   Action: string (required)
  ##   SnsTopicArn: string (required)
  ##              : The Amazon Resource Name (ARN) of the Amazon SNS topic used to transmit the event notifications. The ARN is created by Amazon SNS when you create a topic and subscribe to it.
  ##   Version: string (required)
  var query_611755 = newJObject()
  if Tags != nil:
    query_611755.add "Tags", Tags
  add(query_611755, "SourceType", newJString(SourceType))
  add(query_611755, "Enabled", newJBool(Enabled))
  add(query_611755, "Severity", newJString(Severity))
  add(query_611755, "SubscriptionName", newJString(SubscriptionName))
  if EventCategories != nil:
    query_611755.add "EventCategories", EventCategories
  if SourceIds != nil:
    query_611755.add "SourceIds", SourceIds
  add(query_611755, "Action", newJString(Action))
  add(query_611755, "SnsTopicArn", newJString(SnsTopicArn))
  add(query_611755, "Version", newJString(Version))
  result = call_611754.call(nil, query_611755, nil, nil, nil)

var getCreateEventSubscription* = Call_GetCreateEventSubscription_611733(
    name: "getCreateEventSubscription", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=CreateEventSubscription",
    validator: validate_GetCreateEventSubscription_611734, base: "/",
    url: url_GetCreateEventSubscription_611735,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCreateHsmClientCertificate_611797 = ref object of OpenApiRestCall_610642
proc url_PostCreateHsmClientCertificate_611799(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostCreateHsmClientCertificate_611798(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates an HSM client certificate that an Amazon Redshift cluster will use to connect to the client's HSM in order to store and retrieve the keys used to encrypt the cluster databases.</p> <p>The command returns a public key, which you must store in the HSM. In addition to creating the HSM certificate, you must create an Amazon Redshift HSM configuration that provides a cluster the information needed to store and use encryption keys in the HSM. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a> in the Amazon Redshift Cluster Management Guide.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_611800 = query.getOrDefault("Action")
  valid_611800 = validateParameter(valid_611800, JString, required = true, default = newJString(
      "CreateHsmClientCertificate"))
  if valid_611800 != nil:
    section.add "Action", valid_611800
  var valid_611801 = query.getOrDefault("Version")
  valid_611801 = validateParameter(valid_611801, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_611801 != nil:
    section.add "Version", valid_611801
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_611802 = header.getOrDefault("X-Amz-Signature")
  valid_611802 = validateParameter(valid_611802, JString, required = false,
                                 default = nil)
  if valid_611802 != nil:
    section.add "X-Amz-Signature", valid_611802
  var valid_611803 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_611803 = validateParameter(valid_611803, JString, required = false,
                                 default = nil)
  if valid_611803 != nil:
    section.add "X-Amz-Content-Sha256", valid_611803
  var valid_611804 = header.getOrDefault("X-Amz-Date")
  valid_611804 = validateParameter(valid_611804, JString, required = false,
                                 default = nil)
  if valid_611804 != nil:
    section.add "X-Amz-Date", valid_611804
  var valid_611805 = header.getOrDefault("X-Amz-Credential")
  valid_611805 = validateParameter(valid_611805, JString, required = false,
                                 default = nil)
  if valid_611805 != nil:
    section.add "X-Amz-Credential", valid_611805
  var valid_611806 = header.getOrDefault("X-Amz-Security-Token")
  valid_611806 = validateParameter(valid_611806, JString, required = false,
                                 default = nil)
  if valid_611806 != nil:
    section.add "X-Amz-Security-Token", valid_611806
  var valid_611807 = header.getOrDefault("X-Amz-Algorithm")
  valid_611807 = validateParameter(valid_611807, JString, required = false,
                                 default = nil)
  if valid_611807 != nil:
    section.add "X-Amz-Algorithm", valid_611807
  var valid_611808 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_611808 = validateParameter(valid_611808, JString, required = false,
                                 default = nil)
  if valid_611808 != nil:
    section.add "X-Amz-SignedHeaders", valid_611808
  result.add "header", section
  ## parameters in `formData` object:
  ##   HsmClientCertificateIdentifier: JString (required)
  ##                                 : The identifier to be assigned to the new HSM client certificate that the cluster will use to connect to the HSM to use the database encryption keys.
  ##   Tags: JArray
  ##       : A list of tag instances.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `HsmClientCertificateIdentifier` field"
  var valid_611809 = formData.getOrDefault("HsmClientCertificateIdentifier")
  valid_611809 = validateParameter(valid_611809, JString, required = true,
                                 default = nil)
  if valid_611809 != nil:
    section.add "HsmClientCertificateIdentifier", valid_611809
  var valid_611810 = formData.getOrDefault("Tags")
  valid_611810 = validateParameter(valid_611810, JArray, required = false,
                                 default = nil)
  if valid_611810 != nil:
    section.add "Tags", valid_611810
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_611811: Call_PostCreateHsmClientCertificate_611797; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates an HSM client certificate that an Amazon Redshift cluster will use to connect to the client's HSM in order to store and retrieve the keys used to encrypt the cluster databases.</p> <p>The command returns a public key, which you must store in the HSM. In addition to creating the HSM certificate, you must create an Amazon Redshift HSM configuration that provides a cluster the information needed to store and use encryption keys in the HSM. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a> in the Amazon Redshift Cluster Management Guide.</p>
  ## 
  let valid = call_611811.validator(path, query, header, formData, body)
  let scheme = call_611811.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_611811.url(scheme.get, call_611811.host, call_611811.base,
                         call_611811.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_611811, url, valid)

proc call*(call_611812: Call_PostCreateHsmClientCertificate_611797;
          HsmClientCertificateIdentifier: string;
          Action: string = "CreateHsmClientCertificate"; Tags: JsonNode = nil;
          Version: string = "2012-12-01"): Recallable =
  ## postCreateHsmClientCertificate
  ## <p>Creates an HSM client certificate that an Amazon Redshift cluster will use to connect to the client's HSM in order to store and retrieve the keys used to encrypt the cluster databases.</p> <p>The command returns a public key, which you must store in the HSM. In addition to creating the HSM certificate, you must create an Amazon Redshift HSM configuration that provides a cluster the information needed to store and use encryption keys in the HSM. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a> in the Amazon Redshift Cluster Management Guide.</p>
  ##   Action: string (required)
  ##   HsmClientCertificateIdentifier: string (required)
  ##                                 : The identifier to be assigned to the new HSM client certificate that the cluster will use to connect to the HSM to use the database encryption keys.
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Version: string (required)
  var query_611813 = newJObject()
  var formData_611814 = newJObject()
  add(query_611813, "Action", newJString(Action))
  add(formData_611814, "HsmClientCertificateIdentifier",
      newJString(HsmClientCertificateIdentifier))
  if Tags != nil:
    formData_611814.add "Tags", Tags
  add(query_611813, "Version", newJString(Version))
  result = call_611812.call(nil, query_611813, nil, formData_611814, nil)

var postCreateHsmClientCertificate* = Call_PostCreateHsmClientCertificate_611797(
    name: "postCreateHsmClientCertificate", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=CreateHsmClientCertificate",
    validator: validate_PostCreateHsmClientCertificate_611798, base: "/",
    url: url_PostCreateHsmClientCertificate_611799,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCreateHsmClientCertificate_611780 = ref object of OpenApiRestCall_610642
proc url_GetCreateHsmClientCertificate_611782(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetCreateHsmClientCertificate_611781(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates an HSM client certificate that an Amazon Redshift cluster will use to connect to the client's HSM in order to store and retrieve the keys used to encrypt the cluster databases.</p> <p>The command returns a public key, which you must store in the HSM. In addition to creating the HSM certificate, you must create an Amazon Redshift HSM configuration that provides a cluster the information needed to store and use encryption keys in the HSM. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a> in the Amazon Redshift Cluster Management Guide.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   HsmClientCertificateIdentifier: JString (required)
  ##                                 : The identifier to be assigned to the new HSM client certificate that the cluster will use to connect to the HSM to use the database encryption keys.
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `HsmClientCertificateIdentifier` field"
  var valid_611783 = query.getOrDefault("HsmClientCertificateIdentifier")
  valid_611783 = validateParameter(valid_611783, JString, required = true,
                                 default = nil)
  if valid_611783 != nil:
    section.add "HsmClientCertificateIdentifier", valid_611783
  var valid_611784 = query.getOrDefault("Tags")
  valid_611784 = validateParameter(valid_611784, JArray, required = false,
                                 default = nil)
  if valid_611784 != nil:
    section.add "Tags", valid_611784
  var valid_611785 = query.getOrDefault("Action")
  valid_611785 = validateParameter(valid_611785, JString, required = true, default = newJString(
      "CreateHsmClientCertificate"))
  if valid_611785 != nil:
    section.add "Action", valid_611785
  var valid_611786 = query.getOrDefault("Version")
  valid_611786 = validateParameter(valid_611786, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_611786 != nil:
    section.add "Version", valid_611786
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_611787 = header.getOrDefault("X-Amz-Signature")
  valid_611787 = validateParameter(valid_611787, JString, required = false,
                                 default = nil)
  if valid_611787 != nil:
    section.add "X-Amz-Signature", valid_611787
  var valid_611788 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_611788 = validateParameter(valid_611788, JString, required = false,
                                 default = nil)
  if valid_611788 != nil:
    section.add "X-Amz-Content-Sha256", valid_611788
  var valid_611789 = header.getOrDefault("X-Amz-Date")
  valid_611789 = validateParameter(valid_611789, JString, required = false,
                                 default = nil)
  if valid_611789 != nil:
    section.add "X-Amz-Date", valid_611789
  var valid_611790 = header.getOrDefault("X-Amz-Credential")
  valid_611790 = validateParameter(valid_611790, JString, required = false,
                                 default = nil)
  if valid_611790 != nil:
    section.add "X-Amz-Credential", valid_611790
  var valid_611791 = header.getOrDefault("X-Amz-Security-Token")
  valid_611791 = validateParameter(valid_611791, JString, required = false,
                                 default = nil)
  if valid_611791 != nil:
    section.add "X-Amz-Security-Token", valid_611791
  var valid_611792 = header.getOrDefault("X-Amz-Algorithm")
  valid_611792 = validateParameter(valid_611792, JString, required = false,
                                 default = nil)
  if valid_611792 != nil:
    section.add "X-Amz-Algorithm", valid_611792
  var valid_611793 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_611793 = validateParameter(valid_611793, JString, required = false,
                                 default = nil)
  if valid_611793 != nil:
    section.add "X-Amz-SignedHeaders", valid_611793
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_611794: Call_GetCreateHsmClientCertificate_611780; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates an HSM client certificate that an Amazon Redshift cluster will use to connect to the client's HSM in order to store and retrieve the keys used to encrypt the cluster databases.</p> <p>The command returns a public key, which you must store in the HSM. In addition to creating the HSM certificate, you must create an Amazon Redshift HSM configuration that provides a cluster the information needed to store and use encryption keys in the HSM. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a> in the Amazon Redshift Cluster Management Guide.</p>
  ## 
  let valid = call_611794.validator(path, query, header, formData, body)
  let scheme = call_611794.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_611794.url(scheme.get, call_611794.host, call_611794.base,
                         call_611794.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_611794, url, valid)

proc call*(call_611795: Call_GetCreateHsmClientCertificate_611780;
          HsmClientCertificateIdentifier: string; Tags: JsonNode = nil;
          Action: string = "CreateHsmClientCertificate";
          Version: string = "2012-12-01"): Recallable =
  ## getCreateHsmClientCertificate
  ## <p>Creates an HSM client certificate that an Amazon Redshift cluster will use to connect to the client's HSM in order to store and retrieve the keys used to encrypt the cluster databases.</p> <p>The command returns a public key, which you must store in the HSM. In addition to creating the HSM certificate, you must create an Amazon Redshift HSM configuration that provides a cluster the information needed to store and use encryption keys in the HSM. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a> in the Amazon Redshift Cluster Management Guide.</p>
  ##   HsmClientCertificateIdentifier: string (required)
  ##                                 : The identifier to be assigned to the new HSM client certificate that the cluster will use to connect to the HSM to use the database encryption keys.
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_611796 = newJObject()
  add(query_611796, "HsmClientCertificateIdentifier",
      newJString(HsmClientCertificateIdentifier))
  if Tags != nil:
    query_611796.add "Tags", Tags
  add(query_611796, "Action", newJString(Action))
  add(query_611796, "Version", newJString(Version))
  result = call_611795.call(nil, query_611796, nil, nil, nil)

var getCreateHsmClientCertificate* = Call_GetCreateHsmClientCertificate_611780(
    name: "getCreateHsmClientCertificate", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=CreateHsmClientCertificate",
    validator: validate_GetCreateHsmClientCertificate_611781, base: "/",
    url: url_GetCreateHsmClientCertificate_611782,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCreateHsmConfiguration_611837 = ref object of OpenApiRestCall_610642
proc url_PostCreateHsmConfiguration_611839(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostCreateHsmConfiguration_611838(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates an HSM configuration that contains the information required by an Amazon Redshift cluster to store and use database encryption keys in a Hardware Security Module (HSM). After creating the HSM configuration, you can specify it as a parameter when creating a cluster. The cluster will then store its encryption keys in the HSM.</p> <p>In addition to creating an HSM configuration, you must also create an HSM client certificate. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a> in the Amazon Redshift Cluster Management Guide.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_611840 = query.getOrDefault("Action")
  valid_611840 = validateParameter(valid_611840, JString, required = true,
                                 default = newJString("CreateHsmConfiguration"))
  if valid_611840 != nil:
    section.add "Action", valid_611840
  var valid_611841 = query.getOrDefault("Version")
  valid_611841 = validateParameter(valid_611841, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_611841 != nil:
    section.add "Version", valid_611841
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_611842 = header.getOrDefault("X-Amz-Signature")
  valid_611842 = validateParameter(valid_611842, JString, required = false,
                                 default = nil)
  if valid_611842 != nil:
    section.add "X-Amz-Signature", valid_611842
  var valid_611843 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_611843 = validateParameter(valid_611843, JString, required = false,
                                 default = nil)
  if valid_611843 != nil:
    section.add "X-Amz-Content-Sha256", valid_611843
  var valid_611844 = header.getOrDefault("X-Amz-Date")
  valid_611844 = validateParameter(valid_611844, JString, required = false,
                                 default = nil)
  if valid_611844 != nil:
    section.add "X-Amz-Date", valid_611844
  var valid_611845 = header.getOrDefault("X-Amz-Credential")
  valid_611845 = validateParameter(valid_611845, JString, required = false,
                                 default = nil)
  if valid_611845 != nil:
    section.add "X-Amz-Credential", valid_611845
  var valid_611846 = header.getOrDefault("X-Amz-Security-Token")
  valid_611846 = validateParameter(valid_611846, JString, required = false,
                                 default = nil)
  if valid_611846 != nil:
    section.add "X-Amz-Security-Token", valid_611846
  var valid_611847 = header.getOrDefault("X-Amz-Algorithm")
  valid_611847 = validateParameter(valid_611847, JString, required = false,
                                 default = nil)
  if valid_611847 != nil:
    section.add "X-Amz-Algorithm", valid_611847
  var valid_611848 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_611848 = validateParameter(valid_611848, JString, required = false,
                                 default = nil)
  if valid_611848 != nil:
    section.add "X-Amz-SignedHeaders", valid_611848
  result.add "header", section
  ## parameters in `formData` object:
  ##   Description: JString (required)
  ##              : A text description of the HSM configuration to be created.
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   HsmPartitionPassword: JString (required)
  ##                       : The password required to access the HSM partition.
  ##   HsmPartitionName: JString (required)
  ##                   : The name of the partition in the HSM where the Amazon Redshift clusters will store their database encryption keys.
  ##   HsmServerPublicCertificate: JString (required)
  ##                             : The HSMs public certificate file. When using Cloud HSM, the file name is server.pem.
  ##   HsmConfigurationIdentifier: JString (required)
  ##                             : The identifier to be assigned to the new Amazon Redshift HSM configuration.
  ##   HsmIpAddress: JString (required)
  ##               : The IP address that the Amazon Redshift cluster must use to access the HSM.
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `Description` field"
  var valid_611849 = formData.getOrDefault("Description")
  valid_611849 = validateParameter(valid_611849, JString, required = true,
                                 default = nil)
  if valid_611849 != nil:
    section.add "Description", valid_611849
  var valid_611850 = formData.getOrDefault("Tags")
  valid_611850 = validateParameter(valid_611850, JArray, required = false,
                                 default = nil)
  if valid_611850 != nil:
    section.add "Tags", valid_611850
  var valid_611851 = formData.getOrDefault("HsmPartitionPassword")
  valid_611851 = validateParameter(valid_611851, JString, required = true,
                                 default = nil)
  if valid_611851 != nil:
    section.add "HsmPartitionPassword", valid_611851
  var valid_611852 = formData.getOrDefault("HsmPartitionName")
  valid_611852 = validateParameter(valid_611852, JString, required = true,
                                 default = nil)
  if valid_611852 != nil:
    section.add "HsmPartitionName", valid_611852
  var valid_611853 = formData.getOrDefault("HsmServerPublicCertificate")
  valid_611853 = validateParameter(valid_611853, JString, required = true,
                                 default = nil)
  if valid_611853 != nil:
    section.add "HsmServerPublicCertificate", valid_611853
  var valid_611854 = formData.getOrDefault("HsmConfigurationIdentifier")
  valid_611854 = validateParameter(valid_611854, JString, required = true,
                                 default = nil)
  if valid_611854 != nil:
    section.add "HsmConfigurationIdentifier", valid_611854
  var valid_611855 = formData.getOrDefault("HsmIpAddress")
  valid_611855 = validateParameter(valid_611855, JString, required = true,
                                 default = nil)
  if valid_611855 != nil:
    section.add "HsmIpAddress", valid_611855
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_611856: Call_PostCreateHsmConfiguration_611837; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates an HSM configuration that contains the information required by an Amazon Redshift cluster to store and use database encryption keys in a Hardware Security Module (HSM). After creating the HSM configuration, you can specify it as a parameter when creating a cluster. The cluster will then store its encryption keys in the HSM.</p> <p>In addition to creating an HSM configuration, you must also create an HSM client certificate. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a> in the Amazon Redshift Cluster Management Guide.</p>
  ## 
  let valid = call_611856.validator(path, query, header, formData, body)
  let scheme = call_611856.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_611856.url(scheme.get, call_611856.host, call_611856.base,
                         call_611856.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_611856, url, valid)

proc call*(call_611857: Call_PostCreateHsmConfiguration_611837;
          Description: string; HsmPartitionPassword: string;
          HsmPartitionName: string; HsmServerPublicCertificate: string;
          HsmConfigurationIdentifier: string; HsmIpAddress: string;
          Action: string = "CreateHsmConfiguration"; Tags: JsonNode = nil;
          Version: string = "2012-12-01"): Recallable =
  ## postCreateHsmConfiguration
  ## <p>Creates an HSM configuration that contains the information required by an Amazon Redshift cluster to store and use database encryption keys in a Hardware Security Module (HSM). After creating the HSM configuration, you can specify it as a parameter when creating a cluster. The cluster will then store its encryption keys in the HSM.</p> <p>In addition to creating an HSM configuration, you must also create an HSM client certificate. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a> in the Amazon Redshift Cluster Management Guide.</p>
  ##   Description: string (required)
  ##              : A text description of the HSM configuration to be created.
  ##   Action: string (required)
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   HsmPartitionPassword: string (required)
  ##                       : The password required to access the HSM partition.
  ##   Version: string (required)
  ##   HsmPartitionName: string (required)
  ##                   : The name of the partition in the HSM where the Amazon Redshift clusters will store their database encryption keys.
  ##   HsmServerPublicCertificate: string (required)
  ##                             : The HSMs public certificate file. When using Cloud HSM, the file name is server.pem.
  ##   HsmConfigurationIdentifier: string (required)
  ##                             : The identifier to be assigned to the new Amazon Redshift HSM configuration.
  ##   HsmIpAddress: string (required)
  ##               : The IP address that the Amazon Redshift cluster must use to access the HSM.
  var query_611858 = newJObject()
  var formData_611859 = newJObject()
  add(formData_611859, "Description", newJString(Description))
  add(query_611858, "Action", newJString(Action))
  if Tags != nil:
    formData_611859.add "Tags", Tags
  add(formData_611859, "HsmPartitionPassword", newJString(HsmPartitionPassword))
  add(query_611858, "Version", newJString(Version))
  add(formData_611859, "HsmPartitionName", newJString(HsmPartitionName))
  add(formData_611859, "HsmServerPublicCertificate",
      newJString(HsmServerPublicCertificate))
  add(formData_611859, "HsmConfigurationIdentifier",
      newJString(HsmConfigurationIdentifier))
  add(formData_611859, "HsmIpAddress", newJString(HsmIpAddress))
  result = call_611857.call(nil, query_611858, nil, formData_611859, nil)

var postCreateHsmConfiguration* = Call_PostCreateHsmConfiguration_611837(
    name: "postCreateHsmConfiguration", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=CreateHsmConfiguration",
    validator: validate_PostCreateHsmConfiguration_611838, base: "/",
    url: url_PostCreateHsmConfiguration_611839,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCreateHsmConfiguration_611815 = ref object of OpenApiRestCall_610642
proc url_GetCreateHsmConfiguration_611817(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetCreateHsmConfiguration_611816(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates an HSM configuration that contains the information required by an Amazon Redshift cluster to store and use database encryption keys in a Hardware Security Module (HSM). After creating the HSM configuration, you can specify it as a parameter when creating a cluster. The cluster will then store its encryption keys in the HSM.</p> <p>In addition to creating an HSM configuration, you must also create an HSM client certificate. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a> in the Amazon Redshift Cluster Management Guide.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   HsmIpAddress: JString (required)
  ##               : The IP address that the Amazon Redshift cluster must use to access the HSM.
  ##   HsmPartitionPassword: JString (required)
  ##                       : The password required to access the HSM partition.
  ##   HsmServerPublicCertificate: JString (required)
  ##                             : The HSMs public certificate file. When using Cloud HSM, the file name is server.pem.
  ##   HsmPartitionName: JString (required)
  ##                   : The name of the partition in the HSM where the Amazon Redshift clusters will store their database encryption keys.
  ##   Action: JString (required)
  ##   Description: JString (required)
  ##              : A text description of the HSM configuration to be created.
  ##   HsmConfigurationIdentifier: JString (required)
  ##                             : The identifier to be assigned to the new Amazon Redshift HSM configuration.
  ##   Version: JString (required)
  section = newJObject()
  var valid_611818 = query.getOrDefault("Tags")
  valid_611818 = validateParameter(valid_611818, JArray, required = false,
                                 default = nil)
  if valid_611818 != nil:
    section.add "Tags", valid_611818
  assert query != nil,
        "query argument is necessary due to required `HsmIpAddress` field"
  var valid_611819 = query.getOrDefault("HsmIpAddress")
  valid_611819 = validateParameter(valid_611819, JString, required = true,
                                 default = nil)
  if valid_611819 != nil:
    section.add "HsmIpAddress", valid_611819
  var valid_611820 = query.getOrDefault("HsmPartitionPassword")
  valid_611820 = validateParameter(valid_611820, JString, required = true,
                                 default = nil)
  if valid_611820 != nil:
    section.add "HsmPartitionPassword", valid_611820
  var valid_611821 = query.getOrDefault("HsmServerPublicCertificate")
  valid_611821 = validateParameter(valid_611821, JString, required = true,
                                 default = nil)
  if valid_611821 != nil:
    section.add "HsmServerPublicCertificate", valid_611821
  var valid_611822 = query.getOrDefault("HsmPartitionName")
  valid_611822 = validateParameter(valid_611822, JString, required = true,
                                 default = nil)
  if valid_611822 != nil:
    section.add "HsmPartitionName", valid_611822
  var valid_611823 = query.getOrDefault("Action")
  valid_611823 = validateParameter(valid_611823, JString, required = true,
                                 default = newJString("CreateHsmConfiguration"))
  if valid_611823 != nil:
    section.add "Action", valid_611823
  var valid_611824 = query.getOrDefault("Description")
  valid_611824 = validateParameter(valid_611824, JString, required = true,
                                 default = nil)
  if valid_611824 != nil:
    section.add "Description", valid_611824
  var valid_611825 = query.getOrDefault("HsmConfigurationIdentifier")
  valid_611825 = validateParameter(valid_611825, JString, required = true,
                                 default = nil)
  if valid_611825 != nil:
    section.add "HsmConfigurationIdentifier", valid_611825
  var valid_611826 = query.getOrDefault("Version")
  valid_611826 = validateParameter(valid_611826, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_611826 != nil:
    section.add "Version", valid_611826
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_611827 = header.getOrDefault("X-Amz-Signature")
  valid_611827 = validateParameter(valid_611827, JString, required = false,
                                 default = nil)
  if valid_611827 != nil:
    section.add "X-Amz-Signature", valid_611827
  var valid_611828 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_611828 = validateParameter(valid_611828, JString, required = false,
                                 default = nil)
  if valid_611828 != nil:
    section.add "X-Amz-Content-Sha256", valid_611828
  var valid_611829 = header.getOrDefault("X-Amz-Date")
  valid_611829 = validateParameter(valid_611829, JString, required = false,
                                 default = nil)
  if valid_611829 != nil:
    section.add "X-Amz-Date", valid_611829
  var valid_611830 = header.getOrDefault("X-Amz-Credential")
  valid_611830 = validateParameter(valid_611830, JString, required = false,
                                 default = nil)
  if valid_611830 != nil:
    section.add "X-Amz-Credential", valid_611830
  var valid_611831 = header.getOrDefault("X-Amz-Security-Token")
  valid_611831 = validateParameter(valid_611831, JString, required = false,
                                 default = nil)
  if valid_611831 != nil:
    section.add "X-Amz-Security-Token", valid_611831
  var valid_611832 = header.getOrDefault("X-Amz-Algorithm")
  valid_611832 = validateParameter(valid_611832, JString, required = false,
                                 default = nil)
  if valid_611832 != nil:
    section.add "X-Amz-Algorithm", valid_611832
  var valid_611833 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_611833 = validateParameter(valid_611833, JString, required = false,
                                 default = nil)
  if valid_611833 != nil:
    section.add "X-Amz-SignedHeaders", valid_611833
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_611834: Call_GetCreateHsmConfiguration_611815; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates an HSM configuration that contains the information required by an Amazon Redshift cluster to store and use database encryption keys in a Hardware Security Module (HSM). After creating the HSM configuration, you can specify it as a parameter when creating a cluster. The cluster will then store its encryption keys in the HSM.</p> <p>In addition to creating an HSM configuration, you must also create an HSM client certificate. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a> in the Amazon Redshift Cluster Management Guide.</p>
  ## 
  let valid = call_611834.validator(path, query, header, formData, body)
  let scheme = call_611834.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_611834.url(scheme.get, call_611834.host, call_611834.base,
                         call_611834.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_611834, url, valid)

proc call*(call_611835: Call_GetCreateHsmConfiguration_611815;
          HsmIpAddress: string; HsmPartitionPassword: string;
          HsmServerPublicCertificate: string; HsmPartitionName: string;
          Description: string; HsmConfigurationIdentifier: string;
          Tags: JsonNode = nil; Action: string = "CreateHsmConfiguration";
          Version: string = "2012-12-01"): Recallable =
  ## getCreateHsmConfiguration
  ## <p>Creates an HSM configuration that contains the information required by an Amazon Redshift cluster to store and use database encryption keys in a Hardware Security Module (HSM). After creating the HSM configuration, you can specify it as a parameter when creating a cluster. The cluster will then store its encryption keys in the HSM.</p> <p>In addition to creating an HSM configuration, you must also create an HSM client certificate. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a> in the Amazon Redshift Cluster Management Guide.</p>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   HsmIpAddress: string (required)
  ##               : The IP address that the Amazon Redshift cluster must use to access the HSM.
  ##   HsmPartitionPassword: string (required)
  ##                       : The password required to access the HSM partition.
  ##   HsmServerPublicCertificate: string (required)
  ##                             : The HSMs public certificate file. When using Cloud HSM, the file name is server.pem.
  ##   HsmPartitionName: string (required)
  ##                   : The name of the partition in the HSM where the Amazon Redshift clusters will store their database encryption keys.
  ##   Action: string (required)
  ##   Description: string (required)
  ##              : A text description of the HSM configuration to be created.
  ##   HsmConfigurationIdentifier: string (required)
  ##                             : The identifier to be assigned to the new Amazon Redshift HSM configuration.
  ##   Version: string (required)
  var query_611836 = newJObject()
  if Tags != nil:
    query_611836.add "Tags", Tags
  add(query_611836, "HsmIpAddress", newJString(HsmIpAddress))
  add(query_611836, "HsmPartitionPassword", newJString(HsmPartitionPassword))
  add(query_611836, "HsmServerPublicCertificate",
      newJString(HsmServerPublicCertificate))
  add(query_611836, "HsmPartitionName", newJString(HsmPartitionName))
  add(query_611836, "Action", newJString(Action))
  add(query_611836, "Description", newJString(Description))
  add(query_611836, "HsmConfigurationIdentifier",
      newJString(HsmConfigurationIdentifier))
  add(query_611836, "Version", newJString(Version))
  result = call_611835.call(nil, query_611836, nil, nil, nil)

var getCreateHsmConfiguration* = Call_GetCreateHsmConfiguration_611815(
    name: "getCreateHsmConfiguration", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=CreateHsmConfiguration",
    validator: validate_GetCreateHsmConfiguration_611816, base: "/",
    url: url_GetCreateHsmConfiguration_611817,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCreateScheduledAction_611883 = ref object of OpenApiRestCall_610642
proc url_PostCreateScheduledAction_611885(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostCreateScheduledAction_611884(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Creates a scheduled action. A scheduled action contains a schedule and an Amazon Redshift API action. For example, you can create a schedule of when to run the <code>ResizeCluster</code> API operation. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_611886 = query.getOrDefault("Action")
  valid_611886 = validateParameter(valid_611886, JString, required = true,
                                 default = newJString("CreateScheduledAction"))
  if valid_611886 != nil:
    section.add "Action", valid_611886
  var valid_611887 = query.getOrDefault("Version")
  valid_611887 = validateParameter(valid_611887, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_611887 != nil:
    section.add "Version", valid_611887
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_611888 = header.getOrDefault("X-Amz-Signature")
  valid_611888 = validateParameter(valid_611888, JString, required = false,
                                 default = nil)
  if valid_611888 != nil:
    section.add "X-Amz-Signature", valid_611888
  var valid_611889 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_611889 = validateParameter(valid_611889, JString, required = false,
                                 default = nil)
  if valid_611889 != nil:
    section.add "X-Amz-Content-Sha256", valid_611889
  var valid_611890 = header.getOrDefault("X-Amz-Date")
  valid_611890 = validateParameter(valid_611890, JString, required = false,
                                 default = nil)
  if valid_611890 != nil:
    section.add "X-Amz-Date", valid_611890
  var valid_611891 = header.getOrDefault("X-Amz-Credential")
  valid_611891 = validateParameter(valid_611891, JString, required = false,
                                 default = nil)
  if valid_611891 != nil:
    section.add "X-Amz-Credential", valid_611891
  var valid_611892 = header.getOrDefault("X-Amz-Security-Token")
  valid_611892 = validateParameter(valid_611892, JString, required = false,
                                 default = nil)
  if valid_611892 != nil:
    section.add "X-Amz-Security-Token", valid_611892
  var valid_611893 = header.getOrDefault("X-Amz-Algorithm")
  valid_611893 = validateParameter(valid_611893, JString, required = false,
                                 default = nil)
  if valid_611893 != nil:
    section.add "X-Amz-Algorithm", valid_611893
  var valid_611894 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_611894 = validateParameter(valid_611894, JString, required = false,
                                 default = nil)
  if valid_611894 != nil:
    section.add "X-Amz-SignedHeaders", valid_611894
  result.add "header", section
  ## parameters in `formData` object:
  ##   Enable: JBool
  ##         : If true, the schedule is enabled. If false, the scheduled action does not trigger. For more information about <code>state</code> of the scheduled action, see <a>ScheduledAction</a>. 
  ##   TargetAction.ResizeCluster: JString
  ##                             : The action type that specifies an Amazon Redshift API operation that is supported by the Amazon Redshift scheduler. 
  ## An action that runs a <code>ResizeCluster</code> API operation. 
  ##   ScheduledActionName: JString (required)
  ##                      : The name of the scheduled action. The name must be unique within an account. For more information about this parameter, see <a>ScheduledAction</a>. 
  ##   ScheduledActionDescription: JString
  ##                             : The description of the scheduled action. 
  ##   Schedule: JString (required)
  ##           : The schedule in <code>at( )</code> or <code>cron( )</code> format. For more information about this parameter, see <a>ScheduledAction</a>.
  ##   EndTime: JString
  ##          : The end time in UTC of the scheduled action. After this time, the scheduled action does not trigger. For more information about this parameter, see <a>ScheduledAction</a>. 
  ##   StartTime: JString
  ##            : The start time in UTC of the scheduled action. Before this time, the scheduled action does not trigger. For more information about this parameter, see <a>ScheduledAction</a>.
  ##   IamRole: JString (required)
  ##          : The IAM role to assume to run the target action. For more information about this parameter, see <a>ScheduledAction</a>. 
  section = newJObject()
  var valid_611895 = formData.getOrDefault("Enable")
  valid_611895 = validateParameter(valid_611895, JBool, required = false, default = nil)
  if valid_611895 != nil:
    section.add "Enable", valid_611895
  var valid_611896 = formData.getOrDefault("TargetAction.ResizeCluster")
  valid_611896 = validateParameter(valid_611896, JString, required = false,
                                 default = nil)
  if valid_611896 != nil:
    section.add "TargetAction.ResizeCluster", valid_611896
  assert formData != nil, "formData argument is necessary due to required `ScheduledActionName` field"
  var valid_611897 = formData.getOrDefault("ScheduledActionName")
  valid_611897 = validateParameter(valid_611897, JString, required = true,
                                 default = nil)
  if valid_611897 != nil:
    section.add "ScheduledActionName", valid_611897
  var valid_611898 = formData.getOrDefault("ScheduledActionDescription")
  valid_611898 = validateParameter(valid_611898, JString, required = false,
                                 default = nil)
  if valid_611898 != nil:
    section.add "ScheduledActionDescription", valid_611898
  var valid_611899 = formData.getOrDefault("Schedule")
  valid_611899 = validateParameter(valid_611899, JString, required = true,
                                 default = nil)
  if valid_611899 != nil:
    section.add "Schedule", valid_611899
  var valid_611900 = formData.getOrDefault("EndTime")
  valid_611900 = validateParameter(valid_611900, JString, required = false,
                                 default = nil)
  if valid_611900 != nil:
    section.add "EndTime", valid_611900
  var valid_611901 = formData.getOrDefault("StartTime")
  valid_611901 = validateParameter(valid_611901, JString, required = false,
                                 default = nil)
  if valid_611901 != nil:
    section.add "StartTime", valid_611901
  var valid_611902 = formData.getOrDefault("IamRole")
  valid_611902 = validateParameter(valid_611902, JString, required = true,
                                 default = nil)
  if valid_611902 != nil:
    section.add "IamRole", valid_611902
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_611903: Call_PostCreateScheduledAction_611883; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a scheduled action. A scheduled action contains a schedule and an Amazon Redshift API action. For example, you can create a schedule of when to run the <code>ResizeCluster</code> API operation. 
  ## 
  let valid = call_611903.validator(path, query, header, formData, body)
  let scheme = call_611903.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_611903.url(scheme.get, call_611903.host, call_611903.base,
                         call_611903.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_611903, url, valid)

proc call*(call_611904: Call_PostCreateScheduledAction_611883;
          ScheduledActionName: string; Schedule: string; IamRole: string;
          Enable: bool = false; TargetActionResizeCluster: string = "";
          ScheduledActionDescription: string = ""; EndTime: string = "";
          StartTime: string = ""; Action: string = "CreateScheduledAction";
          Version: string = "2012-12-01"): Recallable =
  ## postCreateScheduledAction
  ## Creates a scheduled action. A scheduled action contains a schedule and an Amazon Redshift API action. For example, you can create a schedule of when to run the <code>ResizeCluster</code> API operation. 
  ##   Enable: bool
  ##         : If true, the schedule is enabled. If false, the scheduled action does not trigger. For more information about <code>state</code> of the scheduled action, see <a>ScheduledAction</a>. 
  ##   TargetActionResizeCluster: string
  ##                            : The action type that specifies an Amazon Redshift API operation that is supported by the Amazon Redshift scheduler. 
  ## An action that runs a <code>ResizeCluster</code> API operation. 
  ##   ScheduledActionName: string (required)
  ##                      : The name of the scheduled action. The name must be unique within an account. For more information about this parameter, see <a>ScheduledAction</a>. 
  ##   ScheduledActionDescription: string
  ##                             : The description of the scheduled action. 
  ##   Schedule: string (required)
  ##           : The schedule in <code>at( )</code> or <code>cron( )</code> format. For more information about this parameter, see <a>ScheduledAction</a>.
  ##   EndTime: string
  ##          : The end time in UTC of the scheduled action. After this time, the scheduled action does not trigger. For more information about this parameter, see <a>ScheduledAction</a>. 
  ##   StartTime: string
  ##            : The start time in UTC of the scheduled action. Before this time, the scheduled action does not trigger. For more information about this parameter, see <a>ScheduledAction</a>.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   IamRole: string (required)
  ##          : The IAM role to assume to run the target action. For more information about this parameter, see <a>ScheduledAction</a>. 
  var query_611905 = newJObject()
  var formData_611906 = newJObject()
  add(formData_611906, "Enable", newJBool(Enable))
  add(formData_611906, "TargetAction.ResizeCluster",
      newJString(TargetActionResizeCluster))
  add(formData_611906, "ScheduledActionName", newJString(ScheduledActionName))
  add(formData_611906, "ScheduledActionDescription",
      newJString(ScheduledActionDescription))
  add(formData_611906, "Schedule", newJString(Schedule))
  add(formData_611906, "EndTime", newJString(EndTime))
  add(formData_611906, "StartTime", newJString(StartTime))
  add(query_611905, "Action", newJString(Action))
  add(query_611905, "Version", newJString(Version))
  add(formData_611906, "IamRole", newJString(IamRole))
  result = call_611904.call(nil, query_611905, nil, formData_611906, nil)

var postCreateScheduledAction* = Call_PostCreateScheduledAction_611883(
    name: "postCreateScheduledAction", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=CreateScheduledAction",
    validator: validate_PostCreateScheduledAction_611884, base: "/",
    url: url_PostCreateScheduledAction_611885,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCreateScheduledAction_611860 = ref object of OpenApiRestCall_610642
proc url_GetCreateScheduledAction_611862(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetCreateScheduledAction_611861(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Creates a scheduled action. A scheduled action contains a schedule and an Amazon Redshift API action. For example, you can create a schedule of when to run the <code>ResizeCluster</code> API operation. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Schedule: JString (required)
  ##           : The schedule in <code>at( )</code> or <code>cron( )</code> format. For more information about this parameter, see <a>ScheduledAction</a>.
  ##   Enable: JBool
  ##         : If true, the schedule is enabled. If false, the scheduled action does not trigger. For more information about <code>state</code> of the scheduled action, see <a>ScheduledAction</a>. 
  ##   ScheduledActionName: JString (required)
  ##                      : The name of the scheduled action. The name must be unique within an account. For more information about this parameter, see <a>ScheduledAction</a>. 
  ##   IamRole: JString (required)
  ##          : The IAM role to assume to run the target action. For more information about this parameter, see <a>ScheduledAction</a>. 
  ##   TargetAction.ResizeCluster: JString
  ##                             : The action type that specifies an Amazon Redshift API operation that is supported by the Amazon Redshift scheduler. 
  ## An action that runs a <code>ResizeCluster</code> API operation. 
  ##   ScheduledActionDescription: JString
  ##                             : The description of the scheduled action. 
  ##   Action: JString (required)
  ##   StartTime: JString
  ##            : The start time in UTC of the scheduled action. Before this time, the scheduled action does not trigger. For more information about this parameter, see <a>ScheduledAction</a>.
  ##   EndTime: JString
  ##          : The end time in UTC of the scheduled action. After this time, the scheduled action does not trigger. For more information about this parameter, see <a>ScheduledAction</a>. 
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `Schedule` field"
  var valid_611863 = query.getOrDefault("Schedule")
  valid_611863 = validateParameter(valid_611863, JString, required = true,
                                 default = nil)
  if valid_611863 != nil:
    section.add "Schedule", valid_611863
  var valid_611864 = query.getOrDefault("Enable")
  valid_611864 = validateParameter(valid_611864, JBool, required = false, default = nil)
  if valid_611864 != nil:
    section.add "Enable", valid_611864
  var valid_611865 = query.getOrDefault("ScheduledActionName")
  valid_611865 = validateParameter(valid_611865, JString, required = true,
                                 default = nil)
  if valid_611865 != nil:
    section.add "ScheduledActionName", valid_611865
  var valid_611866 = query.getOrDefault("IamRole")
  valid_611866 = validateParameter(valid_611866, JString, required = true,
                                 default = nil)
  if valid_611866 != nil:
    section.add "IamRole", valid_611866
  var valid_611867 = query.getOrDefault("TargetAction.ResizeCluster")
  valid_611867 = validateParameter(valid_611867, JString, required = false,
                                 default = nil)
  if valid_611867 != nil:
    section.add "TargetAction.ResizeCluster", valid_611867
  var valid_611868 = query.getOrDefault("ScheduledActionDescription")
  valid_611868 = validateParameter(valid_611868, JString, required = false,
                                 default = nil)
  if valid_611868 != nil:
    section.add "ScheduledActionDescription", valid_611868
  var valid_611869 = query.getOrDefault("Action")
  valid_611869 = validateParameter(valid_611869, JString, required = true,
                                 default = newJString("CreateScheduledAction"))
  if valid_611869 != nil:
    section.add "Action", valid_611869
  var valid_611870 = query.getOrDefault("StartTime")
  valid_611870 = validateParameter(valid_611870, JString, required = false,
                                 default = nil)
  if valid_611870 != nil:
    section.add "StartTime", valid_611870
  var valid_611871 = query.getOrDefault("EndTime")
  valid_611871 = validateParameter(valid_611871, JString, required = false,
                                 default = nil)
  if valid_611871 != nil:
    section.add "EndTime", valid_611871
  var valid_611872 = query.getOrDefault("Version")
  valid_611872 = validateParameter(valid_611872, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_611872 != nil:
    section.add "Version", valid_611872
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_611873 = header.getOrDefault("X-Amz-Signature")
  valid_611873 = validateParameter(valid_611873, JString, required = false,
                                 default = nil)
  if valid_611873 != nil:
    section.add "X-Amz-Signature", valid_611873
  var valid_611874 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_611874 = validateParameter(valid_611874, JString, required = false,
                                 default = nil)
  if valid_611874 != nil:
    section.add "X-Amz-Content-Sha256", valid_611874
  var valid_611875 = header.getOrDefault("X-Amz-Date")
  valid_611875 = validateParameter(valid_611875, JString, required = false,
                                 default = nil)
  if valid_611875 != nil:
    section.add "X-Amz-Date", valid_611875
  var valid_611876 = header.getOrDefault("X-Amz-Credential")
  valid_611876 = validateParameter(valid_611876, JString, required = false,
                                 default = nil)
  if valid_611876 != nil:
    section.add "X-Amz-Credential", valid_611876
  var valid_611877 = header.getOrDefault("X-Amz-Security-Token")
  valid_611877 = validateParameter(valid_611877, JString, required = false,
                                 default = nil)
  if valid_611877 != nil:
    section.add "X-Amz-Security-Token", valid_611877
  var valid_611878 = header.getOrDefault("X-Amz-Algorithm")
  valid_611878 = validateParameter(valid_611878, JString, required = false,
                                 default = nil)
  if valid_611878 != nil:
    section.add "X-Amz-Algorithm", valid_611878
  var valid_611879 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_611879 = validateParameter(valid_611879, JString, required = false,
                                 default = nil)
  if valid_611879 != nil:
    section.add "X-Amz-SignedHeaders", valid_611879
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_611880: Call_GetCreateScheduledAction_611860; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a scheduled action. A scheduled action contains a schedule and an Amazon Redshift API action. For example, you can create a schedule of when to run the <code>ResizeCluster</code> API operation. 
  ## 
  let valid = call_611880.validator(path, query, header, formData, body)
  let scheme = call_611880.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_611880.url(scheme.get, call_611880.host, call_611880.base,
                         call_611880.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_611880, url, valid)

proc call*(call_611881: Call_GetCreateScheduledAction_611860; Schedule: string;
          ScheduledActionName: string; IamRole: string; Enable: bool = false;
          TargetActionResizeCluster: string = "";
          ScheduledActionDescription: string = "";
          Action: string = "CreateScheduledAction"; StartTime: string = "";
          EndTime: string = ""; Version: string = "2012-12-01"): Recallable =
  ## getCreateScheduledAction
  ## Creates a scheduled action. A scheduled action contains a schedule and an Amazon Redshift API action. For example, you can create a schedule of when to run the <code>ResizeCluster</code> API operation. 
  ##   Schedule: string (required)
  ##           : The schedule in <code>at( )</code> or <code>cron( )</code> format. For more information about this parameter, see <a>ScheduledAction</a>.
  ##   Enable: bool
  ##         : If true, the schedule is enabled. If false, the scheduled action does not trigger. For more information about <code>state</code> of the scheduled action, see <a>ScheduledAction</a>. 
  ##   ScheduledActionName: string (required)
  ##                      : The name of the scheduled action. The name must be unique within an account. For more information about this parameter, see <a>ScheduledAction</a>. 
  ##   IamRole: string (required)
  ##          : The IAM role to assume to run the target action. For more information about this parameter, see <a>ScheduledAction</a>. 
  ##   TargetActionResizeCluster: string
  ##                            : The action type that specifies an Amazon Redshift API operation that is supported by the Amazon Redshift scheduler. 
  ## An action that runs a <code>ResizeCluster</code> API operation. 
  ##   ScheduledActionDescription: string
  ##                             : The description of the scheduled action. 
  ##   Action: string (required)
  ##   StartTime: string
  ##            : The start time in UTC of the scheduled action. Before this time, the scheduled action does not trigger. For more information about this parameter, see <a>ScheduledAction</a>.
  ##   EndTime: string
  ##          : The end time in UTC of the scheduled action. After this time, the scheduled action does not trigger. For more information about this parameter, see <a>ScheduledAction</a>. 
  ##   Version: string (required)
  var query_611882 = newJObject()
  add(query_611882, "Schedule", newJString(Schedule))
  add(query_611882, "Enable", newJBool(Enable))
  add(query_611882, "ScheduledActionName", newJString(ScheduledActionName))
  add(query_611882, "IamRole", newJString(IamRole))
  add(query_611882, "TargetAction.ResizeCluster",
      newJString(TargetActionResizeCluster))
  add(query_611882, "ScheduledActionDescription",
      newJString(ScheduledActionDescription))
  add(query_611882, "Action", newJString(Action))
  add(query_611882, "StartTime", newJString(StartTime))
  add(query_611882, "EndTime", newJString(EndTime))
  add(query_611882, "Version", newJString(Version))
  result = call_611881.call(nil, query_611882, nil, nil, nil)

var getCreateScheduledAction* = Call_GetCreateScheduledAction_611860(
    name: "getCreateScheduledAction", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=CreateScheduledAction",
    validator: validate_GetCreateScheduledAction_611861, base: "/",
    url: url_GetCreateScheduledAction_611862, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCreateSnapshotCopyGrant_611925 = ref object of OpenApiRestCall_610642
proc url_PostCreateSnapshotCopyGrant_611927(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostCreateSnapshotCopyGrant_611926(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a snapshot copy grant that permits Amazon Redshift to use a customer master key (CMK) from AWS Key Management Service (AWS KMS) to encrypt copied snapshots in a destination region.</p> <p> For more information about managing snapshot copy grants, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_611928 = query.getOrDefault("Action")
  valid_611928 = validateParameter(valid_611928, JString, required = true, default = newJString(
      "CreateSnapshotCopyGrant"))
  if valid_611928 != nil:
    section.add "Action", valid_611928
  var valid_611929 = query.getOrDefault("Version")
  valid_611929 = validateParameter(valid_611929, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_611929 != nil:
    section.add "Version", valid_611929
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_611930 = header.getOrDefault("X-Amz-Signature")
  valid_611930 = validateParameter(valid_611930, JString, required = false,
                                 default = nil)
  if valid_611930 != nil:
    section.add "X-Amz-Signature", valid_611930
  var valid_611931 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_611931 = validateParameter(valid_611931, JString, required = false,
                                 default = nil)
  if valid_611931 != nil:
    section.add "X-Amz-Content-Sha256", valid_611931
  var valid_611932 = header.getOrDefault("X-Amz-Date")
  valid_611932 = validateParameter(valid_611932, JString, required = false,
                                 default = nil)
  if valid_611932 != nil:
    section.add "X-Amz-Date", valid_611932
  var valid_611933 = header.getOrDefault("X-Amz-Credential")
  valid_611933 = validateParameter(valid_611933, JString, required = false,
                                 default = nil)
  if valid_611933 != nil:
    section.add "X-Amz-Credential", valid_611933
  var valid_611934 = header.getOrDefault("X-Amz-Security-Token")
  valid_611934 = validateParameter(valid_611934, JString, required = false,
                                 default = nil)
  if valid_611934 != nil:
    section.add "X-Amz-Security-Token", valid_611934
  var valid_611935 = header.getOrDefault("X-Amz-Algorithm")
  valid_611935 = validateParameter(valid_611935, JString, required = false,
                                 default = nil)
  if valid_611935 != nil:
    section.add "X-Amz-Algorithm", valid_611935
  var valid_611936 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_611936 = validateParameter(valid_611936, JString, required = false,
                                 default = nil)
  if valid_611936 != nil:
    section.add "X-Amz-SignedHeaders", valid_611936
  result.add "header", section
  ## parameters in `formData` object:
  ##   KmsKeyId: JString
  ##           : The unique identifier of the customer master key (CMK) to which to grant Amazon Redshift permission. If no key is specified, the default key is used.
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   SnapshotCopyGrantName: JString (required)
  ##                        : <p>The name of the snapshot copy grant. This name must be unique in the region for the AWS account.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul>
  section = newJObject()
  var valid_611937 = formData.getOrDefault("KmsKeyId")
  valid_611937 = validateParameter(valid_611937, JString, required = false,
                                 default = nil)
  if valid_611937 != nil:
    section.add "KmsKeyId", valid_611937
  var valid_611938 = formData.getOrDefault("Tags")
  valid_611938 = validateParameter(valid_611938, JArray, required = false,
                                 default = nil)
  if valid_611938 != nil:
    section.add "Tags", valid_611938
  assert formData != nil, "formData argument is necessary due to required `SnapshotCopyGrantName` field"
  var valid_611939 = formData.getOrDefault("SnapshotCopyGrantName")
  valid_611939 = validateParameter(valid_611939, JString, required = true,
                                 default = nil)
  if valid_611939 != nil:
    section.add "SnapshotCopyGrantName", valid_611939
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_611940: Call_PostCreateSnapshotCopyGrant_611925; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a snapshot copy grant that permits Amazon Redshift to use a customer master key (CMK) from AWS Key Management Service (AWS KMS) to encrypt copied snapshots in a destination region.</p> <p> For more information about managing snapshot copy grants, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ## 
  let valid = call_611940.validator(path, query, header, formData, body)
  let scheme = call_611940.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_611940.url(scheme.get, call_611940.host, call_611940.base,
                         call_611940.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_611940, url, valid)

proc call*(call_611941: Call_PostCreateSnapshotCopyGrant_611925;
          SnapshotCopyGrantName: string; KmsKeyId: string = "";
          Action: string = "CreateSnapshotCopyGrant"; Tags: JsonNode = nil;
          Version: string = "2012-12-01"): Recallable =
  ## postCreateSnapshotCopyGrant
  ## <p>Creates a snapshot copy grant that permits Amazon Redshift to use a customer master key (CMK) from AWS Key Management Service (AWS KMS) to encrypt copied snapshots in a destination region.</p> <p> For more information about managing snapshot copy grants, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ##   KmsKeyId: string
  ##           : The unique identifier of the customer master key (CMK) to which to grant Amazon Redshift permission. If no key is specified, the default key is used.
  ##   Action: string (required)
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   SnapshotCopyGrantName: string (required)
  ##                        : <p>The name of the snapshot copy grant. This name must be unique in the region for the AWS account.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul>
  ##   Version: string (required)
  var query_611942 = newJObject()
  var formData_611943 = newJObject()
  add(formData_611943, "KmsKeyId", newJString(KmsKeyId))
  add(query_611942, "Action", newJString(Action))
  if Tags != nil:
    formData_611943.add "Tags", Tags
  add(formData_611943, "SnapshotCopyGrantName", newJString(SnapshotCopyGrantName))
  add(query_611942, "Version", newJString(Version))
  result = call_611941.call(nil, query_611942, nil, formData_611943, nil)

var postCreateSnapshotCopyGrant* = Call_PostCreateSnapshotCopyGrant_611925(
    name: "postCreateSnapshotCopyGrant", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=CreateSnapshotCopyGrant",
    validator: validate_PostCreateSnapshotCopyGrant_611926, base: "/",
    url: url_PostCreateSnapshotCopyGrant_611927,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCreateSnapshotCopyGrant_611907 = ref object of OpenApiRestCall_610642
proc url_GetCreateSnapshotCopyGrant_611909(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetCreateSnapshotCopyGrant_611908(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a snapshot copy grant that permits Amazon Redshift to use a customer master key (CMK) from AWS Key Management Service (AWS KMS) to encrypt copied snapshots in a destination region.</p> <p> For more information about managing snapshot copy grants, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   KmsKeyId: JString
  ##           : The unique identifier of the customer master key (CMK) to which to grant Amazon Redshift permission. If no key is specified, the default key is used.
  ##   Action: JString (required)
  ##   Version: JString (required)
  ##   SnapshotCopyGrantName: JString (required)
  ##                        : <p>The name of the snapshot copy grant. This name must be unique in the region for the AWS account.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul>
  section = newJObject()
  var valid_611910 = query.getOrDefault("Tags")
  valid_611910 = validateParameter(valid_611910, JArray, required = false,
                                 default = nil)
  if valid_611910 != nil:
    section.add "Tags", valid_611910
  var valid_611911 = query.getOrDefault("KmsKeyId")
  valid_611911 = validateParameter(valid_611911, JString, required = false,
                                 default = nil)
  if valid_611911 != nil:
    section.add "KmsKeyId", valid_611911
  var valid_611912 = query.getOrDefault("Action")
  valid_611912 = validateParameter(valid_611912, JString, required = true, default = newJString(
      "CreateSnapshotCopyGrant"))
  if valid_611912 != nil:
    section.add "Action", valid_611912
  var valid_611913 = query.getOrDefault("Version")
  valid_611913 = validateParameter(valid_611913, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_611913 != nil:
    section.add "Version", valid_611913
  var valid_611914 = query.getOrDefault("SnapshotCopyGrantName")
  valid_611914 = validateParameter(valid_611914, JString, required = true,
                                 default = nil)
  if valid_611914 != nil:
    section.add "SnapshotCopyGrantName", valid_611914
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_611915 = header.getOrDefault("X-Amz-Signature")
  valid_611915 = validateParameter(valid_611915, JString, required = false,
                                 default = nil)
  if valid_611915 != nil:
    section.add "X-Amz-Signature", valid_611915
  var valid_611916 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_611916 = validateParameter(valid_611916, JString, required = false,
                                 default = nil)
  if valid_611916 != nil:
    section.add "X-Amz-Content-Sha256", valid_611916
  var valid_611917 = header.getOrDefault("X-Amz-Date")
  valid_611917 = validateParameter(valid_611917, JString, required = false,
                                 default = nil)
  if valid_611917 != nil:
    section.add "X-Amz-Date", valid_611917
  var valid_611918 = header.getOrDefault("X-Amz-Credential")
  valid_611918 = validateParameter(valid_611918, JString, required = false,
                                 default = nil)
  if valid_611918 != nil:
    section.add "X-Amz-Credential", valid_611918
  var valid_611919 = header.getOrDefault("X-Amz-Security-Token")
  valid_611919 = validateParameter(valid_611919, JString, required = false,
                                 default = nil)
  if valid_611919 != nil:
    section.add "X-Amz-Security-Token", valid_611919
  var valid_611920 = header.getOrDefault("X-Amz-Algorithm")
  valid_611920 = validateParameter(valid_611920, JString, required = false,
                                 default = nil)
  if valid_611920 != nil:
    section.add "X-Amz-Algorithm", valid_611920
  var valid_611921 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_611921 = validateParameter(valid_611921, JString, required = false,
                                 default = nil)
  if valid_611921 != nil:
    section.add "X-Amz-SignedHeaders", valid_611921
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_611922: Call_GetCreateSnapshotCopyGrant_611907; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a snapshot copy grant that permits Amazon Redshift to use a customer master key (CMK) from AWS Key Management Service (AWS KMS) to encrypt copied snapshots in a destination region.</p> <p> For more information about managing snapshot copy grants, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ## 
  let valid = call_611922.validator(path, query, header, formData, body)
  let scheme = call_611922.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_611922.url(scheme.get, call_611922.host, call_611922.base,
                         call_611922.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_611922, url, valid)

proc call*(call_611923: Call_GetCreateSnapshotCopyGrant_611907;
          SnapshotCopyGrantName: string; Tags: JsonNode = nil; KmsKeyId: string = "";
          Action: string = "CreateSnapshotCopyGrant"; Version: string = "2012-12-01"): Recallable =
  ## getCreateSnapshotCopyGrant
  ## <p>Creates a snapshot copy grant that permits Amazon Redshift to use a customer master key (CMK) from AWS Key Management Service (AWS KMS) to encrypt copied snapshots in a destination region.</p> <p> For more information about managing snapshot copy grants, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   KmsKeyId: string
  ##           : The unique identifier of the customer master key (CMK) to which to grant Amazon Redshift permission. If no key is specified, the default key is used.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   SnapshotCopyGrantName: string (required)
  ##                        : <p>The name of the snapshot copy grant. This name must be unique in the region for the AWS account.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul>
  var query_611924 = newJObject()
  if Tags != nil:
    query_611924.add "Tags", Tags
  add(query_611924, "KmsKeyId", newJString(KmsKeyId))
  add(query_611924, "Action", newJString(Action))
  add(query_611924, "Version", newJString(Version))
  add(query_611924, "SnapshotCopyGrantName", newJString(SnapshotCopyGrantName))
  result = call_611923.call(nil, query_611924, nil, nil, nil)

var getCreateSnapshotCopyGrant* = Call_GetCreateSnapshotCopyGrant_611907(
    name: "getCreateSnapshotCopyGrant", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=CreateSnapshotCopyGrant",
    validator: validate_GetCreateSnapshotCopyGrant_611908, base: "/",
    url: url_GetCreateSnapshotCopyGrant_611909,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCreateSnapshotSchedule_611965 = ref object of OpenApiRestCall_610642
proc url_PostCreateSnapshotSchedule_611967(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostCreateSnapshotSchedule_611966(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Creates a snapshot schedule with the rate of every 12 hours.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_611968 = query.getOrDefault("Action")
  valid_611968 = validateParameter(valid_611968, JString, required = true,
                                 default = newJString("CreateSnapshotSchedule"))
  if valid_611968 != nil:
    section.add "Action", valid_611968
  var valid_611969 = query.getOrDefault("Version")
  valid_611969 = validateParameter(valid_611969, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_611969 != nil:
    section.add "Version", valid_611969
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_611970 = header.getOrDefault("X-Amz-Signature")
  valid_611970 = validateParameter(valid_611970, JString, required = false,
                                 default = nil)
  if valid_611970 != nil:
    section.add "X-Amz-Signature", valid_611970
  var valid_611971 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_611971 = validateParameter(valid_611971, JString, required = false,
                                 default = nil)
  if valid_611971 != nil:
    section.add "X-Amz-Content-Sha256", valid_611971
  var valid_611972 = header.getOrDefault("X-Amz-Date")
  valid_611972 = validateParameter(valid_611972, JString, required = false,
                                 default = nil)
  if valid_611972 != nil:
    section.add "X-Amz-Date", valid_611972
  var valid_611973 = header.getOrDefault("X-Amz-Credential")
  valid_611973 = validateParameter(valid_611973, JString, required = false,
                                 default = nil)
  if valid_611973 != nil:
    section.add "X-Amz-Credential", valid_611973
  var valid_611974 = header.getOrDefault("X-Amz-Security-Token")
  valid_611974 = validateParameter(valid_611974, JString, required = false,
                                 default = nil)
  if valid_611974 != nil:
    section.add "X-Amz-Security-Token", valid_611974
  var valid_611975 = header.getOrDefault("X-Amz-Algorithm")
  valid_611975 = validateParameter(valid_611975, JString, required = false,
                                 default = nil)
  if valid_611975 != nil:
    section.add "X-Amz-Algorithm", valid_611975
  var valid_611976 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_611976 = validateParameter(valid_611976, JString, required = false,
                                 default = nil)
  if valid_611976 != nil:
    section.add "X-Amz-SignedHeaders", valid_611976
  result.add "header", section
  ## parameters in `formData` object:
  ##   ScheduleDefinitions: JArray
  ##                      : The definition of the snapshot schedule. The definition is made up of schedule expressions, for example "cron(30 12 *)" or "rate(12 hours)". 
  ##   ScheduleDescription: JString
  ##                      : The description of the snapshot schedule.
  ##   DryRun: JBool
  ##         : <p/>
  ##   NextInvocations: JInt
  ##                  : <p/>
  ##   Tags: JArray
  ##       : An optional set of tags you can use to search for the schedule.
  ##   ScheduleIdentifier: JString
  ##                     : A unique identifier for a snapshot schedule. Only alphanumeric characters are allowed for the identifier.
  section = newJObject()
  var valid_611977 = formData.getOrDefault("ScheduleDefinitions")
  valid_611977 = validateParameter(valid_611977, JArray, required = false,
                                 default = nil)
  if valid_611977 != nil:
    section.add "ScheduleDefinitions", valid_611977
  var valid_611978 = formData.getOrDefault("ScheduleDescription")
  valid_611978 = validateParameter(valid_611978, JString, required = false,
                                 default = nil)
  if valid_611978 != nil:
    section.add "ScheduleDescription", valid_611978
  var valid_611979 = formData.getOrDefault("DryRun")
  valid_611979 = validateParameter(valid_611979, JBool, required = false, default = nil)
  if valid_611979 != nil:
    section.add "DryRun", valid_611979
  var valid_611980 = formData.getOrDefault("NextInvocations")
  valid_611980 = validateParameter(valid_611980, JInt, required = false, default = nil)
  if valid_611980 != nil:
    section.add "NextInvocations", valid_611980
  var valid_611981 = formData.getOrDefault("Tags")
  valid_611981 = validateParameter(valid_611981, JArray, required = false,
                                 default = nil)
  if valid_611981 != nil:
    section.add "Tags", valid_611981
  var valid_611982 = formData.getOrDefault("ScheduleIdentifier")
  valid_611982 = validateParameter(valid_611982, JString, required = false,
                                 default = nil)
  if valid_611982 != nil:
    section.add "ScheduleIdentifier", valid_611982
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_611983: Call_PostCreateSnapshotSchedule_611965; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a snapshot schedule with the rate of every 12 hours.
  ## 
  let valid = call_611983.validator(path, query, header, formData, body)
  let scheme = call_611983.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_611983.url(scheme.get, call_611983.host, call_611983.base,
                         call_611983.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_611983, url, valid)

proc call*(call_611984: Call_PostCreateSnapshotSchedule_611965;
          ScheduleDefinitions: JsonNode = nil; ScheduleDescription: string = "";
          DryRun: bool = false; NextInvocations: int = 0;
          Action: string = "CreateSnapshotSchedule"; Tags: JsonNode = nil;
          ScheduleIdentifier: string = ""; Version: string = "2012-12-01"): Recallable =
  ## postCreateSnapshotSchedule
  ## Creates a snapshot schedule with the rate of every 12 hours.
  ##   ScheduleDefinitions: JArray
  ##                      : The definition of the snapshot schedule. The definition is made up of schedule expressions, for example "cron(30 12 *)" or "rate(12 hours)". 
  ##   ScheduleDescription: string
  ##                      : The description of the snapshot schedule.
  ##   DryRun: bool
  ##         : <p/>
  ##   NextInvocations: int
  ##                  : <p/>
  ##   Action: string (required)
  ##   Tags: JArray
  ##       : An optional set of tags you can use to search for the schedule.
  ##   ScheduleIdentifier: string
  ##                     : A unique identifier for a snapshot schedule. Only alphanumeric characters are allowed for the identifier.
  ##   Version: string (required)
  var query_611985 = newJObject()
  var formData_611986 = newJObject()
  if ScheduleDefinitions != nil:
    formData_611986.add "ScheduleDefinitions", ScheduleDefinitions
  add(formData_611986, "ScheduleDescription", newJString(ScheduleDescription))
  add(formData_611986, "DryRun", newJBool(DryRun))
  add(formData_611986, "NextInvocations", newJInt(NextInvocations))
  add(query_611985, "Action", newJString(Action))
  if Tags != nil:
    formData_611986.add "Tags", Tags
  add(formData_611986, "ScheduleIdentifier", newJString(ScheduleIdentifier))
  add(query_611985, "Version", newJString(Version))
  result = call_611984.call(nil, query_611985, nil, formData_611986, nil)

var postCreateSnapshotSchedule* = Call_PostCreateSnapshotSchedule_611965(
    name: "postCreateSnapshotSchedule", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=CreateSnapshotSchedule",
    validator: validate_PostCreateSnapshotSchedule_611966, base: "/",
    url: url_PostCreateSnapshotSchedule_611967,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCreateSnapshotSchedule_611944 = ref object of OpenApiRestCall_610642
proc url_GetCreateSnapshotSchedule_611946(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetCreateSnapshotSchedule_611945(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Creates a snapshot schedule with the rate of every 12 hours.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Tags: JArray
  ##       : An optional set of tags you can use to search for the schedule.
  ##   ScheduleIdentifier: JString
  ##                     : A unique identifier for a snapshot schedule. Only alphanumeric characters are allowed for the identifier.
  ##   DryRun: JBool
  ##         : <p/>
  ##   NextInvocations: JInt
  ##                  : <p/>
  ##   ScheduleDefinitions: JArray
  ##                      : The definition of the snapshot schedule. The definition is made up of schedule expressions, for example "cron(30 12 *)" or "rate(12 hours)". 
  ##   ScheduleDescription: JString
  ##                      : The description of the snapshot schedule.
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_611947 = query.getOrDefault("Tags")
  valid_611947 = validateParameter(valid_611947, JArray, required = false,
                                 default = nil)
  if valid_611947 != nil:
    section.add "Tags", valid_611947
  var valid_611948 = query.getOrDefault("ScheduleIdentifier")
  valid_611948 = validateParameter(valid_611948, JString, required = false,
                                 default = nil)
  if valid_611948 != nil:
    section.add "ScheduleIdentifier", valid_611948
  var valid_611949 = query.getOrDefault("DryRun")
  valid_611949 = validateParameter(valid_611949, JBool, required = false, default = nil)
  if valid_611949 != nil:
    section.add "DryRun", valid_611949
  var valid_611950 = query.getOrDefault("NextInvocations")
  valid_611950 = validateParameter(valid_611950, JInt, required = false, default = nil)
  if valid_611950 != nil:
    section.add "NextInvocations", valid_611950
  var valid_611951 = query.getOrDefault("ScheduleDefinitions")
  valid_611951 = validateParameter(valid_611951, JArray, required = false,
                                 default = nil)
  if valid_611951 != nil:
    section.add "ScheduleDefinitions", valid_611951
  var valid_611952 = query.getOrDefault("ScheduleDescription")
  valid_611952 = validateParameter(valid_611952, JString, required = false,
                                 default = nil)
  if valid_611952 != nil:
    section.add "ScheduleDescription", valid_611952
  var valid_611953 = query.getOrDefault("Action")
  valid_611953 = validateParameter(valid_611953, JString, required = true,
                                 default = newJString("CreateSnapshotSchedule"))
  if valid_611953 != nil:
    section.add "Action", valid_611953
  var valid_611954 = query.getOrDefault("Version")
  valid_611954 = validateParameter(valid_611954, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_611954 != nil:
    section.add "Version", valid_611954
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_611955 = header.getOrDefault("X-Amz-Signature")
  valid_611955 = validateParameter(valid_611955, JString, required = false,
                                 default = nil)
  if valid_611955 != nil:
    section.add "X-Amz-Signature", valid_611955
  var valid_611956 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_611956 = validateParameter(valid_611956, JString, required = false,
                                 default = nil)
  if valid_611956 != nil:
    section.add "X-Amz-Content-Sha256", valid_611956
  var valid_611957 = header.getOrDefault("X-Amz-Date")
  valid_611957 = validateParameter(valid_611957, JString, required = false,
                                 default = nil)
  if valid_611957 != nil:
    section.add "X-Amz-Date", valid_611957
  var valid_611958 = header.getOrDefault("X-Amz-Credential")
  valid_611958 = validateParameter(valid_611958, JString, required = false,
                                 default = nil)
  if valid_611958 != nil:
    section.add "X-Amz-Credential", valid_611958
  var valid_611959 = header.getOrDefault("X-Amz-Security-Token")
  valid_611959 = validateParameter(valid_611959, JString, required = false,
                                 default = nil)
  if valid_611959 != nil:
    section.add "X-Amz-Security-Token", valid_611959
  var valid_611960 = header.getOrDefault("X-Amz-Algorithm")
  valid_611960 = validateParameter(valid_611960, JString, required = false,
                                 default = nil)
  if valid_611960 != nil:
    section.add "X-Amz-Algorithm", valid_611960
  var valid_611961 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_611961 = validateParameter(valid_611961, JString, required = false,
                                 default = nil)
  if valid_611961 != nil:
    section.add "X-Amz-SignedHeaders", valid_611961
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_611962: Call_GetCreateSnapshotSchedule_611944; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a snapshot schedule with the rate of every 12 hours.
  ## 
  let valid = call_611962.validator(path, query, header, formData, body)
  let scheme = call_611962.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_611962.url(scheme.get, call_611962.host, call_611962.base,
                         call_611962.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_611962, url, valid)

proc call*(call_611963: Call_GetCreateSnapshotSchedule_611944;
          Tags: JsonNode = nil; ScheduleIdentifier: string = ""; DryRun: bool = false;
          NextInvocations: int = 0; ScheduleDefinitions: JsonNode = nil;
          ScheduleDescription: string = "";
          Action: string = "CreateSnapshotSchedule"; Version: string = "2012-12-01"): Recallable =
  ## getCreateSnapshotSchedule
  ## Creates a snapshot schedule with the rate of every 12 hours.
  ##   Tags: JArray
  ##       : An optional set of tags you can use to search for the schedule.
  ##   ScheduleIdentifier: string
  ##                     : A unique identifier for a snapshot schedule. Only alphanumeric characters are allowed for the identifier.
  ##   DryRun: bool
  ##         : <p/>
  ##   NextInvocations: int
  ##                  : <p/>
  ##   ScheduleDefinitions: JArray
  ##                      : The definition of the snapshot schedule. The definition is made up of schedule expressions, for example "cron(30 12 *)" or "rate(12 hours)". 
  ##   ScheduleDescription: string
  ##                      : The description of the snapshot schedule.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_611964 = newJObject()
  if Tags != nil:
    query_611964.add "Tags", Tags
  add(query_611964, "ScheduleIdentifier", newJString(ScheduleIdentifier))
  add(query_611964, "DryRun", newJBool(DryRun))
  add(query_611964, "NextInvocations", newJInt(NextInvocations))
  if ScheduleDefinitions != nil:
    query_611964.add "ScheduleDefinitions", ScheduleDefinitions
  add(query_611964, "ScheduleDescription", newJString(ScheduleDescription))
  add(query_611964, "Action", newJString(Action))
  add(query_611964, "Version", newJString(Version))
  result = call_611963.call(nil, query_611964, nil, nil, nil)

var getCreateSnapshotSchedule* = Call_GetCreateSnapshotSchedule_611944(
    name: "getCreateSnapshotSchedule", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=CreateSnapshotSchedule",
    validator: validate_GetCreateSnapshotSchedule_611945, base: "/",
    url: url_GetCreateSnapshotSchedule_611946,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCreateTags_612004 = ref object of OpenApiRestCall_610642
proc url_PostCreateTags_612006(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostCreateTags_612005(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode): JsonNode =
  ## <p>Adds tags to a cluster.</p> <p>A resource can have up to 50 tags. If you try to create more than 50 tags for a resource, you will receive an error and the attempt will fail.</p> <p>If you specify a key that already exists for the resource, the value for that key will be updated with the new value.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_612007 = query.getOrDefault("Action")
  valid_612007 = validateParameter(valid_612007, JString, required = true,
                                 default = newJString("CreateTags"))
  if valid_612007 != nil:
    section.add "Action", valid_612007
  var valid_612008 = query.getOrDefault("Version")
  valid_612008 = validateParameter(valid_612008, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_612008 != nil:
    section.add "Version", valid_612008
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_612009 = header.getOrDefault("X-Amz-Signature")
  valid_612009 = validateParameter(valid_612009, JString, required = false,
                                 default = nil)
  if valid_612009 != nil:
    section.add "X-Amz-Signature", valid_612009
  var valid_612010 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_612010 = validateParameter(valid_612010, JString, required = false,
                                 default = nil)
  if valid_612010 != nil:
    section.add "X-Amz-Content-Sha256", valid_612010
  var valid_612011 = header.getOrDefault("X-Amz-Date")
  valid_612011 = validateParameter(valid_612011, JString, required = false,
                                 default = nil)
  if valid_612011 != nil:
    section.add "X-Amz-Date", valid_612011
  var valid_612012 = header.getOrDefault("X-Amz-Credential")
  valid_612012 = validateParameter(valid_612012, JString, required = false,
                                 default = nil)
  if valid_612012 != nil:
    section.add "X-Amz-Credential", valid_612012
  var valid_612013 = header.getOrDefault("X-Amz-Security-Token")
  valid_612013 = validateParameter(valid_612013, JString, required = false,
                                 default = nil)
  if valid_612013 != nil:
    section.add "X-Amz-Security-Token", valid_612013
  var valid_612014 = header.getOrDefault("X-Amz-Algorithm")
  valid_612014 = validateParameter(valid_612014, JString, required = false,
                                 default = nil)
  if valid_612014 != nil:
    section.add "X-Amz-Algorithm", valid_612014
  var valid_612015 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_612015 = validateParameter(valid_612015, JString, required = false,
                                 default = nil)
  if valid_612015 != nil:
    section.add "X-Amz-SignedHeaders", valid_612015
  result.add "header", section
  ## parameters in `formData` object:
  ##   Tags: JArray (required)
  ##       : One or more name/value pairs to add as tags to the specified resource. Each tag name is passed in with the parameter <code>Key</code> and the corresponding value is passed in with the parameter <code>Value</code>. The <code>Key</code> and <code>Value</code> parameters are separated by a comma (,). Separate multiple tags with a space. For example, <code>--tags "Key"="owner","Value"="admin" "Key"="environment","Value"="test" "Key"="version","Value"="1.0"</code>. 
  ##   ResourceName: JString (required)
  ##               : The Amazon Resource Name (ARN) to which you want to add the tag or tags. For example, <code>arn:aws:redshift:us-east-2:123456789:cluster:t1</code>. 
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `Tags` field"
  var valid_612016 = formData.getOrDefault("Tags")
  valid_612016 = validateParameter(valid_612016, JArray, required = true, default = nil)
  if valid_612016 != nil:
    section.add "Tags", valid_612016
  var valid_612017 = formData.getOrDefault("ResourceName")
  valid_612017 = validateParameter(valid_612017, JString, required = true,
                                 default = nil)
  if valid_612017 != nil:
    section.add "ResourceName", valid_612017
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_612018: Call_PostCreateTags_612004; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Adds tags to a cluster.</p> <p>A resource can have up to 50 tags. If you try to create more than 50 tags for a resource, you will receive an error and the attempt will fail.</p> <p>If you specify a key that already exists for the resource, the value for that key will be updated with the new value.</p>
  ## 
  let valid = call_612018.validator(path, query, header, formData, body)
  let scheme = call_612018.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_612018.url(scheme.get, call_612018.host, call_612018.base,
                         call_612018.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_612018, url, valid)

proc call*(call_612019: Call_PostCreateTags_612004; Tags: JsonNode;
          ResourceName: string; Action: string = "CreateTags";
          Version: string = "2012-12-01"): Recallable =
  ## postCreateTags
  ## <p>Adds tags to a cluster.</p> <p>A resource can have up to 50 tags. If you try to create more than 50 tags for a resource, you will receive an error and the attempt will fail.</p> <p>If you specify a key that already exists for the resource, the value for that key will be updated with the new value.</p>
  ##   Action: string (required)
  ##   Tags: JArray (required)
  ##       : One or more name/value pairs to add as tags to the specified resource. Each tag name is passed in with the parameter <code>Key</code> and the corresponding value is passed in with the parameter <code>Value</code>. The <code>Key</code> and <code>Value</code> parameters are separated by a comma (,). Separate multiple tags with a space. For example, <code>--tags "Key"="owner","Value"="admin" "Key"="environment","Value"="test" "Key"="version","Value"="1.0"</code>. 
  ##   Version: string (required)
  ##   ResourceName: string (required)
  ##               : The Amazon Resource Name (ARN) to which you want to add the tag or tags. For example, <code>arn:aws:redshift:us-east-2:123456789:cluster:t1</code>. 
  var query_612020 = newJObject()
  var formData_612021 = newJObject()
  add(query_612020, "Action", newJString(Action))
  if Tags != nil:
    formData_612021.add "Tags", Tags
  add(query_612020, "Version", newJString(Version))
  add(formData_612021, "ResourceName", newJString(ResourceName))
  result = call_612019.call(nil, query_612020, nil, formData_612021, nil)

var postCreateTags* = Call_PostCreateTags_612004(name: "postCreateTags",
    meth: HttpMethod.HttpPost, host: "redshift.amazonaws.com",
    route: "/#Action=CreateTags", validator: validate_PostCreateTags_612005,
    base: "/", url: url_PostCreateTags_612006, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCreateTags_611987 = ref object of OpenApiRestCall_610642
proc url_GetCreateTags_611989(protocol: Scheme; host: string; base: string;
                             route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetCreateTags_611988(path: JsonNode; query: JsonNode; header: JsonNode;
                                  formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Adds tags to a cluster.</p> <p>A resource can have up to 50 tags. If you try to create more than 50 tags for a resource, you will receive an error and the attempt will fail.</p> <p>If you specify a key that already exists for the resource, the value for that key will be updated with the new value.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Tags: JArray (required)
  ##       : One or more name/value pairs to add as tags to the specified resource. Each tag name is passed in with the parameter <code>Key</code> and the corresponding value is passed in with the parameter <code>Value</code>. The <code>Key</code> and <code>Value</code> parameters are separated by a comma (,). Separate multiple tags with a space. For example, <code>--tags "Key"="owner","Value"="admin" "Key"="environment","Value"="test" "Key"="version","Value"="1.0"</code>. 
  ##   ResourceName: JString (required)
  ##               : The Amazon Resource Name (ARN) to which you want to add the tag or tags. For example, <code>arn:aws:redshift:us-east-2:123456789:cluster:t1</code>. 
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Tags` field"
  var valid_611990 = query.getOrDefault("Tags")
  valid_611990 = validateParameter(valid_611990, JArray, required = true, default = nil)
  if valid_611990 != nil:
    section.add "Tags", valid_611990
  var valid_611991 = query.getOrDefault("ResourceName")
  valid_611991 = validateParameter(valid_611991, JString, required = true,
                                 default = nil)
  if valid_611991 != nil:
    section.add "ResourceName", valid_611991
  var valid_611992 = query.getOrDefault("Action")
  valid_611992 = validateParameter(valid_611992, JString, required = true,
                                 default = newJString("CreateTags"))
  if valid_611992 != nil:
    section.add "Action", valid_611992
  var valid_611993 = query.getOrDefault("Version")
  valid_611993 = validateParameter(valid_611993, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_611993 != nil:
    section.add "Version", valid_611993
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_611994 = header.getOrDefault("X-Amz-Signature")
  valid_611994 = validateParameter(valid_611994, JString, required = false,
                                 default = nil)
  if valid_611994 != nil:
    section.add "X-Amz-Signature", valid_611994
  var valid_611995 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_611995 = validateParameter(valid_611995, JString, required = false,
                                 default = nil)
  if valid_611995 != nil:
    section.add "X-Amz-Content-Sha256", valid_611995
  var valid_611996 = header.getOrDefault("X-Amz-Date")
  valid_611996 = validateParameter(valid_611996, JString, required = false,
                                 default = nil)
  if valid_611996 != nil:
    section.add "X-Amz-Date", valid_611996
  var valid_611997 = header.getOrDefault("X-Amz-Credential")
  valid_611997 = validateParameter(valid_611997, JString, required = false,
                                 default = nil)
  if valid_611997 != nil:
    section.add "X-Amz-Credential", valid_611997
  var valid_611998 = header.getOrDefault("X-Amz-Security-Token")
  valid_611998 = validateParameter(valid_611998, JString, required = false,
                                 default = nil)
  if valid_611998 != nil:
    section.add "X-Amz-Security-Token", valid_611998
  var valid_611999 = header.getOrDefault("X-Amz-Algorithm")
  valid_611999 = validateParameter(valid_611999, JString, required = false,
                                 default = nil)
  if valid_611999 != nil:
    section.add "X-Amz-Algorithm", valid_611999
  var valid_612000 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_612000 = validateParameter(valid_612000, JString, required = false,
                                 default = nil)
  if valid_612000 != nil:
    section.add "X-Amz-SignedHeaders", valid_612000
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_612001: Call_GetCreateTags_611987; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Adds tags to a cluster.</p> <p>A resource can have up to 50 tags. If you try to create more than 50 tags for a resource, you will receive an error and the attempt will fail.</p> <p>If you specify a key that already exists for the resource, the value for that key will be updated with the new value.</p>
  ## 
  let valid = call_612001.validator(path, query, header, formData, body)
  let scheme = call_612001.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_612001.url(scheme.get, call_612001.host, call_612001.base,
                         call_612001.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_612001, url, valid)

proc call*(call_612002: Call_GetCreateTags_611987; Tags: JsonNode;
          ResourceName: string; Action: string = "CreateTags";
          Version: string = "2012-12-01"): Recallable =
  ## getCreateTags
  ## <p>Adds tags to a cluster.</p> <p>A resource can have up to 50 tags. If you try to create more than 50 tags for a resource, you will receive an error and the attempt will fail.</p> <p>If you specify a key that already exists for the resource, the value for that key will be updated with the new value.</p>
  ##   Tags: JArray (required)
  ##       : One or more name/value pairs to add as tags to the specified resource. Each tag name is passed in with the parameter <code>Key</code> and the corresponding value is passed in with the parameter <code>Value</code>. The <code>Key</code> and <code>Value</code> parameters are separated by a comma (,). Separate multiple tags with a space. For example, <code>--tags "Key"="owner","Value"="admin" "Key"="environment","Value"="test" "Key"="version","Value"="1.0"</code>. 
  ##   ResourceName: string (required)
  ##               : The Amazon Resource Name (ARN) to which you want to add the tag or tags. For example, <code>arn:aws:redshift:us-east-2:123456789:cluster:t1</code>. 
  ##   Action: string (required)
  ##   Version: string (required)
  var query_612003 = newJObject()
  if Tags != nil:
    query_612003.add "Tags", Tags
  add(query_612003, "ResourceName", newJString(ResourceName))
  add(query_612003, "Action", newJString(Action))
  add(query_612003, "Version", newJString(Version))
  result = call_612002.call(nil, query_612003, nil, nil, nil)

var getCreateTags* = Call_GetCreateTags_611987(name: "getCreateTags",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=CreateTags", validator: validate_GetCreateTags_611988,
    base: "/", url: url_GetCreateTags_611989, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDeleteCluster_612041 = ref object of OpenApiRestCall_610642
proc url_PostDeleteCluster_612043(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDeleteCluster_612042(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## <p>Deletes a previously provisioned cluster without its final snapshot being created. A successful response from the web service indicates that the request was received correctly. Use <a>DescribeClusters</a> to monitor the status of the deletion. The delete operation cannot be canceled or reverted once submitted. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you want to shut down the cluster and retain it for future use, set <i>SkipFinalClusterSnapshot</i> to <code>false</code> and specify a name for <i>FinalClusterSnapshotIdentifier</i>. You can later restore this snapshot to resume using the cluster. If a final cluster snapshot is requested, the status of the cluster will be "final-snapshot" while the snapshot is being taken, then it's "deleting" once Amazon Redshift begins deleting the cluster. </p> <p> For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_612044 = query.getOrDefault("Action")
  valid_612044 = validateParameter(valid_612044, JString, required = true,
                                 default = newJString("DeleteCluster"))
  if valid_612044 != nil:
    section.add "Action", valid_612044
  var valid_612045 = query.getOrDefault("Version")
  valid_612045 = validateParameter(valid_612045, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_612045 != nil:
    section.add "Version", valid_612045
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_612046 = header.getOrDefault("X-Amz-Signature")
  valid_612046 = validateParameter(valid_612046, JString, required = false,
                                 default = nil)
  if valid_612046 != nil:
    section.add "X-Amz-Signature", valid_612046
  var valid_612047 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_612047 = validateParameter(valid_612047, JString, required = false,
                                 default = nil)
  if valid_612047 != nil:
    section.add "X-Amz-Content-Sha256", valid_612047
  var valid_612048 = header.getOrDefault("X-Amz-Date")
  valid_612048 = validateParameter(valid_612048, JString, required = false,
                                 default = nil)
  if valid_612048 != nil:
    section.add "X-Amz-Date", valid_612048
  var valid_612049 = header.getOrDefault("X-Amz-Credential")
  valid_612049 = validateParameter(valid_612049, JString, required = false,
                                 default = nil)
  if valid_612049 != nil:
    section.add "X-Amz-Credential", valid_612049
  var valid_612050 = header.getOrDefault("X-Amz-Security-Token")
  valid_612050 = validateParameter(valid_612050, JString, required = false,
                                 default = nil)
  if valid_612050 != nil:
    section.add "X-Amz-Security-Token", valid_612050
  var valid_612051 = header.getOrDefault("X-Amz-Algorithm")
  valid_612051 = validateParameter(valid_612051, JString, required = false,
                                 default = nil)
  if valid_612051 != nil:
    section.add "X-Amz-Algorithm", valid_612051
  var valid_612052 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_612052 = validateParameter(valid_612052, JString, required = false,
                                 default = nil)
  if valid_612052 != nil:
    section.add "X-Amz-SignedHeaders", valid_612052
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The identifier of the cluster to be deleted.</p> <p>Constraints:</p> <ul> <li> <p>Must contain lowercase characters.</p> </li> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   FinalClusterSnapshotIdentifier: JString
  ##                                 : <p>The identifier of the final snapshot that is to be created immediately before deleting the cluster. If this parameter is provided, <i>SkipFinalClusterSnapshot</i> must be <code>false</code>. </p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   FinalClusterSnapshotRetentionPeriod: JInt
  ##                                      : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  ##   SkipFinalClusterSnapshot: JBool
  ##                           : <p>Determines whether a final snapshot of the cluster is created before Amazon Redshift deletes the cluster. If <code>true</code>, a final cluster snapshot is not created. If <code>false</code>, a final cluster snapshot is created before the cluster is deleted. </p> <note> <p>The <i>FinalClusterSnapshotIdentifier</i> parameter must be specified if <i>SkipFinalClusterSnapshot</i> is <code>false</code>.</p> </note> <p>Default: <code>false</code> </p>
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_612053 = formData.getOrDefault("ClusterIdentifier")
  valid_612053 = validateParameter(valid_612053, JString, required = true,
                                 default = nil)
  if valid_612053 != nil:
    section.add "ClusterIdentifier", valid_612053
  var valid_612054 = formData.getOrDefault("FinalClusterSnapshotIdentifier")
  valid_612054 = validateParameter(valid_612054, JString, required = false,
                                 default = nil)
  if valid_612054 != nil:
    section.add "FinalClusterSnapshotIdentifier", valid_612054
  var valid_612055 = formData.getOrDefault("FinalClusterSnapshotRetentionPeriod")
  valid_612055 = validateParameter(valid_612055, JInt, required = false, default = nil)
  if valid_612055 != nil:
    section.add "FinalClusterSnapshotRetentionPeriod", valid_612055
  var valid_612056 = formData.getOrDefault("SkipFinalClusterSnapshot")
  valid_612056 = validateParameter(valid_612056, JBool, required = false, default = nil)
  if valid_612056 != nil:
    section.add "SkipFinalClusterSnapshot", valid_612056
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_612057: Call_PostDeleteCluster_612041; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Deletes a previously provisioned cluster without its final snapshot being created. A successful response from the web service indicates that the request was received correctly. Use <a>DescribeClusters</a> to monitor the status of the deletion. The delete operation cannot be canceled or reverted once submitted. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you want to shut down the cluster and retain it for future use, set <i>SkipFinalClusterSnapshot</i> to <code>false</code> and specify a name for <i>FinalClusterSnapshotIdentifier</i>. You can later restore this snapshot to resume using the cluster. If a final cluster snapshot is requested, the status of the cluster will be "final-snapshot" while the snapshot is being taken, then it's "deleting" once Amazon Redshift begins deleting the cluster. </p> <p> For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_612057.validator(path, query, header, formData, body)
  let scheme = call_612057.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_612057.url(scheme.get, call_612057.host, call_612057.base,
                         call_612057.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_612057, url, valid)

proc call*(call_612058: Call_PostDeleteCluster_612041; ClusterIdentifier: string;
          FinalClusterSnapshotIdentifier: string = "";
          Action: string = "DeleteCluster";
          FinalClusterSnapshotRetentionPeriod: int = 0;
          Version: string = "2012-12-01"; SkipFinalClusterSnapshot: bool = false): Recallable =
  ## postDeleteCluster
  ## <p>Deletes a previously provisioned cluster without its final snapshot being created. A successful response from the web service indicates that the request was received correctly. Use <a>DescribeClusters</a> to monitor the status of the deletion. The delete operation cannot be canceled or reverted once submitted. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you want to shut down the cluster and retain it for future use, set <i>SkipFinalClusterSnapshot</i> to <code>false</code> and specify a name for <i>FinalClusterSnapshotIdentifier</i>. You can later restore this snapshot to resume using the cluster. If a final cluster snapshot is requested, the status of the cluster will be "final-snapshot" while the snapshot is being taken, then it's "deleting" once Amazon Redshift begins deleting the cluster. </p> <p> For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The identifier of the cluster to be deleted.</p> <p>Constraints:</p> <ul> <li> <p>Must contain lowercase characters.</p> </li> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   FinalClusterSnapshotIdentifier: string
  ##                                 : <p>The identifier of the final snapshot that is to be created immediately before deleting the cluster. If this parameter is provided, <i>SkipFinalClusterSnapshot</i> must be <code>false</code>. </p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   Action: string (required)
  ##   FinalClusterSnapshotRetentionPeriod: int
  ##                                      : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  ##   Version: string (required)
  ##   SkipFinalClusterSnapshot: bool
  ##                           : <p>Determines whether a final snapshot of the cluster is created before Amazon Redshift deletes the cluster. If <code>true</code>, a final cluster snapshot is not created. If <code>false</code>, a final cluster snapshot is created before the cluster is deleted. </p> <note> <p>The <i>FinalClusterSnapshotIdentifier</i> parameter must be specified if <i>SkipFinalClusterSnapshot</i> is <code>false</code>.</p> </note> <p>Default: <code>false</code> </p>
  var query_612059 = newJObject()
  var formData_612060 = newJObject()
  add(formData_612060, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_612060, "FinalClusterSnapshotIdentifier",
      newJString(FinalClusterSnapshotIdentifier))
  add(query_612059, "Action", newJString(Action))
  add(formData_612060, "FinalClusterSnapshotRetentionPeriod",
      newJInt(FinalClusterSnapshotRetentionPeriod))
  add(query_612059, "Version", newJString(Version))
  add(formData_612060, "SkipFinalClusterSnapshot",
      newJBool(SkipFinalClusterSnapshot))
  result = call_612058.call(nil, query_612059, nil, formData_612060, nil)

var postDeleteCluster* = Call_PostDeleteCluster_612041(name: "postDeleteCluster",
    meth: HttpMethod.HttpPost, host: "redshift.amazonaws.com",
    route: "/#Action=DeleteCluster", validator: validate_PostDeleteCluster_612042,
    base: "/", url: url_PostDeleteCluster_612043,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeleteCluster_612022 = ref object of OpenApiRestCall_610642
proc url_GetDeleteCluster_612024(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDeleteCluster_612023(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## <p>Deletes a previously provisioned cluster without its final snapshot being created. A successful response from the web service indicates that the request was received correctly. Use <a>DescribeClusters</a> to monitor the status of the deletion. The delete operation cannot be canceled or reverted once submitted. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you want to shut down the cluster and retain it for future use, set <i>SkipFinalClusterSnapshot</i> to <code>false</code> and specify a name for <i>FinalClusterSnapshotIdentifier</i>. You can later restore this snapshot to resume using the cluster. If a final cluster snapshot is requested, the status of the cluster will be "final-snapshot" while the snapshot is being taken, then it's "deleting" once Amazon Redshift begins deleting the cluster. </p> <p> For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   SkipFinalClusterSnapshot: JBool
  ##                           : <p>Determines whether a final snapshot of the cluster is created before Amazon Redshift deletes the cluster. If <code>true</code>, a final cluster snapshot is not created. If <code>false</code>, a final cluster snapshot is created before the cluster is deleted. </p> <note> <p>The <i>FinalClusterSnapshotIdentifier</i> parameter must be specified if <i>SkipFinalClusterSnapshot</i> is <code>false</code>.</p> </note> <p>Default: <code>false</code> </p>
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The identifier of the cluster to be deleted.</p> <p>Constraints:</p> <ul> <li> <p>Must contain lowercase characters.</p> </li> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   Version: JString (required)
  ##   FinalClusterSnapshotIdentifier: JString
  ##                                 : <p>The identifier of the final snapshot that is to be created immediately before deleting the cluster. If this parameter is provided, <i>SkipFinalClusterSnapshot</i> must be <code>false</code>. </p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   FinalClusterSnapshotRetentionPeriod: JInt
  ##                                      : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  section = newJObject()
  var valid_612025 = query.getOrDefault("Action")
  valid_612025 = validateParameter(valid_612025, JString, required = true,
                                 default = newJString("DeleteCluster"))
  if valid_612025 != nil:
    section.add "Action", valid_612025
  var valid_612026 = query.getOrDefault("SkipFinalClusterSnapshot")
  valid_612026 = validateParameter(valid_612026, JBool, required = false, default = nil)
  if valid_612026 != nil:
    section.add "SkipFinalClusterSnapshot", valid_612026
  var valid_612027 = query.getOrDefault("ClusterIdentifier")
  valid_612027 = validateParameter(valid_612027, JString, required = true,
                                 default = nil)
  if valid_612027 != nil:
    section.add "ClusterIdentifier", valid_612027
  var valid_612028 = query.getOrDefault("Version")
  valid_612028 = validateParameter(valid_612028, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_612028 != nil:
    section.add "Version", valid_612028
  var valid_612029 = query.getOrDefault("FinalClusterSnapshotIdentifier")
  valid_612029 = validateParameter(valid_612029, JString, required = false,
                                 default = nil)
  if valid_612029 != nil:
    section.add "FinalClusterSnapshotIdentifier", valid_612029
  var valid_612030 = query.getOrDefault("FinalClusterSnapshotRetentionPeriod")
  valid_612030 = validateParameter(valid_612030, JInt, required = false, default = nil)
  if valid_612030 != nil:
    section.add "FinalClusterSnapshotRetentionPeriod", valid_612030
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_612031 = header.getOrDefault("X-Amz-Signature")
  valid_612031 = validateParameter(valid_612031, JString, required = false,
                                 default = nil)
  if valid_612031 != nil:
    section.add "X-Amz-Signature", valid_612031
  var valid_612032 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_612032 = validateParameter(valid_612032, JString, required = false,
                                 default = nil)
  if valid_612032 != nil:
    section.add "X-Amz-Content-Sha256", valid_612032
  var valid_612033 = header.getOrDefault("X-Amz-Date")
  valid_612033 = validateParameter(valid_612033, JString, required = false,
                                 default = nil)
  if valid_612033 != nil:
    section.add "X-Amz-Date", valid_612033
  var valid_612034 = header.getOrDefault("X-Amz-Credential")
  valid_612034 = validateParameter(valid_612034, JString, required = false,
                                 default = nil)
  if valid_612034 != nil:
    section.add "X-Amz-Credential", valid_612034
  var valid_612035 = header.getOrDefault("X-Amz-Security-Token")
  valid_612035 = validateParameter(valid_612035, JString, required = false,
                                 default = nil)
  if valid_612035 != nil:
    section.add "X-Amz-Security-Token", valid_612035
  var valid_612036 = header.getOrDefault("X-Amz-Algorithm")
  valid_612036 = validateParameter(valid_612036, JString, required = false,
                                 default = nil)
  if valid_612036 != nil:
    section.add "X-Amz-Algorithm", valid_612036
  var valid_612037 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_612037 = validateParameter(valid_612037, JString, required = false,
                                 default = nil)
  if valid_612037 != nil:
    section.add "X-Amz-SignedHeaders", valid_612037
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_612038: Call_GetDeleteCluster_612022; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Deletes a previously provisioned cluster without its final snapshot being created. A successful response from the web service indicates that the request was received correctly. Use <a>DescribeClusters</a> to monitor the status of the deletion. The delete operation cannot be canceled or reverted once submitted. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you want to shut down the cluster and retain it for future use, set <i>SkipFinalClusterSnapshot</i> to <code>false</code> and specify a name for <i>FinalClusterSnapshotIdentifier</i>. You can later restore this snapshot to resume using the cluster. If a final cluster snapshot is requested, the status of the cluster will be "final-snapshot" while the snapshot is being taken, then it's "deleting" once Amazon Redshift begins deleting the cluster. </p> <p> For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_612038.validator(path, query, header, formData, body)
  let scheme = call_612038.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_612038.url(scheme.get, call_612038.host, call_612038.base,
                         call_612038.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_612038, url, valid)

proc call*(call_612039: Call_GetDeleteCluster_612022; ClusterIdentifier: string;
          Action: string = "DeleteCluster"; SkipFinalClusterSnapshot: bool = false;
          Version: string = "2012-12-01";
          FinalClusterSnapshotIdentifier: string = "";
          FinalClusterSnapshotRetentionPeriod: int = 0): Recallable =
  ## getDeleteCluster
  ## <p>Deletes a previously provisioned cluster without its final snapshot being created. A successful response from the web service indicates that the request was received correctly. Use <a>DescribeClusters</a> to monitor the status of the deletion. The delete operation cannot be canceled or reverted once submitted. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you want to shut down the cluster and retain it for future use, set <i>SkipFinalClusterSnapshot</i> to <code>false</code> and specify a name for <i>FinalClusterSnapshotIdentifier</i>. You can later restore this snapshot to resume using the cluster. If a final cluster snapshot is requested, the status of the cluster will be "final-snapshot" while the snapshot is being taken, then it's "deleting" once Amazon Redshift begins deleting the cluster. </p> <p> For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   Action: string (required)
  ##   SkipFinalClusterSnapshot: bool
  ##                           : <p>Determines whether a final snapshot of the cluster is created before Amazon Redshift deletes the cluster. If <code>true</code>, a final cluster snapshot is not created. If <code>false</code>, a final cluster snapshot is created before the cluster is deleted. </p> <note> <p>The <i>FinalClusterSnapshotIdentifier</i> parameter must be specified if <i>SkipFinalClusterSnapshot</i> is <code>false</code>.</p> </note> <p>Default: <code>false</code> </p>
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The identifier of the cluster to be deleted.</p> <p>Constraints:</p> <ul> <li> <p>Must contain lowercase characters.</p> </li> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   Version: string (required)
  ##   FinalClusterSnapshotIdentifier: string
  ##                                 : <p>The identifier of the final snapshot that is to be created immediately before deleting the cluster. If this parameter is provided, <i>SkipFinalClusterSnapshot</i> must be <code>false</code>. </p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   FinalClusterSnapshotRetentionPeriod: int
  ##                                      : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  var query_612040 = newJObject()
  add(query_612040, "Action", newJString(Action))
  add(query_612040, "SkipFinalClusterSnapshot", newJBool(SkipFinalClusterSnapshot))
  add(query_612040, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_612040, "Version", newJString(Version))
  add(query_612040, "FinalClusterSnapshotIdentifier",
      newJString(FinalClusterSnapshotIdentifier))
  add(query_612040, "FinalClusterSnapshotRetentionPeriod",
      newJInt(FinalClusterSnapshotRetentionPeriod))
  result = call_612039.call(nil, query_612040, nil, nil, nil)

var getDeleteCluster* = Call_GetDeleteCluster_612022(name: "getDeleteCluster",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=DeleteCluster", validator: validate_GetDeleteCluster_612023,
    base: "/", url: url_GetDeleteCluster_612024,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDeleteClusterParameterGroup_612077 = ref object of OpenApiRestCall_610642
proc url_PostDeleteClusterParameterGroup_612079(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDeleteClusterParameterGroup_612078(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Deletes a specified Amazon Redshift parameter group.</p> <note> <p>You cannot delete a parameter group if it is associated with a cluster.</p> </note>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_612080 = query.getOrDefault("Action")
  valid_612080 = validateParameter(valid_612080, JString, required = true, default = newJString(
      "DeleteClusterParameterGroup"))
  if valid_612080 != nil:
    section.add "Action", valid_612080
  var valid_612081 = query.getOrDefault("Version")
  valid_612081 = validateParameter(valid_612081, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_612081 != nil:
    section.add "Version", valid_612081
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_612082 = header.getOrDefault("X-Amz-Signature")
  valid_612082 = validateParameter(valid_612082, JString, required = false,
                                 default = nil)
  if valid_612082 != nil:
    section.add "X-Amz-Signature", valid_612082
  var valid_612083 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_612083 = validateParameter(valid_612083, JString, required = false,
                                 default = nil)
  if valid_612083 != nil:
    section.add "X-Amz-Content-Sha256", valid_612083
  var valid_612084 = header.getOrDefault("X-Amz-Date")
  valid_612084 = validateParameter(valid_612084, JString, required = false,
                                 default = nil)
  if valid_612084 != nil:
    section.add "X-Amz-Date", valid_612084
  var valid_612085 = header.getOrDefault("X-Amz-Credential")
  valid_612085 = validateParameter(valid_612085, JString, required = false,
                                 default = nil)
  if valid_612085 != nil:
    section.add "X-Amz-Credential", valid_612085
  var valid_612086 = header.getOrDefault("X-Amz-Security-Token")
  valid_612086 = validateParameter(valid_612086, JString, required = false,
                                 default = nil)
  if valid_612086 != nil:
    section.add "X-Amz-Security-Token", valid_612086
  var valid_612087 = header.getOrDefault("X-Amz-Algorithm")
  valid_612087 = validateParameter(valid_612087, JString, required = false,
                                 default = nil)
  if valid_612087 != nil:
    section.add "X-Amz-Algorithm", valid_612087
  var valid_612088 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_612088 = validateParameter(valid_612088, JString, required = false,
                                 default = nil)
  if valid_612088 != nil:
    section.add "X-Amz-SignedHeaders", valid_612088
  result.add "header", section
  ## parameters in `formData` object:
  ##   ParameterGroupName: JString (required)
  ##                     : <p>The name of the parameter group to be deleted.</p> <p>Constraints:</p> <ul> <li> <p>Must be the name of an existing cluster parameter group.</p> </li> <li> <p>Cannot delete a default cluster parameter group.</p> </li> </ul>
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ParameterGroupName` field"
  var valid_612089 = formData.getOrDefault("ParameterGroupName")
  valid_612089 = validateParameter(valid_612089, JString, required = true,
                                 default = nil)
  if valid_612089 != nil:
    section.add "ParameterGroupName", valid_612089
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_612090: Call_PostDeleteClusterParameterGroup_612077;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Deletes a specified Amazon Redshift parameter group.</p> <note> <p>You cannot delete a parameter group if it is associated with a cluster.</p> </note>
  ## 
  let valid = call_612090.validator(path, query, header, formData, body)
  let scheme = call_612090.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_612090.url(scheme.get, call_612090.host, call_612090.base,
                         call_612090.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_612090, url, valid)

proc call*(call_612091: Call_PostDeleteClusterParameterGroup_612077;
          ParameterGroupName: string;
          Action: string = "DeleteClusterParameterGroup";
          Version: string = "2012-12-01"): Recallable =
  ## postDeleteClusterParameterGroup
  ## <p>Deletes a specified Amazon Redshift parameter group.</p> <note> <p>You cannot delete a parameter group if it is associated with a cluster.</p> </note>
  ##   Action: string (required)
  ##   ParameterGroupName: string (required)
  ##                     : <p>The name of the parameter group to be deleted.</p> <p>Constraints:</p> <ul> <li> <p>Must be the name of an existing cluster parameter group.</p> </li> <li> <p>Cannot delete a default cluster parameter group.</p> </li> </ul>
  ##   Version: string (required)
  var query_612092 = newJObject()
  var formData_612093 = newJObject()
  add(query_612092, "Action", newJString(Action))
  add(formData_612093, "ParameterGroupName", newJString(ParameterGroupName))
  add(query_612092, "Version", newJString(Version))
  result = call_612091.call(nil, query_612092, nil, formData_612093, nil)

var postDeleteClusterParameterGroup* = Call_PostDeleteClusterParameterGroup_612077(
    name: "postDeleteClusterParameterGroup", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteClusterParameterGroup",
    validator: validate_PostDeleteClusterParameterGroup_612078, base: "/",
    url: url_PostDeleteClusterParameterGroup_612079,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeleteClusterParameterGroup_612061 = ref object of OpenApiRestCall_610642
proc url_GetDeleteClusterParameterGroup_612063(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDeleteClusterParameterGroup_612062(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Deletes a specified Amazon Redshift parameter group.</p> <note> <p>You cannot delete a parameter group if it is associated with a cluster.</p> </note>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   ParameterGroupName: JString (required)
  ##                     : <p>The name of the parameter group to be deleted.</p> <p>Constraints:</p> <ul> <li> <p>Must be the name of an existing cluster parameter group.</p> </li> <li> <p>Cannot delete a default cluster parameter group.</p> </li> </ul>
  ##   Version: JString (required)
  section = newJObject()
  var valid_612064 = query.getOrDefault("Action")
  valid_612064 = validateParameter(valid_612064, JString, required = true, default = newJString(
      "DeleteClusterParameterGroup"))
  if valid_612064 != nil:
    section.add "Action", valid_612064
  var valid_612065 = query.getOrDefault("ParameterGroupName")
  valid_612065 = validateParameter(valid_612065, JString, required = true,
                                 default = nil)
  if valid_612065 != nil:
    section.add "ParameterGroupName", valid_612065
  var valid_612066 = query.getOrDefault("Version")
  valid_612066 = validateParameter(valid_612066, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_612066 != nil:
    section.add "Version", valid_612066
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_612067 = header.getOrDefault("X-Amz-Signature")
  valid_612067 = validateParameter(valid_612067, JString, required = false,
                                 default = nil)
  if valid_612067 != nil:
    section.add "X-Amz-Signature", valid_612067
  var valid_612068 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_612068 = validateParameter(valid_612068, JString, required = false,
                                 default = nil)
  if valid_612068 != nil:
    section.add "X-Amz-Content-Sha256", valid_612068
  var valid_612069 = header.getOrDefault("X-Amz-Date")
  valid_612069 = validateParameter(valid_612069, JString, required = false,
                                 default = nil)
  if valid_612069 != nil:
    section.add "X-Amz-Date", valid_612069
  var valid_612070 = header.getOrDefault("X-Amz-Credential")
  valid_612070 = validateParameter(valid_612070, JString, required = false,
                                 default = nil)
  if valid_612070 != nil:
    section.add "X-Amz-Credential", valid_612070
  var valid_612071 = header.getOrDefault("X-Amz-Security-Token")
  valid_612071 = validateParameter(valid_612071, JString, required = false,
                                 default = nil)
  if valid_612071 != nil:
    section.add "X-Amz-Security-Token", valid_612071
  var valid_612072 = header.getOrDefault("X-Amz-Algorithm")
  valid_612072 = validateParameter(valid_612072, JString, required = false,
                                 default = nil)
  if valid_612072 != nil:
    section.add "X-Amz-Algorithm", valid_612072
  var valid_612073 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_612073 = validateParameter(valid_612073, JString, required = false,
                                 default = nil)
  if valid_612073 != nil:
    section.add "X-Amz-SignedHeaders", valid_612073
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_612074: Call_GetDeleteClusterParameterGroup_612061; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Deletes a specified Amazon Redshift parameter group.</p> <note> <p>You cannot delete a parameter group if it is associated with a cluster.</p> </note>
  ## 
  let valid = call_612074.validator(path, query, header, formData, body)
  let scheme = call_612074.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_612074.url(scheme.get, call_612074.host, call_612074.base,
                         call_612074.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_612074, url, valid)

proc call*(call_612075: Call_GetDeleteClusterParameterGroup_612061;
          ParameterGroupName: string;
          Action: string = "DeleteClusterParameterGroup";
          Version: string = "2012-12-01"): Recallable =
  ## getDeleteClusterParameterGroup
  ## <p>Deletes a specified Amazon Redshift parameter group.</p> <note> <p>You cannot delete a parameter group if it is associated with a cluster.</p> </note>
  ##   Action: string (required)
  ##   ParameterGroupName: string (required)
  ##                     : <p>The name of the parameter group to be deleted.</p> <p>Constraints:</p> <ul> <li> <p>Must be the name of an existing cluster parameter group.</p> </li> <li> <p>Cannot delete a default cluster parameter group.</p> </li> </ul>
  ##   Version: string (required)
  var query_612076 = newJObject()
  add(query_612076, "Action", newJString(Action))
  add(query_612076, "ParameterGroupName", newJString(ParameterGroupName))
  add(query_612076, "Version", newJString(Version))
  result = call_612075.call(nil, query_612076, nil, nil, nil)

var getDeleteClusterParameterGroup* = Call_GetDeleteClusterParameterGroup_612061(
    name: "getDeleteClusterParameterGroup", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteClusterParameterGroup",
    validator: validate_GetDeleteClusterParameterGroup_612062, base: "/",
    url: url_GetDeleteClusterParameterGroup_612063,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDeleteClusterSecurityGroup_612110 = ref object of OpenApiRestCall_610642
proc url_PostDeleteClusterSecurityGroup_612112(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDeleteClusterSecurityGroup_612111(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Deletes an Amazon Redshift security group.</p> <note> <p>You cannot delete a security group that is associated with any clusters. You cannot delete the default security group.</p> </note> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_612113 = query.getOrDefault("Action")
  valid_612113 = validateParameter(valid_612113, JString, required = true, default = newJString(
      "DeleteClusterSecurityGroup"))
  if valid_612113 != nil:
    section.add "Action", valid_612113
  var valid_612114 = query.getOrDefault("Version")
  valid_612114 = validateParameter(valid_612114, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_612114 != nil:
    section.add "Version", valid_612114
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_612115 = header.getOrDefault("X-Amz-Signature")
  valid_612115 = validateParameter(valid_612115, JString, required = false,
                                 default = nil)
  if valid_612115 != nil:
    section.add "X-Amz-Signature", valid_612115
  var valid_612116 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_612116 = validateParameter(valid_612116, JString, required = false,
                                 default = nil)
  if valid_612116 != nil:
    section.add "X-Amz-Content-Sha256", valid_612116
  var valid_612117 = header.getOrDefault("X-Amz-Date")
  valid_612117 = validateParameter(valid_612117, JString, required = false,
                                 default = nil)
  if valid_612117 != nil:
    section.add "X-Amz-Date", valid_612117
  var valid_612118 = header.getOrDefault("X-Amz-Credential")
  valid_612118 = validateParameter(valid_612118, JString, required = false,
                                 default = nil)
  if valid_612118 != nil:
    section.add "X-Amz-Credential", valid_612118
  var valid_612119 = header.getOrDefault("X-Amz-Security-Token")
  valid_612119 = validateParameter(valid_612119, JString, required = false,
                                 default = nil)
  if valid_612119 != nil:
    section.add "X-Amz-Security-Token", valid_612119
  var valid_612120 = header.getOrDefault("X-Amz-Algorithm")
  valid_612120 = validateParameter(valid_612120, JString, required = false,
                                 default = nil)
  if valid_612120 != nil:
    section.add "X-Amz-Algorithm", valid_612120
  var valid_612121 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_612121 = validateParameter(valid_612121, JString, required = false,
                                 default = nil)
  if valid_612121 != nil:
    section.add "X-Amz-SignedHeaders", valid_612121
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterSecurityGroupName: JString (required)
  ##                           : The name of the cluster security group to be deleted.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterSecurityGroupName` field"
  var valid_612122 = formData.getOrDefault("ClusterSecurityGroupName")
  valid_612122 = validateParameter(valid_612122, JString, required = true,
                                 default = nil)
  if valid_612122 != nil:
    section.add "ClusterSecurityGroupName", valid_612122
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_612123: Call_PostDeleteClusterSecurityGroup_612110; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Deletes an Amazon Redshift security group.</p> <note> <p>You cannot delete a security group that is associated with any clusters. You cannot delete the default security group.</p> </note> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_612123.validator(path, query, header, formData, body)
  let scheme = call_612123.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_612123.url(scheme.get, call_612123.host, call_612123.base,
                         call_612123.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_612123, url, valid)

proc call*(call_612124: Call_PostDeleteClusterSecurityGroup_612110;
          ClusterSecurityGroupName: string;
          Action: string = "DeleteClusterSecurityGroup";
          Version: string = "2012-12-01"): Recallable =
  ## postDeleteClusterSecurityGroup
  ## <p>Deletes an Amazon Redshift security group.</p> <note> <p>You cannot delete a security group that is associated with any clusters. You cannot delete the default security group.</p> </note> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   ClusterSecurityGroupName: string (required)
  ##                           : The name of the cluster security group to be deleted.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_612125 = newJObject()
  var formData_612126 = newJObject()
  add(formData_612126, "ClusterSecurityGroupName",
      newJString(ClusterSecurityGroupName))
  add(query_612125, "Action", newJString(Action))
  add(query_612125, "Version", newJString(Version))
  result = call_612124.call(nil, query_612125, nil, formData_612126, nil)

var postDeleteClusterSecurityGroup* = Call_PostDeleteClusterSecurityGroup_612110(
    name: "postDeleteClusterSecurityGroup", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteClusterSecurityGroup",
    validator: validate_PostDeleteClusterSecurityGroup_612111, base: "/",
    url: url_PostDeleteClusterSecurityGroup_612112,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeleteClusterSecurityGroup_612094 = ref object of OpenApiRestCall_610642
proc url_GetDeleteClusterSecurityGroup_612096(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDeleteClusterSecurityGroup_612095(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Deletes an Amazon Redshift security group.</p> <note> <p>You cannot delete a security group that is associated with any clusters. You cannot delete the default security group.</p> </note> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ClusterSecurityGroupName: JString (required)
  ##                           : The name of the cluster security group to be deleted.
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `ClusterSecurityGroupName` field"
  var valid_612097 = query.getOrDefault("ClusterSecurityGroupName")
  valid_612097 = validateParameter(valid_612097, JString, required = true,
                                 default = nil)
  if valid_612097 != nil:
    section.add "ClusterSecurityGroupName", valid_612097
  var valid_612098 = query.getOrDefault("Action")
  valid_612098 = validateParameter(valid_612098, JString, required = true, default = newJString(
      "DeleteClusterSecurityGroup"))
  if valid_612098 != nil:
    section.add "Action", valid_612098
  var valid_612099 = query.getOrDefault("Version")
  valid_612099 = validateParameter(valid_612099, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_612099 != nil:
    section.add "Version", valid_612099
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_612100 = header.getOrDefault("X-Amz-Signature")
  valid_612100 = validateParameter(valid_612100, JString, required = false,
                                 default = nil)
  if valid_612100 != nil:
    section.add "X-Amz-Signature", valid_612100
  var valid_612101 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_612101 = validateParameter(valid_612101, JString, required = false,
                                 default = nil)
  if valid_612101 != nil:
    section.add "X-Amz-Content-Sha256", valid_612101
  var valid_612102 = header.getOrDefault("X-Amz-Date")
  valid_612102 = validateParameter(valid_612102, JString, required = false,
                                 default = nil)
  if valid_612102 != nil:
    section.add "X-Amz-Date", valid_612102
  var valid_612103 = header.getOrDefault("X-Amz-Credential")
  valid_612103 = validateParameter(valid_612103, JString, required = false,
                                 default = nil)
  if valid_612103 != nil:
    section.add "X-Amz-Credential", valid_612103
  var valid_612104 = header.getOrDefault("X-Amz-Security-Token")
  valid_612104 = validateParameter(valid_612104, JString, required = false,
                                 default = nil)
  if valid_612104 != nil:
    section.add "X-Amz-Security-Token", valid_612104
  var valid_612105 = header.getOrDefault("X-Amz-Algorithm")
  valid_612105 = validateParameter(valid_612105, JString, required = false,
                                 default = nil)
  if valid_612105 != nil:
    section.add "X-Amz-Algorithm", valid_612105
  var valid_612106 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_612106 = validateParameter(valid_612106, JString, required = false,
                                 default = nil)
  if valid_612106 != nil:
    section.add "X-Amz-SignedHeaders", valid_612106
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_612107: Call_GetDeleteClusterSecurityGroup_612094; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Deletes an Amazon Redshift security group.</p> <note> <p>You cannot delete a security group that is associated with any clusters. You cannot delete the default security group.</p> </note> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_612107.validator(path, query, header, formData, body)
  let scheme = call_612107.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_612107.url(scheme.get, call_612107.host, call_612107.base,
                         call_612107.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_612107, url, valid)

proc call*(call_612108: Call_GetDeleteClusterSecurityGroup_612094;
          ClusterSecurityGroupName: string;
          Action: string = "DeleteClusterSecurityGroup";
          Version: string = "2012-12-01"): Recallable =
  ## getDeleteClusterSecurityGroup
  ## <p>Deletes an Amazon Redshift security group.</p> <note> <p>You cannot delete a security group that is associated with any clusters. You cannot delete the default security group.</p> </note> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   ClusterSecurityGroupName: string (required)
  ##                           : The name of the cluster security group to be deleted.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_612109 = newJObject()
  add(query_612109, "ClusterSecurityGroupName",
      newJString(ClusterSecurityGroupName))
  add(query_612109, "Action", newJString(Action))
  add(query_612109, "Version", newJString(Version))
  result = call_612108.call(nil, query_612109, nil, nil, nil)

var getDeleteClusterSecurityGroup* = Call_GetDeleteClusterSecurityGroup_612094(
    name: "getDeleteClusterSecurityGroup", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteClusterSecurityGroup",
    validator: validate_GetDeleteClusterSecurityGroup_612095, base: "/",
    url: url_GetDeleteClusterSecurityGroup_612096,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDeleteClusterSnapshot_612144 = ref object of OpenApiRestCall_610642
proc url_PostDeleteClusterSnapshot_612146(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDeleteClusterSnapshot_612145(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Deletes the specified manual snapshot. The snapshot must be in the <code>available</code> state, with no other users authorized to access the snapshot. </p> <p>Unlike automated snapshots, manual snapshots are retained even after you delete your cluster. Amazon Redshift does not delete your manual snapshots. You must delete manual snapshot explicitly to avoid getting charged. If other accounts are authorized to access the snapshot, you must revoke all of the authorizations before you can delete the snapshot.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_612147 = query.getOrDefault("Action")
  valid_612147 = validateParameter(valid_612147, JString, required = true,
                                 default = newJString("DeleteClusterSnapshot"))
  if valid_612147 != nil:
    section.add "Action", valid_612147
  var valid_612148 = query.getOrDefault("Version")
  valid_612148 = validateParameter(valid_612148, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_612148 != nil:
    section.add "Version", valid_612148
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_612149 = header.getOrDefault("X-Amz-Signature")
  valid_612149 = validateParameter(valid_612149, JString, required = false,
                                 default = nil)
  if valid_612149 != nil:
    section.add "X-Amz-Signature", valid_612149
  var valid_612150 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_612150 = validateParameter(valid_612150, JString, required = false,
                                 default = nil)
  if valid_612150 != nil:
    section.add "X-Amz-Content-Sha256", valid_612150
  var valid_612151 = header.getOrDefault("X-Amz-Date")
  valid_612151 = validateParameter(valid_612151, JString, required = false,
                                 default = nil)
  if valid_612151 != nil:
    section.add "X-Amz-Date", valid_612151
  var valid_612152 = header.getOrDefault("X-Amz-Credential")
  valid_612152 = validateParameter(valid_612152, JString, required = false,
                                 default = nil)
  if valid_612152 != nil:
    section.add "X-Amz-Credential", valid_612152
  var valid_612153 = header.getOrDefault("X-Amz-Security-Token")
  valid_612153 = validateParameter(valid_612153, JString, required = false,
                                 default = nil)
  if valid_612153 != nil:
    section.add "X-Amz-Security-Token", valid_612153
  var valid_612154 = header.getOrDefault("X-Amz-Algorithm")
  valid_612154 = validateParameter(valid_612154, JString, required = false,
                                 default = nil)
  if valid_612154 != nil:
    section.add "X-Amz-Algorithm", valid_612154
  var valid_612155 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_612155 = validateParameter(valid_612155, JString, required = false,
                                 default = nil)
  if valid_612155 != nil:
    section.add "X-Amz-SignedHeaders", valid_612155
  result.add "header", section
  ## parameters in `formData` object:
  ##   SnapshotIdentifier: JString (required)
  ##                     : <p>The unique identifier of the manual snapshot to be deleted.</p> <p>Constraints: Must be the name of an existing snapshot that is in the <code>available</code>, <code>failed</code>, or <code>cancelled</code> state.</p>
  ##   SnapshotClusterIdentifier: JString
  ##                            : <p>The unique identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.</p> <p>Constraints: Must be the name of valid cluster.</p>
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `SnapshotIdentifier` field"
  var valid_612156 = formData.getOrDefault("SnapshotIdentifier")
  valid_612156 = validateParameter(valid_612156, JString, required = true,
                                 default = nil)
  if valid_612156 != nil:
    section.add "SnapshotIdentifier", valid_612156
  var valid_612157 = formData.getOrDefault("SnapshotClusterIdentifier")
  valid_612157 = validateParameter(valid_612157, JString, required = false,
                                 default = nil)
  if valid_612157 != nil:
    section.add "SnapshotClusterIdentifier", valid_612157
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_612158: Call_PostDeleteClusterSnapshot_612144; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Deletes the specified manual snapshot. The snapshot must be in the <code>available</code> state, with no other users authorized to access the snapshot. </p> <p>Unlike automated snapshots, manual snapshots are retained even after you delete your cluster. Amazon Redshift does not delete your manual snapshots. You must delete manual snapshot explicitly to avoid getting charged. If other accounts are authorized to access the snapshot, you must revoke all of the authorizations before you can delete the snapshot.</p>
  ## 
  let valid = call_612158.validator(path, query, header, formData, body)
  let scheme = call_612158.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_612158.url(scheme.get, call_612158.host, call_612158.base,
                         call_612158.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_612158, url, valid)

proc call*(call_612159: Call_PostDeleteClusterSnapshot_612144;
          SnapshotIdentifier: string; Action: string = "DeleteClusterSnapshot";
          SnapshotClusterIdentifier: string = ""; Version: string = "2012-12-01"): Recallable =
  ## postDeleteClusterSnapshot
  ## <p>Deletes the specified manual snapshot. The snapshot must be in the <code>available</code> state, with no other users authorized to access the snapshot. </p> <p>Unlike automated snapshots, manual snapshots are retained even after you delete your cluster. Amazon Redshift does not delete your manual snapshots. You must delete manual snapshot explicitly to avoid getting charged. If other accounts are authorized to access the snapshot, you must revoke all of the authorizations before you can delete the snapshot.</p>
  ##   SnapshotIdentifier: string (required)
  ##                     : <p>The unique identifier of the manual snapshot to be deleted.</p> <p>Constraints: Must be the name of an existing snapshot that is in the <code>available</code>, <code>failed</code>, or <code>cancelled</code> state.</p>
  ##   Action: string (required)
  ##   SnapshotClusterIdentifier: string
  ##                            : <p>The unique identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.</p> <p>Constraints: Must be the name of valid cluster.</p>
  ##   Version: string (required)
  var query_612160 = newJObject()
  var formData_612161 = newJObject()
  add(formData_612161, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_612160, "Action", newJString(Action))
  add(formData_612161, "SnapshotClusterIdentifier",
      newJString(SnapshotClusterIdentifier))
  add(query_612160, "Version", newJString(Version))
  result = call_612159.call(nil, query_612160, nil, formData_612161, nil)

var postDeleteClusterSnapshot* = Call_PostDeleteClusterSnapshot_612144(
    name: "postDeleteClusterSnapshot", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteClusterSnapshot",
    validator: validate_PostDeleteClusterSnapshot_612145, base: "/",
    url: url_PostDeleteClusterSnapshot_612146,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeleteClusterSnapshot_612127 = ref object of OpenApiRestCall_610642
proc url_GetDeleteClusterSnapshot_612129(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDeleteClusterSnapshot_612128(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Deletes the specified manual snapshot. The snapshot must be in the <code>available</code> state, with no other users authorized to access the snapshot. </p> <p>Unlike automated snapshots, manual snapshots are retained even after you delete your cluster. Amazon Redshift does not delete your manual snapshots. You must delete manual snapshot explicitly to avoid getting charged. If other accounts are authorized to access the snapshot, you must revoke all of the authorizations before you can delete the snapshot.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   SnapshotIdentifier: JString (required)
  ##                     : <p>The unique identifier of the manual snapshot to be deleted.</p> <p>Constraints: Must be the name of an existing snapshot that is in the <code>available</code>, <code>failed</code>, or <code>cancelled</code> state.</p>
  ##   SnapshotClusterIdentifier: JString
  ##                            : <p>The unique identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.</p> <p>Constraints: Must be the name of valid cluster.</p>
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `SnapshotIdentifier` field"
  var valid_612130 = query.getOrDefault("SnapshotIdentifier")
  valid_612130 = validateParameter(valid_612130, JString, required = true,
                                 default = nil)
  if valid_612130 != nil:
    section.add "SnapshotIdentifier", valid_612130
  var valid_612131 = query.getOrDefault("SnapshotClusterIdentifier")
  valid_612131 = validateParameter(valid_612131, JString, required = false,
                                 default = nil)
  if valid_612131 != nil:
    section.add "SnapshotClusterIdentifier", valid_612131
  var valid_612132 = query.getOrDefault("Action")
  valid_612132 = validateParameter(valid_612132, JString, required = true,
                                 default = newJString("DeleteClusterSnapshot"))
  if valid_612132 != nil:
    section.add "Action", valid_612132
  var valid_612133 = query.getOrDefault("Version")
  valid_612133 = validateParameter(valid_612133, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_612133 != nil:
    section.add "Version", valid_612133
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_612134 = header.getOrDefault("X-Amz-Signature")
  valid_612134 = validateParameter(valid_612134, JString, required = false,
                                 default = nil)
  if valid_612134 != nil:
    section.add "X-Amz-Signature", valid_612134
  var valid_612135 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_612135 = validateParameter(valid_612135, JString, required = false,
                                 default = nil)
  if valid_612135 != nil:
    section.add "X-Amz-Content-Sha256", valid_612135
  var valid_612136 = header.getOrDefault("X-Amz-Date")
  valid_612136 = validateParameter(valid_612136, JString, required = false,
                                 default = nil)
  if valid_612136 != nil:
    section.add "X-Amz-Date", valid_612136
  var valid_612137 = header.getOrDefault("X-Amz-Credential")
  valid_612137 = validateParameter(valid_612137, JString, required = false,
                                 default = nil)
  if valid_612137 != nil:
    section.add "X-Amz-Credential", valid_612137
  var valid_612138 = header.getOrDefault("X-Amz-Security-Token")
  valid_612138 = validateParameter(valid_612138, JString, required = false,
                                 default = nil)
  if valid_612138 != nil:
    section.add "X-Amz-Security-Token", valid_612138
  var valid_612139 = header.getOrDefault("X-Amz-Algorithm")
  valid_612139 = validateParameter(valid_612139, JString, required = false,
                                 default = nil)
  if valid_612139 != nil:
    section.add "X-Amz-Algorithm", valid_612139
  var valid_612140 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_612140 = validateParameter(valid_612140, JString, required = false,
                                 default = nil)
  if valid_612140 != nil:
    section.add "X-Amz-SignedHeaders", valid_612140
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_612141: Call_GetDeleteClusterSnapshot_612127; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Deletes the specified manual snapshot. The snapshot must be in the <code>available</code> state, with no other users authorized to access the snapshot. </p> <p>Unlike automated snapshots, manual snapshots are retained even after you delete your cluster. Amazon Redshift does not delete your manual snapshots. You must delete manual snapshot explicitly to avoid getting charged. If other accounts are authorized to access the snapshot, you must revoke all of the authorizations before you can delete the snapshot.</p>
  ## 
  let valid = call_612141.validator(path, query, header, formData, body)
  let scheme = call_612141.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_612141.url(scheme.get, call_612141.host, call_612141.base,
                         call_612141.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_612141, url, valid)

proc call*(call_612142: Call_GetDeleteClusterSnapshot_612127;
          SnapshotIdentifier: string; SnapshotClusterIdentifier: string = "";
          Action: string = "DeleteClusterSnapshot"; Version: string = "2012-12-01"): Recallable =
  ## getDeleteClusterSnapshot
  ## <p>Deletes the specified manual snapshot. The snapshot must be in the <code>available</code> state, with no other users authorized to access the snapshot. </p> <p>Unlike automated snapshots, manual snapshots are retained even after you delete your cluster. Amazon Redshift does not delete your manual snapshots. You must delete manual snapshot explicitly to avoid getting charged. If other accounts are authorized to access the snapshot, you must revoke all of the authorizations before you can delete the snapshot.</p>
  ##   SnapshotIdentifier: string (required)
  ##                     : <p>The unique identifier of the manual snapshot to be deleted.</p> <p>Constraints: Must be the name of an existing snapshot that is in the <code>available</code>, <code>failed</code>, or <code>cancelled</code> state.</p>
  ##   SnapshotClusterIdentifier: string
  ##                            : <p>The unique identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.</p> <p>Constraints: Must be the name of valid cluster.</p>
  ##   Action: string (required)
  ##   Version: string (required)
  var query_612143 = newJObject()
  add(query_612143, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_612143, "SnapshotClusterIdentifier",
      newJString(SnapshotClusterIdentifier))
  add(query_612143, "Action", newJString(Action))
  add(query_612143, "Version", newJString(Version))
  result = call_612142.call(nil, query_612143, nil, nil, nil)

var getDeleteClusterSnapshot* = Call_GetDeleteClusterSnapshot_612127(
    name: "getDeleteClusterSnapshot", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteClusterSnapshot",
    validator: validate_GetDeleteClusterSnapshot_612128, base: "/",
    url: url_GetDeleteClusterSnapshot_612129, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDeleteClusterSubnetGroup_612178 = ref object of OpenApiRestCall_610642
proc url_PostDeleteClusterSubnetGroup_612180(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDeleteClusterSubnetGroup_612179(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes the specified cluster subnet group.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_612181 = query.getOrDefault("Action")
  valid_612181 = validateParameter(valid_612181, JString, required = true, default = newJString(
      "DeleteClusterSubnetGroup"))
  if valid_612181 != nil:
    section.add "Action", valid_612181
  var valid_612182 = query.getOrDefault("Version")
  valid_612182 = validateParameter(valid_612182, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_612182 != nil:
    section.add "Version", valid_612182
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_612183 = header.getOrDefault("X-Amz-Signature")
  valid_612183 = validateParameter(valid_612183, JString, required = false,
                                 default = nil)
  if valid_612183 != nil:
    section.add "X-Amz-Signature", valid_612183
  var valid_612184 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_612184 = validateParameter(valid_612184, JString, required = false,
                                 default = nil)
  if valid_612184 != nil:
    section.add "X-Amz-Content-Sha256", valid_612184
  var valid_612185 = header.getOrDefault("X-Amz-Date")
  valid_612185 = validateParameter(valid_612185, JString, required = false,
                                 default = nil)
  if valid_612185 != nil:
    section.add "X-Amz-Date", valid_612185
  var valid_612186 = header.getOrDefault("X-Amz-Credential")
  valid_612186 = validateParameter(valid_612186, JString, required = false,
                                 default = nil)
  if valid_612186 != nil:
    section.add "X-Amz-Credential", valid_612186
  var valid_612187 = header.getOrDefault("X-Amz-Security-Token")
  valid_612187 = validateParameter(valid_612187, JString, required = false,
                                 default = nil)
  if valid_612187 != nil:
    section.add "X-Amz-Security-Token", valid_612187
  var valid_612188 = header.getOrDefault("X-Amz-Algorithm")
  valid_612188 = validateParameter(valid_612188, JString, required = false,
                                 default = nil)
  if valid_612188 != nil:
    section.add "X-Amz-Algorithm", valid_612188
  var valid_612189 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_612189 = validateParameter(valid_612189, JString, required = false,
                                 default = nil)
  if valid_612189 != nil:
    section.add "X-Amz-SignedHeaders", valid_612189
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterSubnetGroupName: JString (required)
  ##                         : The name of the cluster subnet group name to be deleted.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterSubnetGroupName` field"
  var valid_612190 = formData.getOrDefault("ClusterSubnetGroupName")
  valid_612190 = validateParameter(valid_612190, JString, required = true,
                                 default = nil)
  if valid_612190 != nil:
    section.add "ClusterSubnetGroupName", valid_612190
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_612191: Call_PostDeleteClusterSubnetGroup_612178; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes the specified cluster subnet group.
  ## 
  let valid = call_612191.validator(path, query, header, formData, body)
  let scheme = call_612191.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_612191.url(scheme.get, call_612191.host, call_612191.base,
                         call_612191.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_612191, url, valid)

proc call*(call_612192: Call_PostDeleteClusterSubnetGroup_612178;
          ClusterSubnetGroupName: string;
          Action: string = "DeleteClusterSubnetGroup";
          Version: string = "2012-12-01"): Recallable =
  ## postDeleteClusterSubnetGroup
  ## Deletes the specified cluster subnet group.
  ##   ClusterSubnetGroupName: string (required)
  ##                         : The name of the cluster subnet group name to be deleted.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_612193 = newJObject()
  var formData_612194 = newJObject()
  add(formData_612194, "ClusterSubnetGroupName",
      newJString(ClusterSubnetGroupName))
  add(query_612193, "Action", newJString(Action))
  add(query_612193, "Version", newJString(Version))
  result = call_612192.call(nil, query_612193, nil, formData_612194, nil)

var postDeleteClusterSubnetGroup* = Call_PostDeleteClusterSubnetGroup_612178(
    name: "postDeleteClusterSubnetGroup", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteClusterSubnetGroup",
    validator: validate_PostDeleteClusterSubnetGroup_612179, base: "/",
    url: url_PostDeleteClusterSubnetGroup_612180,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeleteClusterSubnetGroup_612162 = ref object of OpenApiRestCall_610642
proc url_GetDeleteClusterSubnetGroup_612164(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDeleteClusterSubnetGroup_612163(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes the specified cluster subnet group.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ClusterSubnetGroupName: JString (required)
  ##                         : The name of the cluster subnet group name to be deleted.
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `ClusterSubnetGroupName` field"
  var valid_612165 = query.getOrDefault("ClusterSubnetGroupName")
  valid_612165 = validateParameter(valid_612165, JString, required = true,
                                 default = nil)
  if valid_612165 != nil:
    section.add "ClusterSubnetGroupName", valid_612165
  var valid_612166 = query.getOrDefault("Action")
  valid_612166 = validateParameter(valid_612166, JString, required = true, default = newJString(
      "DeleteClusterSubnetGroup"))
  if valid_612166 != nil:
    section.add "Action", valid_612166
  var valid_612167 = query.getOrDefault("Version")
  valid_612167 = validateParameter(valid_612167, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_612167 != nil:
    section.add "Version", valid_612167
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_612168 = header.getOrDefault("X-Amz-Signature")
  valid_612168 = validateParameter(valid_612168, JString, required = false,
                                 default = nil)
  if valid_612168 != nil:
    section.add "X-Amz-Signature", valid_612168
  var valid_612169 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_612169 = validateParameter(valid_612169, JString, required = false,
                                 default = nil)
  if valid_612169 != nil:
    section.add "X-Amz-Content-Sha256", valid_612169
  var valid_612170 = header.getOrDefault("X-Amz-Date")
  valid_612170 = validateParameter(valid_612170, JString, required = false,
                                 default = nil)
  if valid_612170 != nil:
    section.add "X-Amz-Date", valid_612170
  var valid_612171 = header.getOrDefault("X-Amz-Credential")
  valid_612171 = validateParameter(valid_612171, JString, required = false,
                                 default = nil)
  if valid_612171 != nil:
    section.add "X-Amz-Credential", valid_612171
  var valid_612172 = header.getOrDefault("X-Amz-Security-Token")
  valid_612172 = validateParameter(valid_612172, JString, required = false,
                                 default = nil)
  if valid_612172 != nil:
    section.add "X-Amz-Security-Token", valid_612172
  var valid_612173 = header.getOrDefault("X-Amz-Algorithm")
  valid_612173 = validateParameter(valid_612173, JString, required = false,
                                 default = nil)
  if valid_612173 != nil:
    section.add "X-Amz-Algorithm", valid_612173
  var valid_612174 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_612174 = validateParameter(valid_612174, JString, required = false,
                                 default = nil)
  if valid_612174 != nil:
    section.add "X-Amz-SignedHeaders", valid_612174
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_612175: Call_GetDeleteClusterSubnetGroup_612162; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes the specified cluster subnet group.
  ## 
  let valid = call_612175.validator(path, query, header, formData, body)
  let scheme = call_612175.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_612175.url(scheme.get, call_612175.host, call_612175.base,
                         call_612175.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_612175, url, valid)

proc call*(call_612176: Call_GetDeleteClusterSubnetGroup_612162;
          ClusterSubnetGroupName: string;
          Action: string = "DeleteClusterSubnetGroup";
          Version: string = "2012-12-01"): Recallable =
  ## getDeleteClusterSubnetGroup
  ## Deletes the specified cluster subnet group.
  ##   ClusterSubnetGroupName: string (required)
  ##                         : The name of the cluster subnet group name to be deleted.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_612177 = newJObject()
  add(query_612177, "ClusterSubnetGroupName", newJString(ClusterSubnetGroupName))
  add(query_612177, "Action", newJString(Action))
  add(query_612177, "Version", newJString(Version))
  result = call_612176.call(nil, query_612177, nil, nil, nil)

var getDeleteClusterSubnetGroup* = Call_GetDeleteClusterSubnetGroup_612162(
    name: "getDeleteClusterSubnetGroup", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteClusterSubnetGroup",
    validator: validate_GetDeleteClusterSubnetGroup_612163, base: "/",
    url: url_GetDeleteClusterSubnetGroup_612164,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDeleteEventSubscription_612211 = ref object of OpenApiRestCall_610642
proc url_PostDeleteEventSubscription_612213(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDeleteEventSubscription_612212(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes an Amazon Redshift event notification subscription.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_612214 = query.getOrDefault("Action")
  valid_612214 = validateParameter(valid_612214, JString, required = true, default = newJString(
      "DeleteEventSubscription"))
  if valid_612214 != nil:
    section.add "Action", valid_612214
  var valid_612215 = query.getOrDefault("Version")
  valid_612215 = validateParameter(valid_612215, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_612215 != nil:
    section.add "Version", valid_612215
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_612216 = header.getOrDefault("X-Amz-Signature")
  valid_612216 = validateParameter(valid_612216, JString, required = false,
                                 default = nil)
  if valid_612216 != nil:
    section.add "X-Amz-Signature", valid_612216
  var valid_612217 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_612217 = validateParameter(valid_612217, JString, required = false,
                                 default = nil)
  if valid_612217 != nil:
    section.add "X-Amz-Content-Sha256", valid_612217
  var valid_612218 = header.getOrDefault("X-Amz-Date")
  valid_612218 = validateParameter(valid_612218, JString, required = false,
                                 default = nil)
  if valid_612218 != nil:
    section.add "X-Amz-Date", valid_612218
  var valid_612219 = header.getOrDefault("X-Amz-Credential")
  valid_612219 = validateParameter(valid_612219, JString, required = false,
                                 default = nil)
  if valid_612219 != nil:
    section.add "X-Amz-Credential", valid_612219
  var valid_612220 = header.getOrDefault("X-Amz-Security-Token")
  valid_612220 = validateParameter(valid_612220, JString, required = false,
                                 default = nil)
  if valid_612220 != nil:
    section.add "X-Amz-Security-Token", valid_612220
  var valid_612221 = header.getOrDefault("X-Amz-Algorithm")
  valid_612221 = validateParameter(valid_612221, JString, required = false,
                                 default = nil)
  if valid_612221 != nil:
    section.add "X-Amz-Algorithm", valid_612221
  var valid_612222 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_612222 = validateParameter(valid_612222, JString, required = false,
                                 default = nil)
  if valid_612222 != nil:
    section.add "X-Amz-SignedHeaders", valid_612222
  result.add "header", section
  ## parameters in `formData` object:
  ##   SubscriptionName: JString (required)
  ##                   : The name of the Amazon Redshift event notification subscription to be deleted.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `SubscriptionName` field"
  var valid_612223 = formData.getOrDefault("SubscriptionName")
  valid_612223 = validateParameter(valid_612223, JString, required = true,
                                 default = nil)
  if valid_612223 != nil:
    section.add "SubscriptionName", valid_612223
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_612224: Call_PostDeleteEventSubscription_612211; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes an Amazon Redshift event notification subscription.
  ## 
  let valid = call_612224.validator(path, query, header, formData, body)
  let scheme = call_612224.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_612224.url(scheme.get, call_612224.host, call_612224.base,
                         call_612224.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_612224, url, valid)

proc call*(call_612225: Call_PostDeleteEventSubscription_612211;
          SubscriptionName: string; Action: string = "DeleteEventSubscription";
          Version: string = "2012-12-01"): Recallable =
  ## postDeleteEventSubscription
  ## Deletes an Amazon Redshift event notification subscription.
  ##   SubscriptionName: string (required)
  ##                   : The name of the Amazon Redshift event notification subscription to be deleted.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_612226 = newJObject()
  var formData_612227 = newJObject()
  add(formData_612227, "SubscriptionName", newJString(SubscriptionName))
  add(query_612226, "Action", newJString(Action))
  add(query_612226, "Version", newJString(Version))
  result = call_612225.call(nil, query_612226, nil, formData_612227, nil)

var postDeleteEventSubscription* = Call_PostDeleteEventSubscription_612211(
    name: "postDeleteEventSubscription", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteEventSubscription",
    validator: validate_PostDeleteEventSubscription_612212, base: "/",
    url: url_PostDeleteEventSubscription_612213,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeleteEventSubscription_612195 = ref object of OpenApiRestCall_610642
proc url_GetDeleteEventSubscription_612197(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDeleteEventSubscription_612196(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes an Amazon Redshift event notification subscription.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   SubscriptionName: JString (required)
  ##                   : The name of the Amazon Redshift event notification subscription to be deleted.
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `SubscriptionName` field"
  var valid_612198 = query.getOrDefault("SubscriptionName")
  valid_612198 = validateParameter(valid_612198, JString, required = true,
                                 default = nil)
  if valid_612198 != nil:
    section.add "SubscriptionName", valid_612198
  var valid_612199 = query.getOrDefault("Action")
  valid_612199 = validateParameter(valid_612199, JString, required = true, default = newJString(
      "DeleteEventSubscription"))
  if valid_612199 != nil:
    section.add "Action", valid_612199
  var valid_612200 = query.getOrDefault("Version")
  valid_612200 = validateParameter(valid_612200, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_612200 != nil:
    section.add "Version", valid_612200
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_612201 = header.getOrDefault("X-Amz-Signature")
  valid_612201 = validateParameter(valid_612201, JString, required = false,
                                 default = nil)
  if valid_612201 != nil:
    section.add "X-Amz-Signature", valid_612201
  var valid_612202 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_612202 = validateParameter(valid_612202, JString, required = false,
                                 default = nil)
  if valid_612202 != nil:
    section.add "X-Amz-Content-Sha256", valid_612202
  var valid_612203 = header.getOrDefault("X-Amz-Date")
  valid_612203 = validateParameter(valid_612203, JString, required = false,
                                 default = nil)
  if valid_612203 != nil:
    section.add "X-Amz-Date", valid_612203
  var valid_612204 = header.getOrDefault("X-Amz-Credential")
  valid_612204 = validateParameter(valid_612204, JString, required = false,
                                 default = nil)
  if valid_612204 != nil:
    section.add "X-Amz-Credential", valid_612204
  var valid_612205 = header.getOrDefault("X-Amz-Security-Token")
  valid_612205 = validateParameter(valid_612205, JString, required = false,
                                 default = nil)
  if valid_612205 != nil:
    section.add "X-Amz-Security-Token", valid_612205
  var valid_612206 = header.getOrDefault("X-Amz-Algorithm")
  valid_612206 = validateParameter(valid_612206, JString, required = false,
                                 default = nil)
  if valid_612206 != nil:
    section.add "X-Amz-Algorithm", valid_612206
  var valid_612207 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_612207 = validateParameter(valid_612207, JString, required = false,
                                 default = nil)
  if valid_612207 != nil:
    section.add "X-Amz-SignedHeaders", valid_612207
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_612208: Call_GetDeleteEventSubscription_612195; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes an Amazon Redshift event notification subscription.
  ## 
  let valid = call_612208.validator(path, query, header, formData, body)
  let scheme = call_612208.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_612208.url(scheme.get, call_612208.host, call_612208.base,
                         call_612208.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_612208, url, valid)

proc call*(call_612209: Call_GetDeleteEventSubscription_612195;
          SubscriptionName: string; Action: string = "DeleteEventSubscription";
          Version: string = "2012-12-01"): Recallable =
  ## getDeleteEventSubscription
  ## Deletes an Amazon Redshift event notification subscription.
  ##   SubscriptionName: string (required)
  ##                   : The name of the Amazon Redshift event notification subscription to be deleted.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_612210 = newJObject()
  add(query_612210, "SubscriptionName", newJString(SubscriptionName))
  add(query_612210, "Action", newJString(Action))
  add(query_612210, "Version", newJString(Version))
  result = call_612209.call(nil, query_612210, nil, nil, nil)

var getDeleteEventSubscription* = Call_GetDeleteEventSubscription_612195(
    name: "getDeleteEventSubscription", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteEventSubscription",
    validator: validate_GetDeleteEventSubscription_612196, base: "/",
    url: url_GetDeleteEventSubscription_612197,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDeleteHsmClientCertificate_612244 = ref object of OpenApiRestCall_610642
proc url_PostDeleteHsmClientCertificate_612246(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDeleteHsmClientCertificate_612245(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes the specified HSM client certificate.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_612247 = query.getOrDefault("Action")
  valid_612247 = validateParameter(valid_612247, JString, required = true, default = newJString(
      "DeleteHsmClientCertificate"))
  if valid_612247 != nil:
    section.add "Action", valid_612247
  var valid_612248 = query.getOrDefault("Version")
  valid_612248 = validateParameter(valid_612248, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_612248 != nil:
    section.add "Version", valid_612248
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_612249 = header.getOrDefault("X-Amz-Signature")
  valid_612249 = validateParameter(valid_612249, JString, required = false,
                                 default = nil)
  if valid_612249 != nil:
    section.add "X-Amz-Signature", valid_612249
  var valid_612250 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_612250 = validateParameter(valid_612250, JString, required = false,
                                 default = nil)
  if valid_612250 != nil:
    section.add "X-Amz-Content-Sha256", valid_612250
  var valid_612251 = header.getOrDefault("X-Amz-Date")
  valid_612251 = validateParameter(valid_612251, JString, required = false,
                                 default = nil)
  if valid_612251 != nil:
    section.add "X-Amz-Date", valid_612251
  var valid_612252 = header.getOrDefault("X-Amz-Credential")
  valid_612252 = validateParameter(valid_612252, JString, required = false,
                                 default = nil)
  if valid_612252 != nil:
    section.add "X-Amz-Credential", valid_612252
  var valid_612253 = header.getOrDefault("X-Amz-Security-Token")
  valid_612253 = validateParameter(valid_612253, JString, required = false,
                                 default = nil)
  if valid_612253 != nil:
    section.add "X-Amz-Security-Token", valid_612253
  var valid_612254 = header.getOrDefault("X-Amz-Algorithm")
  valid_612254 = validateParameter(valid_612254, JString, required = false,
                                 default = nil)
  if valid_612254 != nil:
    section.add "X-Amz-Algorithm", valid_612254
  var valid_612255 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_612255 = validateParameter(valid_612255, JString, required = false,
                                 default = nil)
  if valid_612255 != nil:
    section.add "X-Amz-SignedHeaders", valid_612255
  result.add "header", section
  ## parameters in `formData` object:
  ##   HsmClientCertificateIdentifier: JString (required)
  ##                                 : The identifier of the HSM client certificate to be deleted.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `HsmClientCertificateIdentifier` field"
  var valid_612256 = formData.getOrDefault("HsmClientCertificateIdentifier")
  valid_612256 = validateParameter(valid_612256, JString, required = true,
                                 default = nil)
  if valid_612256 != nil:
    section.add "HsmClientCertificateIdentifier", valid_612256
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_612257: Call_PostDeleteHsmClientCertificate_612244; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes the specified HSM client certificate.
  ## 
  let valid = call_612257.validator(path, query, header, formData, body)
  let scheme = call_612257.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_612257.url(scheme.get, call_612257.host, call_612257.base,
                         call_612257.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_612257, url, valid)

proc call*(call_612258: Call_PostDeleteHsmClientCertificate_612244;
          HsmClientCertificateIdentifier: string;
          Action: string = "DeleteHsmClientCertificate";
          Version: string = "2012-12-01"): Recallable =
  ## postDeleteHsmClientCertificate
  ## Deletes the specified HSM client certificate.
  ##   Action: string (required)
  ##   HsmClientCertificateIdentifier: string (required)
  ##                                 : The identifier of the HSM client certificate to be deleted.
  ##   Version: string (required)
  var query_612259 = newJObject()
  var formData_612260 = newJObject()
  add(query_612259, "Action", newJString(Action))
  add(formData_612260, "HsmClientCertificateIdentifier",
      newJString(HsmClientCertificateIdentifier))
  add(query_612259, "Version", newJString(Version))
  result = call_612258.call(nil, query_612259, nil, formData_612260, nil)

var postDeleteHsmClientCertificate* = Call_PostDeleteHsmClientCertificate_612244(
    name: "postDeleteHsmClientCertificate", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteHsmClientCertificate",
    validator: validate_PostDeleteHsmClientCertificate_612245, base: "/",
    url: url_PostDeleteHsmClientCertificate_612246,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeleteHsmClientCertificate_612228 = ref object of OpenApiRestCall_610642
proc url_GetDeleteHsmClientCertificate_612230(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDeleteHsmClientCertificate_612229(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes the specified HSM client certificate.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   HsmClientCertificateIdentifier: JString (required)
  ##                                 : The identifier of the HSM client certificate to be deleted.
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `HsmClientCertificateIdentifier` field"
  var valid_612231 = query.getOrDefault("HsmClientCertificateIdentifier")
  valid_612231 = validateParameter(valid_612231, JString, required = true,
                                 default = nil)
  if valid_612231 != nil:
    section.add "HsmClientCertificateIdentifier", valid_612231
  var valid_612232 = query.getOrDefault("Action")
  valid_612232 = validateParameter(valid_612232, JString, required = true, default = newJString(
      "DeleteHsmClientCertificate"))
  if valid_612232 != nil:
    section.add "Action", valid_612232
  var valid_612233 = query.getOrDefault("Version")
  valid_612233 = validateParameter(valid_612233, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_612233 != nil:
    section.add "Version", valid_612233
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_612234 = header.getOrDefault("X-Amz-Signature")
  valid_612234 = validateParameter(valid_612234, JString, required = false,
                                 default = nil)
  if valid_612234 != nil:
    section.add "X-Amz-Signature", valid_612234
  var valid_612235 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_612235 = validateParameter(valid_612235, JString, required = false,
                                 default = nil)
  if valid_612235 != nil:
    section.add "X-Amz-Content-Sha256", valid_612235
  var valid_612236 = header.getOrDefault("X-Amz-Date")
  valid_612236 = validateParameter(valid_612236, JString, required = false,
                                 default = nil)
  if valid_612236 != nil:
    section.add "X-Amz-Date", valid_612236
  var valid_612237 = header.getOrDefault("X-Amz-Credential")
  valid_612237 = validateParameter(valid_612237, JString, required = false,
                                 default = nil)
  if valid_612237 != nil:
    section.add "X-Amz-Credential", valid_612237
  var valid_612238 = header.getOrDefault("X-Amz-Security-Token")
  valid_612238 = validateParameter(valid_612238, JString, required = false,
                                 default = nil)
  if valid_612238 != nil:
    section.add "X-Amz-Security-Token", valid_612238
  var valid_612239 = header.getOrDefault("X-Amz-Algorithm")
  valid_612239 = validateParameter(valid_612239, JString, required = false,
                                 default = nil)
  if valid_612239 != nil:
    section.add "X-Amz-Algorithm", valid_612239
  var valid_612240 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_612240 = validateParameter(valid_612240, JString, required = false,
                                 default = nil)
  if valid_612240 != nil:
    section.add "X-Amz-SignedHeaders", valid_612240
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_612241: Call_GetDeleteHsmClientCertificate_612228; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes the specified HSM client certificate.
  ## 
  let valid = call_612241.validator(path, query, header, formData, body)
  let scheme = call_612241.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_612241.url(scheme.get, call_612241.host, call_612241.base,
                         call_612241.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_612241, url, valid)

proc call*(call_612242: Call_GetDeleteHsmClientCertificate_612228;
          HsmClientCertificateIdentifier: string;
          Action: string = "DeleteHsmClientCertificate";
          Version: string = "2012-12-01"): Recallable =
  ## getDeleteHsmClientCertificate
  ## Deletes the specified HSM client certificate.
  ##   HsmClientCertificateIdentifier: string (required)
  ##                                 : The identifier of the HSM client certificate to be deleted.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_612243 = newJObject()
  add(query_612243, "HsmClientCertificateIdentifier",
      newJString(HsmClientCertificateIdentifier))
  add(query_612243, "Action", newJString(Action))
  add(query_612243, "Version", newJString(Version))
  result = call_612242.call(nil, query_612243, nil, nil, nil)

var getDeleteHsmClientCertificate* = Call_GetDeleteHsmClientCertificate_612228(
    name: "getDeleteHsmClientCertificate", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteHsmClientCertificate",
    validator: validate_GetDeleteHsmClientCertificate_612229, base: "/",
    url: url_GetDeleteHsmClientCertificate_612230,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDeleteHsmConfiguration_612277 = ref object of OpenApiRestCall_610642
proc url_PostDeleteHsmConfiguration_612279(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDeleteHsmConfiguration_612278(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes the specified Amazon Redshift HSM configuration.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_612280 = query.getOrDefault("Action")
  valid_612280 = validateParameter(valid_612280, JString, required = true,
                                 default = newJString("DeleteHsmConfiguration"))
  if valid_612280 != nil:
    section.add "Action", valid_612280
  var valid_612281 = query.getOrDefault("Version")
  valid_612281 = validateParameter(valid_612281, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_612281 != nil:
    section.add "Version", valid_612281
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_612282 = header.getOrDefault("X-Amz-Signature")
  valid_612282 = validateParameter(valid_612282, JString, required = false,
                                 default = nil)
  if valid_612282 != nil:
    section.add "X-Amz-Signature", valid_612282
  var valid_612283 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_612283 = validateParameter(valid_612283, JString, required = false,
                                 default = nil)
  if valid_612283 != nil:
    section.add "X-Amz-Content-Sha256", valid_612283
  var valid_612284 = header.getOrDefault("X-Amz-Date")
  valid_612284 = validateParameter(valid_612284, JString, required = false,
                                 default = nil)
  if valid_612284 != nil:
    section.add "X-Amz-Date", valid_612284
  var valid_612285 = header.getOrDefault("X-Amz-Credential")
  valid_612285 = validateParameter(valid_612285, JString, required = false,
                                 default = nil)
  if valid_612285 != nil:
    section.add "X-Amz-Credential", valid_612285
  var valid_612286 = header.getOrDefault("X-Amz-Security-Token")
  valid_612286 = validateParameter(valid_612286, JString, required = false,
                                 default = nil)
  if valid_612286 != nil:
    section.add "X-Amz-Security-Token", valid_612286
  var valid_612287 = header.getOrDefault("X-Amz-Algorithm")
  valid_612287 = validateParameter(valid_612287, JString, required = false,
                                 default = nil)
  if valid_612287 != nil:
    section.add "X-Amz-Algorithm", valid_612287
  var valid_612288 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_612288 = validateParameter(valid_612288, JString, required = false,
                                 default = nil)
  if valid_612288 != nil:
    section.add "X-Amz-SignedHeaders", valid_612288
  result.add "header", section
  ## parameters in `formData` object:
  ##   HsmConfigurationIdentifier: JString (required)
  ##                             : The identifier of the Amazon Redshift HSM configuration to be deleted.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `HsmConfigurationIdentifier` field"
  var valid_612289 = formData.getOrDefault("HsmConfigurationIdentifier")
  valid_612289 = validateParameter(valid_612289, JString, required = true,
                                 default = nil)
  if valid_612289 != nil:
    section.add "HsmConfigurationIdentifier", valid_612289
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_612290: Call_PostDeleteHsmConfiguration_612277; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes the specified Amazon Redshift HSM configuration.
  ## 
  let valid = call_612290.validator(path, query, header, formData, body)
  let scheme = call_612290.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_612290.url(scheme.get, call_612290.host, call_612290.base,
                         call_612290.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_612290, url, valid)

proc call*(call_612291: Call_PostDeleteHsmConfiguration_612277;
          HsmConfigurationIdentifier: string;
          Action: string = "DeleteHsmConfiguration"; Version: string = "2012-12-01"): Recallable =
  ## postDeleteHsmConfiguration
  ## Deletes the specified Amazon Redshift HSM configuration.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   HsmConfigurationIdentifier: string (required)
  ##                             : The identifier of the Amazon Redshift HSM configuration to be deleted.
  var query_612292 = newJObject()
  var formData_612293 = newJObject()
  add(query_612292, "Action", newJString(Action))
  add(query_612292, "Version", newJString(Version))
  add(formData_612293, "HsmConfigurationIdentifier",
      newJString(HsmConfigurationIdentifier))
  result = call_612291.call(nil, query_612292, nil, formData_612293, nil)

var postDeleteHsmConfiguration* = Call_PostDeleteHsmConfiguration_612277(
    name: "postDeleteHsmConfiguration", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteHsmConfiguration",
    validator: validate_PostDeleteHsmConfiguration_612278, base: "/",
    url: url_PostDeleteHsmConfiguration_612279,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeleteHsmConfiguration_612261 = ref object of OpenApiRestCall_610642
proc url_GetDeleteHsmConfiguration_612263(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDeleteHsmConfiguration_612262(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes the specified Amazon Redshift HSM configuration.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   HsmConfigurationIdentifier: JString (required)
  ##                             : The identifier of the Amazon Redshift HSM configuration to be deleted.
  ##   Version: JString (required)
  section = newJObject()
  var valid_612264 = query.getOrDefault("Action")
  valid_612264 = validateParameter(valid_612264, JString, required = true,
                                 default = newJString("DeleteHsmConfiguration"))
  if valid_612264 != nil:
    section.add "Action", valid_612264
  var valid_612265 = query.getOrDefault("HsmConfigurationIdentifier")
  valid_612265 = validateParameter(valid_612265, JString, required = true,
                                 default = nil)
  if valid_612265 != nil:
    section.add "HsmConfigurationIdentifier", valid_612265
  var valid_612266 = query.getOrDefault("Version")
  valid_612266 = validateParameter(valid_612266, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_612266 != nil:
    section.add "Version", valid_612266
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_612267 = header.getOrDefault("X-Amz-Signature")
  valid_612267 = validateParameter(valid_612267, JString, required = false,
                                 default = nil)
  if valid_612267 != nil:
    section.add "X-Amz-Signature", valid_612267
  var valid_612268 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_612268 = validateParameter(valid_612268, JString, required = false,
                                 default = nil)
  if valid_612268 != nil:
    section.add "X-Amz-Content-Sha256", valid_612268
  var valid_612269 = header.getOrDefault("X-Amz-Date")
  valid_612269 = validateParameter(valid_612269, JString, required = false,
                                 default = nil)
  if valid_612269 != nil:
    section.add "X-Amz-Date", valid_612269
  var valid_612270 = header.getOrDefault("X-Amz-Credential")
  valid_612270 = validateParameter(valid_612270, JString, required = false,
                                 default = nil)
  if valid_612270 != nil:
    section.add "X-Amz-Credential", valid_612270
  var valid_612271 = header.getOrDefault("X-Amz-Security-Token")
  valid_612271 = validateParameter(valid_612271, JString, required = false,
                                 default = nil)
  if valid_612271 != nil:
    section.add "X-Amz-Security-Token", valid_612271
  var valid_612272 = header.getOrDefault("X-Amz-Algorithm")
  valid_612272 = validateParameter(valid_612272, JString, required = false,
                                 default = nil)
  if valid_612272 != nil:
    section.add "X-Amz-Algorithm", valid_612272
  var valid_612273 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_612273 = validateParameter(valid_612273, JString, required = false,
                                 default = nil)
  if valid_612273 != nil:
    section.add "X-Amz-SignedHeaders", valid_612273
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_612274: Call_GetDeleteHsmConfiguration_612261; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes the specified Amazon Redshift HSM configuration.
  ## 
  let valid = call_612274.validator(path, query, header, formData, body)
  let scheme = call_612274.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_612274.url(scheme.get, call_612274.host, call_612274.base,
                         call_612274.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_612274, url, valid)

proc call*(call_612275: Call_GetDeleteHsmConfiguration_612261;
          HsmConfigurationIdentifier: string;
          Action: string = "DeleteHsmConfiguration"; Version: string = "2012-12-01"): Recallable =
  ## getDeleteHsmConfiguration
  ## Deletes the specified Amazon Redshift HSM configuration.
  ##   Action: string (required)
  ##   HsmConfigurationIdentifier: string (required)
  ##                             : The identifier of the Amazon Redshift HSM configuration to be deleted.
  ##   Version: string (required)
  var query_612276 = newJObject()
  add(query_612276, "Action", newJString(Action))
  add(query_612276, "HsmConfigurationIdentifier",
      newJString(HsmConfigurationIdentifier))
  add(query_612276, "Version", newJString(Version))
  result = call_612275.call(nil, query_612276, nil, nil, nil)

var getDeleteHsmConfiguration* = Call_GetDeleteHsmConfiguration_612261(
    name: "getDeleteHsmConfiguration", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteHsmConfiguration",
    validator: validate_GetDeleteHsmConfiguration_612262, base: "/",
    url: url_GetDeleteHsmConfiguration_612263,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDeleteScheduledAction_612310 = ref object of OpenApiRestCall_610642
proc url_PostDeleteScheduledAction_612312(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDeleteScheduledAction_612311(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a scheduled action. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_612313 = query.getOrDefault("Action")
  valid_612313 = validateParameter(valid_612313, JString, required = true,
                                 default = newJString("DeleteScheduledAction"))
  if valid_612313 != nil:
    section.add "Action", valid_612313
  var valid_612314 = query.getOrDefault("Version")
  valid_612314 = validateParameter(valid_612314, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_612314 != nil:
    section.add "Version", valid_612314
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_612315 = header.getOrDefault("X-Amz-Signature")
  valid_612315 = validateParameter(valid_612315, JString, required = false,
                                 default = nil)
  if valid_612315 != nil:
    section.add "X-Amz-Signature", valid_612315
  var valid_612316 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_612316 = validateParameter(valid_612316, JString, required = false,
                                 default = nil)
  if valid_612316 != nil:
    section.add "X-Amz-Content-Sha256", valid_612316
  var valid_612317 = header.getOrDefault("X-Amz-Date")
  valid_612317 = validateParameter(valid_612317, JString, required = false,
                                 default = nil)
  if valid_612317 != nil:
    section.add "X-Amz-Date", valid_612317
  var valid_612318 = header.getOrDefault("X-Amz-Credential")
  valid_612318 = validateParameter(valid_612318, JString, required = false,
                                 default = nil)
  if valid_612318 != nil:
    section.add "X-Amz-Credential", valid_612318
  var valid_612319 = header.getOrDefault("X-Amz-Security-Token")
  valid_612319 = validateParameter(valid_612319, JString, required = false,
                                 default = nil)
  if valid_612319 != nil:
    section.add "X-Amz-Security-Token", valid_612319
  var valid_612320 = header.getOrDefault("X-Amz-Algorithm")
  valid_612320 = validateParameter(valid_612320, JString, required = false,
                                 default = nil)
  if valid_612320 != nil:
    section.add "X-Amz-Algorithm", valid_612320
  var valid_612321 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_612321 = validateParameter(valid_612321, JString, required = false,
                                 default = nil)
  if valid_612321 != nil:
    section.add "X-Amz-SignedHeaders", valid_612321
  result.add "header", section
  ## parameters in `formData` object:
  ##   ScheduledActionName: JString (required)
  ##                      : The name of the scheduled action to delete. 
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ScheduledActionName` field"
  var valid_612322 = formData.getOrDefault("ScheduledActionName")
  valid_612322 = validateParameter(valid_612322, JString, required = true,
                                 default = nil)
  if valid_612322 != nil:
    section.add "ScheduledActionName", valid_612322
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_612323: Call_PostDeleteScheduledAction_612310; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a scheduled action. 
  ## 
  let valid = call_612323.validator(path, query, header, formData, body)
  let scheme = call_612323.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_612323.url(scheme.get, call_612323.host, call_612323.base,
                         call_612323.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_612323, url, valid)

proc call*(call_612324: Call_PostDeleteScheduledAction_612310;
          ScheduledActionName: string; Action: string = "DeleteScheduledAction";
          Version: string = "2012-12-01"): Recallable =
  ## postDeleteScheduledAction
  ## Deletes a scheduled action. 
  ##   ScheduledActionName: string (required)
  ##                      : The name of the scheduled action to delete. 
  ##   Action: string (required)
  ##   Version: string (required)
  var query_612325 = newJObject()
  var formData_612326 = newJObject()
  add(formData_612326, "ScheduledActionName", newJString(ScheduledActionName))
  add(query_612325, "Action", newJString(Action))
  add(query_612325, "Version", newJString(Version))
  result = call_612324.call(nil, query_612325, nil, formData_612326, nil)

var postDeleteScheduledAction* = Call_PostDeleteScheduledAction_612310(
    name: "postDeleteScheduledAction", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteScheduledAction",
    validator: validate_PostDeleteScheduledAction_612311, base: "/",
    url: url_PostDeleteScheduledAction_612312,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeleteScheduledAction_612294 = ref object of OpenApiRestCall_610642
proc url_GetDeleteScheduledAction_612296(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDeleteScheduledAction_612295(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a scheduled action. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ScheduledActionName: JString (required)
  ##                      : The name of the scheduled action to delete. 
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `ScheduledActionName` field"
  var valid_612297 = query.getOrDefault("ScheduledActionName")
  valid_612297 = validateParameter(valid_612297, JString, required = true,
                                 default = nil)
  if valid_612297 != nil:
    section.add "ScheduledActionName", valid_612297
  var valid_612298 = query.getOrDefault("Action")
  valid_612298 = validateParameter(valid_612298, JString, required = true,
                                 default = newJString("DeleteScheduledAction"))
  if valid_612298 != nil:
    section.add "Action", valid_612298
  var valid_612299 = query.getOrDefault("Version")
  valid_612299 = validateParameter(valid_612299, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_612299 != nil:
    section.add "Version", valid_612299
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_612300 = header.getOrDefault("X-Amz-Signature")
  valid_612300 = validateParameter(valid_612300, JString, required = false,
                                 default = nil)
  if valid_612300 != nil:
    section.add "X-Amz-Signature", valid_612300
  var valid_612301 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_612301 = validateParameter(valid_612301, JString, required = false,
                                 default = nil)
  if valid_612301 != nil:
    section.add "X-Amz-Content-Sha256", valid_612301
  var valid_612302 = header.getOrDefault("X-Amz-Date")
  valid_612302 = validateParameter(valid_612302, JString, required = false,
                                 default = nil)
  if valid_612302 != nil:
    section.add "X-Amz-Date", valid_612302
  var valid_612303 = header.getOrDefault("X-Amz-Credential")
  valid_612303 = validateParameter(valid_612303, JString, required = false,
                                 default = nil)
  if valid_612303 != nil:
    section.add "X-Amz-Credential", valid_612303
  var valid_612304 = header.getOrDefault("X-Amz-Security-Token")
  valid_612304 = validateParameter(valid_612304, JString, required = false,
                                 default = nil)
  if valid_612304 != nil:
    section.add "X-Amz-Security-Token", valid_612304
  var valid_612305 = header.getOrDefault("X-Amz-Algorithm")
  valid_612305 = validateParameter(valid_612305, JString, required = false,
                                 default = nil)
  if valid_612305 != nil:
    section.add "X-Amz-Algorithm", valid_612305
  var valid_612306 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_612306 = validateParameter(valid_612306, JString, required = false,
                                 default = nil)
  if valid_612306 != nil:
    section.add "X-Amz-SignedHeaders", valid_612306
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_612307: Call_GetDeleteScheduledAction_612294; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a scheduled action. 
  ## 
  let valid = call_612307.validator(path, query, header, formData, body)
  let scheme = call_612307.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_612307.url(scheme.get, call_612307.host, call_612307.base,
                         call_612307.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_612307, url, valid)

proc call*(call_612308: Call_GetDeleteScheduledAction_612294;
          ScheduledActionName: string; Action: string = "DeleteScheduledAction";
          Version: string = "2012-12-01"): Recallable =
  ## getDeleteScheduledAction
  ## Deletes a scheduled action. 
  ##   ScheduledActionName: string (required)
  ##                      : The name of the scheduled action to delete. 
  ##   Action: string (required)
  ##   Version: string (required)
  var query_612309 = newJObject()
  add(query_612309, "ScheduledActionName", newJString(ScheduledActionName))
  add(query_612309, "Action", newJString(Action))
  add(query_612309, "Version", newJString(Version))
  result = call_612308.call(nil, query_612309, nil, nil, nil)

var getDeleteScheduledAction* = Call_GetDeleteScheduledAction_612294(
    name: "getDeleteScheduledAction", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteScheduledAction",
    validator: validate_GetDeleteScheduledAction_612295, base: "/",
    url: url_GetDeleteScheduledAction_612296, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDeleteSnapshotCopyGrant_612343 = ref object of OpenApiRestCall_610642
proc url_PostDeleteSnapshotCopyGrant_612345(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDeleteSnapshotCopyGrant_612344(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes the specified snapshot copy grant.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_612346 = query.getOrDefault("Action")
  valid_612346 = validateParameter(valid_612346, JString, required = true, default = newJString(
      "DeleteSnapshotCopyGrant"))
  if valid_612346 != nil:
    section.add "Action", valid_612346
  var valid_612347 = query.getOrDefault("Version")
  valid_612347 = validateParameter(valid_612347, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_612347 != nil:
    section.add "Version", valid_612347
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_612348 = header.getOrDefault("X-Amz-Signature")
  valid_612348 = validateParameter(valid_612348, JString, required = false,
                                 default = nil)
  if valid_612348 != nil:
    section.add "X-Amz-Signature", valid_612348
  var valid_612349 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_612349 = validateParameter(valid_612349, JString, required = false,
                                 default = nil)
  if valid_612349 != nil:
    section.add "X-Amz-Content-Sha256", valid_612349
  var valid_612350 = header.getOrDefault("X-Amz-Date")
  valid_612350 = validateParameter(valid_612350, JString, required = false,
                                 default = nil)
  if valid_612350 != nil:
    section.add "X-Amz-Date", valid_612350
  var valid_612351 = header.getOrDefault("X-Amz-Credential")
  valid_612351 = validateParameter(valid_612351, JString, required = false,
                                 default = nil)
  if valid_612351 != nil:
    section.add "X-Amz-Credential", valid_612351
  var valid_612352 = header.getOrDefault("X-Amz-Security-Token")
  valid_612352 = validateParameter(valid_612352, JString, required = false,
                                 default = nil)
  if valid_612352 != nil:
    section.add "X-Amz-Security-Token", valid_612352
  var valid_612353 = header.getOrDefault("X-Amz-Algorithm")
  valid_612353 = validateParameter(valid_612353, JString, required = false,
                                 default = nil)
  if valid_612353 != nil:
    section.add "X-Amz-Algorithm", valid_612353
  var valid_612354 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_612354 = validateParameter(valid_612354, JString, required = false,
                                 default = nil)
  if valid_612354 != nil:
    section.add "X-Amz-SignedHeaders", valid_612354
  result.add "header", section
  ## parameters in `formData` object:
  ##   SnapshotCopyGrantName: JString (required)
  ##                        : The name of the snapshot copy grant to delete.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `SnapshotCopyGrantName` field"
  var valid_612355 = formData.getOrDefault("SnapshotCopyGrantName")
  valid_612355 = validateParameter(valid_612355, JString, required = true,
                                 default = nil)
  if valid_612355 != nil:
    section.add "SnapshotCopyGrantName", valid_612355
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_612356: Call_PostDeleteSnapshotCopyGrant_612343; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes the specified snapshot copy grant.
  ## 
  let valid = call_612356.validator(path, query, header, formData, body)
  let scheme = call_612356.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_612356.url(scheme.get, call_612356.host, call_612356.base,
                         call_612356.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_612356, url, valid)

proc call*(call_612357: Call_PostDeleteSnapshotCopyGrant_612343;
          SnapshotCopyGrantName: string;
          Action: string = "DeleteSnapshotCopyGrant"; Version: string = "2012-12-01"): Recallable =
  ## postDeleteSnapshotCopyGrant
  ## Deletes the specified snapshot copy grant.
  ##   Action: string (required)
  ##   SnapshotCopyGrantName: string (required)
  ##                        : The name of the snapshot copy grant to delete.
  ##   Version: string (required)
  var query_612358 = newJObject()
  var formData_612359 = newJObject()
  add(query_612358, "Action", newJString(Action))
  add(formData_612359, "SnapshotCopyGrantName", newJString(SnapshotCopyGrantName))
  add(query_612358, "Version", newJString(Version))
  result = call_612357.call(nil, query_612358, nil, formData_612359, nil)

var postDeleteSnapshotCopyGrant* = Call_PostDeleteSnapshotCopyGrant_612343(
    name: "postDeleteSnapshotCopyGrant", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteSnapshotCopyGrant",
    validator: validate_PostDeleteSnapshotCopyGrant_612344, base: "/",
    url: url_PostDeleteSnapshotCopyGrant_612345,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeleteSnapshotCopyGrant_612327 = ref object of OpenApiRestCall_610642
proc url_GetDeleteSnapshotCopyGrant_612329(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDeleteSnapshotCopyGrant_612328(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes the specified snapshot copy grant.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  ##   SnapshotCopyGrantName: JString (required)
  ##                        : The name of the snapshot copy grant to delete.
  section = newJObject()
  var valid_612330 = query.getOrDefault("Action")
  valid_612330 = validateParameter(valid_612330, JString, required = true, default = newJString(
      "DeleteSnapshotCopyGrant"))
  if valid_612330 != nil:
    section.add "Action", valid_612330
  var valid_612331 = query.getOrDefault("Version")
  valid_612331 = validateParameter(valid_612331, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_612331 != nil:
    section.add "Version", valid_612331
  var valid_612332 = query.getOrDefault("SnapshotCopyGrantName")
  valid_612332 = validateParameter(valid_612332, JString, required = true,
                                 default = nil)
  if valid_612332 != nil:
    section.add "SnapshotCopyGrantName", valid_612332
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_612333 = header.getOrDefault("X-Amz-Signature")
  valid_612333 = validateParameter(valid_612333, JString, required = false,
                                 default = nil)
  if valid_612333 != nil:
    section.add "X-Amz-Signature", valid_612333
  var valid_612334 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_612334 = validateParameter(valid_612334, JString, required = false,
                                 default = nil)
  if valid_612334 != nil:
    section.add "X-Amz-Content-Sha256", valid_612334
  var valid_612335 = header.getOrDefault("X-Amz-Date")
  valid_612335 = validateParameter(valid_612335, JString, required = false,
                                 default = nil)
  if valid_612335 != nil:
    section.add "X-Amz-Date", valid_612335
  var valid_612336 = header.getOrDefault("X-Amz-Credential")
  valid_612336 = validateParameter(valid_612336, JString, required = false,
                                 default = nil)
  if valid_612336 != nil:
    section.add "X-Amz-Credential", valid_612336
  var valid_612337 = header.getOrDefault("X-Amz-Security-Token")
  valid_612337 = validateParameter(valid_612337, JString, required = false,
                                 default = nil)
  if valid_612337 != nil:
    section.add "X-Amz-Security-Token", valid_612337
  var valid_612338 = header.getOrDefault("X-Amz-Algorithm")
  valid_612338 = validateParameter(valid_612338, JString, required = false,
                                 default = nil)
  if valid_612338 != nil:
    section.add "X-Amz-Algorithm", valid_612338
  var valid_612339 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_612339 = validateParameter(valid_612339, JString, required = false,
                                 default = nil)
  if valid_612339 != nil:
    section.add "X-Amz-SignedHeaders", valid_612339
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_612340: Call_GetDeleteSnapshotCopyGrant_612327; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes the specified snapshot copy grant.
  ## 
  let valid = call_612340.validator(path, query, header, formData, body)
  let scheme = call_612340.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_612340.url(scheme.get, call_612340.host, call_612340.base,
                         call_612340.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_612340, url, valid)

proc call*(call_612341: Call_GetDeleteSnapshotCopyGrant_612327;
          SnapshotCopyGrantName: string;
          Action: string = "DeleteSnapshotCopyGrant"; Version: string = "2012-12-01"): Recallable =
  ## getDeleteSnapshotCopyGrant
  ## Deletes the specified snapshot copy grant.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   SnapshotCopyGrantName: string (required)
  ##                        : The name of the snapshot copy grant to delete.
  var query_612342 = newJObject()
  add(query_612342, "Action", newJString(Action))
  add(query_612342, "Version", newJString(Version))
  add(query_612342, "SnapshotCopyGrantName", newJString(SnapshotCopyGrantName))
  result = call_612341.call(nil, query_612342, nil, nil, nil)

var getDeleteSnapshotCopyGrant* = Call_GetDeleteSnapshotCopyGrant_612327(
    name: "getDeleteSnapshotCopyGrant", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteSnapshotCopyGrant",
    validator: validate_GetDeleteSnapshotCopyGrant_612328, base: "/",
    url: url_GetDeleteSnapshotCopyGrant_612329,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDeleteSnapshotSchedule_612376 = ref object of OpenApiRestCall_610642
proc url_PostDeleteSnapshotSchedule_612378(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDeleteSnapshotSchedule_612377(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a snapshot schedule.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_612379 = query.getOrDefault("Action")
  valid_612379 = validateParameter(valid_612379, JString, required = true,
                                 default = newJString("DeleteSnapshotSchedule"))
  if valid_612379 != nil:
    section.add "Action", valid_612379
  var valid_612380 = query.getOrDefault("Version")
  valid_612380 = validateParameter(valid_612380, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_612380 != nil:
    section.add "Version", valid_612380
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_612381 = header.getOrDefault("X-Amz-Signature")
  valid_612381 = validateParameter(valid_612381, JString, required = false,
                                 default = nil)
  if valid_612381 != nil:
    section.add "X-Amz-Signature", valid_612381
  var valid_612382 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_612382 = validateParameter(valid_612382, JString, required = false,
                                 default = nil)
  if valid_612382 != nil:
    section.add "X-Amz-Content-Sha256", valid_612382
  var valid_612383 = header.getOrDefault("X-Amz-Date")
  valid_612383 = validateParameter(valid_612383, JString, required = false,
                                 default = nil)
  if valid_612383 != nil:
    section.add "X-Amz-Date", valid_612383
  var valid_612384 = header.getOrDefault("X-Amz-Credential")
  valid_612384 = validateParameter(valid_612384, JString, required = false,
                                 default = nil)
  if valid_612384 != nil:
    section.add "X-Amz-Credential", valid_612384
  var valid_612385 = header.getOrDefault("X-Amz-Security-Token")
  valid_612385 = validateParameter(valid_612385, JString, required = false,
                                 default = nil)
  if valid_612385 != nil:
    section.add "X-Amz-Security-Token", valid_612385
  var valid_612386 = header.getOrDefault("X-Amz-Algorithm")
  valid_612386 = validateParameter(valid_612386, JString, required = false,
                                 default = nil)
  if valid_612386 != nil:
    section.add "X-Amz-Algorithm", valid_612386
  var valid_612387 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_612387 = validateParameter(valid_612387, JString, required = false,
                                 default = nil)
  if valid_612387 != nil:
    section.add "X-Amz-SignedHeaders", valid_612387
  result.add "header", section
  ## parameters in `formData` object:
  ##   ScheduleIdentifier: JString (required)
  ##                     : A unique identifier of the snapshot schedule to delete.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ScheduleIdentifier` field"
  var valid_612388 = formData.getOrDefault("ScheduleIdentifier")
  valid_612388 = validateParameter(valid_612388, JString, required = true,
                                 default = nil)
  if valid_612388 != nil:
    section.add "ScheduleIdentifier", valid_612388
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_612389: Call_PostDeleteSnapshotSchedule_612376; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a snapshot schedule.
  ## 
  let valid = call_612389.validator(path, query, header, formData, body)
  let scheme = call_612389.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_612389.url(scheme.get, call_612389.host, call_612389.base,
                         call_612389.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_612389, url, valid)

proc call*(call_612390: Call_PostDeleteSnapshotSchedule_612376;
          ScheduleIdentifier: string; Action: string = "DeleteSnapshotSchedule";
          Version: string = "2012-12-01"): Recallable =
  ## postDeleteSnapshotSchedule
  ## Deletes a snapshot schedule.
  ##   Action: string (required)
  ##   ScheduleIdentifier: string (required)
  ##                     : A unique identifier of the snapshot schedule to delete.
  ##   Version: string (required)
  var query_612391 = newJObject()
  var formData_612392 = newJObject()
  add(query_612391, "Action", newJString(Action))
  add(formData_612392, "ScheduleIdentifier", newJString(ScheduleIdentifier))
  add(query_612391, "Version", newJString(Version))
  result = call_612390.call(nil, query_612391, nil, formData_612392, nil)

var postDeleteSnapshotSchedule* = Call_PostDeleteSnapshotSchedule_612376(
    name: "postDeleteSnapshotSchedule", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteSnapshotSchedule",
    validator: validate_PostDeleteSnapshotSchedule_612377, base: "/",
    url: url_PostDeleteSnapshotSchedule_612378,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeleteSnapshotSchedule_612360 = ref object of OpenApiRestCall_610642
proc url_GetDeleteSnapshotSchedule_612362(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDeleteSnapshotSchedule_612361(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a snapshot schedule.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ScheduleIdentifier: JString (required)
  ##                     : A unique identifier of the snapshot schedule to delete.
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `ScheduleIdentifier` field"
  var valid_612363 = query.getOrDefault("ScheduleIdentifier")
  valid_612363 = validateParameter(valid_612363, JString, required = true,
                                 default = nil)
  if valid_612363 != nil:
    section.add "ScheduleIdentifier", valid_612363
  var valid_612364 = query.getOrDefault("Action")
  valid_612364 = validateParameter(valid_612364, JString, required = true,
                                 default = newJString("DeleteSnapshotSchedule"))
  if valid_612364 != nil:
    section.add "Action", valid_612364
  var valid_612365 = query.getOrDefault("Version")
  valid_612365 = validateParameter(valid_612365, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_612365 != nil:
    section.add "Version", valid_612365
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_612366 = header.getOrDefault("X-Amz-Signature")
  valid_612366 = validateParameter(valid_612366, JString, required = false,
                                 default = nil)
  if valid_612366 != nil:
    section.add "X-Amz-Signature", valid_612366
  var valid_612367 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_612367 = validateParameter(valid_612367, JString, required = false,
                                 default = nil)
  if valid_612367 != nil:
    section.add "X-Amz-Content-Sha256", valid_612367
  var valid_612368 = header.getOrDefault("X-Amz-Date")
  valid_612368 = validateParameter(valid_612368, JString, required = false,
                                 default = nil)
  if valid_612368 != nil:
    section.add "X-Amz-Date", valid_612368
  var valid_612369 = header.getOrDefault("X-Amz-Credential")
  valid_612369 = validateParameter(valid_612369, JString, required = false,
                                 default = nil)
  if valid_612369 != nil:
    section.add "X-Amz-Credential", valid_612369
  var valid_612370 = header.getOrDefault("X-Amz-Security-Token")
  valid_612370 = validateParameter(valid_612370, JString, required = false,
                                 default = nil)
  if valid_612370 != nil:
    section.add "X-Amz-Security-Token", valid_612370
  var valid_612371 = header.getOrDefault("X-Amz-Algorithm")
  valid_612371 = validateParameter(valid_612371, JString, required = false,
                                 default = nil)
  if valid_612371 != nil:
    section.add "X-Amz-Algorithm", valid_612371
  var valid_612372 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_612372 = validateParameter(valid_612372, JString, required = false,
                                 default = nil)
  if valid_612372 != nil:
    section.add "X-Amz-SignedHeaders", valid_612372
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_612373: Call_GetDeleteSnapshotSchedule_612360; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a snapshot schedule.
  ## 
  let valid = call_612373.validator(path, query, header, formData, body)
  let scheme = call_612373.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_612373.url(scheme.get, call_612373.host, call_612373.base,
                         call_612373.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_612373, url, valid)

proc call*(call_612374: Call_GetDeleteSnapshotSchedule_612360;
          ScheduleIdentifier: string; Action: string = "DeleteSnapshotSchedule";
          Version: string = "2012-12-01"): Recallable =
  ## getDeleteSnapshotSchedule
  ## Deletes a snapshot schedule.
  ##   ScheduleIdentifier: string (required)
  ##                     : A unique identifier of the snapshot schedule to delete.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_612375 = newJObject()
  add(query_612375, "ScheduleIdentifier", newJString(ScheduleIdentifier))
  add(query_612375, "Action", newJString(Action))
  add(query_612375, "Version", newJString(Version))
  result = call_612374.call(nil, query_612375, nil, nil, nil)

var getDeleteSnapshotSchedule* = Call_GetDeleteSnapshotSchedule_612360(
    name: "getDeleteSnapshotSchedule", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteSnapshotSchedule",
    validator: validate_GetDeleteSnapshotSchedule_612361, base: "/",
    url: url_GetDeleteSnapshotSchedule_612362,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDeleteTags_612410 = ref object of OpenApiRestCall_610642
proc url_PostDeleteTags_612412(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDeleteTags_612411(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode): JsonNode =
  ## Deletes tags from a resource. You must provide the ARN of the resource from which you want to delete the tag or tags.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_612413 = query.getOrDefault("Action")
  valid_612413 = validateParameter(valid_612413, JString, required = true,
                                 default = newJString("DeleteTags"))
  if valid_612413 != nil:
    section.add "Action", valid_612413
  var valid_612414 = query.getOrDefault("Version")
  valid_612414 = validateParameter(valid_612414, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_612414 != nil:
    section.add "Version", valid_612414
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_612415 = header.getOrDefault("X-Amz-Signature")
  valid_612415 = validateParameter(valid_612415, JString, required = false,
                                 default = nil)
  if valid_612415 != nil:
    section.add "X-Amz-Signature", valid_612415
  var valid_612416 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_612416 = validateParameter(valid_612416, JString, required = false,
                                 default = nil)
  if valid_612416 != nil:
    section.add "X-Amz-Content-Sha256", valid_612416
  var valid_612417 = header.getOrDefault("X-Amz-Date")
  valid_612417 = validateParameter(valid_612417, JString, required = false,
                                 default = nil)
  if valid_612417 != nil:
    section.add "X-Amz-Date", valid_612417
  var valid_612418 = header.getOrDefault("X-Amz-Credential")
  valid_612418 = validateParameter(valid_612418, JString, required = false,
                                 default = nil)
  if valid_612418 != nil:
    section.add "X-Amz-Credential", valid_612418
  var valid_612419 = header.getOrDefault("X-Amz-Security-Token")
  valid_612419 = validateParameter(valid_612419, JString, required = false,
                                 default = nil)
  if valid_612419 != nil:
    section.add "X-Amz-Security-Token", valid_612419
  var valid_612420 = header.getOrDefault("X-Amz-Algorithm")
  valid_612420 = validateParameter(valid_612420, JString, required = false,
                                 default = nil)
  if valid_612420 != nil:
    section.add "X-Amz-Algorithm", valid_612420
  var valid_612421 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_612421 = validateParameter(valid_612421, JString, required = false,
                                 default = nil)
  if valid_612421 != nil:
    section.add "X-Amz-SignedHeaders", valid_612421
  result.add "header", section
  ## parameters in `formData` object:
  ##   TagKeys: JArray (required)
  ##          : The tag key that you want to delete.
  ##   ResourceName: JString (required)
  ##               : The Amazon Resource Name (ARN) from which you want to remove the tag or tags. For example, <code>arn:aws:redshift:us-east-2:123456789:cluster:t1</code>. 
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `TagKeys` field"
  var valid_612422 = formData.getOrDefault("TagKeys")
  valid_612422 = validateParameter(valid_612422, JArray, required = true, default = nil)
  if valid_612422 != nil:
    section.add "TagKeys", valid_612422
  var valid_612423 = formData.getOrDefault("ResourceName")
  valid_612423 = validateParameter(valid_612423, JString, required = true,
                                 default = nil)
  if valid_612423 != nil:
    section.add "ResourceName", valid_612423
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_612424: Call_PostDeleteTags_612410; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes tags from a resource. You must provide the ARN of the resource from which you want to delete the tag or tags.
  ## 
  let valid = call_612424.validator(path, query, header, formData, body)
  let scheme = call_612424.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_612424.url(scheme.get, call_612424.host, call_612424.base,
                         call_612424.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_612424, url, valid)

proc call*(call_612425: Call_PostDeleteTags_612410; TagKeys: JsonNode;
          ResourceName: string; Action: string = "DeleteTags";
          Version: string = "2012-12-01"): Recallable =
  ## postDeleteTags
  ## Deletes tags from a resource. You must provide the ARN of the resource from which you want to delete the tag or tags.
  ##   TagKeys: JArray (required)
  ##          : The tag key that you want to delete.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   ResourceName: string (required)
  ##               : The Amazon Resource Name (ARN) from which you want to remove the tag or tags. For example, <code>arn:aws:redshift:us-east-2:123456789:cluster:t1</code>. 
  var query_612426 = newJObject()
  var formData_612427 = newJObject()
  if TagKeys != nil:
    formData_612427.add "TagKeys", TagKeys
  add(query_612426, "Action", newJString(Action))
  add(query_612426, "Version", newJString(Version))
  add(formData_612427, "ResourceName", newJString(ResourceName))
  result = call_612425.call(nil, query_612426, nil, formData_612427, nil)

var postDeleteTags* = Call_PostDeleteTags_612410(name: "postDeleteTags",
    meth: HttpMethod.HttpPost, host: "redshift.amazonaws.com",
    route: "/#Action=DeleteTags", validator: validate_PostDeleteTags_612411,
    base: "/", url: url_PostDeleteTags_612412, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeleteTags_612393 = ref object of OpenApiRestCall_610642
proc url_GetDeleteTags_612395(protocol: Scheme; host: string; base: string;
                             route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDeleteTags_612394(path: JsonNode; query: JsonNode; header: JsonNode;
                                  formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes tags from a resource. You must provide the ARN of the resource from which you want to delete the tag or tags.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ResourceName: JString (required)
  ##               : The Amazon Resource Name (ARN) from which you want to remove the tag or tags. For example, <code>arn:aws:redshift:us-east-2:123456789:cluster:t1</code>. 
  ##   TagKeys: JArray (required)
  ##          : The tag key that you want to delete.
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `ResourceName` field"
  var valid_612396 = query.getOrDefault("ResourceName")
  valid_612396 = validateParameter(valid_612396, JString, required = true,
                                 default = nil)
  if valid_612396 != nil:
    section.add "ResourceName", valid_612396
  var valid_612397 = query.getOrDefault("TagKeys")
  valid_612397 = validateParameter(valid_612397, JArray, required = true, default = nil)
  if valid_612397 != nil:
    section.add "TagKeys", valid_612397
  var valid_612398 = query.getOrDefault("Action")
  valid_612398 = validateParameter(valid_612398, JString, required = true,
                                 default = newJString("DeleteTags"))
  if valid_612398 != nil:
    section.add "Action", valid_612398
  var valid_612399 = query.getOrDefault("Version")
  valid_612399 = validateParameter(valid_612399, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_612399 != nil:
    section.add "Version", valid_612399
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_612400 = header.getOrDefault("X-Amz-Signature")
  valid_612400 = validateParameter(valid_612400, JString, required = false,
                                 default = nil)
  if valid_612400 != nil:
    section.add "X-Amz-Signature", valid_612400
  var valid_612401 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_612401 = validateParameter(valid_612401, JString, required = false,
                                 default = nil)
  if valid_612401 != nil:
    section.add "X-Amz-Content-Sha256", valid_612401
  var valid_612402 = header.getOrDefault("X-Amz-Date")
  valid_612402 = validateParameter(valid_612402, JString, required = false,
                                 default = nil)
  if valid_612402 != nil:
    section.add "X-Amz-Date", valid_612402
  var valid_612403 = header.getOrDefault("X-Amz-Credential")
  valid_612403 = validateParameter(valid_612403, JString, required = false,
                                 default = nil)
  if valid_612403 != nil:
    section.add "X-Amz-Credential", valid_612403
  var valid_612404 = header.getOrDefault("X-Amz-Security-Token")
  valid_612404 = validateParameter(valid_612404, JString, required = false,
                                 default = nil)
  if valid_612404 != nil:
    section.add "X-Amz-Security-Token", valid_612404
  var valid_612405 = header.getOrDefault("X-Amz-Algorithm")
  valid_612405 = validateParameter(valid_612405, JString, required = false,
                                 default = nil)
  if valid_612405 != nil:
    section.add "X-Amz-Algorithm", valid_612405
  var valid_612406 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_612406 = validateParameter(valid_612406, JString, required = false,
                                 default = nil)
  if valid_612406 != nil:
    section.add "X-Amz-SignedHeaders", valid_612406
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_612407: Call_GetDeleteTags_612393; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes tags from a resource. You must provide the ARN of the resource from which you want to delete the tag or tags.
  ## 
  let valid = call_612407.validator(path, query, header, formData, body)
  let scheme = call_612407.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_612407.url(scheme.get, call_612407.host, call_612407.base,
                         call_612407.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_612407, url, valid)

proc call*(call_612408: Call_GetDeleteTags_612393; ResourceName: string;
          TagKeys: JsonNode; Action: string = "DeleteTags";
          Version: string = "2012-12-01"): Recallable =
  ## getDeleteTags
  ## Deletes tags from a resource. You must provide the ARN of the resource from which you want to delete the tag or tags.
  ##   ResourceName: string (required)
  ##               : The Amazon Resource Name (ARN) from which you want to remove the tag or tags. For example, <code>arn:aws:redshift:us-east-2:123456789:cluster:t1</code>. 
  ##   TagKeys: JArray (required)
  ##          : The tag key that you want to delete.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_612409 = newJObject()
  add(query_612409, "ResourceName", newJString(ResourceName))
  if TagKeys != nil:
    query_612409.add "TagKeys", TagKeys
  add(query_612409, "Action", newJString(Action))
  add(query_612409, "Version", newJString(Version))
  result = call_612408.call(nil, query_612409, nil, nil, nil)

var getDeleteTags* = Call_GetDeleteTags_612393(name: "getDeleteTags",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=DeleteTags", validator: validate_GetDeleteTags_612394,
    base: "/", url: url_GetDeleteTags_612395, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeAccountAttributes_612444 = ref object of OpenApiRestCall_610642
proc url_PostDescribeAccountAttributes_612446(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeAccountAttributes_612445(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns a list of attributes attached to an account
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_612447 = query.getOrDefault("Action")
  valid_612447 = validateParameter(valid_612447, JString, required = true, default = newJString(
      "DescribeAccountAttributes"))
  if valid_612447 != nil:
    section.add "Action", valid_612447
  var valid_612448 = query.getOrDefault("Version")
  valid_612448 = validateParameter(valid_612448, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_612448 != nil:
    section.add "Version", valid_612448
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_612449 = header.getOrDefault("X-Amz-Signature")
  valid_612449 = validateParameter(valid_612449, JString, required = false,
                                 default = nil)
  if valid_612449 != nil:
    section.add "X-Amz-Signature", valid_612449
  var valid_612450 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_612450 = validateParameter(valid_612450, JString, required = false,
                                 default = nil)
  if valid_612450 != nil:
    section.add "X-Amz-Content-Sha256", valid_612450
  var valid_612451 = header.getOrDefault("X-Amz-Date")
  valid_612451 = validateParameter(valid_612451, JString, required = false,
                                 default = nil)
  if valid_612451 != nil:
    section.add "X-Amz-Date", valid_612451
  var valid_612452 = header.getOrDefault("X-Amz-Credential")
  valid_612452 = validateParameter(valid_612452, JString, required = false,
                                 default = nil)
  if valid_612452 != nil:
    section.add "X-Amz-Credential", valid_612452
  var valid_612453 = header.getOrDefault("X-Amz-Security-Token")
  valid_612453 = validateParameter(valid_612453, JString, required = false,
                                 default = nil)
  if valid_612453 != nil:
    section.add "X-Amz-Security-Token", valid_612453
  var valid_612454 = header.getOrDefault("X-Amz-Algorithm")
  valid_612454 = validateParameter(valid_612454, JString, required = false,
                                 default = nil)
  if valid_612454 != nil:
    section.add "X-Amz-Algorithm", valid_612454
  var valid_612455 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_612455 = validateParameter(valid_612455, JString, required = false,
                                 default = nil)
  if valid_612455 != nil:
    section.add "X-Amz-SignedHeaders", valid_612455
  result.add "header", section
  ## parameters in `formData` object:
  ##   AttributeNames: JArray
  ##                 : A list of attribute names.
  section = newJObject()
  var valid_612456 = formData.getOrDefault("AttributeNames")
  valid_612456 = validateParameter(valid_612456, JArray, required = false,
                                 default = nil)
  if valid_612456 != nil:
    section.add "AttributeNames", valid_612456
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_612457: Call_PostDescribeAccountAttributes_612444; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns a list of attributes attached to an account
  ## 
  let valid = call_612457.validator(path, query, header, formData, body)
  let scheme = call_612457.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_612457.url(scheme.get, call_612457.host, call_612457.base,
                         call_612457.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_612457, url, valid)

proc call*(call_612458: Call_PostDescribeAccountAttributes_612444;
          AttributeNames: JsonNode = nil;
          Action: string = "DescribeAccountAttributes";
          Version: string = "2012-12-01"): Recallable =
  ## postDescribeAccountAttributes
  ## Returns a list of attributes attached to an account
  ##   AttributeNames: JArray
  ##                 : A list of attribute names.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_612459 = newJObject()
  var formData_612460 = newJObject()
  if AttributeNames != nil:
    formData_612460.add "AttributeNames", AttributeNames
  add(query_612459, "Action", newJString(Action))
  add(query_612459, "Version", newJString(Version))
  result = call_612458.call(nil, query_612459, nil, formData_612460, nil)

var postDescribeAccountAttributes* = Call_PostDescribeAccountAttributes_612444(
    name: "postDescribeAccountAttributes", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeAccountAttributes",
    validator: validate_PostDescribeAccountAttributes_612445, base: "/",
    url: url_PostDescribeAccountAttributes_612446,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeAccountAttributes_612428 = ref object of OpenApiRestCall_610642
proc url_GetDescribeAccountAttributes_612430(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeAccountAttributes_612429(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns a list of attributes attached to an account
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   AttributeNames: JArray
  ##                 : A list of attribute names.
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_612431 = query.getOrDefault("AttributeNames")
  valid_612431 = validateParameter(valid_612431, JArray, required = false,
                                 default = nil)
  if valid_612431 != nil:
    section.add "AttributeNames", valid_612431
  var valid_612432 = query.getOrDefault("Action")
  valid_612432 = validateParameter(valid_612432, JString, required = true, default = newJString(
      "DescribeAccountAttributes"))
  if valid_612432 != nil:
    section.add "Action", valid_612432
  var valid_612433 = query.getOrDefault("Version")
  valid_612433 = validateParameter(valid_612433, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_612433 != nil:
    section.add "Version", valid_612433
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_612434 = header.getOrDefault("X-Amz-Signature")
  valid_612434 = validateParameter(valid_612434, JString, required = false,
                                 default = nil)
  if valid_612434 != nil:
    section.add "X-Amz-Signature", valid_612434
  var valid_612435 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_612435 = validateParameter(valid_612435, JString, required = false,
                                 default = nil)
  if valid_612435 != nil:
    section.add "X-Amz-Content-Sha256", valid_612435
  var valid_612436 = header.getOrDefault("X-Amz-Date")
  valid_612436 = validateParameter(valid_612436, JString, required = false,
                                 default = nil)
  if valid_612436 != nil:
    section.add "X-Amz-Date", valid_612436
  var valid_612437 = header.getOrDefault("X-Amz-Credential")
  valid_612437 = validateParameter(valid_612437, JString, required = false,
                                 default = nil)
  if valid_612437 != nil:
    section.add "X-Amz-Credential", valid_612437
  var valid_612438 = header.getOrDefault("X-Amz-Security-Token")
  valid_612438 = validateParameter(valid_612438, JString, required = false,
                                 default = nil)
  if valid_612438 != nil:
    section.add "X-Amz-Security-Token", valid_612438
  var valid_612439 = header.getOrDefault("X-Amz-Algorithm")
  valid_612439 = validateParameter(valid_612439, JString, required = false,
                                 default = nil)
  if valid_612439 != nil:
    section.add "X-Amz-Algorithm", valid_612439
  var valid_612440 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_612440 = validateParameter(valid_612440, JString, required = false,
                                 default = nil)
  if valid_612440 != nil:
    section.add "X-Amz-SignedHeaders", valid_612440
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_612441: Call_GetDescribeAccountAttributes_612428; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns a list of attributes attached to an account
  ## 
  let valid = call_612441.validator(path, query, header, formData, body)
  let scheme = call_612441.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_612441.url(scheme.get, call_612441.host, call_612441.base,
                         call_612441.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_612441, url, valid)

proc call*(call_612442: Call_GetDescribeAccountAttributes_612428;
          AttributeNames: JsonNode = nil;
          Action: string = "DescribeAccountAttributes";
          Version: string = "2012-12-01"): Recallable =
  ## getDescribeAccountAttributes
  ## Returns a list of attributes attached to an account
  ##   AttributeNames: JArray
  ##                 : A list of attribute names.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_612443 = newJObject()
  if AttributeNames != nil:
    query_612443.add "AttributeNames", AttributeNames
  add(query_612443, "Action", newJString(Action))
  add(query_612443, "Version", newJString(Version))
  result = call_612442.call(nil, query_612443, nil, nil, nil)

var getDescribeAccountAttributes* = Call_GetDescribeAccountAttributes_612428(
    name: "getDescribeAccountAttributes", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeAccountAttributes",
    validator: validate_GetDescribeAccountAttributes_612429, base: "/",
    url: url_GetDescribeAccountAttributes_612430,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeClusterDbRevisions_612479 = ref object of OpenApiRestCall_610642
proc url_PostDescribeClusterDbRevisions_612481(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeClusterDbRevisions_612480(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns an array of <code>ClusterDbRevision</code> objects.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_612482 = query.getOrDefault("Action")
  valid_612482 = validateParameter(valid_612482, JString, required = true, default = newJString(
      "DescribeClusterDbRevisions"))
  if valid_612482 != nil:
    section.add "Action", valid_612482
  var valid_612483 = query.getOrDefault("Version")
  valid_612483 = validateParameter(valid_612483, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_612483 != nil:
    section.add "Version", valid_612483
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_612484 = header.getOrDefault("X-Amz-Signature")
  valid_612484 = validateParameter(valid_612484, JString, required = false,
                                 default = nil)
  if valid_612484 != nil:
    section.add "X-Amz-Signature", valid_612484
  var valid_612485 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_612485 = validateParameter(valid_612485, JString, required = false,
                                 default = nil)
  if valid_612485 != nil:
    section.add "X-Amz-Content-Sha256", valid_612485
  var valid_612486 = header.getOrDefault("X-Amz-Date")
  valid_612486 = validateParameter(valid_612486, JString, required = false,
                                 default = nil)
  if valid_612486 != nil:
    section.add "X-Amz-Date", valid_612486
  var valid_612487 = header.getOrDefault("X-Amz-Credential")
  valid_612487 = validateParameter(valid_612487, JString, required = false,
                                 default = nil)
  if valid_612487 != nil:
    section.add "X-Amz-Credential", valid_612487
  var valid_612488 = header.getOrDefault("X-Amz-Security-Token")
  valid_612488 = validateParameter(valid_612488, JString, required = false,
                                 default = nil)
  if valid_612488 != nil:
    section.add "X-Amz-Security-Token", valid_612488
  var valid_612489 = header.getOrDefault("X-Amz-Algorithm")
  valid_612489 = validateParameter(valid_612489, JString, required = false,
                                 default = nil)
  if valid_612489 != nil:
    section.add "X-Amz-Algorithm", valid_612489
  var valid_612490 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_612490 = validateParameter(valid_612490, JString, required = false,
                                 default = nil)
  if valid_612490 != nil:
    section.add "X-Amz-SignedHeaders", valid_612490
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString
  ##                    : A unique identifier for a cluster whose <code>ClusterDbRevisions</code> you are requesting. This parameter is case sensitive. All clusters defined for an account are returned by default.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified MaxRecords value, a value is returned in the <code>marker</code> field of the response. You can retrieve the next set of response records by providing the returned <code>marker</code> value in the <code>marker</code> parameter and retrying the request. </p> <p>Default: 100</p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: JString
  ##         : <p>An optional parameter that specifies the starting point for returning a set of response records. When the results of a <code>DescribeClusterDbRevisions</code> request exceed the value specified in <code>MaxRecords</code>, Amazon Redshift returns a value in the <code>marker</code> field of the response. You can retrieve the next set of response records by providing the returned <code>marker</code> value in the <code>marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <code>ClusterIdentifier</code> parameter, or the <code>marker</code> parameter, but not both.</p>
  section = newJObject()
  var valid_612491 = formData.getOrDefault("ClusterIdentifier")
  valid_612491 = validateParameter(valid_612491, JString, required = false,
                                 default = nil)
  if valid_612491 != nil:
    section.add "ClusterIdentifier", valid_612491
  var valid_612492 = formData.getOrDefault("MaxRecords")
  valid_612492 = validateParameter(valid_612492, JInt, required = false, default = nil)
  if valid_612492 != nil:
    section.add "MaxRecords", valid_612492
  var valid_612493 = formData.getOrDefault("Marker")
  valid_612493 = validateParameter(valid_612493, JString, required = false,
                                 default = nil)
  if valid_612493 != nil:
    section.add "Marker", valid_612493
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_612494: Call_PostDescribeClusterDbRevisions_612479; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns an array of <code>ClusterDbRevision</code> objects.
  ## 
  let valid = call_612494.validator(path, query, header, formData, body)
  let scheme = call_612494.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_612494.url(scheme.get, call_612494.host, call_612494.base,
                         call_612494.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_612494, url, valid)

proc call*(call_612495: Call_PostDescribeClusterDbRevisions_612479;
          ClusterIdentifier: string = ""; MaxRecords: int = 0; Marker: string = "";
          Action: string = "DescribeClusterDbRevisions";
          Version: string = "2012-12-01"): Recallable =
  ## postDescribeClusterDbRevisions
  ## Returns an array of <code>ClusterDbRevision</code> objects.
  ##   ClusterIdentifier: string
  ##                    : A unique identifier for a cluster whose <code>ClusterDbRevisions</code> you are requesting. This parameter is case sensitive. All clusters defined for an account are returned by default.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified MaxRecords value, a value is returned in the <code>marker</code> field of the response. You can retrieve the next set of response records by providing the returned <code>marker</code> value in the <code>marker</code> parameter and retrying the request. </p> <p>Default: 100</p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: string
  ##         : <p>An optional parameter that specifies the starting point for returning a set of response records. When the results of a <code>DescribeClusterDbRevisions</code> request exceed the value specified in <code>MaxRecords</code>, Amazon Redshift returns a value in the <code>marker</code> field of the response. You can retrieve the next set of response records by providing the returned <code>marker</code> value in the <code>marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <code>ClusterIdentifier</code> parameter, or the <code>marker</code> parameter, but not both.</p>
  ##   Action: string (required)
  ##   Version: string (required)
  var query_612496 = newJObject()
  var formData_612497 = newJObject()
  add(formData_612497, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_612497, "MaxRecords", newJInt(MaxRecords))
  add(formData_612497, "Marker", newJString(Marker))
  add(query_612496, "Action", newJString(Action))
  add(query_612496, "Version", newJString(Version))
  result = call_612495.call(nil, query_612496, nil, formData_612497, nil)

var postDescribeClusterDbRevisions* = Call_PostDescribeClusterDbRevisions_612479(
    name: "postDescribeClusterDbRevisions", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusterDbRevisions",
    validator: validate_PostDescribeClusterDbRevisions_612480, base: "/",
    url: url_PostDescribeClusterDbRevisions_612481,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeClusterDbRevisions_612461 = ref object of OpenApiRestCall_610642
proc url_GetDescribeClusterDbRevisions_612463(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeClusterDbRevisions_612462(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns an array of <code>ClusterDbRevision</code> objects.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Marker: JString
  ##         : <p>An optional parameter that specifies the starting point for returning a set of response records. When the results of a <code>DescribeClusterDbRevisions</code> request exceed the value specified in <code>MaxRecords</code>, Amazon Redshift returns a value in the <code>marker</code> field of the response. You can retrieve the next set of response records by providing the returned <code>marker</code> value in the <code>marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <code>ClusterIdentifier</code> parameter, or the <code>marker</code> parameter, but not both.</p>
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString
  ##                    : A unique identifier for a cluster whose <code>ClusterDbRevisions</code> you are requesting. This parameter is case sensitive. All clusters defined for an account are returned by default.
  ##   Version: JString (required)
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified MaxRecords value, a value is returned in the <code>marker</code> field of the response. You can retrieve the next set of response records by providing the returned <code>marker</code> value in the <code>marker</code> parameter and retrying the request. </p> <p>Default: 100</p> <p>Constraints: minimum 20, maximum 100.</p>
  section = newJObject()
  var valid_612464 = query.getOrDefault("Marker")
  valid_612464 = validateParameter(valid_612464, JString, required = false,
                                 default = nil)
  if valid_612464 != nil:
    section.add "Marker", valid_612464
  var valid_612465 = query.getOrDefault("Action")
  valid_612465 = validateParameter(valid_612465, JString, required = true, default = newJString(
      "DescribeClusterDbRevisions"))
  if valid_612465 != nil:
    section.add "Action", valid_612465
  var valid_612466 = query.getOrDefault("ClusterIdentifier")
  valid_612466 = validateParameter(valid_612466, JString, required = false,
                                 default = nil)
  if valid_612466 != nil:
    section.add "ClusterIdentifier", valid_612466
  var valid_612467 = query.getOrDefault("Version")
  valid_612467 = validateParameter(valid_612467, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_612467 != nil:
    section.add "Version", valid_612467
  var valid_612468 = query.getOrDefault("MaxRecords")
  valid_612468 = validateParameter(valid_612468, JInt, required = false, default = nil)
  if valid_612468 != nil:
    section.add "MaxRecords", valid_612468
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_612469 = header.getOrDefault("X-Amz-Signature")
  valid_612469 = validateParameter(valid_612469, JString, required = false,
                                 default = nil)
  if valid_612469 != nil:
    section.add "X-Amz-Signature", valid_612469
  var valid_612470 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_612470 = validateParameter(valid_612470, JString, required = false,
                                 default = nil)
  if valid_612470 != nil:
    section.add "X-Amz-Content-Sha256", valid_612470
  var valid_612471 = header.getOrDefault("X-Amz-Date")
  valid_612471 = validateParameter(valid_612471, JString, required = false,
                                 default = nil)
  if valid_612471 != nil:
    section.add "X-Amz-Date", valid_612471
  var valid_612472 = header.getOrDefault("X-Amz-Credential")
  valid_612472 = validateParameter(valid_612472, JString, required = false,
                                 default = nil)
  if valid_612472 != nil:
    section.add "X-Amz-Credential", valid_612472
  var valid_612473 = header.getOrDefault("X-Amz-Security-Token")
  valid_612473 = validateParameter(valid_612473, JString, required = false,
                                 default = nil)
  if valid_612473 != nil:
    section.add "X-Amz-Security-Token", valid_612473
  var valid_612474 = header.getOrDefault("X-Amz-Algorithm")
  valid_612474 = validateParameter(valid_612474, JString, required = false,
                                 default = nil)
  if valid_612474 != nil:
    section.add "X-Amz-Algorithm", valid_612474
  var valid_612475 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_612475 = validateParameter(valid_612475, JString, required = false,
                                 default = nil)
  if valid_612475 != nil:
    section.add "X-Amz-SignedHeaders", valid_612475
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_612476: Call_GetDescribeClusterDbRevisions_612461; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns an array of <code>ClusterDbRevision</code> objects.
  ## 
  let valid = call_612476.validator(path, query, header, formData, body)
  let scheme = call_612476.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_612476.url(scheme.get, call_612476.host, call_612476.base,
                         call_612476.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_612476, url, valid)

proc call*(call_612477: Call_GetDescribeClusterDbRevisions_612461;
          Marker: string = ""; Action: string = "DescribeClusterDbRevisions";
          ClusterIdentifier: string = ""; Version: string = "2012-12-01";
          MaxRecords: int = 0): Recallable =
  ## getDescribeClusterDbRevisions
  ## Returns an array of <code>ClusterDbRevision</code> objects.
  ##   Marker: string
  ##         : <p>An optional parameter that specifies the starting point for returning a set of response records. When the results of a <code>DescribeClusterDbRevisions</code> request exceed the value specified in <code>MaxRecords</code>, Amazon Redshift returns a value in the <code>marker</code> field of the response. You can retrieve the next set of response records by providing the returned <code>marker</code> value in the <code>marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <code>ClusterIdentifier</code> parameter, or the <code>marker</code> parameter, but not both.</p>
  ##   Action: string (required)
  ##   ClusterIdentifier: string
  ##                    : A unique identifier for a cluster whose <code>ClusterDbRevisions</code> you are requesting. This parameter is case sensitive. All clusters defined for an account are returned by default.
  ##   Version: string (required)
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified MaxRecords value, a value is returned in the <code>marker</code> field of the response. You can retrieve the next set of response records by providing the returned <code>marker</code> value in the <code>marker</code> parameter and retrying the request. </p> <p>Default: 100</p> <p>Constraints: minimum 20, maximum 100.</p>
  var query_612478 = newJObject()
  add(query_612478, "Marker", newJString(Marker))
  add(query_612478, "Action", newJString(Action))
  add(query_612478, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_612478, "Version", newJString(Version))
  add(query_612478, "MaxRecords", newJInt(MaxRecords))
  result = call_612477.call(nil, query_612478, nil, nil, nil)

var getDescribeClusterDbRevisions* = Call_GetDescribeClusterDbRevisions_612461(
    name: "getDescribeClusterDbRevisions", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusterDbRevisions",
    validator: validate_GetDescribeClusterDbRevisions_612462, base: "/",
    url: url_GetDescribeClusterDbRevisions_612463,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeClusterParameterGroups_612518 = ref object of OpenApiRestCall_610642
proc url_PostDescribeClusterParameterGroups_612520(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeClusterParameterGroups_612519(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns a list of Amazon Redshift parameter groups, including parameter groups you created and the default parameter group. For each parameter group, the response includes the parameter group name, description, and parameter group family name. You can optionally specify a name to retrieve the description of a specific parameter group.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all parameter groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all parameter groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, parameter groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_612521 = query.getOrDefault("Action")
  valid_612521 = validateParameter(valid_612521, JString, required = true, default = newJString(
      "DescribeClusterParameterGroups"))
  if valid_612521 != nil:
    section.add "Action", valid_612521
  var valid_612522 = query.getOrDefault("Version")
  valid_612522 = validateParameter(valid_612522, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_612522 != nil:
    section.add "Version", valid_612522
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_612523 = header.getOrDefault("X-Amz-Signature")
  valid_612523 = validateParameter(valid_612523, JString, required = false,
                                 default = nil)
  if valid_612523 != nil:
    section.add "X-Amz-Signature", valid_612523
  var valid_612524 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_612524 = validateParameter(valid_612524, JString, required = false,
                                 default = nil)
  if valid_612524 != nil:
    section.add "X-Amz-Content-Sha256", valid_612524
  var valid_612525 = header.getOrDefault("X-Amz-Date")
  valid_612525 = validateParameter(valid_612525, JString, required = false,
                                 default = nil)
  if valid_612525 != nil:
    section.add "X-Amz-Date", valid_612525
  var valid_612526 = header.getOrDefault("X-Amz-Credential")
  valid_612526 = validateParameter(valid_612526, JString, required = false,
                                 default = nil)
  if valid_612526 != nil:
    section.add "X-Amz-Credential", valid_612526
  var valid_612527 = header.getOrDefault("X-Amz-Security-Token")
  valid_612527 = validateParameter(valid_612527, JString, required = false,
                                 default = nil)
  if valid_612527 != nil:
    section.add "X-Amz-Security-Token", valid_612527
  var valid_612528 = header.getOrDefault("X-Amz-Algorithm")
  valid_612528 = validateParameter(valid_612528, JString, required = false,
                                 default = nil)
  if valid_612528 != nil:
    section.add "X-Amz-Algorithm", valid_612528
  var valid_612529 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_612529 = validateParameter(valid_612529, JString, required = false,
                                 default = nil)
  if valid_612529 != nil:
    section.add "X-Amz-SignedHeaders", valid_612529
  result.add "header", section
  ## parameters in `formData` object:
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster parameter groups that are associated with the specified key or keys. For example, suppose that you have parameter groups that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the parameter groups that have either or both of these tag keys associated with them.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterParameterGroups</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster parameter groups that are associated with the specified tag value or values. For example, suppose that you have parameter groups that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the parameter groups that have either or both of these tag values associated with them.
  ##   ParameterGroupName: JString
  ##                     : The name of a specific parameter group for which to return details. By default, details about all parameter groups and the default parameter group are returned.
  section = newJObject()
  var valid_612530 = formData.getOrDefault("TagKeys")
  valid_612530 = validateParameter(valid_612530, JArray, required = false,
                                 default = nil)
  if valid_612530 != nil:
    section.add "TagKeys", valid_612530
  var valid_612531 = formData.getOrDefault("MaxRecords")
  valid_612531 = validateParameter(valid_612531, JInt, required = false, default = nil)
  if valid_612531 != nil:
    section.add "MaxRecords", valid_612531
  var valid_612532 = formData.getOrDefault("Marker")
  valid_612532 = validateParameter(valid_612532, JString, required = false,
                                 default = nil)
  if valid_612532 != nil:
    section.add "Marker", valid_612532
  var valid_612533 = formData.getOrDefault("TagValues")
  valid_612533 = validateParameter(valid_612533, JArray, required = false,
                                 default = nil)
  if valid_612533 != nil:
    section.add "TagValues", valid_612533
  var valid_612534 = formData.getOrDefault("ParameterGroupName")
  valid_612534 = validateParameter(valid_612534, JString, required = false,
                                 default = nil)
  if valid_612534 != nil:
    section.add "ParameterGroupName", valid_612534
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_612535: Call_PostDescribeClusterParameterGroups_612518;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Returns a list of Amazon Redshift parameter groups, including parameter groups you created and the default parameter group. For each parameter group, the response includes the parameter group name, description, and parameter group family name. You can optionally specify a name to retrieve the description of a specific parameter group.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all parameter groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all parameter groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, parameter groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_612535.validator(path, query, header, formData, body)
  let scheme = call_612535.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_612535.url(scheme.get, call_612535.host, call_612535.base,
                         call_612535.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_612535, url, valid)

proc call*(call_612536: Call_PostDescribeClusterParameterGroups_612518;
          TagKeys: JsonNode = nil; MaxRecords: int = 0; Marker: string = "";
          TagValues: JsonNode = nil;
          Action: string = "DescribeClusterParameterGroups";
          ParameterGroupName: string = ""; Version: string = "2012-12-01"): Recallable =
  ## postDescribeClusterParameterGroups
  ## <p>Returns a list of Amazon Redshift parameter groups, including parameter groups you created and the default parameter group. For each parameter group, the response includes the parameter group name, description, and parameter group family name. You can optionally specify a name to retrieve the description of a specific parameter group.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all parameter groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all parameter groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, parameter groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster parameter groups that are associated with the specified key or keys. For example, suppose that you have parameter groups that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the parameter groups that have either or both of these tag keys associated with them.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterParameterGroups</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster parameter groups that are associated with the specified tag value or values. For example, suppose that you have parameter groups that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the parameter groups that have either or both of these tag values associated with them.
  ##   Action: string (required)
  ##   ParameterGroupName: string
  ##                     : The name of a specific parameter group for which to return details. By default, details about all parameter groups and the default parameter group are returned.
  ##   Version: string (required)
  var query_612537 = newJObject()
  var formData_612538 = newJObject()
  if TagKeys != nil:
    formData_612538.add "TagKeys", TagKeys
  add(formData_612538, "MaxRecords", newJInt(MaxRecords))
  add(formData_612538, "Marker", newJString(Marker))
  if TagValues != nil:
    formData_612538.add "TagValues", TagValues
  add(query_612537, "Action", newJString(Action))
  add(formData_612538, "ParameterGroupName", newJString(ParameterGroupName))
  add(query_612537, "Version", newJString(Version))
  result = call_612536.call(nil, query_612537, nil, formData_612538, nil)

var postDescribeClusterParameterGroups* = Call_PostDescribeClusterParameterGroups_612518(
    name: "postDescribeClusterParameterGroups", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeClusterParameterGroups",
    validator: validate_PostDescribeClusterParameterGroups_612519, base: "/",
    url: url_PostDescribeClusterParameterGroups_612520,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeClusterParameterGroups_612498 = ref object of OpenApiRestCall_610642
proc url_GetDescribeClusterParameterGroups_612500(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeClusterParameterGroups_612499(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns a list of Amazon Redshift parameter groups, including parameter groups you created and the default parameter group. For each parameter group, the response includes the parameter group name, description, and parameter group family name. You can optionally specify a name to retrieve the description of a specific parameter group.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all parameter groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all parameter groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, parameter groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterParameterGroups</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster parameter groups that are associated with the specified key or keys. For example, suppose that you have parameter groups that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the parameter groups that have either or both of these tag keys associated with them.
  ##   Action: JString (required)
  ##   ParameterGroupName: JString
  ##                     : The name of a specific parameter group for which to return details. By default, details about all parameter groups and the default parameter group are returned.
  ##   Version: JString (required)
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster parameter groups that are associated with the specified tag value or values. For example, suppose that you have parameter groups that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the parameter groups that have either or both of these tag values associated with them.
  section = newJObject()
  var valid_612501 = query.getOrDefault("Marker")
  valid_612501 = validateParameter(valid_612501, JString, required = false,
                                 default = nil)
  if valid_612501 != nil:
    section.add "Marker", valid_612501
  var valid_612502 = query.getOrDefault("TagKeys")
  valid_612502 = validateParameter(valid_612502, JArray, required = false,
                                 default = nil)
  if valid_612502 != nil:
    section.add "TagKeys", valid_612502
  var valid_612503 = query.getOrDefault("Action")
  valid_612503 = validateParameter(valid_612503, JString, required = true, default = newJString(
      "DescribeClusterParameterGroups"))
  if valid_612503 != nil:
    section.add "Action", valid_612503
  var valid_612504 = query.getOrDefault("ParameterGroupName")
  valid_612504 = validateParameter(valid_612504, JString, required = false,
                                 default = nil)
  if valid_612504 != nil:
    section.add "ParameterGroupName", valid_612504
  var valid_612505 = query.getOrDefault("Version")
  valid_612505 = validateParameter(valid_612505, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_612505 != nil:
    section.add "Version", valid_612505
  var valid_612506 = query.getOrDefault("MaxRecords")
  valid_612506 = validateParameter(valid_612506, JInt, required = false, default = nil)
  if valid_612506 != nil:
    section.add "MaxRecords", valid_612506
  var valid_612507 = query.getOrDefault("TagValues")
  valid_612507 = validateParameter(valid_612507, JArray, required = false,
                                 default = nil)
  if valid_612507 != nil:
    section.add "TagValues", valid_612507
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_612508 = header.getOrDefault("X-Amz-Signature")
  valid_612508 = validateParameter(valid_612508, JString, required = false,
                                 default = nil)
  if valid_612508 != nil:
    section.add "X-Amz-Signature", valid_612508
  var valid_612509 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_612509 = validateParameter(valid_612509, JString, required = false,
                                 default = nil)
  if valid_612509 != nil:
    section.add "X-Amz-Content-Sha256", valid_612509
  var valid_612510 = header.getOrDefault("X-Amz-Date")
  valid_612510 = validateParameter(valid_612510, JString, required = false,
                                 default = nil)
  if valid_612510 != nil:
    section.add "X-Amz-Date", valid_612510
  var valid_612511 = header.getOrDefault("X-Amz-Credential")
  valid_612511 = validateParameter(valid_612511, JString, required = false,
                                 default = nil)
  if valid_612511 != nil:
    section.add "X-Amz-Credential", valid_612511
  var valid_612512 = header.getOrDefault("X-Amz-Security-Token")
  valid_612512 = validateParameter(valid_612512, JString, required = false,
                                 default = nil)
  if valid_612512 != nil:
    section.add "X-Amz-Security-Token", valid_612512
  var valid_612513 = header.getOrDefault("X-Amz-Algorithm")
  valid_612513 = validateParameter(valid_612513, JString, required = false,
                                 default = nil)
  if valid_612513 != nil:
    section.add "X-Amz-Algorithm", valid_612513
  var valid_612514 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_612514 = validateParameter(valid_612514, JString, required = false,
                                 default = nil)
  if valid_612514 != nil:
    section.add "X-Amz-SignedHeaders", valid_612514
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_612515: Call_GetDescribeClusterParameterGroups_612498;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Returns a list of Amazon Redshift parameter groups, including parameter groups you created and the default parameter group. For each parameter group, the response includes the parameter group name, description, and parameter group family name. You can optionally specify a name to retrieve the description of a specific parameter group.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all parameter groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all parameter groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, parameter groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_612515.validator(path, query, header, formData, body)
  let scheme = call_612515.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_612515.url(scheme.get, call_612515.host, call_612515.base,
                         call_612515.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_612515, url, valid)

proc call*(call_612516: Call_GetDescribeClusterParameterGroups_612498;
          Marker: string = ""; TagKeys: JsonNode = nil;
          Action: string = "DescribeClusterParameterGroups";
          ParameterGroupName: string = ""; Version: string = "2012-12-01";
          MaxRecords: int = 0; TagValues: JsonNode = nil): Recallable =
  ## getDescribeClusterParameterGroups
  ## <p>Returns a list of Amazon Redshift parameter groups, including parameter groups you created and the default parameter group. For each parameter group, the response includes the parameter group name, description, and parameter group family name. You can optionally specify a name to retrieve the description of a specific parameter group.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all parameter groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all parameter groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, parameter groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterParameterGroups</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster parameter groups that are associated with the specified key or keys. For example, suppose that you have parameter groups that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the parameter groups that have either or both of these tag keys associated with them.
  ##   Action: string (required)
  ##   ParameterGroupName: string
  ##                     : The name of a specific parameter group for which to return details. By default, details about all parameter groups and the default parameter group are returned.
  ##   Version: string (required)
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster parameter groups that are associated with the specified tag value or values. For example, suppose that you have parameter groups that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the parameter groups that have either or both of these tag values associated with them.
  var query_612517 = newJObject()
  add(query_612517, "Marker", newJString(Marker))
  if TagKeys != nil:
    query_612517.add "TagKeys", TagKeys
  add(query_612517, "Action", newJString(Action))
  add(query_612517, "ParameterGroupName", newJString(ParameterGroupName))
  add(query_612517, "Version", newJString(Version))
  add(query_612517, "MaxRecords", newJInt(MaxRecords))
  if TagValues != nil:
    query_612517.add "TagValues", TagValues
  result = call_612516.call(nil, query_612517, nil, nil, nil)

var getDescribeClusterParameterGroups* = Call_GetDescribeClusterParameterGroups_612498(
    name: "getDescribeClusterParameterGroups", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeClusterParameterGroups",
    validator: validate_GetDescribeClusterParameterGroups_612499, base: "/",
    url: url_GetDescribeClusterParameterGroups_612500,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeClusterParameters_612558 = ref object of OpenApiRestCall_610642
proc url_PostDescribeClusterParameters_612560(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeClusterParameters_612559(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns a detailed list of parameters contained within the specified Amazon Redshift parameter group. For each parameter the response includes information such as parameter name, description, data type, value, whether the parameter value is modifiable, and so on.</p> <p>You can specify <i>source</i> filter to retrieve parameters of only specific type. For example, to retrieve parameters that were modified by a user action such as from <a>ModifyClusterParameterGroup</a>, you can specify <i>source</i> equal to <i>user</i>.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_612561 = query.getOrDefault("Action")
  valid_612561 = validateParameter(valid_612561, JString, required = true, default = newJString(
      "DescribeClusterParameters"))
  if valid_612561 != nil:
    section.add "Action", valid_612561
  var valid_612562 = query.getOrDefault("Version")
  valid_612562 = validateParameter(valid_612562, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_612562 != nil:
    section.add "Version", valid_612562
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_612563 = header.getOrDefault("X-Amz-Signature")
  valid_612563 = validateParameter(valid_612563, JString, required = false,
                                 default = nil)
  if valid_612563 != nil:
    section.add "X-Amz-Signature", valid_612563
  var valid_612564 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_612564 = validateParameter(valid_612564, JString, required = false,
                                 default = nil)
  if valid_612564 != nil:
    section.add "X-Amz-Content-Sha256", valid_612564
  var valid_612565 = header.getOrDefault("X-Amz-Date")
  valid_612565 = validateParameter(valid_612565, JString, required = false,
                                 default = nil)
  if valid_612565 != nil:
    section.add "X-Amz-Date", valid_612565
  var valid_612566 = header.getOrDefault("X-Amz-Credential")
  valid_612566 = validateParameter(valid_612566, JString, required = false,
                                 default = nil)
  if valid_612566 != nil:
    section.add "X-Amz-Credential", valid_612566
  var valid_612567 = header.getOrDefault("X-Amz-Security-Token")
  valid_612567 = validateParameter(valid_612567, JString, required = false,
                                 default = nil)
  if valid_612567 != nil:
    section.add "X-Amz-Security-Token", valid_612567
  var valid_612568 = header.getOrDefault("X-Amz-Algorithm")
  valid_612568 = validateParameter(valid_612568, JString, required = false,
                                 default = nil)
  if valid_612568 != nil:
    section.add "X-Amz-Algorithm", valid_612568
  var valid_612569 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_612569 = validateParameter(valid_612569, JString, required = false,
                                 default = nil)
  if valid_612569 != nil:
    section.add "X-Amz-SignedHeaders", valid_612569
  result.add "header", section
  ## parameters in `formData` object:
  ##   Source: JString
  ##         : <p>The parameter types to return. Specify <code>user</code> to show parameters that are different form the default. Similarly, specify <code>engine-default</code> to show parameters that are the same as the default parameter group. </p> <p>Default: All parameter types returned.</p> <p>Valid Values: <code>user</code> | <code>engine-default</code> </p>
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterParameters</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   ParameterGroupName: JString (required)
  ##                     : The name of a cluster parameter group for which to return details.
  section = newJObject()
  var valid_612570 = formData.getOrDefault("Source")
  valid_612570 = validateParameter(valid_612570, JString, required = false,
                                 default = nil)
  if valid_612570 != nil:
    section.add "Source", valid_612570
  var valid_612571 = formData.getOrDefault("MaxRecords")
  valid_612571 = validateParameter(valid_612571, JInt, required = false, default = nil)
  if valid_612571 != nil:
    section.add "MaxRecords", valid_612571
  var valid_612572 = formData.getOrDefault("Marker")
  valid_612572 = validateParameter(valid_612572, JString, required = false,
                                 default = nil)
  if valid_612572 != nil:
    section.add "Marker", valid_612572
  assert formData != nil, "formData argument is necessary due to required `ParameterGroupName` field"
  var valid_612573 = formData.getOrDefault("ParameterGroupName")
  valid_612573 = validateParameter(valid_612573, JString, required = true,
                                 default = nil)
  if valid_612573 != nil:
    section.add "ParameterGroupName", valid_612573
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_612574: Call_PostDescribeClusterParameters_612558; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns a detailed list of parameters contained within the specified Amazon Redshift parameter group. For each parameter the response includes information such as parameter name, description, data type, value, whether the parameter value is modifiable, and so on.</p> <p>You can specify <i>source</i> filter to retrieve parameters of only specific type. For example, to retrieve parameters that were modified by a user action such as from <a>ModifyClusterParameterGroup</a>, you can specify <i>source</i> equal to <i>user</i>.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_612574.validator(path, query, header, formData, body)
  let scheme = call_612574.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_612574.url(scheme.get, call_612574.host, call_612574.base,
                         call_612574.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_612574, url, valid)

proc call*(call_612575: Call_PostDescribeClusterParameters_612558;
          ParameterGroupName: string; Source: string = ""; MaxRecords: int = 0;
          Marker: string = ""; Action: string = "DescribeClusterParameters";
          Version: string = "2012-12-01"): Recallable =
  ## postDescribeClusterParameters
  ## <p>Returns a detailed list of parameters contained within the specified Amazon Redshift parameter group. For each parameter the response includes information such as parameter name, description, data type, value, whether the parameter value is modifiable, and so on.</p> <p>You can specify <i>source</i> filter to retrieve parameters of only specific type. For example, to retrieve parameters that were modified by a user action such as from <a>ModifyClusterParameterGroup</a>, you can specify <i>source</i> equal to <i>user</i>.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   Source: string
  ##         : <p>The parameter types to return. Specify <code>user</code> to show parameters that are different form the default. Similarly, specify <code>engine-default</code> to show parameters that are the same as the default parameter group. </p> <p>Default: All parameter types returned.</p> <p>Valid Values: <code>user</code> | <code>engine-default</code> </p>
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterParameters</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Action: string (required)
  ##   ParameterGroupName: string (required)
  ##                     : The name of a cluster parameter group for which to return details.
  ##   Version: string (required)
  var query_612576 = newJObject()
  var formData_612577 = newJObject()
  add(formData_612577, "Source", newJString(Source))
  add(formData_612577, "MaxRecords", newJInt(MaxRecords))
  add(formData_612577, "Marker", newJString(Marker))
  add(query_612576, "Action", newJString(Action))
  add(formData_612577, "ParameterGroupName", newJString(ParameterGroupName))
  add(query_612576, "Version", newJString(Version))
  result = call_612575.call(nil, query_612576, nil, formData_612577, nil)

var postDescribeClusterParameters* = Call_PostDescribeClusterParameters_612558(
    name: "postDescribeClusterParameters", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusterParameters",
    validator: validate_PostDescribeClusterParameters_612559, base: "/",
    url: url_PostDescribeClusterParameters_612560,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeClusterParameters_612539 = ref object of OpenApiRestCall_610642
proc url_GetDescribeClusterParameters_612541(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeClusterParameters_612540(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns a detailed list of parameters contained within the specified Amazon Redshift parameter group. For each parameter the response includes information such as parameter name, description, data type, value, whether the parameter value is modifiable, and so on.</p> <p>You can specify <i>source</i> filter to retrieve parameters of only specific type. For example, to retrieve parameters that were modified by a user action such as from <a>ModifyClusterParameterGroup</a>, you can specify <i>source</i> equal to <i>user</i>.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterParameters</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Source: JString
  ##         : <p>The parameter types to return. Specify <code>user</code> to show parameters that are different form the default. Similarly, specify <code>engine-default</code> to show parameters that are the same as the default parameter group. </p> <p>Default: All parameter types returned.</p> <p>Valid Values: <code>user</code> | <code>engine-default</code> </p>
  ##   Action: JString (required)
  ##   ParameterGroupName: JString (required)
  ##                     : The name of a cluster parameter group for which to return details.
  ##   Version: JString (required)
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  section = newJObject()
  var valid_612542 = query.getOrDefault("Marker")
  valid_612542 = validateParameter(valid_612542, JString, required = false,
                                 default = nil)
  if valid_612542 != nil:
    section.add "Marker", valid_612542
  var valid_612543 = query.getOrDefault("Source")
  valid_612543 = validateParameter(valid_612543, JString, required = false,
                                 default = nil)
  if valid_612543 != nil:
    section.add "Source", valid_612543
  var valid_612544 = query.getOrDefault("Action")
  valid_612544 = validateParameter(valid_612544, JString, required = true, default = newJString(
      "DescribeClusterParameters"))
  if valid_612544 != nil:
    section.add "Action", valid_612544
  var valid_612545 = query.getOrDefault("ParameterGroupName")
  valid_612545 = validateParameter(valid_612545, JString, required = true,
                                 default = nil)
  if valid_612545 != nil:
    section.add "ParameterGroupName", valid_612545
  var valid_612546 = query.getOrDefault("Version")
  valid_612546 = validateParameter(valid_612546, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_612546 != nil:
    section.add "Version", valid_612546
  var valid_612547 = query.getOrDefault("MaxRecords")
  valid_612547 = validateParameter(valid_612547, JInt, required = false, default = nil)
  if valid_612547 != nil:
    section.add "MaxRecords", valid_612547
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_612548 = header.getOrDefault("X-Amz-Signature")
  valid_612548 = validateParameter(valid_612548, JString, required = false,
                                 default = nil)
  if valid_612548 != nil:
    section.add "X-Amz-Signature", valid_612548
  var valid_612549 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_612549 = validateParameter(valid_612549, JString, required = false,
                                 default = nil)
  if valid_612549 != nil:
    section.add "X-Amz-Content-Sha256", valid_612549
  var valid_612550 = header.getOrDefault("X-Amz-Date")
  valid_612550 = validateParameter(valid_612550, JString, required = false,
                                 default = nil)
  if valid_612550 != nil:
    section.add "X-Amz-Date", valid_612550
  var valid_612551 = header.getOrDefault("X-Amz-Credential")
  valid_612551 = validateParameter(valid_612551, JString, required = false,
                                 default = nil)
  if valid_612551 != nil:
    section.add "X-Amz-Credential", valid_612551
  var valid_612552 = header.getOrDefault("X-Amz-Security-Token")
  valid_612552 = validateParameter(valid_612552, JString, required = false,
                                 default = nil)
  if valid_612552 != nil:
    section.add "X-Amz-Security-Token", valid_612552
  var valid_612553 = header.getOrDefault("X-Amz-Algorithm")
  valid_612553 = validateParameter(valid_612553, JString, required = false,
                                 default = nil)
  if valid_612553 != nil:
    section.add "X-Amz-Algorithm", valid_612553
  var valid_612554 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_612554 = validateParameter(valid_612554, JString, required = false,
                                 default = nil)
  if valid_612554 != nil:
    section.add "X-Amz-SignedHeaders", valid_612554
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_612555: Call_GetDescribeClusterParameters_612539; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns a detailed list of parameters contained within the specified Amazon Redshift parameter group. For each parameter the response includes information such as parameter name, description, data type, value, whether the parameter value is modifiable, and so on.</p> <p>You can specify <i>source</i> filter to retrieve parameters of only specific type. For example, to retrieve parameters that were modified by a user action such as from <a>ModifyClusterParameterGroup</a>, you can specify <i>source</i> equal to <i>user</i>.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_612555.validator(path, query, header, formData, body)
  let scheme = call_612555.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_612555.url(scheme.get, call_612555.host, call_612555.base,
                         call_612555.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_612555, url, valid)

proc call*(call_612556: Call_GetDescribeClusterParameters_612539;
          ParameterGroupName: string; Marker: string = ""; Source: string = "";
          Action: string = "DescribeClusterParameters";
          Version: string = "2012-12-01"; MaxRecords: int = 0): Recallable =
  ## getDescribeClusterParameters
  ## <p>Returns a detailed list of parameters contained within the specified Amazon Redshift parameter group. For each parameter the response includes information such as parameter name, description, data type, value, whether the parameter value is modifiable, and so on.</p> <p>You can specify <i>source</i> filter to retrieve parameters of only specific type. For example, to retrieve parameters that were modified by a user action such as from <a>ModifyClusterParameterGroup</a>, you can specify <i>source</i> equal to <i>user</i>.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterParameters</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Source: string
  ##         : <p>The parameter types to return. Specify <code>user</code> to show parameters that are different form the default. Similarly, specify <code>engine-default</code> to show parameters that are the same as the default parameter group. </p> <p>Default: All parameter types returned.</p> <p>Valid Values: <code>user</code> | <code>engine-default</code> </p>
  ##   Action: string (required)
  ##   ParameterGroupName: string (required)
  ##                     : The name of a cluster parameter group for which to return details.
  ##   Version: string (required)
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  var query_612557 = newJObject()
  add(query_612557, "Marker", newJString(Marker))
  add(query_612557, "Source", newJString(Source))
  add(query_612557, "Action", newJString(Action))
  add(query_612557, "ParameterGroupName", newJString(ParameterGroupName))
  add(query_612557, "Version", newJString(Version))
  add(query_612557, "MaxRecords", newJInt(MaxRecords))
  result = call_612556.call(nil, query_612557, nil, nil, nil)

var getDescribeClusterParameters* = Call_GetDescribeClusterParameters_612539(
    name: "getDescribeClusterParameters", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusterParameters",
    validator: validate_GetDescribeClusterParameters_612540, base: "/",
    url: url_GetDescribeClusterParameters_612541,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeClusterSecurityGroups_612598 = ref object of OpenApiRestCall_610642
proc url_PostDescribeClusterSecurityGroups_612600(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeClusterSecurityGroups_612599(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns information about Amazon Redshift security groups. If the name of a security group is specified, the response will contain only information about only that security group.</p> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all security groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all security groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, security groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_612601 = query.getOrDefault("Action")
  valid_612601 = validateParameter(valid_612601, JString, required = true, default = newJString(
      "DescribeClusterSecurityGroups"))
  if valid_612601 != nil:
    section.add "Action", valid_612601
  var valid_612602 = query.getOrDefault("Version")
  valid_612602 = validateParameter(valid_612602, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_612602 != nil:
    section.add "Version", valid_612602
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_612603 = header.getOrDefault("X-Amz-Signature")
  valid_612603 = validateParameter(valid_612603, JString, required = false,
                                 default = nil)
  if valid_612603 != nil:
    section.add "X-Amz-Signature", valid_612603
  var valid_612604 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_612604 = validateParameter(valid_612604, JString, required = false,
                                 default = nil)
  if valid_612604 != nil:
    section.add "X-Amz-Content-Sha256", valid_612604
  var valid_612605 = header.getOrDefault("X-Amz-Date")
  valid_612605 = validateParameter(valid_612605, JString, required = false,
                                 default = nil)
  if valid_612605 != nil:
    section.add "X-Amz-Date", valid_612605
  var valid_612606 = header.getOrDefault("X-Amz-Credential")
  valid_612606 = validateParameter(valid_612606, JString, required = false,
                                 default = nil)
  if valid_612606 != nil:
    section.add "X-Amz-Credential", valid_612606
  var valid_612607 = header.getOrDefault("X-Amz-Security-Token")
  valid_612607 = validateParameter(valid_612607, JString, required = false,
                                 default = nil)
  if valid_612607 != nil:
    section.add "X-Amz-Security-Token", valid_612607
  var valid_612608 = header.getOrDefault("X-Amz-Algorithm")
  valid_612608 = validateParameter(valid_612608, JString, required = false,
                                 default = nil)
  if valid_612608 != nil:
    section.add "X-Amz-Algorithm", valid_612608
  var valid_612609 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_612609 = validateParameter(valid_612609, JString, required = false,
                                 default = nil)
  if valid_612609 != nil:
    section.add "X-Amz-SignedHeaders", valid_612609
  result.add "header", section
  ## parameters in `formData` object:
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster security groups that are associated with the specified key or keys. For example, suppose that you have security groups that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the security groups that have either or both of these tag keys associated with them.
  ##   ClusterSecurityGroupName: JString
  ##                           : <p>The name of a cluster security group for which you are requesting details. You can specify either the <b>Marker</b> parameter or a <b>ClusterSecurityGroupName</b> parameter, but not both. </p> <p> Example: <code>securitygroup1</code> </p>
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: JString
  ##         : <p>An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterSecurityGroups</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <b>ClusterSecurityGroupName</b> parameter or the <b>Marker</b> parameter, but not both. </p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster security groups that are associated with the specified tag value or values. For example, suppose that you have security groups that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the security groups that have either or both of these tag values associated with them.
  section = newJObject()
  var valid_612610 = formData.getOrDefault("TagKeys")
  valid_612610 = validateParameter(valid_612610, JArray, required = false,
                                 default = nil)
  if valid_612610 != nil:
    section.add "TagKeys", valid_612610
  var valid_612611 = formData.getOrDefault("ClusterSecurityGroupName")
  valid_612611 = validateParameter(valid_612611, JString, required = false,
                                 default = nil)
  if valid_612611 != nil:
    section.add "ClusterSecurityGroupName", valid_612611
  var valid_612612 = formData.getOrDefault("MaxRecords")
  valid_612612 = validateParameter(valid_612612, JInt, required = false, default = nil)
  if valid_612612 != nil:
    section.add "MaxRecords", valid_612612
  var valid_612613 = formData.getOrDefault("Marker")
  valid_612613 = validateParameter(valid_612613, JString, required = false,
                                 default = nil)
  if valid_612613 != nil:
    section.add "Marker", valid_612613
  var valid_612614 = formData.getOrDefault("TagValues")
  valid_612614 = validateParameter(valid_612614, JArray, required = false,
                                 default = nil)
  if valid_612614 != nil:
    section.add "TagValues", valid_612614
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_612615: Call_PostDescribeClusterSecurityGroups_612598;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Returns information about Amazon Redshift security groups. If the name of a security group is specified, the response will contain only information about only that security group.</p> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all security groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all security groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, security groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_612615.validator(path, query, header, formData, body)
  let scheme = call_612615.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_612615.url(scheme.get, call_612615.host, call_612615.base,
                         call_612615.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_612615, url, valid)

proc call*(call_612616: Call_PostDescribeClusterSecurityGroups_612598;
          TagKeys: JsonNode = nil; ClusterSecurityGroupName: string = "";
          MaxRecords: int = 0; Marker: string = ""; TagValues: JsonNode = nil;
          Action: string = "DescribeClusterSecurityGroups";
          Version: string = "2012-12-01"): Recallable =
  ## postDescribeClusterSecurityGroups
  ## <p>Returns information about Amazon Redshift security groups. If the name of a security group is specified, the response will contain only information about only that security group.</p> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all security groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all security groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, security groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster security groups that are associated with the specified key or keys. For example, suppose that you have security groups that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the security groups that have either or both of these tag keys associated with them.
  ##   ClusterSecurityGroupName: string
  ##                           : <p>The name of a cluster security group for which you are requesting details. You can specify either the <b>Marker</b> parameter or a <b>ClusterSecurityGroupName</b> parameter, but not both. </p> <p> Example: <code>securitygroup1</code> </p>
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: string
  ##         : <p>An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterSecurityGroups</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <b>ClusterSecurityGroupName</b> parameter or the <b>Marker</b> parameter, but not both. </p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster security groups that are associated with the specified tag value or values. For example, suppose that you have security groups that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the security groups that have either or both of these tag values associated with them.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_612617 = newJObject()
  var formData_612618 = newJObject()
  if TagKeys != nil:
    formData_612618.add "TagKeys", TagKeys
  add(formData_612618, "ClusterSecurityGroupName",
      newJString(ClusterSecurityGroupName))
  add(formData_612618, "MaxRecords", newJInt(MaxRecords))
  add(formData_612618, "Marker", newJString(Marker))
  if TagValues != nil:
    formData_612618.add "TagValues", TagValues
  add(query_612617, "Action", newJString(Action))
  add(query_612617, "Version", newJString(Version))
  result = call_612616.call(nil, query_612617, nil, formData_612618, nil)

var postDescribeClusterSecurityGroups* = Call_PostDescribeClusterSecurityGroups_612598(
    name: "postDescribeClusterSecurityGroups", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeClusterSecurityGroups",
    validator: validate_PostDescribeClusterSecurityGroups_612599, base: "/",
    url: url_PostDescribeClusterSecurityGroups_612600,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeClusterSecurityGroups_612578 = ref object of OpenApiRestCall_610642
proc url_GetDescribeClusterSecurityGroups_612580(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeClusterSecurityGroups_612579(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns information about Amazon Redshift security groups. If the name of a security group is specified, the response will contain only information about only that security group.</p> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all security groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all security groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, security groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Marker: JString
  ##         : <p>An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterSecurityGroups</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <b>ClusterSecurityGroupName</b> parameter or the <b>Marker</b> parameter, but not both. </p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster security groups that are associated with the specified key or keys. For example, suppose that you have security groups that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the security groups that have either or both of these tag keys associated with them.
  ##   ClusterSecurityGroupName: JString
  ##                           : <p>The name of a cluster security group for which you are requesting details. You can specify either the <b>Marker</b> parameter or a <b>ClusterSecurityGroupName</b> parameter, but not both. </p> <p> Example: <code>securitygroup1</code> </p>
  ##   Action: JString (required)
  ##   Version: JString (required)
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster security groups that are associated with the specified tag value or values. For example, suppose that you have security groups that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the security groups that have either or both of these tag values associated with them.
  section = newJObject()
  var valid_612581 = query.getOrDefault("Marker")
  valid_612581 = validateParameter(valid_612581, JString, required = false,
                                 default = nil)
  if valid_612581 != nil:
    section.add "Marker", valid_612581
  var valid_612582 = query.getOrDefault("TagKeys")
  valid_612582 = validateParameter(valid_612582, JArray, required = false,
                                 default = nil)
  if valid_612582 != nil:
    section.add "TagKeys", valid_612582
  var valid_612583 = query.getOrDefault("ClusterSecurityGroupName")
  valid_612583 = validateParameter(valid_612583, JString, required = false,
                                 default = nil)
  if valid_612583 != nil:
    section.add "ClusterSecurityGroupName", valid_612583
  var valid_612584 = query.getOrDefault("Action")
  valid_612584 = validateParameter(valid_612584, JString, required = true, default = newJString(
      "DescribeClusterSecurityGroups"))
  if valid_612584 != nil:
    section.add "Action", valid_612584
  var valid_612585 = query.getOrDefault("Version")
  valid_612585 = validateParameter(valid_612585, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_612585 != nil:
    section.add "Version", valid_612585
  var valid_612586 = query.getOrDefault("MaxRecords")
  valid_612586 = validateParameter(valid_612586, JInt, required = false, default = nil)
  if valid_612586 != nil:
    section.add "MaxRecords", valid_612586
  var valid_612587 = query.getOrDefault("TagValues")
  valid_612587 = validateParameter(valid_612587, JArray, required = false,
                                 default = nil)
  if valid_612587 != nil:
    section.add "TagValues", valid_612587
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_612588 = header.getOrDefault("X-Amz-Signature")
  valid_612588 = validateParameter(valid_612588, JString, required = false,
                                 default = nil)
  if valid_612588 != nil:
    section.add "X-Amz-Signature", valid_612588
  var valid_612589 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_612589 = validateParameter(valid_612589, JString, required = false,
                                 default = nil)
  if valid_612589 != nil:
    section.add "X-Amz-Content-Sha256", valid_612589
  var valid_612590 = header.getOrDefault("X-Amz-Date")
  valid_612590 = validateParameter(valid_612590, JString, required = false,
                                 default = nil)
  if valid_612590 != nil:
    section.add "X-Amz-Date", valid_612590
  var valid_612591 = header.getOrDefault("X-Amz-Credential")
  valid_612591 = validateParameter(valid_612591, JString, required = false,
                                 default = nil)
  if valid_612591 != nil:
    section.add "X-Amz-Credential", valid_612591
  var valid_612592 = header.getOrDefault("X-Amz-Security-Token")
  valid_612592 = validateParameter(valid_612592, JString, required = false,
                                 default = nil)
  if valid_612592 != nil:
    section.add "X-Amz-Security-Token", valid_612592
  var valid_612593 = header.getOrDefault("X-Amz-Algorithm")
  valid_612593 = validateParameter(valid_612593, JString, required = false,
                                 default = nil)
  if valid_612593 != nil:
    section.add "X-Amz-Algorithm", valid_612593
  var valid_612594 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_612594 = validateParameter(valid_612594, JString, required = false,
                                 default = nil)
  if valid_612594 != nil:
    section.add "X-Amz-SignedHeaders", valid_612594
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_612595: Call_GetDescribeClusterSecurityGroups_612578;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Returns information about Amazon Redshift security groups. If the name of a security group is specified, the response will contain only information about only that security group.</p> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all security groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all security groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, security groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_612595.validator(path, query, header, formData, body)
  let scheme = call_612595.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_612595.url(scheme.get, call_612595.host, call_612595.base,
                         call_612595.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_612595, url, valid)

proc call*(call_612596: Call_GetDescribeClusterSecurityGroups_612578;
          Marker: string = ""; TagKeys: JsonNode = nil;
          ClusterSecurityGroupName: string = "";
          Action: string = "DescribeClusterSecurityGroups";
          Version: string = "2012-12-01"; MaxRecords: int = 0; TagValues: JsonNode = nil): Recallable =
  ## getDescribeClusterSecurityGroups
  ## <p>Returns information about Amazon Redshift security groups. If the name of a security group is specified, the response will contain only information about only that security group.</p> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all security groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all security groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, security groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   Marker: string
  ##         : <p>An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterSecurityGroups</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <b>ClusterSecurityGroupName</b> parameter or the <b>Marker</b> parameter, but not both. </p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster security groups that are associated with the specified key or keys. For example, suppose that you have security groups that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the security groups that have either or both of these tag keys associated with them.
  ##   ClusterSecurityGroupName: string
  ##                           : <p>The name of a cluster security group for which you are requesting details. You can specify either the <b>Marker</b> parameter or a <b>ClusterSecurityGroupName</b> parameter, but not both. </p> <p> Example: <code>securitygroup1</code> </p>
  ##   Action: string (required)
  ##   Version: string (required)
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster security groups that are associated with the specified tag value or values. For example, suppose that you have security groups that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the security groups that have either or both of these tag values associated with them.
  var query_612597 = newJObject()
  add(query_612597, "Marker", newJString(Marker))
  if TagKeys != nil:
    query_612597.add "TagKeys", TagKeys
  add(query_612597, "ClusterSecurityGroupName",
      newJString(ClusterSecurityGroupName))
  add(query_612597, "Action", newJString(Action))
  add(query_612597, "Version", newJString(Version))
  add(query_612597, "MaxRecords", newJInt(MaxRecords))
  if TagValues != nil:
    query_612597.add "TagValues", TagValues
  result = call_612596.call(nil, query_612597, nil, nil, nil)

var getDescribeClusterSecurityGroups* = Call_GetDescribeClusterSecurityGroups_612578(
    name: "getDescribeClusterSecurityGroups", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeClusterSecurityGroups",
    validator: validate_GetDescribeClusterSecurityGroups_612579, base: "/",
    url: url_GetDescribeClusterSecurityGroups_612580,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeClusterSnapshots_612646 = ref object of OpenApiRestCall_610642
proc url_PostDescribeClusterSnapshots_612648(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeClusterSnapshots_612647(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns one or more snapshot objects, which contain metadata about your cluster snapshots. By default, this operation returns information about all snapshots of all clusters that are owned by you AWS customer account. No information is returned for snapshots owned by inactive AWS customer accounts.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all snapshots that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all snapshots that have any combination of those values are returned. Only snapshots that you own are returned in the response; shared snapshots are not returned with the tag key and tag value request parameters.</p> <p>If both tag keys and values are omitted from the request, snapshots are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_612649 = query.getOrDefault("Action")
  valid_612649 = validateParameter(valid_612649, JString, required = true, default = newJString(
      "DescribeClusterSnapshots"))
  if valid_612649 != nil:
    section.add "Action", valid_612649
  var valid_612650 = query.getOrDefault("Version")
  valid_612650 = validateParameter(valid_612650, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_612650 != nil:
    section.add "Version", valid_612650
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_612651 = header.getOrDefault("X-Amz-Signature")
  valid_612651 = validateParameter(valid_612651, JString, required = false,
                                 default = nil)
  if valid_612651 != nil:
    section.add "X-Amz-Signature", valid_612651
  var valid_612652 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_612652 = validateParameter(valid_612652, JString, required = false,
                                 default = nil)
  if valid_612652 != nil:
    section.add "X-Amz-Content-Sha256", valid_612652
  var valid_612653 = header.getOrDefault("X-Amz-Date")
  valid_612653 = validateParameter(valid_612653, JString, required = false,
                                 default = nil)
  if valid_612653 != nil:
    section.add "X-Amz-Date", valid_612653
  var valid_612654 = header.getOrDefault("X-Amz-Credential")
  valid_612654 = validateParameter(valid_612654, JString, required = false,
                                 default = nil)
  if valid_612654 != nil:
    section.add "X-Amz-Credential", valid_612654
  var valid_612655 = header.getOrDefault("X-Amz-Security-Token")
  valid_612655 = validateParameter(valid_612655, JString, required = false,
                                 default = nil)
  if valid_612655 != nil:
    section.add "X-Amz-Security-Token", valid_612655
  var valid_612656 = header.getOrDefault("X-Amz-Algorithm")
  valid_612656 = validateParameter(valid_612656, JString, required = false,
                                 default = nil)
  if valid_612656 != nil:
    section.add "X-Amz-Algorithm", valid_612656
  var valid_612657 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_612657 = validateParameter(valid_612657, JString, required = false,
                                 default = nil)
  if valid_612657 != nil:
    section.add "X-Amz-SignedHeaders", valid_612657
  result.add "header", section
  ## parameters in `formData` object:
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster snapshots that are associated with the specified key or keys. For example, suppose that you have snapshots that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the snapshots that have either or both of these tag keys associated with them.
  ##   ClusterIdentifier: JString
  ##                    : The identifier of the cluster which generated the requested snapshots.
  ##   SnapshotType: JString
  ##               : <p>The type of snapshots for which you are requesting information. By default, snapshots of all types are returned.</p> <p>Valid Values: <code>automated</code> | <code>manual</code> </p>
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   OwnerAccount: JString
  ##               : The AWS customer account used to create or copy the snapshot. Use this field to filter the results to snapshots owned by a particular account. To describe snapshots you own, either specify your AWS customer account, or do not specify the parameter.
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterSnapshots</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   ClusterExists: JBool
  ##                : <p>A value that indicates whether to return snapshots only for an existing cluster. You can perform table-level restore only by using a snapshot of an existing cluster, that is, a cluster that has not been deleted. Values for this parameter work as follows: </p> <ul> <li> <p>If <code>ClusterExists</code> is set to <code>true</code>, <code>ClusterIdentifier</code> is required.</p> </li> <li> <p>If <code>ClusterExists</code> is set to <code>false</code> and <code>ClusterIdentifier</code> isn't specified, all snapshots associated with deleted clusters (orphaned snapshots) are returned. </p> </li> <li> <p>If <code>ClusterExists</code> is set to <code>false</code> and <code>ClusterIdentifier</code> is specified for a deleted cluster, snapshots associated with that cluster are returned.</p> </li> <li> <p>If <code>ClusterExists</code> is set to <code>false</code> and <code>ClusterIdentifier</code> is specified for an existing cluster, no snapshots are returned. </p> </li> </ul>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster snapshots that are associated with the specified tag value or values. For example, suppose that you have snapshots that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the snapshots that have either or both of these tag values associated with them.
  ##   EndTime: JString
  ##          : <p>A time value that requests only snapshots created at or before the specified time. The time value is specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2012-07-16T18:00:00Z</code> </p>
  ##   StartTime: JString
  ##            : <p>A value that requests only snapshots created at or after the specified time. The time value is specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2012-07-16T18:00:00Z</code> </p>
  ##   SnapshotIdentifier: JString
  ##                     : The snapshot identifier of the snapshot about which to return information.
  ##   SortingEntities: JArray
  ##                  : <p/>
  section = newJObject()
  var valid_612658 = formData.getOrDefault("TagKeys")
  valid_612658 = validateParameter(valid_612658, JArray, required = false,
                                 default = nil)
  if valid_612658 != nil:
    section.add "TagKeys", valid_612658
  var valid_612659 = formData.getOrDefault("ClusterIdentifier")
  valid_612659 = validateParameter(valid_612659, JString, required = false,
                                 default = nil)
  if valid_612659 != nil:
    section.add "ClusterIdentifier", valid_612659
  var valid_612660 = formData.getOrDefault("SnapshotType")
  valid_612660 = validateParameter(valid_612660, JString, required = false,
                                 default = nil)
  if valid_612660 != nil:
    section.add "SnapshotType", valid_612660
  var valid_612661 = formData.getOrDefault("MaxRecords")
  valid_612661 = validateParameter(valid_612661, JInt, required = false, default = nil)
  if valid_612661 != nil:
    section.add "MaxRecords", valid_612661
  var valid_612662 = formData.getOrDefault("OwnerAccount")
  valid_612662 = validateParameter(valid_612662, JString, required = false,
                                 default = nil)
  if valid_612662 != nil:
    section.add "OwnerAccount", valid_612662
  var valid_612663 = formData.getOrDefault("Marker")
  valid_612663 = validateParameter(valid_612663, JString, required = false,
                                 default = nil)
  if valid_612663 != nil:
    section.add "Marker", valid_612663
  var valid_612664 = formData.getOrDefault("ClusterExists")
  valid_612664 = validateParameter(valid_612664, JBool, required = false, default = nil)
  if valid_612664 != nil:
    section.add "ClusterExists", valid_612664
  var valid_612665 = formData.getOrDefault("TagValues")
  valid_612665 = validateParameter(valid_612665, JArray, required = false,
                                 default = nil)
  if valid_612665 != nil:
    section.add "TagValues", valid_612665
  var valid_612666 = formData.getOrDefault("EndTime")
  valid_612666 = validateParameter(valid_612666, JString, required = false,
                                 default = nil)
  if valid_612666 != nil:
    section.add "EndTime", valid_612666
  var valid_612667 = formData.getOrDefault("StartTime")
  valid_612667 = validateParameter(valid_612667, JString, required = false,
                                 default = nil)
  if valid_612667 != nil:
    section.add "StartTime", valid_612667
  var valid_612668 = formData.getOrDefault("SnapshotIdentifier")
  valid_612668 = validateParameter(valid_612668, JString, required = false,
                                 default = nil)
  if valid_612668 != nil:
    section.add "SnapshotIdentifier", valid_612668
  var valid_612669 = formData.getOrDefault("SortingEntities")
  valid_612669 = validateParameter(valid_612669, JArray, required = false,
                                 default = nil)
  if valid_612669 != nil:
    section.add "SortingEntities", valid_612669
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_612670: Call_PostDescribeClusterSnapshots_612646; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns one or more snapshot objects, which contain metadata about your cluster snapshots. By default, this operation returns information about all snapshots of all clusters that are owned by you AWS customer account. No information is returned for snapshots owned by inactive AWS customer accounts.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all snapshots that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all snapshots that have any combination of those values are returned. Only snapshots that you own are returned in the response; shared snapshots are not returned with the tag key and tag value request parameters.</p> <p>If both tag keys and values are omitted from the request, snapshots are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_612670.validator(path, query, header, formData, body)
  let scheme = call_612670.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_612670.url(scheme.get, call_612670.host, call_612670.base,
                         call_612670.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_612670, url, valid)

proc call*(call_612671: Call_PostDescribeClusterSnapshots_612646;
          TagKeys: JsonNode = nil; ClusterIdentifier: string = "";
          SnapshotType: string = ""; MaxRecords: int = 0; OwnerAccount: string = "";
          Marker: string = ""; ClusterExists: bool = false; TagValues: JsonNode = nil;
          EndTime: string = ""; StartTime: string = ""; SnapshotIdentifier: string = "";
          Action: string = "DescribeClusterSnapshots";
          SortingEntities: JsonNode = nil; Version: string = "2012-12-01"): Recallable =
  ## postDescribeClusterSnapshots
  ## <p>Returns one or more snapshot objects, which contain metadata about your cluster snapshots. By default, this operation returns information about all snapshots of all clusters that are owned by you AWS customer account. No information is returned for snapshots owned by inactive AWS customer accounts.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all snapshots that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all snapshots that have any combination of those values are returned. Only snapshots that you own are returned in the response; shared snapshots are not returned with the tag key and tag value request parameters.</p> <p>If both tag keys and values are omitted from the request, snapshots are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster snapshots that are associated with the specified key or keys. For example, suppose that you have snapshots that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the snapshots that have either or both of these tag keys associated with them.
  ##   ClusterIdentifier: string
  ##                    : The identifier of the cluster which generated the requested snapshots.
  ##   SnapshotType: string
  ##               : <p>The type of snapshots for which you are requesting information. By default, snapshots of all types are returned.</p> <p>Valid Values: <code>automated</code> | <code>manual</code> </p>
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   OwnerAccount: string
  ##               : The AWS customer account used to create or copy the snapshot. Use this field to filter the results to snapshots owned by a particular account. To describe snapshots you own, either specify your AWS customer account, or do not specify the parameter.
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterSnapshots</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   ClusterExists: bool
  ##                : <p>A value that indicates whether to return snapshots only for an existing cluster. You can perform table-level restore only by using a snapshot of an existing cluster, that is, a cluster that has not been deleted. Values for this parameter work as follows: </p> <ul> <li> <p>If <code>ClusterExists</code> is set to <code>true</code>, <code>ClusterIdentifier</code> is required.</p> </li> <li> <p>If <code>ClusterExists</code> is set to <code>false</code> and <code>ClusterIdentifier</code> isn't specified, all snapshots associated with deleted clusters (orphaned snapshots) are returned. </p> </li> <li> <p>If <code>ClusterExists</code> is set to <code>false</code> and <code>ClusterIdentifier</code> is specified for a deleted cluster, snapshots associated with that cluster are returned.</p> </li> <li> <p>If <code>ClusterExists</code> is set to <code>false</code> and <code>ClusterIdentifier</code> is specified for an existing cluster, no snapshots are returned. </p> </li> </ul>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster snapshots that are associated with the specified tag value or values. For example, suppose that you have snapshots that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the snapshots that have either or both of these tag values associated with them.
  ##   EndTime: string
  ##          : <p>A time value that requests only snapshots created at or before the specified time. The time value is specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2012-07-16T18:00:00Z</code> </p>
  ##   StartTime: string
  ##            : <p>A value that requests only snapshots created at or after the specified time. The time value is specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2012-07-16T18:00:00Z</code> </p>
  ##   SnapshotIdentifier: string
  ##                     : The snapshot identifier of the snapshot about which to return information.
  ##   Action: string (required)
  ##   SortingEntities: JArray
  ##                  : <p/>
  ##   Version: string (required)
  var query_612672 = newJObject()
  var formData_612673 = newJObject()
  if TagKeys != nil:
    formData_612673.add "TagKeys", TagKeys
  add(formData_612673, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_612673, "SnapshotType", newJString(SnapshotType))
  add(formData_612673, "MaxRecords", newJInt(MaxRecords))
  add(formData_612673, "OwnerAccount", newJString(OwnerAccount))
  add(formData_612673, "Marker", newJString(Marker))
  add(formData_612673, "ClusterExists", newJBool(ClusterExists))
  if TagValues != nil:
    formData_612673.add "TagValues", TagValues
  add(formData_612673, "EndTime", newJString(EndTime))
  add(formData_612673, "StartTime", newJString(StartTime))
  add(formData_612673, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_612672, "Action", newJString(Action))
  if SortingEntities != nil:
    formData_612673.add "SortingEntities", SortingEntities
  add(query_612672, "Version", newJString(Version))
  result = call_612671.call(nil, query_612672, nil, formData_612673, nil)

var postDescribeClusterSnapshots* = Call_PostDescribeClusterSnapshots_612646(
    name: "postDescribeClusterSnapshots", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusterSnapshots",
    validator: validate_PostDescribeClusterSnapshots_612647, base: "/",
    url: url_PostDescribeClusterSnapshots_612648,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeClusterSnapshots_612619 = ref object of OpenApiRestCall_610642
proc url_GetDescribeClusterSnapshots_612621(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeClusterSnapshots_612620(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns one or more snapshot objects, which contain metadata about your cluster snapshots. By default, this operation returns information about all snapshots of all clusters that are owned by you AWS customer account. No information is returned for snapshots owned by inactive AWS customer accounts.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all snapshots that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all snapshots that have any combination of those values are returned. Only snapshots that you own are returned in the response; shared snapshots are not returned with the tag key and tag value request parameters.</p> <p>If both tag keys and values are omitted from the request, snapshots are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterSnapshots</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   SortingEntities: JArray
  ##                  : <p/>
  ##   SnapshotIdentifier: JString
  ##                     : The snapshot identifier of the snapshot about which to return information.
  ##   ClusterExists: JBool
  ##                : <p>A value that indicates whether to return snapshots only for an existing cluster. You can perform table-level restore only by using a snapshot of an existing cluster, that is, a cluster that has not been deleted. Values for this parameter work as follows: </p> <ul> <li> <p>If <code>ClusterExists</code> is set to <code>true</code>, <code>ClusterIdentifier</code> is required.</p> </li> <li> <p>If <code>ClusterExists</code> is set to <code>false</code> and <code>ClusterIdentifier</code> isn't specified, all snapshots associated with deleted clusters (orphaned snapshots) are returned. </p> </li> <li> <p>If <code>ClusterExists</code> is set to <code>false</code> and <code>ClusterIdentifier</code> is specified for a deleted cluster, snapshots associated with that cluster are returned.</p> </li> <li> <p>If <code>ClusterExists</code> is set to <code>false</code> and <code>ClusterIdentifier</code> is specified for an existing cluster, no snapshots are returned. </p> </li> </ul>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster snapshots that are associated with the specified key or keys. For example, suppose that you have snapshots that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the snapshots that have either or both of these tag keys associated with them.
  ##   SnapshotType: JString
  ##               : <p>The type of snapshots for which you are requesting information. By default, snapshots of all types are returned.</p> <p>Valid Values: <code>automated</code> | <code>manual</code> </p>
  ##   Action: JString (required)
  ##   StartTime: JString
  ##            : <p>A value that requests only snapshots created at or after the specified time. The time value is specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2012-07-16T18:00:00Z</code> </p>
  ##   ClusterIdentifier: JString
  ##                    : The identifier of the cluster which generated the requested snapshots.
  ##   EndTime: JString
  ##          : <p>A time value that requests only snapshots created at or before the specified time. The time value is specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2012-07-16T18:00:00Z</code> </p>
  ##   OwnerAccount: JString
  ##               : The AWS customer account used to create or copy the snapshot. Use this field to filter the results to snapshots owned by a particular account. To describe snapshots you own, either specify your AWS customer account, or do not specify the parameter.
  ##   Version: JString (required)
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster snapshots that are associated with the specified tag value or values. For example, suppose that you have snapshots that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the snapshots that have either or both of these tag values associated with them.
  section = newJObject()
  var valid_612622 = query.getOrDefault("Marker")
  valid_612622 = validateParameter(valid_612622, JString, required = false,
                                 default = nil)
  if valid_612622 != nil:
    section.add "Marker", valid_612622
  var valid_612623 = query.getOrDefault("SortingEntities")
  valid_612623 = validateParameter(valid_612623, JArray, required = false,
                                 default = nil)
  if valid_612623 != nil:
    section.add "SortingEntities", valid_612623
  var valid_612624 = query.getOrDefault("SnapshotIdentifier")
  valid_612624 = validateParameter(valid_612624, JString, required = false,
                                 default = nil)
  if valid_612624 != nil:
    section.add "SnapshotIdentifier", valid_612624
  var valid_612625 = query.getOrDefault("ClusterExists")
  valid_612625 = validateParameter(valid_612625, JBool, required = false, default = nil)
  if valid_612625 != nil:
    section.add "ClusterExists", valid_612625
  var valid_612626 = query.getOrDefault("TagKeys")
  valid_612626 = validateParameter(valid_612626, JArray, required = false,
                                 default = nil)
  if valid_612626 != nil:
    section.add "TagKeys", valid_612626
  var valid_612627 = query.getOrDefault("SnapshotType")
  valid_612627 = validateParameter(valid_612627, JString, required = false,
                                 default = nil)
  if valid_612627 != nil:
    section.add "SnapshotType", valid_612627
  var valid_612628 = query.getOrDefault("Action")
  valid_612628 = validateParameter(valid_612628, JString, required = true, default = newJString(
      "DescribeClusterSnapshots"))
  if valid_612628 != nil:
    section.add "Action", valid_612628
  var valid_612629 = query.getOrDefault("StartTime")
  valid_612629 = validateParameter(valid_612629, JString, required = false,
                                 default = nil)
  if valid_612629 != nil:
    section.add "StartTime", valid_612629
  var valid_612630 = query.getOrDefault("ClusterIdentifier")
  valid_612630 = validateParameter(valid_612630, JString, required = false,
                                 default = nil)
  if valid_612630 != nil:
    section.add "ClusterIdentifier", valid_612630
  var valid_612631 = query.getOrDefault("EndTime")
  valid_612631 = validateParameter(valid_612631, JString, required = false,
                                 default = nil)
  if valid_612631 != nil:
    section.add "EndTime", valid_612631
  var valid_612632 = query.getOrDefault("OwnerAccount")
  valid_612632 = validateParameter(valid_612632, JString, required = false,
                                 default = nil)
  if valid_612632 != nil:
    section.add "OwnerAccount", valid_612632
  var valid_612633 = query.getOrDefault("Version")
  valid_612633 = validateParameter(valid_612633, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_612633 != nil:
    section.add "Version", valid_612633
  var valid_612634 = query.getOrDefault("MaxRecords")
  valid_612634 = validateParameter(valid_612634, JInt, required = false, default = nil)
  if valid_612634 != nil:
    section.add "MaxRecords", valid_612634
  var valid_612635 = query.getOrDefault("TagValues")
  valid_612635 = validateParameter(valid_612635, JArray, required = false,
                                 default = nil)
  if valid_612635 != nil:
    section.add "TagValues", valid_612635
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_612636 = header.getOrDefault("X-Amz-Signature")
  valid_612636 = validateParameter(valid_612636, JString, required = false,
                                 default = nil)
  if valid_612636 != nil:
    section.add "X-Amz-Signature", valid_612636
  var valid_612637 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_612637 = validateParameter(valid_612637, JString, required = false,
                                 default = nil)
  if valid_612637 != nil:
    section.add "X-Amz-Content-Sha256", valid_612637
  var valid_612638 = header.getOrDefault("X-Amz-Date")
  valid_612638 = validateParameter(valid_612638, JString, required = false,
                                 default = nil)
  if valid_612638 != nil:
    section.add "X-Amz-Date", valid_612638
  var valid_612639 = header.getOrDefault("X-Amz-Credential")
  valid_612639 = validateParameter(valid_612639, JString, required = false,
                                 default = nil)
  if valid_612639 != nil:
    section.add "X-Amz-Credential", valid_612639
  var valid_612640 = header.getOrDefault("X-Amz-Security-Token")
  valid_612640 = validateParameter(valid_612640, JString, required = false,
                                 default = nil)
  if valid_612640 != nil:
    section.add "X-Amz-Security-Token", valid_612640
  var valid_612641 = header.getOrDefault("X-Amz-Algorithm")
  valid_612641 = validateParameter(valid_612641, JString, required = false,
                                 default = nil)
  if valid_612641 != nil:
    section.add "X-Amz-Algorithm", valid_612641
  var valid_612642 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_612642 = validateParameter(valid_612642, JString, required = false,
                                 default = nil)
  if valid_612642 != nil:
    section.add "X-Amz-SignedHeaders", valid_612642
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_612643: Call_GetDescribeClusterSnapshots_612619; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns one or more snapshot objects, which contain metadata about your cluster snapshots. By default, this operation returns information about all snapshots of all clusters that are owned by you AWS customer account. No information is returned for snapshots owned by inactive AWS customer accounts.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all snapshots that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all snapshots that have any combination of those values are returned. Only snapshots that you own are returned in the response; shared snapshots are not returned with the tag key and tag value request parameters.</p> <p>If both tag keys and values are omitted from the request, snapshots are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_612643.validator(path, query, header, formData, body)
  let scheme = call_612643.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_612643.url(scheme.get, call_612643.host, call_612643.base,
                         call_612643.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_612643, url, valid)

proc call*(call_612644: Call_GetDescribeClusterSnapshots_612619;
          Marker: string = ""; SortingEntities: JsonNode = nil;
          SnapshotIdentifier: string = ""; ClusterExists: bool = false;
          TagKeys: JsonNode = nil; SnapshotType: string = "";
          Action: string = "DescribeClusterSnapshots"; StartTime: string = "";
          ClusterIdentifier: string = ""; EndTime: string = "";
          OwnerAccount: string = ""; Version: string = "2012-12-01";
          MaxRecords: int = 0; TagValues: JsonNode = nil): Recallable =
  ## getDescribeClusterSnapshots
  ## <p>Returns one or more snapshot objects, which contain metadata about your cluster snapshots. By default, this operation returns information about all snapshots of all clusters that are owned by you AWS customer account. No information is returned for snapshots owned by inactive AWS customer accounts.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all snapshots that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all snapshots that have any combination of those values are returned. Only snapshots that you own are returned in the response; shared snapshots are not returned with the tag key and tag value request parameters.</p> <p>If both tag keys and values are omitted from the request, snapshots are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterSnapshots</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   SortingEntities: JArray
  ##                  : <p/>
  ##   SnapshotIdentifier: string
  ##                     : The snapshot identifier of the snapshot about which to return information.
  ##   ClusterExists: bool
  ##                : <p>A value that indicates whether to return snapshots only for an existing cluster. You can perform table-level restore only by using a snapshot of an existing cluster, that is, a cluster that has not been deleted. Values for this parameter work as follows: </p> <ul> <li> <p>If <code>ClusterExists</code> is set to <code>true</code>, <code>ClusterIdentifier</code> is required.</p> </li> <li> <p>If <code>ClusterExists</code> is set to <code>false</code> and <code>ClusterIdentifier</code> isn't specified, all snapshots associated with deleted clusters (orphaned snapshots) are returned. </p> </li> <li> <p>If <code>ClusterExists</code> is set to <code>false</code> and <code>ClusterIdentifier</code> is specified for a deleted cluster, snapshots associated with that cluster are returned.</p> </li> <li> <p>If <code>ClusterExists</code> is set to <code>false</code> and <code>ClusterIdentifier</code> is specified for an existing cluster, no snapshots are returned. </p> </li> </ul>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster snapshots that are associated with the specified key or keys. For example, suppose that you have snapshots that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the snapshots that have either or both of these tag keys associated with them.
  ##   SnapshotType: string
  ##               : <p>The type of snapshots for which you are requesting information. By default, snapshots of all types are returned.</p> <p>Valid Values: <code>automated</code> | <code>manual</code> </p>
  ##   Action: string (required)
  ##   StartTime: string
  ##            : <p>A value that requests only snapshots created at or after the specified time. The time value is specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2012-07-16T18:00:00Z</code> </p>
  ##   ClusterIdentifier: string
  ##                    : The identifier of the cluster which generated the requested snapshots.
  ##   EndTime: string
  ##          : <p>A time value that requests only snapshots created at or before the specified time. The time value is specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2012-07-16T18:00:00Z</code> </p>
  ##   OwnerAccount: string
  ##               : The AWS customer account used to create or copy the snapshot. Use this field to filter the results to snapshots owned by a particular account. To describe snapshots you own, either specify your AWS customer account, or do not specify the parameter.
  ##   Version: string (required)
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster snapshots that are associated with the specified tag value or values. For example, suppose that you have snapshots that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the snapshots that have either or both of these tag values associated with them.
  var query_612645 = newJObject()
  add(query_612645, "Marker", newJString(Marker))
  if SortingEntities != nil:
    query_612645.add "SortingEntities", SortingEntities
  add(query_612645, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_612645, "ClusterExists", newJBool(ClusterExists))
  if TagKeys != nil:
    query_612645.add "TagKeys", TagKeys
  add(query_612645, "SnapshotType", newJString(SnapshotType))
  add(query_612645, "Action", newJString(Action))
  add(query_612645, "StartTime", newJString(StartTime))
  add(query_612645, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_612645, "EndTime", newJString(EndTime))
  add(query_612645, "OwnerAccount", newJString(OwnerAccount))
  add(query_612645, "Version", newJString(Version))
  add(query_612645, "MaxRecords", newJInt(MaxRecords))
  if TagValues != nil:
    query_612645.add "TagValues", TagValues
  result = call_612644.call(nil, query_612645, nil, nil, nil)

var getDescribeClusterSnapshots* = Call_GetDescribeClusterSnapshots_612619(
    name: "getDescribeClusterSnapshots", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusterSnapshots",
    validator: validate_GetDescribeClusterSnapshots_612620, base: "/",
    url: url_GetDescribeClusterSnapshots_612621,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeClusterSubnetGroups_612694 = ref object of OpenApiRestCall_610642
proc url_PostDescribeClusterSubnetGroups_612696(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeClusterSubnetGroups_612695(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns one or more cluster subnet group objects, which contain metadata about your cluster subnet groups. By default, this operation returns information about all cluster subnet groups that are defined in you AWS account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all subnet groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all subnet groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, subnet groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_612697 = query.getOrDefault("Action")
  valid_612697 = validateParameter(valid_612697, JString, required = true, default = newJString(
      "DescribeClusterSubnetGroups"))
  if valid_612697 != nil:
    section.add "Action", valid_612697
  var valid_612698 = query.getOrDefault("Version")
  valid_612698 = validateParameter(valid_612698, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_612698 != nil:
    section.add "Version", valid_612698
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_612699 = header.getOrDefault("X-Amz-Signature")
  valid_612699 = validateParameter(valid_612699, JString, required = false,
                                 default = nil)
  if valid_612699 != nil:
    section.add "X-Amz-Signature", valid_612699
  var valid_612700 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_612700 = validateParameter(valid_612700, JString, required = false,
                                 default = nil)
  if valid_612700 != nil:
    section.add "X-Amz-Content-Sha256", valid_612700
  var valid_612701 = header.getOrDefault("X-Amz-Date")
  valid_612701 = validateParameter(valid_612701, JString, required = false,
                                 default = nil)
  if valid_612701 != nil:
    section.add "X-Amz-Date", valid_612701
  var valid_612702 = header.getOrDefault("X-Amz-Credential")
  valid_612702 = validateParameter(valid_612702, JString, required = false,
                                 default = nil)
  if valid_612702 != nil:
    section.add "X-Amz-Credential", valid_612702
  var valid_612703 = header.getOrDefault("X-Amz-Security-Token")
  valid_612703 = validateParameter(valid_612703, JString, required = false,
                                 default = nil)
  if valid_612703 != nil:
    section.add "X-Amz-Security-Token", valid_612703
  var valid_612704 = header.getOrDefault("X-Amz-Algorithm")
  valid_612704 = validateParameter(valid_612704, JString, required = false,
                                 default = nil)
  if valid_612704 != nil:
    section.add "X-Amz-Algorithm", valid_612704
  var valid_612705 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_612705 = validateParameter(valid_612705, JString, required = false,
                                 default = nil)
  if valid_612705 != nil:
    section.add "X-Amz-SignedHeaders", valid_612705
  result.add "header", section
  ## parameters in `formData` object:
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster subnet groups that are associated with the specified key or keys. For example, suppose that you have subnet groups that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the subnet groups that have either or both of these tag keys associated with them.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterSubnetGroups</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   ClusterSubnetGroupName: JString
  ##                         : The name of the cluster subnet group for which information is requested.
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster subnet groups that are associated with the specified tag value or values. For example, suppose that you have subnet groups that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the subnet groups that have either or both of these tag values associated with them.
  section = newJObject()
  var valid_612706 = formData.getOrDefault("TagKeys")
  valid_612706 = validateParameter(valid_612706, JArray, required = false,
                                 default = nil)
  if valid_612706 != nil:
    section.add "TagKeys", valid_612706
  var valid_612707 = formData.getOrDefault("MaxRecords")
  valid_612707 = validateParameter(valid_612707, JInt, required = false, default = nil)
  if valid_612707 != nil:
    section.add "MaxRecords", valid_612707
  var valid_612708 = formData.getOrDefault("Marker")
  valid_612708 = validateParameter(valid_612708, JString, required = false,
                                 default = nil)
  if valid_612708 != nil:
    section.add "Marker", valid_612708
  var valid_612709 = formData.getOrDefault("ClusterSubnetGroupName")
  valid_612709 = validateParameter(valid_612709, JString, required = false,
                                 default = nil)
  if valid_612709 != nil:
    section.add "ClusterSubnetGroupName", valid_612709
  var valid_612710 = formData.getOrDefault("TagValues")
  valid_612710 = validateParameter(valid_612710, JArray, required = false,
                                 default = nil)
  if valid_612710 != nil:
    section.add "TagValues", valid_612710
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_612711: Call_PostDescribeClusterSubnetGroups_612694;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Returns one or more cluster subnet group objects, which contain metadata about your cluster subnet groups. By default, this operation returns information about all cluster subnet groups that are defined in you AWS account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all subnet groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all subnet groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, subnet groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_612711.validator(path, query, header, formData, body)
  let scheme = call_612711.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_612711.url(scheme.get, call_612711.host, call_612711.base,
                         call_612711.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_612711, url, valid)

proc call*(call_612712: Call_PostDescribeClusterSubnetGroups_612694;
          TagKeys: JsonNode = nil; MaxRecords: int = 0; Marker: string = "";
          ClusterSubnetGroupName: string = ""; TagValues: JsonNode = nil;
          Action: string = "DescribeClusterSubnetGroups";
          Version: string = "2012-12-01"): Recallable =
  ## postDescribeClusterSubnetGroups
  ## <p>Returns one or more cluster subnet group objects, which contain metadata about your cluster subnet groups. By default, this operation returns information about all cluster subnet groups that are defined in you AWS account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all subnet groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all subnet groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, subnet groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster subnet groups that are associated with the specified key or keys. For example, suppose that you have subnet groups that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the subnet groups that have either or both of these tag keys associated with them.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterSubnetGroups</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   ClusterSubnetGroupName: string
  ##                         : The name of the cluster subnet group for which information is requested.
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster subnet groups that are associated with the specified tag value or values. For example, suppose that you have subnet groups that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the subnet groups that have either or both of these tag values associated with them.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_612713 = newJObject()
  var formData_612714 = newJObject()
  if TagKeys != nil:
    formData_612714.add "TagKeys", TagKeys
  add(formData_612714, "MaxRecords", newJInt(MaxRecords))
  add(formData_612714, "Marker", newJString(Marker))
  add(formData_612714, "ClusterSubnetGroupName",
      newJString(ClusterSubnetGroupName))
  if TagValues != nil:
    formData_612714.add "TagValues", TagValues
  add(query_612713, "Action", newJString(Action))
  add(query_612713, "Version", newJString(Version))
  result = call_612712.call(nil, query_612713, nil, formData_612714, nil)

var postDescribeClusterSubnetGroups* = Call_PostDescribeClusterSubnetGroups_612694(
    name: "postDescribeClusterSubnetGroups", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusterSubnetGroups",
    validator: validate_PostDescribeClusterSubnetGroups_612695, base: "/",
    url: url_PostDescribeClusterSubnetGroups_612696,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeClusterSubnetGroups_612674 = ref object of OpenApiRestCall_610642
proc url_GetDescribeClusterSubnetGroups_612676(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeClusterSubnetGroups_612675(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns one or more cluster subnet group objects, which contain metadata about your cluster subnet groups. By default, this operation returns information about all cluster subnet groups that are defined in you AWS account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all subnet groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all subnet groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, subnet groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ClusterSubnetGroupName: JString
  ##                         : The name of the cluster subnet group for which information is requested.
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterSubnetGroups</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster subnet groups that are associated with the specified key or keys. For example, suppose that you have subnet groups that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the subnet groups that have either or both of these tag keys associated with them.
  ##   Action: JString (required)
  ##   Version: JString (required)
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster subnet groups that are associated with the specified tag value or values. For example, suppose that you have subnet groups that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the subnet groups that have either or both of these tag values associated with them.
  section = newJObject()
  var valid_612677 = query.getOrDefault("ClusterSubnetGroupName")
  valid_612677 = validateParameter(valid_612677, JString, required = false,
                                 default = nil)
  if valid_612677 != nil:
    section.add "ClusterSubnetGroupName", valid_612677
  var valid_612678 = query.getOrDefault("Marker")
  valid_612678 = validateParameter(valid_612678, JString, required = false,
                                 default = nil)
  if valid_612678 != nil:
    section.add "Marker", valid_612678
  var valid_612679 = query.getOrDefault("TagKeys")
  valid_612679 = validateParameter(valid_612679, JArray, required = false,
                                 default = nil)
  if valid_612679 != nil:
    section.add "TagKeys", valid_612679
  var valid_612680 = query.getOrDefault("Action")
  valid_612680 = validateParameter(valid_612680, JString, required = true, default = newJString(
      "DescribeClusterSubnetGroups"))
  if valid_612680 != nil:
    section.add "Action", valid_612680
  var valid_612681 = query.getOrDefault("Version")
  valid_612681 = validateParameter(valid_612681, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_612681 != nil:
    section.add "Version", valid_612681
  var valid_612682 = query.getOrDefault("MaxRecords")
  valid_612682 = validateParameter(valid_612682, JInt, required = false, default = nil)
  if valid_612682 != nil:
    section.add "MaxRecords", valid_612682
  var valid_612683 = query.getOrDefault("TagValues")
  valid_612683 = validateParameter(valid_612683, JArray, required = false,
                                 default = nil)
  if valid_612683 != nil:
    section.add "TagValues", valid_612683
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_612684 = header.getOrDefault("X-Amz-Signature")
  valid_612684 = validateParameter(valid_612684, JString, required = false,
                                 default = nil)
  if valid_612684 != nil:
    section.add "X-Amz-Signature", valid_612684
  var valid_612685 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_612685 = validateParameter(valid_612685, JString, required = false,
                                 default = nil)
  if valid_612685 != nil:
    section.add "X-Amz-Content-Sha256", valid_612685
  var valid_612686 = header.getOrDefault("X-Amz-Date")
  valid_612686 = validateParameter(valid_612686, JString, required = false,
                                 default = nil)
  if valid_612686 != nil:
    section.add "X-Amz-Date", valid_612686
  var valid_612687 = header.getOrDefault("X-Amz-Credential")
  valid_612687 = validateParameter(valid_612687, JString, required = false,
                                 default = nil)
  if valid_612687 != nil:
    section.add "X-Amz-Credential", valid_612687
  var valid_612688 = header.getOrDefault("X-Amz-Security-Token")
  valid_612688 = validateParameter(valid_612688, JString, required = false,
                                 default = nil)
  if valid_612688 != nil:
    section.add "X-Amz-Security-Token", valid_612688
  var valid_612689 = header.getOrDefault("X-Amz-Algorithm")
  valid_612689 = validateParameter(valid_612689, JString, required = false,
                                 default = nil)
  if valid_612689 != nil:
    section.add "X-Amz-Algorithm", valid_612689
  var valid_612690 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_612690 = validateParameter(valid_612690, JString, required = false,
                                 default = nil)
  if valid_612690 != nil:
    section.add "X-Amz-SignedHeaders", valid_612690
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_612691: Call_GetDescribeClusterSubnetGroups_612674; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns one or more cluster subnet group objects, which contain metadata about your cluster subnet groups. By default, this operation returns information about all cluster subnet groups that are defined in you AWS account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all subnet groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all subnet groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, subnet groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_612691.validator(path, query, header, formData, body)
  let scheme = call_612691.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_612691.url(scheme.get, call_612691.host, call_612691.base,
                         call_612691.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_612691, url, valid)

proc call*(call_612692: Call_GetDescribeClusterSubnetGroups_612674;
          ClusterSubnetGroupName: string = ""; Marker: string = "";
          TagKeys: JsonNode = nil; Action: string = "DescribeClusterSubnetGroups";
          Version: string = "2012-12-01"; MaxRecords: int = 0; TagValues: JsonNode = nil): Recallable =
  ## getDescribeClusterSubnetGroups
  ## <p>Returns one or more cluster subnet group objects, which contain metadata about your cluster subnet groups. By default, this operation returns information about all cluster subnet groups that are defined in you AWS account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all subnet groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all subnet groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, subnet groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   ClusterSubnetGroupName: string
  ##                         : The name of the cluster subnet group for which information is requested.
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterSubnetGroups</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster subnet groups that are associated with the specified key or keys. For example, suppose that you have subnet groups that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the subnet groups that have either or both of these tag keys associated with them.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster subnet groups that are associated with the specified tag value or values. For example, suppose that you have subnet groups that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the subnet groups that have either or both of these tag values associated with them.
  var query_612693 = newJObject()
  add(query_612693, "ClusterSubnetGroupName", newJString(ClusterSubnetGroupName))
  add(query_612693, "Marker", newJString(Marker))
  if TagKeys != nil:
    query_612693.add "TagKeys", TagKeys
  add(query_612693, "Action", newJString(Action))
  add(query_612693, "Version", newJString(Version))
  add(query_612693, "MaxRecords", newJInt(MaxRecords))
  if TagValues != nil:
    query_612693.add "TagValues", TagValues
  result = call_612692.call(nil, query_612693, nil, nil, nil)

var getDescribeClusterSubnetGroups* = Call_GetDescribeClusterSubnetGroups_612674(
    name: "getDescribeClusterSubnetGroups", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusterSubnetGroups",
    validator: validate_GetDescribeClusterSubnetGroups_612675, base: "/",
    url: url_GetDescribeClusterSubnetGroups_612676,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeClusterTracks_612733 = ref object of OpenApiRestCall_610642
proc url_PostDescribeClusterTracks_612735(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeClusterTracks_612734(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns a list of all the available maintenance tracks.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_612736 = query.getOrDefault("Action")
  valid_612736 = validateParameter(valid_612736, JString, required = true,
                                 default = newJString("DescribeClusterTracks"))
  if valid_612736 != nil:
    section.add "Action", valid_612736
  var valid_612737 = query.getOrDefault("Version")
  valid_612737 = validateParameter(valid_612737, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_612737 != nil:
    section.add "Version", valid_612737
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_612738 = header.getOrDefault("X-Amz-Signature")
  valid_612738 = validateParameter(valid_612738, JString, required = false,
                                 default = nil)
  if valid_612738 != nil:
    section.add "X-Amz-Signature", valid_612738
  var valid_612739 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_612739 = validateParameter(valid_612739, JString, required = false,
                                 default = nil)
  if valid_612739 != nil:
    section.add "X-Amz-Content-Sha256", valid_612739
  var valid_612740 = header.getOrDefault("X-Amz-Date")
  valid_612740 = validateParameter(valid_612740, JString, required = false,
                                 default = nil)
  if valid_612740 != nil:
    section.add "X-Amz-Date", valid_612740
  var valid_612741 = header.getOrDefault("X-Amz-Credential")
  valid_612741 = validateParameter(valid_612741, JString, required = false,
                                 default = nil)
  if valid_612741 != nil:
    section.add "X-Amz-Credential", valid_612741
  var valid_612742 = header.getOrDefault("X-Amz-Security-Token")
  valid_612742 = validateParameter(valid_612742, JString, required = false,
                                 default = nil)
  if valid_612742 != nil:
    section.add "X-Amz-Security-Token", valid_612742
  var valid_612743 = header.getOrDefault("X-Amz-Algorithm")
  valid_612743 = validateParameter(valid_612743, JString, required = false,
                                 default = nil)
  if valid_612743 != nil:
    section.add "X-Amz-Algorithm", valid_612743
  var valid_612744 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_612744 = validateParameter(valid_612744, JString, required = false,
                                 default = nil)
  if valid_612744 != nil:
    section.add "X-Amz-SignedHeaders", valid_612744
  result.add "header", section
  ## parameters in `formData` object:
  ##   MaintenanceTrackName: JString
  ##                       : The name of the maintenance track. 
  ##   MaxRecords: JInt
  ##             : An integer value for the maximum number of maintenance tracks to return.
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <code>DescribeClusterTracks</code> request exceed the value specified in <code>MaxRecords</code>, Amazon Redshift returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  section = newJObject()
  var valid_612745 = formData.getOrDefault("MaintenanceTrackName")
  valid_612745 = validateParameter(valid_612745, JString, required = false,
                                 default = nil)
  if valid_612745 != nil:
    section.add "MaintenanceTrackName", valid_612745
  var valid_612746 = formData.getOrDefault("MaxRecords")
  valid_612746 = validateParameter(valid_612746, JInt, required = false, default = nil)
  if valid_612746 != nil:
    section.add "MaxRecords", valid_612746
  var valid_612747 = formData.getOrDefault("Marker")
  valid_612747 = validateParameter(valid_612747, JString, required = false,
                                 default = nil)
  if valid_612747 != nil:
    section.add "Marker", valid_612747
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_612748: Call_PostDescribeClusterTracks_612733; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns a list of all the available maintenance tracks.
  ## 
  let valid = call_612748.validator(path, query, header, formData, body)
  let scheme = call_612748.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_612748.url(scheme.get, call_612748.host, call_612748.base,
                         call_612748.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_612748, url, valid)

proc call*(call_612749: Call_PostDescribeClusterTracks_612733;
          MaintenanceTrackName: string = ""; MaxRecords: int = 0; Marker: string = "";
          Action: string = "DescribeClusterTracks"; Version: string = "2012-12-01"): Recallable =
  ## postDescribeClusterTracks
  ## Returns a list of all the available maintenance tracks.
  ##   MaintenanceTrackName: string
  ##                       : The name of the maintenance track. 
  ##   MaxRecords: int
  ##             : An integer value for the maximum number of maintenance tracks to return.
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <code>DescribeClusterTracks</code> request exceed the value specified in <code>MaxRecords</code>, Amazon Redshift returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Action: string (required)
  ##   Version: string (required)
  var query_612750 = newJObject()
  var formData_612751 = newJObject()
  add(formData_612751, "MaintenanceTrackName", newJString(MaintenanceTrackName))
  add(formData_612751, "MaxRecords", newJInt(MaxRecords))
  add(formData_612751, "Marker", newJString(Marker))
  add(query_612750, "Action", newJString(Action))
  add(query_612750, "Version", newJString(Version))
  result = call_612749.call(nil, query_612750, nil, formData_612751, nil)

var postDescribeClusterTracks* = Call_PostDescribeClusterTracks_612733(
    name: "postDescribeClusterTracks", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusterTracks",
    validator: validate_PostDescribeClusterTracks_612734, base: "/",
    url: url_PostDescribeClusterTracks_612735,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeClusterTracks_612715 = ref object of OpenApiRestCall_610642
proc url_GetDescribeClusterTracks_612717(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeClusterTracks_612716(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns a list of all the available maintenance tracks.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <code>DescribeClusterTracks</code> request exceed the value specified in <code>MaxRecords</code>, Amazon Redshift returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   MaintenanceTrackName: JString
  ##                       : The name of the maintenance track. 
  ##   Action: JString (required)
  ##   Version: JString (required)
  ##   MaxRecords: JInt
  ##             : An integer value for the maximum number of maintenance tracks to return.
  section = newJObject()
  var valid_612718 = query.getOrDefault("Marker")
  valid_612718 = validateParameter(valid_612718, JString, required = false,
                                 default = nil)
  if valid_612718 != nil:
    section.add "Marker", valid_612718
  var valid_612719 = query.getOrDefault("MaintenanceTrackName")
  valid_612719 = validateParameter(valid_612719, JString, required = false,
                                 default = nil)
  if valid_612719 != nil:
    section.add "MaintenanceTrackName", valid_612719
  var valid_612720 = query.getOrDefault("Action")
  valid_612720 = validateParameter(valid_612720, JString, required = true,
                                 default = newJString("DescribeClusterTracks"))
  if valid_612720 != nil:
    section.add "Action", valid_612720
  var valid_612721 = query.getOrDefault("Version")
  valid_612721 = validateParameter(valid_612721, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_612721 != nil:
    section.add "Version", valid_612721
  var valid_612722 = query.getOrDefault("MaxRecords")
  valid_612722 = validateParameter(valid_612722, JInt, required = false, default = nil)
  if valid_612722 != nil:
    section.add "MaxRecords", valid_612722
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_612723 = header.getOrDefault("X-Amz-Signature")
  valid_612723 = validateParameter(valid_612723, JString, required = false,
                                 default = nil)
  if valid_612723 != nil:
    section.add "X-Amz-Signature", valid_612723
  var valid_612724 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_612724 = validateParameter(valid_612724, JString, required = false,
                                 default = nil)
  if valid_612724 != nil:
    section.add "X-Amz-Content-Sha256", valid_612724
  var valid_612725 = header.getOrDefault("X-Amz-Date")
  valid_612725 = validateParameter(valid_612725, JString, required = false,
                                 default = nil)
  if valid_612725 != nil:
    section.add "X-Amz-Date", valid_612725
  var valid_612726 = header.getOrDefault("X-Amz-Credential")
  valid_612726 = validateParameter(valid_612726, JString, required = false,
                                 default = nil)
  if valid_612726 != nil:
    section.add "X-Amz-Credential", valid_612726
  var valid_612727 = header.getOrDefault("X-Amz-Security-Token")
  valid_612727 = validateParameter(valid_612727, JString, required = false,
                                 default = nil)
  if valid_612727 != nil:
    section.add "X-Amz-Security-Token", valid_612727
  var valid_612728 = header.getOrDefault("X-Amz-Algorithm")
  valid_612728 = validateParameter(valid_612728, JString, required = false,
                                 default = nil)
  if valid_612728 != nil:
    section.add "X-Amz-Algorithm", valid_612728
  var valid_612729 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_612729 = validateParameter(valid_612729, JString, required = false,
                                 default = nil)
  if valid_612729 != nil:
    section.add "X-Amz-SignedHeaders", valid_612729
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_612730: Call_GetDescribeClusterTracks_612715; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns a list of all the available maintenance tracks.
  ## 
  let valid = call_612730.validator(path, query, header, formData, body)
  let scheme = call_612730.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_612730.url(scheme.get, call_612730.host, call_612730.base,
                         call_612730.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_612730, url, valid)

proc call*(call_612731: Call_GetDescribeClusterTracks_612715; Marker: string = "";
          MaintenanceTrackName: string = "";
          Action: string = "DescribeClusterTracks"; Version: string = "2012-12-01";
          MaxRecords: int = 0): Recallable =
  ## getDescribeClusterTracks
  ## Returns a list of all the available maintenance tracks.
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <code>DescribeClusterTracks</code> request exceed the value specified in <code>MaxRecords</code>, Amazon Redshift returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   MaintenanceTrackName: string
  ##                       : The name of the maintenance track. 
  ##   Action: string (required)
  ##   Version: string (required)
  ##   MaxRecords: int
  ##             : An integer value for the maximum number of maintenance tracks to return.
  var query_612732 = newJObject()
  add(query_612732, "Marker", newJString(Marker))
  add(query_612732, "MaintenanceTrackName", newJString(MaintenanceTrackName))
  add(query_612732, "Action", newJString(Action))
  add(query_612732, "Version", newJString(Version))
  add(query_612732, "MaxRecords", newJInt(MaxRecords))
  result = call_612731.call(nil, query_612732, nil, nil, nil)

var getDescribeClusterTracks* = Call_GetDescribeClusterTracks_612715(
    name: "getDescribeClusterTracks", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusterTracks",
    validator: validate_GetDescribeClusterTracks_612716, base: "/",
    url: url_GetDescribeClusterTracks_612717, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeClusterVersions_612771 = ref object of OpenApiRestCall_610642
proc url_PostDescribeClusterVersions_612773(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeClusterVersions_612772(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns descriptions of the available Amazon Redshift cluster versions. You can call this operation even before creating any clusters to learn more about the Amazon Redshift versions. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_612774 = query.getOrDefault("Action")
  valid_612774 = validateParameter(valid_612774, JString, required = true, default = newJString(
      "DescribeClusterVersions"))
  if valid_612774 != nil:
    section.add "Action", valid_612774
  var valid_612775 = query.getOrDefault("Version")
  valid_612775 = validateParameter(valid_612775, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_612775 != nil:
    section.add "Version", valid_612775
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_612776 = header.getOrDefault("X-Amz-Signature")
  valid_612776 = validateParameter(valid_612776, JString, required = false,
                                 default = nil)
  if valid_612776 != nil:
    section.add "X-Amz-Signature", valid_612776
  var valid_612777 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_612777 = validateParameter(valid_612777, JString, required = false,
                                 default = nil)
  if valid_612777 != nil:
    section.add "X-Amz-Content-Sha256", valid_612777
  var valid_612778 = header.getOrDefault("X-Amz-Date")
  valid_612778 = validateParameter(valid_612778, JString, required = false,
                                 default = nil)
  if valid_612778 != nil:
    section.add "X-Amz-Date", valid_612778
  var valid_612779 = header.getOrDefault("X-Amz-Credential")
  valid_612779 = validateParameter(valid_612779, JString, required = false,
                                 default = nil)
  if valid_612779 != nil:
    section.add "X-Amz-Credential", valid_612779
  var valid_612780 = header.getOrDefault("X-Amz-Security-Token")
  valid_612780 = validateParameter(valid_612780, JString, required = false,
                                 default = nil)
  if valid_612780 != nil:
    section.add "X-Amz-Security-Token", valid_612780
  var valid_612781 = header.getOrDefault("X-Amz-Algorithm")
  valid_612781 = validateParameter(valid_612781, JString, required = false,
                                 default = nil)
  if valid_612781 != nil:
    section.add "X-Amz-Algorithm", valid_612781
  var valid_612782 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_612782 = validateParameter(valid_612782, JString, required = false,
                                 default = nil)
  if valid_612782 != nil:
    section.add "X-Amz-SignedHeaders", valid_612782
  result.add "header", section
  ## parameters in `formData` object:
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   ClusterParameterGroupFamily: JString
  ##                              : <p>The name of a specific cluster parameter group family to return details for.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters</p> </li> <li> <p>First character must be a letter</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens</p> </li> </ul>
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterVersions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   ClusterVersion: JString
  ##                 : <p>The specific cluster version to return.</p> <p>Example: <code>1.0</code> </p>
  section = newJObject()
  var valid_612783 = formData.getOrDefault("MaxRecords")
  valid_612783 = validateParameter(valid_612783, JInt, required = false, default = nil)
  if valid_612783 != nil:
    section.add "MaxRecords", valid_612783
  var valid_612784 = formData.getOrDefault("ClusterParameterGroupFamily")
  valid_612784 = validateParameter(valid_612784, JString, required = false,
                                 default = nil)
  if valid_612784 != nil:
    section.add "ClusterParameterGroupFamily", valid_612784
  var valid_612785 = formData.getOrDefault("Marker")
  valid_612785 = validateParameter(valid_612785, JString, required = false,
                                 default = nil)
  if valid_612785 != nil:
    section.add "Marker", valid_612785
  var valid_612786 = formData.getOrDefault("ClusterVersion")
  valid_612786 = validateParameter(valid_612786, JString, required = false,
                                 default = nil)
  if valid_612786 != nil:
    section.add "ClusterVersion", valid_612786
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_612787: Call_PostDescribeClusterVersions_612771; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns descriptions of the available Amazon Redshift cluster versions. You can call this operation even before creating any clusters to learn more about the Amazon Redshift versions. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.
  ## 
  let valid = call_612787.validator(path, query, header, formData, body)
  let scheme = call_612787.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_612787.url(scheme.get, call_612787.host, call_612787.base,
                         call_612787.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_612787, url, valid)

proc call*(call_612788: Call_PostDescribeClusterVersions_612771;
          MaxRecords: int = 0; ClusterParameterGroupFamily: string = "";
          Marker: string = ""; Action: string = "DescribeClusterVersions";
          ClusterVersion: string = ""; Version: string = "2012-12-01"): Recallable =
  ## postDescribeClusterVersions
  ## Returns descriptions of the available Amazon Redshift cluster versions. You can call this operation even before creating any clusters to learn more about the Amazon Redshift versions. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   ClusterParameterGroupFamily: string
  ##                              : <p>The name of a specific cluster parameter group family to return details for.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters</p> </li> <li> <p>First character must be a letter</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens</p> </li> </ul>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterVersions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Action: string (required)
  ##   ClusterVersion: string
  ##                 : <p>The specific cluster version to return.</p> <p>Example: <code>1.0</code> </p>
  ##   Version: string (required)
  var query_612789 = newJObject()
  var formData_612790 = newJObject()
  add(formData_612790, "MaxRecords", newJInt(MaxRecords))
  add(formData_612790, "ClusterParameterGroupFamily",
      newJString(ClusterParameterGroupFamily))
  add(formData_612790, "Marker", newJString(Marker))
  add(query_612789, "Action", newJString(Action))
  add(formData_612790, "ClusterVersion", newJString(ClusterVersion))
  add(query_612789, "Version", newJString(Version))
  result = call_612788.call(nil, query_612789, nil, formData_612790, nil)

var postDescribeClusterVersions* = Call_PostDescribeClusterVersions_612771(
    name: "postDescribeClusterVersions", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusterVersions",
    validator: validate_PostDescribeClusterVersions_612772, base: "/",
    url: url_PostDescribeClusterVersions_612773,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeClusterVersions_612752 = ref object of OpenApiRestCall_610642
proc url_GetDescribeClusterVersions_612754(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeClusterVersions_612753(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns descriptions of the available Amazon Redshift cluster versions. You can call this operation even before creating any clusters to learn more about the Amazon Redshift versions. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterVersions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   ClusterParameterGroupFamily: JString
  ##                              : <p>The name of a specific cluster parameter group family to return details for.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters</p> </li> <li> <p>First character must be a letter</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens</p> </li> </ul>
  ##   ClusterVersion: JString
  ##                 : <p>The specific cluster version to return.</p> <p>Example: <code>1.0</code> </p>
  ##   Action: JString (required)
  ##   Version: JString (required)
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  section = newJObject()
  var valid_612755 = query.getOrDefault("Marker")
  valid_612755 = validateParameter(valid_612755, JString, required = false,
                                 default = nil)
  if valid_612755 != nil:
    section.add "Marker", valid_612755
  var valid_612756 = query.getOrDefault("ClusterParameterGroupFamily")
  valid_612756 = validateParameter(valid_612756, JString, required = false,
                                 default = nil)
  if valid_612756 != nil:
    section.add "ClusterParameterGroupFamily", valid_612756
  var valid_612757 = query.getOrDefault("ClusterVersion")
  valid_612757 = validateParameter(valid_612757, JString, required = false,
                                 default = nil)
  if valid_612757 != nil:
    section.add "ClusterVersion", valid_612757
  var valid_612758 = query.getOrDefault("Action")
  valid_612758 = validateParameter(valid_612758, JString, required = true, default = newJString(
      "DescribeClusterVersions"))
  if valid_612758 != nil:
    section.add "Action", valid_612758
  var valid_612759 = query.getOrDefault("Version")
  valid_612759 = validateParameter(valid_612759, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_612759 != nil:
    section.add "Version", valid_612759
  var valid_612760 = query.getOrDefault("MaxRecords")
  valid_612760 = validateParameter(valid_612760, JInt, required = false, default = nil)
  if valid_612760 != nil:
    section.add "MaxRecords", valid_612760
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_612761 = header.getOrDefault("X-Amz-Signature")
  valid_612761 = validateParameter(valid_612761, JString, required = false,
                                 default = nil)
  if valid_612761 != nil:
    section.add "X-Amz-Signature", valid_612761
  var valid_612762 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_612762 = validateParameter(valid_612762, JString, required = false,
                                 default = nil)
  if valid_612762 != nil:
    section.add "X-Amz-Content-Sha256", valid_612762
  var valid_612763 = header.getOrDefault("X-Amz-Date")
  valid_612763 = validateParameter(valid_612763, JString, required = false,
                                 default = nil)
  if valid_612763 != nil:
    section.add "X-Amz-Date", valid_612763
  var valid_612764 = header.getOrDefault("X-Amz-Credential")
  valid_612764 = validateParameter(valid_612764, JString, required = false,
                                 default = nil)
  if valid_612764 != nil:
    section.add "X-Amz-Credential", valid_612764
  var valid_612765 = header.getOrDefault("X-Amz-Security-Token")
  valid_612765 = validateParameter(valid_612765, JString, required = false,
                                 default = nil)
  if valid_612765 != nil:
    section.add "X-Amz-Security-Token", valid_612765
  var valid_612766 = header.getOrDefault("X-Amz-Algorithm")
  valid_612766 = validateParameter(valid_612766, JString, required = false,
                                 default = nil)
  if valid_612766 != nil:
    section.add "X-Amz-Algorithm", valid_612766
  var valid_612767 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_612767 = validateParameter(valid_612767, JString, required = false,
                                 default = nil)
  if valid_612767 != nil:
    section.add "X-Amz-SignedHeaders", valid_612767
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_612768: Call_GetDescribeClusterVersions_612752; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns descriptions of the available Amazon Redshift cluster versions. You can call this operation even before creating any clusters to learn more about the Amazon Redshift versions. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.
  ## 
  let valid = call_612768.validator(path, query, header, formData, body)
  let scheme = call_612768.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_612768.url(scheme.get, call_612768.host, call_612768.base,
                         call_612768.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_612768, url, valid)

proc call*(call_612769: Call_GetDescribeClusterVersions_612752;
          Marker: string = ""; ClusterParameterGroupFamily: string = "";
          ClusterVersion: string = ""; Action: string = "DescribeClusterVersions";
          Version: string = "2012-12-01"; MaxRecords: int = 0): Recallable =
  ## getDescribeClusterVersions
  ## Returns descriptions of the available Amazon Redshift cluster versions. You can call this operation even before creating any clusters to learn more about the Amazon Redshift versions. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterVersions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   ClusterParameterGroupFamily: string
  ##                              : <p>The name of a specific cluster parameter group family to return details for.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters</p> </li> <li> <p>First character must be a letter</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens</p> </li> </ul>
  ##   ClusterVersion: string
  ##                 : <p>The specific cluster version to return.</p> <p>Example: <code>1.0</code> </p>
  ##   Action: string (required)
  ##   Version: string (required)
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  var query_612770 = newJObject()
  add(query_612770, "Marker", newJString(Marker))
  add(query_612770, "ClusterParameterGroupFamily",
      newJString(ClusterParameterGroupFamily))
  add(query_612770, "ClusterVersion", newJString(ClusterVersion))
  add(query_612770, "Action", newJString(Action))
  add(query_612770, "Version", newJString(Version))
  add(query_612770, "MaxRecords", newJInt(MaxRecords))
  result = call_612769.call(nil, query_612770, nil, nil, nil)

var getDescribeClusterVersions* = Call_GetDescribeClusterVersions_612752(
    name: "getDescribeClusterVersions", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusterVersions",
    validator: validate_GetDescribeClusterVersions_612753, base: "/",
    url: url_GetDescribeClusterVersions_612754,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeClusters_612811 = ref object of OpenApiRestCall_610642
proc url_PostDescribeClusters_612813(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeClusters_612812(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns properties of provisioned clusters including general cluster properties, cluster database properties, maintenance and backup properties, and security and access properties. This operation supports pagination. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all clusters that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all clusters that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, clusters are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_612814 = query.getOrDefault("Action")
  valid_612814 = validateParameter(valid_612814, JString, required = true,
                                 default = newJString("DescribeClusters"))
  if valid_612814 != nil:
    section.add "Action", valid_612814
  var valid_612815 = query.getOrDefault("Version")
  valid_612815 = validateParameter(valid_612815, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_612815 != nil:
    section.add "Version", valid_612815
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_612816 = header.getOrDefault("X-Amz-Signature")
  valid_612816 = validateParameter(valid_612816, JString, required = false,
                                 default = nil)
  if valid_612816 != nil:
    section.add "X-Amz-Signature", valid_612816
  var valid_612817 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_612817 = validateParameter(valid_612817, JString, required = false,
                                 default = nil)
  if valid_612817 != nil:
    section.add "X-Amz-Content-Sha256", valid_612817
  var valid_612818 = header.getOrDefault("X-Amz-Date")
  valid_612818 = validateParameter(valid_612818, JString, required = false,
                                 default = nil)
  if valid_612818 != nil:
    section.add "X-Amz-Date", valid_612818
  var valid_612819 = header.getOrDefault("X-Amz-Credential")
  valid_612819 = validateParameter(valid_612819, JString, required = false,
                                 default = nil)
  if valid_612819 != nil:
    section.add "X-Amz-Credential", valid_612819
  var valid_612820 = header.getOrDefault("X-Amz-Security-Token")
  valid_612820 = validateParameter(valid_612820, JString, required = false,
                                 default = nil)
  if valid_612820 != nil:
    section.add "X-Amz-Security-Token", valid_612820
  var valid_612821 = header.getOrDefault("X-Amz-Algorithm")
  valid_612821 = validateParameter(valid_612821, JString, required = false,
                                 default = nil)
  if valid_612821 != nil:
    section.add "X-Amz-Algorithm", valid_612821
  var valid_612822 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_612822 = validateParameter(valid_612822, JString, required = false,
                                 default = nil)
  if valid_612822 != nil:
    section.add "X-Amz-SignedHeaders", valid_612822
  result.add "header", section
  ## parameters in `formData` object:
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching clusters that are associated with the specified key or keys. For example, suppose that you have clusters that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the clusters that have either or both of these tag keys associated with them.
  ##   ClusterIdentifier: JString
  ##                    : <p>The unique identifier of a cluster whose properties you are requesting. This parameter is case sensitive.</p> <p>The default is that all clusters defined for an account are returned.</p>
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: JString
  ##         : <p>An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusters</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <b>ClusterIdentifier</b> parameter or the <b>Marker</b> parameter, but not both. </p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching clusters that are associated with the specified tag value or values. For example, suppose that you have clusters that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the clusters that have either or both of these tag values associated with them.
  section = newJObject()
  var valid_612823 = formData.getOrDefault("TagKeys")
  valid_612823 = validateParameter(valid_612823, JArray, required = false,
                                 default = nil)
  if valid_612823 != nil:
    section.add "TagKeys", valid_612823
  var valid_612824 = formData.getOrDefault("ClusterIdentifier")
  valid_612824 = validateParameter(valid_612824, JString, required = false,
                                 default = nil)
  if valid_612824 != nil:
    section.add "ClusterIdentifier", valid_612824
  var valid_612825 = formData.getOrDefault("MaxRecords")
  valid_612825 = validateParameter(valid_612825, JInt, required = false, default = nil)
  if valid_612825 != nil:
    section.add "MaxRecords", valid_612825
  var valid_612826 = formData.getOrDefault("Marker")
  valid_612826 = validateParameter(valid_612826, JString, required = false,
                                 default = nil)
  if valid_612826 != nil:
    section.add "Marker", valid_612826
  var valid_612827 = formData.getOrDefault("TagValues")
  valid_612827 = validateParameter(valid_612827, JArray, required = false,
                                 default = nil)
  if valid_612827 != nil:
    section.add "TagValues", valid_612827
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_612828: Call_PostDescribeClusters_612811; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns properties of provisioned clusters including general cluster properties, cluster database properties, maintenance and backup properties, and security and access properties. This operation supports pagination. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all clusters that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all clusters that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, clusters are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_612828.validator(path, query, header, formData, body)
  let scheme = call_612828.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_612828.url(scheme.get, call_612828.host, call_612828.base,
                         call_612828.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_612828, url, valid)

proc call*(call_612829: Call_PostDescribeClusters_612811; TagKeys: JsonNode = nil;
          ClusterIdentifier: string = ""; MaxRecords: int = 0; Marker: string = "";
          TagValues: JsonNode = nil; Action: string = "DescribeClusters";
          Version: string = "2012-12-01"): Recallable =
  ## postDescribeClusters
  ## <p>Returns properties of provisioned clusters including general cluster properties, cluster database properties, maintenance and backup properties, and security and access properties. This operation supports pagination. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all clusters that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all clusters that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, clusters are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching clusters that are associated with the specified key or keys. For example, suppose that you have clusters that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the clusters that have either or both of these tag keys associated with them.
  ##   ClusterIdentifier: string
  ##                    : <p>The unique identifier of a cluster whose properties you are requesting. This parameter is case sensitive.</p> <p>The default is that all clusters defined for an account are returned.</p>
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: string
  ##         : <p>An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusters</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <b>ClusterIdentifier</b> parameter or the <b>Marker</b> parameter, but not both. </p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching clusters that are associated with the specified tag value or values. For example, suppose that you have clusters that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the clusters that have either or both of these tag values associated with them.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_612830 = newJObject()
  var formData_612831 = newJObject()
  if TagKeys != nil:
    formData_612831.add "TagKeys", TagKeys
  add(formData_612831, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_612831, "MaxRecords", newJInt(MaxRecords))
  add(formData_612831, "Marker", newJString(Marker))
  if TagValues != nil:
    formData_612831.add "TagValues", TagValues
  add(query_612830, "Action", newJString(Action))
  add(query_612830, "Version", newJString(Version))
  result = call_612829.call(nil, query_612830, nil, formData_612831, nil)

var postDescribeClusters* = Call_PostDescribeClusters_612811(
    name: "postDescribeClusters", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusters",
    validator: validate_PostDescribeClusters_612812, base: "/",
    url: url_PostDescribeClusters_612813, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeClusters_612791 = ref object of OpenApiRestCall_610642
proc url_GetDescribeClusters_612793(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeClusters_612792(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## <p>Returns properties of provisioned clusters including general cluster properties, cluster database properties, maintenance and backup properties, and security and access properties. This operation supports pagination. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all clusters that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all clusters that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, clusters are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Marker: JString
  ##         : <p>An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusters</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <b>ClusterIdentifier</b> parameter or the <b>Marker</b> parameter, but not both. </p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching clusters that are associated with the specified key or keys. For example, suppose that you have clusters that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the clusters that have either or both of these tag keys associated with them.
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString
  ##                    : <p>The unique identifier of a cluster whose properties you are requesting. This parameter is case sensitive.</p> <p>The default is that all clusters defined for an account are returned.</p>
  ##   Version: JString (required)
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching clusters that are associated with the specified tag value or values. For example, suppose that you have clusters that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the clusters that have either or both of these tag values associated with them.
  section = newJObject()
  var valid_612794 = query.getOrDefault("Marker")
  valid_612794 = validateParameter(valid_612794, JString, required = false,
                                 default = nil)
  if valid_612794 != nil:
    section.add "Marker", valid_612794
  var valid_612795 = query.getOrDefault("TagKeys")
  valid_612795 = validateParameter(valid_612795, JArray, required = false,
                                 default = nil)
  if valid_612795 != nil:
    section.add "TagKeys", valid_612795
  var valid_612796 = query.getOrDefault("Action")
  valid_612796 = validateParameter(valid_612796, JString, required = true,
                                 default = newJString("DescribeClusters"))
  if valid_612796 != nil:
    section.add "Action", valid_612796
  var valid_612797 = query.getOrDefault("ClusterIdentifier")
  valid_612797 = validateParameter(valid_612797, JString, required = false,
                                 default = nil)
  if valid_612797 != nil:
    section.add "ClusterIdentifier", valid_612797
  var valid_612798 = query.getOrDefault("Version")
  valid_612798 = validateParameter(valid_612798, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_612798 != nil:
    section.add "Version", valid_612798
  var valid_612799 = query.getOrDefault("MaxRecords")
  valid_612799 = validateParameter(valid_612799, JInt, required = false, default = nil)
  if valid_612799 != nil:
    section.add "MaxRecords", valid_612799
  var valid_612800 = query.getOrDefault("TagValues")
  valid_612800 = validateParameter(valid_612800, JArray, required = false,
                                 default = nil)
  if valid_612800 != nil:
    section.add "TagValues", valid_612800
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_612801 = header.getOrDefault("X-Amz-Signature")
  valid_612801 = validateParameter(valid_612801, JString, required = false,
                                 default = nil)
  if valid_612801 != nil:
    section.add "X-Amz-Signature", valid_612801
  var valid_612802 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_612802 = validateParameter(valid_612802, JString, required = false,
                                 default = nil)
  if valid_612802 != nil:
    section.add "X-Amz-Content-Sha256", valid_612802
  var valid_612803 = header.getOrDefault("X-Amz-Date")
  valid_612803 = validateParameter(valid_612803, JString, required = false,
                                 default = nil)
  if valid_612803 != nil:
    section.add "X-Amz-Date", valid_612803
  var valid_612804 = header.getOrDefault("X-Amz-Credential")
  valid_612804 = validateParameter(valid_612804, JString, required = false,
                                 default = nil)
  if valid_612804 != nil:
    section.add "X-Amz-Credential", valid_612804
  var valid_612805 = header.getOrDefault("X-Amz-Security-Token")
  valid_612805 = validateParameter(valid_612805, JString, required = false,
                                 default = nil)
  if valid_612805 != nil:
    section.add "X-Amz-Security-Token", valid_612805
  var valid_612806 = header.getOrDefault("X-Amz-Algorithm")
  valid_612806 = validateParameter(valid_612806, JString, required = false,
                                 default = nil)
  if valid_612806 != nil:
    section.add "X-Amz-Algorithm", valid_612806
  var valid_612807 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_612807 = validateParameter(valid_612807, JString, required = false,
                                 default = nil)
  if valid_612807 != nil:
    section.add "X-Amz-SignedHeaders", valid_612807
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_612808: Call_GetDescribeClusters_612791; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns properties of provisioned clusters including general cluster properties, cluster database properties, maintenance and backup properties, and security and access properties. This operation supports pagination. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all clusters that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all clusters that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, clusters are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_612808.validator(path, query, header, formData, body)
  let scheme = call_612808.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_612808.url(scheme.get, call_612808.host, call_612808.base,
                         call_612808.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_612808, url, valid)

proc call*(call_612809: Call_GetDescribeClusters_612791; Marker: string = "";
          TagKeys: JsonNode = nil; Action: string = "DescribeClusters";
          ClusterIdentifier: string = ""; Version: string = "2012-12-01";
          MaxRecords: int = 0; TagValues: JsonNode = nil): Recallable =
  ## getDescribeClusters
  ## <p>Returns properties of provisioned clusters including general cluster properties, cluster database properties, maintenance and backup properties, and security and access properties. This operation supports pagination. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all clusters that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all clusters that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, clusters are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   Marker: string
  ##         : <p>An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusters</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <b>ClusterIdentifier</b> parameter or the <b>Marker</b> parameter, but not both. </p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching clusters that are associated with the specified key or keys. For example, suppose that you have clusters that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the clusters that have either or both of these tag keys associated with them.
  ##   Action: string (required)
  ##   ClusterIdentifier: string
  ##                    : <p>The unique identifier of a cluster whose properties you are requesting. This parameter is case sensitive.</p> <p>The default is that all clusters defined for an account are returned.</p>
  ##   Version: string (required)
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching clusters that are associated with the specified tag value or values. For example, suppose that you have clusters that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the clusters that have either or both of these tag values associated with them.
  var query_612810 = newJObject()
  add(query_612810, "Marker", newJString(Marker))
  if TagKeys != nil:
    query_612810.add "TagKeys", TagKeys
  add(query_612810, "Action", newJString(Action))
  add(query_612810, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_612810, "Version", newJString(Version))
  add(query_612810, "MaxRecords", newJInt(MaxRecords))
  if TagValues != nil:
    query_612810.add "TagValues", TagValues
  result = call_612809.call(nil, query_612810, nil, nil, nil)

var getDescribeClusters* = Call_GetDescribeClusters_612791(
    name: "getDescribeClusters", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusters",
    validator: validate_GetDescribeClusters_612792, base: "/",
    url: url_GetDescribeClusters_612793, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeDefaultClusterParameters_612850 = ref object of OpenApiRestCall_610642
proc url_PostDescribeDefaultClusterParameters_612852(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeDefaultClusterParameters_612851(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns a list of parameter settings for the specified parameter group family.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_612853 = query.getOrDefault("Action")
  valid_612853 = validateParameter(valid_612853, JString, required = true, default = newJString(
      "DescribeDefaultClusterParameters"))
  if valid_612853 != nil:
    section.add "Action", valid_612853
  var valid_612854 = query.getOrDefault("Version")
  valid_612854 = validateParameter(valid_612854, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_612854 != nil:
    section.add "Version", valid_612854
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_612855 = header.getOrDefault("X-Amz-Signature")
  valid_612855 = validateParameter(valid_612855, JString, required = false,
                                 default = nil)
  if valid_612855 != nil:
    section.add "X-Amz-Signature", valid_612855
  var valid_612856 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_612856 = validateParameter(valid_612856, JString, required = false,
                                 default = nil)
  if valid_612856 != nil:
    section.add "X-Amz-Content-Sha256", valid_612856
  var valid_612857 = header.getOrDefault("X-Amz-Date")
  valid_612857 = validateParameter(valid_612857, JString, required = false,
                                 default = nil)
  if valid_612857 != nil:
    section.add "X-Amz-Date", valid_612857
  var valid_612858 = header.getOrDefault("X-Amz-Credential")
  valid_612858 = validateParameter(valid_612858, JString, required = false,
                                 default = nil)
  if valid_612858 != nil:
    section.add "X-Amz-Credential", valid_612858
  var valid_612859 = header.getOrDefault("X-Amz-Security-Token")
  valid_612859 = validateParameter(valid_612859, JString, required = false,
                                 default = nil)
  if valid_612859 != nil:
    section.add "X-Amz-Security-Token", valid_612859
  var valid_612860 = header.getOrDefault("X-Amz-Algorithm")
  valid_612860 = validateParameter(valid_612860, JString, required = false,
                                 default = nil)
  if valid_612860 != nil:
    section.add "X-Amz-Algorithm", valid_612860
  var valid_612861 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_612861 = validateParameter(valid_612861, JString, required = false,
                                 default = nil)
  if valid_612861 != nil:
    section.add "X-Amz-SignedHeaders", valid_612861
  result.add "header", section
  ## parameters in `formData` object:
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeDefaultClusterParameters</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   ParameterGroupFamily: JString (required)
  ##                       : The name of the cluster parameter group family.
  section = newJObject()
  var valid_612862 = formData.getOrDefault("MaxRecords")
  valid_612862 = validateParameter(valid_612862, JInt, required = false, default = nil)
  if valid_612862 != nil:
    section.add "MaxRecords", valid_612862
  var valid_612863 = formData.getOrDefault("Marker")
  valid_612863 = validateParameter(valid_612863, JString, required = false,
                                 default = nil)
  if valid_612863 != nil:
    section.add "Marker", valid_612863
  assert formData != nil, "formData argument is necessary due to required `ParameterGroupFamily` field"
  var valid_612864 = formData.getOrDefault("ParameterGroupFamily")
  valid_612864 = validateParameter(valid_612864, JString, required = true,
                                 default = nil)
  if valid_612864 != nil:
    section.add "ParameterGroupFamily", valid_612864
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_612865: Call_PostDescribeDefaultClusterParameters_612850;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Returns a list of parameter settings for the specified parameter group family.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_612865.validator(path, query, header, formData, body)
  let scheme = call_612865.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_612865.url(scheme.get, call_612865.host, call_612865.base,
                         call_612865.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_612865, url, valid)

proc call*(call_612866: Call_PostDescribeDefaultClusterParameters_612850;
          ParameterGroupFamily: string; MaxRecords: int = 0; Marker: string = "";
          Action: string = "DescribeDefaultClusterParameters";
          Version: string = "2012-12-01"): Recallable =
  ## postDescribeDefaultClusterParameters
  ## <p>Returns a list of parameter settings for the specified parameter group family.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeDefaultClusterParameters</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   ParameterGroupFamily: string (required)
  ##                       : The name of the cluster parameter group family.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_612867 = newJObject()
  var formData_612868 = newJObject()
  add(formData_612868, "MaxRecords", newJInt(MaxRecords))
  add(formData_612868, "Marker", newJString(Marker))
  add(formData_612868, "ParameterGroupFamily", newJString(ParameterGroupFamily))
  add(query_612867, "Action", newJString(Action))
  add(query_612867, "Version", newJString(Version))
  result = call_612866.call(nil, query_612867, nil, formData_612868, nil)

var postDescribeDefaultClusterParameters* = Call_PostDescribeDefaultClusterParameters_612850(
    name: "postDescribeDefaultClusterParameters", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeDefaultClusterParameters",
    validator: validate_PostDescribeDefaultClusterParameters_612851, base: "/",
    url: url_PostDescribeDefaultClusterParameters_612852,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeDefaultClusterParameters_612832 = ref object of OpenApiRestCall_610642
proc url_GetDescribeDefaultClusterParameters_612834(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeDefaultClusterParameters_612833(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns a list of parameter settings for the specified parameter group family.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeDefaultClusterParameters</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   ParameterGroupFamily: JString (required)
  ##                       : The name of the cluster parameter group family.
  ##   Action: JString (required)
  ##   Version: JString (required)
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  section = newJObject()
  var valid_612835 = query.getOrDefault("Marker")
  valid_612835 = validateParameter(valid_612835, JString, required = false,
                                 default = nil)
  if valid_612835 != nil:
    section.add "Marker", valid_612835
  assert query != nil, "query argument is necessary due to required `ParameterGroupFamily` field"
  var valid_612836 = query.getOrDefault("ParameterGroupFamily")
  valid_612836 = validateParameter(valid_612836, JString, required = true,
                                 default = nil)
  if valid_612836 != nil:
    section.add "ParameterGroupFamily", valid_612836
  var valid_612837 = query.getOrDefault("Action")
  valid_612837 = validateParameter(valid_612837, JString, required = true, default = newJString(
      "DescribeDefaultClusterParameters"))
  if valid_612837 != nil:
    section.add "Action", valid_612837
  var valid_612838 = query.getOrDefault("Version")
  valid_612838 = validateParameter(valid_612838, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_612838 != nil:
    section.add "Version", valid_612838
  var valid_612839 = query.getOrDefault("MaxRecords")
  valid_612839 = validateParameter(valid_612839, JInt, required = false, default = nil)
  if valid_612839 != nil:
    section.add "MaxRecords", valid_612839
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_612840 = header.getOrDefault("X-Amz-Signature")
  valid_612840 = validateParameter(valid_612840, JString, required = false,
                                 default = nil)
  if valid_612840 != nil:
    section.add "X-Amz-Signature", valid_612840
  var valid_612841 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_612841 = validateParameter(valid_612841, JString, required = false,
                                 default = nil)
  if valid_612841 != nil:
    section.add "X-Amz-Content-Sha256", valid_612841
  var valid_612842 = header.getOrDefault("X-Amz-Date")
  valid_612842 = validateParameter(valid_612842, JString, required = false,
                                 default = nil)
  if valid_612842 != nil:
    section.add "X-Amz-Date", valid_612842
  var valid_612843 = header.getOrDefault("X-Amz-Credential")
  valid_612843 = validateParameter(valid_612843, JString, required = false,
                                 default = nil)
  if valid_612843 != nil:
    section.add "X-Amz-Credential", valid_612843
  var valid_612844 = header.getOrDefault("X-Amz-Security-Token")
  valid_612844 = validateParameter(valid_612844, JString, required = false,
                                 default = nil)
  if valid_612844 != nil:
    section.add "X-Amz-Security-Token", valid_612844
  var valid_612845 = header.getOrDefault("X-Amz-Algorithm")
  valid_612845 = validateParameter(valid_612845, JString, required = false,
                                 default = nil)
  if valid_612845 != nil:
    section.add "X-Amz-Algorithm", valid_612845
  var valid_612846 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_612846 = validateParameter(valid_612846, JString, required = false,
                                 default = nil)
  if valid_612846 != nil:
    section.add "X-Amz-SignedHeaders", valid_612846
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_612847: Call_GetDescribeDefaultClusterParameters_612832;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Returns a list of parameter settings for the specified parameter group family.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_612847.validator(path, query, header, formData, body)
  let scheme = call_612847.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_612847.url(scheme.get, call_612847.host, call_612847.base,
                         call_612847.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_612847, url, valid)

proc call*(call_612848: Call_GetDescribeDefaultClusterParameters_612832;
          ParameterGroupFamily: string; Marker: string = "";
          Action: string = "DescribeDefaultClusterParameters";
          Version: string = "2012-12-01"; MaxRecords: int = 0): Recallable =
  ## getDescribeDefaultClusterParameters
  ## <p>Returns a list of parameter settings for the specified parameter group family.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeDefaultClusterParameters</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   ParameterGroupFamily: string (required)
  ##                       : The name of the cluster parameter group family.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  var query_612849 = newJObject()
  add(query_612849, "Marker", newJString(Marker))
  add(query_612849, "ParameterGroupFamily", newJString(ParameterGroupFamily))
  add(query_612849, "Action", newJString(Action))
  add(query_612849, "Version", newJString(Version))
  add(query_612849, "MaxRecords", newJInt(MaxRecords))
  result = call_612848.call(nil, query_612849, nil, nil, nil)

var getDescribeDefaultClusterParameters* = Call_GetDescribeDefaultClusterParameters_612832(
    name: "getDescribeDefaultClusterParameters", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeDefaultClusterParameters",
    validator: validate_GetDescribeDefaultClusterParameters_612833, base: "/",
    url: url_GetDescribeDefaultClusterParameters_612834,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeEventCategories_612885 = ref object of OpenApiRestCall_610642
proc url_PostDescribeEventCategories_612887(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeEventCategories_612886(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Displays a list of event categories for all event source types, or for a specified source type. For a list of the event categories and source types, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-event-notifications.html">Amazon Redshift Event Notifications</a>.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_612888 = query.getOrDefault("Action")
  valid_612888 = validateParameter(valid_612888, JString, required = true, default = newJString(
      "DescribeEventCategories"))
  if valid_612888 != nil:
    section.add "Action", valid_612888
  var valid_612889 = query.getOrDefault("Version")
  valid_612889 = validateParameter(valid_612889, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_612889 != nil:
    section.add "Version", valid_612889
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_612890 = header.getOrDefault("X-Amz-Signature")
  valid_612890 = validateParameter(valid_612890, JString, required = false,
                                 default = nil)
  if valid_612890 != nil:
    section.add "X-Amz-Signature", valid_612890
  var valid_612891 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_612891 = validateParameter(valid_612891, JString, required = false,
                                 default = nil)
  if valid_612891 != nil:
    section.add "X-Amz-Content-Sha256", valid_612891
  var valid_612892 = header.getOrDefault("X-Amz-Date")
  valid_612892 = validateParameter(valid_612892, JString, required = false,
                                 default = nil)
  if valid_612892 != nil:
    section.add "X-Amz-Date", valid_612892
  var valid_612893 = header.getOrDefault("X-Amz-Credential")
  valid_612893 = validateParameter(valid_612893, JString, required = false,
                                 default = nil)
  if valid_612893 != nil:
    section.add "X-Amz-Credential", valid_612893
  var valid_612894 = header.getOrDefault("X-Amz-Security-Token")
  valid_612894 = validateParameter(valid_612894, JString, required = false,
                                 default = nil)
  if valid_612894 != nil:
    section.add "X-Amz-Security-Token", valid_612894
  var valid_612895 = header.getOrDefault("X-Amz-Algorithm")
  valid_612895 = validateParameter(valid_612895, JString, required = false,
                                 default = nil)
  if valid_612895 != nil:
    section.add "X-Amz-Algorithm", valid_612895
  var valid_612896 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_612896 = validateParameter(valid_612896, JString, required = false,
                                 default = nil)
  if valid_612896 != nil:
    section.add "X-Amz-SignedHeaders", valid_612896
  result.add "header", section
  ## parameters in `formData` object:
  ##   SourceType: JString
  ##             : <p>The source type, such as cluster or parameter group, to which the described event categories apply.</p> <p>Valid values: cluster, cluster-snapshot, cluster-parameter-group, cluster-security-group, and scheduled-action.</p>
  section = newJObject()
  var valid_612897 = formData.getOrDefault("SourceType")
  valid_612897 = validateParameter(valid_612897, JString, required = false,
                                 default = nil)
  if valid_612897 != nil:
    section.add "SourceType", valid_612897
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_612898: Call_PostDescribeEventCategories_612885; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Displays a list of event categories for all event source types, or for a specified source type. For a list of the event categories and source types, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-event-notifications.html">Amazon Redshift Event Notifications</a>.
  ## 
  let valid = call_612898.validator(path, query, header, formData, body)
  let scheme = call_612898.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_612898.url(scheme.get, call_612898.host, call_612898.base,
                         call_612898.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_612898, url, valid)

proc call*(call_612899: Call_PostDescribeEventCategories_612885;
          SourceType: string = ""; Action: string = "DescribeEventCategories";
          Version: string = "2012-12-01"): Recallable =
  ## postDescribeEventCategories
  ## Displays a list of event categories for all event source types, or for a specified source type. For a list of the event categories and source types, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-event-notifications.html">Amazon Redshift Event Notifications</a>.
  ##   SourceType: string
  ##             : <p>The source type, such as cluster or parameter group, to which the described event categories apply.</p> <p>Valid values: cluster, cluster-snapshot, cluster-parameter-group, cluster-security-group, and scheduled-action.</p>
  ##   Action: string (required)
  ##   Version: string (required)
  var query_612900 = newJObject()
  var formData_612901 = newJObject()
  add(formData_612901, "SourceType", newJString(SourceType))
  add(query_612900, "Action", newJString(Action))
  add(query_612900, "Version", newJString(Version))
  result = call_612899.call(nil, query_612900, nil, formData_612901, nil)

var postDescribeEventCategories* = Call_PostDescribeEventCategories_612885(
    name: "postDescribeEventCategories", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeEventCategories",
    validator: validate_PostDescribeEventCategories_612886, base: "/",
    url: url_PostDescribeEventCategories_612887,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeEventCategories_612869 = ref object of OpenApiRestCall_610642
proc url_GetDescribeEventCategories_612871(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeEventCategories_612870(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Displays a list of event categories for all event source types, or for a specified source type. For a list of the event categories and source types, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-event-notifications.html">Amazon Redshift Event Notifications</a>.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   SourceType: JString
  ##             : <p>The source type, such as cluster or parameter group, to which the described event categories apply.</p> <p>Valid values: cluster, cluster-snapshot, cluster-parameter-group, cluster-security-group, and scheduled-action.</p>
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_612872 = query.getOrDefault("SourceType")
  valid_612872 = validateParameter(valid_612872, JString, required = false,
                                 default = nil)
  if valid_612872 != nil:
    section.add "SourceType", valid_612872
  var valid_612873 = query.getOrDefault("Action")
  valid_612873 = validateParameter(valid_612873, JString, required = true, default = newJString(
      "DescribeEventCategories"))
  if valid_612873 != nil:
    section.add "Action", valid_612873
  var valid_612874 = query.getOrDefault("Version")
  valid_612874 = validateParameter(valid_612874, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_612874 != nil:
    section.add "Version", valid_612874
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_612875 = header.getOrDefault("X-Amz-Signature")
  valid_612875 = validateParameter(valid_612875, JString, required = false,
                                 default = nil)
  if valid_612875 != nil:
    section.add "X-Amz-Signature", valid_612875
  var valid_612876 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_612876 = validateParameter(valid_612876, JString, required = false,
                                 default = nil)
  if valid_612876 != nil:
    section.add "X-Amz-Content-Sha256", valid_612876
  var valid_612877 = header.getOrDefault("X-Amz-Date")
  valid_612877 = validateParameter(valid_612877, JString, required = false,
                                 default = nil)
  if valid_612877 != nil:
    section.add "X-Amz-Date", valid_612877
  var valid_612878 = header.getOrDefault("X-Amz-Credential")
  valid_612878 = validateParameter(valid_612878, JString, required = false,
                                 default = nil)
  if valid_612878 != nil:
    section.add "X-Amz-Credential", valid_612878
  var valid_612879 = header.getOrDefault("X-Amz-Security-Token")
  valid_612879 = validateParameter(valid_612879, JString, required = false,
                                 default = nil)
  if valid_612879 != nil:
    section.add "X-Amz-Security-Token", valid_612879
  var valid_612880 = header.getOrDefault("X-Amz-Algorithm")
  valid_612880 = validateParameter(valid_612880, JString, required = false,
                                 default = nil)
  if valid_612880 != nil:
    section.add "X-Amz-Algorithm", valid_612880
  var valid_612881 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_612881 = validateParameter(valid_612881, JString, required = false,
                                 default = nil)
  if valid_612881 != nil:
    section.add "X-Amz-SignedHeaders", valid_612881
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_612882: Call_GetDescribeEventCategories_612869; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Displays a list of event categories for all event source types, or for a specified source type. For a list of the event categories and source types, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-event-notifications.html">Amazon Redshift Event Notifications</a>.
  ## 
  let valid = call_612882.validator(path, query, header, formData, body)
  let scheme = call_612882.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_612882.url(scheme.get, call_612882.host, call_612882.base,
                         call_612882.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_612882, url, valid)

proc call*(call_612883: Call_GetDescribeEventCategories_612869;
          SourceType: string = ""; Action: string = "DescribeEventCategories";
          Version: string = "2012-12-01"): Recallable =
  ## getDescribeEventCategories
  ## Displays a list of event categories for all event source types, or for a specified source type. For a list of the event categories and source types, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-event-notifications.html">Amazon Redshift Event Notifications</a>.
  ##   SourceType: string
  ##             : <p>The source type, such as cluster or parameter group, to which the described event categories apply.</p> <p>Valid values: cluster, cluster-snapshot, cluster-parameter-group, cluster-security-group, and scheduled-action.</p>
  ##   Action: string (required)
  ##   Version: string (required)
  var query_612884 = newJObject()
  add(query_612884, "SourceType", newJString(SourceType))
  add(query_612884, "Action", newJString(Action))
  add(query_612884, "Version", newJString(Version))
  result = call_612883.call(nil, query_612884, nil, nil, nil)

var getDescribeEventCategories* = Call_GetDescribeEventCategories_612869(
    name: "getDescribeEventCategories", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeEventCategories",
    validator: validate_GetDescribeEventCategories_612870, base: "/",
    url: url_GetDescribeEventCategories_612871,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeEventSubscriptions_612922 = ref object of OpenApiRestCall_610642
proc url_PostDescribeEventSubscriptions_612924(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeEventSubscriptions_612923(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Lists descriptions of all the Amazon Redshift event notification subscriptions for a customer account. If you specify a subscription name, lists the description for that subscription.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all event notification subscriptions that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all subscriptions that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, subscriptions are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_612925 = query.getOrDefault("Action")
  valid_612925 = validateParameter(valid_612925, JString, required = true, default = newJString(
      "DescribeEventSubscriptions"))
  if valid_612925 != nil:
    section.add "Action", valid_612925
  var valid_612926 = query.getOrDefault("Version")
  valid_612926 = validateParameter(valid_612926, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_612926 != nil:
    section.add "Version", valid_612926
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_612927 = header.getOrDefault("X-Amz-Signature")
  valid_612927 = validateParameter(valid_612927, JString, required = false,
                                 default = nil)
  if valid_612927 != nil:
    section.add "X-Amz-Signature", valid_612927
  var valid_612928 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_612928 = validateParameter(valid_612928, JString, required = false,
                                 default = nil)
  if valid_612928 != nil:
    section.add "X-Amz-Content-Sha256", valid_612928
  var valid_612929 = header.getOrDefault("X-Amz-Date")
  valid_612929 = validateParameter(valid_612929, JString, required = false,
                                 default = nil)
  if valid_612929 != nil:
    section.add "X-Amz-Date", valid_612929
  var valid_612930 = header.getOrDefault("X-Amz-Credential")
  valid_612930 = validateParameter(valid_612930, JString, required = false,
                                 default = nil)
  if valid_612930 != nil:
    section.add "X-Amz-Credential", valid_612930
  var valid_612931 = header.getOrDefault("X-Amz-Security-Token")
  valid_612931 = validateParameter(valid_612931, JString, required = false,
                                 default = nil)
  if valid_612931 != nil:
    section.add "X-Amz-Security-Token", valid_612931
  var valid_612932 = header.getOrDefault("X-Amz-Algorithm")
  valid_612932 = validateParameter(valid_612932, JString, required = false,
                                 default = nil)
  if valid_612932 != nil:
    section.add "X-Amz-Algorithm", valid_612932
  var valid_612933 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_612933 = validateParameter(valid_612933, JString, required = false,
                                 default = nil)
  if valid_612933 != nil:
    section.add "X-Amz-SignedHeaders", valid_612933
  result.add "header", section
  ## parameters in `formData` object:
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching event notification subscriptions that are associated with the specified key or keys. For example, suppose that you have subscriptions that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the subscriptions that have either or both of these tag keys associated with them.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a DescribeEventSubscriptions request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   SubscriptionName: JString
  ##                   : The name of the Amazon Redshift event notification subscription to be described.
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching event notification subscriptions that are associated with the specified tag value or values. For example, suppose that you have subscriptions that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the subscriptions that have either or both of these tag values associated with them.
  section = newJObject()
  var valid_612934 = formData.getOrDefault("TagKeys")
  valid_612934 = validateParameter(valid_612934, JArray, required = false,
                                 default = nil)
  if valid_612934 != nil:
    section.add "TagKeys", valid_612934
  var valid_612935 = formData.getOrDefault("MaxRecords")
  valid_612935 = validateParameter(valid_612935, JInt, required = false, default = nil)
  if valid_612935 != nil:
    section.add "MaxRecords", valid_612935
  var valid_612936 = formData.getOrDefault("Marker")
  valid_612936 = validateParameter(valid_612936, JString, required = false,
                                 default = nil)
  if valid_612936 != nil:
    section.add "Marker", valid_612936
  var valid_612937 = formData.getOrDefault("SubscriptionName")
  valid_612937 = validateParameter(valid_612937, JString, required = false,
                                 default = nil)
  if valid_612937 != nil:
    section.add "SubscriptionName", valid_612937
  var valid_612938 = formData.getOrDefault("TagValues")
  valid_612938 = validateParameter(valid_612938, JArray, required = false,
                                 default = nil)
  if valid_612938 != nil:
    section.add "TagValues", valid_612938
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_612939: Call_PostDescribeEventSubscriptions_612922; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Lists descriptions of all the Amazon Redshift event notification subscriptions for a customer account. If you specify a subscription name, lists the description for that subscription.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all event notification subscriptions that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all subscriptions that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, subscriptions are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_612939.validator(path, query, header, formData, body)
  let scheme = call_612939.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_612939.url(scheme.get, call_612939.host, call_612939.base,
                         call_612939.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_612939, url, valid)

proc call*(call_612940: Call_PostDescribeEventSubscriptions_612922;
          TagKeys: JsonNode = nil; MaxRecords: int = 0; Marker: string = "";
          SubscriptionName: string = ""; TagValues: JsonNode = nil;
          Action: string = "DescribeEventSubscriptions";
          Version: string = "2012-12-01"): Recallable =
  ## postDescribeEventSubscriptions
  ## <p>Lists descriptions of all the Amazon Redshift event notification subscriptions for a customer account. If you specify a subscription name, lists the description for that subscription.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all event notification subscriptions that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all subscriptions that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, subscriptions are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching event notification subscriptions that are associated with the specified key or keys. For example, suppose that you have subscriptions that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the subscriptions that have either or both of these tag keys associated with them.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a DescribeEventSubscriptions request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   SubscriptionName: string
  ##                   : The name of the Amazon Redshift event notification subscription to be described.
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching event notification subscriptions that are associated with the specified tag value or values. For example, suppose that you have subscriptions that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the subscriptions that have either or both of these tag values associated with them.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_612941 = newJObject()
  var formData_612942 = newJObject()
  if TagKeys != nil:
    formData_612942.add "TagKeys", TagKeys
  add(formData_612942, "MaxRecords", newJInt(MaxRecords))
  add(formData_612942, "Marker", newJString(Marker))
  add(formData_612942, "SubscriptionName", newJString(SubscriptionName))
  if TagValues != nil:
    formData_612942.add "TagValues", TagValues
  add(query_612941, "Action", newJString(Action))
  add(query_612941, "Version", newJString(Version))
  result = call_612940.call(nil, query_612941, nil, formData_612942, nil)

var postDescribeEventSubscriptions* = Call_PostDescribeEventSubscriptions_612922(
    name: "postDescribeEventSubscriptions", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeEventSubscriptions",
    validator: validate_PostDescribeEventSubscriptions_612923, base: "/",
    url: url_PostDescribeEventSubscriptions_612924,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeEventSubscriptions_612902 = ref object of OpenApiRestCall_610642
proc url_GetDescribeEventSubscriptions_612904(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeEventSubscriptions_612903(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Lists descriptions of all the Amazon Redshift event notification subscriptions for a customer account. If you specify a subscription name, lists the description for that subscription.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all event notification subscriptions that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all subscriptions that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, subscriptions are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a DescribeEventSubscriptions request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching event notification subscriptions that are associated with the specified key or keys. For example, suppose that you have subscriptions that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the subscriptions that have either or both of these tag keys associated with them.
  ##   SubscriptionName: JString
  ##                   : The name of the Amazon Redshift event notification subscription to be described.
  ##   Action: JString (required)
  ##   Version: JString (required)
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching event notification subscriptions that are associated with the specified tag value or values. For example, suppose that you have subscriptions that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the subscriptions that have either or both of these tag values associated with them.
  section = newJObject()
  var valid_612905 = query.getOrDefault("Marker")
  valid_612905 = validateParameter(valid_612905, JString, required = false,
                                 default = nil)
  if valid_612905 != nil:
    section.add "Marker", valid_612905
  var valid_612906 = query.getOrDefault("TagKeys")
  valid_612906 = validateParameter(valid_612906, JArray, required = false,
                                 default = nil)
  if valid_612906 != nil:
    section.add "TagKeys", valid_612906
  var valid_612907 = query.getOrDefault("SubscriptionName")
  valid_612907 = validateParameter(valid_612907, JString, required = false,
                                 default = nil)
  if valid_612907 != nil:
    section.add "SubscriptionName", valid_612907
  var valid_612908 = query.getOrDefault("Action")
  valid_612908 = validateParameter(valid_612908, JString, required = true, default = newJString(
      "DescribeEventSubscriptions"))
  if valid_612908 != nil:
    section.add "Action", valid_612908
  var valid_612909 = query.getOrDefault("Version")
  valid_612909 = validateParameter(valid_612909, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_612909 != nil:
    section.add "Version", valid_612909
  var valid_612910 = query.getOrDefault("MaxRecords")
  valid_612910 = validateParameter(valid_612910, JInt, required = false, default = nil)
  if valid_612910 != nil:
    section.add "MaxRecords", valid_612910
  var valid_612911 = query.getOrDefault("TagValues")
  valid_612911 = validateParameter(valid_612911, JArray, required = false,
                                 default = nil)
  if valid_612911 != nil:
    section.add "TagValues", valid_612911
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_612912 = header.getOrDefault("X-Amz-Signature")
  valid_612912 = validateParameter(valid_612912, JString, required = false,
                                 default = nil)
  if valid_612912 != nil:
    section.add "X-Amz-Signature", valid_612912
  var valid_612913 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_612913 = validateParameter(valid_612913, JString, required = false,
                                 default = nil)
  if valid_612913 != nil:
    section.add "X-Amz-Content-Sha256", valid_612913
  var valid_612914 = header.getOrDefault("X-Amz-Date")
  valid_612914 = validateParameter(valid_612914, JString, required = false,
                                 default = nil)
  if valid_612914 != nil:
    section.add "X-Amz-Date", valid_612914
  var valid_612915 = header.getOrDefault("X-Amz-Credential")
  valid_612915 = validateParameter(valid_612915, JString, required = false,
                                 default = nil)
  if valid_612915 != nil:
    section.add "X-Amz-Credential", valid_612915
  var valid_612916 = header.getOrDefault("X-Amz-Security-Token")
  valid_612916 = validateParameter(valid_612916, JString, required = false,
                                 default = nil)
  if valid_612916 != nil:
    section.add "X-Amz-Security-Token", valid_612916
  var valid_612917 = header.getOrDefault("X-Amz-Algorithm")
  valid_612917 = validateParameter(valid_612917, JString, required = false,
                                 default = nil)
  if valid_612917 != nil:
    section.add "X-Amz-Algorithm", valid_612917
  var valid_612918 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_612918 = validateParameter(valid_612918, JString, required = false,
                                 default = nil)
  if valid_612918 != nil:
    section.add "X-Amz-SignedHeaders", valid_612918
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_612919: Call_GetDescribeEventSubscriptions_612902; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Lists descriptions of all the Amazon Redshift event notification subscriptions for a customer account. If you specify a subscription name, lists the description for that subscription.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all event notification subscriptions that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all subscriptions that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, subscriptions are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_612919.validator(path, query, header, formData, body)
  let scheme = call_612919.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_612919.url(scheme.get, call_612919.host, call_612919.base,
                         call_612919.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_612919, url, valid)

proc call*(call_612920: Call_GetDescribeEventSubscriptions_612902;
          Marker: string = ""; TagKeys: JsonNode = nil; SubscriptionName: string = "";
          Action: string = "DescribeEventSubscriptions";
          Version: string = "2012-12-01"; MaxRecords: int = 0; TagValues: JsonNode = nil): Recallable =
  ## getDescribeEventSubscriptions
  ## <p>Lists descriptions of all the Amazon Redshift event notification subscriptions for a customer account. If you specify a subscription name, lists the description for that subscription.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all event notification subscriptions that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all subscriptions that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, subscriptions are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a DescribeEventSubscriptions request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching event notification subscriptions that are associated with the specified key or keys. For example, suppose that you have subscriptions that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the subscriptions that have either or both of these tag keys associated with them.
  ##   SubscriptionName: string
  ##                   : The name of the Amazon Redshift event notification subscription to be described.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching event notification subscriptions that are associated with the specified tag value or values. For example, suppose that you have subscriptions that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the subscriptions that have either or both of these tag values associated with them.
  var query_612921 = newJObject()
  add(query_612921, "Marker", newJString(Marker))
  if TagKeys != nil:
    query_612921.add "TagKeys", TagKeys
  add(query_612921, "SubscriptionName", newJString(SubscriptionName))
  add(query_612921, "Action", newJString(Action))
  add(query_612921, "Version", newJString(Version))
  add(query_612921, "MaxRecords", newJInt(MaxRecords))
  if TagValues != nil:
    query_612921.add "TagValues", TagValues
  result = call_612920.call(nil, query_612921, nil, nil, nil)

var getDescribeEventSubscriptions* = Call_GetDescribeEventSubscriptions_612902(
    name: "getDescribeEventSubscriptions", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeEventSubscriptions",
    validator: validate_GetDescribeEventSubscriptions_612903, base: "/",
    url: url_GetDescribeEventSubscriptions_612904,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeEvents_612965 = ref object of OpenApiRestCall_610642
proc url_PostDescribeEvents_612967(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeEvents_612966(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Returns events related to clusters, security groups, snapshots, and parameter groups for the past 14 days. Events specific to a particular cluster, security group, snapshot or parameter group can be obtained by providing the name as a parameter. By default, the past hour of events are returned.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_612968 = query.getOrDefault("Action")
  valid_612968 = validateParameter(valid_612968, JString, required = true,
                                 default = newJString("DescribeEvents"))
  if valid_612968 != nil:
    section.add "Action", valid_612968
  var valid_612969 = query.getOrDefault("Version")
  valid_612969 = validateParameter(valid_612969, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_612969 != nil:
    section.add "Version", valid_612969
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_612970 = header.getOrDefault("X-Amz-Signature")
  valid_612970 = validateParameter(valid_612970, JString, required = false,
                                 default = nil)
  if valid_612970 != nil:
    section.add "X-Amz-Signature", valid_612970
  var valid_612971 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_612971 = validateParameter(valid_612971, JString, required = false,
                                 default = nil)
  if valid_612971 != nil:
    section.add "X-Amz-Content-Sha256", valid_612971
  var valid_612972 = header.getOrDefault("X-Amz-Date")
  valid_612972 = validateParameter(valid_612972, JString, required = false,
                                 default = nil)
  if valid_612972 != nil:
    section.add "X-Amz-Date", valid_612972
  var valid_612973 = header.getOrDefault("X-Amz-Credential")
  valid_612973 = validateParameter(valid_612973, JString, required = false,
                                 default = nil)
  if valid_612973 != nil:
    section.add "X-Amz-Credential", valid_612973
  var valid_612974 = header.getOrDefault("X-Amz-Security-Token")
  valid_612974 = validateParameter(valid_612974, JString, required = false,
                                 default = nil)
  if valid_612974 != nil:
    section.add "X-Amz-Security-Token", valid_612974
  var valid_612975 = header.getOrDefault("X-Amz-Algorithm")
  valid_612975 = validateParameter(valid_612975, JString, required = false,
                                 default = nil)
  if valid_612975 != nil:
    section.add "X-Amz-Algorithm", valid_612975
  var valid_612976 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_612976 = validateParameter(valid_612976, JString, required = false,
                                 default = nil)
  if valid_612976 != nil:
    section.add "X-Amz-SignedHeaders", valid_612976
  result.add "header", section
  ## parameters in `formData` object:
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeEvents</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   SourceIdentifier: JString
  ##                   : <p>The identifier of the event source for which events will be returned. If this parameter is not specified, then all sources are included in the response.</p> <p>Constraints:</p> <p>If <i>SourceIdentifier</i> is supplied, <i>SourceType</i> must also be provided.</p> <ul> <li> <p>Specify a cluster identifier when <i>SourceType</i> is <code>cluster</code>.</p> </li> <li> <p>Specify a cluster security group name when <i>SourceType</i> is <code>cluster-security-group</code>.</p> </li> <li> <p>Specify a cluster parameter group name when <i>SourceType</i> is <code>cluster-parameter-group</code>.</p> </li> <li> <p>Specify a cluster snapshot identifier when <i>SourceType</i> is <code>cluster-snapshot</code>.</p> </li> </ul>
  ##   SourceType: JString
  ##             : <p>The event source to retrieve events for. If no value is specified, all events are returned.</p> <p>Constraints:</p> <p>If <i>SourceType</i> is supplied, <i>SourceIdentifier</i> must also be provided.</p> <ul> <li> <p>Specify <code>cluster</code> when <i>SourceIdentifier</i> is a cluster identifier.</p> </li> <li> <p>Specify <code>cluster-security-group</code> when <i>SourceIdentifier</i> is a cluster security group name.</p> </li> <li> <p>Specify <code>cluster-parameter-group</code> when <i>SourceIdentifier</i> is a cluster parameter group name.</p> </li> <li> <p>Specify <code>cluster-snapshot</code> when <i>SourceIdentifier</i> is a cluster snapshot identifier.</p> </li> </ul>
  ##   Duration: JInt
  ##           : <p>The number of minutes prior to the time of the request for which to retrieve events. For example, if the request is sent at 18:00 and you specify a duration of 60, then only events which have occurred after 17:00 will be returned.</p> <p>Default: <code>60</code> </p>
  ##   EndTime: JString
  ##          : <p>The end of the time interval for which to retrieve events, specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2009-07-08T18:00Z</code> </p>
  ##   StartTime: JString
  ##            : <p>The beginning of the time interval to retrieve events for, specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2009-07-08T18:00Z</code> </p>
  section = newJObject()
  var valid_612977 = formData.getOrDefault("MaxRecords")
  valid_612977 = validateParameter(valid_612977, JInt, required = false, default = nil)
  if valid_612977 != nil:
    section.add "MaxRecords", valid_612977
  var valid_612978 = formData.getOrDefault("Marker")
  valid_612978 = validateParameter(valid_612978, JString, required = false,
                                 default = nil)
  if valid_612978 != nil:
    section.add "Marker", valid_612978
  var valid_612979 = formData.getOrDefault("SourceIdentifier")
  valid_612979 = validateParameter(valid_612979, JString, required = false,
                                 default = nil)
  if valid_612979 != nil:
    section.add "SourceIdentifier", valid_612979
  var valid_612980 = formData.getOrDefault("SourceType")
  valid_612980 = validateParameter(valid_612980, JString, required = false,
                                 default = newJString("cluster"))
  if valid_612980 != nil:
    section.add "SourceType", valid_612980
  var valid_612981 = formData.getOrDefault("Duration")
  valid_612981 = validateParameter(valid_612981, JInt, required = false, default = nil)
  if valid_612981 != nil:
    section.add "Duration", valid_612981
  var valid_612982 = formData.getOrDefault("EndTime")
  valid_612982 = validateParameter(valid_612982, JString, required = false,
                                 default = nil)
  if valid_612982 != nil:
    section.add "EndTime", valid_612982
  var valid_612983 = formData.getOrDefault("StartTime")
  valid_612983 = validateParameter(valid_612983, JString, required = false,
                                 default = nil)
  if valid_612983 != nil:
    section.add "StartTime", valid_612983
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_612984: Call_PostDescribeEvents_612965; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns events related to clusters, security groups, snapshots, and parameter groups for the past 14 days. Events specific to a particular cluster, security group, snapshot or parameter group can be obtained by providing the name as a parameter. By default, the past hour of events are returned.
  ## 
  let valid = call_612984.validator(path, query, header, formData, body)
  let scheme = call_612984.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_612984.url(scheme.get, call_612984.host, call_612984.base,
                         call_612984.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_612984, url, valid)

proc call*(call_612985: Call_PostDescribeEvents_612965; MaxRecords: int = 0;
          Marker: string = ""; SourceIdentifier: string = "";
          SourceType: string = "cluster"; Duration: int = 0; EndTime: string = "";
          StartTime: string = ""; Action: string = "DescribeEvents";
          Version: string = "2012-12-01"): Recallable =
  ## postDescribeEvents
  ## Returns events related to clusters, security groups, snapshots, and parameter groups for the past 14 days. Events specific to a particular cluster, security group, snapshot or parameter group can be obtained by providing the name as a parameter. By default, the past hour of events are returned.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeEvents</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   SourceIdentifier: string
  ##                   : <p>The identifier of the event source for which events will be returned. If this parameter is not specified, then all sources are included in the response.</p> <p>Constraints:</p> <p>If <i>SourceIdentifier</i> is supplied, <i>SourceType</i> must also be provided.</p> <ul> <li> <p>Specify a cluster identifier when <i>SourceType</i> is <code>cluster</code>.</p> </li> <li> <p>Specify a cluster security group name when <i>SourceType</i> is <code>cluster-security-group</code>.</p> </li> <li> <p>Specify a cluster parameter group name when <i>SourceType</i> is <code>cluster-parameter-group</code>.</p> </li> <li> <p>Specify a cluster snapshot identifier when <i>SourceType</i> is <code>cluster-snapshot</code>.</p> </li> </ul>
  ##   SourceType: string
  ##             : <p>The event source to retrieve events for. If no value is specified, all events are returned.</p> <p>Constraints:</p> <p>If <i>SourceType</i> is supplied, <i>SourceIdentifier</i> must also be provided.</p> <ul> <li> <p>Specify <code>cluster</code> when <i>SourceIdentifier</i> is a cluster identifier.</p> </li> <li> <p>Specify <code>cluster-security-group</code> when <i>SourceIdentifier</i> is a cluster security group name.</p> </li> <li> <p>Specify <code>cluster-parameter-group</code> when <i>SourceIdentifier</i> is a cluster parameter group name.</p> </li> <li> <p>Specify <code>cluster-snapshot</code> when <i>SourceIdentifier</i> is a cluster snapshot identifier.</p> </li> </ul>
  ##   Duration: int
  ##           : <p>The number of minutes prior to the time of the request for which to retrieve events. For example, if the request is sent at 18:00 and you specify a duration of 60, then only events which have occurred after 17:00 will be returned.</p> <p>Default: <code>60</code> </p>
  ##   EndTime: string
  ##          : <p>The end of the time interval for which to retrieve events, specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2009-07-08T18:00Z</code> </p>
  ##   StartTime: string
  ##            : <p>The beginning of the time interval to retrieve events for, specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2009-07-08T18:00Z</code> </p>
  ##   Action: string (required)
  ##   Version: string (required)
  var query_612986 = newJObject()
  var formData_612987 = newJObject()
  add(formData_612987, "MaxRecords", newJInt(MaxRecords))
  add(formData_612987, "Marker", newJString(Marker))
  add(formData_612987, "SourceIdentifier", newJString(SourceIdentifier))
  add(formData_612987, "SourceType", newJString(SourceType))
  add(formData_612987, "Duration", newJInt(Duration))
  add(formData_612987, "EndTime", newJString(EndTime))
  add(formData_612987, "StartTime", newJString(StartTime))
  add(query_612986, "Action", newJString(Action))
  add(query_612986, "Version", newJString(Version))
  result = call_612985.call(nil, query_612986, nil, formData_612987, nil)

var postDescribeEvents* = Call_PostDescribeEvents_612965(
    name: "postDescribeEvents", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeEvents",
    validator: validate_PostDescribeEvents_612966, base: "/",
    url: url_PostDescribeEvents_612967, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeEvents_612943 = ref object of OpenApiRestCall_610642
proc url_GetDescribeEvents_612945(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeEvents_612944(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## Returns events related to clusters, security groups, snapshots, and parameter groups for the past 14 days. Events specific to a particular cluster, security group, snapshot or parameter group can be obtained by providing the name as a parameter. By default, the past hour of events are returned.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeEvents</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   SourceType: JString
  ##             : <p>The event source to retrieve events for. If no value is specified, all events are returned.</p> <p>Constraints:</p> <p>If <i>SourceType</i> is supplied, <i>SourceIdentifier</i> must also be provided.</p> <ul> <li> <p>Specify <code>cluster</code> when <i>SourceIdentifier</i> is a cluster identifier.</p> </li> <li> <p>Specify <code>cluster-security-group</code> when <i>SourceIdentifier</i> is a cluster security group name.</p> </li> <li> <p>Specify <code>cluster-parameter-group</code> when <i>SourceIdentifier</i> is a cluster parameter group name.</p> </li> <li> <p>Specify <code>cluster-snapshot</code> when <i>SourceIdentifier</i> is a cluster snapshot identifier.</p> </li> </ul>
  ##   SourceIdentifier: JString
  ##                   : <p>The identifier of the event source for which events will be returned. If this parameter is not specified, then all sources are included in the response.</p> <p>Constraints:</p> <p>If <i>SourceIdentifier</i> is supplied, <i>SourceType</i> must also be provided.</p> <ul> <li> <p>Specify a cluster identifier when <i>SourceType</i> is <code>cluster</code>.</p> </li> <li> <p>Specify a cluster security group name when <i>SourceType</i> is <code>cluster-security-group</code>.</p> </li> <li> <p>Specify a cluster parameter group name when <i>SourceType</i> is <code>cluster-parameter-group</code>.</p> </li> <li> <p>Specify a cluster snapshot identifier when <i>SourceType</i> is <code>cluster-snapshot</code>.</p> </li> </ul>
  ##   Action: JString (required)
  ##   StartTime: JString
  ##            : <p>The beginning of the time interval to retrieve events for, specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2009-07-08T18:00Z</code> </p>
  ##   Duration: JInt
  ##           : <p>The number of minutes prior to the time of the request for which to retrieve events. For example, if the request is sent at 18:00 and you specify a duration of 60, then only events which have occurred after 17:00 will be returned.</p> <p>Default: <code>60</code> </p>
  ##   EndTime: JString
  ##          : <p>The end of the time interval for which to retrieve events, specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2009-07-08T18:00Z</code> </p>
  ##   Version: JString (required)
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  section = newJObject()
  var valid_612946 = query.getOrDefault("Marker")
  valid_612946 = validateParameter(valid_612946, JString, required = false,
                                 default = nil)
  if valid_612946 != nil:
    section.add "Marker", valid_612946
  var valid_612947 = query.getOrDefault("SourceType")
  valid_612947 = validateParameter(valid_612947, JString, required = false,
                                 default = newJString("cluster"))
  if valid_612947 != nil:
    section.add "SourceType", valid_612947
  var valid_612948 = query.getOrDefault("SourceIdentifier")
  valid_612948 = validateParameter(valid_612948, JString, required = false,
                                 default = nil)
  if valid_612948 != nil:
    section.add "SourceIdentifier", valid_612948
  var valid_612949 = query.getOrDefault("Action")
  valid_612949 = validateParameter(valid_612949, JString, required = true,
                                 default = newJString("DescribeEvents"))
  if valid_612949 != nil:
    section.add "Action", valid_612949
  var valid_612950 = query.getOrDefault("StartTime")
  valid_612950 = validateParameter(valid_612950, JString, required = false,
                                 default = nil)
  if valid_612950 != nil:
    section.add "StartTime", valid_612950
  var valid_612951 = query.getOrDefault("Duration")
  valid_612951 = validateParameter(valid_612951, JInt, required = false, default = nil)
  if valid_612951 != nil:
    section.add "Duration", valid_612951
  var valid_612952 = query.getOrDefault("EndTime")
  valid_612952 = validateParameter(valid_612952, JString, required = false,
                                 default = nil)
  if valid_612952 != nil:
    section.add "EndTime", valid_612952
  var valid_612953 = query.getOrDefault("Version")
  valid_612953 = validateParameter(valid_612953, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_612953 != nil:
    section.add "Version", valid_612953
  var valid_612954 = query.getOrDefault("MaxRecords")
  valid_612954 = validateParameter(valid_612954, JInt, required = false, default = nil)
  if valid_612954 != nil:
    section.add "MaxRecords", valid_612954
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_612955 = header.getOrDefault("X-Amz-Signature")
  valid_612955 = validateParameter(valid_612955, JString, required = false,
                                 default = nil)
  if valid_612955 != nil:
    section.add "X-Amz-Signature", valid_612955
  var valid_612956 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_612956 = validateParameter(valid_612956, JString, required = false,
                                 default = nil)
  if valid_612956 != nil:
    section.add "X-Amz-Content-Sha256", valid_612956
  var valid_612957 = header.getOrDefault("X-Amz-Date")
  valid_612957 = validateParameter(valid_612957, JString, required = false,
                                 default = nil)
  if valid_612957 != nil:
    section.add "X-Amz-Date", valid_612957
  var valid_612958 = header.getOrDefault("X-Amz-Credential")
  valid_612958 = validateParameter(valid_612958, JString, required = false,
                                 default = nil)
  if valid_612958 != nil:
    section.add "X-Amz-Credential", valid_612958
  var valid_612959 = header.getOrDefault("X-Amz-Security-Token")
  valid_612959 = validateParameter(valid_612959, JString, required = false,
                                 default = nil)
  if valid_612959 != nil:
    section.add "X-Amz-Security-Token", valid_612959
  var valid_612960 = header.getOrDefault("X-Amz-Algorithm")
  valid_612960 = validateParameter(valid_612960, JString, required = false,
                                 default = nil)
  if valid_612960 != nil:
    section.add "X-Amz-Algorithm", valid_612960
  var valid_612961 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_612961 = validateParameter(valid_612961, JString, required = false,
                                 default = nil)
  if valid_612961 != nil:
    section.add "X-Amz-SignedHeaders", valid_612961
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_612962: Call_GetDescribeEvents_612943; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns events related to clusters, security groups, snapshots, and parameter groups for the past 14 days. Events specific to a particular cluster, security group, snapshot or parameter group can be obtained by providing the name as a parameter. By default, the past hour of events are returned.
  ## 
  let valid = call_612962.validator(path, query, header, formData, body)
  let scheme = call_612962.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_612962.url(scheme.get, call_612962.host, call_612962.base,
                         call_612962.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_612962, url, valid)

proc call*(call_612963: Call_GetDescribeEvents_612943; Marker: string = "";
          SourceType: string = "cluster"; SourceIdentifier: string = "";
          Action: string = "DescribeEvents"; StartTime: string = ""; Duration: int = 0;
          EndTime: string = ""; Version: string = "2012-12-01"; MaxRecords: int = 0): Recallable =
  ## getDescribeEvents
  ## Returns events related to clusters, security groups, snapshots, and parameter groups for the past 14 days. Events specific to a particular cluster, security group, snapshot or parameter group can be obtained by providing the name as a parameter. By default, the past hour of events are returned.
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeEvents</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   SourceType: string
  ##             : <p>The event source to retrieve events for. If no value is specified, all events are returned.</p> <p>Constraints:</p> <p>If <i>SourceType</i> is supplied, <i>SourceIdentifier</i> must also be provided.</p> <ul> <li> <p>Specify <code>cluster</code> when <i>SourceIdentifier</i> is a cluster identifier.</p> </li> <li> <p>Specify <code>cluster-security-group</code> when <i>SourceIdentifier</i> is a cluster security group name.</p> </li> <li> <p>Specify <code>cluster-parameter-group</code> when <i>SourceIdentifier</i> is a cluster parameter group name.</p> </li> <li> <p>Specify <code>cluster-snapshot</code> when <i>SourceIdentifier</i> is a cluster snapshot identifier.</p> </li> </ul>
  ##   SourceIdentifier: string
  ##                   : <p>The identifier of the event source for which events will be returned. If this parameter is not specified, then all sources are included in the response.</p> <p>Constraints:</p> <p>If <i>SourceIdentifier</i> is supplied, <i>SourceType</i> must also be provided.</p> <ul> <li> <p>Specify a cluster identifier when <i>SourceType</i> is <code>cluster</code>.</p> </li> <li> <p>Specify a cluster security group name when <i>SourceType</i> is <code>cluster-security-group</code>.</p> </li> <li> <p>Specify a cluster parameter group name when <i>SourceType</i> is <code>cluster-parameter-group</code>.</p> </li> <li> <p>Specify a cluster snapshot identifier when <i>SourceType</i> is <code>cluster-snapshot</code>.</p> </li> </ul>
  ##   Action: string (required)
  ##   StartTime: string
  ##            : <p>The beginning of the time interval to retrieve events for, specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2009-07-08T18:00Z</code> </p>
  ##   Duration: int
  ##           : <p>The number of minutes prior to the time of the request for which to retrieve events. For example, if the request is sent at 18:00 and you specify a duration of 60, then only events which have occurred after 17:00 will be returned.</p> <p>Default: <code>60</code> </p>
  ##   EndTime: string
  ##          : <p>The end of the time interval for which to retrieve events, specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2009-07-08T18:00Z</code> </p>
  ##   Version: string (required)
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  var query_612964 = newJObject()
  add(query_612964, "Marker", newJString(Marker))
  add(query_612964, "SourceType", newJString(SourceType))
  add(query_612964, "SourceIdentifier", newJString(SourceIdentifier))
  add(query_612964, "Action", newJString(Action))
  add(query_612964, "StartTime", newJString(StartTime))
  add(query_612964, "Duration", newJInt(Duration))
  add(query_612964, "EndTime", newJString(EndTime))
  add(query_612964, "Version", newJString(Version))
  add(query_612964, "MaxRecords", newJInt(MaxRecords))
  result = call_612963.call(nil, query_612964, nil, nil, nil)

var getDescribeEvents* = Call_GetDescribeEvents_612943(name: "getDescribeEvents",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=DescribeEvents", validator: validate_GetDescribeEvents_612944,
    base: "/", url: url_GetDescribeEvents_612945,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeHsmClientCertificates_613008 = ref object of OpenApiRestCall_610642
proc url_PostDescribeHsmClientCertificates_613010(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeHsmClientCertificates_613009(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns information about the specified HSM client certificate. If no certificate ID is specified, returns information about all the HSM certificates owned by your AWS customer account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM client certificates that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all HSM client certificates that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, HSM client certificates are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_613011 = query.getOrDefault("Action")
  valid_613011 = validateParameter(valid_613011, JString, required = true, default = newJString(
      "DescribeHsmClientCertificates"))
  if valid_613011 != nil:
    section.add "Action", valid_613011
  var valid_613012 = query.getOrDefault("Version")
  valid_613012 = validateParameter(valid_613012, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_613012 != nil:
    section.add "Version", valid_613012
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613013 = header.getOrDefault("X-Amz-Signature")
  valid_613013 = validateParameter(valid_613013, JString, required = false,
                                 default = nil)
  if valid_613013 != nil:
    section.add "X-Amz-Signature", valid_613013
  var valid_613014 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613014 = validateParameter(valid_613014, JString, required = false,
                                 default = nil)
  if valid_613014 != nil:
    section.add "X-Amz-Content-Sha256", valid_613014
  var valid_613015 = header.getOrDefault("X-Amz-Date")
  valid_613015 = validateParameter(valid_613015, JString, required = false,
                                 default = nil)
  if valid_613015 != nil:
    section.add "X-Amz-Date", valid_613015
  var valid_613016 = header.getOrDefault("X-Amz-Credential")
  valid_613016 = validateParameter(valid_613016, JString, required = false,
                                 default = nil)
  if valid_613016 != nil:
    section.add "X-Amz-Credential", valid_613016
  var valid_613017 = header.getOrDefault("X-Amz-Security-Token")
  valid_613017 = validateParameter(valid_613017, JString, required = false,
                                 default = nil)
  if valid_613017 != nil:
    section.add "X-Amz-Security-Token", valid_613017
  var valid_613018 = header.getOrDefault("X-Amz-Algorithm")
  valid_613018 = validateParameter(valid_613018, JString, required = false,
                                 default = nil)
  if valid_613018 != nil:
    section.add "X-Amz-Algorithm", valid_613018
  var valid_613019 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613019 = validateParameter(valid_613019, JString, required = false,
                                 default = nil)
  if valid_613019 != nil:
    section.add "X-Amz-SignedHeaders", valid_613019
  result.add "header", section
  ## parameters in `formData` object:
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching HSM client certificates that are associated with the specified key or keys. For example, suppose that you have HSM client certificates that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the HSM client certificates that have either or both of these tag keys associated with them.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeHsmClientCertificates</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching HSM client certificates that are associated with the specified tag value or values. For example, suppose that you have HSM client certificates that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the HSM client certificates that have either or both of these tag values associated with them.
  ##   HsmClientCertificateIdentifier: JString
  ##                                 : The identifier of a specific HSM client certificate for which you want information. If no identifier is specified, information is returned for all HSM client certificates owned by your AWS customer account.
  section = newJObject()
  var valid_613020 = formData.getOrDefault("TagKeys")
  valid_613020 = validateParameter(valid_613020, JArray, required = false,
                                 default = nil)
  if valid_613020 != nil:
    section.add "TagKeys", valid_613020
  var valid_613021 = formData.getOrDefault("MaxRecords")
  valid_613021 = validateParameter(valid_613021, JInt, required = false, default = nil)
  if valid_613021 != nil:
    section.add "MaxRecords", valid_613021
  var valid_613022 = formData.getOrDefault("Marker")
  valid_613022 = validateParameter(valid_613022, JString, required = false,
                                 default = nil)
  if valid_613022 != nil:
    section.add "Marker", valid_613022
  var valid_613023 = formData.getOrDefault("TagValues")
  valid_613023 = validateParameter(valid_613023, JArray, required = false,
                                 default = nil)
  if valid_613023 != nil:
    section.add "TagValues", valid_613023
  var valid_613024 = formData.getOrDefault("HsmClientCertificateIdentifier")
  valid_613024 = validateParameter(valid_613024, JString, required = false,
                                 default = nil)
  if valid_613024 != nil:
    section.add "HsmClientCertificateIdentifier", valid_613024
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613025: Call_PostDescribeHsmClientCertificates_613008;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Returns information about the specified HSM client certificate. If no certificate ID is specified, returns information about all the HSM certificates owned by your AWS customer account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM client certificates that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all HSM client certificates that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, HSM client certificates are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_613025.validator(path, query, header, formData, body)
  let scheme = call_613025.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613025.url(scheme.get, call_613025.host, call_613025.base,
                         call_613025.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613025, url, valid)

proc call*(call_613026: Call_PostDescribeHsmClientCertificates_613008;
          TagKeys: JsonNode = nil; MaxRecords: int = 0; Marker: string = "";
          TagValues: JsonNode = nil;
          Action: string = "DescribeHsmClientCertificates";
          HsmClientCertificateIdentifier: string = "";
          Version: string = "2012-12-01"): Recallable =
  ## postDescribeHsmClientCertificates
  ## <p>Returns information about the specified HSM client certificate. If no certificate ID is specified, returns information about all the HSM certificates owned by your AWS customer account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM client certificates that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all HSM client certificates that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, HSM client certificates are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching HSM client certificates that are associated with the specified key or keys. For example, suppose that you have HSM client certificates that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the HSM client certificates that have either or both of these tag keys associated with them.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeHsmClientCertificates</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching HSM client certificates that are associated with the specified tag value or values. For example, suppose that you have HSM client certificates that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the HSM client certificates that have either or both of these tag values associated with them.
  ##   Action: string (required)
  ##   HsmClientCertificateIdentifier: string
  ##                                 : The identifier of a specific HSM client certificate for which you want information. If no identifier is specified, information is returned for all HSM client certificates owned by your AWS customer account.
  ##   Version: string (required)
  var query_613027 = newJObject()
  var formData_613028 = newJObject()
  if TagKeys != nil:
    formData_613028.add "TagKeys", TagKeys
  add(formData_613028, "MaxRecords", newJInt(MaxRecords))
  add(formData_613028, "Marker", newJString(Marker))
  if TagValues != nil:
    formData_613028.add "TagValues", TagValues
  add(query_613027, "Action", newJString(Action))
  add(formData_613028, "HsmClientCertificateIdentifier",
      newJString(HsmClientCertificateIdentifier))
  add(query_613027, "Version", newJString(Version))
  result = call_613026.call(nil, query_613027, nil, formData_613028, nil)

var postDescribeHsmClientCertificates* = Call_PostDescribeHsmClientCertificates_613008(
    name: "postDescribeHsmClientCertificates", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeHsmClientCertificates",
    validator: validate_PostDescribeHsmClientCertificates_613009, base: "/",
    url: url_PostDescribeHsmClientCertificates_613010,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeHsmClientCertificates_612988 = ref object of OpenApiRestCall_610642
proc url_GetDescribeHsmClientCertificates_612990(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeHsmClientCertificates_612989(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns information about the specified HSM client certificate. If no certificate ID is specified, returns information about all the HSM certificates owned by your AWS customer account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM client certificates that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all HSM client certificates that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, HSM client certificates are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeHsmClientCertificates</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   HsmClientCertificateIdentifier: JString
  ##                                 : The identifier of a specific HSM client certificate for which you want information. If no identifier is specified, information is returned for all HSM client certificates owned by your AWS customer account.
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching HSM client certificates that are associated with the specified key or keys. For example, suppose that you have HSM client certificates that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the HSM client certificates that have either or both of these tag keys associated with them.
  ##   Action: JString (required)
  ##   Version: JString (required)
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching HSM client certificates that are associated with the specified tag value or values. For example, suppose that you have HSM client certificates that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the HSM client certificates that have either or both of these tag values associated with them.
  section = newJObject()
  var valid_612991 = query.getOrDefault("Marker")
  valid_612991 = validateParameter(valid_612991, JString, required = false,
                                 default = nil)
  if valid_612991 != nil:
    section.add "Marker", valid_612991
  var valid_612992 = query.getOrDefault("HsmClientCertificateIdentifier")
  valid_612992 = validateParameter(valid_612992, JString, required = false,
                                 default = nil)
  if valid_612992 != nil:
    section.add "HsmClientCertificateIdentifier", valid_612992
  var valid_612993 = query.getOrDefault("TagKeys")
  valid_612993 = validateParameter(valid_612993, JArray, required = false,
                                 default = nil)
  if valid_612993 != nil:
    section.add "TagKeys", valid_612993
  var valid_612994 = query.getOrDefault("Action")
  valid_612994 = validateParameter(valid_612994, JString, required = true, default = newJString(
      "DescribeHsmClientCertificates"))
  if valid_612994 != nil:
    section.add "Action", valid_612994
  var valid_612995 = query.getOrDefault("Version")
  valid_612995 = validateParameter(valid_612995, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_612995 != nil:
    section.add "Version", valid_612995
  var valid_612996 = query.getOrDefault("MaxRecords")
  valid_612996 = validateParameter(valid_612996, JInt, required = false, default = nil)
  if valid_612996 != nil:
    section.add "MaxRecords", valid_612996
  var valid_612997 = query.getOrDefault("TagValues")
  valid_612997 = validateParameter(valid_612997, JArray, required = false,
                                 default = nil)
  if valid_612997 != nil:
    section.add "TagValues", valid_612997
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_612998 = header.getOrDefault("X-Amz-Signature")
  valid_612998 = validateParameter(valid_612998, JString, required = false,
                                 default = nil)
  if valid_612998 != nil:
    section.add "X-Amz-Signature", valid_612998
  var valid_612999 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_612999 = validateParameter(valid_612999, JString, required = false,
                                 default = nil)
  if valid_612999 != nil:
    section.add "X-Amz-Content-Sha256", valid_612999
  var valid_613000 = header.getOrDefault("X-Amz-Date")
  valid_613000 = validateParameter(valid_613000, JString, required = false,
                                 default = nil)
  if valid_613000 != nil:
    section.add "X-Amz-Date", valid_613000
  var valid_613001 = header.getOrDefault("X-Amz-Credential")
  valid_613001 = validateParameter(valid_613001, JString, required = false,
                                 default = nil)
  if valid_613001 != nil:
    section.add "X-Amz-Credential", valid_613001
  var valid_613002 = header.getOrDefault("X-Amz-Security-Token")
  valid_613002 = validateParameter(valid_613002, JString, required = false,
                                 default = nil)
  if valid_613002 != nil:
    section.add "X-Amz-Security-Token", valid_613002
  var valid_613003 = header.getOrDefault("X-Amz-Algorithm")
  valid_613003 = validateParameter(valid_613003, JString, required = false,
                                 default = nil)
  if valid_613003 != nil:
    section.add "X-Amz-Algorithm", valid_613003
  var valid_613004 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613004 = validateParameter(valid_613004, JString, required = false,
                                 default = nil)
  if valid_613004 != nil:
    section.add "X-Amz-SignedHeaders", valid_613004
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613005: Call_GetDescribeHsmClientCertificates_612988;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Returns information about the specified HSM client certificate. If no certificate ID is specified, returns information about all the HSM certificates owned by your AWS customer account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM client certificates that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all HSM client certificates that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, HSM client certificates are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_613005.validator(path, query, header, formData, body)
  let scheme = call_613005.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613005.url(scheme.get, call_613005.host, call_613005.base,
                         call_613005.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613005, url, valid)

proc call*(call_613006: Call_GetDescribeHsmClientCertificates_612988;
          Marker: string = ""; HsmClientCertificateIdentifier: string = "";
          TagKeys: JsonNode = nil; Action: string = "DescribeHsmClientCertificates";
          Version: string = "2012-12-01"; MaxRecords: int = 0; TagValues: JsonNode = nil): Recallable =
  ## getDescribeHsmClientCertificates
  ## <p>Returns information about the specified HSM client certificate. If no certificate ID is specified, returns information about all the HSM certificates owned by your AWS customer account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM client certificates that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all HSM client certificates that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, HSM client certificates are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeHsmClientCertificates</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   HsmClientCertificateIdentifier: string
  ##                                 : The identifier of a specific HSM client certificate for which you want information. If no identifier is specified, information is returned for all HSM client certificates owned by your AWS customer account.
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching HSM client certificates that are associated with the specified key or keys. For example, suppose that you have HSM client certificates that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the HSM client certificates that have either or both of these tag keys associated with them.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching HSM client certificates that are associated with the specified tag value or values. For example, suppose that you have HSM client certificates that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the HSM client certificates that have either or both of these tag values associated with them.
  var query_613007 = newJObject()
  add(query_613007, "Marker", newJString(Marker))
  add(query_613007, "HsmClientCertificateIdentifier",
      newJString(HsmClientCertificateIdentifier))
  if TagKeys != nil:
    query_613007.add "TagKeys", TagKeys
  add(query_613007, "Action", newJString(Action))
  add(query_613007, "Version", newJString(Version))
  add(query_613007, "MaxRecords", newJInt(MaxRecords))
  if TagValues != nil:
    query_613007.add "TagValues", TagValues
  result = call_613006.call(nil, query_613007, nil, nil, nil)

var getDescribeHsmClientCertificates* = Call_GetDescribeHsmClientCertificates_612988(
    name: "getDescribeHsmClientCertificates", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeHsmClientCertificates",
    validator: validate_GetDescribeHsmClientCertificates_612989, base: "/",
    url: url_GetDescribeHsmClientCertificates_612990,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeHsmConfigurations_613049 = ref object of OpenApiRestCall_610642
proc url_PostDescribeHsmConfigurations_613051(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeHsmConfigurations_613050(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns information about the specified Amazon Redshift HSM configuration. If no configuration ID is specified, returns information about all the HSM configurations owned by your AWS customer account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM connections that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all HSM connections that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, HSM connections are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_613052 = query.getOrDefault("Action")
  valid_613052 = validateParameter(valid_613052, JString, required = true, default = newJString(
      "DescribeHsmConfigurations"))
  if valid_613052 != nil:
    section.add "Action", valid_613052
  var valid_613053 = query.getOrDefault("Version")
  valid_613053 = validateParameter(valid_613053, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_613053 != nil:
    section.add "Version", valid_613053
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613054 = header.getOrDefault("X-Amz-Signature")
  valid_613054 = validateParameter(valid_613054, JString, required = false,
                                 default = nil)
  if valid_613054 != nil:
    section.add "X-Amz-Signature", valid_613054
  var valid_613055 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613055 = validateParameter(valid_613055, JString, required = false,
                                 default = nil)
  if valid_613055 != nil:
    section.add "X-Amz-Content-Sha256", valid_613055
  var valid_613056 = header.getOrDefault("X-Amz-Date")
  valid_613056 = validateParameter(valid_613056, JString, required = false,
                                 default = nil)
  if valid_613056 != nil:
    section.add "X-Amz-Date", valid_613056
  var valid_613057 = header.getOrDefault("X-Amz-Credential")
  valid_613057 = validateParameter(valid_613057, JString, required = false,
                                 default = nil)
  if valid_613057 != nil:
    section.add "X-Amz-Credential", valid_613057
  var valid_613058 = header.getOrDefault("X-Amz-Security-Token")
  valid_613058 = validateParameter(valid_613058, JString, required = false,
                                 default = nil)
  if valid_613058 != nil:
    section.add "X-Amz-Security-Token", valid_613058
  var valid_613059 = header.getOrDefault("X-Amz-Algorithm")
  valid_613059 = validateParameter(valid_613059, JString, required = false,
                                 default = nil)
  if valid_613059 != nil:
    section.add "X-Amz-Algorithm", valid_613059
  var valid_613060 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613060 = validateParameter(valid_613060, JString, required = false,
                                 default = nil)
  if valid_613060 != nil:
    section.add "X-Amz-SignedHeaders", valid_613060
  result.add "header", section
  ## parameters in `formData` object:
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching HSM configurations that are associated with the specified key or keys. For example, suppose that you have HSM configurations that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the HSM configurations that have either or both of these tag keys associated with them.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeHsmConfigurations</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching HSM configurations that are associated with the specified tag value or values. For example, suppose that you have HSM configurations that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the HSM configurations that have either or both of these tag values associated with them.
  ##   HsmConfigurationIdentifier: JString
  ##                             : The identifier of a specific Amazon Redshift HSM configuration to be described. If no identifier is specified, information is returned for all HSM configurations owned by your AWS customer account.
  section = newJObject()
  var valid_613061 = formData.getOrDefault("TagKeys")
  valid_613061 = validateParameter(valid_613061, JArray, required = false,
                                 default = nil)
  if valid_613061 != nil:
    section.add "TagKeys", valid_613061
  var valid_613062 = formData.getOrDefault("MaxRecords")
  valid_613062 = validateParameter(valid_613062, JInt, required = false, default = nil)
  if valid_613062 != nil:
    section.add "MaxRecords", valid_613062
  var valid_613063 = formData.getOrDefault("Marker")
  valid_613063 = validateParameter(valid_613063, JString, required = false,
                                 default = nil)
  if valid_613063 != nil:
    section.add "Marker", valid_613063
  var valid_613064 = formData.getOrDefault("TagValues")
  valid_613064 = validateParameter(valid_613064, JArray, required = false,
                                 default = nil)
  if valid_613064 != nil:
    section.add "TagValues", valid_613064
  var valid_613065 = formData.getOrDefault("HsmConfigurationIdentifier")
  valid_613065 = validateParameter(valid_613065, JString, required = false,
                                 default = nil)
  if valid_613065 != nil:
    section.add "HsmConfigurationIdentifier", valid_613065
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613066: Call_PostDescribeHsmConfigurations_613049; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns information about the specified Amazon Redshift HSM configuration. If no configuration ID is specified, returns information about all the HSM configurations owned by your AWS customer account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM connections that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all HSM connections that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, HSM connections are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_613066.validator(path, query, header, formData, body)
  let scheme = call_613066.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613066.url(scheme.get, call_613066.host, call_613066.base,
                         call_613066.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613066, url, valid)

proc call*(call_613067: Call_PostDescribeHsmConfigurations_613049;
          TagKeys: JsonNode = nil; MaxRecords: int = 0; Marker: string = "";
          TagValues: JsonNode = nil; Action: string = "DescribeHsmConfigurations";
          Version: string = "2012-12-01"; HsmConfigurationIdentifier: string = ""): Recallable =
  ## postDescribeHsmConfigurations
  ## <p>Returns information about the specified Amazon Redshift HSM configuration. If no configuration ID is specified, returns information about all the HSM configurations owned by your AWS customer account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM connections that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all HSM connections that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, HSM connections are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching HSM configurations that are associated with the specified key or keys. For example, suppose that you have HSM configurations that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the HSM configurations that have either or both of these tag keys associated with them.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeHsmConfigurations</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching HSM configurations that are associated with the specified tag value or values. For example, suppose that you have HSM configurations that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the HSM configurations that have either or both of these tag values associated with them.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   HsmConfigurationIdentifier: string
  ##                             : The identifier of a specific Amazon Redshift HSM configuration to be described. If no identifier is specified, information is returned for all HSM configurations owned by your AWS customer account.
  var query_613068 = newJObject()
  var formData_613069 = newJObject()
  if TagKeys != nil:
    formData_613069.add "TagKeys", TagKeys
  add(formData_613069, "MaxRecords", newJInt(MaxRecords))
  add(formData_613069, "Marker", newJString(Marker))
  if TagValues != nil:
    formData_613069.add "TagValues", TagValues
  add(query_613068, "Action", newJString(Action))
  add(query_613068, "Version", newJString(Version))
  add(formData_613069, "HsmConfigurationIdentifier",
      newJString(HsmConfigurationIdentifier))
  result = call_613067.call(nil, query_613068, nil, formData_613069, nil)

var postDescribeHsmConfigurations* = Call_PostDescribeHsmConfigurations_613049(
    name: "postDescribeHsmConfigurations", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeHsmConfigurations",
    validator: validate_PostDescribeHsmConfigurations_613050, base: "/",
    url: url_PostDescribeHsmConfigurations_613051,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeHsmConfigurations_613029 = ref object of OpenApiRestCall_610642
proc url_GetDescribeHsmConfigurations_613031(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeHsmConfigurations_613030(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns information about the specified Amazon Redshift HSM configuration. If no configuration ID is specified, returns information about all the HSM configurations owned by your AWS customer account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM connections that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all HSM connections that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, HSM connections are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeHsmConfigurations</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching HSM configurations that are associated with the specified key or keys. For example, suppose that you have HSM configurations that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the HSM configurations that have either or both of these tag keys associated with them.
  ##   Action: JString (required)
  ##   HsmConfigurationIdentifier: JString
  ##                             : The identifier of a specific Amazon Redshift HSM configuration to be described. If no identifier is specified, information is returned for all HSM configurations owned by your AWS customer account.
  ##   Version: JString (required)
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching HSM configurations that are associated with the specified tag value or values. For example, suppose that you have HSM configurations that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the HSM configurations that have either or both of these tag values associated with them.
  section = newJObject()
  var valid_613032 = query.getOrDefault("Marker")
  valid_613032 = validateParameter(valid_613032, JString, required = false,
                                 default = nil)
  if valid_613032 != nil:
    section.add "Marker", valid_613032
  var valid_613033 = query.getOrDefault("TagKeys")
  valid_613033 = validateParameter(valid_613033, JArray, required = false,
                                 default = nil)
  if valid_613033 != nil:
    section.add "TagKeys", valid_613033
  var valid_613034 = query.getOrDefault("Action")
  valid_613034 = validateParameter(valid_613034, JString, required = true, default = newJString(
      "DescribeHsmConfigurations"))
  if valid_613034 != nil:
    section.add "Action", valid_613034
  var valid_613035 = query.getOrDefault("HsmConfigurationIdentifier")
  valid_613035 = validateParameter(valid_613035, JString, required = false,
                                 default = nil)
  if valid_613035 != nil:
    section.add "HsmConfigurationIdentifier", valid_613035
  var valid_613036 = query.getOrDefault("Version")
  valid_613036 = validateParameter(valid_613036, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_613036 != nil:
    section.add "Version", valid_613036
  var valid_613037 = query.getOrDefault("MaxRecords")
  valid_613037 = validateParameter(valid_613037, JInt, required = false, default = nil)
  if valid_613037 != nil:
    section.add "MaxRecords", valid_613037
  var valid_613038 = query.getOrDefault("TagValues")
  valid_613038 = validateParameter(valid_613038, JArray, required = false,
                                 default = nil)
  if valid_613038 != nil:
    section.add "TagValues", valid_613038
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613039 = header.getOrDefault("X-Amz-Signature")
  valid_613039 = validateParameter(valid_613039, JString, required = false,
                                 default = nil)
  if valid_613039 != nil:
    section.add "X-Amz-Signature", valid_613039
  var valid_613040 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613040 = validateParameter(valid_613040, JString, required = false,
                                 default = nil)
  if valid_613040 != nil:
    section.add "X-Amz-Content-Sha256", valid_613040
  var valid_613041 = header.getOrDefault("X-Amz-Date")
  valid_613041 = validateParameter(valid_613041, JString, required = false,
                                 default = nil)
  if valid_613041 != nil:
    section.add "X-Amz-Date", valid_613041
  var valid_613042 = header.getOrDefault("X-Amz-Credential")
  valid_613042 = validateParameter(valid_613042, JString, required = false,
                                 default = nil)
  if valid_613042 != nil:
    section.add "X-Amz-Credential", valid_613042
  var valid_613043 = header.getOrDefault("X-Amz-Security-Token")
  valid_613043 = validateParameter(valid_613043, JString, required = false,
                                 default = nil)
  if valid_613043 != nil:
    section.add "X-Amz-Security-Token", valid_613043
  var valid_613044 = header.getOrDefault("X-Amz-Algorithm")
  valid_613044 = validateParameter(valid_613044, JString, required = false,
                                 default = nil)
  if valid_613044 != nil:
    section.add "X-Amz-Algorithm", valid_613044
  var valid_613045 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613045 = validateParameter(valid_613045, JString, required = false,
                                 default = nil)
  if valid_613045 != nil:
    section.add "X-Amz-SignedHeaders", valid_613045
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613046: Call_GetDescribeHsmConfigurations_613029; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns information about the specified Amazon Redshift HSM configuration. If no configuration ID is specified, returns information about all the HSM configurations owned by your AWS customer account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM connections that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all HSM connections that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, HSM connections are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_613046.validator(path, query, header, formData, body)
  let scheme = call_613046.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613046.url(scheme.get, call_613046.host, call_613046.base,
                         call_613046.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613046, url, valid)

proc call*(call_613047: Call_GetDescribeHsmConfigurations_613029;
          Marker: string = ""; TagKeys: JsonNode = nil;
          Action: string = "DescribeHsmConfigurations";
          HsmConfigurationIdentifier: string = ""; Version: string = "2012-12-01";
          MaxRecords: int = 0; TagValues: JsonNode = nil): Recallable =
  ## getDescribeHsmConfigurations
  ## <p>Returns information about the specified Amazon Redshift HSM configuration. If no configuration ID is specified, returns information about all the HSM configurations owned by your AWS customer account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM connections that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all HSM connections that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, HSM connections are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeHsmConfigurations</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching HSM configurations that are associated with the specified key or keys. For example, suppose that you have HSM configurations that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the HSM configurations that have either or both of these tag keys associated with them.
  ##   Action: string (required)
  ##   HsmConfigurationIdentifier: string
  ##                             : The identifier of a specific Amazon Redshift HSM configuration to be described. If no identifier is specified, information is returned for all HSM configurations owned by your AWS customer account.
  ##   Version: string (required)
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching HSM configurations that are associated with the specified tag value or values. For example, suppose that you have HSM configurations that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the HSM configurations that have either or both of these tag values associated with them.
  var query_613048 = newJObject()
  add(query_613048, "Marker", newJString(Marker))
  if TagKeys != nil:
    query_613048.add "TagKeys", TagKeys
  add(query_613048, "Action", newJString(Action))
  add(query_613048, "HsmConfigurationIdentifier",
      newJString(HsmConfigurationIdentifier))
  add(query_613048, "Version", newJString(Version))
  add(query_613048, "MaxRecords", newJInt(MaxRecords))
  if TagValues != nil:
    query_613048.add "TagValues", TagValues
  result = call_613047.call(nil, query_613048, nil, nil, nil)

var getDescribeHsmConfigurations* = Call_GetDescribeHsmConfigurations_613029(
    name: "getDescribeHsmConfigurations", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeHsmConfigurations",
    validator: validate_GetDescribeHsmConfigurations_613030, base: "/",
    url: url_GetDescribeHsmConfigurations_613031,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeLoggingStatus_613086 = ref object of OpenApiRestCall_610642
proc url_PostDescribeLoggingStatus_613088(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeLoggingStatus_613087(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Describes whether information, such as queries and connection attempts, is being logged for the specified Amazon Redshift cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_613089 = query.getOrDefault("Action")
  valid_613089 = validateParameter(valid_613089, JString, required = true,
                                 default = newJString("DescribeLoggingStatus"))
  if valid_613089 != nil:
    section.add "Action", valid_613089
  var valid_613090 = query.getOrDefault("Version")
  valid_613090 = validateParameter(valid_613090, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_613090 != nil:
    section.add "Version", valid_613090
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613091 = header.getOrDefault("X-Amz-Signature")
  valid_613091 = validateParameter(valid_613091, JString, required = false,
                                 default = nil)
  if valid_613091 != nil:
    section.add "X-Amz-Signature", valid_613091
  var valid_613092 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613092 = validateParameter(valid_613092, JString, required = false,
                                 default = nil)
  if valid_613092 != nil:
    section.add "X-Amz-Content-Sha256", valid_613092
  var valid_613093 = header.getOrDefault("X-Amz-Date")
  valid_613093 = validateParameter(valid_613093, JString, required = false,
                                 default = nil)
  if valid_613093 != nil:
    section.add "X-Amz-Date", valid_613093
  var valid_613094 = header.getOrDefault("X-Amz-Credential")
  valid_613094 = validateParameter(valid_613094, JString, required = false,
                                 default = nil)
  if valid_613094 != nil:
    section.add "X-Amz-Credential", valid_613094
  var valid_613095 = header.getOrDefault("X-Amz-Security-Token")
  valid_613095 = validateParameter(valid_613095, JString, required = false,
                                 default = nil)
  if valid_613095 != nil:
    section.add "X-Amz-Security-Token", valid_613095
  var valid_613096 = header.getOrDefault("X-Amz-Algorithm")
  valid_613096 = validateParameter(valid_613096, JString, required = false,
                                 default = nil)
  if valid_613096 != nil:
    section.add "X-Amz-Algorithm", valid_613096
  var valid_613097 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613097 = validateParameter(valid_613097, JString, required = false,
                                 default = nil)
  if valid_613097 != nil:
    section.add "X-Amz-SignedHeaders", valid_613097
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The identifier of the cluster from which to get the logging status.</p> <p>Example: <code>examplecluster</code> </p>
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_613098 = formData.getOrDefault("ClusterIdentifier")
  valid_613098 = validateParameter(valid_613098, JString, required = true,
                                 default = nil)
  if valid_613098 != nil:
    section.add "ClusterIdentifier", valid_613098
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613099: Call_PostDescribeLoggingStatus_613086; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Describes whether information, such as queries and connection attempts, is being logged for the specified Amazon Redshift cluster.
  ## 
  let valid = call_613099.validator(path, query, header, formData, body)
  let scheme = call_613099.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613099.url(scheme.get, call_613099.host, call_613099.base,
                         call_613099.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613099, url, valid)

proc call*(call_613100: Call_PostDescribeLoggingStatus_613086;
          ClusterIdentifier: string; Action: string = "DescribeLoggingStatus";
          Version: string = "2012-12-01"): Recallable =
  ## postDescribeLoggingStatus
  ## Describes whether information, such as queries and connection attempts, is being logged for the specified Amazon Redshift cluster.
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The identifier of the cluster from which to get the logging status.</p> <p>Example: <code>examplecluster</code> </p>
  ##   Action: string (required)
  ##   Version: string (required)
  var query_613101 = newJObject()
  var formData_613102 = newJObject()
  add(formData_613102, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_613101, "Action", newJString(Action))
  add(query_613101, "Version", newJString(Version))
  result = call_613100.call(nil, query_613101, nil, formData_613102, nil)

var postDescribeLoggingStatus* = Call_PostDescribeLoggingStatus_613086(
    name: "postDescribeLoggingStatus", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeLoggingStatus",
    validator: validate_PostDescribeLoggingStatus_613087, base: "/",
    url: url_PostDescribeLoggingStatus_613088,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeLoggingStatus_613070 = ref object of OpenApiRestCall_610642
proc url_GetDescribeLoggingStatus_613072(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeLoggingStatus_613071(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Describes whether information, such as queries and connection attempts, is being logged for the specified Amazon Redshift cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The identifier of the cluster from which to get the logging status.</p> <p>Example: <code>examplecluster</code> </p>
  ##   Version: JString (required)
  section = newJObject()
  var valid_613073 = query.getOrDefault("Action")
  valid_613073 = validateParameter(valid_613073, JString, required = true,
                                 default = newJString("DescribeLoggingStatus"))
  if valid_613073 != nil:
    section.add "Action", valid_613073
  var valid_613074 = query.getOrDefault("ClusterIdentifier")
  valid_613074 = validateParameter(valid_613074, JString, required = true,
                                 default = nil)
  if valid_613074 != nil:
    section.add "ClusterIdentifier", valid_613074
  var valid_613075 = query.getOrDefault("Version")
  valid_613075 = validateParameter(valid_613075, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_613075 != nil:
    section.add "Version", valid_613075
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613076 = header.getOrDefault("X-Amz-Signature")
  valid_613076 = validateParameter(valid_613076, JString, required = false,
                                 default = nil)
  if valid_613076 != nil:
    section.add "X-Amz-Signature", valid_613076
  var valid_613077 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613077 = validateParameter(valid_613077, JString, required = false,
                                 default = nil)
  if valid_613077 != nil:
    section.add "X-Amz-Content-Sha256", valid_613077
  var valid_613078 = header.getOrDefault("X-Amz-Date")
  valid_613078 = validateParameter(valid_613078, JString, required = false,
                                 default = nil)
  if valid_613078 != nil:
    section.add "X-Amz-Date", valid_613078
  var valid_613079 = header.getOrDefault("X-Amz-Credential")
  valid_613079 = validateParameter(valid_613079, JString, required = false,
                                 default = nil)
  if valid_613079 != nil:
    section.add "X-Amz-Credential", valid_613079
  var valid_613080 = header.getOrDefault("X-Amz-Security-Token")
  valid_613080 = validateParameter(valid_613080, JString, required = false,
                                 default = nil)
  if valid_613080 != nil:
    section.add "X-Amz-Security-Token", valid_613080
  var valid_613081 = header.getOrDefault("X-Amz-Algorithm")
  valid_613081 = validateParameter(valid_613081, JString, required = false,
                                 default = nil)
  if valid_613081 != nil:
    section.add "X-Amz-Algorithm", valid_613081
  var valid_613082 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613082 = validateParameter(valid_613082, JString, required = false,
                                 default = nil)
  if valid_613082 != nil:
    section.add "X-Amz-SignedHeaders", valid_613082
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613083: Call_GetDescribeLoggingStatus_613070; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Describes whether information, such as queries and connection attempts, is being logged for the specified Amazon Redshift cluster.
  ## 
  let valid = call_613083.validator(path, query, header, formData, body)
  let scheme = call_613083.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613083.url(scheme.get, call_613083.host, call_613083.base,
                         call_613083.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613083, url, valid)

proc call*(call_613084: Call_GetDescribeLoggingStatus_613070;
          ClusterIdentifier: string; Action: string = "DescribeLoggingStatus";
          Version: string = "2012-12-01"): Recallable =
  ## getDescribeLoggingStatus
  ## Describes whether information, such as queries and connection attempts, is being logged for the specified Amazon Redshift cluster.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The identifier of the cluster from which to get the logging status.</p> <p>Example: <code>examplecluster</code> </p>
  ##   Version: string (required)
  var query_613085 = newJObject()
  add(query_613085, "Action", newJString(Action))
  add(query_613085, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_613085, "Version", newJString(Version))
  result = call_613084.call(nil, query_613085, nil, nil, nil)

var getDescribeLoggingStatus* = Call_GetDescribeLoggingStatus_613070(
    name: "getDescribeLoggingStatus", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeLoggingStatus",
    validator: validate_GetDescribeLoggingStatus_613071, base: "/",
    url: url_GetDescribeLoggingStatus_613072, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeNodeConfigurationOptions_613125 = ref object of OpenApiRestCall_610642
proc url_PostDescribeNodeConfigurationOptions_613127(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeNodeConfigurationOptions_613126(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns properties of possible node configurations such as node type, number of nodes, and disk usage for the specified action type.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_613128 = query.getOrDefault("Action")
  valid_613128 = validateParameter(valid_613128, JString, required = true, default = newJString(
      "DescribeNodeConfigurationOptions"))
  if valid_613128 != nil:
    section.add "Action", valid_613128
  var valid_613129 = query.getOrDefault("Version")
  valid_613129 = validateParameter(valid_613129, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_613129 != nil:
    section.add "Version", valid_613129
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613130 = header.getOrDefault("X-Amz-Signature")
  valid_613130 = validateParameter(valid_613130, JString, required = false,
                                 default = nil)
  if valid_613130 != nil:
    section.add "X-Amz-Signature", valid_613130
  var valid_613131 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613131 = validateParameter(valid_613131, JString, required = false,
                                 default = nil)
  if valid_613131 != nil:
    section.add "X-Amz-Content-Sha256", valid_613131
  var valid_613132 = header.getOrDefault("X-Amz-Date")
  valid_613132 = validateParameter(valid_613132, JString, required = false,
                                 default = nil)
  if valid_613132 != nil:
    section.add "X-Amz-Date", valid_613132
  var valid_613133 = header.getOrDefault("X-Amz-Credential")
  valid_613133 = validateParameter(valid_613133, JString, required = false,
                                 default = nil)
  if valid_613133 != nil:
    section.add "X-Amz-Credential", valid_613133
  var valid_613134 = header.getOrDefault("X-Amz-Security-Token")
  valid_613134 = validateParameter(valid_613134, JString, required = false,
                                 default = nil)
  if valid_613134 != nil:
    section.add "X-Amz-Security-Token", valid_613134
  var valid_613135 = header.getOrDefault("X-Amz-Algorithm")
  valid_613135 = validateParameter(valid_613135, JString, required = false,
                                 default = nil)
  if valid_613135 != nil:
    section.add "X-Amz-Algorithm", valid_613135
  var valid_613136 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613136 = validateParameter(valid_613136, JString, required = false,
                                 default = nil)
  if valid_613136 != nil:
    section.add "X-Amz-SignedHeaders", valid_613136
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString
  ##                    : The identifier of the cluster to evaluate for possible node configurations.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>500</code> </p> <p>Constraints: minimum 100, maximum 500.</p>
  ##   OwnerAccount: JString
  ##               : The AWS customer account used to create or copy the snapshot. Required if you are restoring a snapshot you do not own, optional if you own the snapshot.
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeNodeConfigurationOptions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   SnapshotIdentifier: JString
  ##                     : The identifier of the snapshot to evaluate for possible node configurations.
  ##   ActionType: JString (required)
  ##             : The action type to evaluate for possible node configurations. Specify "restore-cluster" to get configuration combinations based on an existing snapshot. Specify "recommend-node-config" to get configuration recommendations based on an existing cluster or snapshot. 
  ##   Filter: JArray
  ##         : A set of name, operator, and value items to filter the results.
  section = newJObject()
  var valid_613137 = formData.getOrDefault("ClusterIdentifier")
  valid_613137 = validateParameter(valid_613137, JString, required = false,
                                 default = nil)
  if valid_613137 != nil:
    section.add "ClusterIdentifier", valid_613137
  var valid_613138 = formData.getOrDefault("MaxRecords")
  valid_613138 = validateParameter(valid_613138, JInt, required = false, default = nil)
  if valid_613138 != nil:
    section.add "MaxRecords", valid_613138
  var valid_613139 = formData.getOrDefault("OwnerAccount")
  valid_613139 = validateParameter(valid_613139, JString, required = false,
                                 default = nil)
  if valid_613139 != nil:
    section.add "OwnerAccount", valid_613139
  var valid_613140 = formData.getOrDefault("Marker")
  valid_613140 = validateParameter(valid_613140, JString, required = false,
                                 default = nil)
  if valid_613140 != nil:
    section.add "Marker", valid_613140
  var valid_613141 = formData.getOrDefault("SnapshotIdentifier")
  valid_613141 = validateParameter(valid_613141, JString, required = false,
                                 default = nil)
  if valid_613141 != nil:
    section.add "SnapshotIdentifier", valid_613141
  var valid_613142 = formData.getOrDefault("ActionType")
  valid_613142 = validateParameter(valid_613142, JString, required = true,
                                 default = newJString("restore-cluster"))
  if valid_613142 != nil:
    section.add "ActionType", valid_613142
  var valid_613143 = formData.getOrDefault("Filter")
  valid_613143 = validateParameter(valid_613143, JArray, required = false,
                                 default = nil)
  if valid_613143 != nil:
    section.add "Filter", valid_613143
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613144: Call_PostDescribeNodeConfigurationOptions_613125;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Returns properties of possible node configurations such as node type, number of nodes, and disk usage for the specified action type.
  ## 
  let valid = call_613144.validator(path, query, header, formData, body)
  let scheme = call_613144.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613144.url(scheme.get, call_613144.host, call_613144.base,
                         call_613144.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613144, url, valid)

proc call*(call_613145: Call_PostDescribeNodeConfigurationOptions_613125;
          ClusterIdentifier: string = ""; MaxRecords: int = 0;
          OwnerAccount: string = ""; Marker: string = "";
          SnapshotIdentifier: string = "";
          Action: string = "DescribeNodeConfigurationOptions";
          Version: string = "2012-12-01"; ActionType: string = "restore-cluster";
          Filter: JsonNode = nil): Recallable =
  ## postDescribeNodeConfigurationOptions
  ## Returns properties of possible node configurations such as node type, number of nodes, and disk usage for the specified action type.
  ##   ClusterIdentifier: string
  ##                    : The identifier of the cluster to evaluate for possible node configurations.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>500</code> </p> <p>Constraints: minimum 100, maximum 500.</p>
  ##   OwnerAccount: string
  ##               : The AWS customer account used to create or copy the snapshot. Required if you are restoring a snapshot you do not own, optional if you own the snapshot.
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeNodeConfigurationOptions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   SnapshotIdentifier: string
  ##                     : The identifier of the snapshot to evaluate for possible node configurations.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   ActionType: string (required)
  ##             : The action type to evaluate for possible node configurations. Specify "restore-cluster" to get configuration combinations based on an existing snapshot. Specify "recommend-node-config" to get configuration recommendations based on an existing cluster or snapshot. 
  ##   Filter: JArray
  ##         : A set of name, operator, and value items to filter the results.
  var query_613146 = newJObject()
  var formData_613147 = newJObject()
  add(formData_613147, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_613147, "MaxRecords", newJInt(MaxRecords))
  add(formData_613147, "OwnerAccount", newJString(OwnerAccount))
  add(formData_613147, "Marker", newJString(Marker))
  add(formData_613147, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_613146, "Action", newJString(Action))
  add(query_613146, "Version", newJString(Version))
  add(formData_613147, "ActionType", newJString(ActionType))
  if Filter != nil:
    formData_613147.add "Filter", Filter
  result = call_613145.call(nil, query_613146, nil, formData_613147, nil)

var postDescribeNodeConfigurationOptions* = Call_PostDescribeNodeConfigurationOptions_613125(
    name: "postDescribeNodeConfigurationOptions", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeNodeConfigurationOptions",
    validator: validate_PostDescribeNodeConfigurationOptions_613126, base: "/",
    url: url_PostDescribeNodeConfigurationOptions_613127,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeNodeConfigurationOptions_613103 = ref object of OpenApiRestCall_610642
proc url_GetDescribeNodeConfigurationOptions_613105(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeNodeConfigurationOptions_613104(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns properties of possible node configurations such as node type, number of nodes, and disk usage for the specified action type.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeNodeConfigurationOptions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   SnapshotIdentifier: JString
  ##                     : The identifier of the snapshot to evaluate for possible node configurations.
  ##   ActionType: JString (required)
  ##             : The action type to evaluate for possible node configurations. Specify "restore-cluster" to get configuration combinations based on an existing snapshot. Specify "recommend-node-config" to get configuration recommendations based on an existing cluster or snapshot. 
  ##   Filter: JArray
  ##         : A set of name, operator, and value items to filter the results.
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString
  ##                    : The identifier of the cluster to evaluate for possible node configurations.
  ##   OwnerAccount: JString
  ##               : The AWS customer account used to create or copy the snapshot. Required if you are restoring a snapshot you do not own, optional if you own the snapshot.
  ##   Version: JString (required)
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>500</code> </p> <p>Constraints: minimum 100, maximum 500.</p>
  section = newJObject()
  var valid_613106 = query.getOrDefault("Marker")
  valid_613106 = validateParameter(valid_613106, JString, required = false,
                                 default = nil)
  if valid_613106 != nil:
    section.add "Marker", valid_613106
  var valid_613107 = query.getOrDefault("SnapshotIdentifier")
  valid_613107 = validateParameter(valid_613107, JString, required = false,
                                 default = nil)
  if valid_613107 != nil:
    section.add "SnapshotIdentifier", valid_613107
  var valid_613108 = query.getOrDefault("ActionType")
  valid_613108 = validateParameter(valid_613108, JString, required = true,
                                 default = newJString("restore-cluster"))
  if valid_613108 != nil:
    section.add "ActionType", valid_613108
  var valid_613109 = query.getOrDefault("Filter")
  valid_613109 = validateParameter(valid_613109, JArray, required = false,
                                 default = nil)
  if valid_613109 != nil:
    section.add "Filter", valid_613109
  var valid_613110 = query.getOrDefault("Action")
  valid_613110 = validateParameter(valid_613110, JString, required = true, default = newJString(
      "DescribeNodeConfigurationOptions"))
  if valid_613110 != nil:
    section.add "Action", valid_613110
  var valid_613111 = query.getOrDefault("ClusterIdentifier")
  valid_613111 = validateParameter(valid_613111, JString, required = false,
                                 default = nil)
  if valid_613111 != nil:
    section.add "ClusterIdentifier", valid_613111
  var valid_613112 = query.getOrDefault("OwnerAccount")
  valid_613112 = validateParameter(valid_613112, JString, required = false,
                                 default = nil)
  if valid_613112 != nil:
    section.add "OwnerAccount", valid_613112
  var valid_613113 = query.getOrDefault("Version")
  valid_613113 = validateParameter(valid_613113, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_613113 != nil:
    section.add "Version", valid_613113
  var valid_613114 = query.getOrDefault("MaxRecords")
  valid_613114 = validateParameter(valid_613114, JInt, required = false, default = nil)
  if valid_613114 != nil:
    section.add "MaxRecords", valid_613114
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613115 = header.getOrDefault("X-Amz-Signature")
  valid_613115 = validateParameter(valid_613115, JString, required = false,
                                 default = nil)
  if valid_613115 != nil:
    section.add "X-Amz-Signature", valid_613115
  var valid_613116 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613116 = validateParameter(valid_613116, JString, required = false,
                                 default = nil)
  if valid_613116 != nil:
    section.add "X-Amz-Content-Sha256", valid_613116
  var valid_613117 = header.getOrDefault("X-Amz-Date")
  valid_613117 = validateParameter(valid_613117, JString, required = false,
                                 default = nil)
  if valid_613117 != nil:
    section.add "X-Amz-Date", valid_613117
  var valid_613118 = header.getOrDefault("X-Amz-Credential")
  valid_613118 = validateParameter(valid_613118, JString, required = false,
                                 default = nil)
  if valid_613118 != nil:
    section.add "X-Amz-Credential", valid_613118
  var valid_613119 = header.getOrDefault("X-Amz-Security-Token")
  valid_613119 = validateParameter(valid_613119, JString, required = false,
                                 default = nil)
  if valid_613119 != nil:
    section.add "X-Amz-Security-Token", valid_613119
  var valid_613120 = header.getOrDefault("X-Amz-Algorithm")
  valid_613120 = validateParameter(valid_613120, JString, required = false,
                                 default = nil)
  if valid_613120 != nil:
    section.add "X-Amz-Algorithm", valid_613120
  var valid_613121 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613121 = validateParameter(valid_613121, JString, required = false,
                                 default = nil)
  if valid_613121 != nil:
    section.add "X-Amz-SignedHeaders", valid_613121
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613122: Call_GetDescribeNodeConfigurationOptions_613103;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Returns properties of possible node configurations such as node type, number of nodes, and disk usage for the specified action type.
  ## 
  let valid = call_613122.validator(path, query, header, formData, body)
  let scheme = call_613122.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613122.url(scheme.get, call_613122.host, call_613122.base,
                         call_613122.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613122, url, valid)

proc call*(call_613123: Call_GetDescribeNodeConfigurationOptions_613103;
          Marker: string = ""; SnapshotIdentifier: string = "";
          ActionType: string = "restore-cluster"; Filter: JsonNode = nil;
          Action: string = "DescribeNodeConfigurationOptions";
          ClusterIdentifier: string = ""; OwnerAccount: string = "";
          Version: string = "2012-12-01"; MaxRecords: int = 0): Recallable =
  ## getDescribeNodeConfigurationOptions
  ## Returns properties of possible node configurations such as node type, number of nodes, and disk usage for the specified action type.
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeNodeConfigurationOptions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   SnapshotIdentifier: string
  ##                     : The identifier of the snapshot to evaluate for possible node configurations.
  ##   ActionType: string (required)
  ##             : The action type to evaluate for possible node configurations. Specify "restore-cluster" to get configuration combinations based on an existing snapshot. Specify "recommend-node-config" to get configuration recommendations based on an existing cluster or snapshot. 
  ##   Filter: JArray
  ##         : A set of name, operator, and value items to filter the results.
  ##   Action: string (required)
  ##   ClusterIdentifier: string
  ##                    : The identifier of the cluster to evaluate for possible node configurations.
  ##   OwnerAccount: string
  ##               : The AWS customer account used to create or copy the snapshot. Required if you are restoring a snapshot you do not own, optional if you own the snapshot.
  ##   Version: string (required)
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>500</code> </p> <p>Constraints: minimum 100, maximum 500.</p>
  var query_613124 = newJObject()
  add(query_613124, "Marker", newJString(Marker))
  add(query_613124, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_613124, "ActionType", newJString(ActionType))
  if Filter != nil:
    query_613124.add "Filter", Filter
  add(query_613124, "Action", newJString(Action))
  add(query_613124, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_613124, "OwnerAccount", newJString(OwnerAccount))
  add(query_613124, "Version", newJString(Version))
  add(query_613124, "MaxRecords", newJInt(MaxRecords))
  result = call_613123.call(nil, query_613124, nil, nil, nil)

var getDescribeNodeConfigurationOptions* = Call_GetDescribeNodeConfigurationOptions_613103(
    name: "getDescribeNodeConfigurationOptions", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeNodeConfigurationOptions",
    validator: validate_GetDescribeNodeConfigurationOptions_613104, base: "/",
    url: url_GetDescribeNodeConfigurationOptions_613105,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeOrderableClusterOptions_613167 = ref object of OpenApiRestCall_610642
proc url_PostDescribeOrderableClusterOptions_613169(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeOrderableClusterOptions_613168(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns a list of orderable cluster options. Before you create a new cluster you can use this operation to find what options are available, such as the EC2 Availability Zones (AZ) in the specific AWS Region that you can specify, and the node types you can request. The node types differ by available storage, memory, CPU and price. With the cost involved you might want to obtain a list of cluster options in the specific region and specify values when creating a cluster. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_613170 = query.getOrDefault("Action")
  valid_613170 = validateParameter(valid_613170, JString, required = true, default = newJString(
      "DescribeOrderableClusterOptions"))
  if valid_613170 != nil:
    section.add "Action", valid_613170
  var valid_613171 = query.getOrDefault("Version")
  valid_613171 = validateParameter(valid_613171, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_613171 != nil:
    section.add "Version", valid_613171
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613172 = header.getOrDefault("X-Amz-Signature")
  valid_613172 = validateParameter(valid_613172, JString, required = false,
                                 default = nil)
  if valid_613172 != nil:
    section.add "X-Amz-Signature", valid_613172
  var valid_613173 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613173 = validateParameter(valid_613173, JString, required = false,
                                 default = nil)
  if valid_613173 != nil:
    section.add "X-Amz-Content-Sha256", valid_613173
  var valid_613174 = header.getOrDefault("X-Amz-Date")
  valid_613174 = validateParameter(valid_613174, JString, required = false,
                                 default = nil)
  if valid_613174 != nil:
    section.add "X-Amz-Date", valid_613174
  var valid_613175 = header.getOrDefault("X-Amz-Credential")
  valid_613175 = validateParameter(valid_613175, JString, required = false,
                                 default = nil)
  if valid_613175 != nil:
    section.add "X-Amz-Credential", valid_613175
  var valid_613176 = header.getOrDefault("X-Amz-Security-Token")
  valid_613176 = validateParameter(valid_613176, JString, required = false,
                                 default = nil)
  if valid_613176 != nil:
    section.add "X-Amz-Security-Token", valid_613176
  var valid_613177 = header.getOrDefault("X-Amz-Algorithm")
  valid_613177 = validateParameter(valid_613177, JString, required = false,
                                 default = nil)
  if valid_613177 != nil:
    section.add "X-Amz-Algorithm", valid_613177
  var valid_613178 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613178 = validateParameter(valid_613178, JString, required = false,
                                 default = nil)
  if valid_613178 != nil:
    section.add "X-Amz-SignedHeaders", valid_613178
  result.add "header", section
  ## parameters in `formData` object:
  ##   NodeType: JString
  ##           : The node type filter value. Specify this parameter to show only the available offerings matching the specified node type.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeOrderableClusterOptions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   ClusterVersion: JString
  ##                 : <p>The version filter value. Specify this parameter to show only the available offerings matching the specified version.</p> <p>Default: All versions.</p> <p>Constraints: Must be one of the version returned from <a>DescribeClusterVersions</a>.</p>
  section = newJObject()
  var valid_613179 = formData.getOrDefault("NodeType")
  valid_613179 = validateParameter(valid_613179, JString, required = false,
                                 default = nil)
  if valid_613179 != nil:
    section.add "NodeType", valid_613179
  var valid_613180 = formData.getOrDefault("MaxRecords")
  valid_613180 = validateParameter(valid_613180, JInt, required = false, default = nil)
  if valid_613180 != nil:
    section.add "MaxRecords", valid_613180
  var valid_613181 = formData.getOrDefault("Marker")
  valid_613181 = validateParameter(valid_613181, JString, required = false,
                                 default = nil)
  if valid_613181 != nil:
    section.add "Marker", valid_613181
  var valid_613182 = formData.getOrDefault("ClusterVersion")
  valid_613182 = validateParameter(valid_613182, JString, required = false,
                                 default = nil)
  if valid_613182 != nil:
    section.add "ClusterVersion", valid_613182
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613183: Call_PostDescribeOrderableClusterOptions_613167;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Returns a list of orderable cluster options. Before you create a new cluster you can use this operation to find what options are available, such as the EC2 Availability Zones (AZ) in the specific AWS Region that you can specify, and the node types you can request. The node types differ by available storage, memory, CPU and price. With the cost involved you might want to obtain a list of cluster options in the specific region and specify values when creating a cluster. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.
  ## 
  let valid = call_613183.validator(path, query, header, formData, body)
  let scheme = call_613183.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613183.url(scheme.get, call_613183.host, call_613183.base,
                         call_613183.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613183, url, valid)

proc call*(call_613184: Call_PostDescribeOrderableClusterOptions_613167;
          NodeType: string = ""; MaxRecords: int = 0; Marker: string = "";
          Action: string = "DescribeOrderableClusterOptions";
          ClusterVersion: string = ""; Version: string = "2012-12-01"): Recallable =
  ## postDescribeOrderableClusterOptions
  ## Returns a list of orderable cluster options. Before you create a new cluster you can use this operation to find what options are available, such as the EC2 Availability Zones (AZ) in the specific AWS Region that you can specify, and the node types you can request. The node types differ by available storage, memory, CPU and price. With the cost involved you might want to obtain a list of cluster options in the specific region and specify values when creating a cluster. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.
  ##   NodeType: string
  ##           : The node type filter value. Specify this parameter to show only the available offerings matching the specified node type.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeOrderableClusterOptions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Action: string (required)
  ##   ClusterVersion: string
  ##                 : <p>The version filter value. Specify this parameter to show only the available offerings matching the specified version.</p> <p>Default: All versions.</p> <p>Constraints: Must be one of the version returned from <a>DescribeClusterVersions</a>.</p>
  ##   Version: string (required)
  var query_613185 = newJObject()
  var formData_613186 = newJObject()
  add(formData_613186, "NodeType", newJString(NodeType))
  add(formData_613186, "MaxRecords", newJInt(MaxRecords))
  add(formData_613186, "Marker", newJString(Marker))
  add(query_613185, "Action", newJString(Action))
  add(formData_613186, "ClusterVersion", newJString(ClusterVersion))
  add(query_613185, "Version", newJString(Version))
  result = call_613184.call(nil, query_613185, nil, formData_613186, nil)

var postDescribeOrderableClusterOptions* = Call_PostDescribeOrderableClusterOptions_613167(
    name: "postDescribeOrderableClusterOptions", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeOrderableClusterOptions",
    validator: validate_PostDescribeOrderableClusterOptions_613168, base: "/",
    url: url_PostDescribeOrderableClusterOptions_613169,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeOrderableClusterOptions_613148 = ref object of OpenApiRestCall_610642
proc url_GetDescribeOrderableClusterOptions_613150(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeOrderableClusterOptions_613149(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns a list of orderable cluster options. Before you create a new cluster you can use this operation to find what options are available, such as the EC2 Availability Zones (AZ) in the specific AWS Region that you can specify, and the node types you can request. The node types differ by available storage, memory, CPU and price. With the cost involved you might want to obtain a list of cluster options in the specific region and specify values when creating a cluster. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeOrderableClusterOptions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   ClusterVersion: JString
  ##                 : <p>The version filter value. Specify this parameter to show only the available offerings matching the specified version.</p> <p>Default: All versions.</p> <p>Constraints: Must be one of the version returned from <a>DescribeClusterVersions</a>.</p>
  ##   NodeType: JString
  ##           : The node type filter value. Specify this parameter to show only the available offerings matching the specified node type.
  ##   Action: JString (required)
  ##   Version: JString (required)
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  section = newJObject()
  var valid_613151 = query.getOrDefault("Marker")
  valid_613151 = validateParameter(valid_613151, JString, required = false,
                                 default = nil)
  if valid_613151 != nil:
    section.add "Marker", valid_613151
  var valid_613152 = query.getOrDefault("ClusterVersion")
  valid_613152 = validateParameter(valid_613152, JString, required = false,
                                 default = nil)
  if valid_613152 != nil:
    section.add "ClusterVersion", valid_613152
  var valid_613153 = query.getOrDefault("NodeType")
  valid_613153 = validateParameter(valid_613153, JString, required = false,
                                 default = nil)
  if valid_613153 != nil:
    section.add "NodeType", valid_613153
  var valid_613154 = query.getOrDefault("Action")
  valid_613154 = validateParameter(valid_613154, JString, required = true, default = newJString(
      "DescribeOrderableClusterOptions"))
  if valid_613154 != nil:
    section.add "Action", valid_613154
  var valid_613155 = query.getOrDefault("Version")
  valid_613155 = validateParameter(valid_613155, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_613155 != nil:
    section.add "Version", valid_613155
  var valid_613156 = query.getOrDefault("MaxRecords")
  valid_613156 = validateParameter(valid_613156, JInt, required = false, default = nil)
  if valid_613156 != nil:
    section.add "MaxRecords", valid_613156
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613157 = header.getOrDefault("X-Amz-Signature")
  valid_613157 = validateParameter(valid_613157, JString, required = false,
                                 default = nil)
  if valid_613157 != nil:
    section.add "X-Amz-Signature", valid_613157
  var valid_613158 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613158 = validateParameter(valid_613158, JString, required = false,
                                 default = nil)
  if valid_613158 != nil:
    section.add "X-Amz-Content-Sha256", valid_613158
  var valid_613159 = header.getOrDefault("X-Amz-Date")
  valid_613159 = validateParameter(valid_613159, JString, required = false,
                                 default = nil)
  if valid_613159 != nil:
    section.add "X-Amz-Date", valid_613159
  var valid_613160 = header.getOrDefault("X-Amz-Credential")
  valid_613160 = validateParameter(valid_613160, JString, required = false,
                                 default = nil)
  if valid_613160 != nil:
    section.add "X-Amz-Credential", valid_613160
  var valid_613161 = header.getOrDefault("X-Amz-Security-Token")
  valid_613161 = validateParameter(valid_613161, JString, required = false,
                                 default = nil)
  if valid_613161 != nil:
    section.add "X-Amz-Security-Token", valid_613161
  var valid_613162 = header.getOrDefault("X-Amz-Algorithm")
  valid_613162 = validateParameter(valid_613162, JString, required = false,
                                 default = nil)
  if valid_613162 != nil:
    section.add "X-Amz-Algorithm", valid_613162
  var valid_613163 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613163 = validateParameter(valid_613163, JString, required = false,
                                 default = nil)
  if valid_613163 != nil:
    section.add "X-Amz-SignedHeaders", valid_613163
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613164: Call_GetDescribeOrderableClusterOptions_613148;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Returns a list of orderable cluster options. Before you create a new cluster you can use this operation to find what options are available, such as the EC2 Availability Zones (AZ) in the specific AWS Region that you can specify, and the node types you can request. The node types differ by available storage, memory, CPU and price. With the cost involved you might want to obtain a list of cluster options in the specific region and specify values when creating a cluster. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.
  ## 
  let valid = call_613164.validator(path, query, header, formData, body)
  let scheme = call_613164.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613164.url(scheme.get, call_613164.host, call_613164.base,
                         call_613164.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613164, url, valid)

proc call*(call_613165: Call_GetDescribeOrderableClusterOptions_613148;
          Marker: string = ""; ClusterVersion: string = ""; NodeType: string = "";
          Action: string = "DescribeOrderableClusterOptions";
          Version: string = "2012-12-01"; MaxRecords: int = 0): Recallable =
  ## getDescribeOrderableClusterOptions
  ## Returns a list of orderable cluster options. Before you create a new cluster you can use this operation to find what options are available, such as the EC2 Availability Zones (AZ) in the specific AWS Region that you can specify, and the node types you can request. The node types differ by available storage, memory, CPU and price. With the cost involved you might want to obtain a list of cluster options in the specific region and specify values when creating a cluster. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeOrderableClusterOptions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   ClusterVersion: string
  ##                 : <p>The version filter value. Specify this parameter to show only the available offerings matching the specified version.</p> <p>Default: All versions.</p> <p>Constraints: Must be one of the version returned from <a>DescribeClusterVersions</a>.</p>
  ##   NodeType: string
  ##           : The node type filter value. Specify this parameter to show only the available offerings matching the specified node type.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  var query_613166 = newJObject()
  add(query_613166, "Marker", newJString(Marker))
  add(query_613166, "ClusterVersion", newJString(ClusterVersion))
  add(query_613166, "NodeType", newJString(NodeType))
  add(query_613166, "Action", newJString(Action))
  add(query_613166, "Version", newJString(Version))
  add(query_613166, "MaxRecords", newJInt(MaxRecords))
  result = call_613165.call(nil, query_613166, nil, nil, nil)

var getDescribeOrderableClusterOptions* = Call_GetDescribeOrderableClusterOptions_613148(
    name: "getDescribeOrderableClusterOptions", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeOrderableClusterOptions",
    validator: validate_GetDescribeOrderableClusterOptions_613149, base: "/",
    url: url_GetDescribeOrderableClusterOptions_613150,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeReservedNodeOfferings_613205 = ref object of OpenApiRestCall_610642
proc url_PostDescribeReservedNodeOfferings_613207(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeReservedNodeOfferings_613206(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns a list of the available reserved node offerings by Amazon Redshift with their descriptions including the node type, the fixed and recurring costs of reserving the node and duration the node will be reserved for you. These descriptions help you determine which reserve node offering you want to purchase. You then use the unique offering ID in you call to <a>PurchaseReservedNodeOffering</a> to reserve one or more nodes for your Amazon Redshift cluster. </p> <p> For more information about reserved node offerings, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_613208 = query.getOrDefault("Action")
  valid_613208 = validateParameter(valid_613208, JString, required = true, default = newJString(
      "DescribeReservedNodeOfferings"))
  if valid_613208 != nil:
    section.add "Action", valid_613208
  var valid_613209 = query.getOrDefault("Version")
  valid_613209 = validateParameter(valid_613209, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_613209 != nil:
    section.add "Version", valid_613209
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613210 = header.getOrDefault("X-Amz-Signature")
  valid_613210 = validateParameter(valid_613210, JString, required = false,
                                 default = nil)
  if valid_613210 != nil:
    section.add "X-Amz-Signature", valid_613210
  var valid_613211 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613211 = validateParameter(valid_613211, JString, required = false,
                                 default = nil)
  if valid_613211 != nil:
    section.add "X-Amz-Content-Sha256", valid_613211
  var valid_613212 = header.getOrDefault("X-Amz-Date")
  valid_613212 = validateParameter(valid_613212, JString, required = false,
                                 default = nil)
  if valid_613212 != nil:
    section.add "X-Amz-Date", valid_613212
  var valid_613213 = header.getOrDefault("X-Amz-Credential")
  valid_613213 = validateParameter(valid_613213, JString, required = false,
                                 default = nil)
  if valid_613213 != nil:
    section.add "X-Amz-Credential", valid_613213
  var valid_613214 = header.getOrDefault("X-Amz-Security-Token")
  valid_613214 = validateParameter(valid_613214, JString, required = false,
                                 default = nil)
  if valid_613214 != nil:
    section.add "X-Amz-Security-Token", valid_613214
  var valid_613215 = header.getOrDefault("X-Amz-Algorithm")
  valid_613215 = validateParameter(valid_613215, JString, required = false,
                                 default = nil)
  if valid_613215 != nil:
    section.add "X-Amz-Algorithm", valid_613215
  var valid_613216 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613216 = validateParameter(valid_613216, JString, required = false,
                                 default = nil)
  if valid_613216 != nil:
    section.add "X-Amz-SignedHeaders", valid_613216
  result.add "header", section
  ## parameters in `formData` object:
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   ReservedNodeOfferingId: JString
  ##                         : The unique identifier for the offering.
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeReservedNodeOfferings</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  section = newJObject()
  var valid_613217 = formData.getOrDefault("MaxRecords")
  valid_613217 = validateParameter(valid_613217, JInt, required = false, default = nil)
  if valid_613217 != nil:
    section.add "MaxRecords", valid_613217
  var valid_613218 = formData.getOrDefault("ReservedNodeOfferingId")
  valid_613218 = validateParameter(valid_613218, JString, required = false,
                                 default = nil)
  if valid_613218 != nil:
    section.add "ReservedNodeOfferingId", valid_613218
  var valid_613219 = formData.getOrDefault("Marker")
  valid_613219 = validateParameter(valid_613219, JString, required = false,
                                 default = nil)
  if valid_613219 != nil:
    section.add "Marker", valid_613219
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613220: Call_PostDescribeReservedNodeOfferings_613205;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Returns a list of the available reserved node offerings by Amazon Redshift with their descriptions including the node type, the fixed and recurring costs of reserving the node and duration the node will be reserved for you. These descriptions help you determine which reserve node offering you want to purchase. You then use the unique offering ID in you call to <a>PurchaseReservedNodeOffering</a> to reserve one or more nodes for your Amazon Redshift cluster. </p> <p> For more information about reserved node offerings, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_613220.validator(path, query, header, formData, body)
  let scheme = call_613220.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613220.url(scheme.get, call_613220.host, call_613220.base,
                         call_613220.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613220, url, valid)

proc call*(call_613221: Call_PostDescribeReservedNodeOfferings_613205;
          MaxRecords: int = 0; ReservedNodeOfferingId: string = ""; Marker: string = "";
          Action: string = "DescribeReservedNodeOfferings";
          Version: string = "2012-12-01"): Recallable =
  ## postDescribeReservedNodeOfferings
  ## <p>Returns a list of the available reserved node offerings by Amazon Redshift with their descriptions including the node type, the fixed and recurring costs of reserving the node and duration the node will be reserved for you. These descriptions help you determine which reserve node offering you want to purchase. You then use the unique offering ID in you call to <a>PurchaseReservedNodeOffering</a> to reserve one or more nodes for your Amazon Redshift cluster. </p> <p> For more information about reserved node offerings, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   ReservedNodeOfferingId: string
  ##                         : The unique identifier for the offering.
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeReservedNodeOfferings</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Action: string (required)
  ##   Version: string (required)
  var query_613222 = newJObject()
  var formData_613223 = newJObject()
  add(formData_613223, "MaxRecords", newJInt(MaxRecords))
  add(formData_613223, "ReservedNodeOfferingId",
      newJString(ReservedNodeOfferingId))
  add(formData_613223, "Marker", newJString(Marker))
  add(query_613222, "Action", newJString(Action))
  add(query_613222, "Version", newJString(Version))
  result = call_613221.call(nil, query_613222, nil, formData_613223, nil)

var postDescribeReservedNodeOfferings* = Call_PostDescribeReservedNodeOfferings_613205(
    name: "postDescribeReservedNodeOfferings", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeReservedNodeOfferings",
    validator: validate_PostDescribeReservedNodeOfferings_613206, base: "/",
    url: url_PostDescribeReservedNodeOfferings_613207,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeReservedNodeOfferings_613187 = ref object of OpenApiRestCall_610642
proc url_GetDescribeReservedNodeOfferings_613189(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeReservedNodeOfferings_613188(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns a list of the available reserved node offerings by Amazon Redshift with their descriptions including the node type, the fixed and recurring costs of reserving the node and duration the node will be reserved for you. These descriptions help you determine which reserve node offering you want to purchase. You then use the unique offering ID in you call to <a>PurchaseReservedNodeOffering</a> to reserve one or more nodes for your Amazon Redshift cluster. </p> <p> For more information about reserved node offerings, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeReservedNodeOfferings</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   ReservedNodeOfferingId: JString
  ##                         : The unique identifier for the offering.
  ##   Action: JString (required)
  ##   Version: JString (required)
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  section = newJObject()
  var valid_613190 = query.getOrDefault("Marker")
  valid_613190 = validateParameter(valid_613190, JString, required = false,
                                 default = nil)
  if valid_613190 != nil:
    section.add "Marker", valid_613190
  var valid_613191 = query.getOrDefault("ReservedNodeOfferingId")
  valid_613191 = validateParameter(valid_613191, JString, required = false,
                                 default = nil)
  if valid_613191 != nil:
    section.add "ReservedNodeOfferingId", valid_613191
  var valid_613192 = query.getOrDefault("Action")
  valid_613192 = validateParameter(valid_613192, JString, required = true, default = newJString(
      "DescribeReservedNodeOfferings"))
  if valid_613192 != nil:
    section.add "Action", valid_613192
  var valid_613193 = query.getOrDefault("Version")
  valid_613193 = validateParameter(valid_613193, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_613193 != nil:
    section.add "Version", valid_613193
  var valid_613194 = query.getOrDefault("MaxRecords")
  valid_613194 = validateParameter(valid_613194, JInt, required = false, default = nil)
  if valid_613194 != nil:
    section.add "MaxRecords", valid_613194
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613195 = header.getOrDefault("X-Amz-Signature")
  valid_613195 = validateParameter(valid_613195, JString, required = false,
                                 default = nil)
  if valid_613195 != nil:
    section.add "X-Amz-Signature", valid_613195
  var valid_613196 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613196 = validateParameter(valid_613196, JString, required = false,
                                 default = nil)
  if valid_613196 != nil:
    section.add "X-Amz-Content-Sha256", valid_613196
  var valid_613197 = header.getOrDefault("X-Amz-Date")
  valid_613197 = validateParameter(valid_613197, JString, required = false,
                                 default = nil)
  if valid_613197 != nil:
    section.add "X-Amz-Date", valid_613197
  var valid_613198 = header.getOrDefault("X-Amz-Credential")
  valid_613198 = validateParameter(valid_613198, JString, required = false,
                                 default = nil)
  if valid_613198 != nil:
    section.add "X-Amz-Credential", valid_613198
  var valid_613199 = header.getOrDefault("X-Amz-Security-Token")
  valid_613199 = validateParameter(valid_613199, JString, required = false,
                                 default = nil)
  if valid_613199 != nil:
    section.add "X-Amz-Security-Token", valid_613199
  var valid_613200 = header.getOrDefault("X-Amz-Algorithm")
  valid_613200 = validateParameter(valid_613200, JString, required = false,
                                 default = nil)
  if valid_613200 != nil:
    section.add "X-Amz-Algorithm", valid_613200
  var valid_613201 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613201 = validateParameter(valid_613201, JString, required = false,
                                 default = nil)
  if valid_613201 != nil:
    section.add "X-Amz-SignedHeaders", valid_613201
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613202: Call_GetDescribeReservedNodeOfferings_613187;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Returns a list of the available reserved node offerings by Amazon Redshift with their descriptions including the node type, the fixed and recurring costs of reserving the node and duration the node will be reserved for you. These descriptions help you determine which reserve node offering you want to purchase. You then use the unique offering ID in you call to <a>PurchaseReservedNodeOffering</a> to reserve one or more nodes for your Amazon Redshift cluster. </p> <p> For more information about reserved node offerings, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_613202.validator(path, query, header, formData, body)
  let scheme = call_613202.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613202.url(scheme.get, call_613202.host, call_613202.base,
                         call_613202.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613202, url, valid)

proc call*(call_613203: Call_GetDescribeReservedNodeOfferings_613187;
          Marker: string = ""; ReservedNodeOfferingId: string = "";
          Action: string = "DescribeReservedNodeOfferings";
          Version: string = "2012-12-01"; MaxRecords: int = 0): Recallable =
  ## getDescribeReservedNodeOfferings
  ## <p>Returns a list of the available reserved node offerings by Amazon Redshift with their descriptions including the node type, the fixed and recurring costs of reserving the node and duration the node will be reserved for you. These descriptions help you determine which reserve node offering you want to purchase. You then use the unique offering ID in you call to <a>PurchaseReservedNodeOffering</a> to reserve one or more nodes for your Amazon Redshift cluster. </p> <p> For more information about reserved node offerings, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeReservedNodeOfferings</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   ReservedNodeOfferingId: string
  ##                         : The unique identifier for the offering.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  var query_613204 = newJObject()
  add(query_613204, "Marker", newJString(Marker))
  add(query_613204, "ReservedNodeOfferingId", newJString(ReservedNodeOfferingId))
  add(query_613204, "Action", newJString(Action))
  add(query_613204, "Version", newJString(Version))
  add(query_613204, "MaxRecords", newJInt(MaxRecords))
  result = call_613203.call(nil, query_613204, nil, nil, nil)

var getDescribeReservedNodeOfferings* = Call_GetDescribeReservedNodeOfferings_613187(
    name: "getDescribeReservedNodeOfferings", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeReservedNodeOfferings",
    validator: validate_GetDescribeReservedNodeOfferings_613188, base: "/",
    url: url_GetDescribeReservedNodeOfferings_613189,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeReservedNodes_613242 = ref object of OpenApiRestCall_610642
proc url_PostDescribeReservedNodes_613244(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeReservedNodes_613243(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns the descriptions of the reserved nodes.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_613245 = query.getOrDefault("Action")
  valid_613245 = validateParameter(valid_613245, JString, required = true,
                                 default = newJString("DescribeReservedNodes"))
  if valid_613245 != nil:
    section.add "Action", valid_613245
  var valid_613246 = query.getOrDefault("Version")
  valid_613246 = validateParameter(valid_613246, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_613246 != nil:
    section.add "Version", valid_613246
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613247 = header.getOrDefault("X-Amz-Signature")
  valid_613247 = validateParameter(valid_613247, JString, required = false,
                                 default = nil)
  if valid_613247 != nil:
    section.add "X-Amz-Signature", valid_613247
  var valid_613248 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613248 = validateParameter(valid_613248, JString, required = false,
                                 default = nil)
  if valid_613248 != nil:
    section.add "X-Amz-Content-Sha256", valid_613248
  var valid_613249 = header.getOrDefault("X-Amz-Date")
  valid_613249 = validateParameter(valid_613249, JString, required = false,
                                 default = nil)
  if valid_613249 != nil:
    section.add "X-Amz-Date", valid_613249
  var valid_613250 = header.getOrDefault("X-Amz-Credential")
  valid_613250 = validateParameter(valid_613250, JString, required = false,
                                 default = nil)
  if valid_613250 != nil:
    section.add "X-Amz-Credential", valid_613250
  var valid_613251 = header.getOrDefault("X-Amz-Security-Token")
  valid_613251 = validateParameter(valid_613251, JString, required = false,
                                 default = nil)
  if valid_613251 != nil:
    section.add "X-Amz-Security-Token", valid_613251
  var valid_613252 = header.getOrDefault("X-Amz-Algorithm")
  valid_613252 = validateParameter(valid_613252, JString, required = false,
                                 default = nil)
  if valid_613252 != nil:
    section.add "X-Amz-Algorithm", valid_613252
  var valid_613253 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613253 = validateParameter(valid_613253, JString, required = false,
                                 default = nil)
  if valid_613253 != nil:
    section.add "X-Amz-SignedHeaders", valid_613253
  result.add "header", section
  ## parameters in `formData` object:
  ##   ReservedNodeId: JString
  ##                 : Identifier for the node reservation.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeReservedNodes</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  section = newJObject()
  var valid_613254 = formData.getOrDefault("ReservedNodeId")
  valid_613254 = validateParameter(valid_613254, JString, required = false,
                                 default = nil)
  if valid_613254 != nil:
    section.add "ReservedNodeId", valid_613254
  var valid_613255 = formData.getOrDefault("MaxRecords")
  valid_613255 = validateParameter(valid_613255, JInt, required = false, default = nil)
  if valid_613255 != nil:
    section.add "MaxRecords", valid_613255
  var valid_613256 = formData.getOrDefault("Marker")
  valid_613256 = validateParameter(valid_613256, JString, required = false,
                                 default = nil)
  if valid_613256 != nil:
    section.add "Marker", valid_613256
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613257: Call_PostDescribeReservedNodes_613242; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns the descriptions of the reserved nodes.
  ## 
  let valid = call_613257.validator(path, query, header, formData, body)
  let scheme = call_613257.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613257.url(scheme.get, call_613257.host, call_613257.base,
                         call_613257.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613257, url, valid)

proc call*(call_613258: Call_PostDescribeReservedNodes_613242;
          ReservedNodeId: string = ""; MaxRecords: int = 0; Marker: string = "";
          Action: string = "DescribeReservedNodes"; Version: string = "2012-12-01"): Recallable =
  ## postDescribeReservedNodes
  ## Returns the descriptions of the reserved nodes.
  ##   ReservedNodeId: string
  ##                 : Identifier for the node reservation.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeReservedNodes</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Action: string (required)
  ##   Version: string (required)
  var query_613259 = newJObject()
  var formData_613260 = newJObject()
  add(formData_613260, "ReservedNodeId", newJString(ReservedNodeId))
  add(formData_613260, "MaxRecords", newJInt(MaxRecords))
  add(formData_613260, "Marker", newJString(Marker))
  add(query_613259, "Action", newJString(Action))
  add(query_613259, "Version", newJString(Version))
  result = call_613258.call(nil, query_613259, nil, formData_613260, nil)

var postDescribeReservedNodes* = Call_PostDescribeReservedNodes_613242(
    name: "postDescribeReservedNodes", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeReservedNodes",
    validator: validate_PostDescribeReservedNodes_613243, base: "/",
    url: url_PostDescribeReservedNodes_613244,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeReservedNodes_613224 = ref object of OpenApiRestCall_610642
proc url_GetDescribeReservedNodes_613226(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeReservedNodes_613225(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns the descriptions of the reserved nodes.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeReservedNodes</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Action: JString (required)
  ##   ReservedNodeId: JString
  ##                 : Identifier for the node reservation.
  ##   Version: JString (required)
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  section = newJObject()
  var valid_613227 = query.getOrDefault("Marker")
  valid_613227 = validateParameter(valid_613227, JString, required = false,
                                 default = nil)
  if valid_613227 != nil:
    section.add "Marker", valid_613227
  var valid_613228 = query.getOrDefault("Action")
  valid_613228 = validateParameter(valid_613228, JString, required = true,
                                 default = newJString("DescribeReservedNodes"))
  if valid_613228 != nil:
    section.add "Action", valid_613228
  var valid_613229 = query.getOrDefault("ReservedNodeId")
  valid_613229 = validateParameter(valid_613229, JString, required = false,
                                 default = nil)
  if valid_613229 != nil:
    section.add "ReservedNodeId", valid_613229
  var valid_613230 = query.getOrDefault("Version")
  valid_613230 = validateParameter(valid_613230, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_613230 != nil:
    section.add "Version", valid_613230
  var valid_613231 = query.getOrDefault("MaxRecords")
  valid_613231 = validateParameter(valid_613231, JInt, required = false, default = nil)
  if valid_613231 != nil:
    section.add "MaxRecords", valid_613231
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613232 = header.getOrDefault("X-Amz-Signature")
  valid_613232 = validateParameter(valid_613232, JString, required = false,
                                 default = nil)
  if valid_613232 != nil:
    section.add "X-Amz-Signature", valid_613232
  var valid_613233 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613233 = validateParameter(valid_613233, JString, required = false,
                                 default = nil)
  if valid_613233 != nil:
    section.add "X-Amz-Content-Sha256", valid_613233
  var valid_613234 = header.getOrDefault("X-Amz-Date")
  valid_613234 = validateParameter(valid_613234, JString, required = false,
                                 default = nil)
  if valid_613234 != nil:
    section.add "X-Amz-Date", valid_613234
  var valid_613235 = header.getOrDefault("X-Amz-Credential")
  valid_613235 = validateParameter(valid_613235, JString, required = false,
                                 default = nil)
  if valid_613235 != nil:
    section.add "X-Amz-Credential", valid_613235
  var valid_613236 = header.getOrDefault("X-Amz-Security-Token")
  valid_613236 = validateParameter(valid_613236, JString, required = false,
                                 default = nil)
  if valid_613236 != nil:
    section.add "X-Amz-Security-Token", valid_613236
  var valid_613237 = header.getOrDefault("X-Amz-Algorithm")
  valid_613237 = validateParameter(valid_613237, JString, required = false,
                                 default = nil)
  if valid_613237 != nil:
    section.add "X-Amz-Algorithm", valid_613237
  var valid_613238 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613238 = validateParameter(valid_613238, JString, required = false,
                                 default = nil)
  if valid_613238 != nil:
    section.add "X-Amz-SignedHeaders", valid_613238
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613239: Call_GetDescribeReservedNodes_613224; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns the descriptions of the reserved nodes.
  ## 
  let valid = call_613239.validator(path, query, header, formData, body)
  let scheme = call_613239.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613239.url(scheme.get, call_613239.host, call_613239.base,
                         call_613239.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613239, url, valid)

proc call*(call_613240: Call_GetDescribeReservedNodes_613224; Marker: string = "";
          Action: string = "DescribeReservedNodes"; ReservedNodeId: string = "";
          Version: string = "2012-12-01"; MaxRecords: int = 0): Recallable =
  ## getDescribeReservedNodes
  ## Returns the descriptions of the reserved nodes.
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeReservedNodes</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Action: string (required)
  ##   ReservedNodeId: string
  ##                 : Identifier for the node reservation.
  ##   Version: string (required)
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  var query_613241 = newJObject()
  add(query_613241, "Marker", newJString(Marker))
  add(query_613241, "Action", newJString(Action))
  add(query_613241, "ReservedNodeId", newJString(ReservedNodeId))
  add(query_613241, "Version", newJString(Version))
  add(query_613241, "MaxRecords", newJInt(MaxRecords))
  result = call_613240.call(nil, query_613241, nil, nil, nil)

var getDescribeReservedNodes* = Call_GetDescribeReservedNodes_613224(
    name: "getDescribeReservedNodes", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeReservedNodes",
    validator: validate_GetDescribeReservedNodes_613225, base: "/",
    url: url_GetDescribeReservedNodes_613226, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeResize_613277 = ref object of OpenApiRestCall_610642
proc url_PostDescribeResize_613279(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeResize_613278(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## <p>Returns information about the last resize operation for the specified cluster. If no resize operation has ever been initiated for the specified cluster, a <code>HTTP 404</code> error is returned. If a resize operation was initiated and completed, the status of the resize remains as <code>SUCCEEDED</code> until the next resize. </p> <p>A resize operation can be requested using <a>ModifyCluster</a> and specifying a different number or type of nodes for the cluster. </p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_613280 = query.getOrDefault("Action")
  valid_613280 = validateParameter(valid_613280, JString, required = true,
                                 default = newJString("DescribeResize"))
  if valid_613280 != nil:
    section.add "Action", valid_613280
  var valid_613281 = query.getOrDefault("Version")
  valid_613281 = validateParameter(valid_613281, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_613281 != nil:
    section.add "Version", valid_613281
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613282 = header.getOrDefault("X-Amz-Signature")
  valid_613282 = validateParameter(valid_613282, JString, required = false,
                                 default = nil)
  if valid_613282 != nil:
    section.add "X-Amz-Signature", valid_613282
  var valid_613283 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613283 = validateParameter(valid_613283, JString, required = false,
                                 default = nil)
  if valid_613283 != nil:
    section.add "X-Amz-Content-Sha256", valid_613283
  var valid_613284 = header.getOrDefault("X-Amz-Date")
  valid_613284 = validateParameter(valid_613284, JString, required = false,
                                 default = nil)
  if valid_613284 != nil:
    section.add "X-Amz-Date", valid_613284
  var valid_613285 = header.getOrDefault("X-Amz-Credential")
  valid_613285 = validateParameter(valid_613285, JString, required = false,
                                 default = nil)
  if valid_613285 != nil:
    section.add "X-Amz-Credential", valid_613285
  var valid_613286 = header.getOrDefault("X-Amz-Security-Token")
  valid_613286 = validateParameter(valid_613286, JString, required = false,
                                 default = nil)
  if valid_613286 != nil:
    section.add "X-Amz-Security-Token", valid_613286
  var valid_613287 = header.getOrDefault("X-Amz-Algorithm")
  valid_613287 = validateParameter(valid_613287, JString, required = false,
                                 default = nil)
  if valid_613287 != nil:
    section.add "X-Amz-Algorithm", valid_613287
  var valid_613288 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613288 = validateParameter(valid_613288, JString, required = false,
                                 default = nil)
  if valid_613288 != nil:
    section.add "X-Amz-SignedHeaders", valid_613288
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of a cluster whose resize progress you are requesting. This parameter is case-sensitive.</p> <p>By default, resize operations for all clusters defined for an AWS account are returned.</p>
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_613289 = formData.getOrDefault("ClusterIdentifier")
  valid_613289 = validateParameter(valid_613289, JString, required = true,
                                 default = nil)
  if valid_613289 != nil:
    section.add "ClusterIdentifier", valid_613289
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613290: Call_PostDescribeResize_613277; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns information about the last resize operation for the specified cluster. If no resize operation has ever been initiated for the specified cluster, a <code>HTTP 404</code> error is returned. If a resize operation was initiated and completed, the status of the resize remains as <code>SUCCEEDED</code> until the next resize. </p> <p>A resize operation can be requested using <a>ModifyCluster</a> and specifying a different number or type of nodes for the cluster. </p>
  ## 
  let valid = call_613290.validator(path, query, header, formData, body)
  let scheme = call_613290.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613290.url(scheme.get, call_613290.host, call_613290.base,
                         call_613290.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613290, url, valid)

proc call*(call_613291: Call_PostDescribeResize_613277; ClusterIdentifier: string;
          Action: string = "DescribeResize"; Version: string = "2012-12-01"): Recallable =
  ## postDescribeResize
  ## <p>Returns information about the last resize operation for the specified cluster. If no resize operation has ever been initiated for the specified cluster, a <code>HTTP 404</code> error is returned. If a resize operation was initiated and completed, the status of the resize remains as <code>SUCCEEDED</code> until the next resize. </p> <p>A resize operation can be requested using <a>ModifyCluster</a> and specifying a different number or type of nodes for the cluster. </p>
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of a cluster whose resize progress you are requesting. This parameter is case-sensitive.</p> <p>By default, resize operations for all clusters defined for an AWS account are returned.</p>
  ##   Action: string (required)
  ##   Version: string (required)
  var query_613292 = newJObject()
  var formData_613293 = newJObject()
  add(formData_613293, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_613292, "Action", newJString(Action))
  add(query_613292, "Version", newJString(Version))
  result = call_613291.call(nil, query_613292, nil, formData_613293, nil)

var postDescribeResize* = Call_PostDescribeResize_613277(
    name: "postDescribeResize", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeResize",
    validator: validate_PostDescribeResize_613278, base: "/",
    url: url_PostDescribeResize_613279, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeResize_613261 = ref object of OpenApiRestCall_610642
proc url_GetDescribeResize_613263(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeResize_613262(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## <p>Returns information about the last resize operation for the specified cluster. If no resize operation has ever been initiated for the specified cluster, a <code>HTTP 404</code> error is returned. If a resize operation was initiated and completed, the status of the resize remains as <code>SUCCEEDED</code> until the next resize. </p> <p>A resize operation can be requested using <a>ModifyCluster</a> and specifying a different number or type of nodes for the cluster. </p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of a cluster whose resize progress you are requesting. This parameter is case-sensitive.</p> <p>By default, resize operations for all clusters defined for an AWS account are returned.</p>
  ##   Version: JString (required)
  section = newJObject()
  var valid_613264 = query.getOrDefault("Action")
  valid_613264 = validateParameter(valid_613264, JString, required = true,
                                 default = newJString("DescribeResize"))
  if valid_613264 != nil:
    section.add "Action", valid_613264
  var valid_613265 = query.getOrDefault("ClusterIdentifier")
  valid_613265 = validateParameter(valid_613265, JString, required = true,
                                 default = nil)
  if valid_613265 != nil:
    section.add "ClusterIdentifier", valid_613265
  var valid_613266 = query.getOrDefault("Version")
  valid_613266 = validateParameter(valid_613266, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_613266 != nil:
    section.add "Version", valid_613266
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613267 = header.getOrDefault("X-Amz-Signature")
  valid_613267 = validateParameter(valid_613267, JString, required = false,
                                 default = nil)
  if valid_613267 != nil:
    section.add "X-Amz-Signature", valid_613267
  var valid_613268 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613268 = validateParameter(valid_613268, JString, required = false,
                                 default = nil)
  if valid_613268 != nil:
    section.add "X-Amz-Content-Sha256", valid_613268
  var valid_613269 = header.getOrDefault("X-Amz-Date")
  valid_613269 = validateParameter(valid_613269, JString, required = false,
                                 default = nil)
  if valid_613269 != nil:
    section.add "X-Amz-Date", valid_613269
  var valid_613270 = header.getOrDefault("X-Amz-Credential")
  valid_613270 = validateParameter(valid_613270, JString, required = false,
                                 default = nil)
  if valid_613270 != nil:
    section.add "X-Amz-Credential", valid_613270
  var valid_613271 = header.getOrDefault("X-Amz-Security-Token")
  valid_613271 = validateParameter(valid_613271, JString, required = false,
                                 default = nil)
  if valid_613271 != nil:
    section.add "X-Amz-Security-Token", valid_613271
  var valid_613272 = header.getOrDefault("X-Amz-Algorithm")
  valid_613272 = validateParameter(valid_613272, JString, required = false,
                                 default = nil)
  if valid_613272 != nil:
    section.add "X-Amz-Algorithm", valid_613272
  var valid_613273 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613273 = validateParameter(valid_613273, JString, required = false,
                                 default = nil)
  if valid_613273 != nil:
    section.add "X-Amz-SignedHeaders", valid_613273
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613274: Call_GetDescribeResize_613261; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns information about the last resize operation for the specified cluster. If no resize operation has ever been initiated for the specified cluster, a <code>HTTP 404</code> error is returned. If a resize operation was initiated and completed, the status of the resize remains as <code>SUCCEEDED</code> until the next resize. </p> <p>A resize operation can be requested using <a>ModifyCluster</a> and specifying a different number or type of nodes for the cluster. </p>
  ## 
  let valid = call_613274.validator(path, query, header, formData, body)
  let scheme = call_613274.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613274.url(scheme.get, call_613274.host, call_613274.base,
                         call_613274.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613274, url, valid)

proc call*(call_613275: Call_GetDescribeResize_613261; ClusterIdentifier: string;
          Action: string = "DescribeResize"; Version: string = "2012-12-01"): Recallable =
  ## getDescribeResize
  ## <p>Returns information about the last resize operation for the specified cluster. If no resize operation has ever been initiated for the specified cluster, a <code>HTTP 404</code> error is returned. If a resize operation was initiated and completed, the status of the resize remains as <code>SUCCEEDED</code> until the next resize. </p> <p>A resize operation can be requested using <a>ModifyCluster</a> and specifying a different number or type of nodes for the cluster. </p>
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of a cluster whose resize progress you are requesting. This parameter is case-sensitive.</p> <p>By default, resize operations for all clusters defined for an AWS account are returned.</p>
  ##   Version: string (required)
  var query_613276 = newJObject()
  add(query_613276, "Action", newJString(Action))
  add(query_613276, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_613276, "Version", newJString(Version))
  result = call_613275.call(nil, query_613276, nil, nil, nil)

var getDescribeResize* = Call_GetDescribeResize_613261(name: "getDescribeResize",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=DescribeResize", validator: validate_GetDescribeResize_613262,
    base: "/", url: url_GetDescribeResize_613263,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeScheduledActions_613317 = ref object of OpenApiRestCall_610642
proc url_PostDescribeScheduledActions_613319(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeScheduledActions_613318(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Describes properties of scheduled actions. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_613320 = query.getOrDefault("Action")
  valid_613320 = validateParameter(valid_613320, JString, required = true, default = newJString(
      "DescribeScheduledActions"))
  if valid_613320 != nil:
    section.add "Action", valid_613320
  var valid_613321 = query.getOrDefault("Version")
  valid_613321 = validateParameter(valid_613321, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_613321 != nil:
    section.add "Version", valid_613321
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613322 = header.getOrDefault("X-Amz-Signature")
  valid_613322 = validateParameter(valid_613322, JString, required = false,
                                 default = nil)
  if valid_613322 != nil:
    section.add "X-Amz-Signature", valid_613322
  var valid_613323 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613323 = validateParameter(valid_613323, JString, required = false,
                                 default = nil)
  if valid_613323 != nil:
    section.add "X-Amz-Content-Sha256", valid_613323
  var valid_613324 = header.getOrDefault("X-Amz-Date")
  valid_613324 = validateParameter(valid_613324, JString, required = false,
                                 default = nil)
  if valid_613324 != nil:
    section.add "X-Amz-Date", valid_613324
  var valid_613325 = header.getOrDefault("X-Amz-Credential")
  valid_613325 = validateParameter(valid_613325, JString, required = false,
                                 default = nil)
  if valid_613325 != nil:
    section.add "X-Amz-Credential", valid_613325
  var valid_613326 = header.getOrDefault("X-Amz-Security-Token")
  valid_613326 = validateParameter(valid_613326, JString, required = false,
                                 default = nil)
  if valid_613326 != nil:
    section.add "X-Amz-Security-Token", valid_613326
  var valid_613327 = header.getOrDefault("X-Amz-Algorithm")
  valid_613327 = validateParameter(valid_613327, JString, required = false,
                                 default = nil)
  if valid_613327 != nil:
    section.add "X-Amz-Algorithm", valid_613327
  var valid_613328 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613328 = validateParameter(valid_613328, JString, required = false,
                                 default = nil)
  if valid_613328 != nil:
    section.add "X-Amz-SignedHeaders", valid_613328
  result.add "header", section
  ## parameters in `formData` object:
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   ScheduledActionName: JString
  ##                      : The name of the scheduled action to retrieve. 
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeScheduledActions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   EndTime: JString
  ##          : The end time in UTC of the scheduled action to retrieve. Only active scheduled actions that have invocations before this time are retrieved.
  ##   StartTime: JString
  ##            : The start time in UTC of the scheduled actions to retrieve. Only active scheduled actions that have invocations after this time are retrieved.
  ##   Filters: JArray
  ##          : List of scheduled action filters. 
  ##   TargetActionType: JString
  ##                   : The type of the scheduled actions to retrieve. 
  ##   Active: JBool
  ##         : If true, retrieve only active scheduled actions. If false, retrieve only disabled scheduled actions. 
  section = newJObject()
  var valid_613329 = formData.getOrDefault("MaxRecords")
  valid_613329 = validateParameter(valid_613329, JInt, required = false, default = nil)
  if valid_613329 != nil:
    section.add "MaxRecords", valid_613329
  var valid_613330 = formData.getOrDefault("ScheduledActionName")
  valid_613330 = validateParameter(valid_613330, JString, required = false,
                                 default = nil)
  if valid_613330 != nil:
    section.add "ScheduledActionName", valid_613330
  var valid_613331 = formData.getOrDefault("Marker")
  valid_613331 = validateParameter(valid_613331, JString, required = false,
                                 default = nil)
  if valid_613331 != nil:
    section.add "Marker", valid_613331
  var valid_613332 = formData.getOrDefault("EndTime")
  valid_613332 = validateParameter(valid_613332, JString, required = false,
                                 default = nil)
  if valid_613332 != nil:
    section.add "EndTime", valid_613332
  var valid_613333 = formData.getOrDefault("StartTime")
  valid_613333 = validateParameter(valid_613333, JString, required = false,
                                 default = nil)
  if valid_613333 != nil:
    section.add "StartTime", valid_613333
  var valid_613334 = formData.getOrDefault("Filters")
  valid_613334 = validateParameter(valid_613334, JArray, required = false,
                                 default = nil)
  if valid_613334 != nil:
    section.add "Filters", valid_613334
  var valid_613335 = formData.getOrDefault("TargetActionType")
  valid_613335 = validateParameter(valid_613335, JString, required = false,
                                 default = newJString("ResizeCluster"))
  if valid_613335 != nil:
    section.add "TargetActionType", valid_613335
  var valid_613336 = formData.getOrDefault("Active")
  valid_613336 = validateParameter(valid_613336, JBool, required = false, default = nil)
  if valid_613336 != nil:
    section.add "Active", valid_613336
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613337: Call_PostDescribeScheduledActions_613317; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Describes properties of scheduled actions. 
  ## 
  let valid = call_613337.validator(path, query, header, formData, body)
  let scheme = call_613337.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613337.url(scheme.get, call_613337.host, call_613337.base,
                         call_613337.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613337, url, valid)

proc call*(call_613338: Call_PostDescribeScheduledActions_613317;
          MaxRecords: int = 0; ScheduledActionName: string = ""; Marker: string = "";
          EndTime: string = ""; StartTime: string = "";
          Action: string = "DescribeScheduledActions"; Filters: JsonNode = nil;
          TargetActionType: string = "ResizeCluster";
          Version: string = "2012-12-01"; Active: bool = false): Recallable =
  ## postDescribeScheduledActions
  ## Describes properties of scheduled actions. 
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   ScheduledActionName: string
  ##                      : The name of the scheduled action to retrieve. 
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeScheduledActions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   EndTime: string
  ##          : The end time in UTC of the scheduled action to retrieve. Only active scheduled actions that have invocations before this time are retrieved.
  ##   StartTime: string
  ##            : The start time in UTC of the scheduled actions to retrieve. Only active scheduled actions that have invocations after this time are retrieved.
  ##   Action: string (required)
  ##   Filters: JArray
  ##          : List of scheduled action filters. 
  ##   TargetActionType: string
  ##                   : The type of the scheduled actions to retrieve. 
  ##   Version: string (required)
  ##   Active: bool
  ##         : If true, retrieve only active scheduled actions. If false, retrieve only disabled scheduled actions. 
  var query_613339 = newJObject()
  var formData_613340 = newJObject()
  add(formData_613340, "MaxRecords", newJInt(MaxRecords))
  add(formData_613340, "ScheduledActionName", newJString(ScheduledActionName))
  add(formData_613340, "Marker", newJString(Marker))
  add(formData_613340, "EndTime", newJString(EndTime))
  add(formData_613340, "StartTime", newJString(StartTime))
  add(query_613339, "Action", newJString(Action))
  if Filters != nil:
    formData_613340.add "Filters", Filters
  add(formData_613340, "TargetActionType", newJString(TargetActionType))
  add(query_613339, "Version", newJString(Version))
  add(formData_613340, "Active", newJBool(Active))
  result = call_613338.call(nil, query_613339, nil, formData_613340, nil)

var postDescribeScheduledActions* = Call_PostDescribeScheduledActions_613317(
    name: "postDescribeScheduledActions", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeScheduledActions",
    validator: validate_PostDescribeScheduledActions_613318, base: "/",
    url: url_PostDescribeScheduledActions_613319,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeScheduledActions_613294 = ref object of OpenApiRestCall_610642
proc url_GetDescribeScheduledActions_613296(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeScheduledActions_613295(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Describes properties of scheduled actions. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeScheduledActions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TargetActionType: JString
  ##                   : The type of the scheduled actions to retrieve. 
  ##   ScheduledActionName: JString
  ##                      : The name of the scheduled action to retrieve. 
  ##   Active: JBool
  ##         : If true, retrieve only active scheduled actions. If false, retrieve only disabled scheduled actions. 
  ##   Action: JString (required)
  ##   StartTime: JString
  ##            : The start time in UTC of the scheduled actions to retrieve. Only active scheduled actions that have invocations after this time are retrieved.
  ##   EndTime: JString
  ##          : The end time in UTC of the scheduled action to retrieve. Only active scheduled actions that have invocations before this time are retrieved.
  ##   Version: JString (required)
  ##   Filters: JArray
  ##          : List of scheduled action filters. 
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  section = newJObject()
  var valid_613297 = query.getOrDefault("Marker")
  valid_613297 = validateParameter(valid_613297, JString, required = false,
                                 default = nil)
  if valid_613297 != nil:
    section.add "Marker", valid_613297
  var valid_613298 = query.getOrDefault("TargetActionType")
  valid_613298 = validateParameter(valid_613298, JString, required = false,
                                 default = newJString("ResizeCluster"))
  if valid_613298 != nil:
    section.add "TargetActionType", valid_613298
  var valid_613299 = query.getOrDefault("ScheduledActionName")
  valid_613299 = validateParameter(valid_613299, JString, required = false,
                                 default = nil)
  if valid_613299 != nil:
    section.add "ScheduledActionName", valid_613299
  var valid_613300 = query.getOrDefault("Active")
  valid_613300 = validateParameter(valid_613300, JBool, required = false, default = nil)
  if valid_613300 != nil:
    section.add "Active", valid_613300
  var valid_613301 = query.getOrDefault("Action")
  valid_613301 = validateParameter(valid_613301, JString, required = true, default = newJString(
      "DescribeScheduledActions"))
  if valid_613301 != nil:
    section.add "Action", valid_613301
  var valid_613302 = query.getOrDefault("StartTime")
  valid_613302 = validateParameter(valid_613302, JString, required = false,
                                 default = nil)
  if valid_613302 != nil:
    section.add "StartTime", valid_613302
  var valid_613303 = query.getOrDefault("EndTime")
  valid_613303 = validateParameter(valid_613303, JString, required = false,
                                 default = nil)
  if valid_613303 != nil:
    section.add "EndTime", valid_613303
  var valid_613304 = query.getOrDefault("Version")
  valid_613304 = validateParameter(valid_613304, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_613304 != nil:
    section.add "Version", valid_613304
  var valid_613305 = query.getOrDefault("Filters")
  valid_613305 = validateParameter(valid_613305, JArray, required = false,
                                 default = nil)
  if valid_613305 != nil:
    section.add "Filters", valid_613305
  var valid_613306 = query.getOrDefault("MaxRecords")
  valid_613306 = validateParameter(valid_613306, JInt, required = false, default = nil)
  if valid_613306 != nil:
    section.add "MaxRecords", valid_613306
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613307 = header.getOrDefault("X-Amz-Signature")
  valid_613307 = validateParameter(valid_613307, JString, required = false,
                                 default = nil)
  if valid_613307 != nil:
    section.add "X-Amz-Signature", valid_613307
  var valid_613308 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613308 = validateParameter(valid_613308, JString, required = false,
                                 default = nil)
  if valid_613308 != nil:
    section.add "X-Amz-Content-Sha256", valid_613308
  var valid_613309 = header.getOrDefault("X-Amz-Date")
  valid_613309 = validateParameter(valid_613309, JString, required = false,
                                 default = nil)
  if valid_613309 != nil:
    section.add "X-Amz-Date", valid_613309
  var valid_613310 = header.getOrDefault("X-Amz-Credential")
  valid_613310 = validateParameter(valid_613310, JString, required = false,
                                 default = nil)
  if valid_613310 != nil:
    section.add "X-Amz-Credential", valid_613310
  var valid_613311 = header.getOrDefault("X-Amz-Security-Token")
  valid_613311 = validateParameter(valid_613311, JString, required = false,
                                 default = nil)
  if valid_613311 != nil:
    section.add "X-Amz-Security-Token", valid_613311
  var valid_613312 = header.getOrDefault("X-Amz-Algorithm")
  valid_613312 = validateParameter(valid_613312, JString, required = false,
                                 default = nil)
  if valid_613312 != nil:
    section.add "X-Amz-Algorithm", valid_613312
  var valid_613313 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613313 = validateParameter(valid_613313, JString, required = false,
                                 default = nil)
  if valid_613313 != nil:
    section.add "X-Amz-SignedHeaders", valid_613313
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613314: Call_GetDescribeScheduledActions_613294; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Describes properties of scheduled actions. 
  ## 
  let valid = call_613314.validator(path, query, header, formData, body)
  let scheme = call_613314.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613314.url(scheme.get, call_613314.host, call_613314.base,
                         call_613314.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613314, url, valid)

proc call*(call_613315: Call_GetDescribeScheduledActions_613294;
          Marker: string = ""; TargetActionType: string = "ResizeCluster";
          ScheduledActionName: string = ""; Active: bool = false;
          Action: string = "DescribeScheduledActions"; StartTime: string = "";
          EndTime: string = ""; Version: string = "2012-12-01"; Filters: JsonNode = nil;
          MaxRecords: int = 0): Recallable =
  ## getDescribeScheduledActions
  ## Describes properties of scheduled actions. 
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeScheduledActions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TargetActionType: string
  ##                   : The type of the scheduled actions to retrieve. 
  ##   ScheduledActionName: string
  ##                      : The name of the scheduled action to retrieve. 
  ##   Active: bool
  ##         : If true, retrieve only active scheduled actions. If false, retrieve only disabled scheduled actions. 
  ##   Action: string (required)
  ##   StartTime: string
  ##            : The start time in UTC of the scheduled actions to retrieve. Only active scheduled actions that have invocations after this time are retrieved.
  ##   EndTime: string
  ##          : The end time in UTC of the scheduled action to retrieve. Only active scheduled actions that have invocations before this time are retrieved.
  ##   Version: string (required)
  ##   Filters: JArray
  ##          : List of scheduled action filters. 
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  var query_613316 = newJObject()
  add(query_613316, "Marker", newJString(Marker))
  add(query_613316, "TargetActionType", newJString(TargetActionType))
  add(query_613316, "ScheduledActionName", newJString(ScheduledActionName))
  add(query_613316, "Active", newJBool(Active))
  add(query_613316, "Action", newJString(Action))
  add(query_613316, "StartTime", newJString(StartTime))
  add(query_613316, "EndTime", newJString(EndTime))
  add(query_613316, "Version", newJString(Version))
  if Filters != nil:
    query_613316.add "Filters", Filters
  add(query_613316, "MaxRecords", newJInt(MaxRecords))
  result = call_613315.call(nil, query_613316, nil, nil, nil)

var getDescribeScheduledActions* = Call_GetDescribeScheduledActions_613294(
    name: "getDescribeScheduledActions", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeScheduledActions",
    validator: validate_GetDescribeScheduledActions_613295, base: "/",
    url: url_GetDescribeScheduledActions_613296,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeSnapshotCopyGrants_613361 = ref object of OpenApiRestCall_610642
proc url_PostDescribeSnapshotCopyGrants_613363(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeSnapshotCopyGrants_613362(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns a list of snapshot copy grants owned by the AWS account in the destination region.</p> <p> For more information about managing snapshot copy grants, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_613364 = query.getOrDefault("Action")
  valid_613364 = validateParameter(valid_613364, JString, required = true, default = newJString(
      "DescribeSnapshotCopyGrants"))
  if valid_613364 != nil:
    section.add "Action", valid_613364
  var valid_613365 = query.getOrDefault("Version")
  valid_613365 = validateParameter(valid_613365, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_613365 != nil:
    section.add "Version", valid_613365
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613366 = header.getOrDefault("X-Amz-Signature")
  valid_613366 = validateParameter(valid_613366, JString, required = false,
                                 default = nil)
  if valid_613366 != nil:
    section.add "X-Amz-Signature", valid_613366
  var valid_613367 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613367 = validateParameter(valid_613367, JString, required = false,
                                 default = nil)
  if valid_613367 != nil:
    section.add "X-Amz-Content-Sha256", valid_613367
  var valid_613368 = header.getOrDefault("X-Amz-Date")
  valid_613368 = validateParameter(valid_613368, JString, required = false,
                                 default = nil)
  if valid_613368 != nil:
    section.add "X-Amz-Date", valid_613368
  var valid_613369 = header.getOrDefault("X-Amz-Credential")
  valid_613369 = validateParameter(valid_613369, JString, required = false,
                                 default = nil)
  if valid_613369 != nil:
    section.add "X-Amz-Credential", valid_613369
  var valid_613370 = header.getOrDefault("X-Amz-Security-Token")
  valid_613370 = validateParameter(valid_613370, JString, required = false,
                                 default = nil)
  if valid_613370 != nil:
    section.add "X-Amz-Security-Token", valid_613370
  var valid_613371 = header.getOrDefault("X-Amz-Algorithm")
  valid_613371 = validateParameter(valid_613371, JString, required = false,
                                 default = nil)
  if valid_613371 != nil:
    section.add "X-Amz-Algorithm", valid_613371
  var valid_613372 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613372 = validateParameter(valid_613372, JString, required = false,
                                 default = nil)
  if valid_613372 != nil:
    section.add "X-Amz-SignedHeaders", valid_613372
  result.add "header", section
  ## parameters in `formData` object:
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching resources that are associated with the specified key or keys. For example, suppose that you have resources tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with all resources that have either or both of these tag keys associated with them.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: JString
  ##         : <p>An optional parameter that specifies the starting point to return a set of response records. When the results of a <code>DescribeSnapshotCopyGrant</code> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <b>SnapshotCopyGrantName</b> parameter or the <b>Marker</b> parameter, but not both. </p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching resources that are associated with the specified value or values. For example, suppose that you have resources tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with all resources that have either or both of these tag values associated with them.
  ##   SnapshotCopyGrantName: JString
  ##                        : The name of the snapshot copy grant.
  section = newJObject()
  var valid_613373 = formData.getOrDefault("TagKeys")
  valid_613373 = validateParameter(valid_613373, JArray, required = false,
                                 default = nil)
  if valid_613373 != nil:
    section.add "TagKeys", valid_613373
  var valid_613374 = formData.getOrDefault("MaxRecords")
  valid_613374 = validateParameter(valid_613374, JInt, required = false, default = nil)
  if valid_613374 != nil:
    section.add "MaxRecords", valid_613374
  var valid_613375 = formData.getOrDefault("Marker")
  valid_613375 = validateParameter(valid_613375, JString, required = false,
                                 default = nil)
  if valid_613375 != nil:
    section.add "Marker", valid_613375
  var valid_613376 = formData.getOrDefault("TagValues")
  valid_613376 = validateParameter(valid_613376, JArray, required = false,
                                 default = nil)
  if valid_613376 != nil:
    section.add "TagValues", valid_613376
  var valid_613377 = formData.getOrDefault("SnapshotCopyGrantName")
  valid_613377 = validateParameter(valid_613377, JString, required = false,
                                 default = nil)
  if valid_613377 != nil:
    section.add "SnapshotCopyGrantName", valid_613377
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613378: Call_PostDescribeSnapshotCopyGrants_613361; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns a list of snapshot copy grants owned by the AWS account in the destination region.</p> <p> For more information about managing snapshot copy grants, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ## 
  let valid = call_613378.validator(path, query, header, formData, body)
  let scheme = call_613378.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613378.url(scheme.get, call_613378.host, call_613378.base,
                         call_613378.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613378, url, valid)

proc call*(call_613379: Call_PostDescribeSnapshotCopyGrants_613361;
          TagKeys: JsonNode = nil; MaxRecords: int = 0; Marker: string = "";
          TagValues: JsonNode = nil; Action: string = "DescribeSnapshotCopyGrants";
          SnapshotCopyGrantName: string = ""; Version: string = "2012-12-01"): Recallable =
  ## postDescribeSnapshotCopyGrants
  ## <p>Returns a list of snapshot copy grants owned by the AWS account in the destination region.</p> <p> For more information about managing snapshot copy grants, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching resources that are associated with the specified key or keys. For example, suppose that you have resources tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with all resources that have either or both of these tag keys associated with them.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: string
  ##         : <p>An optional parameter that specifies the starting point to return a set of response records. When the results of a <code>DescribeSnapshotCopyGrant</code> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <b>SnapshotCopyGrantName</b> parameter or the <b>Marker</b> parameter, but not both. </p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching resources that are associated with the specified value or values. For example, suppose that you have resources tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with all resources that have either or both of these tag values associated with them.
  ##   Action: string (required)
  ##   SnapshotCopyGrantName: string
  ##                        : The name of the snapshot copy grant.
  ##   Version: string (required)
  var query_613380 = newJObject()
  var formData_613381 = newJObject()
  if TagKeys != nil:
    formData_613381.add "TagKeys", TagKeys
  add(formData_613381, "MaxRecords", newJInt(MaxRecords))
  add(formData_613381, "Marker", newJString(Marker))
  if TagValues != nil:
    formData_613381.add "TagValues", TagValues
  add(query_613380, "Action", newJString(Action))
  add(formData_613381, "SnapshotCopyGrantName", newJString(SnapshotCopyGrantName))
  add(query_613380, "Version", newJString(Version))
  result = call_613379.call(nil, query_613380, nil, formData_613381, nil)

var postDescribeSnapshotCopyGrants* = Call_PostDescribeSnapshotCopyGrants_613361(
    name: "postDescribeSnapshotCopyGrants", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeSnapshotCopyGrants",
    validator: validate_PostDescribeSnapshotCopyGrants_613362, base: "/",
    url: url_PostDescribeSnapshotCopyGrants_613363,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeSnapshotCopyGrants_613341 = ref object of OpenApiRestCall_610642
proc url_GetDescribeSnapshotCopyGrants_613343(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeSnapshotCopyGrants_613342(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns a list of snapshot copy grants owned by the AWS account in the destination region.</p> <p> For more information about managing snapshot copy grants, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Marker: JString
  ##         : <p>An optional parameter that specifies the starting point to return a set of response records. When the results of a <code>DescribeSnapshotCopyGrant</code> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <b>SnapshotCopyGrantName</b> parameter or the <b>Marker</b> parameter, but not both. </p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching resources that are associated with the specified key or keys. For example, suppose that you have resources tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with all resources that have either or both of these tag keys associated with them.
  ##   Action: JString (required)
  ##   Version: JString (required)
  ##   SnapshotCopyGrantName: JString
  ##                        : The name of the snapshot copy grant.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching resources that are associated with the specified value or values. For example, suppose that you have resources tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with all resources that have either or both of these tag values associated with them.
  section = newJObject()
  var valid_613344 = query.getOrDefault("Marker")
  valid_613344 = validateParameter(valid_613344, JString, required = false,
                                 default = nil)
  if valid_613344 != nil:
    section.add "Marker", valid_613344
  var valid_613345 = query.getOrDefault("TagKeys")
  valid_613345 = validateParameter(valid_613345, JArray, required = false,
                                 default = nil)
  if valid_613345 != nil:
    section.add "TagKeys", valid_613345
  var valid_613346 = query.getOrDefault("Action")
  valid_613346 = validateParameter(valid_613346, JString, required = true, default = newJString(
      "DescribeSnapshotCopyGrants"))
  if valid_613346 != nil:
    section.add "Action", valid_613346
  var valid_613347 = query.getOrDefault("Version")
  valid_613347 = validateParameter(valid_613347, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_613347 != nil:
    section.add "Version", valid_613347
  var valid_613348 = query.getOrDefault("SnapshotCopyGrantName")
  valid_613348 = validateParameter(valid_613348, JString, required = false,
                                 default = nil)
  if valid_613348 != nil:
    section.add "SnapshotCopyGrantName", valid_613348
  var valid_613349 = query.getOrDefault("MaxRecords")
  valid_613349 = validateParameter(valid_613349, JInt, required = false, default = nil)
  if valid_613349 != nil:
    section.add "MaxRecords", valid_613349
  var valid_613350 = query.getOrDefault("TagValues")
  valid_613350 = validateParameter(valid_613350, JArray, required = false,
                                 default = nil)
  if valid_613350 != nil:
    section.add "TagValues", valid_613350
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613351 = header.getOrDefault("X-Amz-Signature")
  valid_613351 = validateParameter(valid_613351, JString, required = false,
                                 default = nil)
  if valid_613351 != nil:
    section.add "X-Amz-Signature", valid_613351
  var valid_613352 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613352 = validateParameter(valid_613352, JString, required = false,
                                 default = nil)
  if valid_613352 != nil:
    section.add "X-Amz-Content-Sha256", valid_613352
  var valid_613353 = header.getOrDefault("X-Amz-Date")
  valid_613353 = validateParameter(valid_613353, JString, required = false,
                                 default = nil)
  if valid_613353 != nil:
    section.add "X-Amz-Date", valid_613353
  var valid_613354 = header.getOrDefault("X-Amz-Credential")
  valid_613354 = validateParameter(valid_613354, JString, required = false,
                                 default = nil)
  if valid_613354 != nil:
    section.add "X-Amz-Credential", valid_613354
  var valid_613355 = header.getOrDefault("X-Amz-Security-Token")
  valid_613355 = validateParameter(valid_613355, JString, required = false,
                                 default = nil)
  if valid_613355 != nil:
    section.add "X-Amz-Security-Token", valid_613355
  var valid_613356 = header.getOrDefault("X-Amz-Algorithm")
  valid_613356 = validateParameter(valid_613356, JString, required = false,
                                 default = nil)
  if valid_613356 != nil:
    section.add "X-Amz-Algorithm", valid_613356
  var valid_613357 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613357 = validateParameter(valid_613357, JString, required = false,
                                 default = nil)
  if valid_613357 != nil:
    section.add "X-Amz-SignedHeaders", valid_613357
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613358: Call_GetDescribeSnapshotCopyGrants_613341; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns a list of snapshot copy grants owned by the AWS account in the destination region.</p> <p> For more information about managing snapshot copy grants, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ## 
  let valid = call_613358.validator(path, query, header, formData, body)
  let scheme = call_613358.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613358.url(scheme.get, call_613358.host, call_613358.base,
                         call_613358.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613358, url, valid)

proc call*(call_613359: Call_GetDescribeSnapshotCopyGrants_613341;
          Marker: string = ""; TagKeys: JsonNode = nil;
          Action: string = "DescribeSnapshotCopyGrants";
          Version: string = "2012-12-01"; SnapshotCopyGrantName: string = "";
          MaxRecords: int = 0; TagValues: JsonNode = nil): Recallable =
  ## getDescribeSnapshotCopyGrants
  ## <p>Returns a list of snapshot copy grants owned by the AWS account in the destination region.</p> <p> For more information about managing snapshot copy grants, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ##   Marker: string
  ##         : <p>An optional parameter that specifies the starting point to return a set of response records. When the results of a <code>DescribeSnapshotCopyGrant</code> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <b>SnapshotCopyGrantName</b> parameter or the <b>Marker</b> parameter, but not both. </p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching resources that are associated with the specified key or keys. For example, suppose that you have resources tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with all resources that have either or both of these tag keys associated with them.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   SnapshotCopyGrantName: string
  ##                        : The name of the snapshot copy grant.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching resources that are associated with the specified value or values. For example, suppose that you have resources tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with all resources that have either or both of these tag values associated with them.
  var query_613360 = newJObject()
  add(query_613360, "Marker", newJString(Marker))
  if TagKeys != nil:
    query_613360.add "TagKeys", TagKeys
  add(query_613360, "Action", newJString(Action))
  add(query_613360, "Version", newJString(Version))
  add(query_613360, "SnapshotCopyGrantName", newJString(SnapshotCopyGrantName))
  add(query_613360, "MaxRecords", newJInt(MaxRecords))
  if TagValues != nil:
    query_613360.add "TagValues", TagValues
  result = call_613359.call(nil, query_613360, nil, nil, nil)

var getDescribeSnapshotCopyGrants* = Call_GetDescribeSnapshotCopyGrants_613341(
    name: "getDescribeSnapshotCopyGrants", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeSnapshotCopyGrants",
    validator: validate_GetDescribeSnapshotCopyGrants_613342, base: "/",
    url: url_GetDescribeSnapshotCopyGrants_613343,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeSnapshotSchedules_613403 = ref object of OpenApiRestCall_610642
proc url_PostDescribeSnapshotSchedules_613405(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeSnapshotSchedules_613404(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns a list of snapshot schedules. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_613406 = query.getOrDefault("Action")
  valid_613406 = validateParameter(valid_613406, JString, required = true, default = newJString(
      "DescribeSnapshotSchedules"))
  if valid_613406 != nil:
    section.add "Action", valid_613406
  var valid_613407 = query.getOrDefault("Version")
  valid_613407 = validateParameter(valid_613407, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_613407 != nil:
    section.add "Version", valid_613407
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613408 = header.getOrDefault("X-Amz-Signature")
  valid_613408 = validateParameter(valid_613408, JString, required = false,
                                 default = nil)
  if valid_613408 != nil:
    section.add "X-Amz-Signature", valid_613408
  var valid_613409 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613409 = validateParameter(valid_613409, JString, required = false,
                                 default = nil)
  if valid_613409 != nil:
    section.add "X-Amz-Content-Sha256", valid_613409
  var valid_613410 = header.getOrDefault("X-Amz-Date")
  valid_613410 = validateParameter(valid_613410, JString, required = false,
                                 default = nil)
  if valid_613410 != nil:
    section.add "X-Amz-Date", valid_613410
  var valid_613411 = header.getOrDefault("X-Amz-Credential")
  valid_613411 = validateParameter(valid_613411, JString, required = false,
                                 default = nil)
  if valid_613411 != nil:
    section.add "X-Amz-Credential", valid_613411
  var valid_613412 = header.getOrDefault("X-Amz-Security-Token")
  valid_613412 = validateParameter(valid_613412, JString, required = false,
                                 default = nil)
  if valid_613412 != nil:
    section.add "X-Amz-Security-Token", valid_613412
  var valid_613413 = header.getOrDefault("X-Amz-Algorithm")
  valid_613413 = validateParameter(valid_613413, JString, required = false,
                                 default = nil)
  if valid_613413 != nil:
    section.add "X-Amz-Algorithm", valid_613413
  var valid_613414 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613414 = validateParameter(valid_613414, JString, required = false,
                                 default = nil)
  if valid_613414 != nil:
    section.add "X-Amz-SignedHeaders", valid_613414
  result.add "header", section
  ## parameters in `formData` object:
  ##   TagKeys: JArray
  ##          : The key value for a snapshot schedule tag.
  ##   ClusterIdentifier: JString
  ##                    : The unique identifier for the cluster whose snapshot schedules you want to view.
  ##   MaxRecords: JInt
  ##             : The maximum number or response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned <code>marker</code> value.
  ##   Marker: JString
  ##         : A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned marker value in the <code>marker</code> parameter and retrying the command. If the <code>marker</code> field is empty, all response records have been retrieved for the request.
  ##   TagValues: JArray
  ##            : The value corresponding to the key of the snapshot schedule tag.
  ##   ScheduleIdentifier: JString
  ##                     : A unique identifier for a snapshot schedule.
  section = newJObject()
  var valid_613415 = formData.getOrDefault("TagKeys")
  valid_613415 = validateParameter(valid_613415, JArray, required = false,
                                 default = nil)
  if valid_613415 != nil:
    section.add "TagKeys", valid_613415
  var valid_613416 = formData.getOrDefault("ClusterIdentifier")
  valid_613416 = validateParameter(valid_613416, JString, required = false,
                                 default = nil)
  if valid_613416 != nil:
    section.add "ClusterIdentifier", valid_613416
  var valid_613417 = formData.getOrDefault("MaxRecords")
  valid_613417 = validateParameter(valid_613417, JInt, required = false, default = nil)
  if valid_613417 != nil:
    section.add "MaxRecords", valid_613417
  var valid_613418 = formData.getOrDefault("Marker")
  valid_613418 = validateParameter(valid_613418, JString, required = false,
                                 default = nil)
  if valid_613418 != nil:
    section.add "Marker", valid_613418
  var valid_613419 = formData.getOrDefault("TagValues")
  valid_613419 = validateParameter(valid_613419, JArray, required = false,
                                 default = nil)
  if valid_613419 != nil:
    section.add "TagValues", valid_613419
  var valid_613420 = formData.getOrDefault("ScheduleIdentifier")
  valid_613420 = validateParameter(valid_613420, JString, required = false,
                                 default = nil)
  if valid_613420 != nil:
    section.add "ScheduleIdentifier", valid_613420
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613421: Call_PostDescribeSnapshotSchedules_613403; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns a list of snapshot schedules. 
  ## 
  let valid = call_613421.validator(path, query, header, formData, body)
  let scheme = call_613421.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613421.url(scheme.get, call_613421.host, call_613421.base,
                         call_613421.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613421, url, valid)

proc call*(call_613422: Call_PostDescribeSnapshotSchedules_613403;
          TagKeys: JsonNode = nil; ClusterIdentifier: string = ""; MaxRecords: int = 0;
          Marker: string = ""; TagValues: JsonNode = nil;
          Action: string = "DescribeSnapshotSchedules";
          ScheduleIdentifier: string = ""; Version: string = "2012-12-01"): Recallable =
  ## postDescribeSnapshotSchedules
  ## Returns a list of snapshot schedules. 
  ##   TagKeys: JArray
  ##          : The key value for a snapshot schedule tag.
  ##   ClusterIdentifier: string
  ##                    : The unique identifier for the cluster whose snapshot schedules you want to view.
  ##   MaxRecords: int
  ##             : The maximum number or response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned <code>marker</code> value.
  ##   Marker: string
  ##         : A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned marker value in the <code>marker</code> parameter and retrying the command. If the <code>marker</code> field is empty, all response records have been retrieved for the request.
  ##   TagValues: JArray
  ##            : The value corresponding to the key of the snapshot schedule tag.
  ##   Action: string (required)
  ##   ScheduleIdentifier: string
  ##                     : A unique identifier for a snapshot schedule.
  ##   Version: string (required)
  var query_613423 = newJObject()
  var formData_613424 = newJObject()
  if TagKeys != nil:
    formData_613424.add "TagKeys", TagKeys
  add(formData_613424, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_613424, "MaxRecords", newJInt(MaxRecords))
  add(formData_613424, "Marker", newJString(Marker))
  if TagValues != nil:
    formData_613424.add "TagValues", TagValues
  add(query_613423, "Action", newJString(Action))
  add(formData_613424, "ScheduleIdentifier", newJString(ScheduleIdentifier))
  add(query_613423, "Version", newJString(Version))
  result = call_613422.call(nil, query_613423, nil, formData_613424, nil)

var postDescribeSnapshotSchedules* = Call_PostDescribeSnapshotSchedules_613403(
    name: "postDescribeSnapshotSchedules", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeSnapshotSchedules",
    validator: validate_PostDescribeSnapshotSchedules_613404, base: "/",
    url: url_PostDescribeSnapshotSchedules_613405,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeSnapshotSchedules_613382 = ref object of OpenApiRestCall_610642
proc url_GetDescribeSnapshotSchedules_613384(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeSnapshotSchedules_613383(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns a list of snapshot schedules. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Marker: JString
  ##         : A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned marker value in the <code>marker</code> parameter and retrying the command. If the <code>marker</code> field is empty, all response records have been retrieved for the request.
  ##   ScheduleIdentifier: JString
  ##                     : A unique identifier for a snapshot schedule.
  ##   TagKeys: JArray
  ##          : The key value for a snapshot schedule tag.
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString
  ##                    : The unique identifier for the cluster whose snapshot schedules you want to view.
  ##   Version: JString (required)
  ##   MaxRecords: JInt
  ##             : The maximum number or response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned <code>marker</code> value.
  ##   TagValues: JArray
  ##            : The value corresponding to the key of the snapshot schedule tag.
  section = newJObject()
  var valid_613385 = query.getOrDefault("Marker")
  valid_613385 = validateParameter(valid_613385, JString, required = false,
                                 default = nil)
  if valid_613385 != nil:
    section.add "Marker", valid_613385
  var valid_613386 = query.getOrDefault("ScheduleIdentifier")
  valid_613386 = validateParameter(valid_613386, JString, required = false,
                                 default = nil)
  if valid_613386 != nil:
    section.add "ScheduleIdentifier", valid_613386
  var valid_613387 = query.getOrDefault("TagKeys")
  valid_613387 = validateParameter(valid_613387, JArray, required = false,
                                 default = nil)
  if valid_613387 != nil:
    section.add "TagKeys", valid_613387
  var valid_613388 = query.getOrDefault("Action")
  valid_613388 = validateParameter(valid_613388, JString, required = true, default = newJString(
      "DescribeSnapshotSchedules"))
  if valid_613388 != nil:
    section.add "Action", valid_613388
  var valid_613389 = query.getOrDefault("ClusterIdentifier")
  valid_613389 = validateParameter(valid_613389, JString, required = false,
                                 default = nil)
  if valid_613389 != nil:
    section.add "ClusterIdentifier", valid_613389
  var valid_613390 = query.getOrDefault("Version")
  valid_613390 = validateParameter(valid_613390, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_613390 != nil:
    section.add "Version", valid_613390
  var valid_613391 = query.getOrDefault("MaxRecords")
  valid_613391 = validateParameter(valid_613391, JInt, required = false, default = nil)
  if valid_613391 != nil:
    section.add "MaxRecords", valid_613391
  var valid_613392 = query.getOrDefault("TagValues")
  valid_613392 = validateParameter(valid_613392, JArray, required = false,
                                 default = nil)
  if valid_613392 != nil:
    section.add "TagValues", valid_613392
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613393 = header.getOrDefault("X-Amz-Signature")
  valid_613393 = validateParameter(valid_613393, JString, required = false,
                                 default = nil)
  if valid_613393 != nil:
    section.add "X-Amz-Signature", valid_613393
  var valid_613394 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613394 = validateParameter(valid_613394, JString, required = false,
                                 default = nil)
  if valid_613394 != nil:
    section.add "X-Amz-Content-Sha256", valid_613394
  var valid_613395 = header.getOrDefault("X-Amz-Date")
  valid_613395 = validateParameter(valid_613395, JString, required = false,
                                 default = nil)
  if valid_613395 != nil:
    section.add "X-Amz-Date", valid_613395
  var valid_613396 = header.getOrDefault("X-Amz-Credential")
  valid_613396 = validateParameter(valid_613396, JString, required = false,
                                 default = nil)
  if valid_613396 != nil:
    section.add "X-Amz-Credential", valid_613396
  var valid_613397 = header.getOrDefault("X-Amz-Security-Token")
  valid_613397 = validateParameter(valid_613397, JString, required = false,
                                 default = nil)
  if valid_613397 != nil:
    section.add "X-Amz-Security-Token", valid_613397
  var valid_613398 = header.getOrDefault("X-Amz-Algorithm")
  valid_613398 = validateParameter(valid_613398, JString, required = false,
                                 default = nil)
  if valid_613398 != nil:
    section.add "X-Amz-Algorithm", valid_613398
  var valid_613399 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613399 = validateParameter(valid_613399, JString, required = false,
                                 default = nil)
  if valid_613399 != nil:
    section.add "X-Amz-SignedHeaders", valid_613399
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613400: Call_GetDescribeSnapshotSchedules_613382; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns a list of snapshot schedules. 
  ## 
  let valid = call_613400.validator(path, query, header, formData, body)
  let scheme = call_613400.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613400.url(scheme.get, call_613400.host, call_613400.base,
                         call_613400.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613400, url, valid)

proc call*(call_613401: Call_GetDescribeSnapshotSchedules_613382;
          Marker: string = ""; ScheduleIdentifier: string = ""; TagKeys: JsonNode = nil;
          Action: string = "DescribeSnapshotSchedules";
          ClusterIdentifier: string = ""; Version: string = "2012-12-01";
          MaxRecords: int = 0; TagValues: JsonNode = nil): Recallable =
  ## getDescribeSnapshotSchedules
  ## Returns a list of snapshot schedules. 
  ##   Marker: string
  ##         : A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned marker value in the <code>marker</code> parameter and retrying the command. If the <code>marker</code> field is empty, all response records have been retrieved for the request.
  ##   ScheduleIdentifier: string
  ##                     : A unique identifier for a snapshot schedule.
  ##   TagKeys: JArray
  ##          : The key value for a snapshot schedule tag.
  ##   Action: string (required)
  ##   ClusterIdentifier: string
  ##                    : The unique identifier for the cluster whose snapshot schedules you want to view.
  ##   Version: string (required)
  ##   MaxRecords: int
  ##             : The maximum number or response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned <code>marker</code> value.
  ##   TagValues: JArray
  ##            : The value corresponding to the key of the snapshot schedule tag.
  var query_613402 = newJObject()
  add(query_613402, "Marker", newJString(Marker))
  add(query_613402, "ScheduleIdentifier", newJString(ScheduleIdentifier))
  if TagKeys != nil:
    query_613402.add "TagKeys", TagKeys
  add(query_613402, "Action", newJString(Action))
  add(query_613402, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_613402, "Version", newJString(Version))
  add(query_613402, "MaxRecords", newJInt(MaxRecords))
  if TagValues != nil:
    query_613402.add "TagValues", TagValues
  result = call_613401.call(nil, query_613402, nil, nil, nil)

var getDescribeSnapshotSchedules* = Call_GetDescribeSnapshotSchedules_613382(
    name: "getDescribeSnapshotSchedules", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeSnapshotSchedules",
    validator: validate_GetDescribeSnapshotSchedules_613383, base: "/",
    url: url_GetDescribeSnapshotSchedules_613384,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeStorage_613440 = ref object of OpenApiRestCall_610642
proc url_PostDescribeStorage_613442(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeStorage_613441(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Returns account level backups storage size and provisional storage.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_613443 = query.getOrDefault("Action")
  valid_613443 = validateParameter(valid_613443, JString, required = true,
                                 default = newJString("DescribeStorage"))
  if valid_613443 != nil:
    section.add "Action", valid_613443
  var valid_613444 = query.getOrDefault("Version")
  valid_613444 = validateParameter(valid_613444, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_613444 != nil:
    section.add "Version", valid_613444
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613445 = header.getOrDefault("X-Amz-Signature")
  valid_613445 = validateParameter(valid_613445, JString, required = false,
                                 default = nil)
  if valid_613445 != nil:
    section.add "X-Amz-Signature", valid_613445
  var valid_613446 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613446 = validateParameter(valid_613446, JString, required = false,
                                 default = nil)
  if valid_613446 != nil:
    section.add "X-Amz-Content-Sha256", valid_613446
  var valid_613447 = header.getOrDefault("X-Amz-Date")
  valid_613447 = validateParameter(valid_613447, JString, required = false,
                                 default = nil)
  if valid_613447 != nil:
    section.add "X-Amz-Date", valid_613447
  var valid_613448 = header.getOrDefault("X-Amz-Credential")
  valid_613448 = validateParameter(valid_613448, JString, required = false,
                                 default = nil)
  if valid_613448 != nil:
    section.add "X-Amz-Credential", valid_613448
  var valid_613449 = header.getOrDefault("X-Amz-Security-Token")
  valid_613449 = validateParameter(valid_613449, JString, required = false,
                                 default = nil)
  if valid_613449 != nil:
    section.add "X-Amz-Security-Token", valid_613449
  var valid_613450 = header.getOrDefault("X-Amz-Algorithm")
  valid_613450 = validateParameter(valid_613450, JString, required = false,
                                 default = nil)
  if valid_613450 != nil:
    section.add "X-Amz-Algorithm", valid_613450
  var valid_613451 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613451 = validateParameter(valid_613451, JString, required = false,
                                 default = nil)
  if valid_613451 != nil:
    section.add "X-Amz-SignedHeaders", valid_613451
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613452: Call_PostDescribeStorage_613440; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns account level backups storage size and provisional storage.
  ## 
  let valid = call_613452.validator(path, query, header, formData, body)
  let scheme = call_613452.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613452.url(scheme.get, call_613452.host, call_613452.base,
                         call_613452.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613452, url, valid)

proc call*(call_613453: Call_PostDescribeStorage_613440;
          Action: string = "DescribeStorage"; Version: string = "2012-12-01"): Recallable =
  ## postDescribeStorage
  ## Returns account level backups storage size and provisional storage.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_613454 = newJObject()
  add(query_613454, "Action", newJString(Action))
  add(query_613454, "Version", newJString(Version))
  result = call_613453.call(nil, query_613454, nil, nil, nil)

var postDescribeStorage* = Call_PostDescribeStorage_613440(
    name: "postDescribeStorage", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeStorage",
    validator: validate_PostDescribeStorage_613441, base: "/",
    url: url_PostDescribeStorage_613442, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeStorage_613425 = ref object of OpenApiRestCall_610642
proc url_GetDescribeStorage_613427(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeStorage_613426(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Returns account level backups storage size and provisional storage.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_613428 = query.getOrDefault("Action")
  valid_613428 = validateParameter(valid_613428, JString, required = true,
                                 default = newJString("DescribeStorage"))
  if valid_613428 != nil:
    section.add "Action", valid_613428
  var valid_613429 = query.getOrDefault("Version")
  valid_613429 = validateParameter(valid_613429, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_613429 != nil:
    section.add "Version", valid_613429
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613430 = header.getOrDefault("X-Amz-Signature")
  valid_613430 = validateParameter(valid_613430, JString, required = false,
                                 default = nil)
  if valid_613430 != nil:
    section.add "X-Amz-Signature", valid_613430
  var valid_613431 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613431 = validateParameter(valid_613431, JString, required = false,
                                 default = nil)
  if valid_613431 != nil:
    section.add "X-Amz-Content-Sha256", valid_613431
  var valid_613432 = header.getOrDefault("X-Amz-Date")
  valid_613432 = validateParameter(valid_613432, JString, required = false,
                                 default = nil)
  if valid_613432 != nil:
    section.add "X-Amz-Date", valid_613432
  var valid_613433 = header.getOrDefault("X-Amz-Credential")
  valid_613433 = validateParameter(valid_613433, JString, required = false,
                                 default = nil)
  if valid_613433 != nil:
    section.add "X-Amz-Credential", valid_613433
  var valid_613434 = header.getOrDefault("X-Amz-Security-Token")
  valid_613434 = validateParameter(valid_613434, JString, required = false,
                                 default = nil)
  if valid_613434 != nil:
    section.add "X-Amz-Security-Token", valid_613434
  var valid_613435 = header.getOrDefault("X-Amz-Algorithm")
  valid_613435 = validateParameter(valid_613435, JString, required = false,
                                 default = nil)
  if valid_613435 != nil:
    section.add "X-Amz-Algorithm", valid_613435
  var valid_613436 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613436 = validateParameter(valid_613436, JString, required = false,
                                 default = nil)
  if valid_613436 != nil:
    section.add "X-Amz-SignedHeaders", valid_613436
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613437: Call_GetDescribeStorage_613425; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns account level backups storage size and provisional storage.
  ## 
  let valid = call_613437.validator(path, query, header, formData, body)
  let scheme = call_613437.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613437.url(scheme.get, call_613437.host, call_613437.base,
                         call_613437.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613437, url, valid)

proc call*(call_613438: Call_GetDescribeStorage_613425;
          Action: string = "DescribeStorage"; Version: string = "2012-12-01"): Recallable =
  ## getDescribeStorage
  ## Returns account level backups storage size and provisional storage.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_613439 = newJObject()
  add(query_613439, "Action", newJString(Action))
  add(query_613439, "Version", newJString(Version))
  result = call_613438.call(nil, query_613439, nil, nil, nil)

var getDescribeStorage* = Call_GetDescribeStorage_613425(
    name: "getDescribeStorage", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeStorage",
    validator: validate_GetDescribeStorage_613426, base: "/",
    url: url_GetDescribeStorage_613427, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeTableRestoreStatus_613474 = ref object of OpenApiRestCall_610642
proc url_PostDescribeTableRestoreStatus_613476(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeTableRestoreStatus_613475(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists the status of one or more table restore requests made using the <a>RestoreTableFromClusterSnapshot</a> API action. If you don't specify a value for the <code>TableRestoreRequestId</code> parameter, then <code>DescribeTableRestoreStatus</code> returns the status of all table restore requests ordered by the date and time of the request in ascending order. Otherwise <code>DescribeTableRestoreStatus</code> returns the status of the table specified by <code>TableRestoreRequestId</code>.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_613477 = query.getOrDefault("Action")
  valid_613477 = validateParameter(valid_613477, JString, required = true, default = newJString(
      "DescribeTableRestoreStatus"))
  if valid_613477 != nil:
    section.add "Action", valid_613477
  var valid_613478 = query.getOrDefault("Version")
  valid_613478 = validateParameter(valid_613478, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_613478 != nil:
    section.add "Version", valid_613478
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613479 = header.getOrDefault("X-Amz-Signature")
  valid_613479 = validateParameter(valid_613479, JString, required = false,
                                 default = nil)
  if valid_613479 != nil:
    section.add "X-Amz-Signature", valid_613479
  var valid_613480 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613480 = validateParameter(valid_613480, JString, required = false,
                                 default = nil)
  if valid_613480 != nil:
    section.add "X-Amz-Content-Sha256", valid_613480
  var valid_613481 = header.getOrDefault("X-Amz-Date")
  valid_613481 = validateParameter(valid_613481, JString, required = false,
                                 default = nil)
  if valid_613481 != nil:
    section.add "X-Amz-Date", valid_613481
  var valid_613482 = header.getOrDefault("X-Amz-Credential")
  valid_613482 = validateParameter(valid_613482, JString, required = false,
                                 default = nil)
  if valid_613482 != nil:
    section.add "X-Amz-Credential", valid_613482
  var valid_613483 = header.getOrDefault("X-Amz-Security-Token")
  valid_613483 = validateParameter(valid_613483, JString, required = false,
                                 default = nil)
  if valid_613483 != nil:
    section.add "X-Amz-Security-Token", valid_613483
  var valid_613484 = header.getOrDefault("X-Amz-Algorithm")
  valid_613484 = validateParameter(valid_613484, JString, required = false,
                                 default = nil)
  if valid_613484 != nil:
    section.add "X-Amz-Algorithm", valid_613484
  var valid_613485 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613485 = validateParameter(valid_613485, JString, required = false,
                                 default = nil)
  if valid_613485 != nil:
    section.add "X-Amz-SignedHeaders", valid_613485
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString
  ##                    : The Amazon Redshift cluster that the table is being restored to.
  ##   TableRestoreRequestId: JString
  ##                        : The identifier of the table restore request to return status for. If you don't specify a <code>TableRestoreRequestId</code> value, then <code>DescribeTableRestoreStatus</code> returns the status of all in-progress table restore requests.
  ##   MaxRecords: JInt
  ##             : The maximum number of records to include in the response. If more records exist than the specified <code>MaxRecords</code> value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.
  ##   Marker: JString
  ##         : An optional pagination token provided by a previous <code>DescribeTableRestoreStatus</code> request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by the <code>MaxRecords</code> parameter.
  section = newJObject()
  var valid_613486 = formData.getOrDefault("ClusterIdentifier")
  valid_613486 = validateParameter(valid_613486, JString, required = false,
                                 default = nil)
  if valid_613486 != nil:
    section.add "ClusterIdentifier", valid_613486
  var valid_613487 = formData.getOrDefault("TableRestoreRequestId")
  valid_613487 = validateParameter(valid_613487, JString, required = false,
                                 default = nil)
  if valid_613487 != nil:
    section.add "TableRestoreRequestId", valid_613487
  var valid_613488 = formData.getOrDefault("MaxRecords")
  valid_613488 = validateParameter(valid_613488, JInt, required = false, default = nil)
  if valid_613488 != nil:
    section.add "MaxRecords", valid_613488
  var valid_613489 = formData.getOrDefault("Marker")
  valid_613489 = validateParameter(valid_613489, JString, required = false,
                                 default = nil)
  if valid_613489 != nil:
    section.add "Marker", valid_613489
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613490: Call_PostDescribeTableRestoreStatus_613474; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the status of one or more table restore requests made using the <a>RestoreTableFromClusterSnapshot</a> API action. If you don't specify a value for the <code>TableRestoreRequestId</code> parameter, then <code>DescribeTableRestoreStatus</code> returns the status of all table restore requests ordered by the date and time of the request in ascending order. Otherwise <code>DescribeTableRestoreStatus</code> returns the status of the table specified by <code>TableRestoreRequestId</code>.
  ## 
  let valid = call_613490.validator(path, query, header, formData, body)
  let scheme = call_613490.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613490.url(scheme.get, call_613490.host, call_613490.base,
                         call_613490.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613490, url, valid)

proc call*(call_613491: Call_PostDescribeTableRestoreStatus_613474;
          ClusterIdentifier: string = ""; TableRestoreRequestId: string = "";
          MaxRecords: int = 0; Marker: string = "";
          Action: string = "DescribeTableRestoreStatus";
          Version: string = "2012-12-01"): Recallable =
  ## postDescribeTableRestoreStatus
  ## Lists the status of one or more table restore requests made using the <a>RestoreTableFromClusterSnapshot</a> API action. If you don't specify a value for the <code>TableRestoreRequestId</code> parameter, then <code>DescribeTableRestoreStatus</code> returns the status of all table restore requests ordered by the date and time of the request in ascending order. Otherwise <code>DescribeTableRestoreStatus</code> returns the status of the table specified by <code>TableRestoreRequestId</code>.
  ##   ClusterIdentifier: string
  ##                    : The Amazon Redshift cluster that the table is being restored to.
  ##   TableRestoreRequestId: string
  ##                        : The identifier of the table restore request to return status for. If you don't specify a <code>TableRestoreRequestId</code> value, then <code>DescribeTableRestoreStatus</code> returns the status of all in-progress table restore requests.
  ##   MaxRecords: int
  ##             : The maximum number of records to include in the response. If more records exist than the specified <code>MaxRecords</code> value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.
  ##   Marker: string
  ##         : An optional pagination token provided by a previous <code>DescribeTableRestoreStatus</code> request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by the <code>MaxRecords</code> parameter.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_613492 = newJObject()
  var formData_613493 = newJObject()
  add(formData_613493, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_613493, "TableRestoreRequestId", newJString(TableRestoreRequestId))
  add(formData_613493, "MaxRecords", newJInt(MaxRecords))
  add(formData_613493, "Marker", newJString(Marker))
  add(query_613492, "Action", newJString(Action))
  add(query_613492, "Version", newJString(Version))
  result = call_613491.call(nil, query_613492, nil, formData_613493, nil)

var postDescribeTableRestoreStatus* = Call_PostDescribeTableRestoreStatus_613474(
    name: "postDescribeTableRestoreStatus", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeTableRestoreStatus",
    validator: validate_PostDescribeTableRestoreStatus_613475, base: "/",
    url: url_PostDescribeTableRestoreStatus_613476,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeTableRestoreStatus_613455 = ref object of OpenApiRestCall_610642
proc url_GetDescribeTableRestoreStatus_613457(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeTableRestoreStatus_613456(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists the status of one or more table restore requests made using the <a>RestoreTableFromClusterSnapshot</a> API action. If you don't specify a value for the <code>TableRestoreRequestId</code> parameter, then <code>DescribeTableRestoreStatus</code> returns the status of all table restore requests ordered by the date and time of the request in ascending order. Otherwise <code>DescribeTableRestoreStatus</code> returns the status of the table specified by <code>TableRestoreRequestId</code>.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Marker: JString
  ##         : An optional pagination token provided by a previous <code>DescribeTableRestoreStatus</code> request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by the <code>MaxRecords</code> parameter.
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString
  ##                    : The Amazon Redshift cluster that the table is being restored to.
  ##   Version: JString (required)
  ##   TableRestoreRequestId: JString
  ##                        : The identifier of the table restore request to return status for. If you don't specify a <code>TableRestoreRequestId</code> value, then <code>DescribeTableRestoreStatus</code> returns the status of all in-progress table restore requests.
  ##   MaxRecords: JInt
  ##             : The maximum number of records to include in the response. If more records exist than the specified <code>MaxRecords</code> value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.
  section = newJObject()
  var valid_613458 = query.getOrDefault("Marker")
  valid_613458 = validateParameter(valid_613458, JString, required = false,
                                 default = nil)
  if valid_613458 != nil:
    section.add "Marker", valid_613458
  var valid_613459 = query.getOrDefault("Action")
  valid_613459 = validateParameter(valid_613459, JString, required = true, default = newJString(
      "DescribeTableRestoreStatus"))
  if valid_613459 != nil:
    section.add "Action", valid_613459
  var valid_613460 = query.getOrDefault("ClusterIdentifier")
  valid_613460 = validateParameter(valid_613460, JString, required = false,
                                 default = nil)
  if valid_613460 != nil:
    section.add "ClusterIdentifier", valid_613460
  var valid_613461 = query.getOrDefault("Version")
  valid_613461 = validateParameter(valid_613461, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_613461 != nil:
    section.add "Version", valid_613461
  var valid_613462 = query.getOrDefault("TableRestoreRequestId")
  valid_613462 = validateParameter(valid_613462, JString, required = false,
                                 default = nil)
  if valid_613462 != nil:
    section.add "TableRestoreRequestId", valid_613462
  var valid_613463 = query.getOrDefault("MaxRecords")
  valid_613463 = validateParameter(valid_613463, JInt, required = false, default = nil)
  if valid_613463 != nil:
    section.add "MaxRecords", valid_613463
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613464 = header.getOrDefault("X-Amz-Signature")
  valid_613464 = validateParameter(valid_613464, JString, required = false,
                                 default = nil)
  if valid_613464 != nil:
    section.add "X-Amz-Signature", valid_613464
  var valid_613465 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613465 = validateParameter(valid_613465, JString, required = false,
                                 default = nil)
  if valid_613465 != nil:
    section.add "X-Amz-Content-Sha256", valid_613465
  var valid_613466 = header.getOrDefault("X-Amz-Date")
  valid_613466 = validateParameter(valid_613466, JString, required = false,
                                 default = nil)
  if valid_613466 != nil:
    section.add "X-Amz-Date", valid_613466
  var valid_613467 = header.getOrDefault("X-Amz-Credential")
  valid_613467 = validateParameter(valid_613467, JString, required = false,
                                 default = nil)
  if valid_613467 != nil:
    section.add "X-Amz-Credential", valid_613467
  var valid_613468 = header.getOrDefault("X-Amz-Security-Token")
  valid_613468 = validateParameter(valid_613468, JString, required = false,
                                 default = nil)
  if valid_613468 != nil:
    section.add "X-Amz-Security-Token", valid_613468
  var valid_613469 = header.getOrDefault("X-Amz-Algorithm")
  valid_613469 = validateParameter(valid_613469, JString, required = false,
                                 default = nil)
  if valid_613469 != nil:
    section.add "X-Amz-Algorithm", valid_613469
  var valid_613470 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613470 = validateParameter(valid_613470, JString, required = false,
                                 default = nil)
  if valid_613470 != nil:
    section.add "X-Amz-SignedHeaders", valid_613470
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613471: Call_GetDescribeTableRestoreStatus_613455; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the status of one or more table restore requests made using the <a>RestoreTableFromClusterSnapshot</a> API action. If you don't specify a value for the <code>TableRestoreRequestId</code> parameter, then <code>DescribeTableRestoreStatus</code> returns the status of all table restore requests ordered by the date and time of the request in ascending order. Otherwise <code>DescribeTableRestoreStatus</code> returns the status of the table specified by <code>TableRestoreRequestId</code>.
  ## 
  let valid = call_613471.validator(path, query, header, formData, body)
  let scheme = call_613471.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613471.url(scheme.get, call_613471.host, call_613471.base,
                         call_613471.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613471, url, valid)

proc call*(call_613472: Call_GetDescribeTableRestoreStatus_613455;
          Marker: string = ""; Action: string = "DescribeTableRestoreStatus";
          ClusterIdentifier: string = ""; Version: string = "2012-12-01";
          TableRestoreRequestId: string = ""; MaxRecords: int = 0): Recallable =
  ## getDescribeTableRestoreStatus
  ## Lists the status of one or more table restore requests made using the <a>RestoreTableFromClusterSnapshot</a> API action. If you don't specify a value for the <code>TableRestoreRequestId</code> parameter, then <code>DescribeTableRestoreStatus</code> returns the status of all table restore requests ordered by the date and time of the request in ascending order. Otherwise <code>DescribeTableRestoreStatus</code> returns the status of the table specified by <code>TableRestoreRequestId</code>.
  ##   Marker: string
  ##         : An optional pagination token provided by a previous <code>DescribeTableRestoreStatus</code> request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by the <code>MaxRecords</code> parameter.
  ##   Action: string (required)
  ##   ClusterIdentifier: string
  ##                    : The Amazon Redshift cluster that the table is being restored to.
  ##   Version: string (required)
  ##   TableRestoreRequestId: string
  ##                        : The identifier of the table restore request to return status for. If you don't specify a <code>TableRestoreRequestId</code> value, then <code>DescribeTableRestoreStatus</code> returns the status of all in-progress table restore requests.
  ##   MaxRecords: int
  ##             : The maximum number of records to include in the response. If more records exist than the specified <code>MaxRecords</code> value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.
  var query_613473 = newJObject()
  add(query_613473, "Marker", newJString(Marker))
  add(query_613473, "Action", newJString(Action))
  add(query_613473, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_613473, "Version", newJString(Version))
  add(query_613473, "TableRestoreRequestId", newJString(TableRestoreRequestId))
  add(query_613473, "MaxRecords", newJInt(MaxRecords))
  result = call_613472.call(nil, query_613473, nil, nil, nil)

var getDescribeTableRestoreStatus* = Call_GetDescribeTableRestoreStatus_613455(
    name: "getDescribeTableRestoreStatus", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeTableRestoreStatus",
    validator: validate_GetDescribeTableRestoreStatus_613456, base: "/",
    url: url_GetDescribeTableRestoreStatus_613457,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeTags_613515 = ref object of OpenApiRestCall_610642
proc url_PostDescribeTags_613517(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeTags_613516(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## <p>Returns a list of tags. You can return tags from a specific resource by specifying an ARN, or you can return all tags for a given type of resource, such as clusters, snapshots, and so on.</p> <p>The following are limitations for <code>DescribeTags</code>: </p> <ul> <li> <p>You cannot specify an ARN and a resource-type value together in the same request.</p> </li> <li> <p>You cannot use the <code>MaxRecords</code> and <code>Marker</code> parameters together with the ARN parameter.</p> </li> <li> <p>The <code>MaxRecords</code> parameter can be a range from 10 to 50 results to return in a request.</p> </li> </ul> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all resources that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all resources that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, resources are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_613518 = query.getOrDefault("Action")
  valid_613518 = validateParameter(valid_613518, JString, required = true,
                                 default = newJString("DescribeTags"))
  if valid_613518 != nil:
    section.add "Action", valid_613518
  var valid_613519 = query.getOrDefault("Version")
  valid_613519 = validateParameter(valid_613519, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_613519 != nil:
    section.add "Version", valid_613519
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613520 = header.getOrDefault("X-Amz-Signature")
  valid_613520 = validateParameter(valid_613520, JString, required = false,
                                 default = nil)
  if valid_613520 != nil:
    section.add "X-Amz-Signature", valid_613520
  var valid_613521 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613521 = validateParameter(valid_613521, JString, required = false,
                                 default = nil)
  if valid_613521 != nil:
    section.add "X-Amz-Content-Sha256", valid_613521
  var valid_613522 = header.getOrDefault("X-Amz-Date")
  valid_613522 = validateParameter(valid_613522, JString, required = false,
                                 default = nil)
  if valid_613522 != nil:
    section.add "X-Amz-Date", valid_613522
  var valid_613523 = header.getOrDefault("X-Amz-Credential")
  valid_613523 = validateParameter(valid_613523, JString, required = false,
                                 default = nil)
  if valid_613523 != nil:
    section.add "X-Amz-Credential", valid_613523
  var valid_613524 = header.getOrDefault("X-Amz-Security-Token")
  valid_613524 = validateParameter(valid_613524, JString, required = false,
                                 default = nil)
  if valid_613524 != nil:
    section.add "X-Amz-Security-Token", valid_613524
  var valid_613525 = header.getOrDefault("X-Amz-Algorithm")
  valid_613525 = validateParameter(valid_613525, JString, required = false,
                                 default = nil)
  if valid_613525 != nil:
    section.add "X-Amz-Algorithm", valid_613525
  var valid_613526 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613526 = validateParameter(valid_613526, JString, required = false,
                                 default = nil)
  if valid_613526 != nil:
    section.add "X-Amz-SignedHeaders", valid_613526
  result.add "header", section
  ## parameters in `formData` object:
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching resources that are associated with the specified key or keys. For example, suppose that you have resources tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with all resources that have either or both of these tag keys associated with them.
  ##   MaxRecords: JInt
  ##             : The maximum number or response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned <code>marker</code> value. 
  ##   ResourceType: JString
  ##               : <p>The type of resource with which you want to view tags. Valid resource types are: </p> <ul> <li> <p>Cluster</p> </li> <li> <p>CIDR/IP</p> </li> <li> <p>EC2 security group</p> </li> <li> <p>Snapshot</p> </li> <li> <p>Cluster security group</p> </li> <li> <p>Subnet group</p> </li> <li> <p>HSM connection</p> </li> <li> <p>HSM certificate</p> </li> <li> <p>Parameter group</p> </li> <li> <p>Snapshot copy grant</p> </li> </ul> <p>For more information about Amazon Redshift resource types and constructing ARNs, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-overview.html#redshift-iam-access-control-specify-actions">Specifying Policy Elements: Actions, Effects, Resources, and Principals</a> in the Amazon Redshift Cluster Management Guide. </p>
  ##   Marker: JString
  ##         : A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned marker value in the <code>marker</code> parameter and retrying the command. If the <code>marker</code> field is empty, all response records have been retrieved for the request. 
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching resources that are associated with the specified value or values. For example, suppose that you have resources tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with all resources that have either or both of these tag values associated with them.
  ##   ResourceName: JString
  ##               : The Amazon Resource Name (ARN) for which you want to describe the tag or tags. For example, <code>arn:aws:redshift:us-east-2:123456789:cluster:t1</code>. 
  section = newJObject()
  var valid_613527 = formData.getOrDefault("TagKeys")
  valid_613527 = validateParameter(valid_613527, JArray, required = false,
                                 default = nil)
  if valid_613527 != nil:
    section.add "TagKeys", valid_613527
  var valid_613528 = formData.getOrDefault("MaxRecords")
  valid_613528 = validateParameter(valid_613528, JInt, required = false, default = nil)
  if valid_613528 != nil:
    section.add "MaxRecords", valid_613528
  var valid_613529 = formData.getOrDefault("ResourceType")
  valid_613529 = validateParameter(valid_613529, JString, required = false,
                                 default = nil)
  if valid_613529 != nil:
    section.add "ResourceType", valid_613529
  var valid_613530 = formData.getOrDefault("Marker")
  valid_613530 = validateParameter(valid_613530, JString, required = false,
                                 default = nil)
  if valid_613530 != nil:
    section.add "Marker", valid_613530
  var valid_613531 = formData.getOrDefault("TagValues")
  valid_613531 = validateParameter(valid_613531, JArray, required = false,
                                 default = nil)
  if valid_613531 != nil:
    section.add "TagValues", valid_613531
  var valid_613532 = formData.getOrDefault("ResourceName")
  valid_613532 = validateParameter(valid_613532, JString, required = false,
                                 default = nil)
  if valid_613532 != nil:
    section.add "ResourceName", valid_613532
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613533: Call_PostDescribeTags_613515; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns a list of tags. You can return tags from a specific resource by specifying an ARN, or you can return all tags for a given type of resource, such as clusters, snapshots, and so on.</p> <p>The following are limitations for <code>DescribeTags</code>: </p> <ul> <li> <p>You cannot specify an ARN and a resource-type value together in the same request.</p> </li> <li> <p>You cannot use the <code>MaxRecords</code> and <code>Marker</code> parameters together with the ARN parameter.</p> </li> <li> <p>The <code>MaxRecords</code> parameter can be a range from 10 to 50 results to return in a request.</p> </li> </ul> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all resources that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all resources that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, resources are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_613533.validator(path, query, header, formData, body)
  let scheme = call_613533.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613533.url(scheme.get, call_613533.host, call_613533.base,
                         call_613533.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613533, url, valid)

proc call*(call_613534: Call_PostDescribeTags_613515; TagKeys: JsonNode = nil;
          MaxRecords: int = 0; ResourceType: string = ""; Marker: string = "";
          TagValues: JsonNode = nil; Action: string = "DescribeTags";
          Version: string = "2012-12-01"; ResourceName: string = ""): Recallable =
  ## postDescribeTags
  ## <p>Returns a list of tags. You can return tags from a specific resource by specifying an ARN, or you can return all tags for a given type of resource, such as clusters, snapshots, and so on.</p> <p>The following are limitations for <code>DescribeTags</code>: </p> <ul> <li> <p>You cannot specify an ARN and a resource-type value together in the same request.</p> </li> <li> <p>You cannot use the <code>MaxRecords</code> and <code>Marker</code> parameters together with the ARN parameter.</p> </li> <li> <p>The <code>MaxRecords</code> parameter can be a range from 10 to 50 results to return in a request.</p> </li> </ul> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all resources that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all resources that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, resources are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching resources that are associated with the specified key or keys. For example, suppose that you have resources tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with all resources that have either or both of these tag keys associated with them.
  ##   MaxRecords: int
  ##             : The maximum number or response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned <code>marker</code> value. 
  ##   ResourceType: string
  ##               : <p>The type of resource with which you want to view tags. Valid resource types are: </p> <ul> <li> <p>Cluster</p> </li> <li> <p>CIDR/IP</p> </li> <li> <p>EC2 security group</p> </li> <li> <p>Snapshot</p> </li> <li> <p>Cluster security group</p> </li> <li> <p>Subnet group</p> </li> <li> <p>HSM connection</p> </li> <li> <p>HSM certificate</p> </li> <li> <p>Parameter group</p> </li> <li> <p>Snapshot copy grant</p> </li> </ul> <p>For more information about Amazon Redshift resource types and constructing ARNs, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-overview.html#redshift-iam-access-control-specify-actions">Specifying Policy Elements: Actions, Effects, Resources, and Principals</a> in the Amazon Redshift Cluster Management Guide. </p>
  ##   Marker: string
  ##         : A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned marker value in the <code>marker</code> parameter and retrying the command. If the <code>marker</code> field is empty, all response records have been retrieved for the request. 
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching resources that are associated with the specified value or values. For example, suppose that you have resources tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with all resources that have either or both of these tag values associated with them.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   ResourceName: string
  ##               : The Amazon Resource Name (ARN) for which you want to describe the tag or tags. For example, <code>arn:aws:redshift:us-east-2:123456789:cluster:t1</code>. 
  var query_613535 = newJObject()
  var formData_613536 = newJObject()
  if TagKeys != nil:
    formData_613536.add "TagKeys", TagKeys
  add(formData_613536, "MaxRecords", newJInt(MaxRecords))
  add(formData_613536, "ResourceType", newJString(ResourceType))
  add(formData_613536, "Marker", newJString(Marker))
  if TagValues != nil:
    formData_613536.add "TagValues", TagValues
  add(query_613535, "Action", newJString(Action))
  add(query_613535, "Version", newJString(Version))
  add(formData_613536, "ResourceName", newJString(ResourceName))
  result = call_613534.call(nil, query_613535, nil, formData_613536, nil)

var postDescribeTags* = Call_PostDescribeTags_613515(name: "postDescribeTags",
    meth: HttpMethod.HttpPost, host: "redshift.amazonaws.com",
    route: "/#Action=DescribeTags", validator: validate_PostDescribeTags_613516,
    base: "/", url: url_PostDescribeTags_613517,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeTags_613494 = ref object of OpenApiRestCall_610642
proc url_GetDescribeTags_613496(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeTags_613495(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## <p>Returns a list of tags. You can return tags from a specific resource by specifying an ARN, or you can return all tags for a given type of resource, such as clusters, snapshots, and so on.</p> <p>The following are limitations for <code>DescribeTags</code>: </p> <ul> <li> <p>You cannot specify an ARN and a resource-type value together in the same request.</p> </li> <li> <p>You cannot use the <code>MaxRecords</code> and <code>Marker</code> parameters together with the ARN parameter.</p> </li> <li> <p>The <code>MaxRecords</code> parameter can be a range from 10 to 50 results to return in a request.</p> </li> </ul> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all resources that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all resources that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, resources are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Marker: JString
  ##         : A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned marker value in the <code>marker</code> parameter and retrying the command. If the <code>marker</code> field is empty, all response records have been retrieved for the request. 
  ##   ResourceName: JString
  ##               : The Amazon Resource Name (ARN) for which you want to describe the tag or tags. For example, <code>arn:aws:redshift:us-east-2:123456789:cluster:t1</code>. 
  ##   ResourceType: JString
  ##               : <p>The type of resource with which you want to view tags. Valid resource types are: </p> <ul> <li> <p>Cluster</p> </li> <li> <p>CIDR/IP</p> </li> <li> <p>EC2 security group</p> </li> <li> <p>Snapshot</p> </li> <li> <p>Cluster security group</p> </li> <li> <p>Subnet group</p> </li> <li> <p>HSM connection</p> </li> <li> <p>HSM certificate</p> </li> <li> <p>Parameter group</p> </li> <li> <p>Snapshot copy grant</p> </li> </ul> <p>For more information about Amazon Redshift resource types and constructing ARNs, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-overview.html#redshift-iam-access-control-specify-actions">Specifying Policy Elements: Actions, Effects, Resources, and Principals</a> in the Amazon Redshift Cluster Management Guide. </p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching resources that are associated with the specified key or keys. For example, suppose that you have resources tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with all resources that have either or both of these tag keys associated with them.
  ##   Action: JString (required)
  ##   Version: JString (required)
  ##   MaxRecords: JInt
  ##             : The maximum number or response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned <code>marker</code> value. 
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching resources that are associated with the specified value or values. For example, suppose that you have resources tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with all resources that have either or both of these tag values associated with them.
  section = newJObject()
  var valid_613497 = query.getOrDefault("Marker")
  valid_613497 = validateParameter(valid_613497, JString, required = false,
                                 default = nil)
  if valid_613497 != nil:
    section.add "Marker", valid_613497
  var valid_613498 = query.getOrDefault("ResourceName")
  valid_613498 = validateParameter(valid_613498, JString, required = false,
                                 default = nil)
  if valid_613498 != nil:
    section.add "ResourceName", valid_613498
  var valid_613499 = query.getOrDefault("ResourceType")
  valid_613499 = validateParameter(valid_613499, JString, required = false,
                                 default = nil)
  if valid_613499 != nil:
    section.add "ResourceType", valid_613499
  var valid_613500 = query.getOrDefault("TagKeys")
  valid_613500 = validateParameter(valid_613500, JArray, required = false,
                                 default = nil)
  if valid_613500 != nil:
    section.add "TagKeys", valid_613500
  var valid_613501 = query.getOrDefault("Action")
  valid_613501 = validateParameter(valid_613501, JString, required = true,
                                 default = newJString("DescribeTags"))
  if valid_613501 != nil:
    section.add "Action", valid_613501
  var valid_613502 = query.getOrDefault("Version")
  valid_613502 = validateParameter(valid_613502, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_613502 != nil:
    section.add "Version", valid_613502
  var valid_613503 = query.getOrDefault("MaxRecords")
  valid_613503 = validateParameter(valid_613503, JInt, required = false, default = nil)
  if valid_613503 != nil:
    section.add "MaxRecords", valid_613503
  var valid_613504 = query.getOrDefault("TagValues")
  valid_613504 = validateParameter(valid_613504, JArray, required = false,
                                 default = nil)
  if valid_613504 != nil:
    section.add "TagValues", valid_613504
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613505 = header.getOrDefault("X-Amz-Signature")
  valid_613505 = validateParameter(valid_613505, JString, required = false,
                                 default = nil)
  if valid_613505 != nil:
    section.add "X-Amz-Signature", valid_613505
  var valid_613506 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613506 = validateParameter(valid_613506, JString, required = false,
                                 default = nil)
  if valid_613506 != nil:
    section.add "X-Amz-Content-Sha256", valid_613506
  var valid_613507 = header.getOrDefault("X-Amz-Date")
  valid_613507 = validateParameter(valid_613507, JString, required = false,
                                 default = nil)
  if valid_613507 != nil:
    section.add "X-Amz-Date", valid_613507
  var valid_613508 = header.getOrDefault("X-Amz-Credential")
  valid_613508 = validateParameter(valid_613508, JString, required = false,
                                 default = nil)
  if valid_613508 != nil:
    section.add "X-Amz-Credential", valid_613508
  var valid_613509 = header.getOrDefault("X-Amz-Security-Token")
  valid_613509 = validateParameter(valid_613509, JString, required = false,
                                 default = nil)
  if valid_613509 != nil:
    section.add "X-Amz-Security-Token", valid_613509
  var valid_613510 = header.getOrDefault("X-Amz-Algorithm")
  valid_613510 = validateParameter(valid_613510, JString, required = false,
                                 default = nil)
  if valid_613510 != nil:
    section.add "X-Amz-Algorithm", valid_613510
  var valid_613511 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613511 = validateParameter(valid_613511, JString, required = false,
                                 default = nil)
  if valid_613511 != nil:
    section.add "X-Amz-SignedHeaders", valid_613511
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613512: Call_GetDescribeTags_613494; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns a list of tags. You can return tags from a specific resource by specifying an ARN, or you can return all tags for a given type of resource, such as clusters, snapshots, and so on.</p> <p>The following are limitations for <code>DescribeTags</code>: </p> <ul> <li> <p>You cannot specify an ARN and a resource-type value together in the same request.</p> </li> <li> <p>You cannot use the <code>MaxRecords</code> and <code>Marker</code> parameters together with the ARN parameter.</p> </li> <li> <p>The <code>MaxRecords</code> parameter can be a range from 10 to 50 results to return in a request.</p> </li> </ul> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all resources that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all resources that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, resources are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_613512.validator(path, query, header, formData, body)
  let scheme = call_613512.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613512.url(scheme.get, call_613512.host, call_613512.base,
                         call_613512.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613512, url, valid)

proc call*(call_613513: Call_GetDescribeTags_613494; Marker: string = "";
          ResourceName: string = ""; ResourceType: string = ""; TagKeys: JsonNode = nil;
          Action: string = "DescribeTags"; Version: string = "2012-12-01";
          MaxRecords: int = 0; TagValues: JsonNode = nil): Recallable =
  ## getDescribeTags
  ## <p>Returns a list of tags. You can return tags from a specific resource by specifying an ARN, or you can return all tags for a given type of resource, such as clusters, snapshots, and so on.</p> <p>The following are limitations for <code>DescribeTags</code>: </p> <ul> <li> <p>You cannot specify an ARN and a resource-type value together in the same request.</p> </li> <li> <p>You cannot use the <code>MaxRecords</code> and <code>Marker</code> parameters together with the ARN parameter.</p> </li> <li> <p>The <code>MaxRecords</code> parameter can be a range from 10 to 50 results to return in a request.</p> </li> </ul> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all resources that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all resources that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, resources are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   Marker: string
  ##         : A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned marker value in the <code>marker</code> parameter and retrying the command. If the <code>marker</code> field is empty, all response records have been retrieved for the request. 
  ##   ResourceName: string
  ##               : The Amazon Resource Name (ARN) for which you want to describe the tag or tags. For example, <code>arn:aws:redshift:us-east-2:123456789:cluster:t1</code>. 
  ##   ResourceType: string
  ##               : <p>The type of resource with which you want to view tags. Valid resource types are: </p> <ul> <li> <p>Cluster</p> </li> <li> <p>CIDR/IP</p> </li> <li> <p>EC2 security group</p> </li> <li> <p>Snapshot</p> </li> <li> <p>Cluster security group</p> </li> <li> <p>Subnet group</p> </li> <li> <p>HSM connection</p> </li> <li> <p>HSM certificate</p> </li> <li> <p>Parameter group</p> </li> <li> <p>Snapshot copy grant</p> </li> </ul> <p>For more information about Amazon Redshift resource types and constructing ARNs, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-overview.html#redshift-iam-access-control-specify-actions">Specifying Policy Elements: Actions, Effects, Resources, and Principals</a> in the Amazon Redshift Cluster Management Guide. </p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching resources that are associated with the specified key or keys. For example, suppose that you have resources tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with all resources that have either or both of these tag keys associated with them.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   MaxRecords: int
  ##             : The maximum number or response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned <code>marker</code> value. 
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching resources that are associated with the specified value or values. For example, suppose that you have resources tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with all resources that have either or both of these tag values associated with them.
  var query_613514 = newJObject()
  add(query_613514, "Marker", newJString(Marker))
  add(query_613514, "ResourceName", newJString(ResourceName))
  add(query_613514, "ResourceType", newJString(ResourceType))
  if TagKeys != nil:
    query_613514.add "TagKeys", TagKeys
  add(query_613514, "Action", newJString(Action))
  add(query_613514, "Version", newJString(Version))
  add(query_613514, "MaxRecords", newJInt(MaxRecords))
  if TagValues != nil:
    query_613514.add "TagValues", TagValues
  result = call_613513.call(nil, query_613514, nil, nil, nil)

var getDescribeTags* = Call_GetDescribeTags_613494(name: "getDescribeTags",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=DescribeTags", validator: validate_GetDescribeTags_613495,
    base: "/", url: url_GetDescribeTags_613496, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDisableLogging_613553 = ref object of OpenApiRestCall_610642
proc url_PostDisableLogging_613555(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDisableLogging_613554(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Stops logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_613556 = query.getOrDefault("Action")
  valid_613556 = validateParameter(valid_613556, JString, required = true,
                                 default = newJString("DisableLogging"))
  if valid_613556 != nil:
    section.add "Action", valid_613556
  var valid_613557 = query.getOrDefault("Version")
  valid_613557 = validateParameter(valid_613557, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_613557 != nil:
    section.add "Version", valid_613557
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613558 = header.getOrDefault("X-Amz-Signature")
  valid_613558 = validateParameter(valid_613558, JString, required = false,
                                 default = nil)
  if valid_613558 != nil:
    section.add "X-Amz-Signature", valid_613558
  var valid_613559 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613559 = validateParameter(valid_613559, JString, required = false,
                                 default = nil)
  if valid_613559 != nil:
    section.add "X-Amz-Content-Sha256", valid_613559
  var valid_613560 = header.getOrDefault("X-Amz-Date")
  valid_613560 = validateParameter(valid_613560, JString, required = false,
                                 default = nil)
  if valid_613560 != nil:
    section.add "X-Amz-Date", valid_613560
  var valid_613561 = header.getOrDefault("X-Amz-Credential")
  valid_613561 = validateParameter(valid_613561, JString, required = false,
                                 default = nil)
  if valid_613561 != nil:
    section.add "X-Amz-Credential", valid_613561
  var valid_613562 = header.getOrDefault("X-Amz-Security-Token")
  valid_613562 = validateParameter(valid_613562, JString, required = false,
                                 default = nil)
  if valid_613562 != nil:
    section.add "X-Amz-Security-Token", valid_613562
  var valid_613563 = header.getOrDefault("X-Amz-Algorithm")
  valid_613563 = validateParameter(valid_613563, JString, required = false,
                                 default = nil)
  if valid_613563 != nil:
    section.add "X-Amz-Algorithm", valid_613563
  var valid_613564 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613564 = validateParameter(valid_613564, JString, required = false,
                                 default = nil)
  if valid_613564 != nil:
    section.add "X-Amz-SignedHeaders", valid_613564
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The identifier of the cluster on which logging is to be stopped.</p> <p>Example: <code>examplecluster</code> </p>
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_613565 = formData.getOrDefault("ClusterIdentifier")
  valid_613565 = validateParameter(valid_613565, JString, required = true,
                                 default = nil)
  if valid_613565 != nil:
    section.add "ClusterIdentifier", valid_613565
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613566: Call_PostDisableLogging_613553; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Stops logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
  ## 
  let valid = call_613566.validator(path, query, header, formData, body)
  let scheme = call_613566.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613566.url(scheme.get, call_613566.host, call_613566.base,
                         call_613566.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613566, url, valid)

proc call*(call_613567: Call_PostDisableLogging_613553; ClusterIdentifier: string;
          Action: string = "DisableLogging"; Version: string = "2012-12-01"): Recallable =
  ## postDisableLogging
  ## Stops logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The identifier of the cluster on which logging is to be stopped.</p> <p>Example: <code>examplecluster</code> </p>
  ##   Action: string (required)
  ##   Version: string (required)
  var query_613568 = newJObject()
  var formData_613569 = newJObject()
  add(formData_613569, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_613568, "Action", newJString(Action))
  add(query_613568, "Version", newJString(Version))
  result = call_613567.call(nil, query_613568, nil, formData_613569, nil)

var postDisableLogging* = Call_PostDisableLogging_613553(
    name: "postDisableLogging", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DisableLogging",
    validator: validate_PostDisableLogging_613554, base: "/",
    url: url_PostDisableLogging_613555, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDisableLogging_613537 = ref object of OpenApiRestCall_610642
proc url_GetDisableLogging_613539(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDisableLogging_613538(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## Stops logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The identifier of the cluster on which logging is to be stopped.</p> <p>Example: <code>examplecluster</code> </p>
  ##   Version: JString (required)
  section = newJObject()
  var valid_613540 = query.getOrDefault("Action")
  valid_613540 = validateParameter(valid_613540, JString, required = true,
                                 default = newJString("DisableLogging"))
  if valid_613540 != nil:
    section.add "Action", valid_613540
  var valid_613541 = query.getOrDefault("ClusterIdentifier")
  valid_613541 = validateParameter(valid_613541, JString, required = true,
                                 default = nil)
  if valid_613541 != nil:
    section.add "ClusterIdentifier", valid_613541
  var valid_613542 = query.getOrDefault("Version")
  valid_613542 = validateParameter(valid_613542, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_613542 != nil:
    section.add "Version", valid_613542
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613543 = header.getOrDefault("X-Amz-Signature")
  valid_613543 = validateParameter(valid_613543, JString, required = false,
                                 default = nil)
  if valid_613543 != nil:
    section.add "X-Amz-Signature", valid_613543
  var valid_613544 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613544 = validateParameter(valid_613544, JString, required = false,
                                 default = nil)
  if valid_613544 != nil:
    section.add "X-Amz-Content-Sha256", valid_613544
  var valid_613545 = header.getOrDefault("X-Amz-Date")
  valid_613545 = validateParameter(valid_613545, JString, required = false,
                                 default = nil)
  if valid_613545 != nil:
    section.add "X-Amz-Date", valid_613545
  var valid_613546 = header.getOrDefault("X-Amz-Credential")
  valid_613546 = validateParameter(valid_613546, JString, required = false,
                                 default = nil)
  if valid_613546 != nil:
    section.add "X-Amz-Credential", valid_613546
  var valid_613547 = header.getOrDefault("X-Amz-Security-Token")
  valid_613547 = validateParameter(valid_613547, JString, required = false,
                                 default = nil)
  if valid_613547 != nil:
    section.add "X-Amz-Security-Token", valid_613547
  var valid_613548 = header.getOrDefault("X-Amz-Algorithm")
  valid_613548 = validateParameter(valid_613548, JString, required = false,
                                 default = nil)
  if valid_613548 != nil:
    section.add "X-Amz-Algorithm", valid_613548
  var valid_613549 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613549 = validateParameter(valid_613549, JString, required = false,
                                 default = nil)
  if valid_613549 != nil:
    section.add "X-Amz-SignedHeaders", valid_613549
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613550: Call_GetDisableLogging_613537; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Stops logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
  ## 
  let valid = call_613550.validator(path, query, header, formData, body)
  let scheme = call_613550.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613550.url(scheme.get, call_613550.host, call_613550.base,
                         call_613550.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613550, url, valid)

proc call*(call_613551: Call_GetDisableLogging_613537; ClusterIdentifier: string;
          Action: string = "DisableLogging"; Version: string = "2012-12-01"): Recallable =
  ## getDisableLogging
  ## Stops logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The identifier of the cluster on which logging is to be stopped.</p> <p>Example: <code>examplecluster</code> </p>
  ##   Version: string (required)
  var query_613552 = newJObject()
  add(query_613552, "Action", newJString(Action))
  add(query_613552, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_613552, "Version", newJString(Version))
  result = call_613551.call(nil, query_613552, nil, nil, nil)

var getDisableLogging* = Call_GetDisableLogging_613537(name: "getDisableLogging",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=DisableLogging", validator: validate_GetDisableLogging_613538,
    base: "/", url: url_GetDisableLogging_613539,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDisableSnapshotCopy_613586 = ref object of OpenApiRestCall_610642
proc url_PostDisableSnapshotCopy_613588(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDisableSnapshotCopy_613587(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Disables the automatic copying of snapshots from one region to another region for a specified cluster.</p> <p>If your cluster and its snapshots are encrypted using a customer master key (CMK) from AWS KMS, use <a>DeleteSnapshotCopyGrant</a> to delete the grant that grants Amazon Redshift permission to the CMK in the destination region. </p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_613589 = query.getOrDefault("Action")
  valid_613589 = validateParameter(valid_613589, JString, required = true,
                                 default = newJString("DisableSnapshotCopy"))
  if valid_613589 != nil:
    section.add "Action", valid_613589
  var valid_613590 = query.getOrDefault("Version")
  valid_613590 = validateParameter(valid_613590, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_613590 != nil:
    section.add "Version", valid_613590
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613591 = header.getOrDefault("X-Amz-Signature")
  valid_613591 = validateParameter(valid_613591, JString, required = false,
                                 default = nil)
  if valid_613591 != nil:
    section.add "X-Amz-Signature", valid_613591
  var valid_613592 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613592 = validateParameter(valid_613592, JString, required = false,
                                 default = nil)
  if valid_613592 != nil:
    section.add "X-Amz-Content-Sha256", valid_613592
  var valid_613593 = header.getOrDefault("X-Amz-Date")
  valid_613593 = validateParameter(valid_613593, JString, required = false,
                                 default = nil)
  if valid_613593 != nil:
    section.add "X-Amz-Date", valid_613593
  var valid_613594 = header.getOrDefault("X-Amz-Credential")
  valid_613594 = validateParameter(valid_613594, JString, required = false,
                                 default = nil)
  if valid_613594 != nil:
    section.add "X-Amz-Credential", valid_613594
  var valid_613595 = header.getOrDefault("X-Amz-Security-Token")
  valid_613595 = validateParameter(valid_613595, JString, required = false,
                                 default = nil)
  if valid_613595 != nil:
    section.add "X-Amz-Security-Token", valid_613595
  var valid_613596 = header.getOrDefault("X-Amz-Algorithm")
  valid_613596 = validateParameter(valid_613596, JString, required = false,
                                 default = nil)
  if valid_613596 != nil:
    section.add "X-Amz-Algorithm", valid_613596
  var valid_613597 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613597 = validateParameter(valid_613597, JString, required = false,
                                 default = nil)
  if valid_613597 != nil:
    section.add "X-Amz-SignedHeaders", valid_613597
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of the source cluster that you want to disable copying of snapshots to a destination region.</p> <p>Constraints: Must be the valid name of an existing cluster that has cross-region snapshot copy enabled.</p>
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_613598 = formData.getOrDefault("ClusterIdentifier")
  valid_613598 = validateParameter(valid_613598, JString, required = true,
                                 default = nil)
  if valid_613598 != nil:
    section.add "ClusterIdentifier", valid_613598
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613599: Call_PostDisableSnapshotCopy_613586; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Disables the automatic copying of snapshots from one region to another region for a specified cluster.</p> <p>If your cluster and its snapshots are encrypted using a customer master key (CMK) from AWS KMS, use <a>DeleteSnapshotCopyGrant</a> to delete the grant that grants Amazon Redshift permission to the CMK in the destination region. </p>
  ## 
  let valid = call_613599.validator(path, query, header, formData, body)
  let scheme = call_613599.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613599.url(scheme.get, call_613599.host, call_613599.base,
                         call_613599.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613599, url, valid)

proc call*(call_613600: Call_PostDisableSnapshotCopy_613586;
          ClusterIdentifier: string; Action: string = "DisableSnapshotCopy";
          Version: string = "2012-12-01"): Recallable =
  ## postDisableSnapshotCopy
  ## <p>Disables the automatic copying of snapshots from one region to another region for a specified cluster.</p> <p>If your cluster and its snapshots are encrypted using a customer master key (CMK) from AWS KMS, use <a>DeleteSnapshotCopyGrant</a> to delete the grant that grants Amazon Redshift permission to the CMK in the destination region. </p>
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of the source cluster that you want to disable copying of snapshots to a destination region.</p> <p>Constraints: Must be the valid name of an existing cluster that has cross-region snapshot copy enabled.</p>
  ##   Action: string (required)
  ##   Version: string (required)
  var query_613601 = newJObject()
  var formData_613602 = newJObject()
  add(formData_613602, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_613601, "Action", newJString(Action))
  add(query_613601, "Version", newJString(Version))
  result = call_613600.call(nil, query_613601, nil, formData_613602, nil)

var postDisableSnapshotCopy* = Call_PostDisableSnapshotCopy_613586(
    name: "postDisableSnapshotCopy", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DisableSnapshotCopy",
    validator: validate_PostDisableSnapshotCopy_613587, base: "/",
    url: url_PostDisableSnapshotCopy_613588, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDisableSnapshotCopy_613570 = ref object of OpenApiRestCall_610642
proc url_GetDisableSnapshotCopy_613572(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDisableSnapshotCopy_613571(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Disables the automatic copying of snapshots from one region to another region for a specified cluster.</p> <p>If your cluster and its snapshots are encrypted using a customer master key (CMK) from AWS KMS, use <a>DeleteSnapshotCopyGrant</a> to delete the grant that grants Amazon Redshift permission to the CMK in the destination region. </p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of the source cluster that you want to disable copying of snapshots to a destination region.</p> <p>Constraints: Must be the valid name of an existing cluster that has cross-region snapshot copy enabled.</p>
  ##   Version: JString (required)
  section = newJObject()
  var valid_613573 = query.getOrDefault("Action")
  valid_613573 = validateParameter(valid_613573, JString, required = true,
                                 default = newJString("DisableSnapshotCopy"))
  if valid_613573 != nil:
    section.add "Action", valid_613573
  var valid_613574 = query.getOrDefault("ClusterIdentifier")
  valid_613574 = validateParameter(valid_613574, JString, required = true,
                                 default = nil)
  if valid_613574 != nil:
    section.add "ClusterIdentifier", valid_613574
  var valid_613575 = query.getOrDefault("Version")
  valid_613575 = validateParameter(valid_613575, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_613575 != nil:
    section.add "Version", valid_613575
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613576 = header.getOrDefault("X-Amz-Signature")
  valid_613576 = validateParameter(valid_613576, JString, required = false,
                                 default = nil)
  if valid_613576 != nil:
    section.add "X-Amz-Signature", valid_613576
  var valid_613577 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613577 = validateParameter(valid_613577, JString, required = false,
                                 default = nil)
  if valid_613577 != nil:
    section.add "X-Amz-Content-Sha256", valid_613577
  var valid_613578 = header.getOrDefault("X-Amz-Date")
  valid_613578 = validateParameter(valid_613578, JString, required = false,
                                 default = nil)
  if valid_613578 != nil:
    section.add "X-Amz-Date", valid_613578
  var valid_613579 = header.getOrDefault("X-Amz-Credential")
  valid_613579 = validateParameter(valid_613579, JString, required = false,
                                 default = nil)
  if valid_613579 != nil:
    section.add "X-Amz-Credential", valid_613579
  var valid_613580 = header.getOrDefault("X-Amz-Security-Token")
  valid_613580 = validateParameter(valid_613580, JString, required = false,
                                 default = nil)
  if valid_613580 != nil:
    section.add "X-Amz-Security-Token", valid_613580
  var valid_613581 = header.getOrDefault("X-Amz-Algorithm")
  valid_613581 = validateParameter(valid_613581, JString, required = false,
                                 default = nil)
  if valid_613581 != nil:
    section.add "X-Amz-Algorithm", valid_613581
  var valid_613582 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613582 = validateParameter(valid_613582, JString, required = false,
                                 default = nil)
  if valid_613582 != nil:
    section.add "X-Amz-SignedHeaders", valid_613582
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613583: Call_GetDisableSnapshotCopy_613570; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Disables the automatic copying of snapshots from one region to another region for a specified cluster.</p> <p>If your cluster and its snapshots are encrypted using a customer master key (CMK) from AWS KMS, use <a>DeleteSnapshotCopyGrant</a> to delete the grant that grants Amazon Redshift permission to the CMK in the destination region. </p>
  ## 
  let valid = call_613583.validator(path, query, header, formData, body)
  let scheme = call_613583.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613583.url(scheme.get, call_613583.host, call_613583.base,
                         call_613583.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613583, url, valid)

proc call*(call_613584: Call_GetDisableSnapshotCopy_613570;
          ClusterIdentifier: string; Action: string = "DisableSnapshotCopy";
          Version: string = "2012-12-01"): Recallable =
  ## getDisableSnapshotCopy
  ## <p>Disables the automatic copying of snapshots from one region to another region for a specified cluster.</p> <p>If your cluster and its snapshots are encrypted using a customer master key (CMK) from AWS KMS, use <a>DeleteSnapshotCopyGrant</a> to delete the grant that grants Amazon Redshift permission to the CMK in the destination region. </p>
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of the source cluster that you want to disable copying of snapshots to a destination region.</p> <p>Constraints: Must be the valid name of an existing cluster that has cross-region snapshot copy enabled.</p>
  ##   Version: string (required)
  var query_613585 = newJObject()
  add(query_613585, "Action", newJString(Action))
  add(query_613585, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_613585, "Version", newJString(Version))
  result = call_613584.call(nil, query_613585, nil, nil, nil)

var getDisableSnapshotCopy* = Call_GetDisableSnapshotCopy_613570(
    name: "getDisableSnapshotCopy", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DisableSnapshotCopy",
    validator: validate_GetDisableSnapshotCopy_613571, base: "/",
    url: url_GetDisableSnapshotCopy_613572, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostEnableLogging_613621 = ref object of OpenApiRestCall_610642
proc url_PostEnableLogging_613623(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostEnableLogging_613622(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## Starts logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_613624 = query.getOrDefault("Action")
  valid_613624 = validateParameter(valid_613624, JString, required = true,
                                 default = newJString("EnableLogging"))
  if valid_613624 != nil:
    section.add "Action", valid_613624
  var valid_613625 = query.getOrDefault("Version")
  valid_613625 = validateParameter(valid_613625, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_613625 != nil:
    section.add "Version", valid_613625
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613626 = header.getOrDefault("X-Amz-Signature")
  valid_613626 = validateParameter(valid_613626, JString, required = false,
                                 default = nil)
  if valid_613626 != nil:
    section.add "X-Amz-Signature", valid_613626
  var valid_613627 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613627 = validateParameter(valid_613627, JString, required = false,
                                 default = nil)
  if valid_613627 != nil:
    section.add "X-Amz-Content-Sha256", valid_613627
  var valid_613628 = header.getOrDefault("X-Amz-Date")
  valid_613628 = validateParameter(valid_613628, JString, required = false,
                                 default = nil)
  if valid_613628 != nil:
    section.add "X-Amz-Date", valid_613628
  var valid_613629 = header.getOrDefault("X-Amz-Credential")
  valid_613629 = validateParameter(valid_613629, JString, required = false,
                                 default = nil)
  if valid_613629 != nil:
    section.add "X-Amz-Credential", valid_613629
  var valid_613630 = header.getOrDefault("X-Amz-Security-Token")
  valid_613630 = validateParameter(valid_613630, JString, required = false,
                                 default = nil)
  if valid_613630 != nil:
    section.add "X-Amz-Security-Token", valid_613630
  var valid_613631 = header.getOrDefault("X-Amz-Algorithm")
  valid_613631 = validateParameter(valid_613631, JString, required = false,
                                 default = nil)
  if valid_613631 != nil:
    section.add "X-Amz-Algorithm", valid_613631
  var valid_613632 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613632 = validateParameter(valid_613632, JString, required = false,
                                 default = nil)
  if valid_613632 != nil:
    section.add "X-Amz-SignedHeaders", valid_613632
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The identifier of the cluster on which logging is to be started.</p> <p>Example: <code>examplecluster</code> </p>
  ##   BucketName: JString (required)
  ##             : <p>The name of an existing S3 bucket where the log files are to be stored.</p> <p>Constraints:</p> <ul> <li> <p>Must be in the same region as the cluster</p> </li> <li> <p>The cluster must have read bucket and put object permissions</p> </li> </ul>
  ##   S3KeyPrefix: JString
  ##              : <p>The prefix applied to the log file names.</p> <p>Constraints:</p> <ul> <li> <p>Cannot exceed 512 characters</p> </li> <li> <p>Cannot contain spaces( ), double quotes ("), single quotes ('), a backslash (\), or control characters. The hexadecimal codes for invalid characters are: </p> <ul> <li> <p>x00 to x20</p> </li> <li> <p>x22</p> </li> <li> <p>x27</p> </li> <li> <p>x5c</p> </li> <li> <p>x7f or larger</p> </li> </ul> </li> </ul>
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_613633 = formData.getOrDefault("ClusterIdentifier")
  valid_613633 = validateParameter(valid_613633, JString, required = true,
                                 default = nil)
  if valid_613633 != nil:
    section.add "ClusterIdentifier", valid_613633
  var valid_613634 = formData.getOrDefault("BucketName")
  valid_613634 = validateParameter(valid_613634, JString, required = true,
                                 default = nil)
  if valid_613634 != nil:
    section.add "BucketName", valid_613634
  var valid_613635 = formData.getOrDefault("S3KeyPrefix")
  valid_613635 = validateParameter(valid_613635, JString, required = false,
                                 default = nil)
  if valid_613635 != nil:
    section.add "S3KeyPrefix", valid_613635
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613636: Call_PostEnableLogging_613621; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Starts logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
  ## 
  let valid = call_613636.validator(path, query, header, formData, body)
  let scheme = call_613636.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613636.url(scheme.get, call_613636.host, call_613636.base,
                         call_613636.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613636, url, valid)

proc call*(call_613637: Call_PostEnableLogging_613621; ClusterIdentifier: string;
          BucketName: string; Action: string = "EnableLogging";
          Version: string = "2012-12-01"; S3KeyPrefix: string = ""): Recallable =
  ## postEnableLogging
  ## Starts logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The identifier of the cluster on which logging is to be started.</p> <p>Example: <code>examplecluster</code> </p>
  ##   Action: string (required)
  ##   BucketName: string (required)
  ##             : <p>The name of an existing S3 bucket where the log files are to be stored.</p> <p>Constraints:</p> <ul> <li> <p>Must be in the same region as the cluster</p> </li> <li> <p>The cluster must have read bucket and put object permissions</p> </li> </ul>
  ##   Version: string (required)
  ##   S3KeyPrefix: string
  ##              : <p>The prefix applied to the log file names.</p> <p>Constraints:</p> <ul> <li> <p>Cannot exceed 512 characters</p> </li> <li> <p>Cannot contain spaces( ), double quotes ("), single quotes ('), a backslash (\), or control characters. The hexadecimal codes for invalid characters are: </p> <ul> <li> <p>x00 to x20</p> </li> <li> <p>x22</p> </li> <li> <p>x27</p> </li> <li> <p>x5c</p> </li> <li> <p>x7f or larger</p> </li> </ul> </li> </ul>
  var query_613638 = newJObject()
  var formData_613639 = newJObject()
  add(formData_613639, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_613638, "Action", newJString(Action))
  add(formData_613639, "BucketName", newJString(BucketName))
  add(query_613638, "Version", newJString(Version))
  add(formData_613639, "S3KeyPrefix", newJString(S3KeyPrefix))
  result = call_613637.call(nil, query_613638, nil, formData_613639, nil)

var postEnableLogging* = Call_PostEnableLogging_613621(name: "postEnableLogging",
    meth: HttpMethod.HttpPost, host: "redshift.amazonaws.com",
    route: "/#Action=EnableLogging", validator: validate_PostEnableLogging_613622,
    base: "/", url: url_PostEnableLogging_613623,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetEnableLogging_613603 = ref object of OpenApiRestCall_610642
proc url_GetEnableLogging_613605(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetEnableLogging_613604(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Starts logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   BucketName: JString (required)
  ##             : <p>The name of an existing S3 bucket where the log files are to be stored.</p> <p>Constraints:</p> <ul> <li> <p>Must be in the same region as the cluster</p> </li> <li> <p>The cluster must have read bucket and put object permissions</p> </li> </ul>
  ##   S3KeyPrefix: JString
  ##              : <p>The prefix applied to the log file names.</p> <p>Constraints:</p> <ul> <li> <p>Cannot exceed 512 characters</p> </li> <li> <p>Cannot contain spaces( ), double quotes ("), single quotes ('), a backslash (\), or control characters. The hexadecimal codes for invalid characters are: </p> <ul> <li> <p>x00 to x20</p> </li> <li> <p>x22</p> </li> <li> <p>x27</p> </li> <li> <p>x5c</p> </li> <li> <p>x7f or larger</p> </li> </ul> </li> </ul>
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The identifier of the cluster on which logging is to be started.</p> <p>Example: <code>examplecluster</code> </p>
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `BucketName` field"
  var valid_613606 = query.getOrDefault("BucketName")
  valid_613606 = validateParameter(valid_613606, JString, required = true,
                                 default = nil)
  if valid_613606 != nil:
    section.add "BucketName", valid_613606
  var valid_613607 = query.getOrDefault("S3KeyPrefix")
  valid_613607 = validateParameter(valid_613607, JString, required = false,
                                 default = nil)
  if valid_613607 != nil:
    section.add "S3KeyPrefix", valid_613607
  var valid_613608 = query.getOrDefault("Action")
  valid_613608 = validateParameter(valid_613608, JString, required = true,
                                 default = newJString("EnableLogging"))
  if valid_613608 != nil:
    section.add "Action", valid_613608
  var valid_613609 = query.getOrDefault("ClusterIdentifier")
  valid_613609 = validateParameter(valid_613609, JString, required = true,
                                 default = nil)
  if valid_613609 != nil:
    section.add "ClusterIdentifier", valid_613609
  var valid_613610 = query.getOrDefault("Version")
  valid_613610 = validateParameter(valid_613610, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_613610 != nil:
    section.add "Version", valid_613610
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613611 = header.getOrDefault("X-Amz-Signature")
  valid_613611 = validateParameter(valid_613611, JString, required = false,
                                 default = nil)
  if valid_613611 != nil:
    section.add "X-Amz-Signature", valid_613611
  var valid_613612 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613612 = validateParameter(valid_613612, JString, required = false,
                                 default = nil)
  if valid_613612 != nil:
    section.add "X-Amz-Content-Sha256", valid_613612
  var valid_613613 = header.getOrDefault("X-Amz-Date")
  valid_613613 = validateParameter(valid_613613, JString, required = false,
                                 default = nil)
  if valid_613613 != nil:
    section.add "X-Amz-Date", valid_613613
  var valid_613614 = header.getOrDefault("X-Amz-Credential")
  valid_613614 = validateParameter(valid_613614, JString, required = false,
                                 default = nil)
  if valid_613614 != nil:
    section.add "X-Amz-Credential", valid_613614
  var valid_613615 = header.getOrDefault("X-Amz-Security-Token")
  valid_613615 = validateParameter(valid_613615, JString, required = false,
                                 default = nil)
  if valid_613615 != nil:
    section.add "X-Amz-Security-Token", valid_613615
  var valid_613616 = header.getOrDefault("X-Amz-Algorithm")
  valid_613616 = validateParameter(valid_613616, JString, required = false,
                                 default = nil)
  if valid_613616 != nil:
    section.add "X-Amz-Algorithm", valid_613616
  var valid_613617 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613617 = validateParameter(valid_613617, JString, required = false,
                                 default = nil)
  if valid_613617 != nil:
    section.add "X-Amz-SignedHeaders", valid_613617
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613618: Call_GetEnableLogging_613603; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Starts logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
  ## 
  let valid = call_613618.validator(path, query, header, formData, body)
  let scheme = call_613618.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613618.url(scheme.get, call_613618.host, call_613618.base,
                         call_613618.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613618, url, valid)

proc call*(call_613619: Call_GetEnableLogging_613603; BucketName: string;
          ClusterIdentifier: string; S3KeyPrefix: string = "";
          Action: string = "EnableLogging"; Version: string = "2012-12-01"): Recallable =
  ## getEnableLogging
  ## Starts logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
  ##   BucketName: string (required)
  ##             : <p>The name of an existing S3 bucket where the log files are to be stored.</p> <p>Constraints:</p> <ul> <li> <p>Must be in the same region as the cluster</p> </li> <li> <p>The cluster must have read bucket and put object permissions</p> </li> </ul>
  ##   S3KeyPrefix: string
  ##              : <p>The prefix applied to the log file names.</p> <p>Constraints:</p> <ul> <li> <p>Cannot exceed 512 characters</p> </li> <li> <p>Cannot contain spaces( ), double quotes ("), single quotes ('), a backslash (\), or control characters. The hexadecimal codes for invalid characters are: </p> <ul> <li> <p>x00 to x20</p> </li> <li> <p>x22</p> </li> <li> <p>x27</p> </li> <li> <p>x5c</p> </li> <li> <p>x7f or larger</p> </li> </ul> </li> </ul>
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The identifier of the cluster on which logging is to be started.</p> <p>Example: <code>examplecluster</code> </p>
  ##   Version: string (required)
  var query_613620 = newJObject()
  add(query_613620, "BucketName", newJString(BucketName))
  add(query_613620, "S3KeyPrefix", newJString(S3KeyPrefix))
  add(query_613620, "Action", newJString(Action))
  add(query_613620, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_613620, "Version", newJString(Version))
  result = call_613619.call(nil, query_613620, nil, nil, nil)

var getEnableLogging* = Call_GetEnableLogging_613603(name: "getEnableLogging",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=EnableLogging", validator: validate_GetEnableLogging_613604,
    base: "/", url: url_GetEnableLogging_613605,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostEnableSnapshotCopy_613660 = ref object of OpenApiRestCall_610642
proc url_PostEnableSnapshotCopy_613662(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostEnableSnapshotCopy_613661(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Enables the automatic copy of snapshots from one region to another region for a specified cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_613663 = query.getOrDefault("Action")
  valid_613663 = validateParameter(valid_613663, JString, required = true,
                                 default = newJString("EnableSnapshotCopy"))
  if valid_613663 != nil:
    section.add "Action", valid_613663
  var valid_613664 = query.getOrDefault("Version")
  valid_613664 = validateParameter(valid_613664, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_613664 != nil:
    section.add "Version", valid_613664
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613665 = header.getOrDefault("X-Amz-Signature")
  valid_613665 = validateParameter(valid_613665, JString, required = false,
                                 default = nil)
  if valid_613665 != nil:
    section.add "X-Amz-Signature", valid_613665
  var valid_613666 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613666 = validateParameter(valid_613666, JString, required = false,
                                 default = nil)
  if valid_613666 != nil:
    section.add "X-Amz-Content-Sha256", valid_613666
  var valid_613667 = header.getOrDefault("X-Amz-Date")
  valid_613667 = validateParameter(valid_613667, JString, required = false,
                                 default = nil)
  if valid_613667 != nil:
    section.add "X-Amz-Date", valid_613667
  var valid_613668 = header.getOrDefault("X-Amz-Credential")
  valid_613668 = validateParameter(valid_613668, JString, required = false,
                                 default = nil)
  if valid_613668 != nil:
    section.add "X-Amz-Credential", valid_613668
  var valid_613669 = header.getOrDefault("X-Amz-Security-Token")
  valid_613669 = validateParameter(valid_613669, JString, required = false,
                                 default = nil)
  if valid_613669 != nil:
    section.add "X-Amz-Security-Token", valid_613669
  var valid_613670 = header.getOrDefault("X-Amz-Algorithm")
  valid_613670 = validateParameter(valid_613670, JString, required = false,
                                 default = nil)
  if valid_613670 != nil:
    section.add "X-Amz-Algorithm", valid_613670
  var valid_613671 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613671 = validateParameter(valid_613671, JString, required = false,
                                 default = nil)
  if valid_613671 != nil:
    section.add "X-Amz-SignedHeaders", valid_613671
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of the source cluster to copy snapshots from.</p> <p>Constraints: Must be the valid name of an existing cluster that does not already have cross-region snapshot copy enabled.</p>
  ##   RetentionPeriod: JInt
  ##                  : <p>The number of days to retain automated snapshots in the destination region after they are copied from the source region.</p> <p>Default: 7.</p> <p>Constraints: Must be at least 1 and no more than 35.</p>
  ##   DestinationRegion: JString (required)
  ##                    : <p>The destination AWS Region that you want to copy snapshots to.</p> <p>Constraints: Must be the name of a valid AWS Region. For more information, see <a 
  ## href="https://docs.aws.amazon.com/general/latest/gr/rande.html#redshift_region">Regions and Endpoints</a> in the Amazon Web Services General Reference. </p>
  ##   SnapshotCopyGrantName: JString
  ##                        : The name of the snapshot copy grant to use when snapshots of an AWS KMS-encrypted cluster are copied to the destination region.
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The number of days to retain newly copied snapshots in the destination AWS Region after they are copied from the source AWS Region. If the value is -1, the manual snapshot is retained indefinitely. </p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_613672 = formData.getOrDefault("ClusterIdentifier")
  valid_613672 = validateParameter(valid_613672, JString, required = true,
                                 default = nil)
  if valid_613672 != nil:
    section.add "ClusterIdentifier", valid_613672
  var valid_613673 = formData.getOrDefault("RetentionPeriod")
  valid_613673 = validateParameter(valid_613673, JInt, required = false, default = nil)
  if valid_613673 != nil:
    section.add "RetentionPeriod", valid_613673
  var valid_613674 = formData.getOrDefault("DestinationRegion")
  valid_613674 = validateParameter(valid_613674, JString, required = true,
                                 default = nil)
  if valid_613674 != nil:
    section.add "DestinationRegion", valid_613674
  var valid_613675 = formData.getOrDefault("SnapshotCopyGrantName")
  valid_613675 = validateParameter(valid_613675, JString, required = false,
                                 default = nil)
  if valid_613675 != nil:
    section.add "SnapshotCopyGrantName", valid_613675
  var valid_613676 = formData.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_613676 = validateParameter(valid_613676, JInt, required = false, default = nil)
  if valid_613676 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_613676
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613677: Call_PostEnableSnapshotCopy_613660; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Enables the automatic copy of snapshots from one region to another region for a specified cluster.
  ## 
  let valid = call_613677.validator(path, query, header, formData, body)
  let scheme = call_613677.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613677.url(scheme.get, call_613677.host, call_613677.base,
                         call_613677.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613677, url, valid)

proc call*(call_613678: Call_PostEnableSnapshotCopy_613660;
          ClusterIdentifier: string; DestinationRegion: string;
          RetentionPeriod: int = 0; Action: string = "EnableSnapshotCopy";
          SnapshotCopyGrantName: string = ""; Version: string = "2012-12-01";
          ManualSnapshotRetentionPeriod: int = 0): Recallable =
  ## postEnableSnapshotCopy
  ## Enables the automatic copy of snapshots from one region to another region for a specified cluster.
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of the source cluster to copy snapshots from.</p> <p>Constraints: Must be the valid name of an existing cluster that does not already have cross-region snapshot copy enabled.</p>
  ##   RetentionPeriod: int
  ##                  : <p>The number of days to retain automated snapshots in the destination region after they are copied from the source region.</p> <p>Default: 7.</p> <p>Constraints: Must be at least 1 and no more than 35.</p>
  ##   DestinationRegion: string (required)
  ##                    : <p>The destination AWS Region that you want to copy snapshots to.</p> <p>Constraints: Must be the name of a valid AWS Region. For more information, see <a 
  ## href="https://docs.aws.amazon.com/general/latest/gr/rande.html#redshift_region">Regions and Endpoints</a> in the Amazon Web Services General Reference. </p>
  ##   Action: string (required)
  ##   SnapshotCopyGrantName: string
  ##                        : The name of the snapshot copy grant to use when snapshots of an AWS KMS-encrypted cluster are copied to the destination region.
  ##   Version: string (required)
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The number of days to retain newly copied snapshots in the destination AWS Region after they are copied from the source AWS Region. If the value is -1, the manual snapshot is retained indefinitely. </p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  var query_613679 = newJObject()
  var formData_613680 = newJObject()
  add(formData_613680, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_613680, "RetentionPeriod", newJInt(RetentionPeriod))
  add(formData_613680, "DestinationRegion", newJString(DestinationRegion))
  add(query_613679, "Action", newJString(Action))
  add(formData_613680, "SnapshotCopyGrantName", newJString(SnapshotCopyGrantName))
  add(query_613679, "Version", newJString(Version))
  add(formData_613680, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  result = call_613678.call(nil, query_613679, nil, formData_613680, nil)

var postEnableSnapshotCopy* = Call_PostEnableSnapshotCopy_613660(
    name: "postEnableSnapshotCopy", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=EnableSnapshotCopy",
    validator: validate_PostEnableSnapshotCopy_613661, base: "/",
    url: url_PostEnableSnapshotCopy_613662, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetEnableSnapshotCopy_613640 = ref object of OpenApiRestCall_610642
proc url_GetEnableSnapshotCopy_613642(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetEnableSnapshotCopy_613641(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Enables the automatic copy of snapshots from one region to another region for a specified cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The number of days to retain newly copied snapshots in the destination AWS Region after they are copied from the source AWS Region. If the value is -1, the manual snapshot is retained indefinitely. </p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  ##   DestinationRegion: JString (required)
  ##                    : <p>The destination AWS Region that you want to copy snapshots to.</p> <p>Constraints: Must be the name of a valid AWS Region. For more information, see <a 
  ## href="https://docs.aws.amazon.com/general/latest/gr/rande.html#redshift_region">Regions and Endpoints</a> in the Amazon Web Services General Reference. </p>
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of the source cluster to copy snapshots from.</p> <p>Constraints: Must be the valid name of an existing cluster that does not already have cross-region snapshot copy enabled.</p>
  ##   Version: JString (required)
  ##   RetentionPeriod: JInt
  ##                  : <p>The number of days to retain automated snapshots in the destination region after they are copied from the source region.</p> <p>Default: 7.</p> <p>Constraints: Must be at least 1 and no more than 35.</p>
  ##   SnapshotCopyGrantName: JString
  ##                        : The name of the snapshot copy grant to use when snapshots of an AWS KMS-encrypted cluster are copied to the destination region.
  section = newJObject()
  var valid_613643 = query.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_613643 = validateParameter(valid_613643, JInt, required = false, default = nil)
  if valid_613643 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_613643
  assert query != nil,
        "query argument is necessary due to required `DestinationRegion` field"
  var valid_613644 = query.getOrDefault("DestinationRegion")
  valid_613644 = validateParameter(valid_613644, JString, required = true,
                                 default = nil)
  if valid_613644 != nil:
    section.add "DestinationRegion", valid_613644
  var valid_613645 = query.getOrDefault("Action")
  valid_613645 = validateParameter(valid_613645, JString, required = true,
                                 default = newJString("EnableSnapshotCopy"))
  if valid_613645 != nil:
    section.add "Action", valid_613645
  var valid_613646 = query.getOrDefault("ClusterIdentifier")
  valid_613646 = validateParameter(valid_613646, JString, required = true,
                                 default = nil)
  if valid_613646 != nil:
    section.add "ClusterIdentifier", valid_613646
  var valid_613647 = query.getOrDefault("Version")
  valid_613647 = validateParameter(valid_613647, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_613647 != nil:
    section.add "Version", valid_613647
  var valid_613648 = query.getOrDefault("RetentionPeriod")
  valid_613648 = validateParameter(valid_613648, JInt, required = false, default = nil)
  if valid_613648 != nil:
    section.add "RetentionPeriod", valid_613648
  var valid_613649 = query.getOrDefault("SnapshotCopyGrantName")
  valid_613649 = validateParameter(valid_613649, JString, required = false,
                                 default = nil)
  if valid_613649 != nil:
    section.add "SnapshotCopyGrantName", valid_613649
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613650 = header.getOrDefault("X-Amz-Signature")
  valid_613650 = validateParameter(valid_613650, JString, required = false,
                                 default = nil)
  if valid_613650 != nil:
    section.add "X-Amz-Signature", valid_613650
  var valid_613651 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613651 = validateParameter(valid_613651, JString, required = false,
                                 default = nil)
  if valid_613651 != nil:
    section.add "X-Amz-Content-Sha256", valid_613651
  var valid_613652 = header.getOrDefault("X-Amz-Date")
  valid_613652 = validateParameter(valid_613652, JString, required = false,
                                 default = nil)
  if valid_613652 != nil:
    section.add "X-Amz-Date", valid_613652
  var valid_613653 = header.getOrDefault("X-Amz-Credential")
  valid_613653 = validateParameter(valid_613653, JString, required = false,
                                 default = nil)
  if valid_613653 != nil:
    section.add "X-Amz-Credential", valid_613653
  var valid_613654 = header.getOrDefault("X-Amz-Security-Token")
  valid_613654 = validateParameter(valid_613654, JString, required = false,
                                 default = nil)
  if valid_613654 != nil:
    section.add "X-Amz-Security-Token", valid_613654
  var valid_613655 = header.getOrDefault("X-Amz-Algorithm")
  valid_613655 = validateParameter(valid_613655, JString, required = false,
                                 default = nil)
  if valid_613655 != nil:
    section.add "X-Amz-Algorithm", valid_613655
  var valid_613656 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613656 = validateParameter(valid_613656, JString, required = false,
                                 default = nil)
  if valid_613656 != nil:
    section.add "X-Amz-SignedHeaders", valid_613656
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613657: Call_GetEnableSnapshotCopy_613640; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Enables the automatic copy of snapshots from one region to another region for a specified cluster.
  ## 
  let valid = call_613657.validator(path, query, header, formData, body)
  let scheme = call_613657.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613657.url(scheme.get, call_613657.host, call_613657.base,
                         call_613657.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613657, url, valid)

proc call*(call_613658: Call_GetEnableSnapshotCopy_613640;
          DestinationRegion: string; ClusterIdentifier: string;
          ManualSnapshotRetentionPeriod: int = 0;
          Action: string = "EnableSnapshotCopy"; Version: string = "2012-12-01";
          RetentionPeriod: int = 0; SnapshotCopyGrantName: string = ""): Recallable =
  ## getEnableSnapshotCopy
  ## Enables the automatic copy of snapshots from one region to another region for a specified cluster.
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The number of days to retain newly copied snapshots in the destination AWS Region after they are copied from the source AWS Region. If the value is -1, the manual snapshot is retained indefinitely. </p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  ##   DestinationRegion: string (required)
  ##                    : <p>The destination AWS Region that you want to copy snapshots to.</p> <p>Constraints: Must be the name of a valid AWS Region. For more information, see <a 
  ## href="https://docs.aws.amazon.com/general/latest/gr/rande.html#redshift_region">Regions and Endpoints</a> in the Amazon Web Services General Reference. </p>
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of the source cluster to copy snapshots from.</p> <p>Constraints: Must be the valid name of an existing cluster that does not already have cross-region snapshot copy enabled.</p>
  ##   Version: string (required)
  ##   RetentionPeriod: int
  ##                  : <p>The number of days to retain automated snapshots in the destination region after they are copied from the source region.</p> <p>Default: 7.</p> <p>Constraints: Must be at least 1 and no more than 35.</p>
  ##   SnapshotCopyGrantName: string
  ##                        : The name of the snapshot copy grant to use when snapshots of an AWS KMS-encrypted cluster are copied to the destination region.
  var query_613659 = newJObject()
  add(query_613659, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  add(query_613659, "DestinationRegion", newJString(DestinationRegion))
  add(query_613659, "Action", newJString(Action))
  add(query_613659, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_613659, "Version", newJString(Version))
  add(query_613659, "RetentionPeriod", newJInt(RetentionPeriod))
  add(query_613659, "SnapshotCopyGrantName", newJString(SnapshotCopyGrantName))
  result = call_613658.call(nil, query_613659, nil, nil, nil)

var getEnableSnapshotCopy* = Call_GetEnableSnapshotCopy_613640(
    name: "getEnableSnapshotCopy", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=EnableSnapshotCopy",
    validator: validate_GetEnableSnapshotCopy_613641, base: "/",
    url: url_GetEnableSnapshotCopy_613642, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostGetClusterCredentials_613702 = ref object of OpenApiRestCall_610642
proc url_PostGetClusterCredentials_613704(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostGetClusterCredentials_613703(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns a database user name and temporary password with temporary authorization to log on to an Amazon Redshift database. The action returns the database user name prefixed with <code>IAM:</code> if <code>AutoCreate</code> is <code>False</code> or <code>IAMA:</code> if <code>AutoCreate</code> is <code>True</code>. You can optionally specify one or more database user groups that the user will join at log on. By default, the temporary credentials expire in 900 seconds. You can optionally specify a duration between 900 seconds (15 minutes) and 3600 seconds (60 minutes). For more information, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/generating-user-credentials.html">Using IAM Authentication to Generate Database User Credentials</a> in the Amazon Redshift Cluster Management Guide.</p> <p>The AWS Identity and Access Management (IAM)user or role that executes GetClusterCredentials must have an IAM policy attached that allows access to all necessary actions and resources. For more information about permissions, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-identity-based.html#redshift-policy-resources.getclustercredentials-resources">Resource Policies for GetClusterCredentials</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If the <code>DbGroups</code> parameter is specified, the IAM policy must allow the <code>redshift:JoinGroup</code> action with access to the listed <code>dbgroups</code>. </p> <p>In addition, if the <code>AutoCreate</code> parameter is set to <code>True</code>, then the policy must include the <code>redshift:CreateClusterUser</code> privilege.</p> <p>If the <code>DbName</code> parameter is specified, the IAM policy must allow access to the resource <code>dbname</code> for the specified database name. </p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_613705 = query.getOrDefault("Action")
  valid_613705 = validateParameter(valid_613705, JString, required = true,
                                 default = newJString("GetClusterCredentials"))
  if valid_613705 != nil:
    section.add "Action", valid_613705
  var valid_613706 = query.getOrDefault("Version")
  valid_613706 = validateParameter(valid_613706, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_613706 != nil:
    section.add "Version", valid_613706
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613707 = header.getOrDefault("X-Amz-Signature")
  valid_613707 = validateParameter(valid_613707, JString, required = false,
                                 default = nil)
  if valid_613707 != nil:
    section.add "X-Amz-Signature", valid_613707
  var valid_613708 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613708 = validateParameter(valid_613708, JString, required = false,
                                 default = nil)
  if valid_613708 != nil:
    section.add "X-Amz-Content-Sha256", valid_613708
  var valid_613709 = header.getOrDefault("X-Amz-Date")
  valid_613709 = validateParameter(valid_613709, JString, required = false,
                                 default = nil)
  if valid_613709 != nil:
    section.add "X-Amz-Date", valid_613709
  var valid_613710 = header.getOrDefault("X-Amz-Credential")
  valid_613710 = validateParameter(valid_613710, JString, required = false,
                                 default = nil)
  if valid_613710 != nil:
    section.add "X-Amz-Credential", valid_613710
  var valid_613711 = header.getOrDefault("X-Amz-Security-Token")
  valid_613711 = validateParameter(valid_613711, JString, required = false,
                                 default = nil)
  if valid_613711 != nil:
    section.add "X-Amz-Security-Token", valid_613711
  var valid_613712 = header.getOrDefault("X-Amz-Algorithm")
  valid_613712 = validateParameter(valid_613712, JString, required = false,
                                 default = nil)
  if valid_613712 != nil:
    section.add "X-Amz-Algorithm", valid_613712
  var valid_613713 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613713 = validateParameter(valid_613713, JString, required = false,
                                 default = nil)
  if valid_613713 != nil:
    section.add "X-Amz-SignedHeaders", valid_613713
  result.add "header", section
  ## parameters in `formData` object:
  ##   DbUser: JString (required)
  ##         : <p>The name of a database user. If a user name matching <code>DbUser</code> exists in the database, the temporary user credentials have the same permissions as the existing user. If <code>DbUser</code> doesn't exist in the database and <code>Autocreate</code> is <code>True</code>, a new user is created using the value for <code>DbUser</code> with PUBLIC permissions. If a database user matching the value for <code>DbUser</code> doesn't exist and <code>Autocreate</code> is <code>False</code>, then the command succeeds but the connection attempt will fail because the user doesn't exist in the database.</p> <p>For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/r_CREATE_USER.html">CREATE USER</a> in the Amazon Redshift Database Developer Guide. </p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 64 alphanumeric characters or hyphens. The user name can't be <code>PUBLIC</code>.</p> </li> <li> <p>Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Must not contain a colon ( : ) or slash ( / ). </p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p> </li> </ul>
  ##   ClusterIdentifier: JString (required)
  ##                    : The unique identifier of the cluster that contains the database for which your are requesting credentials. This parameter is case sensitive.
  ##   DurationSeconds: JInt
  ##                  : <p>The number of seconds until the returned temporary password expires.</p> <p>Constraint: minimum 900, maximum 3600.</p> <p>Default: 900</p>
  ##   DbGroups: JArray
  ##           : <p>A list of the names of existing database groups that the user named in <code>DbUser</code> will join for the current session, in addition to any group memberships for an existing user. If not specified, a new user is added only to PUBLIC.</p> <p>Database group name constraints</p> <ul> <li> <p>Must be 1 to 64 alphanumeric characters or hyphens</p> </li> <li> <p>Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Must not contain a colon ( : ) or slash ( / ). </p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p> </li> </ul>
  ##   DbName: JString
  ##         : <p>The name of a database that <code>DbUser</code> is authorized to log on to. If <code>DbName</code> is not specified, <code>DbUser</code> can log on to any existing database.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 64 alphanumeric characters or hyphens</p> </li> <li> <p>Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Must not contain a colon ( : ) or slash ( / ). </p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p> </li> </ul>
  ##   AutoCreate: JBool
  ##             : Create a database user with the name specified for the user named in <code>DbUser</code> if one does not exist.
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `DbUser` field"
  var valid_613714 = formData.getOrDefault("DbUser")
  valid_613714 = validateParameter(valid_613714, JString, required = true,
                                 default = nil)
  if valid_613714 != nil:
    section.add "DbUser", valid_613714
  var valid_613715 = formData.getOrDefault("ClusterIdentifier")
  valid_613715 = validateParameter(valid_613715, JString, required = true,
                                 default = nil)
  if valid_613715 != nil:
    section.add "ClusterIdentifier", valid_613715
  var valid_613716 = formData.getOrDefault("DurationSeconds")
  valid_613716 = validateParameter(valid_613716, JInt, required = false, default = nil)
  if valid_613716 != nil:
    section.add "DurationSeconds", valid_613716
  var valid_613717 = formData.getOrDefault("DbGroups")
  valid_613717 = validateParameter(valid_613717, JArray, required = false,
                                 default = nil)
  if valid_613717 != nil:
    section.add "DbGroups", valid_613717
  var valid_613718 = formData.getOrDefault("DbName")
  valid_613718 = validateParameter(valid_613718, JString, required = false,
                                 default = nil)
  if valid_613718 != nil:
    section.add "DbName", valid_613718
  var valid_613719 = formData.getOrDefault("AutoCreate")
  valid_613719 = validateParameter(valid_613719, JBool, required = false, default = nil)
  if valid_613719 != nil:
    section.add "AutoCreate", valid_613719
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613720: Call_PostGetClusterCredentials_613702; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns a database user name and temporary password with temporary authorization to log on to an Amazon Redshift database. The action returns the database user name prefixed with <code>IAM:</code> if <code>AutoCreate</code> is <code>False</code> or <code>IAMA:</code> if <code>AutoCreate</code> is <code>True</code>. You can optionally specify one or more database user groups that the user will join at log on. By default, the temporary credentials expire in 900 seconds. You can optionally specify a duration between 900 seconds (15 minutes) and 3600 seconds (60 minutes). For more information, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/generating-user-credentials.html">Using IAM Authentication to Generate Database User Credentials</a> in the Amazon Redshift Cluster Management Guide.</p> <p>The AWS Identity and Access Management (IAM)user or role that executes GetClusterCredentials must have an IAM policy attached that allows access to all necessary actions and resources. For more information about permissions, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-identity-based.html#redshift-policy-resources.getclustercredentials-resources">Resource Policies for GetClusterCredentials</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If the <code>DbGroups</code> parameter is specified, the IAM policy must allow the <code>redshift:JoinGroup</code> action with access to the listed <code>dbgroups</code>. </p> <p>In addition, if the <code>AutoCreate</code> parameter is set to <code>True</code>, then the policy must include the <code>redshift:CreateClusterUser</code> privilege.</p> <p>If the <code>DbName</code> parameter is specified, the IAM policy must allow access to the resource <code>dbname</code> for the specified database name. </p>
  ## 
  let valid = call_613720.validator(path, query, header, formData, body)
  let scheme = call_613720.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613720.url(scheme.get, call_613720.host, call_613720.base,
                         call_613720.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613720, url, valid)

proc call*(call_613721: Call_PostGetClusterCredentials_613702; DbUser: string;
          ClusterIdentifier: string; DurationSeconds: int = 0;
          DbGroups: JsonNode = nil; Action: string = "GetClusterCredentials";
          DbName: string = ""; AutoCreate: bool = false; Version: string = "2012-12-01"): Recallable =
  ## postGetClusterCredentials
  ## <p>Returns a database user name and temporary password with temporary authorization to log on to an Amazon Redshift database. The action returns the database user name prefixed with <code>IAM:</code> if <code>AutoCreate</code> is <code>False</code> or <code>IAMA:</code> if <code>AutoCreate</code> is <code>True</code>. You can optionally specify one or more database user groups that the user will join at log on. By default, the temporary credentials expire in 900 seconds. You can optionally specify a duration between 900 seconds (15 minutes) and 3600 seconds (60 minutes). For more information, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/generating-user-credentials.html">Using IAM Authentication to Generate Database User Credentials</a> in the Amazon Redshift Cluster Management Guide.</p> <p>The AWS Identity and Access Management (IAM)user or role that executes GetClusterCredentials must have an IAM policy attached that allows access to all necessary actions and resources. For more information about permissions, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-identity-based.html#redshift-policy-resources.getclustercredentials-resources">Resource Policies for GetClusterCredentials</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If the <code>DbGroups</code> parameter is specified, the IAM policy must allow the <code>redshift:JoinGroup</code> action with access to the listed <code>dbgroups</code>. </p> <p>In addition, if the <code>AutoCreate</code> parameter is set to <code>True</code>, then the policy must include the <code>redshift:CreateClusterUser</code> privilege.</p> <p>If the <code>DbName</code> parameter is specified, the IAM policy must allow access to the resource <code>dbname</code> for the specified database name. </p>
  ##   DbUser: string (required)
  ##         : <p>The name of a database user. If a user name matching <code>DbUser</code> exists in the database, the temporary user credentials have the same permissions as the existing user. If <code>DbUser</code> doesn't exist in the database and <code>Autocreate</code> is <code>True</code>, a new user is created using the value for <code>DbUser</code> with PUBLIC permissions. If a database user matching the value for <code>DbUser</code> doesn't exist and <code>Autocreate</code> is <code>False</code>, then the command succeeds but the connection attempt will fail because the user doesn't exist in the database.</p> <p>For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/r_CREATE_USER.html">CREATE USER</a> in the Amazon Redshift Database Developer Guide. </p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 64 alphanumeric characters or hyphens. The user name can't be <code>PUBLIC</code>.</p> </li> <li> <p>Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Must not contain a colon ( : ) or slash ( / ). </p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p> </li> </ul>
  ##   ClusterIdentifier: string (required)
  ##                    : The unique identifier of the cluster that contains the database for which your are requesting credentials. This parameter is case sensitive.
  ##   DurationSeconds: int
  ##                  : <p>The number of seconds until the returned temporary password expires.</p> <p>Constraint: minimum 900, maximum 3600.</p> <p>Default: 900</p>
  ##   DbGroups: JArray
  ##           : <p>A list of the names of existing database groups that the user named in <code>DbUser</code> will join for the current session, in addition to any group memberships for an existing user. If not specified, a new user is added only to PUBLIC.</p> <p>Database group name constraints</p> <ul> <li> <p>Must be 1 to 64 alphanumeric characters or hyphens</p> </li> <li> <p>Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Must not contain a colon ( : ) or slash ( / ). </p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p> </li> </ul>
  ##   Action: string (required)
  ##   DbName: string
  ##         : <p>The name of a database that <code>DbUser</code> is authorized to log on to. If <code>DbName</code> is not specified, <code>DbUser</code> can log on to any existing database.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 64 alphanumeric characters or hyphens</p> </li> <li> <p>Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Must not contain a colon ( : ) or slash ( / ). </p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p> </li> </ul>
  ##   AutoCreate: bool
  ##             : Create a database user with the name specified for the user named in <code>DbUser</code> if one does not exist.
  ##   Version: string (required)
  var query_613722 = newJObject()
  var formData_613723 = newJObject()
  add(formData_613723, "DbUser", newJString(DbUser))
  add(formData_613723, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_613723, "DurationSeconds", newJInt(DurationSeconds))
  if DbGroups != nil:
    formData_613723.add "DbGroups", DbGroups
  add(query_613722, "Action", newJString(Action))
  add(formData_613723, "DbName", newJString(DbName))
  add(formData_613723, "AutoCreate", newJBool(AutoCreate))
  add(query_613722, "Version", newJString(Version))
  result = call_613721.call(nil, query_613722, nil, formData_613723, nil)

var postGetClusterCredentials* = Call_PostGetClusterCredentials_613702(
    name: "postGetClusterCredentials", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=GetClusterCredentials",
    validator: validate_PostGetClusterCredentials_613703, base: "/",
    url: url_PostGetClusterCredentials_613704,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetGetClusterCredentials_613681 = ref object of OpenApiRestCall_610642
proc url_GetGetClusterCredentials_613683(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetGetClusterCredentials_613682(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns a database user name and temporary password with temporary authorization to log on to an Amazon Redshift database. The action returns the database user name prefixed with <code>IAM:</code> if <code>AutoCreate</code> is <code>False</code> or <code>IAMA:</code> if <code>AutoCreate</code> is <code>True</code>. You can optionally specify one or more database user groups that the user will join at log on. By default, the temporary credentials expire in 900 seconds. You can optionally specify a duration between 900 seconds (15 minutes) and 3600 seconds (60 minutes). For more information, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/generating-user-credentials.html">Using IAM Authentication to Generate Database User Credentials</a> in the Amazon Redshift Cluster Management Guide.</p> <p>The AWS Identity and Access Management (IAM)user or role that executes GetClusterCredentials must have an IAM policy attached that allows access to all necessary actions and resources. For more information about permissions, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-identity-based.html#redshift-policy-resources.getclustercredentials-resources">Resource Policies for GetClusterCredentials</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If the <code>DbGroups</code> parameter is specified, the IAM policy must allow the <code>redshift:JoinGroup</code> action with access to the listed <code>dbgroups</code>. </p> <p>In addition, if the <code>AutoCreate</code> parameter is set to <code>True</code>, then the policy must include the <code>redshift:CreateClusterUser</code> privilege.</p> <p>If the <code>DbName</code> parameter is specified, the IAM policy must allow access to the resource <code>dbname</code> for the specified database name. </p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   DbName: JString
  ##         : <p>The name of a database that <code>DbUser</code> is authorized to log on to. If <code>DbName</code> is not specified, <code>DbUser</code> can log on to any existing database.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 64 alphanumeric characters or hyphens</p> </li> <li> <p>Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Must not contain a colon ( : ) or slash ( / ). </p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p> </li> </ul>
  ##   DbUser: JString (required)
  ##         : <p>The name of a database user. If a user name matching <code>DbUser</code> exists in the database, the temporary user credentials have the same permissions as the existing user. If <code>DbUser</code> doesn't exist in the database and <code>Autocreate</code> is <code>True</code>, a new user is created using the value for <code>DbUser</code> with PUBLIC permissions. If a database user matching the value for <code>DbUser</code> doesn't exist and <code>Autocreate</code> is <code>False</code>, then the command succeeds but the connection attempt will fail because the user doesn't exist in the database.</p> <p>For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/r_CREATE_USER.html">CREATE USER</a> in the Amazon Redshift Database Developer Guide. </p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 64 alphanumeric characters or hyphens. The user name can't be <code>PUBLIC</code>.</p> </li> <li> <p>Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Must not contain a colon ( : ) or slash ( / ). </p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p> </li> </ul>
  ##   AutoCreate: JBool
  ##             : Create a database user with the name specified for the user named in <code>DbUser</code> if one does not exist.
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : The unique identifier of the cluster that contains the database for which your are requesting credentials. This parameter is case sensitive.
  ##   Version: JString (required)
  ##   DbGroups: JArray
  ##           : <p>A list of the names of existing database groups that the user named in <code>DbUser</code> will join for the current session, in addition to any group memberships for an existing user. If not specified, a new user is added only to PUBLIC.</p> <p>Database group name constraints</p> <ul> <li> <p>Must be 1 to 64 alphanumeric characters or hyphens</p> </li> <li> <p>Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Must not contain a colon ( : ) or slash ( / ). </p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p> </li> </ul>
  ##   DurationSeconds: JInt
  ##                  : <p>The number of seconds until the returned temporary password expires.</p> <p>Constraint: minimum 900, maximum 3600.</p> <p>Default: 900</p>
  section = newJObject()
  var valid_613684 = query.getOrDefault("DbName")
  valid_613684 = validateParameter(valid_613684, JString, required = false,
                                 default = nil)
  if valid_613684 != nil:
    section.add "DbName", valid_613684
  assert query != nil, "query argument is necessary due to required `DbUser` field"
  var valid_613685 = query.getOrDefault("DbUser")
  valid_613685 = validateParameter(valid_613685, JString, required = true,
                                 default = nil)
  if valid_613685 != nil:
    section.add "DbUser", valid_613685
  var valid_613686 = query.getOrDefault("AutoCreate")
  valid_613686 = validateParameter(valid_613686, JBool, required = false, default = nil)
  if valid_613686 != nil:
    section.add "AutoCreate", valid_613686
  var valid_613687 = query.getOrDefault("Action")
  valid_613687 = validateParameter(valid_613687, JString, required = true,
                                 default = newJString("GetClusterCredentials"))
  if valid_613687 != nil:
    section.add "Action", valid_613687
  var valid_613688 = query.getOrDefault("ClusterIdentifier")
  valid_613688 = validateParameter(valid_613688, JString, required = true,
                                 default = nil)
  if valid_613688 != nil:
    section.add "ClusterIdentifier", valid_613688
  var valid_613689 = query.getOrDefault("Version")
  valid_613689 = validateParameter(valid_613689, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_613689 != nil:
    section.add "Version", valid_613689
  var valid_613690 = query.getOrDefault("DbGroups")
  valid_613690 = validateParameter(valid_613690, JArray, required = false,
                                 default = nil)
  if valid_613690 != nil:
    section.add "DbGroups", valid_613690
  var valid_613691 = query.getOrDefault("DurationSeconds")
  valid_613691 = validateParameter(valid_613691, JInt, required = false, default = nil)
  if valid_613691 != nil:
    section.add "DurationSeconds", valid_613691
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613692 = header.getOrDefault("X-Amz-Signature")
  valid_613692 = validateParameter(valid_613692, JString, required = false,
                                 default = nil)
  if valid_613692 != nil:
    section.add "X-Amz-Signature", valid_613692
  var valid_613693 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613693 = validateParameter(valid_613693, JString, required = false,
                                 default = nil)
  if valid_613693 != nil:
    section.add "X-Amz-Content-Sha256", valid_613693
  var valid_613694 = header.getOrDefault("X-Amz-Date")
  valid_613694 = validateParameter(valid_613694, JString, required = false,
                                 default = nil)
  if valid_613694 != nil:
    section.add "X-Amz-Date", valid_613694
  var valid_613695 = header.getOrDefault("X-Amz-Credential")
  valid_613695 = validateParameter(valid_613695, JString, required = false,
                                 default = nil)
  if valid_613695 != nil:
    section.add "X-Amz-Credential", valid_613695
  var valid_613696 = header.getOrDefault("X-Amz-Security-Token")
  valid_613696 = validateParameter(valid_613696, JString, required = false,
                                 default = nil)
  if valid_613696 != nil:
    section.add "X-Amz-Security-Token", valid_613696
  var valid_613697 = header.getOrDefault("X-Amz-Algorithm")
  valid_613697 = validateParameter(valid_613697, JString, required = false,
                                 default = nil)
  if valid_613697 != nil:
    section.add "X-Amz-Algorithm", valid_613697
  var valid_613698 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613698 = validateParameter(valid_613698, JString, required = false,
                                 default = nil)
  if valid_613698 != nil:
    section.add "X-Amz-SignedHeaders", valid_613698
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613699: Call_GetGetClusterCredentials_613681; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns a database user name and temporary password with temporary authorization to log on to an Amazon Redshift database. The action returns the database user name prefixed with <code>IAM:</code> if <code>AutoCreate</code> is <code>False</code> or <code>IAMA:</code> if <code>AutoCreate</code> is <code>True</code>. You can optionally specify one or more database user groups that the user will join at log on. By default, the temporary credentials expire in 900 seconds. You can optionally specify a duration between 900 seconds (15 minutes) and 3600 seconds (60 minutes). For more information, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/generating-user-credentials.html">Using IAM Authentication to Generate Database User Credentials</a> in the Amazon Redshift Cluster Management Guide.</p> <p>The AWS Identity and Access Management (IAM)user or role that executes GetClusterCredentials must have an IAM policy attached that allows access to all necessary actions and resources. For more information about permissions, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-identity-based.html#redshift-policy-resources.getclustercredentials-resources">Resource Policies for GetClusterCredentials</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If the <code>DbGroups</code> parameter is specified, the IAM policy must allow the <code>redshift:JoinGroup</code> action with access to the listed <code>dbgroups</code>. </p> <p>In addition, if the <code>AutoCreate</code> parameter is set to <code>True</code>, then the policy must include the <code>redshift:CreateClusterUser</code> privilege.</p> <p>If the <code>DbName</code> parameter is specified, the IAM policy must allow access to the resource <code>dbname</code> for the specified database name. </p>
  ## 
  let valid = call_613699.validator(path, query, header, formData, body)
  let scheme = call_613699.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613699.url(scheme.get, call_613699.host, call_613699.base,
                         call_613699.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613699, url, valid)

proc call*(call_613700: Call_GetGetClusterCredentials_613681; DbUser: string;
          ClusterIdentifier: string; DbName: string = ""; AutoCreate: bool = false;
          Action: string = "GetClusterCredentials"; Version: string = "2012-12-01";
          DbGroups: JsonNode = nil; DurationSeconds: int = 0): Recallable =
  ## getGetClusterCredentials
  ## <p>Returns a database user name and temporary password with temporary authorization to log on to an Amazon Redshift database. The action returns the database user name prefixed with <code>IAM:</code> if <code>AutoCreate</code> is <code>False</code> or <code>IAMA:</code> if <code>AutoCreate</code> is <code>True</code>. You can optionally specify one or more database user groups that the user will join at log on. By default, the temporary credentials expire in 900 seconds. You can optionally specify a duration between 900 seconds (15 minutes) and 3600 seconds (60 minutes). For more information, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/generating-user-credentials.html">Using IAM Authentication to Generate Database User Credentials</a> in the Amazon Redshift Cluster Management Guide.</p> <p>The AWS Identity and Access Management (IAM)user or role that executes GetClusterCredentials must have an IAM policy attached that allows access to all necessary actions and resources. For more information about permissions, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-identity-based.html#redshift-policy-resources.getclustercredentials-resources">Resource Policies for GetClusterCredentials</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If the <code>DbGroups</code> parameter is specified, the IAM policy must allow the <code>redshift:JoinGroup</code> action with access to the listed <code>dbgroups</code>. </p> <p>In addition, if the <code>AutoCreate</code> parameter is set to <code>True</code>, then the policy must include the <code>redshift:CreateClusterUser</code> privilege.</p> <p>If the <code>DbName</code> parameter is specified, the IAM policy must allow access to the resource <code>dbname</code> for the specified database name. </p>
  ##   DbName: string
  ##         : <p>The name of a database that <code>DbUser</code> is authorized to log on to. If <code>DbName</code> is not specified, <code>DbUser</code> can log on to any existing database.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 64 alphanumeric characters or hyphens</p> </li> <li> <p>Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Must not contain a colon ( : ) or slash ( / ). </p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p> </li> </ul>
  ##   DbUser: string (required)
  ##         : <p>The name of a database user. If a user name matching <code>DbUser</code> exists in the database, the temporary user credentials have the same permissions as the existing user. If <code>DbUser</code> doesn't exist in the database and <code>Autocreate</code> is <code>True</code>, a new user is created using the value for <code>DbUser</code> with PUBLIC permissions. If a database user matching the value for <code>DbUser</code> doesn't exist and <code>Autocreate</code> is <code>False</code>, then the command succeeds but the connection attempt will fail because the user doesn't exist in the database.</p> <p>For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/r_CREATE_USER.html">CREATE USER</a> in the Amazon Redshift Database Developer Guide. </p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 64 alphanumeric characters or hyphens. The user name can't be <code>PUBLIC</code>.</p> </li> <li> <p>Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Must not contain a colon ( : ) or slash ( / ). </p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p> </li> </ul>
  ##   AutoCreate: bool
  ##             : Create a database user with the name specified for the user named in <code>DbUser</code> if one does not exist.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : The unique identifier of the cluster that contains the database for which your are requesting credentials. This parameter is case sensitive.
  ##   Version: string (required)
  ##   DbGroups: JArray
  ##           : <p>A list of the names of existing database groups that the user named in <code>DbUser</code> will join for the current session, in addition to any group memberships for an existing user. If not specified, a new user is added only to PUBLIC.</p> <p>Database group name constraints</p> <ul> <li> <p>Must be 1 to 64 alphanumeric characters or hyphens</p> </li> <li> <p>Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Must not contain a colon ( : ) or slash ( / ). </p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p> </li> </ul>
  ##   DurationSeconds: int
  ##                  : <p>The number of seconds until the returned temporary password expires.</p> <p>Constraint: minimum 900, maximum 3600.</p> <p>Default: 900</p>
  var query_613701 = newJObject()
  add(query_613701, "DbName", newJString(DbName))
  add(query_613701, "DbUser", newJString(DbUser))
  add(query_613701, "AutoCreate", newJBool(AutoCreate))
  add(query_613701, "Action", newJString(Action))
  add(query_613701, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_613701, "Version", newJString(Version))
  if DbGroups != nil:
    query_613701.add "DbGroups", DbGroups
  add(query_613701, "DurationSeconds", newJInt(DurationSeconds))
  result = call_613700.call(nil, query_613701, nil, nil, nil)

var getGetClusterCredentials* = Call_GetGetClusterCredentials_613681(
    name: "getGetClusterCredentials", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=GetClusterCredentials",
    validator: validate_GetGetClusterCredentials_613682, base: "/",
    url: url_GetGetClusterCredentials_613683, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostGetReservedNodeExchangeOfferings_613742 = ref object of OpenApiRestCall_610642
proc url_PostGetReservedNodeExchangeOfferings_613744(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostGetReservedNodeExchangeOfferings_613743(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns an array of DC2 ReservedNodeOfferings that matches the payment type, term, and usage price of the given DC1 reserved node.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_613745 = query.getOrDefault("Action")
  valid_613745 = validateParameter(valid_613745, JString, required = true, default = newJString(
      "GetReservedNodeExchangeOfferings"))
  if valid_613745 != nil:
    section.add "Action", valid_613745
  var valid_613746 = query.getOrDefault("Version")
  valid_613746 = validateParameter(valid_613746, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_613746 != nil:
    section.add "Version", valid_613746
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613747 = header.getOrDefault("X-Amz-Signature")
  valid_613747 = validateParameter(valid_613747, JString, required = false,
                                 default = nil)
  if valid_613747 != nil:
    section.add "X-Amz-Signature", valid_613747
  var valid_613748 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613748 = validateParameter(valid_613748, JString, required = false,
                                 default = nil)
  if valid_613748 != nil:
    section.add "X-Amz-Content-Sha256", valid_613748
  var valid_613749 = header.getOrDefault("X-Amz-Date")
  valid_613749 = validateParameter(valid_613749, JString, required = false,
                                 default = nil)
  if valid_613749 != nil:
    section.add "X-Amz-Date", valid_613749
  var valid_613750 = header.getOrDefault("X-Amz-Credential")
  valid_613750 = validateParameter(valid_613750, JString, required = false,
                                 default = nil)
  if valid_613750 != nil:
    section.add "X-Amz-Credential", valid_613750
  var valid_613751 = header.getOrDefault("X-Amz-Security-Token")
  valid_613751 = validateParameter(valid_613751, JString, required = false,
                                 default = nil)
  if valid_613751 != nil:
    section.add "X-Amz-Security-Token", valid_613751
  var valid_613752 = header.getOrDefault("X-Amz-Algorithm")
  valid_613752 = validateParameter(valid_613752, JString, required = false,
                                 default = nil)
  if valid_613752 != nil:
    section.add "X-Amz-Algorithm", valid_613752
  var valid_613753 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613753 = validateParameter(valid_613753, JString, required = false,
                                 default = nil)
  if valid_613753 != nil:
    section.add "X-Amz-SignedHeaders", valid_613753
  result.add "header", section
  ## parameters in `formData` object:
  ##   ReservedNodeId: JString (required)
  ##                 : A string representing the node identifier for the DC1 Reserved Node to be exchanged.
  ##   MaxRecords: JInt
  ##             : An integer setting the maximum number of ReservedNodeOfferings to retrieve.
  ##   Marker: JString
  ##         : A value that indicates the starting point for the next set of ReservedNodeOfferings.
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `ReservedNodeId` field"
  var valid_613754 = formData.getOrDefault("ReservedNodeId")
  valid_613754 = validateParameter(valid_613754, JString, required = true,
                                 default = nil)
  if valid_613754 != nil:
    section.add "ReservedNodeId", valid_613754
  var valid_613755 = formData.getOrDefault("MaxRecords")
  valid_613755 = validateParameter(valid_613755, JInt, required = false, default = nil)
  if valid_613755 != nil:
    section.add "MaxRecords", valid_613755
  var valid_613756 = formData.getOrDefault("Marker")
  valid_613756 = validateParameter(valid_613756, JString, required = false,
                                 default = nil)
  if valid_613756 != nil:
    section.add "Marker", valid_613756
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613757: Call_PostGetReservedNodeExchangeOfferings_613742;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Returns an array of DC2 ReservedNodeOfferings that matches the payment type, term, and usage price of the given DC1 reserved node.
  ## 
  let valid = call_613757.validator(path, query, header, formData, body)
  let scheme = call_613757.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613757.url(scheme.get, call_613757.host, call_613757.base,
                         call_613757.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613757, url, valid)

proc call*(call_613758: Call_PostGetReservedNodeExchangeOfferings_613742;
          ReservedNodeId: string; MaxRecords: int = 0; Marker: string = "";
          Action: string = "GetReservedNodeExchangeOfferings";
          Version: string = "2012-12-01"): Recallable =
  ## postGetReservedNodeExchangeOfferings
  ## Returns an array of DC2 ReservedNodeOfferings that matches the payment type, term, and usage price of the given DC1 reserved node.
  ##   ReservedNodeId: string (required)
  ##                 : A string representing the node identifier for the DC1 Reserved Node to be exchanged.
  ##   MaxRecords: int
  ##             : An integer setting the maximum number of ReservedNodeOfferings to retrieve.
  ##   Marker: string
  ##         : A value that indicates the starting point for the next set of ReservedNodeOfferings.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_613759 = newJObject()
  var formData_613760 = newJObject()
  add(formData_613760, "ReservedNodeId", newJString(ReservedNodeId))
  add(formData_613760, "MaxRecords", newJInt(MaxRecords))
  add(formData_613760, "Marker", newJString(Marker))
  add(query_613759, "Action", newJString(Action))
  add(query_613759, "Version", newJString(Version))
  result = call_613758.call(nil, query_613759, nil, formData_613760, nil)

var postGetReservedNodeExchangeOfferings* = Call_PostGetReservedNodeExchangeOfferings_613742(
    name: "postGetReservedNodeExchangeOfferings", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=GetReservedNodeExchangeOfferings",
    validator: validate_PostGetReservedNodeExchangeOfferings_613743, base: "/",
    url: url_PostGetReservedNodeExchangeOfferings_613744,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetGetReservedNodeExchangeOfferings_613724 = ref object of OpenApiRestCall_610642
proc url_GetGetReservedNodeExchangeOfferings_613726(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetGetReservedNodeExchangeOfferings_613725(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns an array of DC2 ReservedNodeOfferings that matches the payment type, term, and usage price of the given DC1 reserved node.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Marker: JString
  ##         : A value that indicates the starting point for the next set of ReservedNodeOfferings.
  ##   Action: JString (required)
  ##   ReservedNodeId: JString (required)
  ##                 : A string representing the node identifier for the DC1 Reserved Node to be exchanged.
  ##   Version: JString (required)
  ##   MaxRecords: JInt
  ##             : An integer setting the maximum number of ReservedNodeOfferings to retrieve.
  section = newJObject()
  var valid_613727 = query.getOrDefault("Marker")
  valid_613727 = validateParameter(valid_613727, JString, required = false,
                                 default = nil)
  if valid_613727 != nil:
    section.add "Marker", valid_613727
  var valid_613728 = query.getOrDefault("Action")
  valid_613728 = validateParameter(valid_613728, JString, required = true, default = newJString(
      "GetReservedNodeExchangeOfferings"))
  if valid_613728 != nil:
    section.add "Action", valid_613728
  var valid_613729 = query.getOrDefault("ReservedNodeId")
  valid_613729 = validateParameter(valid_613729, JString, required = true,
                                 default = nil)
  if valid_613729 != nil:
    section.add "ReservedNodeId", valid_613729
  var valid_613730 = query.getOrDefault("Version")
  valid_613730 = validateParameter(valid_613730, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_613730 != nil:
    section.add "Version", valid_613730
  var valid_613731 = query.getOrDefault("MaxRecords")
  valid_613731 = validateParameter(valid_613731, JInt, required = false, default = nil)
  if valid_613731 != nil:
    section.add "MaxRecords", valid_613731
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613732 = header.getOrDefault("X-Amz-Signature")
  valid_613732 = validateParameter(valid_613732, JString, required = false,
                                 default = nil)
  if valid_613732 != nil:
    section.add "X-Amz-Signature", valid_613732
  var valid_613733 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613733 = validateParameter(valid_613733, JString, required = false,
                                 default = nil)
  if valid_613733 != nil:
    section.add "X-Amz-Content-Sha256", valid_613733
  var valid_613734 = header.getOrDefault("X-Amz-Date")
  valid_613734 = validateParameter(valid_613734, JString, required = false,
                                 default = nil)
  if valid_613734 != nil:
    section.add "X-Amz-Date", valid_613734
  var valid_613735 = header.getOrDefault("X-Amz-Credential")
  valid_613735 = validateParameter(valid_613735, JString, required = false,
                                 default = nil)
  if valid_613735 != nil:
    section.add "X-Amz-Credential", valid_613735
  var valid_613736 = header.getOrDefault("X-Amz-Security-Token")
  valid_613736 = validateParameter(valid_613736, JString, required = false,
                                 default = nil)
  if valid_613736 != nil:
    section.add "X-Amz-Security-Token", valid_613736
  var valid_613737 = header.getOrDefault("X-Amz-Algorithm")
  valid_613737 = validateParameter(valid_613737, JString, required = false,
                                 default = nil)
  if valid_613737 != nil:
    section.add "X-Amz-Algorithm", valid_613737
  var valid_613738 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613738 = validateParameter(valid_613738, JString, required = false,
                                 default = nil)
  if valid_613738 != nil:
    section.add "X-Amz-SignedHeaders", valid_613738
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613739: Call_GetGetReservedNodeExchangeOfferings_613724;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Returns an array of DC2 ReservedNodeOfferings that matches the payment type, term, and usage price of the given DC1 reserved node.
  ## 
  let valid = call_613739.validator(path, query, header, formData, body)
  let scheme = call_613739.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613739.url(scheme.get, call_613739.host, call_613739.base,
                         call_613739.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613739, url, valid)

proc call*(call_613740: Call_GetGetReservedNodeExchangeOfferings_613724;
          ReservedNodeId: string; Marker: string = "";
          Action: string = "GetReservedNodeExchangeOfferings";
          Version: string = "2012-12-01"; MaxRecords: int = 0): Recallable =
  ## getGetReservedNodeExchangeOfferings
  ## Returns an array of DC2 ReservedNodeOfferings that matches the payment type, term, and usage price of the given DC1 reserved node.
  ##   Marker: string
  ##         : A value that indicates the starting point for the next set of ReservedNodeOfferings.
  ##   Action: string (required)
  ##   ReservedNodeId: string (required)
  ##                 : A string representing the node identifier for the DC1 Reserved Node to be exchanged.
  ##   Version: string (required)
  ##   MaxRecords: int
  ##             : An integer setting the maximum number of ReservedNodeOfferings to retrieve.
  var query_613741 = newJObject()
  add(query_613741, "Marker", newJString(Marker))
  add(query_613741, "Action", newJString(Action))
  add(query_613741, "ReservedNodeId", newJString(ReservedNodeId))
  add(query_613741, "Version", newJString(Version))
  add(query_613741, "MaxRecords", newJInt(MaxRecords))
  result = call_613740.call(nil, query_613741, nil, nil, nil)

var getGetReservedNodeExchangeOfferings* = Call_GetGetReservedNodeExchangeOfferings_613724(
    name: "getGetReservedNodeExchangeOfferings", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=GetReservedNodeExchangeOfferings",
    validator: validate_GetGetReservedNodeExchangeOfferings_613725, base: "/",
    url: url_GetGetReservedNodeExchangeOfferings_613726,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostModifyCluster_613798 = ref object of OpenApiRestCall_610642
proc url_PostModifyCluster_613800(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostModifyCluster_613799(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## <p>Modifies the settings for a cluster.</p> <p>You can also change node type and the number of nodes to scale up or down the cluster. When resizing a cluster, you must specify both the number of nodes and the node type even if one of the parameters does not change.</p> <p>You can add another security or parameter group, or change the master user password. Resetting a cluster password or modifying the security groups associated with a cluster do not need a reboot. However, modifying a parameter group requires a reboot for parameters to take effect. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_613801 = query.getOrDefault("Action")
  valid_613801 = validateParameter(valid_613801, JString, required = true,
                                 default = newJString("ModifyCluster"))
  if valid_613801 != nil:
    section.add "Action", valid_613801
  var valid_613802 = query.getOrDefault("Version")
  valid_613802 = validateParameter(valid_613802, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_613802 != nil:
    section.add "Version", valid_613802
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613803 = header.getOrDefault("X-Amz-Signature")
  valid_613803 = validateParameter(valid_613803, JString, required = false,
                                 default = nil)
  if valid_613803 != nil:
    section.add "X-Amz-Signature", valid_613803
  var valid_613804 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613804 = validateParameter(valid_613804, JString, required = false,
                                 default = nil)
  if valid_613804 != nil:
    section.add "X-Amz-Content-Sha256", valid_613804
  var valid_613805 = header.getOrDefault("X-Amz-Date")
  valid_613805 = validateParameter(valid_613805, JString, required = false,
                                 default = nil)
  if valid_613805 != nil:
    section.add "X-Amz-Date", valid_613805
  var valid_613806 = header.getOrDefault("X-Amz-Credential")
  valid_613806 = validateParameter(valid_613806, JString, required = false,
                                 default = nil)
  if valid_613806 != nil:
    section.add "X-Amz-Credential", valid_613806
  var valid_613807 = header.getOrDefault("X-Amz-Security-Token")
  valid_613807 = validateParameter(valid_613807, JString, required = false,
                                 default = nil)
  if valid_613807 != nil:
    section.add "X-Amz-Security-Token", valid_613807
  var valid_613808 = header.getOrDefault("X-Amz-Algorithm")
  valid_613808 = validateParameter(valid_613808, JString, required = false,
                                 default = nil)
  if valid_613808 != nil:
    section.add "X-Amz-Algorithm", valid_613808
  var valid_613809 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613809 = validateParameter(valid_613809, JString, required = false,
                                 default = nil)
  if valid_613809 != nil:
    section.add "X-Amz-SignedHeaders", valid_613809
  result.add "header", section
  ## parameters in `formData` object:
  ##   PreferredMaintenanceWindow: JString
  ##                             : <p>The weekly time range (in UTC) during which system maintenance can occur, if necessary. If system maintenance is necessary during the window, it may result in an outage.</p> <p>This maintenance window change is made immediately. If the new maintenance window indicates the current time, there must be at least 120 minutes between the current time and end of the window in order to ensure that pending changes are applied.</p> <p>Default: Uses existing setting.</p> <p>Format: ddd:hh24:mi-ddd:hh24:mi, for example <code>wed:07:30-wed:08:00</code>.</p> <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p> <p>Constraints: Must be at least 30 minutes.</p>
  ##   NodeType: JString
  ##           : <p>The new node type of the cluster. If you specify a new node type, you must also specify the number of nodes parameter.</p> <p> For more information about resizing clusters, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/rs-resize-tutorial.html">Resizing Clusters in Amazon Redshift</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>Valid Values: <code>ds2.xlarge</code> | <code>ds2.8xlarge</code> | <code>dc1.large</code> | <code>dc1.8xlarge</code> | <code>dc2.large</code> | <code>dc2.8xlarge</code> | <code>ra3.16xlarge</code> </p>
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of the cluster to be modified.</p> <p>Example: <code>examplecluster</code> </p>
  ##   MasterUserPassword: JString
  ##                     : <p>The new password for the cluster master user. This change is asynchronously applied as soon as possible. Between the time of the request and the completion of the request, the <code>MasterUserPassword</code> element exists in the <code>PendingModifiedValues</code> element of the operation response. </p> <note> <p>Operations never return the password, so this operation provides a way to regain access to the master user account for a cluster if the password is lost.</p> </note> <p>Default: Uses existing setting.</p> <p>Constraints:</p> <ul> <li> <p>Must be between 8 and 64 characters in length.</p> </li> <li> <p>Must contain at least one uppercase letter.</p> </li> <li> <p>Must contain at least one lowercase letter.</p> </li> <li> <p>Must contain one number.</p> </li> <li> <p>Can be any printable ASCII character (ASCII code 33 to 126) except ' (single quote), " (double quote), \, /, @, or space.</p> </li> </ul>
  ##   MaintenanceTrackName: JString
  ##                       : The name for the maintenance track that you want to assign for the cluster. This name change is asynchronous. The new track name stays in the <code>PendingModifiedValues</code> for the cluster until the next maintenance window. When the maintenance track changes, the cluster is switched to the latest cluster release available for the maintenance track. At this point, the maintenance track name is applied.
  ##   ClusterSecurityGroups: JArray
  ##                        : <p>A list of cluster security groups to be authorized on this cluster. This change is asynchronously applied as soon as possible.</p> <p>Security groups currently associated with the cluster, and not in the list of groups to apply, will be revoked from the cluster.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens</p> </li> <li> <p>First character must be a letter</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens</p> </li> </ul>
  ##   NumberOfNodes: JInt
  ##                : <p>The new number of nodes of the cluster. If you specify a new number of nodes, you must also specify the node type parameter.</p> <p> For more information about resizing clusters, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/rs-resize-tutorial.html">Resizing Clusters in Amazon Redshift</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>Valid Values: Integer greater than <code>0</code>.</p>
  ##   VpcSecurityGroupIds: JArray
  ##                      : A list of virtual private cloud (VPC) security groups to be associated with the cluster. This change is asynchronously applied as soon as possible.
  ##   AutomatedSnapshotRetentionPeriod: JInt
  ##                                   : <p>The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p> <p>If you decrease the automated snapshot retention period from its current value, existing automated snapshots that fall outside of the new retention period will be immediately deleted.</p> <p>Default: Uses existing setting.</p> <p>Constraints: Must be a value from 0 to 35.</p>
  ##   NewClusterIdentifier: JString
  ##                       : <p>The new identifier for the cluster.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul> <p>Example: <code>examplecluster</code> </p>
  ##   EnhancedVpcRouting: JBool
  ##                     : <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p> <p>Default: false</p>
  ##   KmsKeyId: JString
  ##           : The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster.
  ##   AllowVersionUpgrade: JBool
  ##                      : <p>If <code>true</code>, major version upgrades will be applied automatically to the cluster during the maintenance window. </p> <p>Default: <code>false</code> </p>
  ##   PubliclyAccessible: JBool
  ##                     : If <code>true</code>, the cluster can be accessed from a public network. Only clusters in VPCs can be set to be publicly available.
  ##   ClusterParameterGroupName: JString
  ##                            : <p>The name of the cluster parameter group to apply to this cluster. This change is applied only after the cluster is rebooted. To reboot a cluster use <a>RebootCluster</a>. </p> <p>Default: Uses existing setting.</p> <p>Constraints: The cluster parameter group must be in the same parameter group family that matches the cluster version.</p>
  ##   ClusterVersion: JString
  ##                 : <p>The new version number of the Amazon Redshift engine to upgrade to.</p> <p>For major version upgrades, if a non-default cluster parameter group is currently in use, a new cluster parameter group in the cluster parameter group family for the new version must be specified. The new cluster parameter group can be the default for that cluster parameter group family. For more information about parameters and parameter groups, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>Example: <code>1.0</code> </p>
  ##   ClusterType: JString
  ##              : <p>The new cluster type.</p> <p>When you submit your cluster resize request, your existing cluster goes into a read-only mode. After Amazon Redshift provisions a new cluster based on your resize requirements, there will be outage for a period while the old cluster is deleted and your connection is switched to the new cluster. You can use <a>DescribeResize</a> to track the progress of the resize request. </p> <p>Valid Values: <code> multi-node | single-node </code> </p>
  ##   HsmClientCertificateIdentifier: JString
  ##                                 : Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM.
  ##   Encrypted: JBool
  ##            : <p>Indicates whether the cluster is encrypted. If the value is encrypted (true) and you provide a value for the <code>KmsKeyId</code> parameter, we encrypt the cluster with the provided <code>KmsKeyId</code>. If you don't provide a <code>KmsKeyId</code>, we encrypt with the default key. In the China region we use legacy encryption if you specify that the cluster is encrypted.</p> <p>If the value is not encrypted (false), then the cluster is decrypted. </p>
  ##   ElasticIp: JString
  ##            : <p>The Elastic IP (EIP) address for the cluster.</p> <p>Constraints: The cluster must be provisioned in EC2-VPC and publicly-accessible through an Internet gateway. For more information about provisioning clusters in EC2-VPC, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#cluster-platforms">Supported Platforms to Launch Your Cluster</a> in the Amazon Redshift Cluster Management Guide.</p>
  ##   HsmConfigurationIdentifier: JString
  ##                             : Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The default for number of days that a newly created manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. This value doesn't retroactively change the retention periods of existing manual snapshots.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  section = newJObject()
  var valid_613810 = formData.getOrDefault("PreferredMaintenanceWindow")
  valid_613810 = validateParameter(valid_613810, JString, required = false,
                                 default = nil)
  if valid_613810 != nil:
    section.add "PreferredMaintenanceWindow", valid_613810
  var valid_613811 = formData.getOrDefault("NodeType")
  valid_613811 = validateParameter(valid_613811, JString, required = false,
                                 default = nil)
  if valid_613811 != nil:
    section.add "NodeType", valid_613811
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_613812 = formData.getOrDefault("ClusterIdentifier")
  valid_613812 = validateParameter(valid_613812, JString, required = true,
                                 default = nil)
  if valid_613812 != nil:
    section.add "ClusterIdentifier", valid_613812
  var valid_613813 = formData.getOrDefault("MasterUserPassword")
  valid_613813 = validateParameter(valid_613813, JString, required = false,
                                 default = nil)
  if valid_613813 != nil:
    section.add "MasterUserPassword", valid_613813
  var valid_613814 = formData.getOrDefault("MaintenanceTrackName")
  valid_613814 = validateParameter(valid_613814, JString, required = false,
                                 default = nil)
  if valid_613814 != nil:
    section.add "MaintenanceTrackName", valid_613814
  var valid_613815 = formData.getOrDefault("ClusterSecurityGroups")
  valid_613815 = validateParameter(valid_613815, JArray, required = false,
                                 default = nil)
  if valid_613815 != nil:
    section.add "ClusterSecurityGroups", valid_613815
  var valid_613816 = formData.getOrDefault("NumberOfNodes")
  valid_613816 = validateParameter(valid_613816, JInt, required = false, default = nil)
  if valid_613816 != nil:
    section.add "NumberOfNodes", valid_613816
  var valid_613817 = formData.getOrDefault("VpcSecurityGroupIds")
  valid_613817 = validateParameter(valid_613817, JArray, required = false,
                                 default = nil)
  if valid_613817 != nil:
    section.add "VpcSecurityGroupIds", valid_613817
  var valid_613818 = formData.getOrDefault("AutomatedSnapshotRetentionPeriod")
  valid_613818 = validateParameter(valid_613818, JInt, required = false, default = nil)
  if valid_613818 != nil:
    section.add "AutomatedSnapshotRetentionPeriod", valid_613818
  var valid_613819 = formData.getOrDefault("NewClusterIdentifier")
  valid_613819 = validateParameter(valid_613819, JString, required = false,
                                 default = nil)
  if valid_613819 != nil:
    section.add "NewClusterIdentifier", valid_613819
  var valid_613820 = formData.getOrDefault("EnhancedVpcRouting")
  valid_613820 = validateParameter(valid_613820, JBool, required = false, default = nil)
  if valid_613820 != nil:
    section.add "EnhancedVpcRouting", valid_613820
  var valid_613821 = formData.getOrDefault("KmsKeyId")
  valid_613821 = validateParameter(valid_613821, JString, required = false,
                                 default = nil)
  if valid_613821 != nil:
    section.add "KmsKeyId", valid_613821
  var valid_613822 = formData.getOrDefault("AllowVersionUpgrade")
  valid_613822 = validateParameter(valid_613822, JBool, required = false, default = nil)
  if valid_613822 != nil:
    section.add "AllowVersionUpgrade", valid_613822
  var valid_613823 = formData.getOrDefault("PubliclyAccessible")
  valid_613823 = validateParameter(valid_613823, JBool, required = false, default = nil)
  if valid_613823 != nil:
    section.add "PubliclyAccessible", valid_613823
  var valid_613824 = formData.getOrDefault("ClusterParameterGroupName")
  valid_613824 = validateParameter(valid_613824, JString, required = false,
                                 default = nil)
  if valid_613824 != nil:
    section.add "ClusterParameterGroupName", valid_613824
  var valid_613825 = formData.getOrDefault("ClusterVersion")
  valid_613825 = validateParameter(valid_613825, JString, required = false,
                                 default = nil)
  if valid_613825 != nil:
    section.add "ClusterVersion", valid_613825
  var valid_613826 = formData.getOrDefault("ClusterType")
  valid_613826 = validateParameter(valid_613826, JString, required = false,
                                 default = nil)
  if valid_613826 != nil:
    section.add "ClusterType", valid_613826
  var valid_613827 = formData.getOrDefault("HsmClientCertificateIdentifier")
  valid_613827 = validateParameter(valid_613827, JString, required = false,
                                 default = nil)
  if valid_613827 != nil:
    section.add "HsmClientCertificateIdentifier", valid_613827
  var valid_613828 = formData.getOrDefault("Encrypted")
  valid_613828 = validateParameter(valid_613828, JBool, required = false, default = nil)
  if valid_613828 != nil:
    section.add "Encrypted", valid_613828
  var valid_613829 = formData.getOrDefault("ElasticIp")
  valid_613829 = validateParameter(valid_613829, JString, required = false,
                                 default = nil)
  if valid_613829 != nil:
    section.add "ElasticIp", valid_613829
  var valid_613830 = formData.getOrDefault("HsmConfigurationIdentifier")
  valid_613830 = validateParameter(valid_613830, JString, required = false,
                                 default = nil)
  if valid_613830 != nil:
    section.add "HsmConfigurationIdentifier", valid_613830
  var valid_613831 = formData.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_613831 = validateParameter(valid_613831, JInt, required = false, default = nil)
  if valid_613831 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_613831
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613832: Call_PostModifyCluster_613798; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Modifies the settings for a cluster.</p> <p>You can also change node type and the number of nodes to scale up or down the cluster. When resizing a cluster, you must specify both the number of nodes and the node type even if one of the parameters does not change.</p> <p>You can add another security or parameter group, or change the master user password. Resetting a cluster password or modifying the security groups associated with a cluster do not need a reboot. However, modifying a parameter group requires a reboot for parameters to take effect. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_613832.validator(path, query, header, formData, body)
  let scheme = call_613832.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613832.url(scheme.get, call_613832.host, call_613832.base,
                         call_613832.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613832, url, valid)

proc call*(call_613833: Call_PostModifyCluster_613798; ClusterIdentifier: string;
          PreferredMaintenanceWindow: string = ""; NodeType: string = "";
          MasterUserPassword: string = ""; MaintenanceTrackName: string = "";
          ClusterSecurityGroups: JsonNode = nil; NumberOfNodes: int = 0;
          VpcSecurityGroupIds: JsonNode = nil;
          AutomatedSnapshotRetentionPeriod: int = 0;
          NewClusterIdentifier: string = ""; EnhancedVpcRouting: bool = false;
          KmsKeyId: string = ""; AllowVersionUpgrade: bool = false;
          PubliclyAccessible: bool = false; Action: string = "ModifyCluster";
          ClusterParameterGroupName: string = ""; ClusterVersion: string = "";
          ClusterType: string = ""; HsmClientCertificateIdentifier: string = "";
          Encrypted: bool = false; Version: string = "2012-12-01";
          ElasticIp: string = ""; HsmConfigurationIdentifier: string = "";
          ManualSnapshotRetentionPeriod: int = 0): Recallable =
  ## postModifyCluster
  ## <p>Modifies the settings for a cluster.</p> <p>You can also change node type and the number of nodes to scale up or down the cluster. When resizing a cluster, you must specify both the number of nodes and the node type even if one of the parameters does not change.</p> <p>You can add another security or parameter group, or change the master user password. Resetting a cluster password or modifying the security groups associated with a cluster do not need a reboot. However, modifying a parameter group requires a reboot for parameters to take effect. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   PreferredMaintenanceWindow: string
  ##                             : <p>The weekly time range (in UTC) during which system maintenance can occur, if necessary. If system maintenance is necessary during the window, it may result in an outage.</p> <p>This maintenance window change is made immediately. If the new maintenance window indicates the current time, there must be at least 120 minutes between the current time and end of the window in order to ensure that pending changes are applied.</p> <p>Default: Uses existing setting.</p> <p>Format: ddd:hh24:mi-ddd:hh24:mi, for example <code>wed:07:30-wed:08:00</code>.</p> <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p> <p>Constraints: Must be at least 30 minutes.</p>
  ##   NodeType: string
  ##           : <p>The new node type of the cluster. If you specify a new node type, you must also specify the number of nodes parameter.</p> <p> For more information about resizing clusters, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/rs-resize-tutorial.html">Resizing Clusters in Amazon Redshift</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>Valid Values: <code>ds2.xlarge</code> | <code>ds2.8xlarge</code> | <code>dc1.large</code> | <code>dc1.8xlarge</code> | <code>dc2.large</code> | <code>dc2.8xlarge</code> | <code>ra3.16xlarge</code> </p>
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of the cluster to be modified.</p> <p>Example: <code>examplecluster</code> </p>
  ##   MasterUserPassword: string
  ##                     : <p>The new password for the cluster master user. This change is asynchronously applied as soon as possible. Between the time of the request and the completion of the request, the <code>MasterUserPassword</code> element exists in the <code>PendingModifiedValues</code> element of the operation response. </p> <note> <p>Operations never return the password, so this operation provides a way to regain access to the master user account for a cluster if the password is lost.</p> </note> <p>Default: Uses existing setting.</p> <p>Constraints:</p> <ul> <li> <p>Must be between 8 and 64 characters in length.</p> </li> <li> <p>Must contain at least one uppercase letter.</p> </li> <li> <p>Must contain at least one lowercase letter.</p> </li> <li> <p>Must contain one number.</p> </li> <li> <p>Can be any printable ASCII character (ASCII code 33 to 126) except ' (single quote), " (double quote), \, /, @, or space.</p> </li> </ul>
  ##   MaintenanceTrackName: string
  ##                       : The name for the maintenance track that you want to assign for the cluster. This name change is asynchronous. The new track name stays in the <code>PendingModifiedValues</code> for the cluster until the next maintenance window. When the maintenance track changes, the cluster is switched to the latest cluster release available for the maintenance track. At this point, the maintenance track name is applied.
  ##   ClusterSecurityGroups: JArray
  ##                        : <p>A list of cluster security groups to be authorized on this cluster. This change is asynchronously applied as soon as possible.</p> <p>Security groups currently associated with the cluster, and not in the list of groups to apply, will be revoked from the cluster.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens</p> </li> <li> <p>First character must be a letter</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens</p> </li> </ul>
  ##   NumberOfNodes: int
  ##                : <p>The new number of nodes of the cluster. If you specify a new number of nodes, you must also specify the node type parameter.</p> <p> For more information about resizing clusters, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/rs-resize-tutorial.html">Resizing Clusters in Amazon Redshift</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>Valid Values: Integer greater than <code>0</code>.</p>
  ##   VpcSecurityGroupIds: JArray
  ##                      : A list of virtual private cloud (VPC) security groups to be associated with the cluster. This change is asynchronously applied as soon as possible.
  ##   AutomatedSnapshotRetentionPeriod: int
  ##                                   : <p>The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p> <p>If you decrease the automated snapshot retention period from its current value, existing automated snapshots that fall outside of the new retention period will be immediately deleted.</p> <p>Default: Uses existing setting.</p> <p>Constraints: Must be a value from 0 to 35.</p>
  ##   NewClusterIdentifier: string
  ##                       : <p>The new identifier for the cluster.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul> <p>Example: <code>examplecluster</code> </p>
  ##   EnhancedVpcRouting: bool
  ##                     : <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p> <p>Default: false</p>
  ##   KmsKeyId: string
  ##           : The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster.
  ##   AllowVersionUpgrade: bool
  ##                      : <p>If <code>true</code>, major version upgrades will be applied automatically to the cluster during the maintenance window. </p> <p>Default: <code>false</code> </p>
  ##   PubliclyAccessible: bool
  ##                     : If <code>true</code>, the cluster can be accessed from a public network. Only clusters in VPCs can be set to be publicly available.
  ##   Action: string (required)
  ##   ClusterParameterGroupName: string
  ##                            : <p>The name of the cluster parameter group to apply to this cluster. This change is applied only after the cluster is rebooted. To reboot a cluster use <a>RebootCluster</a>. </p> <p>Default: Uses existing setting.</p> <p>Constraints: The cluster parameter group must be in the same parameter group family that matches the cluster version.</p>
  ##   ClusterVersion: string
  ##                 : <p>The new version number of the Amazon Redshift engine to upgrade to.</p> <p>For major version upgrades, if a non-default cluster parameter group is currently in use, a new cluster parameter group in the cluster parameter group family for the new version must be specified. The new cluster parameter group can be the default for that cluster parameter group family. For more information about parameters and parameter groups, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>Example: <code>1.0</code> </p>
  ##   ClusterType: string
  ##              : <p>The new cluster type.</p> <p>When you submit your cluster resize request, your existing cluster goes into a read-only mode. After Amazon Redshift provisions a new cluster based on your resize requirements, there will be outage for a period while the old cluster is deleted and your connection is switched to the new cluster. You can use <a>DescribeResize</a> to track the progress of the resize request. </p> <p>Valid Values: <code> multi-node | single-node </code> </p>
  ##   HsmClientCertificateIdentifier: string
  ##                                 : Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM.
  ##   Encrypted: bool
  ##            : <p>Indicates whether the cluster is encrypted. If the value is encrypted (true) and you provide a value for the <code>KmsKeyId</code> parameter, we encrypt the cluster with the provided <code>KmsKeyId</code>. If you don't provide a <code>KmsKeyId</code>, we encrypt with the default key. In the China region we use legacy encryption if you specify that the cluster is encrypted.</p> <p>If the value is not encrypted (false), then the cluster is decrypted. </p>
  ##   Version: string (required)
  ##   ElasticIp: string
  ##            : <p>The Elastic IP (EIP) address for the cluster.</p> <p>Constraints: The cluster must be provisioned in EC2-VPC and publicly-accessible through an Internet gateway. For more information about provisioning clusters in EC2-VPC, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#cluster-platforms">Supported Platforms to Launch Your Cluster</a> in the Amazon Redshift Cluster Management Guide.</p>
  ##   HsmConfigurationIdentifier: string
  ##                             : Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The default for number of days that a newly created manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. This value doesn't retroactively change the retention periods of existing manual snapshots.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  var query_613834 = newJObject()
  var formData_613835 = newJObject()
  add(formData_613835, "PreferredMaintenanceWindow",
      newJString(PreferredMaintenanceWindow))
  add(formData_613835, "NodeType", newJString(NodeType))
  add(formData_613835, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_613835, "MasterUserPassword", newJString(MasterUserPassword))
  add(formData_613835, "MaintenanceTrackName", newJString(MaintenanceTrackName))
  if ClusterSecurityGroups != nil:
    formData_613835.add "ClusterSecurityGroups", ClusterSecurityGroups
  add(formData_613835, "NumberOfNodes", newJInt(NumberOfNodes))
  if VpcSecurityGroupIds != nil:
    formData_613835.add "VpcSecurityGroupIds", VpcSecurityGroupIds
  add(formData_613835, "AutomatedSnapshotRetentionPeriod",
      newJInt(AutomatedSnapshotRetentionPeriod))
  add(formData_613835, "NewClusterIdentifier", newJString(NewClusterIdentifier))
  add(formData_613835, "EnhancedVpcRouting", newJBool(EnhancedVpcRouting))
  add(formData_613835, "KmsKeyId", newJString(KmsKeyId))
  add(formData_613835, "AllowVersionUpgrade", newJBool(AllowVersionUpgrade))
  add(formData_613835, "PubliclyAccessible", newJBool(PubliclyAccessible))
  add(query_613834, "Action", newJString(Action))
  add(formData_613835, "ClusterParameterGroupName",
      newJString(ClusterParameterGroupName))
  add(formData_613835, "ClusterVersion", newJString(ClusterVersion))
  add(formData_613835, "ClusterType", newJString(ClusterType))
  add(formData_613835, "HsmClientCertificateIdentifier",
      newJString(HsmClientCertificateIdentifier))
  add(formData_613835, "Encrypted", newJBool(Encrypted))
  add(query_613834, "Version", newJString(Version))
  add(formData_613835, "ElasticIp", newJString(ElasticIp))
  add(formData_613835, "HsmConfigurationIdentifier",
      newJString(HsmConfigurationIdentifier))
  add(formData_613835, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  result = call_613833.call(nil, query_613834, nil, formData_613835, nil)

var postModifyCluster* = Call_PostModifyCluster_613798(name: "postModifyCluster",
    meth: HttpMethod.HttpPost, host: "redshift.amazonaws.com",
    route: "/#Action=ModifyCluster", validator: validate_PostModifyCluster_613799,
    base: "/", url: url_PostModifyCluster_613800,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetModifyCluster_613761 = ref object of OpenApiRestCall_610642
proc url_GetModifyCluster_613763(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetModifyCluster_613762(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## <p>Modifies the settings for a cluster.</p> <p>You can also change node type and the number of nodes to scale up or down the cluster. When resizing a cluster, you must specify both the number of nodes and the node type even if one of the parameters does not change.</p> <p>You can add another security or parameter group, or change the master user password. Resetting a cluster password or modifying the security groups associated with a cluster do not need a reboot. However, modifying a parameter group requires a reboot for parameters to take effect. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   MaintenanceTrackName: JString
  ##                       : The name for the maintenance track that you want to assign for the cluster. This name change is asynchronous. The new track name stays in the <code>PendingModifiedValues</code> for the cluster until the next maintenance window. When the maintenance track changes, the cluster is switched to the latest cluster release available for the maintenance track. At this point, the maintenance track name is applied.
  ##   Encrypted: JBool
  ##            : <p>Indicates whether the cluster is encrypted. If the value is encrypted (true) and you provide a value for the <code>KmsKeyId</code> parameter, we encrypt the cluster with the provided <code>KmsKeyId</code>. If you don't provide a <code>KmsKeyId</code>, we encrypt with the default key. In the China region we use legacy encryption if you specify that the cluster is encrypted.</p> <p>If the value is not encrypted (false), then the cluster is decrypted. </p>
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The default for number of days that a newly created manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. This value doesn't retroactively change the retention periods of existing manual snapshots.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  ##   HsmClientCertificateIdentifier: JString
  ##                                 : Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM.
  ##   ClusterSecurityGroups: JArray
  ##                        : <p>A list of cluster security groups to be authorized on this cluster. This change is asynchronously applied as soon as possible.</p> <p>Security groups currently associated with the cluster, and not in the list of groups to apply, will be revoked from the cluster.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens</p> </li> <li> <p>First character must be a letter</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens</p> </li> </ul>
  ##   KmsKeyId: JString
  ##           : The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster.
  ##   ClusterParameterGroupName: JString
  ##                            : <p>The name of the cluster parameter group to apply to this cluster. This change is applied only after the cluster is rebooted. To reboot a cluster use <a>RebootCluster</a>. </p> <p>Default: Uses existing setting.</p> <p>Constraints: The cluster parameter group must be in the same parameter group family that matches the cluster version.</p>
  ##   NodeType: JString
  ##           : <p>The new node type of the cluster. If you specify a new node type, you must also specify the number of nodes parameter.</p> <p> For more information about resizing clusters, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/rs-resize-tutorial.html">Resizing Clusters in Amazon Redshift</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>Valid Values: <code>ds2.xlarge</code> | <code>ds2.8xlarge</code> | <code>dc1.large</code> | <code>dc1.8xlarge</code> | <code>dc2.large</code> | <code>dc2.8xlarge</code> | <code>ra3.16xlarge</code> </p>
  ##   ClusterVersion: JString
  ##                 : <p>The new version number of the Amazon Redshift engine to upgrade to.</p> <p>For major version upgrades, if a non-default cluster parameter group is currently in use, a new cluster parameter group in the cluster parameter group family for the new version must be specified. The new cluster parameter group can be the default for that cluster parameter group family. For more information about parameters and parameter groups, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>Example: <code>1.0</code> </p>
  ##   ClusterType: JString
  ##              : <p>The new cluster type.</p> <p>When you submit your cluster resize request, your existing cluster goes into a read-only mode. After Amazon Redshift provisions a new cluster based on your resize requirements, there will be outage for a period while the old cluster is deleted and your connection is switched to the new cluster. You can use <a>DescribeResize</a> to track the progress of the resize request. </p> <p>Valid Values: <code> multi-node | single-node </code> </p>
  ##   NumberOfNodes: JInt
  ##                : <p>The new number of nodes of the cluster. If you specify a new number of nodes, you must also specify the node type parameter.</p> <p> For more information about resizing clusters, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/rs-resize-tutorial.html">Resizing Clusters in Amazon Redshift</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>Valid Values: Integer greater than <code>0</code>.</p>
  ##   AllowVersionUpgrade: JBool
  ##                      : <p>If <code>true</code>, major version upgrades will be applied automatically to the cluster during the maintenance window. </p> <p>Default: <code>false</code> </p>
  ##   ElasticIp: JString
  ##            : <p>The Elastic IP (EIP) address for the cluster.</p> <p>Constraints: The cluster must be provisioned in EC2-VPC and publicly-accessible through an Internet gateway. For more information about provisioning clusters in EC2-VPC, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#cluster-platforms">Supported Platforms to Launch Your Cluster</a> in the Amazon Redshift Cluster Management Guide.</p>
  ##   AutomatedSnapshotRetentionPeriod: JInt
  ##                                   : <p>The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p> <p>If you decrease the automated snapshot retention period from its current value, existing automated snapshots that fall outside of the new retention period will be immediately deleted.</p> <p>Default: Uses existing setting.</p> <p>Constraints: Must be a value from 0 to 35.</p>
  ##   EnhancedVpcRouting: JBool
  ##                     : <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p> <p>Default: false</p>
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of the cluster to be modified.</p> <p>Example: <code>examplecluster</code> </p>
  ##   VpcSecurityGroupIds: JArray
  ##                      : A list of virtual private cloud (VPC) security groups to be associated with the cluster. This change is asynchronously applied as soon as possible.
  ##   NewClusterIdentifier: JString
  ##                       : <p>The new identifier for the cluster.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul> <p>Example: <code>examplecluster</code> </p>
  ##   MasterUserPassword: JString
  ##                     : <p>The new password for the cluster master user. This change is asynchronously applied as soon as possible. Between the time of the request and the completion of the request, the <code>MasterUserPassword</code> element exists in the <code>PendingModifiedValues</code> element of the operation response. </p> <note> <p>Operations never return the password, so this operation provides a way to regain access to the master user account for a cluster if the password is lost.</p> </note> <p>Default: Uses existing setting.</p> <p>Constraints:</p> <ul> <li> <p>Must be between 8 and 64 characters in length.</p> </li> <li> <p>Must contain at least one uppercase letter.</p> </li> <li> <p>Must contain at least one lowercase letter.</p> </li> <li> <p>Must contain one number.</p> </li> <li> <p>Can be any printable ASCII character (ASCII code 33 to 126) except ' (single quote), " (double quote), \, /, @, or space.</p> </li> </ul>
  ##   HsmConfigurationIdentifier: JString
  ##                             : Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
  ##   Version: JString (required)
  ##   PreferredMaintenanceWindow: JString
  ##                             : <p>The weekly time range (in UTC) during which system maintenance can occur, if necessary. If system maintenance is necessary during the window, it may result in an outage.</p> <p>This maintenance window change is made immediately. If the new maintenance window indicates the current time, there must be at least 120 minutes between the current time and end of the window in order to ensure that pending changes are applied.</p> <p>Default: Uses existing setting.</p> <p>Format: ddd:hh24:mi-ddd:hh24:mi, for example <code>wed:07:30-wed:08:00</code>.</p> <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p> <p>Constraints: Must be at least 30 minutes.</p>
  ##   PubliclyAccessible: JBool
  ##                     : If <code>true</code>, the cluster can be accessed from a public network. Only clusters in VPCs can be set to be publicly available.
  section = newJObject()
  var valid_613764 = query.getOrDefault("MaintenanceTrackName")
  valid_613764 = validateParameter(valid_613764, JString, required = false,
                                 default = nil)
  if valid_613764 != nil:
    section.add "MaintenanceTrackName", valid_613764
  var valid_613765 = query.getOrDefault("Encrypted")
  valid_613765 = validateParameter(valid_613765, JBool, required = false, default = nil)
  if valid_613765 != nil:
    section.add "Encrypted", valid_613765
  var valid_613766 = query.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_613766 = validateParameter(valid_613766, JInt, required = false, default = nil)
  if valid_613766 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_613766
  var valid_613767 = query.getOrDefault("HsmClientCertificateIdentifier")
  valid_613767 = validateParameter(valid_613767, JString, required = false,
                                 default = nil)
  if valid_613767 != nil:
    section.add "HsmClientCertificateIdentifier", valid_613767
  var valid_613768 = query.getOrDefault("ClusterSecurityGroups")
  valid_613768 = validateParameter(valid_613768, JArray, required = false,
                                 default = nil)
  if valid_613768 != nil:
    section.add "ClusterSecurityGroups", valid_613768
  var valid_613769 = query.getOrDefault("KmsKeyId")
  valid_613769 = validateParameter(valid_613769, JString, required = false,
                                 default = nil)
  if valid_613769 != nil:
    section.add "KmsKeyId", valid_613769
  var valid_613770 = query.getOrDefault("ClusterParameterGroupName")
  valid_613770 = validateParameter(valid_613770, JString, required = false,
                                 default = nil)
  if valid_613770 != nil:
    section.add "ClusterParameterGroupName", valid_613770
  var valid_613771 = query.getOrDefault("NodeType")
  valid_613771 = validateParameter(valid_613771, JString, required = false,
                                 default = nil)
  if valid_613771 != nil:
    section.add "NodeType", valid_613771
  var valid_613772 = query.getOrDefault("ClusterVersion")
  valid_613772 = validateParameter(valid_613772, JString, required = false,
                                 default = nil)
  if valid_613772 != nil:
    section.add "ClusterVersion", valid_613772
  var valid_613773 = query.getOrDefault("ClusterType")
  valid_613773 = validateParameter(valid_613773, JString, required = false,
                                 default = nil)
  if valid_613773 != nil:
    section.add "ClusterType", valid_613773
  var valid_613774 = query.getOrDefault("NumberOfNodes")
  valid_613774 = validateParameter(valid_613774, JInt, required = false, default = nil)
  if valid_613774 != nil:
    section.add "NumberOfNodes", valid_613774
  var valid_613775 = query.getOrDefault("AllowVersionUpgrade")
  valid_613775 = validateParameter(valid_613775, JBool, required = false, default = nil)
  if valid_613775 != nil:
    section.add "AllowVersionUpgrade", valid_613775
  var valid_613776 = query.getOrDefault("ElasticIp")
  valid_613776 = validateParameter(valid_613776, JString, required = false,
                                 default = nil)
  if valid_613776 != nil:
    section.add "ElasticIp", valid_613776
  var valid_613777 = query.getOrDefault("AutomatedSnapshotRetentionPeriod")
  valid_613777 = validateParameter(valid_613777, JInt, required = false, default = nil)
  if valid_613777 != nil:
    section.add "AutomatedSnapshotRetentionPeriod", valid_613777
  var valid_613778 = query.getOrDefault("EnhancedVpcRouting")
  valid_613778 = validateParameter(valid_613778, JBool, required = false, default = nil)
  if valid_613778 != nil:
    section.add "EnhancedVpcRouting", valid_613778
  var valid_613779 = query.getOrDefault("Action")
  valid_613779 = validateParameter(valid_613779, JString, required = true,
                                 default = newJString("ModifyCluster"))
  if valid_613779 != nil:
    section.add "Action", valid_613779
  var valid_613780 = query.getOrDefault("ClusterIdentifier")
  valid_613780 = validateParameter(valid_613780, JString, required = true,
                                 default = nil)
  if valid_613780 != nil:
    section.add "ClusterIdentifier", valid_613780
  var valid_613781 = query.getOrDefault("VpcSecurityGroupIds")
  valid_613781 = validateParameter(valid_613781, JArray, required = false,
                                 default = nil)
  if valid_613781 != nil:
    section.add "VpcSecurityGroupIds", valid_613781
  var valid_613782 = query.getOrDefault("NewClusterIdentifier")
  valid_613782 = validateParameter(valid_613782, JString, required = false,
                                 default = nil)
  if valid_613782 != nil:
    section.add "NewClusterIdentifier", valid_613782
  var valid_613783 = query.getOrDefault("MasterUserPassword")
  valid_613783 = validateParameter(valid_613783, JString, required = false,
                                 default = nil)
  if valid_613783 != nil:
    section.add "MasterUserPassword", valid_613783
  var valid_613784 = query.getOrDefault("HsmConfigurationIdentifier")
  valid_613784 = validateParameter(valid_613784, JString, required = false,
                                 default = nil)
  if valid_613784 != nil:
    section.add "HsmConfigurationIdentifier", valid_613784
  var valid_613785 = query.getOrDefault("Version")
  valid_613785 = validateParameter(valid_613785, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_613785 != nil:
    section.add "Version", valid_613785
  var valid_613786 = query.getOrDefault("PreferredMaintenanceWindow")
  valid_613786 = validateParameter(valid_613786, JString, required = false,
                                 default = nil)
  if valid_613786 != nil:
    section.add "PreferredMaintenanceWindow", valid_613786
  var valid_613787 = query.getOrDefault("PubliclyAccessible")
  valid_613787 = validateParameter(valid_613787, JBool, required = false, default = nil)
  if valid_613787 != nil:
    section.add "PubliclyAccessible", valid_613787
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613788 = header.getOrDefault("X-Amz-Signature")
  valid_613788 = validateParameter(valid_613788, JString, required = false,
                                 default = nil)
  if valid_613788 != nil:
    section.add "X-Amz-Signature", valid_613788
  var valid_613789 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613789 = validateParameter(valid_613789, JString, required = false,
                                 default = nil)
  if valid_613789 != nil:
    section.add "X-Amz-Content-Sha256", valid_613789
  var valid_613790 = header.getOrDefault("X-Amz-Date")
  valid_613790 = validateParameter(valid_613790, JString, required = false,
                                 default = nil)
  if valid_613790 != nil:
    section.add "X-Amz-Date", valid_613790
  var valid_613791 = header.getOrDefault("X-Amz-Credential")
  valid_613791 = validateParameter(valid_613791, JString, required = false,
                                 default = nil)
  if valid_613791 != nil:
    section.add "X-Amz-Credential", valid_613791
  var valid_613792 = header.getOrDefault("X-Amz-Security-Token")
  valid_613792 = validateParameter(valid_613792, JString, required = false,
                                 default = nil)
  if valid_613792 != nil:
    section.add "X-Amz-Security-Token", valid_613792
  var valid_613793 = header.getOrDefault("X-Amz-Algorithm")
  valid_613793 = validateParameter(valid_613793, JString, required = false,
                                 default = nil)
  if valid_613793 != nil:
    section.add "X-Amz-Algorithm", valid_613793
  var valid_613794 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613794 = validateParameter(valid_613794, JString, required = false,
                                 default = nil)
  if valid_613794 != nil:
    section.add "X-Amz-SignedHeaders", valid_613794
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613795: Call_GetModifyCluster_613761; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Modifies the settings for a cluster.</p> <p>You can also change node type and the number of nodes to scale up or down the cluster. When resizing a cluster, you must specify both the number of nodes and the node type even if one of the parameters does not change.</p> <p>You can add another security or parameter group, or change the master user password. Resetting a cluster password or modifying the security groups associated with a cluster do not need a reboot. However, modifying a parameter group requires a reboot for parameters to take effect. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_613795.validator(path, query, header, formData, body)
  let scheme = call_613795.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613795.url(scheme.get, call_613795.host, call_613795.base,
                         call_613795.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613795, url, valid)

proc call*(call_613796: Call_GetModifyCluster_613761; ClusterIdentifier: string;
          MaintenanceTrackName: string = ""; Encrypted: bool = false;
          ManualSnapshotRetentionPeriod: int = 0;
          HsmClientCertificateIdentifier: string = "";
          ClusterSecurityGroups: JsonNode = nil; KmsKeyId: string = "";
          ClusterParameterGroupName: string = ""; NodeType: string = "";
          ClusterVersion: string = ""; ClusterType: string = ""; NumberOfNodes: int = 0;
          AllowVersionUpgrade: bool = false; ElasticIp: string = "";
          AutomatedSnapshotRetentionPeriod: int = 0;
          EnhancedVpcRouting: bool = false; Action: string = "ModifyCluster";
          VpcSecurityGroupIds: JsonNode = nil; NewClusterIdentifier: string = "";
          MasterUserPassword: string = ""; HsmConfigurationIdentifier: string = "";
          Version: string = "2012-12-01"; PreferredMaintenanceWindow: string = "";
          PubliclyAccessible: bool = false): Recallable =
  ## getModifyCluster
  ## <p>Modifies the settings for a cluster.</p> <p>You can also change node type and the number of nodes to scale up or down the cluster. When resizing a cluster, you must specify both the number of nodes and the node type even if one of the parameters does not change.</p> <p>You can add another security or parameter group, or change the master user password. Resetting a cluster password or modifying the security groups associated with a cluster do not need a reboot. However, modifying a parameter group requires a reboot for parameters to take effect. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   MaintenanceTrackName: string
  ##                       : The name for the maintenance track that you want to assign for the cluster. This name change is asynchronous. The new track name stays in the <code>PendingModifiedValues</code> for the cluster until the next maintenance window. When the maintenance track changes, the cluster is switched to the latest cluster release available for the maintenance track. At this point, the maintenance track name is applied.
  ##   Encrypted: bool
  ##            : <p>Indicates whether the cluster is encrypted. If the value is encrypted (true) and you provide a value for the <code>KmsKeyId</code> parameter, we encrypt the cluster with the provided <code>KmsKeyId</code>. If you don't provide a <code>KmsKeyId</code>, we encrypt with the default key. In the China region we use legacy encryption if you specify that the cluster is encrypted.</p> <p>If the value is not encrypted (false), then the cluster is decrypted. </p>
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The default for number of days that a newly created manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. This value doesn't retroactively change the retention periods of existing manual snapshots.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  ##   HsmClientCertificateIdentifier: string
  ##                                 : Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM.
  ##   ClusterSecurityGroups: JArray
  ##                        : <p>A list of cluster security groups to be authorized on this cluster. This change is asynchronously applied as soon as possible.</p> <p>Security groups currently associated with the cluster, and not in the list of groups to apply, will be revoked from the cluster.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens</p> </li> <li> <p>First character must be a letter</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens</p> </li> </ul>
  ##   KmsKeyId: string
  ##           : The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster.
  ##   ClusterParameterGroupName: string
  ##                            : <p>The name of the cluster parameter group to apply to this cluster. This change is applied only after the cluster is rebooted. To reboot a cluster use <a>RebootCluster</a>. </p> <p>Default: Uses existing setting.</p> <p>Constraints: The cluster parameter group must be in the same parameter group family that matches the cluster version.</p>
  ##   NodeType: string
  ##           : <p>The new node type of the cluster. If you specify a new node type, you must also specify the number of nodes parameter.</p> <p> For more information about resizing clusters, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/rs-resize-tutorial.html">Resizing Clusters in Amazon Redshift</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>Valid Values: <code>ds2.xlarge</code> | <code>ds2.8xlarge</code> | <code>dc1.large</code> | <code>dc1.8xlarge</code> | <code>dc2.large</code> | <code>dc2.8xlarge</code> | <code>ra3.16xlarge</code> </p>
  ##   ClusterVersion: string
  ##                 : <p>The new version number of the Amazon Redshift engine to upgrade to.</p> <p>For major version upgrades, if a non-default cluster parameter group is currently in use, a new cluster parameter group in the cluster parameter group family for the new version must be specified. The new cluster parameter group can be the default for that cluster parameter group family. For more information about parameters and parameter groups, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>Example: <code>1.0</code> </p>
  ##   ClusterType: string
  ##              : <p>The new cluster type.</p> <p>When you submit your cluster resize request, your existing cluster goes into a read-only mode. After Amazon Redshift provisions a new cluster based on your resize requirements, there will be outage for a period while the old cluster is deleted and your connection is switched to the new cluster. You can use <a>DescribeResize</a> to track the progress of the resize request. </p> <p>Valid Values: <code> multi-node | single-node </code> </p>
  ##   NumberOfNodes: int
  ##                : <p>The new number of nodes of the cluster. If you specify a new number of nodes, you must also specify the node type parameter.</p> <p> For more information about resizing clusters, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/rs-resize-tutorial.html">Resizing Clusters in Amazon Redshift</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>Valid Values: Integer greater than <code>0</code>.</p>
  ##   AllowVersionUpgrade: bool
  ##                      : <p>If <code>true</code>, major version upgrades will be applied automatically to the cluster during the maintenance window. </p> <p>Default: <code>false</code> </p>
  ##   ElasticIp: string
  ##            : <p>The Elastic IP (EIP) address for the cluster.</p> <p>Constraints: The cluster must be provisioned in EC2-VPC and publicly-accessible through an Internet gateway. For more information about provisioning clusters in EC2-VPC, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#cluster-platforms">Supported Platforms to Launch Your Cluster</a> in the Amazon Redshift Cluster Management Guide.</p>
  ##   AutomatedSnapshotRetentionPeriod: int
  ##                                   : <p>The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p> <p>If you decrease the automated snapshot retention period from its current value, existing automated snapshots that fall outside of the new retention period will be immediately deleted.</p> <p>Default: Uses existing setting.</p> <p>Constraints: Must be a value from 0 to 35.</p>
  ##   EnhancedVpcRouting: bool
  ##                     : <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p> <p>Default: false</p>
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of the cluster to be modified.</p> <p>Example: <code>examplecluster</code> </p>
  ##   VpcSecurityGroupIds: JArray
  ##                      : A list of virtual private cloud (VPC) security groups to be associated with the cluster. This change is asynchronously applied as soon as possible.
  ##   NewClusterIdentifier: string
  ##                       : <p>The new identifier for the cluster.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul> <p>Example: <code>examplecluster</code> </p>
  ##   MasterUserPassword: string
  ##                     : <p>The new password for the cluster master user. This change is asynchronously applied as soon as possible. Between the time of the request and the completion of the request, the <code>MasterUserPassword</code> element exists in the <code>PendingModifiedValues</code> element of the operation response. </p> <note> <p>Operations never return the password, so this operation provides a way to regain access to the master user account for a cluster if the password is lost.</p> </note> <p>Default: Uses existing setting.</p> <p>Constraints:</p> <ul> <li> <p>Must be between 8 and 64 characters in length.</p> </li> <li> <p>Must contain at least one uppercase letter.</p> </li> <li> <p>Must contain at least one lowercase letter.</p> </li> <li> <p>Must contain one number.</p> </li> <li> <p>Can be any printable ASCII character (ASCII code 33 to 126) except ' (single quote), " (double quote), \, /, @, or space.</p> </li> </ul>
  ##   HsmConfigurationIdentifier: string
  ##                             : Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
  ##   Version: string (required)
  ##   PreferredMaintenanceWindow: string
  ##                             : <p>The weekly time range (in UTC) during which system maintenance can occur, if necessary. If system maintenance is necessary during the window, it may result in an outage.</p> <p>This maintenance window change is made immediately. If the new maintenance window indicates the current time, there must be at least 120 minutes between the current time and end of the window in order to ensure that pending changes are applied.</p> <p>Default: Uses existing setting.</p> <p>Format: ddd:hh24:mi-ddd:hh24:mi, for example <code>wed:07:30-wed:08:00</code>.</p> <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p> <p>Constraints: Must be at least 30 minutes.</p>
  ##   PubliclyAccessible: bool
  ##                     : If <code>true</code>, the cluster can be accessed from a public network. Only clusters in VPCs can be set to be publicly available.
  var query_613797 = newJObject()
  add(query_613797, "MaintenanceTrackName", newJString(MaintenanceTrackName))
  add(query_613797, "Encrypted", newJBool(Encrypted))
  add(query_613797, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  add(query_613797, "HsmClientCertificateIdentifier",
      newJString(HsmClientCertificateIdentifier))
  if ClusterSecurityGroups != nil:
    query_613797.add "ClusterSecurityGroups", ClusterSecurityGroups
  add(query_613797, "KmsKeyId", newJString(KmsKeyId))
  add(query_613797, "ClusterParameterGroupName",
      newJString(ClusterParameterGroupName))
  add(query_613797, "NodeType", newJString(NodeType))
  add(query_613797, "ClusterVersion", newJString(ClusterVersion))
  add(query_613797, "ClusterType", newJString(ClusterType))
  add(query_613797, "NumberOfNodes", newJInt(NumberOfNodes))
  add(query_613797, "AllowVersionUpgrade", newJBool(AllowVersionUpgrade))
  add(query_613797, "ElasticIp", newJString(ElasticIp))
  add(query_613797, "AutomatedSnapshotRetentionPeriod",
      newJInt(AutomatedSnapshotRetentionPeriod))
  add(query_613797, "EnhancedVpcRouting", newJBool(EnhancedVpcRouting))
  add(query_613797, "Action", newJString(Action))
  add(query_613797, "ClusterIdentifier", newJString(ClusterIdentifier))
  if VpcSecurityGroupIds != nil:
    query_613797.add "VpcSecurityGroupIds", VpcSecurityGroupIds
  add(query_613797, "NewClusterIdentifier", newJString(NewClusterIdentifier))
  add(query_613797, "MasterUserPassword", newJString(MasterUserPassword))
  add(query_613797, "HsmConfigurationIdentifier",
      newJString(HsmConfigurationIdentifier))
  add(query_613797, "Version", newJString(Version))
  add(query_613797, "PreferredMaintenanceWindow",
      newJString(PreferredMaintenanceWindow))
  add(query_613797, "PubliclyAccessible", newJBool(PubliclyAccessible))
  result = call_613796.call(nil, query_613797, nil, nil, nil)

var getModifyCluster* = Call_GetModifyCluster_613761(name: "getModifyCluster",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=ModifyCluster", validator: validate_GetModifyCluster_613762,
    base: "/", url: url_GetModifyCluster_613763,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostModifyClusterDbRevision_613853 = ref object of OpenApiRestCall_610642
proc url_PostModifyClusterDbRevision_613855(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostModifyClusterDbRevision_613854(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies the database revision of a cluster. The database revision is a unique revision of the database running in a cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_613856 = query.getOrDefault("Action")
  valid_613856 = validateParameter(valid_613856, JString, required = true, default = newJString(
      "ModifyClusterDbRevision"))
  if valid_613856 != nil:
    section.add "Action", valid_613856
  var valid_613857 = query.getOrDefault("Version")
  valid_613857 = validateParameter(valid_613857, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_613857 != nil:
    section.add "Version", valid_613857
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613858 = header.getOrDefault("X-Amz-Signature")
  valid_613858 = validateParameter(valid_613858, JString, required = false,
                                 default = nil)
  if valid_613858 != nil:
    section.add "X-Amz-Signature", valid_613858
  var valid_613859 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613859 = validateParameter(valid_613859, JString, required = false,
                                 default = nil)
  if valid_613859 != nil:
    section.add "X-Amz-Content-Sha256", valid_613859
  var valid_613860 = header.getOrDefault("X-Amz-Date")
  valid_613860 = validateParameter(valid_613860, JString, required = false,
                                 default = nil)
  if valid_613860 != nil:
    section.add "X-Amz-Date", valid_613860
  var valid_613861 = header.getOrDefault("X-Amz-Credential")
  valid_613861 = validateParameter(valid_613861, JString, required = false,
                                 default = nil)
  if valid_613861 != nil:
    section.add "X-Amz-Credential", valid_613861
  var valid_613862 = header.getOrDefault("X-Amz-Security-Token")
  valid_613862 = validateParameter(valid_613862, JString, required = false,
                                 default = nil)
  if valid_613862 != nil:
    section.add "X-Amz-Security-Token", valid_613862
  var valid_613863 = header.getOrDefault("X-Amz-Algorithm")
  valid_613863 = validateParameter(valid_613863, JString, required = false,
                                 default = nil)
  if valid_613863 != nil:
    section.add "X-Amz-Algorithm", valid_613863
  var valid_613864 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613864 = validateParameter(valid_613864, JString, required = false,
                                 default = nil)
  if valid_613864 != nil:
    section.add "X-Amz-SignedHeaders", valid_613864
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of a cluster whose database revision you want to modify. </p> <p>Example: <code>examplecluster</code> </p>
  ##   RevisionTarget: JString (required)
  ##                 : The identifier of the database revision. You can retrieve this value from the response to the <a>DescribeClusterDbRevisions</a> request.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_613865 = formData.getOrDefault("ClusterIdentifier")
  valid_613865 = validateParameter(valid_613865, JString, required = true,
                                 default = nil)
  if valid_613865 != nil:
    section.add "ClusterIdentifier", valid_613865
  var valid_613866 = formData.getOrDefault("RevisionTarget")
  valid_613866 = validateParameter(valid_613866, JString, required = true,
                                 default = nil)
  if valid_613866 != nil:
    section.add "RevisionTarget", valid_613866
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613867: Call_PostModifyClusterDbRevision_613853; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Modifies the database revision of a cluster. The database revision is a unique revision of the database running in a cluster.
  ## 
  let valid = call_613867.validator(path, query, header, formData, body)
  let scheme = call_613867.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613867.url(scheme.get, call_613867.host, call_613867.base,
                         call_613867.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613867, url, valid)

proc call*(call_613868: Call_PostModifyClusterDbRevision_613853;
          ClusterIdentifier: string; RevisionTarget: string;
          Action: string = "ModifyClusterDbRevision"; Version: string = "2012-12-01"): Recallable =
  ## postModifyClusterDbRevision
  ## Modifies the database revision of a cluster. The database revision is a unique revision of the database running in a cluster.
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of a cluster whose database revision you want to modify. </p> <p>Example: <code>examplecluster</code> </p>
  ##   Action: string (required)
  ##   RevisionTarget: string (required)
  ##                 : The identifier of the database revision. You can retrieve this value from the response to the <a>DescribeClusterDbRevisions</a> request.
  ##   Version: string (required)
  var query_613869 = newJObject()
  var formData_613870 = newJObject()
  add(formData_613870, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_613869, "Action", newJString(Action))
  add(formData_613870, "RevisionTarget", newJString(RevisionTarget))
  add(query_613869, "Version", newJString(Version))
  result = call_613868.call(nil, query_613869, nil, formData_613870, nil)

var postModifyClusterDbRevision* = Call_PostModifyClusterDbRevision_613853(
    name: "postModifyClusterDbRevision", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyClusterDbRevision",
    validator: validate_PostModifyClusterDbRevision_613854, base: "/",
    url: url_PostModifyClusterDbRevision_613855,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetModifyClusterDbRevision_613836 = ref object of OpenApiRestCall_610642
proc url_GetModifyClusterDbRevision_613838(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetModifyClusterDbRevision_613837(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies the database revision of a cluster. The database revision is a unique revision of the database running in a cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   RevisionTarget: JString (required)
  ##                 : The identifier of the database revision. You can retrieve this value from the response to the <a>DescribeClusterDbRevisions</a> request.
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of a cluster whose database revision you want to modify. </p> <p>Example: <code>examplecluster</code> </p>
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `RevisionTarget` field"
  var valid_613839 = query.getOrDefault("RevisionTarget")
  valid_613839 = validateParameter(valid_613839, JString, required = true,
                                 default = nil)
  if valid_613839 != nil:
    section.add "RevisionTarget", valid_613839
  var valid_613840 = query.getOrDefault("Action")
  valid_613840 = validateParameter(valid_613840, JString, required = true, default = newJString(
      "ModifyClusterDbRevision"))
  if valid_613840 != nil:
    section.add "Action", valid_613840
  var valid_613841 = query.getOrDefault("ClusterIdentifier")
  valid_613841 = validateParameter(valid_613841, JString, required = true,
                                 default = nil)
  if valid_613841 != nil:
    section.add "ClusterIdentifier", valid_613841
  var valid_613842 = query.getOrDefault("Version")
  valid_613842 = validateParameter(valid_613842, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_613842 != nil:
    section.add "Version", valid_613842
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613843 = header.getOrDefault("X-Amz-Signature")
  valid_613843 = validateParameter(valid_613843, JString, required = false,
                                 default = nil)
  if valid_613843 != nil:
    section.add "X-Amz-Signature", valid_613843
  var valid_613844 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613844 = validateParameter(valid_613844, JString, required = false,
                                 default = nil)
  if valid_613844 != nil:
    section.add "X-Amz-Content-Sha256", valid_613844
  var valid_613845 = header.getOrDefault("X-Amz-Date")
  valid_613845 = validateParameter(valid_613845, JString, required = false,
                                 default = nil)
  if valid_613845 != nil:
    section.add "X-Amz-Date", valid_613845
  var valid_613846 = header.getOrDefault("X-Amz-Credential")
  valid_613846 = validateParameter(valid_613846, JString, required = false,
                                 default = nil)
  if valid_613846 != nil:
    section.add "X-Amz-Credential", valid_613846
  var valid_613847 = header.getOrDefault("X-Amz-Security-Token")
  valid_613847 = validateParameter(valid_613847, JString, required = false,
                                 default = nil)
  if valid_613847 != nil:
    section.add "X-Amz-Security-Token", valid_613847
  var valid_613848 = header.getOrDefault("X-Amz-Algorithm")
  valid_613848 = validateParameter(valid_613848, JString, required = false,
                                 default = nil)
  if valid_613848 != nil:
    section.add "X-Amz-Algorithm", valid_613848
  var valid_613849 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613849 = validateParameter(valid_613849, JString, required = false,
                                 default = nil)
  if valid_613849 != nil:
    section.add "X-Amz-SignedHeaders", valid_613849
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613850: Call_GetModifyClusterDbRevision_613836; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Modifies the database revision of a cluster. The database revision is a unique revision of the database running in a cluster.
  ## 
  let valid = call_613850.validator(path, query, header, formData, body)
  let scheme = call_613850.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613850.url(scheme.get, call_613850.host, call_613850.base,
                         call_613850.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613850, url, valid)

proc call*(call_613851: Call_GetModifyClusterDbRevision_613836;
          RevisionTarget: string; ClusterIdentifier: string;
          Action: string = "ModifyClusterDbRevision"; Version: string = "2012-12-01"): Recallable =
  ## getModifyClusterDbRevision
  ## Modifies the database revision of a cluster. The database revision is a unique revision of the database running in a cluster.
  ##   RevisionTarget: string (required)
  ##                 : The identifier of the database revision. You can retrieve this value from the response to the <a>DescribeClusterDbRevisions</a> request.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of a cluster whose database revision you want to modify. </p> <p>Example: <code>examplecluster</code> </p>
  ##   Version: string (required)
  var query_613852 = newJObject()
  add(query_613852, "RevisionTarget", newJString(RevisionTarget))
  add(query_613852, "Action", newJString(Action))
  add(query_613852, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_613852, "Version", newJString(Version))
  result = call_613851.call(nil, query_613852, nil, nil, nil)

var getModifyClusterDbRevision* = Call_GetModifyClusterDbRevision_613836(
    name: "getModifyClusterDbRevision", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyClusterDbRevision",
    validator: validate_GetModifyClusterDbRevision_613837, base: "/",
    url: url_GetModifyClusterDbRevision_613838,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostModifyClusterIamRoles_613889 = ref object of OpenApiRestCall_610642
proc url_PostModifyClusterIamRoles_613891(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostModifyClusterIamRoles_613890(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Modifies the list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services.</p> <p>A cluster can have up to 10 IAM roles associated at any time.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_613892 = query.getOrDefault("Action")
  valid_613892 = validateParameter(valid_613892, JString, required = true,
                                 default = newJString("ModifyClusterIamRoles"))
  if valid_613892 != nil:
    section.add "Action", valid_613892
  var valid_613893 = query.getOrDefault("Version")
  valid_613893 = validateParameter(valid_613893, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_613893 != nil:
    section.add "Version", valid_613893
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613894 = header.getOrDefault("X-Amz-Signature")
  valid_613894 = validateParameter(valid_613894, JString, required = false,
                                 default = nil)
  if valid_613894 != nil:
    section.add "X-Amz-Signature", valid_613894
  var valid_613895 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613895 = validateParameter(valid_613895, JString, required = false,
                                 default = nil)
  if valid_613895 != nil:
    section.add "X-Amz-Content-Sha256", valid_613895
  var valid_613896 = header.getOrDefault("X-Amz-Date")
  valid_613896 = validateParameter(valid_613896, JString, required = false,
                                 default = nil)
  if valid_613896 != nil:
    section.add "X-Amz-Date", valid_613896
  var valid_613897 = header.getOrDefault("X-Amz-Credential")
  valid_613897 = validateParameter(valid_613897, JString, required = false,
                                 default = nil)
  if valid_613897 != nil:
    section.add "X-Amz-Credential", valid_613897
  var valid_613898 = header.getOrDefault("X-Amz-Security-Token")
  valid_613898 = validateParameter(valid_613898, JString, required = false,
                                 default = nil)
  if valid_613898 != nil:
    section.add "X-Amz-Security-Token", valid_613898
  var valid_613899 = header.getOrDefault("X-Amz-Algorithm")
  valid_613899 = validateParameter(valid_613899, JString, required = false,
                                 default = nil)
  if valid_613899 != nil:
    section.add "X-Amz-Algorithm", valid_613899
  var valid_613900 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613900 = validateParameter(valid_613900, JString, required = false,
                                 default = nil)
  if valid_613900 != nil:
    section.add "X-Amz-SignedHeaders", valid_613900
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : The unique identifier of the cluster for which you want to associate or disassociate IAM roles.
  ##   RemoveIamRoles: JArray
  ##                 : Zero or more IAM roles in ARN format to disassociate from the cluster. You can disassociate up to 10 IAM roles from a single cluster in a single request.
  ##   AddIamRoles: JArray
  ##              : Zero or more IAM roles to associate with the cluster. The roles must be in their Amazon Resource Name (ARN) format. You can associate up to 10 IAM roles with a single cluster in a single request.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_613901 = formData.getOrDefault("ClusterIdentifier")
  valid_613901 = validateParameter(valid_613901, JString, required = true,
                                 default = nil)
  if valid_613901 != nil:
    section.add "ClusterIdentifier", valid_613901
  var valid_613902 = formData.getOrDefault("RemoveIamRoles")
  valid_613902 = validateParameter(valid_613902, JArray, required = false,
                                 default = nil)
  if valid_613902 != nil:
    section.add "RemoveIamRoles", valid_613902
  var valid_613903 = formData.getOrDefault("AddIamRoles")
  valid_613903 = validateParameter(valid_613903, JArray, required = false,
                                 default = nil)
  if valid_613903 != nil:
    section.add "AddIamRoles", valid_613903
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613904: Call_PostModifyClusterIamRoles_613889; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Modifies the list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services.</p> <p>A cluster can have up to 10 IAM roles associated at any time.</p>
  ## 
  let valid = call_613904.validator(path, query, header, formData, body)
  let scheme = call_613904.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613904.url(scheme.get, call_613904.host, call_613904.base,
                         call_613904.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613904, url, valid)

proc call*(call_613905: Call_PostModifyClusterIamRoles_613889;
          ClusterIdentifier: string; RemoveIamRoles: JsonNode = nil;
          Action: string = "ModifyClusterIamRoles"; AddIamRoles: JsonNode = nil;
          Version: string = "2012-12-01"): Recallable =
  ## postModifyClusterIamRoles
  ## <p>Modifies the list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services.</p> <p>A cluster can have up to 10 IAM roles associated at any time.</p>
  ##   ClusterIdentifier: string (required)
  ##                    : The unique identifier of the cluster for which you want to associate or disassociate IAM roles.
  ##   RemoveIamRoles: JArray
  ##                 : Zero or more IAM roles in ARN format to disassociate from the cluster. You can disassociate up to 10 IAM roles from a single cluster in a single request.
  ##   Action: string (required)
  ##   AddIamRoles: JArray
  ##              : Zero or more IAM roles to associate with the cluster. The roles must be in their Amazon Resource Name (ARN) format. You can associate up to 10 IAM roles with a single cluster in a single request.
  ##   Version: string (required)
  var query_613906 = newJObject()
  var formData_613907 = newJObject()
  add(formData_613907, "ClusterIdentifier", newJString(ClusterIdentifier))
  if RemoveIamRoles != nil:
    formData_613907.add "RemoveIamRoles", RemoveIamRoles
  add(query_613906, "Action", newJString(Action))
  if AddIamRoles != nil:
    formData_613907.add "AddIamRoles", AddIamRoles
  add(query_613906, "Version", newJString(Version))
  result = call_613905.call(nil, query_613906, nil, formData_613907, nil)

var postModifyClusterIamRoles* = Call_PostModifyClusterIamRoles_613889(
    name: "postModifyClusterIamRoles", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyClusterIamRoles",
    validator: validate_PostModifyClusterIamRoles_613890, base: "/",
    url: url_PostModifyClusterIamRoles_613891,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetModifyClusterIamRoles_613871 = ref object of OpenApiRestCall_610642
proc url_GetModifyClusterIamRoles_613873(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetModifyClusterIamRoles_613872(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Modifies the list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services.</p> <p>A cluster can have up to 10 IAM roles associated at any time.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   AddIamRoles: JArray
  ##              : Zero or more IAM roles to associate with the cluster. The roles must be in their Amazon Resource Name (ARN) format. You can associate up to 10 IAM roles with a single cluster in a single request.
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : The unique identifier of the cluster for which you want to associate or disassociate IAM roles.
  ##   RemoveIamRoles: JArray
  ##                 : Zero or more IAM roles in ARN format to disassociate from the cluster. You can disassociate up to 10 IAM roles from a single cluster in a single request.
  ##   Version: JString (required)
  section = newJObject()
  var valid_613874 = query.getOrDefault("AddIamRoles")
  valid_613874 = validateParameter(valid_613874, JArray, required = false,
                                 default = nil)
  if valid_613874 != nil:
    section.add "AddIamRoles", valid_613874
  var valid_613875 = query.getOrDefault("Action")
  valid_613875 = validateParameter(valid_613875, JString, required = true,
                                 default = newJString("ModifyClusterIamRoles"))
  if valid_613875 != nil:
    section.add "Action", valid_613875
  var valid_613876 = query.getOrDefault("ClusterIdentifier")
  valid_613876 = validateParameter(valid_613876, JString, required = true,
                                 default = nil)
  if valid_613876 != nil:
    section.add "ClusterIdentifier", valid_613876
  var valid_613877 = query.getOrDefault("RemoveIamRoles")
  valid_613877 = validateParameter(valid_613877, JArray, required = false,
                                 default = nil)
  if valid_613877 != nil:
    section.add "RemoveIamRoles", valid_613877
  var valid_613878 = query.getOrDefault("Version")
  valid_613878 = validateParameter(valid_613878, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_613878 != nil:
    section.add "Version", valid_613878
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613879 = header.getOrDefault("X-Amz-Signature")
  valid_613879 = validateParameter(valid_613879, JString, required = false,
                                 default = nil)
  if valid_613879 != nil:
    section.add "X-Amz-Signature", valid_613879
  var valid_613880 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613880 = validateParameter(valid_613880, JString, required = false,
                                 default = nil)
  if valid_613880 != nil:
    section.add "X-Amz-Content-Sha256", valid_613880
  var valid_613881 = header.getOrDefault("X-Amz-Date")
  valid_613881 = validateParameter(valid_613881, JString, required = false,
                                 default = nil)
  if valid_613881 != nil:
    section.add "X-Amz-Date", valid_613881
  var valid_613882 = header.getOrDefault("X-Amz-Credential")
  valid_613882 = validateParameter(valid_613882, JString, required = false,
                                 default = nil)
  if valid_613882 != nil:
    section.add "X-Amz-Credential", valid_613882
  var valid_613883 = header.getOrDefault("X-Amz-Security-Token")
  valid_613883 = validateParameter(valid_613883, JString, required = false,
                                 default = nil)
  if valid_613883 != nil:
    section.add "X-Amz-Security-Token", valid_613883
  var valid_613884 = header.getOrDefault("X-Amz-Algorithm")
  valid_613884 = validateParameter(valid_613884, JString, required = false,
                                 default = nil)
  if valid_613884 != nil:
    section.add "X-Amz-Algorithm", valid_613884
  var valid_613885 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613885 = validateParameter(valid_613885, JString, required = false,
                                 default = nil)
  if valid_613885 != nil:
    section.add "X-Amz-SignedHeaders", valid_613885
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613886: Call_GetModifyClusterIamRoles_613871; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Modifies the list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services.</p> <p>A cluster can have up to 10 IAM roles associated at any time.</p>
  ## 
  let valid = call_613886.validator(path, query, header, formData, body)
  let scheme = call_613886.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613886.url(scheme.get, call_613886.host, call_613886.base,
                         call_613886.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613886, url, valid)

proc call*(call_613887: Call_GetModifyClusterIamRoles_613871;
          ClusterIdentifier: string; AddIamRoles: JsonNode = nil;
          Action: string = "ModifyClusterIamRoles"; RemoveIamRoles: JsonNode = nil;
          Version: string = "2012-12-01"): Recallable =
  ## getModifyClusterIamRoles
  ## <p>Modifies the list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services.</p> <p>A cluster can have up to 10 IAM roles associated at any time.</p>
  ##   AddIamRoles: JArray
  ##              : Zero or more IAM roles to associate with the cluster. The roles must be in their Amazon Resource Name (ARN) format. You can associate up to 10 IAM roles with a single cluster in a single request.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : The unique identifier of the cluster for which you want to associate or disassociate IAM roles.
  ##   RemoveIamRoles: JArray
  ##                 : Zero or more IAM roles in ARN format to disassociate from the cluster. You can disassociate up to 10 IAM roles from a single cluster in a single request.
  ##   Version: string (required)
  var query_613888 = newJObject()
  if AddIamRoles != nil:
    query_613888.add "AddIamRoles", AddIamRoles
  add(query_613888, "Action", newJString(Action))
  add(query_613888, "ClusterIdentifier", newJString(ClusterIdentifier))
  if RemoveIamRoles != nil:
    query_613888.add "RemoveIamRoles", RemoveIamRoles
  add(query_613888, "Version", newJString(Version))
  result = call_613887.call(nil, query_613888, nil, nil, nil)

var getModifyClusterIamRoles* = Call_GetModifyClusterIamRoles_613871(
    name: "getModifyClusterIamRoles", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyClusterIamRoles",
    validator: validate_GetModifyClusterIamRoles_613872, base: "/",
    url: url_GetModifyClusterIamRoles_613873, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostModifyClusterMaintenance_613929 = ref object of OpenApiRestCall_610642
proc url_PostModifyClusterMaintenance_613931(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostModifyClusterMaintenance_613930(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies the maintenance settings of a cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_613932 = query.getOrDefault("Action")
  valid_613932 = validateParameter(valid_613932, JString, required = true, default = newJString(
      "ModifyClusterMaintenance"))
  if valid_613932 != nil:
    section.add "Action", valid_613932
  var valid_613933 = query.getOrDefault("Version")
  valid_613933 = validateParameter(valid_613933, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_613933 != nil:
    section.add "Version", valid_613933
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613934 = header.getOrDefault("X-Amz-Signature")
  valid_613934 = validateParameter(valid_613934, JString, required = false,
                                 default = nil)
  if valid_613934 != nil:
    section.add "X-Amz-Signature", valid_613934
  var valid_613935 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613935 = validateParameter(valid_613935, JString, required = false,
                                 default = nil)
  if valid_613935 != nil:
    section.add "X-Amz-Content-Sha256", valid_613935
  var valid_613936 = header.getOrDefault("X-Amz-Date")
  valid_613936 = validateParameter(valid_613936, JString, required = false,
                                 default = nil)
  if valid_613936 != nil:
    section.add "X-Amz-Date", valid_613936
  var valid_613937 = header.getOrDefault("X-Amz-Credential")
  valid_613937 = validateParameter(valid_613937, JString, required = false,
                                 default = nil)
  if valid_613937 != nil:
    section.add "X-Amz-Credential", valid_613937
  var valid_613938 = header.getOrDefault("X-Amz-Security-Token")
  valid_613938 = validateParameter(valid_613938, JString, required = false,
                                 default = nil)
  if valid_613938 != nil:
    section.add "X-Amz-Security-Token", valid_613938
  var valid_613939 = header.getOrDefault("X-Amz-Algorithm")
  valid_613939 = validateParameter(valid_613939, JString, required = false,
                                 default = nil)
  if valid_613939 != nil:
    section.add "X-Amz-Algorithm", valid_613939
  var valid_613940 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613940 = validateParameter(valid_613940, JString, required = false,
                                 default = nil)
  if valid_613940 != nil:
    section.add "X-Amz-SignedHeaders", valid_613940
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : A unique identifier for the cluster.
  ##   DeferMaintenanceStartTime: JString
  ##                            : A timestamp indicating the start time for the deferred maintenance window.
  ##   DeferMaintenance: JBool
  ##                   : A boolean indicating whether to enable the deferred maintenance window. 
  ##   DeferMaintenanceDuration: JInt
  ##                           : An integer indicating the duration of the maintenance window in days. If you specify a duration, you can't specify an end time. The duration must be 45 days or less.
  ##   DeferMaintenanceEndTime: JString
  ##                          : A timestamp indicating end time for the deferred maintenance window. If you specify an end time, you can't specify a duration.
  ##   DeferMaintenanceIdentifier: JString
  ##                             : A unique identifier for the deferred maintenance window.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_613941 = formData.getOrDefault("ClusterIdentifier")
  valid_613941 = validateParameter(valid_613941, JString, required = true,
                                 default = nil)
  if valid_613941 != nil:
    section.add "ClusterIdentifier", valid_613941
  var valid_613942 = formData.getOrDefault("DeferMaintenanceStartTime")
  valid_613942 = validateParameter(valid_613942, JString, required = false,
                                 default = nil)
  if valid_613942 != nil:
    section.add "DeferMaintenanceStartTime", valid_613942
  var valid_613943 = formData.getOrDefault("DeferMaintenance")
  valid_613943 = validateParameter(valid_613943, JBool, required = false, default = nil)
  if valid_613943 != nil:
    section.add "DeferMaintenance", valid_613943
  var valid_613944 = formData.getOrDefault("DeferMaintenanceDuration")
  valid_613944 = validateParameter(valid_613944, JInt, required = false, default = nil)
  if valid_613944 != nil:
    section.add "DeferMaintenanceDuration", valid_613944
  var valid_613945 = formData.getOrDefault("DeferMaintenanceEndTime")
  valid_613945 = validateParameter(valid_613945, JString, required = false,
                                 default = nil)
  if valid_613945 != nil:
    section.add "DeferMaintenanceEndTime", valid_613945
  var valid_613946 = formData.getOrDefault("DeferMaintenanceIdentifier")
  valid_613946 = validateParameter(valid_613946, JString, required = false,
                                 default = nil)
  if valid_613946 != nil:
    section.add "DeferMaintenanceIdentifier", valid_613946
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613947: Call_PostModifyClusterMaintenance_613929; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Modifies the maintenance settings of a cluster.
  ## 
  let valid = call_613947.validator(path, query, header, formData, body)
  let scheme = call_613947.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613947.url(scheme.get, call_613947.host, call_613947.base,
                         call_613947.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613947, url, valid)

proc call*(call_613948: Call_PostModifyClusterMaintenance_613929;
          ClusterIdentifier: string; DeferMaintenanceStartTime: string = "";
          DeferMaintenance: bool = false; DeferMaintenanceDuration: int = 0;
          DeferMaintenanceEndTime: string = "";
          Action: string = "ModifyClusterMaintenance";
          DeferMaintenanceIdentifier: string = ""; Version: string = "2012-12-01"): Recallable =
  ## postModifyClusterMaintenance
  ## Modifies the maintenance settings of a cluster.
  ##   ClusterIdentifier: string (required)
  ##                    : A unique identifier for the cluster.
  ##   DeferMaintenanceStartTime: string
  ##                            : A timestamp indicating the start time for the deferred maintenance window.
  ##   DeferMaintenance: bool
  ##                   : A boolean indicating whether to enable the deferred maintenance window. 
  ##   DeferMaintenanceDuration: int
  ##                           : An integer indicating the duration of the maintenance window in days. If you specify a duration, you can't specify an end time. The duration must be 45 days or less.
  ##   DeferMaintenanceEndTime: string
  ##                          : A timestamp indicating end time for the deferred maintenance window. If you specify an end time, you can't specify a duration.
  ##   Action: string (required)
  ##   DeferMaintenanceIdentifier: string
  ##                             : A unique identifier for the deferred maintenance window.
  ##   Version: string (required)
  var query_613949 = newJObject()
  var formData_613950 = newJObject()
  add(formData_613950, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_613950, "DeferMaintenanceStartTime",
      newJString(DeferMaintenanceStartTime))
  add(formData_613950, "DeferMaintenance", newJBool(DeferMaintenance))
  add(formData_613950, "DeferMaintenanceDuration",
      newJInt(DeferMaintenanceDuration))
  add(formData_613950, "DeferMaintenanceEndTime",
      newJString(DeferMaintenanceEndTime))
  add(query_613949, "Action", newJString(Action))
  add(formData_613950, "DeferMaintenanceIdentifier",
      newJString(DeferMaintenanceIdentifier))
  add(query_613949, "Version", newJString(Version))
  result = call_613948.call(nil, query_613949, nil, formData_613950, nil)

var postModifyClusterMaintenance* = Call_PostModifyClusterMaintenance_613929(
    name: "postModifyClusterMaintenance", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyClusterMaintenance",
    validator: validate_PostModifyClusterMaintenance_613930, base: "/",
    url: url_PostModifyClusterMaintenance_613931,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetModifyClusterMaintenance_613908 = ref object of OpenApiRestCall_610642
proc url_GetModifyClusterMaintenance_613910(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetModifyClusterMaintenance_613909(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies the maintenance settings of a cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   DeferMaintenanceDuration: JInt
  ##                           : An integer indicating the duration of the maintenance window in days. If you specify a duration, you can't specify an end time. The duration must be 45 days or less.
  ##   DeferMaintenanceIdentifier: JString
  ##                             : A unique identifier for the deferred maintenance window.
  ##   DeferMaintenanceEndTime: JString
  ##                          : A timestamp indicating end time for the deferred maintenance window. If you specify an end time, you can't specify a duration.
  ##   Action: JString (required)
  ##   DeferMaintenance: JBool
  ##                   : A boolean indicating whether to enable the deferred maintenance window. 
  ##   ClusterIdentifier: JString (required)
  ##                    : A unique identifier for the cluster.
  ##   Version: JString (required)
  ##   DeferMaintenanceStartTime: JString
  ##                            : A timestamp indicating the start time for the deferred maintenance window.
  section = newJObject()
  var valid_613911 = query.getOrDefault("DeferMaintenanceDuration")
  valid_613911 = validateParameter(valid_613911, JInt, required = false, default = nil)
  if valid_613911 != nil:
    section.add "DeferMaintenanceDuration", valid_613911
  var valid_613912 = query.getOrDefault("DeferMaintenanceIdentifier")
  valid_613912 = validateParameter(valid_613912, JString, required = false,
                                 default = nil)
  if valid_613912 != nil:
    section.add "DeferMaintenanceIdentifier", valid_613912
  var valid_613913 = query.getOrDefault("DeferMaintenanceEndTime")
  valid_613913 = validateParameter(valid_613913, JString, required = false,
                                 default = nil)
  if valid_613913 != nil:
    section.add "DeferMaintenanceEndTime", valid_613913
  var valid_613914 = query.getOrDefault("Action")
  valid_613914 = validateParameter(valid_613914, JString, required = true, default = newJString(
      "ModifyClusterMaintenance"))
  if valid_613914 != nil:
    section.add "Action", valid_613914
  var valid_613915 = query.getOrDefault("DeferMaintenance")
  valid_613915 = validateParameter(valid_613915, JBool, required = false, default = nil)
  if valid_613915 != nil:
    section.add "DeferMaintenance", valid_613915
  var valid_613916 = query.getOrDefault("ClusterIdentifier")
  valid_613916 = validateParameter(valid_613916, JString, required = true,
                                 default = nil)
  if valid_613916 != nil:
    section.add "ClusterIdentifier", valid_613916
  var valid_613917 = query.getOrDefault("Version")
  valid_613917 = validateParameter(valid_613917, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_613917 != nil:
    section.add "Version", valid_613917
  var valid_613918 = query.getOrDefault("DeferMaintenanceStartTime")
  valid_613918 = validateParameter(valid_613918, JString, required = false,
                                 default = nil)
  if valid_613918 != nil:
    section.add "DeferMaintenanceStartTime", valid_613918
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613919 = header.getOrDefault("X-Amz-Signature")
  valid_613919 = validateParameter(valid_613919, JString, required = false,
                                 default = nil)
  if valid_613919 != nil:
    section.add "X-Amz-Signature", valid_613919
  var valid_613920 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613920 = validateParameter(valid_613920, JString, required = false,
                                 default = nil)
  if valid_613920 != nil:
    section.add "X-Amz-Content-Sha256", valid_613920
  var valid_613921 = header.getOrDefault("X-Amz-Date")
  valid_613921 = validateParameter(valid_613921, JString, required = false,
                                 default = nil)
  if valid_613921 != nil:
    section.add "X-Amz-Date", valid_613921
  var valid_613922 = header.getOrDefault("X-Amz-Credential")
  valid_613922 = validateParameter(valid_613922, JString, required = false,
                                 default = nil)
  if valid_613922 != nil:
    section.add "X-Amz-Credential", valid_613922
  var valid_613923 = header.getOrDefault("X-Amz-Security-Token")
  valid_613923 = validateParameter(valid_613923, JString, required = false,
                                 default = nil)
  if valid_613923 != nil:
    section.add "X-Amz-Security-Token", valid_613923
  var valid_613924 = header.getOrDefault("X-Amz-Algorithm")
  valid_613924 = validateParameter(valid_613924, JString, required = false,
                                 default = nil)
  if valid_613924 != nil:
    section.add "X-Amz-Algorithm", valid_613924
  var valid_613925 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613925 = validateParameter(valid_613925, JString, required = false,
                                 default = nil)
  if valid_613925 != nil:
    section.add "X-Amz-SignedHeaders", valid_613925
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613926: Call_GetModifyClusterMaintenance_613908; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Modifies the maintenance settings of a cluster.
  ## 
  let valid = call_613926.validator(path, query, header, formData, body)
  let scheme = call_613926.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613926.url(scheme.get, call_613926.host, call_613926.base,
                         call_613926.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613926, url, valid)

proc call*(call_613927: Call_GetModifyClusterMaintenance_613908;
          ClusterIdentifier: string; DeferMaintenanceDuration: int = 0;
          DeferMaintenanceIdentifier: string = "";
          DeferMaintenanceEndTime: string = "";
          Action: string = "ModifyClusterMaintenance";
          DeferMaintenance: bool = false; Version: string = "2012-12-01";
          DeferMaintenanceStartTime: string = ""): Recallable =
  ## getModifyClusterMaintenance
  ## Modifies the maintenance settings of a cluster.
  ##   DeferMaintenanceDuration: int
  ##                           : An integer indicating the duration of the maintenance window in days. If you specify a duration, you can't specify an end time. The duration must be 45 days or less.
  ##   DeferMaintenanceIdentifier: string
  ##                             : A unique identifier for the deferred maintenance window.
  ##   DeferMaintenanceEndTime: string
  ##                          : A timestamp indicating end time for the deferred maintenance window. If you specify an end time, you can't specify a duration.
  ##   Action: string (required)
  ##   DeferMaintenance: bool
  ##                   : A boolean indicating whether to enable the deferred maintenance window. 
  ##   ClusterIdentifier: string (required)
  ##                    : A unique identifier for the cluster.
  ##   Version: string (required)
  ##   DeferMaintenanceStartTime: string
  ##                            : A timestamp indicating the start time for the deferred maintenance window.
  var query_613928 = newJObject()
  add(query_613928, "DeferMaintenanceDuration", newJInt(DeferMaintenanceDuration))
  add(query_613928, "DeferMaintenanceIdentifier",
      newJString(DeferMaintenanceIdentifier))
  add(query_613928, "DeferMaintenanceEndTime", newJString(DeferMaintenanceEndTime))
  add(query_613928, "Action", newJString(Action))
  add(query_613928, "DeferMaintenance", newJBool(DeferMaintenance))
  add(query_613928, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_613928, "Version", newJString(Version))
  add(query_613928, "DeferMaintenanceStartTime",
      newJString(DeferMaintenanceStartTime))
  result = call_613927.call(nil, query_613928, nil, nil, nil)

var getModifyClusterMaintenance* = Call_GetModifyClusterMaintenance_613908(
    name: "getModifyClusterMaintenance", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyClusterMaintenance",
    validator: validate_GetModifyClusterMaintenance_613909, base: "/",
    url: url_GetModifyClusterMaintenance_613910,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostModifyClusterParameterGroup_613968 = ref object of OpenApiRestCall_610642
proc url_PostModifyClusterParameterGroup_613970(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostModifyClusterParameterGroup_613969(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Modifies the parameters of a parameter group.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_613971 = query.getOrDefault("Action")
  valid_613971 = validateParameter(valid_613971, JString, required = true, default = newJString(
      "ModifyClusterParameterGroup"))
  if valid_613971 != nil:
    section.add "Action", valid_613971
  var valid_613972 = query.getOrDefault("Version")
  valid_613972 = validateParameter(valid_613972, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_613972 != nil:
    section.add "Version", valid_613972
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613973 = header.getOrDefault("X-Amz-Signature")
  valid_613973 = validateParameter(valid_613973, JString, required = false,
                                 default = nil)
  if valid_613973 != nil:
    section.add "X-Amz-Signature", valid_613973
  var valid_613974 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613974 = validateParameter(valid_613974, JString, required = false,
                                 default = nil)
  if valid_613974 != nil:
    section.add "X-Amz-Content-Sha256", valid_613974
  var valid_613975 = header.getOrDefault("X-Amz-Date")
  valid_613975 = validateParameter(valid_613975, JString, required = false,
                                 default = nil)
  if valid_613975 != nil:
    section.add "X-Amz-Date", valid_613975
  var valid_613976 = header.getOrDefault("X-Amz-Credential")
  valid_613976 = validateParameter(valid_613976, JString, required = false,
                                 default = nil)
  if valid_613976 != nil:
    section.add "X-Amz-Credential", valid_613976
  var valid_613977 = header.getOrDefault("X-Amz-Security-Token")
  valid_613977 = validateParameter(valid_613977, JString, required = false,
                                 default = nil)
  if valid_613977 != nil:
    section.add "X-Amz-Security-Token", valid_613977
  var valid_613978 = header.getOrDefault("X-Amz-Algorithm")
  valid_613978 = validateParameter(valid_613978, JString, required = false,
                                 default = nil)
  if valid_613978 != nil:
    section.add "X-Amz-Algorithm", valid_613978
  var valid_613979 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613979 = validateParameter(valid_613979, JString, required = false,
                                 default = nil)
  if valid_613979 != nil:
    section.add "X-Amz-SignedHeaders", valid_613979
  result.add "header", section
  ## parameters in `formData` object:
  ##   Parameters: JArray (required)
  ##             : <p>An array of parameters to be modified. A maximum of 20 parameters can be modified in a single request.</p> <p>For each parameter to be modified, you must supply at least the parameter name and parameter value; other name-value pairs of the parameter are optional.</p> <p>For the workload management (WLM) configuration, you must supply all the name-value pairs in the wlm_json_configuration parameter.</p>
  ##   ParameterGroupName: JString (required)
  ##                     : The name of the parameter group to be modified.
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `Parameters` field"
  var valid_613980 = formData.getOrDefault("Parameters")
  valid_613980 = validateParameter(valid_613980, JArray, required = true, default = nil)
  if valid_613980 != nil:
    section.add "Parameters", valid_613980
  var valid_613981 = formData.getOrDefault("ParameterGroupName")
  valid_613981 = validateParameter(valid_613981, JString, required = true,
                                 default = nil)
  if valid_613981 != nil:
    section.add "ParameterGroupName", valid_613981
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613982: Call_PostModifyClusterParameterGroup_613968;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Modifies the parameters of a parameter group.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_613982.validator(path, query, header, formData, body)
  let scheme = call_613982.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613982.url(scheme.get, call_613982.host, call_613982.base,
                         call_613982.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613982, url, valid)

proc call*(call_613983: Call_PostModifyClusterParameterGroup_613968;
          Parameters: JsonNode; ParameterGroupName: string;
          Action: string = "ModifyClusterParameterGroup";
          Version: string = "2012-12-01"): Recallable =
  ## postModifyClusterParameterGroup
  ## <p>Modifies the parameters of a parameter group.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   Action: string (required)
  ##   Parameters: JArray (required)
  ##             : <p>An array of parameters to be modified. A maximum of 20 parameters can be modified in a single request.</p> <p>For each parameter to be modified, you must supply at least the parameter name and parameter value; other name-value pairs of the parameter are optional.</p> <p>For the workload management (WLM) configuration, you must supply all the name-value pairs in the wlm_json_configuration parameter.</p>
  ##   ParameterGroupName: string (required)
  ##                     : The name of the parameter group to be modified.
  ##   Version: string (required)
  var query_613984 = newJObject()
  var formData_613985 = newJObject()
  add(query_613984, "Action", newJString(Action))
  if Parameters != nil:
    formData_613985.add "Parameters", Parameters
  add(formData_613985, "ParameterGroupName", newJString(ParameterGroupName))
  add(query_613984, "Version", newJString(Version))
  result = call_613983.call(nil, query_613984, nil, formData_613985, nil)

var postModifyClusterParameterGroup* = Call_PostModifyClusterParameterGroup_613968(
    name: "postModifyClusterParameterGroup", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyClusterParameterGroup",
    validator: validate_PostModifyClusterParameterGroup_613969, base: "/",
    url: url_PostModifyClusterParameterGroup_613970,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetModifyClusterParameterGroup_613951 = ref object of OpenApiRestCall_610642
proc url_GetModifyClusterParameterGroup_613953(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetModifyClusterParameterGroup_613952(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Modifies the parameters of a parameter group.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Parameters: JArray (required)
  ##             : <p>An array of parameters to be modified. A maximum of 20 parameters can be modified in a single request.</p> <p>For each parameter to be modified, you must supply at least the parameter name and parameter value; other name-value pairs of the parameter are optional.</p> <p>For the workload management (WLM) configuration, you must supply all the name-value pairs in the wlm_json_configuration parameter.</p>
  ##   Action: JString (required)
  ##   ParameterGroupName: JString (required)
  ##                     : The name of the parameter group to be modified.
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `Parameters` field"
  var valid_613954 = query.getOrDefault("Parameters")
  valid_613954 = validateParameter(valid_613954, JArray, required = true, default = nil)
  if valid_613954 != nil:
    section.add "Parameters", valid_613954
  var valid_613955 = query.getOrDefault("Action")
  valid_613955 = validateParameter(valid_613955, JString, required = true, default = newJString(
      "ModifyClusterParameterGroup"))
  if valid_613955 != nil:
    section.add "Action", valid_613955
  var valid_613956 = query.getOrDefault("ParameterGroupName")
  valid_613956 = validateParameter(valid_613956, JString, required = true,
                                 default = nil)
  if valid_613956 != nil:
    section.add "ParameterGroupName", valid_613956
  var valid_613957 = query.getOrDefault("Version")
  valid_613957 = validateParameter(valid_613957, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_613957 != nil:
    section.add "Version", valid_613957
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613958 = header.getOrDefault("X-Amz-Signature")
  valid_613958 = validateParameter(valid_613958, JString, required = false,
                                 default = nil)
  if valid_613958 != nil:
    section.add "X-Amz-Signature", valid_613958
  var valid_613959 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613959 = validateParameter(valid_613959, JString, required = false,
                                 default = nil)
  if valid_613959 != nil:
    section.add "X-Amz-Content-Sha256", valid_613959
  var valid_613960 = header.getOrDefault("X-Amz-Date")
  valid_613960 = validateParameter(valid_613960, JString, required = false,
                                 default = nil)
  if valid_613960 != nil:
    section.add "X-Amz-Date", valid_613960
  var valid_613961 = header.getOrDefault("X-Amz-Credential")
  valid_613961 = validateParameter(valid_613961, JString, required = false,
                                 default = nil)
  if valid_613961 != nil:
    section.add "X-Amz-Credential", valid_613961
  var valid_613962 = header.getOrDefault("X-Amz-Security-Token")
  valid_613962 = validateParameter(valid_613962, JString, required = false,
                                 default = nil)
  if valid_613962 != nil:
    section.add "X-Amz-Security-Token", valid_613962
  var valid_613963 = header.getOrDefault("X-Amz-Algorithm")
  valid_613963 = validateParameter(valid_613963, JString, required = false,
                                 default = nil)
  if valid_613963 != nil:
    section.add "X-Amz-Algorithm", valid_613963
  var valid_613964 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613964 = validateParameter(valid_613964, JString, required = false,
                                 default = nil)
  if valid_613964 != nil:
    section.add "X-Amz-SignedHeaders", valid_613964
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613965: Call_GetModifyClusterParameterGroup_613951; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Modifies the parameters of a parameter group.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_613965.validator(path, query, header, formData, body)
  let scheme = call_613965.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613965.url(scheme.get, call_613965.host, call_613965.base,
                         call_613965.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613965, url, valid)

proc call*(call_613966: Call_GetModifyClusterParameterGroup_613951;
          Parameters: JsonNode; ParameterGroupName: string;
          Action: string = "ModifyClusterParameterGroup";
          Version: string = "2012-12-01"): Recallable =
  ## getModifyClusterParameterGroup
  ## <p>Modifies the parameters of a parameter group.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   Parameters: JArray (required)
  ##             : <p>An array of parameters to be modified. A maximum of 20 parameters can be modified in a single request.</p> <p>For each parameter to be modified, you must supply at least the parameter name and parameter value; other name-value pairs of the parameter are optional.</p> <p>For the workload management (WLM) configuration, you must supply all the name-value pairs in the wlm_json_configuration parameter.</p>
  ##   Action: string (required)
  ##   ParameterGroupName: string (required)
  ##                     : The name of the parameter group to be modified.
  ##   Version: string (required)
  var query_613967 = newJObject()
  if Parameters != nil:
    query_613967.add "Parameters", Parameters
  add(query_613967, "Action", newJString(Action))
  add(query_613967, "ParameterGroupName", newJString(ParameterGroupName))
  add(query_613967, "Version", newJString(Version))
  result = call_613966.call(nil, query_613967, nil, nil, nil)

var getModifyClusterParameterGroup* = Call_GetModifyClusterParameterGroup_613951(
    name: "getModifyClusterParameterGroup", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyClusterParameterGroup",
    validator: validate_GetModifyClusterParameterGroup_613952, base: "/",
    url: url_GetModifyClusterParameterGroup_613953,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostModifyClusterSnapshot_614004 = ref object of OpenApiRestCall_610642
proc url_PostModifyClusterSnapshot_614006(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostModifyClusterSnapshot_614005(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Modifies the settings for a snapshot.</p> <p>This exanmple modifies the manual retention period setting for a cluster snapshot.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_614007 = query.getOrDefault("Action")
  valid_614007 = validateParameter(valid_614007, JString, required = true,
                                 default = newJString("ModifyClusterSnapshot"))
  if valid_614007 != nil:
    section.add "Action", valid_614007
  var valid_614008 = query.getOrDefault("Version")
  valid_614008 = validateParameter(valid_614008, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_614008 != nil:
    section.add "Version", valid_614008
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614009 = header.getOrDefault("X-Amz-Signature")
  valid_614009 = validateParameter(valid_614009, JString, required = false,
                                 default = nil)
  if valid_614009 != nil:
    section.add "X-Amz-Signature", valid_614009
  var valid_614010 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614010 = validateParameter(valid_614010, JString, required = false,
                                 default = nil)
  if valid_614010 != nil:
    section.add "X-Amz-Content-Sha256", valid_614010
  var valid_614011 = header.getOrDefault("X-Amz-Date")
  valid_614011 = validateParameter(valid_614011, JString, required = false,
                                 default = nil)
  if valid_614011 != nil:
    section.add "X-Amz-Date", valid_614011
  var valid_614012 = header.getOrDefault("X-Amz-Credential")
  valid_614012 = validateParameter(valid_614012, JString, required = false,
                                 default = nil)
  if valid_614012 != nil:
    section.add "X-Amz-Credential", valid_614012
  var valid_614013 = header.getOrDefault("X-Amz-Security-Token")
  valid_614013 = validateParameter(valid_614013, JString, required = false,
                                 default = nil)
  if valid_614013 != nil:
    section.add "X-Amz-Security-Token", valid_614013
  var valid_614014 = header.getOrDefault("X-Amz-Algorithm")
  valid_614014 = validateParameter(valid_614014, JString, required = false,
                                 default = nil)
  if valid_614014 != nil:
    section.add "X-Amz-Algorithm", valid_614014
  var valid_614015 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614015 = validateParameter(valid_614015, JString, required = false,
                                 default = nil)
  if valid_614015 != nil:
    section.add "X-Amz-SignedHeaders", valid_614015
  result.add "header", section
  ## parameters in `formData` object:
  ##   Force: JBool
  ##        : A Boolean option to override an exception if the retention period has already passed.
  ##   SnapshotIdentifier: JString (required)
  ##                     : The identifier of the snapshot whose setting you want to modify.
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely.</p> <p>If the manual snapshot falls outside of the new retention period, you can specify the force option to immediately delete the snapshot.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  section = newJObject()
  var valid_614016 = formData.getOrDefault("Force")
  valid_614016 = validateParameter(valid_614016, JBool, required = false, default = nil)
  if valid_614016 != nil:
    section.add "Force", valid_614016
  assert formData != nil, "formData argument is necessary due to required `SnapshotIdentifier` field"
  var valid_614017 = formData.getOrDefault("SnapshotIdentifier")
  valid_614017 = validateParameter(valid_614017, JString, required = true,
                                 default = nil)
  if valid_614017 != nil:
    section.add "SnapshotIdentifier", valid_614017
  var valid_614018 = formData.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_614018 = validateParameter(valid_614018, JInt, required = false, default = nil)
  if valid_614018 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_614018
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614019: Call_PostModifyClusterSnapshot_614004; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Modifies the settings for a snapshot.</p> <p>This exanmple modifies the manual retention period setting for a cluster snapshot.</p>
  ## 
  let valid = call_614019.validator(path, query, header, formData, body)
  let scheme = call_614019.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614019.url(scheme.get, call_614019.host, call_614019.base,
                         call_614019.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614019, url, valid)

proc call*(call_614020: Call_PostModifyClusterSnapshot_614004;
          SnapshotIdentifier: string; Force: bool = false;
          Action: string = "ModifyClusterSnapshot"; Version: string = "2012-12-01";
          ManualSnapshotRetentionPeriod: int = 0): Recallable =
  ## postModifyClusterSnapshot
  ## <p>Modifies the settings for a snapshot.</p> <p>This exanmple modifies the manual retention period setting for a cluster snapshot.</p>
  ##   Force: bool
  ##        : A Boolean option to override an exception if the retention period has already passed.
  ##   SnapshotIdentifier: string (required)
  ##                     : The identifier of the snapshot whose setting you want to modify.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely.</p> <p>If the manual snapshot falls outside of the new retention period, you can specify the force option to immediately delete the snapshot.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  var query_614021 = newJObject()
  var formData_614022 = newJObject()
  add(formData_614022, "Force", newJBool(Force))
  add(formData_614022, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_614021, "Action", newJString(Action))
  add(query_614021, "Version", newJString(Version))
  add(formData_614022, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  result = call_614020.call(nil, query_614021, nil, formData_614022, nil)

var postModifyClusterSnapshot* = Call_PostModifyClusterSnapshot_614004(
    name: "postModifyClusterSnapshot", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyClusterSnapshot",
    validator: validate_PostModifyClusterSnapshot_614005, base: "/",
    url: url_PostModifyClusterSnapshot_614006,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetModifyClusterSnapshot_613986 = ref object of OpenApiRestCall_610642
proc url_GetModifyClusterSnapshot_613988(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetModifyClusterSnapshot_613987(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Modifies the settings for a snapshot.</p> <p>This exanmple modifies the manual retention period setting for a cluster snapshot.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   SnapshotIdentifier: JString (required)
  ##                     : The identifier of the snapshot whose setting you want to modify.
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely.</p> <p>If the manual snapshot falls outside of the new retention period, you can specify the force option to immediately delete the snapshot.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  ##   Force: JBool
  ##        : A Boolean option to override an exception if the retention period has already passed.
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `SnapshotIdentifier` field"
  var valid_613989 = query.getOrDefault("SnapshotIdentifier")
  valid_613989 = validateParameter(valid_613989, JString, required = true,
                                 default = nil)
  if valid_613989 != nil:
    section.add "SnapshotIdentifier", valid_613989
  var valid_613990 = query.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_613990 = validateParameter(valid_613990, JInt, required = false, default = nil)
  if valid_613990 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_613990
  var valid_613991 = query.getOrDefault("Force")
  valid_613991 = validateParameter(valid_613991, JBool, required = false, default = nil)
  if valid_613991 != nil:
    section.add "Force", valid_613991
  var valid_613992 = query.getOrDefault("Action")
  valid_613992 = validateParameter(valid_613992, JString, required = true,
                                 default = newJString("ModifyClusterSnapshot"))
  if valid_613992 != nil:
    section.add "Action", valid_613992
  var valid_613993 = query.getOrDefault("Version")
  valid_613993 = validateParameter(valid_613993, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_613993 != nil:
    section.add "Version", valid_613993
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613994 = header.getOrDefault("X-Amz-Signature")
  valid_613994 = validateParameter(valid_613994, JString, required = false,
                                 default = nil)
  if valid_613994 != nil:
    section.add "X-Amz-Signature", valid_613994
  var valid_613995 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613995 = validateParameter(valid_613995, JString, required = false,
                                 default = nil)
  if valid_613995 != nil:
    section.add "X-Amz-Content-Sha256", valid_613995
  var valid_613996 = header.getOrDefault("X-Amz-Date")
  valid_613996 = validateParameter(valid_613996, JString, required = false,
                                 default = nil)
  if valid_613996 != nil:
    section.add "X-Amz-Date", valid_613996
  var valid_613997 = header.getOrDefault("X-Amz-Credential")
  valid_613997 = validateParameter(valid_613997, JString, required = false,
                                 default = nil)
  if valid_613997 != nil:
    section.add "X-Amz-Credential", valid_613997
  var valid_613998 = header.getOrDefault("X-Amz-Security-Token")
  valid_613998 = validateParameter(valid_613998, JString, required = false,
                                 default = nil)
  if valid_613998 != nil:
    section.add "X-Amz-Security-Token", valid_613998
  var valid_613999 = header.getOrDefault("X-Amz-Algorithm")
  valid_613999 = validateParameter(valid_613999, JString, required = false,
                                 default = nil)
  if valid_613999 != nil:
    section.add "X-Amz-Algorithm", valid_613999
  var valid_614000 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614000 = validateParameter(valid_614000, JString, required = false,
                                 default = nil)
  if valid_614000 != nil:
    section.add "X-Amz-SignedHeaders", valid_614000
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614001: Call_GetModifyClusterSnapshot_613986; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Modifies the settings for a snapshot.</p> <p>This exanmple modifies the manual retention period setting for a cluster snapshot.</p>
  ## 
  let valid = call_614001.validator(path, query, header, formData, body)
  let scheme = call_614001.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614001.url(scheme.get, call_614001.host, call_614001.base,
                         call_614001.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614001, url, valid)

proc call*(call_614002: Call_GetModifyClusterSnapshot_613986;
          SnapshotIdentifier: string; ManualSnapshotRetentionPeriod: int = 0;
          Force: bool = false; Action: string = "ModifyClusterSnapshot";
          Version: string = "2012-12-01"): Recallable =
  ## getModifyClusterSnapshot
  ## <p>Modifies the settings for a snapshot.</p> <p>This exanmple modifies the manual retention period setting for a cluster snapshot.</p>
  ##   SnapshotIdentifier: string (required)
  ##                     : The identifier of the snapshot whose setting you want to modify.
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely.</p> <p>If the manual snapshot falls outside of the new retention period, you can specify the force option to immediately delete the snapshot.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  ##   Force: bool
  ##        : A Boolean option to override an exception if the retention period has already passed.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_614003 = newJObject()
  add(query_614003, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_614003, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  add(query_614003, "Force", newJBool(Force))
  add(query_614003, "Action", newJString(Action))
  add(query_614003, "Version", newJString(Version))
  result = call_614002.call(nil, query_614003, nil, nil, nil)

var getModifyClusterSnapshot* = Call_GetModifyClusterSnapshot_613986(
    name: "getModifyClusterSnapshot", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyClusterSnapshot",
    validator: validate_GetModifyClusterSnapshot_613987, base: "/",
    url: url_GetModifyClusterSnapshot_613988, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostModifyClusterSnapshotSchedule_614041 = ref object of OpenApiRestCall_610642
proc url_PostModifyClusterSnapshotSchedule_614043(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostModifyClusterSnapshotSchedule_614042(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies a snapshot schedule for a cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_614044 = query.getOrDefault("Action")
  valid_614044 = validateParameter(valid_614044, JString, required = true, default = newJString(
      "ModifyClusterSnapshotSchedule"))
  if valid_614044 != nil:
    section.add "Action", valid_614044
  var valid_614045 = query.getOrDefault("Version")
  valid_614045 = validateParameter(valid_614045, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_614045 != nil:
    section.add "Version", valid_614045
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614046 = header.getOrDefault("X-Amz-Signature")
  valid_614046 = validateParameter(valid_614046, JString, required = false,
                                 default = nil)
  if valid_614046 != nil:
    section.add "X-Amz-Signature", valid_614046
  var valid_614047 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614047 = validateParameter(valid_614047, JString, required = false,
                                 default = nil)
  if valid_614047 != nil:
    section.add "X-Amz-Content-Sha256", valid_614047
  var valid_614048 = header.getOrDefault("X-Amz-Date")
  valid_614048 = validateParameter(valid_614048, JString, required = false,
                                 default = nil)
  if valid_614048 != nil:
    section.add "X-Amz-Date", valid_614048
  var valid_614049 = header.getOrDefault("X-Amz-Credential")
  valid_614049 = validateParameter(valid_614049, JString, required = false,
                                 default = nil)
  if valid_614049 != nil:
    section.add "X-Amz-Credential", valid_614049
  var valid_614050 = header.getOrDefault("X-Amz-Security-Token")
  valid_614050 = validateParameter(valid_614050, JString, required = false,
                                 default = nil)
  if valid_614050 != nil:
    section.add "X-Amz-Security-Token", valid_614050
  var valid_614051 = header.getOrDefault("X-Amz-Algorithm")
  valid_614051 = validateParameter(valid_614051, JString, required = false,
                                 default = nil)
  if valid_614051 != nil:
    section.add "X-Amz-Algorithm", valid_614051
  var valid_614052 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614052 = validateParameter(valid_614052, JString, required = false,
                                 default = nil)
  if valid_614052 != nil:
    section.add "X-Amz-SignedHeaders", valid_614052
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : A unique identifier for the cluster whose snapshot schedule you want to modify. 
  ##   ScheduleIdentifier: JString
  ##                     : A unique alphanumeric identifier for the schedule that you want to associate with the cluster.
  ##   DisassociateSchedule: JBool
  ##                       : A boolean to indicate whether to remove the assoiciation between the cluster and the schedule.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_614053 = formData.getOrDefault("ClusterIdentifier")
  valid_614053 = validateParameter(valid_614053, JString, required = true,
                                 default = nil)
  if valid_614053 != nil:
    section.add "ClusterIdentifier", valid_614053
  var valid_614054 = formData.getOrDefault("ScheduleIdentifier")
  valid_614054 = validateParameter(valid_614054, JString, required = false,
                                 default = nil)
  if valid_614054 != nil:
    section.add "ScheduleIdentifier", valid_614054
  var valid_614055 = formData.getOrDefault("DisassociateSchedule")
  valid_614055 = validateParameter(valid_614055, JBool, required = false, default = nil)
  if valid_614055 != nil:
    section.add "DisassociateSchedule", valid_614055
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614056: Call_PostModifyClusterSnapshotSchedule_614041;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Modifies a snapshot schedule for a cluster.
  ## 
  let valid = call_614056.validator(path, query, header, formData, body)
  let scheme = call_614056.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614056.url(scheme.get, call_614056.host, call_614056.base,
                         call_614056.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614056, url, valid)

proc call*(call_614057: Call_PostModifyClusterSnapshotSchedule_614041;
          ClusterIdentifier: string;
          Action: string = "ModifyClusterSnapshotSchedule";
          ScheduleIdentifier: string = ""; DisassociateSchedule: bool = false;
          Version: string = "2012-12-01"): Recallable =
  ## postModifyClusterSnapshotSchedule
  ## Modifies a snapshot schedule for a cluster.
  ##   ClusterIdentifier: string (required)
  ##                    : A unique identifier for the cluster whose snapshot schedule you want to modify. 
  ##   Action: string (required)
  ##   ScheduleIdentifier: string
  ##                     : A unique alphanumeric identifier for the schedule that you want to associate with the cluster.
  ##   DisassociateSchedule: bool
  ##                       : A boolean to indicate whether to remove the assoiciation between the cluster and the schedule.
  ##   Version: string (required)
  var query_614058 = newJObject()
  var formData_614059 = newJObject()
  add(formData_614059, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_614058, "Action", newJString(Action))
  add(formData_614059, "ScheduleIdentifier", newJString(ScheduleIdentifier))
  add(formData_614059, "DisassociateSchedule", newJBool(DisassociateSchedule))
  add(query_614058, "Version", newJString(Version))
  result = call_614057.call(nil, query_614058, nil, formData_614059, nil)

var postModifyClusterSnapshotSchedule* = Call_PostModifyClusterSnapshotSchedule_614041(
    name: "postModifyClusterSnapshotSchedule", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=ModifyClusterSnapshotSchedule",
    validator: validate_PostModifyClusterSnapshotSchedule_614042, base: "/",
    url: url_PostModifyClusterSnapshotSchedule_614043,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetModifyClusterSnapshotSchedule_614023 = ref object of OpenApiRestCall_610642
proc url_GetModifyClusterSnapshotSchedule_614025(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetModifyClusterSnapshotSchedule_614024(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies a snapshot schedule for a cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ScheduleIdentifier: JString
  ##                     : A unique alphanumeric identifier for the schedule that you want to associate with the cluster.
  ##   Action: JString (required)
  ##   DisassociateSchedule: JBool
  ##                       : A boolean to indicate whether to remove the assoiciation between the cluster and the schedule.
  ##   ClusterIdentifier: JString (required)
  ##                    : A unique identifier for the cluster whose snapshot schedule you want to modify. 
  ##   Version: JString (required)
  section = newJObject()
  var valid_614026 = query.getOrDefault("ScheduleIdentifier")
  valid_614026 = validateParameter(valid_614026, JString, required = false,
                                 default = nil)
  if valid_614026 != nil:
    section.add "ScheduleIdentifier", valid_614026
  var valid_614027 = query.getOrDefault("Action")
  valid_614027 = validateParameter(valid_614027, JString, required = true, default = newJString(
      "ModifyClusterSnapshotSchedule"))
  if valid_614027 != nil:
    section.add "Action", valid_614027
  var valid_614028 = query.getOrDefault("DisassociateSchedule")
  valid_614028 = validateParameter(valid_614028, JBool, required = false, default = nil)
  if valid_614028 != nil:
    section.add "DisassociateSchedule", valid_614028
  var valid_614029 = query.getOrDefault("ClusterIdentifier")
  valid_614029 = validateParameter(valid_614029, JString, required = true,
                                 default = nil)
  if valid_614029 != nil:
    section.add "ClusterIdentifier", valid_614029
  var valid_614030 = query.getOrDefault("Version")
  valid_614030 = validateParameter(valid_614030, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_614030 != nil:
    section.add "Version", valid_614030
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614031 = header.getOrDefault("X-Amz-Signature")
  valid_614031 = validateParameter(valid_614031, JString, required = false,
                                 default = nil)
  if valid_614031 != nil:
    section.add "X-Amz-Signature", valid_614031
  var valid_614032 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614032 = validateParameter(valid_614032, JString, required = false,
                                 default = nil)
  if valid_614032 != nil:
    section.add "X-Amz-Content-Sha256", valid_614032
  var valid_614033 = header.getOrDefault("X-Amz-Date")
  valid_614033 = validateParameter(valid_614033, JString, required = false,
                                 default = nil)
  if valid_614033 != nil:
    section.add "X-Amz-Date", valid_614033
  var valid_614034 = header.getOrDefault("X-Amz-Credential")
  valid_614034 = validateParameter(valid_614034, JString, required = false,
                                 default = nil)
  if valid_614034 != nil:
    section.add "X-Amz-Credential", valid_614034
  var valid_614035 = header.getOrDefault("X-Amz-Security-Token")
  valid_614035 = validateParameter(valid_614035, JString, required = false,
                                 default = nil)
  if valid_614035 != nil:
    section.add "X-Amz-Security-Token", valid_614035
  var valid_614036 = header.getOrDefault("X-Amz-Algorithm")
  valid_614036 = validateParameter(valid_614036, JString, required = false,
                                 default = nil)
  if valid_614036 != nil:
    section.add "X-Amz-Algorithm", valid_614036
  var valid_614037 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614037 = validateParameter(valid_614037, JString, required = false,
                                 default = nil)
  if valid_614037 != nil:
    section.add "X-Amz-SignedHeaders", valid_614037
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614038: Call_GetModifyClusterSnapshotSchedule_614023;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Modifies a snapshot schedule for a cluster.
  ## 
  let valid = call_614038.validator(path, query, header, formData, body)
  let scheme = call_614038.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614038.url(scheme.get, call_614038.host, call_614038.base,
                         call_614038.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614038, url, valid)

proc call*(call_614039: Call_GetModifyClusterSnapshotSchedule_614023;
          ClusterIdentifier: string; ScheduleIdentifier: string = "";
          Action: string = "ModifyClusterSnapshotSchedule";
          DisassociateSchedule: bool = false; Version: string = "2012-12-01"): Recallable =
  ## getModifyClusterSnapshotSchedule
  ## Modifies a snapshot schedule for a cluster.
  ##   ScheduleIdentifier: string
  ##                     : A unique alphanumeric identifier for the schedule that you want to associate with the cluster.
  ##   Action: string (required)
  ##   DisassociateSchedule: bool
  ##                       : A boolean to indicate whether to remove the assoiciation between the cluster and the schedule.
  ##   ClusterIdentifier: string (required)
  ##                    : A unique identifier for the cluster whose snapshot schedule you want to modify. 
  ##   Version: string (required)
  var query_614040 = newJObject()
  add(query_614040, "ScheduleIdentifier", newJString(ScheduleIdentifier))
  add(query_614040, "Action", newJString(Action))
  add(query_614040, "DisassociateSchedule", newJBool(DisassociateSchedule))
  add(query_614040, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_614040, "Version", newJString(Version))
  result = call_614039.call(nil, query_614040, nil, nil, nil)

var getModifyClusterSnapshotSchedule* = Call_GetModifyClusterSnapshotSchedule_614023(
    name: "getModifyClusterSnapshotSchedule", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=ModifyClusterSnapshotSchedule",
    validator: validate_GetModifyClusterSnapshotSchedule_614024, base: "/",
    url: url_GetModifyClusterSnapshotSchedule_614025,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostModifyClusterSubnetGroup_614078 = ref object of OpenApiRestCall_610642
proc url_PostModifyClusterSubnetGroup_614080(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostModifyClusterSubnetGroup_614079(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies a cluster subnet group to include the specified list of VPC subnets. The operation replaces the existing list of subnets with the new list of subnets.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_614081 = query.getOrDefault("Action")
  valid_614081 = validateParameter(valid_614081, JString, required = true, default = newJString(
      "ModifyClusterSubnetGroup"))
  if valid_614081 != nil:
    section.add "Action", valid_614081
  var valid_614082 = query.getOrDefault("Version")
  valid_614082 = validateParameter(valid_614082, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_614082 != nil:
    section.add "Version", valid_614082
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614083 = header.getOrDefault("X-Amz-Signature")
  valid_614083 = validateParameter(valid_614083, JString, required = false,
                                 default = nil)
  if valid_614083 != nil:
    section.add "X-Amz-Signature", valid_614083
  var valid_614084 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614084 = validateParameter(valid_614084, JString, required = false,
                                 default = nil)
  if valid_614084 != nil:
    section.add "X-Amz-Content-Sha256", valid_614084
  var valid_614085 = header.getOrDefault("X-Amz-Date")
  valid_614085 = validateParameter(valid_614085, JString, required = false,
                                 default = nil)
  if valid_614085 != nil:
    section.add "X-Amz-Date", valid_614085
  var valid_614086 = header.getOrDefault("X-Amz-Credential")
  valid_614086 = validateParameter(valid_614086, JString, required = false,
                                 default = nil)
  if valid_614086 != nil:
    section.add "X-Amz-Credential", valid_614086
  var valid_614087 = header.getOrDefault("X-Amz-Security-Token")
  valid_614087 = validateParameter(valid_614087, JString, required = false,
                                 default = nil)
  if valid_614087 != nil:
    section.add "X-Amz-Security-Token", valid_614087
  var valid_614088 = header.getOrDefault("X-Amz-Algorithm")
  valid_614088 = validateParameter(valid_614088, JString, required = false,
                                 default = nil)
  if valid_614088 != nil:
    section.add "X-Amz-Algorithm", valid_614088
  var valid_614089 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614089 = validateParameter(valid_614089, JString, required = false,
                                 default = nil)
  if valid_614089 != nil:
    section.add "X-Amz-SignedHeaders", valid_614089
  result.add "header", section
  ## parameters in `formData` object:
  ##   Description: JString
  ##              : A text description of the subnet group to be modified.
  ##   ClusterSubnetGroupName: JString (required)
  ##                         : The name of the subnet group to be modified.
  ##   SubnetIds: JArray (required)
  ##            : An array of VPC subnet IDs. A maximum of 20 subnets can be modified in a single request.
  section = newJObject()
  var valid_614090 = formData.getOrDefault("Description")
  valid_614090 = validateParameter(valid_614090, JString, required = false,
                                 default = nil)
  if valid_614090 != nil:
    section.add "Description", valid_614090
  assert formData != nil, "formData argument is necessary due to required `ClusterSubnetGroupName` field"
  var valid_614091 = formData.getOrDefault("ClusterSubnetGroupName")
  valid_614091 = validateParameter(valid_614091, JString, required = true,
                                 default = nil)
  if valid_614091 != nil:
    section.add "ClusterSubnetGroupName", valid_614091
  var valid_614092 = formData.getOrDefault("SubnetIds")
  valid_614092 = validateParameter(valid_614092, JArray, required = true, default = nil)
  if valid_614092 != nil:
    section.add "SubnetIds", valid_614092
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614093: Call_PostModifyClusterSubnetGroup_614078; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Modifies a cluster subnet group to include the specified list of VPC subnets. The operation replaces the existing list of subnets with the new list of subnets.
  ## 
  let valid = call_614093.validator(path, query, header, formData, body)
  let scheme = call_614093.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614093.url(scheme.get, call_614093.host, call_614093.base,
                         call_614093.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614093, url, valid)

proc call*(call_614094: Call_PostModifyClusterSubnetGroup_614078;
          ClusterSubnetGroupName: string; SubnetIds: JsonNode;
          Description: string = ""; Action: string = "ModifyClusterSubnetGroup";
          Version: string = "2012-12-01"): Recallable =
  ## postModifyClusterSubnetGroup
  ## Modifies a cluster subnet group to include the specified list of VPC subnets. The operation replaces the existing list of subnets with the new list of subnets.
  ##   Description: string
  ##              : A text description of the subnet group to be modified.
  ##   ClusterSubnetGroupName: string (required)
  ##                         : The name of the subnet group to be modified.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   SubnetIds: JArray (required)
  ##            : An array of VPC subnet IDs. A maximum of 20 subnets can be modified in a single request.
  var query_614095 = newJObject()
  var formData_614096 = newJObject()
  add(formData_614096, "Description", newJString(Description))
  add(formData_614096, "ClusterSubnetGroupName",
      newJString(ClusterSubnetGroupName))
  add(query_614095, "Action", newJString(Action))
  add(query_614095, "Version", newJString(Version))
  if SubnetIds != nil:
    formData_614096.add "SubnetIds", SubnetIds
  result = call_614094.call(nil, query_614095, nil, formData_614096, nil)

var postModifyClusterSubnetGroup* = Call_PostModifyClusterSubnetGroup_614078(
    name: "postModifyClusterSubnetGroup", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyClusterSubnetGroup",
    validator: validate_PostModifyClusterSubnetGroup_614079, base: "/",
    url: url_PostModifyClusterSubnetGroup_614080,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetModifyClusterSubnetGroup_614060 = ref object of OpenApiRestCall_610642
proc url_GetModifyClusterSubnetGroup_614062(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetModifyClusterSubnetGroup_614061(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies a cluster subnet group to include the specified list of VPC subnets. The operation replaces the existing list of subnets with the new list of subnets.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ClusterSubnetGroupName: JString (required)
  ##                         : The name of the subnet group to be modified.
  ##   SubnetIds: JArray (required)
  ##            : An array of VPC subnet IDs. A maximum of 20 subnets can be modified in a single request.
  ##   Action: JString (required)
  ##   Description: JString
  ##              : A text description of the subnet group to be modified.
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `ClusterSubnetGroupName` field"
  var valid_614063 = query.getOrDefault("ClusterSubnetGroupName")
  valid_614063 = validateParameter(valid_614063, JString, required = true,
                                 default = nil)
  if valid_614063 != nil:
    section.add "ClusterSubnetGroupName", valid_614063
  var valid_614064 = query.getOrDefault("SubnetIds")
  valid_614064 = validateParameter(valid_614064, JArray, required = true, default = nil)
  if valid_614064 != nil:
    section.add "SubnetIds", valid_614064
  var valid_614065 = query.getOrDefault("Action")
  valid_614065 = validateParameter(valid_614065, JString, required = true, default = newJString(
      "ModifyClusterSubnetGroup"))
  if valid_614065 != nil:
    section.add "Action", valid_614065
  var valid_614066 = query.getOrDefault("Description")
  valid_614066 = validateParameter(valid_614066, JString, required = false,
                                 default = nil)
  if valid_614066 != nil:
    section.add "Description", valid_614066
  var valid_614067 = query.getOrDefault("Version")
  valid_614067 = validateParameter(valid_614067, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_614067 != nil:
    section.add "Version", valid_614067
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614068 = header.getOrDefault("X-Amz-Signature")
  valid_614068 = validateParameter(valid_614068, JString, required = false,
                                 default = nil)
  if valid_614068 != nil:
    section.add "X-Amz-Signature", valid_614068
  var valid_614069 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614069 = validateParameter(valid_614069, JString, required = false,
                                 default = nil)
  if valid_614069 != nil:
    section.add "X-Amz-Content-Sha256", valid_614069
  var valid_614070 = header.getOrDefault("X-Amz-Date")
  valid_614070 = validateParameter(valid_614070, JString, required = false,
                                 default = nil)
  if valid_614070 != nil:
    section.add "X-Amz-Date", valid_614070
  var valid_614071 = header.getOrDefault("X-Amz-Credential")
  valid_614071 = validateParameter(valid_614071, JString, required = false,
                                 default = nil)
  if valid_614071 != nil:
    section.add "X-Amz-Credential", valid_614071
  var valid_614072 = header.getOrDefault("X-Amz-Security-Token")
  valid_614072 = validateParameter(valid_614072, JString, required = false,
                                 default = nil)
  if valid_614072 != nil:
    section.add "X-Amz-Security-Token", valid_614072
  var valid_614073 = header.getOrDefault("X-Amz-Algorithm")
  valid_614073 = validateParameter(valid_614073, JString, required = false,
                                 default = nil)
  if valid_614073 != nil:
    section.add "X-Amz-Algorithm", valid_614073
  var valid_614074 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614074 = validateParameter(valid_614074, JString, required = false,
                                 default = nil)
  if valid_614074 != nil:
    section.add "X-Amz-SignedHeaders", valid_614074
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614075: Call_GetModifyClusterSubnetGroup_614060; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Modifies a cluster subnet group to include the specified list of VPC subnets. The operation replaces the existing list of subnets with the new list of subnets.
  ## 
  let valid = call_614075.validator(path, query, header, formData, body)
  let scheme = call_614075.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614075.url(scheme.get, call_614075.host, call_614075.base,
                         call_614075.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614075, url, valid)

proc call*(call_614076: Call_GetModifyClusterSubnetGroup_614060;
          ClusterSubnetGroupName: string; SubnetIds: JsonNode;
          Action: string = "ModifyClusterSubnetGroup"; Description: string = "";
          Version: string = "2012-12-01"): Recallable =
  ## getModifyClusterSubnetGroup
  ## Modifies a cluster subnet group to include the specified list of VPC subnets. The operation replaces the existing list of subnets with the new list of subnets.
  ##   ClusterSubnetGroupName: string (required)
  ##                         : The name of the subnet group to be modified.
  ##   SubnetIds: JArray (required)
  ##            : An array of VPC subnet IDs. A maximum of 20 subnets can be modified in a single request.
  ##   Action: string (required)
  ##   Description: string
  ##              : A text description of the subnet group to be modified.
  ##   Version: string (required)
  var query_614077 = newJObject()
  add(query_614077, "ClusterSubnetGroupName", newJString(ClusterSubnetGroupName))
  if SubnetIds != nil:
    query_614077.add "SubnetIds", SubnetIds
  add(query_614077, "Action", newJString(Action))
  add(query_614077, "Description", newJString(Description))
  add(query_614077, "Version", newJString(Version))
  result = call_614076.call(nil, query_614077, nil, nil, nil)

var getModifyClusterSubnetGroup* = Call_GetModifyClusterSubnetGroup_614060(
    name: "getModifyClusterSubnetGroup", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyClusterSubnetGroup",
    validator: validate_GetModifyClusterSubnetGroup_614061, base: "/",
    url: url_GetModifyClusterSubnetGroup_614062,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostModifyEventSubscription_614119 = ref object of OpenApiRestCall_610642
proc url_PostModifyEventSubscription_614121(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostModifyEventSubscription_614120(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies an existing Amazon Redshift event notification subscription.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_614122 = query.getOrDefault("Action")
  valid_614122 = validateParameter(valid_614122, JString, required = true, default = newJString(
      "ModifyEventSubscription"))
  if valid_614122 != nil:
    section.add "Action", valid_614122
  var valid_614123 = query.getOrDefault("Version")
  valid_614123 = validateParameter(valid_614123, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_614123 != nil:
    section.add "Version", valid_614123
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614124 = header.getOrDefault("X-Amz-Signature")
  valid_614124 = validateParameter(valid_614124, JString, required = false,
                                 default = nil)
  if valid_614124 != nil:
    section.add "X-Amz-Signature", valid_614124
  var valid_614125 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614125 = validateParameter(valid_614125, JString, required = false,
                                 default = nil)
  if valid_614125 != nil:
    section.add "X-Amz-Content-Sha256", valid_614125
  var valid_614126 = header.getOrDefault("X-Amz-Date")
  valid_614126 = validateParameter(valid_614126, JString, required = false,
                                 default = nil)
  if valid_614126 != nil:
    section.add "X-Amz-Date", valid_614126
  var valid_614127 = header.getOrDefault("X-Amz-Credential")
  valid_614127 = validateParameter(valid_614127, JString, required = false,
                                 default = nil)
  if valid_614127 != nil:
    section.add "X-Amz-Credential", valid_614127
  var valid_614128 = header.getOrDefault("X-Amz-Security-Token")
  valid_614128 = validateParameter(valid_614128, JString, required = false,
                                 default = nil)
  if valid_614128 != nil:
    section.add "X-Amz-Security-Token", valid_614128
  var valid_614129 = header.getOrDefault("X-Amz-Algorithm")
  valid_614129 = validateParameter(valid_614129, JString, required = false,
                                 default = nil)
  if valid_614129 != nil:
    section.add "X-Amz-Algorithm", valid_614129
  var valid_614130 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614130 = validateParameter(valid_614130, JString, required = false,
                                 default = nil)
  if valid_614130 != nil:
    section.add "X-Amz-SignedHeaders", valid_614130
  result.add "header", section
  ## parameters in `formData` object:
  ##   SourceIds: JArray
  ##            : <p>A list of one or more identifiers of Amazon Redshift source objects. All of the objects must be of the same type as was specified in the source type parameter. The event subscription will return only events generated by the specified objects. If not specified, then events are returned for all objects within the source type specified.</p> <p>Example: my-cluster-1, my-cluster-2</p> <p>Example: my-snapshot-20131010</p>
  ##   SnsTopicArn: JString
  ##              : The Amazon Resource Name (ARN) of the SNS topic to be used by the event notification subscription.
  ##   Enabled: JBool
  ##          : A Boolean value indicating if the subscription is enabled. <code>true</code> indicates the subscription is enabled 
  ##   SubscriptionName: JString (required)
  ##                   : The name of the modified Amazon Redshift event notification subscription.
  ##   SourceType: JString
  ##             : <p>The type of source that will be generating the events. For example, if you want to be notified of events generated by a cluster, you would set this parameter to cluster. If this value is not specified, events are returned for all Amazon Redshift objects in your AWS account. You must specify a source type in order to specify source IDs.</p> <p>Valid values: cluster, cluster-parameter-group, cluster-security-group, cluster-snapshot, and scheduled-action.</p>
  ##   Severity: JString
  ##           : <p>Specifies the Amazon Redshift event severity to be published by the event notification subscription.</p> <p>Values: ERROR, INFO</p>
  ##   EventCategories: JArray
  ##                  : <p>Specifies the Amazon Redshift event categories to be published by the event notification subscription.</p> <p>Values: configuration, management, monitoring, security</p>
  section = newJObject()
  var valid_614131 = formData.getOrDefault("SourceIds")
  valid_614131 = validateParameter(valid_614131, JArray, required = false,
                                 default = nil)
  if valid_614131 != nil:
    section.add "SourceIds", valid_614131
  var valid_614132 = formData.getOrDefault("SnsTopicArn")
  valid_614132 = validateParameter(valid_614132, JString, required = false,
                                 default = nil)
  if valid_614132 != nil:
    section.add "SnsTopicArn", valid_614132
  var valid_614133 = formData.getOrDefault("Enabled")
  valid_614133 = validateParameter(valid_614133, JBool, required = false, default = nil)
  if valid_614133 != nil:
    section.add "Enabled", valid_614133
  assert formData != nil, "formData argument is necessary due to required `SubscriptionName` field"
  var valid_614134 = formData.getOrDefault("SubscriptionName")
  valid_614134 = validateParameter(valid_614134, JString, required = true,
                                 default = nil)
  if valid_614134 != nil:
    section.add "SubscriptionName", valid_614134
  var valid_614135 = formData.getOrDefault("SourceType")
  valid_614135 = validateParameter(valid_614135, JString, required = false,
                                 default = nil)
  if valid_614135 != nil:
    section.add "SourceType", valid_614135
  var valid_614136 = formData.getOrDefault("Severity")
  valid_614136 = validateParameter(valid_614136, JString, required = false,
                                 default = nil)
  if valid_614136 != nil:
    section.add "Severity", valid_614136
  var valid_614137 = formData.getOrDefault("EventCategories")
  valid_614137 = validateParameter(valid_614137, JArray, required = false,
                                 default = nil)
  if valid_614137 != nil:
    section.add "EventCategories", valid_614137
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614138: Call_PostModifyEventSubscription_614119; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Modifies an existing Amazon Redshift event notification subscription.
  ## 
  let valid = call_614138.validator(path, query, header, formData, body)
  let scheme = call_614138.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614138.url(scheme.get, call_614138.host, call_614138.base,
                         call_614138.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614138, url, valid)

proc call*(call_614139: Call_PostModifyEventSubscription_614119;
          SubscriptionName: string; SourceIds: JsonNode = nil;
          SnsTopicArn: string = ""; Enabled: bool = false; SourceType: string = "";
          Severity: string = ""; EventCategories: JsonNode = nil;
          Action: string = "ModifyEventSubscription"; Version: string = "2012-12-01"): Recallable =
  ## postModifyEventSubscription
  ## Modifies an existing Amazon Redshift event notification subscription.
  ##   SourceIds: JArray
  ##            : <p>A list of one or more identifiers of Amazon Redshift source objects. All of the objects must be of the same type as was specified in the source type parameter. The event subscription will return only events generated by the specified objects. If not specified, then events are returned for all objects within the source type specified.</p> <p>Example: my-cluster-1, my-cluster-2</p> <p>Example: my-snapshot-20131010</p>
  ##   SnsTopicArn: string
  ##              : The Amazon Resource Name (ARN) of the SNS topic to be used by the event notification subscription.
  ##   Enabled: bool
  ##          : A Boolean value indicating if the subscription is enabled. <code>true</code> indicates the subscription is enabled 
  ##   SubscriptionName: string (required)
  ##                   : The name of the modified Amazon Redshift event notification subscription.
  ##   SourceType: string
  ##             : <p>The type of source that will be generating the events. For example, if you want to be notified of events generated by a cluster, you would set this parameter to cluster. If this value is not specified, events are returned for all Amazon Redshift objects in your AWS account. You must specify a source type in order to specify source IDs.</p> <p>Valid values: cluster, cluster-parameter-group, cluster-security-group, cluster-snapshot, and scheduled-action.</p>
  ##   Severity: string
  ##           : <p>Specifies the Amazon Redshift event severity to be published by the event notification subscription.</p> <p>Values: ERROR, INFO</p>
  ##   EventCategories: JArray
  ##                  : <p>Specifies the Amazon Redshift event categories to be published by the event notification subscription.</p> <p>Values: configuration, management, monitoring, security</p>
  ##   Action: string (required)
  ##   Version: string (required)
  var query_614140 = newJObject()
  var formData_614141 = newJObject()
  if SourceIds != nil:
    formData_614141.add "SourceIds", SourceIds
  add(formData_614141, "SnsTopicArn", newJString(SnsTopicArn))
  add(formData_614141, "Enabled", newJBool(Enabled))
  add(formData_614141, "SubscriptionName", newJString(SubscriptionName))
  add(formData_614141, "SourceType", newJString(SourceType))
  add(formData_614141, "Severity", newJString(Severity))
  if EventCategories != nil:
    formData_614141.add "EventCategories", EventCategories
  add(query_614140, "Action", newJString(Action))
  add(query_614140, "Version", newJString(Version))
  result = call_614139.call(nil, query_614140, nil, formData_614141, nil)

var postModifyEventSubscription* = Call_PostModifyEventSubscription_614119(
    name: "postModifyEventSubscription", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyEventSubscription",
    validator: validate_PostModifyEventSubscription_614120, base: "/",
    url: url_PostModifyEventSubscription_614121,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetModifyEventSubscription_614097 = ref object of OpenApiRestCall_610642
proc url_GetModifyEventSubscription_614099(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetModifyEventSubscription_614098(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies an existing Amazon Redshift event notification subscription.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   SourceType: JString
  ##             : <p>The type of source that will be generating the events. For example, if you want to be notified of events generated by a cluster, you would set this parameter to cluster. If this value is not specified, events are returned for all Amazon Redshift objects in your AWS account. You must specify a source type in order to specify source IDs.</p> <p>Valid values: cluster, cluster-parameter-group, cluster-security-group, cluster-snapshot, and scheduled-action.</p>
  ##   Enabled: JBool
  ##          : A Boolean value indicating if the subscription is enabled. <code>true</code> indicates the subscription is enabled 
  ##   Severity: JString
  ##           : <p>Specifies the Amazon Redshift event severity to be published by the event notification subscription.</p> <p>Values: ERROR, INFO</p>
  ##   SubscriptionName: JString (required)
  ##                   : The name of the modified Amazon Redshift event notification subscription.
  ##   EventCategories: JArray
  ##                  : <p>Specifies the Amazon Redshift event categories to be published by the event notification subscription.</p> <p>Values: configuration, management, monitoring, security</p>
  ##   SourceIds: JArray
  ##            : <p>A list of one or more identifiers of Amazon Redshift source objects. All of the objects must be of the same type as was specified in the source type parameter. The event subscription will return only events generated by the specified objects. If not specified, then events are returned for all objects within the source type specified.</p> <p>Example: my-cluster-1, my-cluster-2</p> <p>Example: my-snapshot-20131010</p>
  ##   Action: JString (required)
  ##   SnsTopicArn: JString
  ##              : The Amazon Resource Name (ARN) of the SNS topic to be used by the event notification subscription.
  ##   Version: JString (required)
  section = newJObject()
  var valid_614100 = query.getOrDefault("SourceType")
  valid_614100 = validateParameter(valid_614100, JString, required = false,
                                 default = nil)
  if valid_614100 != nil:
    section.add "SourceType", valid_614100
  var valid_614101 = query.getOrDefault("Enabled")
  valid_614101 = validateParameter(valid_614101, JBool, required = false, default = nil)
  if valid_614101 != nil:
    section.add "Enabled", valid_614101
  var valid_614102 = query.getOrDefault("Severity")
  valid_614102 = validateParameter(valid_614102, JString, required = false,
                                 default = nil)
  if valid_614102 != nil:
    section.add "Severity", valid_614102
  assert query != nil,
        "query argument is necessary due to required `SubscriptionName` field"
  var valid_614103 = query.getOrDefault("SubscriptionName")
  valid_614103 = validateParameter(valid_614103, JString, required = true,
                                 default = nil)
  if valid_614103 != nil:
    section.add "SubscriptionName", valid_614103
  var valid_614104 = query.getOrDefault("EventCategories")
  valid_614104 = validateParameter(valid_614104, JArray, required = false,
                                 default = nil)
  if valid_614104 != nil:
    section.add "EventCategories", valid_614104
  var valid_614105 = query.getOrDefault("SourceIds")
  valid_614105 = validateParameter(valid_614105, JArray, required = false,
                                 default = nil)
  if valid_614105 != nil:
    section.add "SourceIds", valid_614105
  var valid_614106 = query.getOrDefault("Action")
  valid_614106 = validateParameter(valid_614106, JString, required = true, default = newJString(
      "ModifyEventSubscription"))
  if valid_614106 != nil:
    section.add "Action", valid_614106
  var valid_614107 = query.getOrDefault("SnsTopicArn")
  valid_614107 = validateParameter(valid_614107, JString, required = false,
                                 default = nil)
  if valid_614107 != nil:
    section.add "SnsTopicArn", valid_614107
  var valid_614108 = query.getOrDefault("Version")
  valid_614108 = validateParameter(valid_614108, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_614108 != nil:
    section.add "Version", valid_614108
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614109 = header.getOrDefault("X-Amz-Signature")
  valid_614109 = validateParameter(valid_614109, JString, required = false,
                                 default = nil)
  if valid_614109 != nil:
    section.add "X-Amz-Signature", valid_614109
  var valid_614110 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614110 = validateParameter(valid_614110, JString, required = false,
                                 default = nil)
  if valid_614110 != nil:
    section.add "X-Amz-Content-Sha256", valid_614110
  var valid_614111 = header.getOrDefault("X-Amz-Date")
  valid_614111 = validateParameter(valid_614111, JString, required = false,
                                 default = nil)
  if valid_614111 != nil:
    section.add "X-Amz-Date", valid_614111
  var valid_614112 = header.getOrDefault("X-Amz-Credential")
  valid_614112 = validateParameter(valid_614112, JString, required = false,
                                 default = nil)
  if valid_614112 != nil:
    section.add "X-Amz-Credential", valid_614112
  var valid_614113 = header.getOrDefault("X-Amz-Security-Token")
  valid_614113 = validateParameter(valid_614113, JString, required = false,
                                 default = nil)
  if valid_614113 != nil:
    section.add "X-Amz-Security-Token", valid_614113
  var valid_614114 = header.getOrDefault("X-Amz-Algorithm")
  valid_614114 = validateParameter(valid_614114, JString, required = false,
                                 default = nil)
  if valid_614114 != nil:
    section.add "X-Amz-Algorithm", valid_614114
  var valid_614115 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614115 = validateParameter(valid_614115, JString, required = false,
                                 default = nil)
  if valid_614115 != nil:
    section.add "X-Amz-SignedHeaders", valid_614115
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614116: Call_GetModifyEventSubscription_614097; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Modifies an existing Amazon Redshift event notification subscription.
  ## 
  let valid = call_614116.validator(path, query, header, formData, body)
  let scheme = call_614116.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614116.url(scheme.get, call_614116.host, call_614116.base,
                         call_614116.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614116, url, valid)

proc call*(call_614117: Call_GetModifyEventSubscription_614097;
          SubscriptionName: string; SourceType: string = ""; Enabled: bool = false;
          Severity: string = ""; EventCategories: JsonNode = nil;
          SourceIds: JsonNode = nil; Action: string = "ModifyEventSubscription";
          SnsTopicArn: string = ""; Version: string = "2012-12-01"): Recallable =
  ## getModifyEventSubscription
  ## Modifies an existing Amazon Redshift event notification subscription.
  ##   SourceType: string
  ##             : <p>The type of source that will be generating the events. For example, if you want to be notified of events generated by a cluster, you would set this parameter to cluster. If this value is not specified, events are returned for all Amazon Redshift objects in your AWS account. You must specify a source type in order to specify source IDs.</p> <p>Valid values: cluster, cluster-parameter-group, cluster-security-group, cluster-snapshot, and scheduled-action.</p>
  ##   Enabled: bool
  ##          : A Boolean value indicating if the subscription is enabled. <code>true</code> indicates the subscription is enabled 
  ##   Severity: string
  ##           : <p>Specifies the Amazon Redshift event severity to be published by the event notification subscription.</p> <p>Values: ERROR, INFO</p>
  ##   SubscriptionName: string (required)
  ##                   : The name of the modified Amazon Redshift event notification subscription.
  ##   EventCategories: JArray
  ##                  : <p>Specifies the Amazon Redshift event categories to be published by the event notification subscription.</p> <p>Values: configuration, management, monitoring, security</p>
  ##   SourceIds: JArray
  ##            : <p>A list of one or more identifiers of Amazon Redshift source objects. All of the objects must be of the same type as was specified in the source type parameter. The event subscription will return only events generated by the specified objects. If not specified, then events are returned for all objects within the source type specified.</p> <p>Example: my-cluster-1, my-cluster-2</p> <p>Example: my-snapshot-20131010</p>
  ##   Action: string (required)
  ##   SnsTopicArn: string
  ##              : The Amazon Resource Name (ARN) of the SNS topic to be used by the event notification subscription.
  ##   Version: string (required)
  var query_614118 = newJObject()
  add(query_614118, "SourceType", newJString(SourceType))
  add(query_614118, "Enabled", newJBool(Enabled))
  add(query_614118, "Severity", newJString(Severity))
  add(query_614118, "SubscriptionName", newJString(SubscriptionName))
  if EventCategories != nil:
    query_614118.add "EventCategories", EventCategories
  if SourceIds != nil:
    query_614118.add "SourceIds", SourceIds
  add(query_614118, "Action", newJString(Action))
  add(query_614118, "SnsTopicArn", newJString(SnsTopicArn))
  add(query_614118, "Version", newJString(Version))
  result = call_614117.call(nil, query_614118, nil, nil, nil)

var getModifyEventSubscription* = Call_GetModifyEventSubscription_614097(
    name: "getModifyEventSubscription", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyEventSubscription",
    validator: validate_GetModifyEventSubscription_614098, base: "/",
    url: url_GetModifyEventSubscription_614099,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostModifyScheduledAction_614165 = ref object of OpenApiRestCall_610642
proc url_PostModifyScheduledAction_614167(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostModifyScheduledAction_614166(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies a scheduled action. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_614168 = query.getOrDefault("Action")
  valid_614168 = validateParameter(valid_614168, JString, required = true,
                                 default = newJString("ModifyScheduledAction"))
  if valid_614168 != nil:
    section.add "Action", valid_614168
  var valid_614169 = query.getOrDefault("Version")
  valid_614169 = validateParameter(valid_614169, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_614169 != nil:
    section.add "Version", valid_614169
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614170 = header.getOrDefault("X-Amz-Signature")
  valid_614170 = validateParameter(valid_614170, JString, required = false,
                                 default = nil)
  if valid_614170 != nil:
    section.add "X-Amz-Signature", valid_614170
  var valid_614171 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614171 = validateParameter(valid_614171, JString, required = false,
                                 default = nil)
  if valid_614171 != nil:
    section.add "X-Amz-Content-Sha256", valid_614171
  var valid_614172 = header.getOrDefault("X-Amz-Date")
  valid_614172 = validateParameter(valid_614172, JString, required = false,
                                 default = nil)
  if valid_614172 != nil:
    section.add "X-Amz-Date", valid_614172
  var valid_614173 = header.getOrDefault("X-Amz-Credential")
  valid_614173 = validateParameter(valid_614173, JString, required = false,
                                 default = nil)
  if valid_614173 != nil:
    section.add "X-Amz-Credential", valid_614173
  var valid_614174 = header.getOrDefault("X-Amz-Security-Token")
  valid_614174 = validateParameter(valid_614174, JString, required = false,
                                 default = nil)
  if valid_614174 != nil:
    section.add "X-Amz-Security-Token", valid_614174
  var valid_614175 = header.getOrDefault("X-Amz-Algorithm")
  valid_614175 = validateParameter(valid_614175, JString, required = false,
                                 default = nil)
  if valid_614175 != nil:
    section.add "X-Amz-Algorithm", valid_614175
  var valid_614176 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614176 = validateParameter(valid_614176, JString, required = false,
                                 default = nil)
  if valid_614176 != nil:
    section.add "X-Amz-SignedHeaders", valid_614176
  result.add "header", section
  ## parameters in `formData` object:
  ##   Enable: JBool
  ##         : A modified enable flag of the scheduled action. If true, the scheduled action is active. If false, the scheduled action is disabled. 
  ##   TargetAction.ResizeCluster: JString
  ##                             : The action type that specifies an Amazon Redshift API operation that is supported by the Amazon Redshift scheduler. 
  ## An action that runs a <code>ResizeCluster</code> API operation. 
  ##   ScheduledActionName: JString (required)
  ##                      : The name of the scheduled action to modify. 
  ##   ScheduledActionDescription: JString
  ##                             : A modified description of the scheduled action. 
  ##   Schedule: JString
  ##           : A modified schedule in either <code>at( )</code> or <code>cron( )</code> format. For more information about this parameter, see <a>ScheduledAction</a>.
  ##   EndTime: JString
  ##          : A modified end time of the scheduled action. For more information about this parameter, see <a>ScheduledAction</a>. 
  ##   StartTime: JString
  ##            : A modified start time of the scheduled action. For more information about this parameter, see <a>ScheduledAction</a>. 
  ##   IamRole: JString
  ##          : A different IAM role to assume to run the target action. For more information about this parameter, see <a>ScheduledAction</a>.
  section = newJObject()
  var valid_614177 = formData.getOrDefault("Enable")
  valid_614177 = validateParameter(valid_614177, JBool, required = false, default = nil)
  if valid_614177 != nil:
    section.add "Enable", valid_614177
  var valid_614178 = formData.getOrDefault("TargetAction.ResizeCluster")
  valid_614178 = validateParameter(valid_614178, JString, required = false,
                                 default = nil)
  if valid_614178 != nil:
    section.add "TargetAction.ResizeCluster", valid_614178
  assert formData != nil, "formData argument is necessary due to required `ScheduledActionName` field"
  var valid_614179 = formData.getOrDefault("ScheduledActionName")
  valid_614179 = validateParameter(valid_614179, JString, required = true,
                                 default = nil)
  if valid_614179 != nil:
    section.add "ScheduledActionName", valid_614179
  var valid_614180 = formData.getOrDefault("ScheduledActionDescription")
  valid_614180 = validateParameter(valid_614180, JString, required = false,
                                 default = nil)
  if valid_614180 != nil:
    section.add "ScheduledActionDescription", valid_614180
  var valid_614181 = formData.getOrDefault("Schedule")
  valid_614181 = validateParameter(valid_614181, JString, required = false,
                                 default = nil)
  if valid_614181 != nil:
    section.add "Schedule", valid_614181
  var valid_614182 = formData.getOrDefault("EndTime")
  valid_614182 = validateParameter(valid_614182, JString, required = false,
                                 default = nil)
  if valid_614182 != nil:
    section.add "EndTime", valid_614182
  var valid_614183 = formData.getOrDefault("StartTime")
  valid_614183 = validateParameter(valid_614183, JString, required = false,
                                 default = nil)
  if valid_614183 != nil:
    section.add "StartTime", valid_614183
  var valid_614184 = formData.getOrDefault("IamRole")
  valid_614184 = validateParameter(valid_614184, JString, required = false,
                                 default = nil)
  if valid_614184 != nil:
    section.add "IamRole", valid_614184
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614185: Call_PostModifyScheduledAction_614165; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Modifies a scheduled action. 
  ## 
  let valid = call_614185.validator(path, query, header, formData, body)
  let scheme = call_614185.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614185.url(scheme.get, call_614185.host, call_614185.base,
                         call_614185.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614185, url, valid)

proc call*(call_614186: Call_PostModifyScheduledAction_614165;
          ScheduledActionName: string; Enable: bool = false;
          TargetActionResizeCluster: string = "";
          ScheduledActionDescription: string = ""; Schedule: string = "";
          EndTime: string = ""; StartTime: string = "";
          Action: string = "ModifyScheduledAction"; Version: string = "2012-12-01";
          IamRole: string = ""): Recallable =
  ## postModifyScheduledAction
  ## Modifies a scheduled action. 
  ##   Enable: bool
  ##         : A modified enable flag of the scheduled action. If true, the scheduled action is active. If false, the scheduled action is disabled. 
  ##   TargetActionResizeCluster: string
  ##                            : The action type that specifies an Amazon Redshift API operation that is supported by the Amazon Redshift scheduler. 
  ## An action that runs a <code>ResizeCluster</code> API operation. 
  ##   ScheduledActionName: string (required)
  ##                      : The name of the scheduled action to modify. 
  ##   ScheduledActionDescription: string
  ##                             : A modified description of the scheduled action. 
  ##   Schedule: string
  ##           : A modified schedule in either <code>at( )</code> or <code>cron( )</code> format. For more information about this parameter, see <a>ScheduledAction</a>.
  ##   EndTime: string
  ##          : A modified end time of the scheduled action. For more information about this parameter, see <a>ScheduledAction</a>. 
  ##   StartTime: string
  ##            : A modified start time of the scheduled action. For more information about this parameter, see <a>ScheduledAction</a>. 
  ##   Action: string (required)
  ##   Version: string (required)
  ##   IamRole: string
  ##          : A different IAM role to assume to run the target action. For more information about this parameter, see <a>ScheduledAction</a>.
  var query_614187 = newJObject()
  var formData_614188 = newJObject()
  add(formData_614188, "Enable", newJBool(Enable))
  add(formData_614188, "TargetAction.ResizeCluster",
      newJString(TargetActionResizeCluster))
  add(formData_614188, "ScheduledActionName", newJString(ScheduledActionName))
  add(formData_614188, "ScheduledActionDescription",
      newJString(ScheduledActionDescription))
  add(formData_614188, "Schedule", newJString(Schedule))
  add(formData_614188, "EndTime", newJString(EndTime))
  add(formData_614188, "StartTime", newJString(StartTime))
  add(query_614187, "Action", newJString(Action))
  add(query_614187, "Version", newJString(Version))
  add(formData_614188, "IamRole", newJString(IamRole))
  result = call_614186.call(nil, query_614187, nil, formData_614188, nil)

var postModifyScheduledAction* = Call_PostModifyScheduledAction_614165(
    name: "postModifyScheduledAction", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyScheduledAction",
    validator: validate_PostModifyScheduledAction_614166, base: "/",
    url: url_PostModifyScheduledAction_614167,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetModifyScheduledAction_614142 = ref object of OpenApiRestCall_610642
proc url_GetModifyScheduledAction_614144(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetModifyScheduledAction_614143(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies a scheduled action. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Schedule: JString
  ##           : A modified schedule in either <code>at( )</code> or <code>cron( )</code> format. For more information about this parameter, see <a>ScheduledAction</a>.
  ##   Enable: JBool
  ##         : A modified enable flag of the scheduled action. If true, the scheduled action is active. If false, the scheduled action is disabled. 
  ##   ScheduledActionName: JString (required)
  ##                      : The name of the scheduled action to modify. 
  ##   IamRole: JString
  ##          : A different IAM role to assume to run the target action. For more information about this parameter, see <a>ScheduledAction</a>.
  ##   TargetAction.ResizeCluster: JString
  ##                             : The action type that specifies an Amazon Redshift API operation that is supported by the Amazon Redshift scheduler. 
  ## An action that runs a <code>ResizeCluster</code> API operation. 
  ##   ScheduledActionDescription: JString
  ##                             : A modified description of the scheduled action. 
  ##   Action: JString (required)
  ##   StartTime: JString
  ##            : A modified start time of the scheduled action. For more information about this parameter, see <a>ScheduledAction</a>. 
  ##   EndTime: JString
  ##          : A modified end time of the scheduled action. For more information about this parameter, see <a>ScheduledAction</a>. 
  ##   Version: JString (required)
  section = newJObject()
  var valid_614145 = query.getOrDefault("Schedule")
  valid_614145 = validateParameter(valid_614145, JString, required = false,
                                 default = nil)
  if valid_614145 != nil:
    section.add "Schedule", valid_614145
  var valid_614146 = query.getOrDefault("Enable")
  valid_614146 = validateParameter(valid_614146, JBool, required = false, default = nil)
  if valid_614146 != nil:
    section.add "Enable", valid_614146
  assert query != nil, "query argument is necessary due to required `ScheduledActionName` field"
  var valid_614147 = query.getOrDefault("ScheduledActionName")
  valid_614147 = validateParameter(valid_614147, JString, required = true,
                                 default = nil)
  if valid_614147 != nil:
    section.add "ScheduledActionName", valid_614147
  var valid_614148 = query.getOrDefault("IamRole")
  valid_614148 = validateParameter(valid_614148, JString, required = false,
                                 default = nil)
  if valid_614148 != nil:
    section.add "IamRole", valid_614148
  var valid_614149 = query.getOrDefault("TargetAction.ResizeCluster")
  valid_614149 = validateParameter(valid_614149, JString, required = false,
                                 default = nil)
  if valid_614149 != nil:
    section.add "TargetAction.ResizeCluster", valid_614149
  var valid_614150 = query.getOrDefault("ScheduledActionDescription")
  valid_614150 = validateParameter(valid_614150, JString, required = false,
                                 default = nil)
  if valid_614150 != nil:
    section.add "ScheduledActionDescription", valid_614150
  var valid_614151 = query.getOrDefault("Action")
  valid_614151 = validateParameter(valid_614151, JString, required = true,
                                 default = newJString("ModifyScheduledAction"))
  if valid_614151 != nil:
    section.add "Action", valid_614151
  var valid_614152 = query.getOrDefault("StartTime")
  valid_614152 = validateParameter(valid_614152, JString, required = false,
                                 default = nil)
  if valid_614152 != nil:
    section.add "StartTime", valid_614152
  var valid_614153 = query.getOrDefault("EndTime")
  valid_614153 = validateParameter(valid_614153, JString, required = false,
                                 default = nil)
  if valid_614153 != nil:
    section.add "EndTime", valid_614153
  var valid_614154 = query.getOrDefault("Version")
  valid_614154 = validateParameter(valid_614154, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_614154 != nil:
    section.add "Version", valid_614154
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614155 = header.getOrDefault("X-Amz-Signature")
  valid_614155 = validateParameter(valid_614155, JString, required = false,
                                 default = nil)
  if valid_614155 != nil:
    section.add "X-Amz-Signature", valid_614155
  var valid_614156 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614156 = validateParameter(valid_614156, JString, required = false,
                                 default = nil)
  if valid_614156 != nil:
    section.add "X-Amz-Content-Sha256", valid_614156
  var valid_614157 = header.getOrDefault("X-Amz-Date")
  valid_614157 = validateParameter(valid_614157, JString, required = false,
                                 default = nil)
  if valid_614157 != nil:
    section.add "X-Amz-Date", valid_614157
  var valid_614158 = header.getOrDefault("X-Amz-Credential")
  valid_614158 = validateParameter(valid_614158, JString, required = false,
                                 default = nil)
  if valid_614158 != nil:
    section.add "X-Amz-Credential", valid_614158
  var valid_614159 = header.getOrDefault("X-Amz-Security-Token")
  valid_614159 = validateParameter(valid_614159, JString, required = false,
                                 default = nil)
  if valid_614159 != nil:
    section.add "X-Amz-Security-Token", valid_614159
  var valid_614160 = header.getOrDefault("X-Amz-Algorithm")
  valid_614160 = validateParameter(valid_614160, JString, required = false,
                                 default = nil)
  if valid_614160 != nil:
    section.add "X-Amz-Algorithm", valid_614160
  var valid_614161 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614161 = validateParameter(valid_614161, JString, required = false,
                                 default = nil)
  if valid_614161 != nil:
    section.add "X-Amz-SignedHeaders", valid_614161
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614162: Call_GetModifyScheduledAction_614142; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Modifies a scheduled action. 
  ## 
  let valid = call_614162.validator(path, query, header, formData, body)
  let scheme = call_614162.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614162.url(scheme.get, call_614162.host, call_614162.base,
                         call_614162.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614162, url, valid)

proc call*(call_614163: Call_GetModifyScheduledAction_614142;
          ScheduledActionName: string; Schedule: string = ""; Enable: bool = false;
          IamRole: string = ""; TargetActionResizeCluster: string = "";
          ScheduledActionDescription: string = "";
          Action: string = "ModifyScheduledAction"; StartTime: string = "";
          EndTime: string = ""; Version: string = "2012-12-01"): Recallable =
  ## getModifyScheduledAction
  ## Modifies a scheduled action. 
  ##   Schedule: string
  ##           : A modified schedule in either <code>at( )</code> or <code>cron( )</code> format. For more information about this parameter, see <a>ScheduledAction</a>.
  ##   Enable: bool
  ##         : A modified enable flag of the scheduled action. If true, the scheduled action is active. If false, the scheduled action is disabled. 
  ##   ScheduledActionName: string (required)
  ##                      : The name of the scheduled action to modify. 
  ##   IamRole: string
  ##          : A different IAM role to assume to run the target action. For more information about this parameter, see <a>ScheduledAction</a>.
  ##   TargetActionResizeCluster: string
  ##                            : The action type that specifies an Amazon Redshift API operation that is supported by the Amazon Redshift scheduler. 
  ## An action that runs a <code>ResizeCluster</code> API operation. 
  ##   ScheduledActionDescription: string
  ##                             : A modified description of the scheduled action. 
  ##   Action: string (required)
  ##   StartTime: string
  ##            : A modified start time of the scheduled action. For more information about this parameter, see <a>ScheduledAction</a>. 
  ##   EndTime: string
  ##          : A modified end time of the scheduled action. For more information about this parameter, see <a>ScheduledAction</a>. 
  ##   Version: string (required)
  var query_614164 = newJObject()
  add(query_614164, "Schedule", newJString(Schedule))
  add(query_614164, "Enable", newJBool(Enable))
  add(query_614164, "ScheduledActionName", newJString(ScheduledActionName))
  add(query_614164, "IamRole", newJString(IamRole))
  add(query_614164, "TargetAction.ResizeCluster",
      newJString(TargetActionResizeCluster))
  add(query_614164, "ScheduledActionDescription",
      newJString(ScheduledActionDescription))
  add(query_614164, "Action", newJString(Action))
  add(query_614164, "StartTime", newJString(StartTime))
  add(query_614164, "EndTime", newJString(EndTime))
  add(query_614164, "Version", newJString(Version))
  result = call_614163.call(nil, query_614164, nil, nil, nil)

var getModifyScheduledAction* = Call_GetModifyScheduledAction_614142(
    name: "getModifyScheduledAction", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyScheduledAction",
    validator: validate_GetModifyScheduledAction_614143, base: "/",
    url: url_GetModifyScheduledAction_614144, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostModifySnapshotCopyRetentionPeriod_614207 = ref object of OpenApiRestCall_610642
proc url_PostModifySnapshotCopyRetentionPeriod_614209(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostModifySnapshotCopyRetentionPeriod_614208(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies the number of days to retain snapshots in the destination AWS Region after they are copied from the source AWS Region. By default, this operation only changes the retention period of copied automated snapshots. The retention periods for both new and existing copied automated snapshots are updated with the new retention period. You can set the manual option to change only the retention periods of copied manual snapshots. If you set this option, only newly copied manual snapshots have the new retention period. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_614210 = query.getOrDefault("Action")
  valid_614210 = validateParameter(valid_614210, JString, required = true, default = newJString(
      "ModifySnapshotCopyRetentionPeriod"))
  if valid_614210 != nil:
    section.add "Action", valid_614210
  var valid_614211 = query.getOrDefault("Version")
  valid_614211 = validateParameter(valid_614211, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_614211 != nil:
    section.add "Version", valid_614211
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614212 = header.getOrDefault("X-Amz-Signature")
  valid_614212 = validateParameter(valid_614212, JString, required = false,
                                 default = nil)
  if valid_614212 != nil:
    section.add "X-Amz-Signature", valid_614212
  var valid_614213 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614213 = validateParameter(valid_614213, JString, required = false,
                                 default = nil)
  if valid_614213 != nil:
    section.add "X-Amz-Content-Sha256", valid_614213
  var valid_614214 = header.getOrDefault("X-Amz-Date")
  valid_614214 = validateParameter(valid_614214, JString, required = false,
                                 default = nil)
  if valid_614214 != nil:
    section.add "X-Amz-Date", valid_614214
  var valid_614215 = header.getOrDefault("X-Amz-Credential")
  valid_614215 = validateParameter(valid_614215, JString, required = false,
                                 default = nil)
  if valid_614215 != nil:
    section.add "X-Amz-Credential", valid_614215
  var valid_614216 = header.getOrDefault("X-Amz-Security-Token")
  valid_614216 = validateParameter(valid_614216, JString, required = false,
                                 default = nil)
  if valid_614216 != nil:
    section.add "X-Amz-Security-Token", valid_614216
  var valid_614217 = header.getOrDefault("X-Amz-Algorithm")
  valid_614217 = validateParameter(valid_614217, JString, required = false,
                                 default = nil)
  if valid_614217 != nil:
    section.add "X-Amz-Algorithm", valid_614217
  var valid_614218 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614218 = validateParameter(valid_614218, JString, required = false,
                                 default = nil)
  if valid_614218 != nil:
    section.add "X-Amz-SignedHeaders", valid_614218
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of the cluster for which you want to change the retention period for either automated or manual snapshots that are copied to a destination AWS Region.</p> <p>Constraints: Must be the valid name of an existing cluster that has cross-region snapshot copy enabled.</p>
  ##   RetentionPeriod: JInt (required)
  ##                  : <p>The number of days to retain automated snapshots in the destination AWS Region after they are copied from the source AWS Region.</p> <p>By default, this only changes the retention period of copied automated snapshots. </p> <p>If you decrease the retention period for automated snapshots that are copied to a destination AWS Region, Amazon Redshift deletes any existing automated snapshots that were copied to the destination AWS Region and that fall outside of the new retention period.</p> <p>Constraints: Must be at least 1 and no more than 35 for automated snapshots. </p> <p>If you specify the <code>manual</code> option, only newly copied manual snapshots will have the new retention period. </p> <p>If you specify the value of -1 newly copied manual snapshots are retained indefinitely.</p> <p>Constraints: The number of days must be either -1 or an integer between 1 and 3,653 for manual snapshots.</p>
  ##   Manual: JBool
  ##         : Indicates whether to apply the snapshot retention period to newly copied manual snapshots instead of automated snapshots.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_614219 = formData.getOrDefault("ClusterIdentifier")
  valid_614219 = validateParameter(valid_614219, JString, required = true,
                                 default = nil)
  if valid_614219 != nil:
    section.add "ClusterIdentifier", valid_614219
  var valid_614220 = formData.getOrDefault("RetentionPeriod")
  valid_614220 = validateParameter(valid_614220, JInt, required = true, default = nil)
  if valid_614220 != nil:
    section.add "RetentionPeriod", valid_614220
  var valid_614221 = formData.getOrDefault("Manual")
  valid_614221 = validateParameter(valid_614221, JBool, required = false, default = nil)
  if valid_614221 != nil:
    section.add "Manual", valid_614221
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614222: Call_PostModifySnapshotCopyRetentionPeriod_614207;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Modifies the number of days to retain snapshots in the destination AWS Region after they are copied from the source AWS Region. By default, this operation only changes the retention period of copied automated snapshots. The retention periods for both new and existing copied automated snapshots are updated with the new retention period. You can set the manual option to change only the retention periods of copied manual snapshots. If you set this option, only newly copied manual snapshots have the new retention period. 
  ## 
  let valid = call_614222.validator(path, query, header, formData, body)
  let scheme = call_614222.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614222.url(scheme.get, call_614222.host, call_614222.base,
                         call_614222.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614222, url, valid)

proc call*(call_614223: Call_PostModifySnapshotCopyRetentionPeriod_614207;
          ClusterIdentifier: string; RetentionPeriod: int;
          Action: string = "ModifySnapshotCopyRetentionPeriod";
          Manual: bool = false; Version: string = "2012-12-01"): Recallable =
  ## postModifySnapshotCopyRetentionPeriod
  ## Modifies the number of days to retain snapshots in the destination AWS Region after they are copied from the source AWS Region. By default, this operation only changes the retention period of copied automated snapshots. The retention periods for both new and existing copied automated snapshots are updated with the new retention period. You can set the manual option to change only the retention periods of copied manual snapshots. If you set this option, only newly copied manual snapshots have the new retention period. 
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of the cluster for which you want to change the retention period for either automated or manual snapshots that are copied to a destination AWS Region.</p> <p>Constraints: Must be the valid name of an existing cluster that has cross-region snapshot copy enabled.</p>
  ##   RetentionPeriod: int (required)
  ##                  : <p>The number of days to retain automated snapshots in the destination AWS Region after they are copied from the source AWS Region.</p> <p>By default, this only changes the retention period of copied automated snapshots. </p> <p>If you decrease the retention period for automated snapshots that are copied to a destination AWS Region, Amazon Redshift deletes any existing automated snapshots that were copied to the destination AWS Region and that fall outside of the new retention period.</p> <p>Constraints: Must be at least 1 and no more than 35 for automated snapshots. </p> <p>If you specify the <code>manual</code> option, only newly copied manual snapshots will have the new retention period. </p> <p>If you specify the value of -1 newly copied manual snapshots are retained indefinitely.</p> <p>Constraints: The number of days must be either -1 or an integer between 1 and 3,653 for manual snapshots.</p>
  ##   Action: string (required)
  ##   Manual: bool
  ##         : Indicates whether to apply the snapshot retention period to newly copied manual snapshots instead of automated snapshots.
  ##   Version: string (required)
  var query_614224 = newJObject()
  var formData_614225 = newJObject()
  add(formData_614225, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_614225, "RetentionPeriod", newJInt(RetentionPeriod))
  add(query_614224, "Action", newJString(Action))
  add(formData_614225, "Manual", newJBool(Manual))
  add(query_614224, "Version", newJString(Version))
  result = call_614223.call(nil, query_614224, nil, formData_614225, nil)

var postModifySnapshotCopyRetentionPeriod* = Call_PostModifySnapshotCopyRetentionPeriod_614207(
    name: "postModifySnapshotCopyRetentionPeriod", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=ModifySnapshotCopyRetentionPeriod",
    validator: validate_PostModifySnapshotCopyRetentionPeriod_614208, base: "/",
    url: url_PostModifySnapshotCopyRetentionPeriod_614209,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetModifySnapshotCopyRetentionPeriod_614189 = ref object of OpenApiRestCall_610642
proc url_GetModifySnapshotCopyRetentionPeriod_614191(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetModifySnapshotCopyRetentionPeriod_614190(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies the number of days to retain snapshots in the destination AWS Region after they are copied from the source AWS Region. By default, this operation only changes the retention period of copied automated snapshots. The retention periods for both new and existing copied automated snapshots are updated with the new retention period. You can set the manual option to change only the retention periods of copied manual snapshots. If you set this option, only newly copied manual snapshots have the new retention period. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Manual: JBool
  ##         : Indicates whether to apply the snapshot retention period to newly copied manual snapshots instead of automated snapshots.
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of the cluster for which you want to change the retention period for either automated or manual snapshots that are copied to a destination AWS Region.</p> <p>Constraints: Must be the valid name of an existing cluster that has cross-region snapshot copy enabled.</p>
  ##   Version: JString (required)
  ##   RetentionPeriod: JInt (required)
  ##                  : <p>The number of days to retain automated snapshots in the destination AWS Region after they are copied from the source AWS Region.</p> <p>By default, this only changes the retention period of copied automated snapshots. </p> <p>If you decrease the retention period for automated snapshots that are copied to a destination AWS Region, Amazon Redshift deletes any existing automated snapshots that were copied to the destination AWS Region and that fall outside of the new retention period.</p> <p>Constraints: Must be at least 1 and no more than 35 for automated snapshots. </p> <p>If you specify the <code>manual</code> option, only newly copied manual snapshots will have the new retention period. </p> <p>If you specify the value of -1 newly copied manual snapshots are retained indefinitely.</p> <p>Constraints: The number of days must be either -1 or an integer between 1 and 3,653 for manual snapshots.</p>
  section = newJObject()
  var valid_614192 = query.getOrDefault("Manual")
  valid_614192 = validateParameter(valid_614192, JBool, required = false, default = nil)
  if valid_614192 != nil:
    section.add "Manual", valid_614192
  var valid_614193 = query.getOrDefault("Action")
  valid_614193 = validateParameter(valid_614193, JString, required = true, default = newJString(
      "ModifySnapshotCopyRetentionPeriod"))
  if valid_614193 != nil:
    section.add "Action", valid_614193
  var valid_614194 = query.getOrDefault("ClusterIdentifier")
  valid_614194 = validateParameter(valid_614194, JString, required = true,
                                 default = nil)
  if valid_614194 != nil:
    section.add "ClusterIdentifier", valid_614194
  var valid_614195 = query.getOrDefault("Version")
  valid_614195 = validateParameter(valid_614195, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_614195 != nil:
    section.add "Version", valid_614195
  var valid_614196 = query.getOrDefault("RetentionPeriod")
  valid_614196 = validateParameter(valid_614196, JInt, required = true, default = nil)
  if valid_614196 != nil:
    section.add "RetentionPeriod", valid_614196
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614197 = header.getOrDefault("X-Amz-Signature")
  valid_614197 = validateParameter(valid_614197, JString, required = false,
                                 default = nil)
  if valid_614197 != nil:
    section.add "X-Amz-Signature", valid_614197
  var valid_614198 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614198 = validateParameter(valid_614198, JString, required = false,
                                 default = nil)
  if valid_614198 != nil:
    section.add "X-Amz-Content-Sha256", valid_614198
  var valid_614199 = header.getOrDefault("X-Amz-Date")
  valid_614199 = validateParameter(valid_614199, JString, required = false,
                                 default = nil)
  if valid_614199 != nil:
    section.add "X-Amz-Date", valid_614199
  var valid_614200 = header.getOrDefault("X-Amz-Credential")
  valid_614200 = validateParameter(valid_614200, JString, required = false,
                                 default = nil)
  if valid_614200 != nil:
    section.add "X-Amz-Credential", valid_614200
  var valid_614201 = header.getOrDefault("X-Amz-Security-Token")
  valid_614201 = validateParameter(valid_614201, JString, required = false,
                                 default = nil)
  if valid_614201 != nil:
    section.add "X-Amz-Security-Token", valid_614201
  var valid_614202 = header.getOrDefault("X-Amz-Algorithm")
  valid_614202 = validateParameter(valid_614202, JString, required = false,
                                 default = nil)
  if valid_614202 != nil:
    section.add "X-Amz-Algorithm", valid_614202
  var valid_614203 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614203 = validateParameter(valid_614203, JString, required = false,
                                 default = nil)
  if valid_614203 != nil:
    section.add "X-Amz-SignedHeaders", valid_614203
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614204: Call_GetModifySnapshotCopyRetentionPeriod_614189;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Modifies the number of days to retain snapshots in the destination AWS Region after they are copied from the source AWS Region. By default, this operation only changes the retention period of copied automated snapshots. The retention periods for both new and existing copied automated snapshots are updated with the new retention period. You can set the manual option to change only the retention periods of copied manual snapshots. If you set this option, only newly copied manual snapshots have the new retention period. 
  ## 
  let valid = call_614204.validator(path, query, header, formData, body)
  let scheme = call_614204.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614204.url(scheme.get, call_614204.host, call_614204.base,
                         call_614204.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614204, url, valid)

proc call*(call_614205: Call_GetModifySnapshotCopyRetentionPeriod_614189;
          ClusterIdentifier: string; RetentionPeriod: int; Manual: bool = false;
          Action: string = "ModifySnapshotCopyRetentionPeriod";
          Version: string = "2012-12-01"): Recallable =
  ## getModifySnapshotCopyRetentionPeriod
  ## Modifies the number of days to retain snapshots in the destination AWS Region after they are copied from the source AWS Region. By default, this operation only changes the retention period of copied automated snapshots. The retention periods for both new and existing copied automated snapshots are updated with the new retention period. You can set the manual option to change only the retention periods of copied manual snapshots. If you set this option, only newly copied manual snapshots have the new retention period. 
  ##   Manual: bool
  ##         : Indicates whether to apply the snapshot retention period to newly copied manual snapshots instead of automated snapshots.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of the cluster for which you want to change the retention period for either automated or manual snapshots that are copied to a destination AWS Region.</p> <p>Constraints: Must be the valid name of an existing cluster that has cross-region snapshot copy enabled.</p>
  ##   Version: string (required)
  ##   RetentionPeriod: int (required)
  ##                  : <p>The number of days to retain automated snapshots in the destination AWS Region after they are copied from the source AWS Region.</p> <p>By default, this only changes the retention period of copied automated snapshots. </p> <p>If you decrease the retention period for automated snapshots that are copied to a destination AWS Region, Amazon Redshift deletes any existing automated snapshots that were copied to the destination AWS Region and that fall outside of the new retention period.</p> <p>Constraints: Must be at least 1 and no more than 35 for automated snapshots. </p> <p>If you specify the <code>manual</code> option, only newly copied manual snapshots will have the new retention period. </p> <p>If you specify the value of -1 newly copied manual snapshots are retained indefinitely.</p> <p>Constraints: The number of days must be either -1 or an integer between 1 and 3,653 for manual snapshots.</p>
  var query_614206 = newJObject()
  add(query_614206, "Manual", newJBool(Manual))
  add(query_614206, "Action", newJString(Action))
  add(query_614206, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_614206, "Version", newJString(Version))
  add(query_614206, "RetentionPeriod", newJInt(RetentionPeriod))
  result = call_614205.call(nil, query_614206, nil, nil, nil)

var getModifySnapshotCopyRetentionPeriod* = Call_GetModifySnapshotCopyRetentionPeriod_614189(
    name: "getModifySnapshotCopyRetentionPeriod", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=ModifySnapshotCopyRetentionPeriod",
    validator: validate_GetModifySnapshotCopyRetentionPeriod_614190, base: "/",
    url: url_GetModifySnapshotCopyRetentionPeriod_614191,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostModifySnapshotSchedule_614243 = ref object of OpenApiRestCall_610642
proc url_PostModifySnapshotSchedule_614245(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostModifySnapshotSchedule_614244(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies a snapshot schedule. Any schedule associated with a cluster is modified asynchronously.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_614246 = query.getOrDefault("Action")
  valid_614246 = validateParameter(valid_614246, JString, required = true,
                                 default = newJString("ModifySnapshotSchedule"))
  if valid_614246 != nil:
    section.add "Action", valid_614246
  var valid_614247 = query.getOrDefault("Version")
  valid_614247 = validateParameter(valid_614247, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_614247 != nil:
    section.add "Version", valid_614247
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614248 = header.getOrDefault("X-Amz-Signature")
  valid_614248 = validateParameter(valid_614248, JString, required = false,
                                 default = nil)
  if valid_614248 != nil:
    section.add "X-Amz-Signature", valid_614248
  var valid_614249 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614249 = validateParameter(valid_614249, JString, required = false,
                                 default = nil)
  if valid_614249 != nil:
    section.add "X-Amz-Content-Sha256", valid_614249
  var valid_614250 = header.getOrDefault("X-Amz-Date")
  valid_614250 = validateParameter(valid_614250, JString, required = false,
                                 default = nil)
  if valid_614250 != nil:
    section.add "X-Amz-Date", valid_614250
  var valid_614251 = header.getOrDefault("X-Amz-Credential")
  valid_614251 = validateParameter(valid_614251, JString, required = false,
                                 default = nil)
  if valid_614251 != nil:
    section.add "X-Amz-Credential", valid_614251
  var valid_614252 = header.getOrDefault("X-Amz-Security-Token")
  valid_614252 = validateParameter(valid_614252, JString, required = false,
                                 default = nil)
  if valid_614252 != nil:
    section.add "X-Amz-Security-Token", valid_614252
  var valid_614253 = header.getOrDefault("X-Amz-Algorithm")
  valid_614253 = validateParameter(valid_614253, JString, required = false,
                                 default = nil)
  if valid_614253 != nil:
    section.add "X-Amz-Algorithm", valid_614253
  var valid_614254 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614254 = validateParameter(valid_614254, JString, required = false,
                                 default = nil)
  if valid_614254 != nil:
    section.add "X-Amz-SignedHeaders", valid_614254
  result.add "header", section
  ## parameters in `formData` object:
  ##   ScheduleDefinitions: JArray (required)
  ##                      : An updated list of schedule definitions. A schedule definition is made up of schedule expressions, for example, "cron(30 12 *)" or "rate(12 hours)".
  ##   ScheduleIdentifier: JString (required)
  ##                     : A unique alphanumeric identifier of the schedule to modify.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ScheduleDefinitions` field"
  var valid_614255 = formData.getOrDefault("ScheduleDefinitions")
  valid_614255 = validateParameter(valid_614255, JArray, required = true, default = nil)
  if valid_614255 != nil:
    section.add "ScheduleDefinitions", valid_614255
  var valid_614256 = formData.getOrDefault("ScheduleIdentifier")
  valid_614256 = validateParameter(valid_614256, JString, required = true,
                                 default = nil)
  if valid_614256 != nil:
    section.add "ScheduleIdentifier", valid_614256
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614257: Call_PostModifySnapshotSchedule_614243; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Modifies a snapshot schedule. Any schedule associated with a cluster is modified asynchronously.
  ## 
  let valid = call_614257.validator(path, query, header, formData, body)
  let scheme = call_614257.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614257.url(scheme.get, call_614257.host, call_614257.base,
                         call_614257.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614257, url, valid)

proc call*(call_614258: Call_PostModifySnapshotSchedule_614243;
          ScheduleDefinitions: JsonNode; ScheduleIdentifier: string;
          Action: string = "ModifySnapshotSchedule"; Version: string = "2012-12-01"): Recallable =
  ## postModifySnapshotSchedule
  ## Modifies a snapshot schedule. Any schedule associated with a cluster is modified asynchronously.
  ##   ScheduleDefinitions: JArray (required)
  ##                      : An updated list of schedule definitions. A schedule definition is made up of schedule expressions, for example, "cron(30 12 *)" or "rate(12 hours)".
  ##   Action: string (required)
  ##   ScheduleIdentifier: string (required)
  ##                     : A unique alphanumeric identifier of the schedule to modify.
  ##   Version: string (required)
  var query_614259 = newJObject()
  var formData_614260 = newJObject()
  if ScheduleDefinitions != nil:
    formData_614260.add "ScheduleDefinitions", ScheduleDefinitions
  add(query_614259, "Action", newJString(Action))
  add(formData_614260, "ScheduleIdentifier", newJString(ScheduleIdentifier))
  add(query_614259, "Version", newJString(Version))
  result = call_614258.call(nil, query_614259, nil, formData_614260, nil)

var postModifySnapshotSchedule* = Call_PostModifySnapshotSchedule_614243(
    name: "postModifySnapshotSchedule", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=ModifySnapshotSchedule",
    validator: validate_PostModifySnapshotSchedule_614244, base: "/",
    url: url_PostModifySnapshotSchedule_614245,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetModifySnapshotSchedule_614226 = ref object of OpenApiRestCall_610642
proc url_GetModifySnapshotSchedule_614228(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetModifySnapshotSchedule_614227(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies a snapshot schedule. Any schedule associated with a cluster is modified asynchronously.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ScheduleIdentifier: JString (required)
  ##                     : A unique alphanumeric identifier of the schedule to modify.
  ##   ScheduleDefinitions: JArray (required)
  ##                      : An updated list of schedule definitions. A schedule definition is made up of schedule expressions, for example, "cron(30 12 *)" or "rate(12 hours)".
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `ScheduleIdentifier` field"
  var valid_614229 = query.getOrDefault("ScheduleIdentifier")
  valid_614229 = validateParameter(valid_614229, JString, required = true,
                                 default = nil)
  if valid_614229 != nil:
    section.add "ScheduleIdentifier", valid_614229
  var valid_614230 = query.getOrDefault("ScheduleDefinitions")
  valid_614230 = validateParameter(valid_614230, JArray, required = true, default = nil)
  if valid_614230 != nil:
    section.add "ScheduleDefinitions", valid_614230
  var valid_614231 = query.getOrDefault("Action")
  valid_614231 = validateParameter(valid_614231, JString, required = true,
                                 default = newJString("ModifySnapshotSchedule"))
  if valid_614231 != nil:
    section.add "Action", valid_614231
  var valid_614232 = query.getOrDefault("Version")
  valid_614232 = validateParameter(valid_614232, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_614232 != nil:
    section.add "Version", valid_614232
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614233 = header.getOrDefault("X-Amz-Signature")
  valid_614233 = validateParameter(valid_614233, JString, required = false,
                                 default = nil)
  if valid_614233 != nil:
    section.add "X-Amz-Signature", valid_614233
  var valid_614234 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614234 = validateParameter(valid_614234, JString, required = false,
                                 default = nil)
  if valid_614234 != nil:
    section.add "X-Amz-Content-Sha256", valid_614234
  var valid_614235 = header.getOrDefault("X-Amz-Date")
  valid_614235 = validateParameter(valid_614235, JString, required = false,
                                 default = nil)
  if valid_614235 != nil:
    section.add "X-Amz-Date", valid_614235
  var valid_614236 = header.getOrDefault("X-Amz-Credential")
  valid_614236 = validateParameter(valid_614236, JString, required = false,
                                 default = nil)
  if valid_614236 != nil:
    section.add "X-Amz-Credential", valid_614236
  var valid_614237 = header.getOrDefault("X-Amz-Security-Token")
  valid_614237 = validateParameter(valid_614237, JString, required = false,
                                 default = nil)
  if valid_614237 != nil:
    section.add "X-Amz-Security-Token", valid_614237
  var valid_614238 = header.getOrDefault("X-Amz-Algorithm")
  valid_614238 = validateParameter(valid_614238, JString, required = false,
                                 default = nil)
  if valid_614238 != nil:
    section.add "X-Amz-Algorithm", valid_614238
  var valid_614239 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614239 = validateParameter(valid_614239, JString, required = false,
                                 default = nil)
  if valid_614239 != nil:
    section.add "X-Amz-SignedHeaders", valid_614239
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614240: Call_GetModifySnapshotSchedule_614226; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Modifies a snapshot schedule. Any schedule associated with a cluster is modified asynchronously.
  ## 
  let valid = call_614240.validator(path, query, header, formData, body)
  let scheme = call_614240.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614240.url(scheme.get, call_614240.host, call_614240.base,
                         call_614240.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614240, url, valid)

proc call*(call_614241: Call_GetModifySnapshotSchedule_614226;
          ScheduleIdentifier: string; ScheduleDefinitions: JsonNode;
          Action: string = "ModifySnapshotSchedule"; Version: string = "2012-12-01"): Recallable =
  ## getModifySnapshotSchedule
  ## Modifies a snapshot schedule. Any schedule associated with a cluster is modified asynchronously.
  ##   ScheduleIdentifier: string (required)
  ##                     : A unique alphanumeric identifier of the schedule to modify.
  ##   ScheduleDefinitions: JArray (required)
  ##                      : An updated list of schedule definitions. A schedule definition is made up of schedule expressions, for example, "cron(30 12 *)" or "rate(12 hours)".
  ##   Action: string (required)
  ##   Version: string (required)
  var query_614242 = newJObject()
  add(query_614242, "ScheduleIdentifier", newJString(ScheduleIdentifier))
  if ScheduleDefinitions != nil:
    query_614242.add "ScheduleDefinitions", ScheduleDefinitions
  add(query_614242, "Action", newJString(Action))
  add(query_614242, "Version", newJString(Version))
  result = call_614241.call(nil, query_614242, nil, nil, nil)

var getModifySnapshotSchedule* = Call_GetModifySnapshotSchedule_614226(
    name: "getModifySnapshotSchedule", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=ModifySnapshotSchedule",
    validator: validate_GetModifySnapshotSchedule_614227, base: "/",
    url: url_GetModifySnapshotSchedule_614228,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostPurchaseReservedNodeOffering_614278 = ref object of OpenApiRestCall_610642
proc url_PostPurchaseReservedNodeOffering_614280(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostPurchaseReservedNodeOffering_614279(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Allows you to purchase reserved nodes. Amazon Redshift offers a predefined set of reserved node offerings. You can purchase one or more of the offerings. You can call the <a>DescribeReservedNodeOfferings</a> API to obtain the available reserved node offerings. You can call this API by providing a specific reserved node offering and the number of nodes you want to reserve. </p> <p> For more information about reserved node offerings, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_614281 = query.getOrDefault("Action")
  valid_614281 = validateParameter(valid_614281, JString, required = true, default = newJString(
      "PurchaseReservedNodeOffering"))
  if valid_614281 != nil:
    section.add "Action", valid_614281
  var valid_614282 = query.getOrDefault("Version")
  valid_614282 = validateParameter(valid_614282, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_614282 != nil:
    section.add "Version", valid_614282
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614283 = header.getOrDefault("X-Amz-Signature")
  valid_614283 = validateParameter(valid_614283, JString, required = false,
                                 default = nil)
  if valid_614283 != nil:
    section.add "X-Amz-Signature", valid_614283
  var valid_614284 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614284 = validateParameter(valid_614284, JString, required = false,
                                 default = nil)
  if valid_614284 != nil:
    section.add "X-Amz-Content-Sha256", valid_614284
  var valid_614285 = header.getOrDefault("X-Amz-Date")
  valid_614285 = validateParameter(valid_614285, JString, required = false,
                                 default = nil)
  if valid_614285 != nil:
    section.add "X-Amz-Date", valid_614285
  var valid_614286 = header.getOrDefault("X-Amz-Credential")
  valid_614286 = validateParameter(valid_614286, JString, required = false,
                                 default = nil)
  if valid_614286 != nil:
    section.add "X-Amz-Credential", valid_614286
  var valid_614287 = header.getOrDefault("X-Amz-Security-Token")
  valid_614287 = validateParameter(valid_614287, JString, required = false,
                                 default = nil)
  if valid_614287 != nil:
    section.add "X-Amz-Security-Token", valid_614287
  var valid_614288 = header.getOrDefault("X-Amz-Algorithm")
  valid_614288 = validateParameter(valid_614288, JString, required = false,
                                 default = nil)
  if valid_614288 != nil:
    section.add "X-Amz-Algorithm", valid_614288
  var valid_614289 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614289 = validateParameter(valid_614289, JString, required = false,
                                 default = nil)
  if valid_614289 != nil:
    section.add "X-Amz-SignedHeaders", valid_614289
  result.add "header", section
  ## parameters in `formData` object:
  ##   NodeCount: JInt
  ##            : <p>The number of reserved nodes that you want to purchase.</p> <p>Default: <code>1</code> </p>
  ##   ReservedNodeOfferingId: JString (required)
  ##                         : The unique identifier of the reserved node offering you want to purchase.
  section = newJObject()
  var valid_614290 = formData.getOrDefault("NodeCount")
  valid_614290 = validateParameter(valid_614290, JInt, required = false, default = nil)
  if valid_614290 != nil:
    section.add "NodeCount", valid_614290
  assert formData != nil, "formData argument is necessary due to required `ReservedNodeOfferingId` field"
  var valid_614291 = formData.getOrDefault("ReservedNodeOfferingId")
  valid_614291 = validateParameter(valid_614291, JString, required = true,
                                 default = nil)
  if valid_614291 != nil:
    section.add "ReservedNodeOfferingId", valid_614291
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614292: Call_PostPurchaseReservedNodeOffering_614278;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Allows you to purchase reserved nodes. Amazon Redshift offers a predefined set of reserved node offerings. You can purchase one or more of the offerings. You can call the <a>DescribeReservedNodeOfferings</a> API to obtain the available reserved node offerings. You can call this API by providing a specific reserved node offering and the number of nodes you want to reserve. </p> <p> For more information about reserved node offerings, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_614292.validator(path, query, header, formData, body)
  let scheme = call_614292.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614292.url(scheme.get, call_614292.host, call_614292.base,
                         call_614292.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614292, url, valid)

proc call*(call_614293: Call_PostPurchaseReservedNodeOffering_614278;
          ReservedNodeOfferingId: string; NodeCount: int = 0;
          Action: string = "PurchaseReservedNodeOffering";
          Version: string = "2012-12-01"): Recallable =
  ## postPurchaseReservedNodeOffering
  ## <p>Allows you to purchase reserved nodes. Amazon Redshift offers a predefined set of reserved node offerings. You can purchase one or more of the offerings. You can call the <a>DescribeReservedNodeOfferings</a> API to obtain the available reserved node offerings. You can call this API by providing a specific reserved node offering and the number of nodes you want to reserve. </p> <p> For more information about reserved node offerings, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   NodeCount: int
  ##            : <p>The number of reserved nodes that you want to purchase.</p> <p>Default: <code>1</code> </p>
  ##   ReservedNodeOfferingId: string (required)
  ##                         : The unique identifier of the reserved node offering you want to purchase.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_614294 = newJObject()
  var formData_614295 = newJObject()
  add(formData_614295, "NodeCount", newJInt(NodeCount))
  add(formData_614295, "ReservedNodeOfferingId",
      newJString(ReservedNodeOfferingId))
  add(query_614294, "Action", newJString(Action))
  add(query_614294, "Version", newJString(Version))
  result = call_614293.call(nil, query_614294, nil, formData_614295, nil)

var postPurchaseReservedNodeOffering* = Call_PostPurchaseReservedNodeOffering_614278(
    name: "postPurchaseReservedNodeOffering", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=PurchaseReservedNodeOffering",
    validator: validate_PostPurchaseReservedNodeOffering_614279, base: "/",
    url: url_PostPurchaseReservedNodeOffering_614280,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetPurchaseReservedNodeOffering_614261 = ref object of OpenApiRestCall_610642
proc url_GetPurchaseReservedNodeOffering_614263(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetPurchaseReservedNodeOffering_614262(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Allows you to purchase reserved nodes. Amazon Redshift offers a predefined set of reserved node offerings. You can purchase one or more of the offerings. You can call the <a>DescribeReservedNodeOfferings</a> API to obtain the available reserved node offerings. You can call this API by providing a specific reserved node offering and the number of nodes you want to reserve. </p> <p> For more information about reserved node offerings, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ReservedNodeOfferingId: JString (required)
  ##                         : The unique identifier of the reserved node offering you want to purchase.
  ##   Action: JString (required)
  ##   Version: JString (required)
  ##   NodeCount: JInt
  ##            : <p>The number of reserved nodes that you want to purchase.</p> <p>Default: <code>1</code> </p>
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `ReservedNodeOfferingId` field"
  var valid_614264 = query.getOrDefault("ReservedNodeOfferingId")
  valid_614264 = validateParameter(valid_614264, JString, required = true,
                                 default = nil)
  if valid_614264 != nil:
    section.add "ReservedNodeOfferingId", valid_614264
  var valid_614265 = query.getOrDefault("Action")
  valid_614265 = validateParameter(valid_614265, JString, required = true, default = newJString(
      "PurchaseReservedNodeOffering"))
  if valid_614265 != nil:
    section.add "Action", valid_614265
  var valid_614266 = query.getOrDefault("Version")
  valid_614266 = validateParameter(valid_614266, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_614266 != nil:
    section.add "Version", valid_614266
  var valid_614267 = query.getOrDefault("NodeCount")
  valid_614267 = validateParameter(valid_614267, JInt, required = false, default = nil)
  if valid_614267 != nil:
    section.add "NodeCount", valid_614267
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614268 = header.getOrDefault("X-Amz-Signature")
  valid_614268 = validateParameter(valid_614268, JString, required = false,
                                 default = nil)
  if valid_614268 != nil:
    section.add "X-Amz-Signature", valid_614268
  var valid_614269 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614269 = validateParameter(valid_614269, JString, required = false,
                                 default = nil)
  if valid_614269 != nil:
    section.add "X-Amz-Content-Sha256", valid_614269
  var valid_614270 = header.getOrDefault("X-Amz-Date")
  valid_614270 = validateParameter(valid_614270, JString, required = false,
                                 default = nil)
  if valid_614270 != nil:
    section.add "X-Amz-Date", valid_614270
  var valid_614271 = header.getOrDefault("X-Amz-Credential")
  valid_614271 = validateParameter(valid_614271, JString, required = false,
                                 default = nil)
  if valid_614271 != nil:
    section.add "X-Amz-Credential", valid_614271
  var valid_614272 = header.getOrDefault("X-Amz-Security-Token")
  valid_614272 = validateParameter(valid_614272, JString, required = false,
                                 default = nil)
  if valid_614272 != nil:
    section.add "X-Amz-Security-Token", valid_614272
  var valid_614273 = header.getOrDefault("X-Amz-Algorithm")
  valid_614273 = validateParameter(valid_614273, JString, required = false,
                                 default = nil)
  if valid_614273 != nil:
    section.add "X-Amz-Algorithm", valid_614273
  var valid_614274 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614274 = validateParameter(valid_614274, JString, required = false,
                                 default = nil)
  if valid_614274 != nil:
    section.add "X-Amz-SignedHeaders", valid_614274
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614275: Call_GetPurchaseReservedNodeOffering_614261;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Allows you to purchase reserved nodes. Amazon Redshift offers a predefined set of reserved node offerings. You can purchase one or more of the offerings. You can call the <a>DescribeReservedNodeOfferings</a> API to obtain the available reserved node offerings. You can call this API by providing a specific reserved node offering and the number of nodes you want to reserve. </p> <p> For more information about reserved node offerings, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_614275.validator(path, query, header, formData, body)
  let scheme = call_614275.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614275.url(scheme.get, call_614275.host, call_614275.base,
                         call_614275.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614275, url, valid)

proc call*(call_614276: Call_GetPurchaseReservedNodeOffering_614261;
          ReservedNodeOfferingId: string;
          Action: string = "PurchaseReservedNodeOffering";
          Version: string = "2012-12-01"; NodeCount: int = 0): Recallable =
  ## getPurchaseReservedNodeOffering
  ## <p>Allows you to purchase reserved nodes. Amazon Redshift offers a predefined set of reserved node offerings. You can purchase one or more of the offerings. You can call the <a>DescribeReservedNodeOfferings</a> API to obtain the available reserved node offerings. You can call this API by providing a specific reserved node offering and the number of nodes you want to reserve. </p> <p> For more information about reserved node offerings, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   ReservedNodeOfferingId: string (required)
  ##                         : The unique identifier of the reserved node offering you want to purchase.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   NodeCount: int
  ##            : <p>The number of reserved nodes that you want to purchase.</p> <p>Default: <code>1</code> </p>
  var query_614277 = newJObject()
  add(query_614277, "ReservedNodeOfferingId", newJString(ReservedNodeOfferingId))
  add(query_614277, "Action", newJString(Action))
  add(query_614277, "Version", newJString(Version))
  add(query_614277, "NodeCount", newJInt(NodeCount))
  result = call_614276.call(nil, query_614277, nil, nil, nil)

var getPurchaseReservedNodeOffering* = Call_GetPurchaseReservedNodeOffering_614261(
    name: "getPurchaseReservedNodeOffering", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=PurchaseReservedNodeOffering",
    validator: validate_GetPurchaseReservedNodeOffering_614262, base: "/",
    url: url_GetPurchaseReservedNodeOffering_614263,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostRebootCluster_614312 = ref object of OpenApiRestCall_610642
proc url_PostRebootCluster_614314(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostRebootCluster_614313(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## Reboots a cluster. This action is taken as soon as possible. It results in a momentary outage to the cluster, during which the cluster status is set to <code>rebooting</code>. A cluster event is created when the reboot is completed. Any pending cluster modifications (see <a>ModifyCluster</a>) are applied at this reboot. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_614315 = query.getOrDefault("Action")
  valid_614315 = validateParameter(valid_614315, JString, required = true,
                                 default = newJString("RebootCluster"))
  if valid_614315 != nil:
    section.add "Action", valid_614315
  var valid_614316 = query.getOrDefault("Version")
  valid_614316 = validateParameter(valid_614316, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_614316 != nil:
    section.add "Version", valid_614316
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614317 = header.getOrDefault("X-Amz-Signature")
  valid_614317 = validateParameter(valid_614317, JString, required = false,
                                 default = nil)
  if valid_614317 != nil:
    section.add "X-Amz-Signature", valid_614317
  var valid_614318 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614318 = validateParameter(valid_614318, JString, required = false,
                                 default = nil)
  if valid_614318 != nil:
    section.add "X-Amz-Content-Sha256", valid_614318
  var valid_614319 = header.getOrDefault("X-Amz-Date")
  valid_614319 = validateParameter(valid_614319, JString, required = false,
                                 default = nil)
  if valid_614319 != nil:
    section.add "X-Amz-Date", valid_614319
  var valid_614320 = header.getOrDefault("X-Amz-Credential")
  valid_614320 = validateParameter(valid_614320, JString, required = false,
                                 default = nil)
  if valid_614320 != nil:
    section.add "X-Amz-Credential", valid_614320
  var valid_614321 = header.getOrDefault("X-Amz-Security-Token")
  valid_614321 = validateParameter(valid_614321, JString, required = false,
                                 default = nil)
  if valid_614321 != nil:
    section.add "X-Amz-Security-Token", valid_614321
  var valid_614322 = header.getOrDefault("X-Amz-Algorithm")
  valid_614322 = validateParameter(valid_614322, JString, required = false,
                                 default = nil)
  if valid_614322 != nil:
    section.add "X-Amz-Algorithm", valid_614322
  var valid_614323 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614323 = validateParameter(valid_614323, JString, required = false,
                                 default = nil)
  if valid_614323 != nil:
    section.add "X-Amz-SignedHeaders", valid_614323
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : The cluster identifier.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_614324 = formData.getOrDefault("ClusterIdentifier")
  valid_614324 = validateParameter(valid_614324, JString, required = true,
                                 default = nil)
  if valid_614324 != nil:
    section.add "ClusterIdentifier", valid_614324
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614325: Call_PostRebootCluster_614312; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Reboots a cluster. This action is taken as soon as possible. It results in a momentary outage to the cluster, during which the cluster status is set to <code>rebooting</code>. A cluster event is created when the reboot is completed. Any pending cluster modifications (see <a>ModifyCluster</a>) are applied at this reboot. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. 
  ## 
  let valid = call_614325.validator(path, query, header, formData, body)
  let scheme = call_614325.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614325.url(scheme.get, call_614325.host, call_614325.base,
                         call_614325.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614325, url, valid)

proc call*(call_614326: Call_PostRebootCluster_614312; ClusterIdentifier: string;
          Action: string = "RebootCluster"; Version: string = "2012-12-01"): Recallable =
  ## postRebootCluster
  ## Reboots a cluster. This action is taken as soon as possible. It results in a momentary outage to the cluster, during which the cluster status is set to <code>rebooting</code>. A cluster event is created when the reboot is completed. Any pending cluster modifications (see <a>ModifyCluster</a>) are applied at this reboot. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. 
  ##   ClusterIdentifier: string (required)
  ##                    : The cluster identifier.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_614327 = newJObject()
  var formData_614328 = newJObject()
  add(formData_614328, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_614327, "Action", newJString(Action))
  add(query_614327, "Version", newJString(Version))
  result = call_614326.call(nil, query_614327, nil, formData_614328, nil)

var postRebootCluster* = Call_PostRebootCluster_614312(name: "postRebootCluster",
    meth: HttpMethod.HttpPost, host: "redshift.amazonaws.com",
    route: "/#Action=RebootCluster", validator: validate_PostRebootCluster_614313,
    base: "/", url: url_PostRebootCluster_614314,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetRebootCluster_614296 = ref object of OpenApiRestCall_610642
proc url_GetRebootCluster_614298(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetRebootCluster_614297(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Reboots a cluster. This action is taken as soon as possible. It results in a momentary outage to the cluster, during which the cluster status is set to <code>rebooting</code>. A cluster event is created when the reboot is completed. Any pending cluster modifications (see <a>ModifyCluster</a>) are applied at this reboot. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : The cluster identifier.
  ##   Version: JString (required)
  section = newJObject()
  var valid_614299 = query.getOrDefault("Action")
  valid_614299 = validateParameter(valid_614299, JString, required = true,
                                 default = newJString("RebootCluster"))
  if valid_614299 != nil:
    section.add "Action", valid_614299
  var valid_614300 = query.getOrDefault("ClusterIdentifier")
  valid_614300 = validateParameter(valid_614300, JString, required = true,
                                 default = nil)
  if valid_614300 != nil:
    section.add "ClusterIdentifier", valid_614300
  var valid_614301 = query.getOrDefault("Version")
  valid_614301 = validateParameter(valid_614301, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_614301 != nil:
    section.add "Version", valid_614301
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614302 = header.getOrDefault("X-Amz-Signature")
  valid_614302 = validateParameter(valid_614302, JString, required = false,
                                 default = nil)
  if valid_614302 != nil:
    section.add "X-Amz-Signature", valid_614302
  var valid_614303 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614303 = validateParameter(valid_614303, JString, required = false,
                                 default = nil)
  if valid_614303 != nil:
    section.add "X-Amz-Content-Sha256", valid_614303
  var valid_614304 = header.getOrDefault("X-Amz-Date")
  valid_614304 = validateParameter(valid_614304, JString, required = false,
                                 default = nil)
  if valid_614304 != nil:
    section.add "X-Amz-Date", valid_614304
  var valid_614305 = header.getOrDefault("X-Amz-Credential")
  valid_614305 = validateParameter(valid_614305, JString, required = false,
                                 default = nil)
  if valid_614305 != nil:
    section.add "X-Amz-Credential", valid_614305
  var valid_614306 = header.getOrDefault("X-Amz-Security-Token")
  valid_614306 = validateParameter(valid_614306, JString, required = false,
                                 default = nil)
  if valid_614306 != nil:
    section.add "X-Amz-Security-Token", valid_614306
  var valid_614307 = header.getOrDefault("X-Amz-Algorithm")
  valid_614307 = validateParameter(valid_614307, JString, required = false,
                                 default = nil)
  if valid_614307 != nil:
    section.add "X-Amz-Algorithm", valid_614307
  var valid_614308 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614308 = validateParameter(valid_614308, JString, required = false,
                                 default = nil)
  if valid_614308 != nil:
    section.add "X-Amz-SignedHeaders", valid_614308
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614309: Call_GetRebootCluster_614296; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Reboots a cluster. This action is taken as soon as possible. It results in a momentary outage to the cluster, during which the cluster status is set to <code>rebooting</code>. A cluster event is created when the reboot is completed. Any pending cluster modifications (see <a>ModifyCluster</a>) are applied at this reboot. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. 
  ## 
  let valid = call_614309.validator(path, query, header, formData, body)
  let scheme = call_614309.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614309.url(scheme.get, call_614309.host, call_614309.base,
                         call_614309.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614309, url, valid)

proc call*(call_614310: Call_GetRebootCluster_614296; ClusterIdentifier: string;
          Action: string = "RebootCluster"; Version: string = "2012-12-01"): Recallable =
  ## getRebootCluster
  ## Reboots a cluster. This action is taken as soon as possible. It results in a momentary outage to the cluster, during which the cluster status is set to <code>rebooting</code>. A cluster event is created when the reboot is completed. Any pending cluster modifications (see <a>ModifyCluster</a>) are applied at this reboot. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. 
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : The cluster identifier.
  ##   Version: string (required)
  var query_614311 = newJObject()
  add(query_614311, "Action", newJString(Action))
  add(query_614311, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_614311, "Version", newJString(Version))
  result = call_614310.call(nil, query_614311, nil, nil, nil)

var getRebootCluster* = Call_GetRebootCluster_614296(name: "getRebootCluster",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=RebootCluster", validator: validate_GetRebootCluster_614297,
    base: "/", url: url_GetRebootCluster_614298,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostResetClusterParameterGroup_614347 = ref object of OpenApiRestCall_610642
proc url_PostResetClusterParameterGroup_614349(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostResetClusterParameterGroup_614348(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Sets one or more parameters of the specified parameter group to their default values and sets the source values of the parameters to "engine-default". To reset the entire parameter group specify the <i>ResetAllParameters</i> parameter. For parameter changes to take effect you must reboot any associated clusters. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_614350 = query.getOrDefault("Action")
  valid_614350 = validateParameter(valid_614350, JString, required = true, default = newJString(
      "ResetClusterParameterGroup"))
  if valid_614350 != nil:
    section.add "Action", valid_614350
  var valid_614351 = query.getOrDefault("Version")
  valid_614351 = validateParameter(valid_614351, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_614351 != nil:
    section.add "Version", valid_614351
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614352 = header.getOrDefault("X-Amz-Signature")
  valid_614352 = validateParameter(valid_614352, JString, required = false,
                                 default = nil)
  if valid_614352 != nil:
    section.add "X-Amz-Signature", valid_614352
  var valid_614353 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614353 = validateParameter(valid_614353, JString, required = false,
                                 default = nil)
  if valid_614353 != nil:
    section.add "X-Amz-Content-Sha256", valid_614353
  var valid_614354 = header.getOrDefault("X-Amz-Date")
  valid_614354 = validateParameter(valid_614354, JString, required = false,
                                 default = nil)
  if valid_614354 != nil:
    section.add "X-Amz-Date", valid_614354
  var valid_614355 = header.getOrDefault("X-Amz-Credential")
  valid_614355 = validateParameter(valid_614355, JString, required = false,
                                 default = nil)
  if valid_614355 != nil:
    section.add "X-Amz-Credential", valid_614355
  var valid_614356 = header.getOrDefault("X-Amz-Security-Token")
  valid_614356 = validateParameter(valid_614356, JString, required = false,
                                 default = nil)
  if valid_614356 != nil:
    section.add "X-Amz-Security-Token", valid_614356
  var valid_614357 = header.getOrDefault("X-Amz-Algorithm")
  valid_614357 = validateParameter(valid_614357, JString, required = false,
                                 default = nil)
  if valid_614357 != nil:
    section.add "X-Amz-Algorithm", valid_614357
  var valid_614358 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614358 = validateParameter(valid_614358, JString, required = false,
                                 default = nil)
  if valid_614358 != nil:
    section.add "X-Amz-SignedHeaders", valid_614358
  result.add "header", section
  ## parameters in `formData` object:
  ##   ResetAllParameters: JBool
  ##                     : <p>If <code>true</code>, all parameters in the specified parameter group will be reset to their default values. </p> <p>Default: <code>true</code> </p>
  ##   Parameters: JArray
  ##             : <p>An array of names of parameters to be reset. If <i>ResetAllParameters</i> option is not used, then at least one parameter name must be supplied. </p> <p>Constraints: A maximum of 20 parameters can be reset in a single request.</p>
  ##   ParameterGroupName: JString (required)
  ##                     : The name of the cluster parameter group to be reset.
  section = newJObject()
  var valid_614359 = formData.getOrDefault("ResetAllParameters")
  valid_614359 = validateParameter(valid_614359, JBool, required = false, default = nil)
  if valid_614359 != nil:
    section.add "ResetAllParameters", valid_614359
  var valid_614360 = formData.getOrDefault("Parameters")
  valid_614360 = validateParameter(valid_614360, JArray, required = false,
                                 default = nil)
  if valid_614360 != nil:
    section.add "Parameters", valid_614360
  assert formData != nil, "formData argument is necessary due to required `ParameterGroupName` field"
  var valid_614361 = formData.getOrDefault("ParameterGroupName")
  valid_614361 = validateParameter(valid_614361, JString, required = true,
                                 default = nil)
  if valid_614361 != nil:
    section.add "ParameterGroupName", valid_614361
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614362: Call_PostResetClusterParameterGroup_614347; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Sets one or more parameters of the specified parameter group to their default values and sets the source values of the parameters to "engine-default". To reset the entire parameter group specify the <i>ResetAllParameters</i> parameter. For parameter changes to take effect you must reboot any associated clusters. 
  ## 
  let valid = call_614362.validator(path, query, header, formData, body)
  let scheme = call_614362.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614362.url(scheme.get, call_614362.host, call_614362.base,
                         call_614362.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614362, url, valid)

proc call*(call_614363: Call_PostResetClusterParameterGroup_614347;
          ParameterGroupName: string; ResetAllParameters: bool = false;
          Action: string = "ResetClusterParameterGroup"; Parameters: JsonNode = nil;
          Version: string = "2012-12-01"): Recallable =
  ## postResetClusterParameterGroup
  ## Sets one or more parameters of the specified parameter group to their default values and sets the source values of the parameters to "engine-default". To reset the entire parameter group specify the <i>ResetAllParameters</i> parameter. For parameter changes to take effect you must reboot any associated clusters. 
  ##   ResetAllParameters: bool
  ##                     : <p>If <code>true</code>, all parameters in the specified parameter group will be reset to their default values. </p> <p>Default: <code>true</code> </p>
  ##   Action: string (required)
  ##   Parameters: JArray
  ##             : <p>An array of names of parameters to be reset. If <i>ResetAllParameters</i> option is not used, then at least one parameter name must be supplied. </p> <p>Constraints: A maximum of 20 parameters can be reset in a single request.</p>
  ##   ParameterGroupName: string (required)
  ##                     : The name of the cluster parameter group to be reset.
  ##   Version: string (required)
  var query_614364 = newJObject()
  var formData_614365 = newJObject()
  add(formData_614365, "ResetAllParameters", newJBool(ResetAllParameters))
  add(query_614364, "Action", newJString(Action))
  if Parameters != nil:
    formData_614365.add "Parameters", Parameters
  add(formData_614365, "ParameterGroupName", newJString(ParameterGroupName))
  add(query_614364, "Version", newJString(Version))
  result = call_614363.call(nil, query_614364, nil, formData_614365, nil)

var postResetClusterParameterGroup* = Call_PostResetClusterParameterGroup_614347(
    name: "postResetClusterParameterGroup", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=ResetClusterParameterGroup",
    validator: validate_PostResetClusterParameterGroup_614348, base: "/",
    url: url_PostResetClusterParameterGroup_614349,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetResetClusterParameterGroup_614329 = ref object of OpenApiRestCall_610642
proc url_GetResetClusterParameterGroup_614331(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetResetClusterParameterGroup_614330(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Sets one or more parameters of the specified parameter group to their default values and sets the source values of the parameters to "engine-default". To reset the entire parameter group specify the <i>ResetAllParameters</i> parameter. For parameter changes to take effect you must reboot any associated clusters. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Parameters: JArray
  ##             : <p>An array of names of parameters to be reset. If <i>ResetAllParameters</i> option is not used, then at least one parameter name must be supplied. </p> <p>Constraints: A maximum of 20 parameters can be reset in a single request.</p>
  ##   ResetAllParameters: JBool
  ##                     : <p>If <code>true</code>, all parameters in the specified parameter group will be reset to their default values. </p> <p>Default: <code>true</code> </p>
  ##   Action: JString (required)
  ##   ParameterGroupName: JString (required)
  ##                     : The name of the cluster parameter group to be reset.
  ##   Version: JString (required)
  section = newJObject()
  var valid_614332 = query.getOrDefault("Parameters")
  valid_614332 = validateParameter(valid_614332, JArray, required = false,
                                 default = nil)
  if valid_614332 != nil:
    section.add "Parameters", valid_614332
  var valid_614333 = query.getOrDefault("ResetAllParameters")
  valid_614333 = validateParameter(valid_614333, JBool, required = false, default = nil)
  if valid_614333 != nil:
    section.add "ResetAllParameters", valid_614333
  var valid_614334 = query.getOrDefault("Action")
  valid_614334 = validateParameter(valid_614334, JString, required = true, default = newJString(
      "ResetClusterParameterGroup"))
  if valid_614334 != nil:
    section.add "Action", valid_614334
  var valid_614335 = query.getOrDefault("ParameterGroupName")
  valid_614335 = validateParameter(valid_614335, JString, required = true,
                                 default = nil)
  if valid_614335 != nil:
    section.add "ParameterGroupName", valid_614335
  var valid_614336 = query.getOrDefault("Version")
  valid_614336 = validateParameter(valid_614336, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_614336 != nil:
    section.add "Version", valid_614336
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614337 = header.getOrDefault("X-Amz-Signature")
  valid_614337 = validateParameter(valid_614337, JString, required = false,
                                 default = nil)
  if valid_614337 != nil:
    section.add "X-Amz-Signature", valid_614337
  var valid_614338 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614338 = validateParameter(valid_614338, JString, required = false,
                                 default = nil)
  if valid_614338 != nil:
    section.add "X-Amz-Content-Sha256", valid_614338
  var valid_614339 = header.getOrDefault("X-Amz-Date")
  valid_614339 = validateParameter(valid_614339, JString, required = false,
                                 default = nil)
  if valid_614339 != nil:
    section.add "X-Amz-Date", valid_614339
  var valid_614340 = header.getOrDefault("X-Amz-Credential")
  valid_614340 = validateParameter(valid_614340, JString, required = false,
                                 default = nil)
  if valid_614340 != nil:
    section.add "X-Amz-Credential", valid_614340
  var valid_614341 = header.getOrDefault("X-Amz-Security-Token")
  valid_614341 = validateParameter(valid_614341, JString, required = false,
                                 default = nil)
  if valid_614341 != nil:
    section.add "X-Amz-Security-Token", valid_614341
  var valid_614342 = header.getOrDefault("X-Amz-Algorithm")
  valid_614342 = validateParameter(valid_614342, JString, required = false,
                                 default = nil)
  if valid_614342 != nil:
    section.add "X-Amz-Algorithm", valid_614342
  var valid_614343 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614343 = validateParameter(valid_614343, JString, required = false,
                                 default = nil)
  if valid_614343 != nil:
    section.add "X-Amz-SignedHeaders", valid_614343
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614344: Call_GetResetClusterParameterGroup_614329; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Sets one or more parameters of the specified parameter group to their default values and sets the source values of the parameters to "engine-default". To reset the entire parameter group specify the <i>ResetAllParameters</i> parameter. For parameter changes to take effect you must reboot any associated clusters. 
  ## 
  let valid = call_614344.validator(path, query, header, formData, body)
  let scheme = call_614344.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614344.url(scheme.get, call_614344.host, call_614344.base,
                         call_614344.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614344, url, valid)

proc call*(call_614345: Call_GetResetClusterParameterGroup_614329;
          ParameterGroupName: string; Parameters: JsonNode = nil;
          ResetAllParameters: bool = false;
          Action: string = "ResetClusterParameterGroup";
          Version: string = "2012-12-01"): Recallable =
  ## getResetClusterParameterGroup
  ## Sets one or more parameters of the specified parameter group to their default values and sets the source values of the parameters to "engine-default". To reset the entire parameter group specify the <i>ResetAllParameters</i> parameter. For parameter changes to take effect you must reboot any associated clusters. 
  ##   Parameters: JArray
  ##             : <p>An array of names of parameters to be reset. If <i>ResetAllParameters</i> option is not used, then at least one parameter name must be supplied. </p> <p>Constraints: A maximum of 20 parameters can be reset in a single request.</p>
  ##   ResetAllParameters: bool
  ##                     : <p>If <code>true</code>, all parameters in the specified parameter group will be reset to their default values. </p> <p>Default: <code>true</code> </p>
  ##   Action: string (required)
  ##   ParameterGroupName: string (required)
  ##                     : The name of the cluster parameter group to be reset.
  ##   Version: string (required)
  var query_614346 = newJObject()
  if Parameters != nil:
    query_614346.add "Parameters", Parameters
  add(query_614346, "ResetAllParameters", newJBool(ResetAllParameters))
  add(query_614346, "Action", newJString(Action))
  add(query_614346, "ParameterGroupName", newJString(ParameterGroupName))
  add(query_614346, "Version", newJString(Version))
  result = call_614345.call(nil, query_614346, nil, nil, nil)

var getResetClusterParameterGroup* = Call_GetResetClusterParameterGroup_614329(
    name: "getResetClusterParameterGroup", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=ResetClusterParameterGroup",
    validator: validate_GetResetClusterParameterGroup_614330, base: "/",
    url: url_GetResetClusterParameterGroup_614331,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostResizeCluster_614386 = ref object of OpenApiRestCall_610642
proc url_PostResizeCluster_614388(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostResizeCluster_614387(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## <p>Changes the size of the cluster. You can change the cluster's type, or change the number or type of nodes. The default behavior is to use the elastic resize method. With an elastic resize, your cluster is available for read and write operations more quickly than with the classic resize method. </p> <p>Elastic resize operations have the following restrictions:</p> <ul> <li> <p>You can only resize clusters of the following types:</p> <ul> <li> <p>dc2.large</p> </li> <li> <p>dc2.8xlarge</p> </li> <li> <p>ds2.xlarge</p> </li> <li> <p>ds2.8xlarge</p> </li> <li> <p>ra3.16xlarge</p> </li> </ul> </li> <li> <p>The type of nodes that you add must match the node type for the cluster.</p> </li> </ul>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_614389 = query.getOrDefault("Action")
  valid_614389 = validateParameter(valid_614389, JString, required = true,
                                 default = newJString("ResizeCluster"))
  if valid_614389 != nil:
    section.add "Action", valid_614389
  var valid_614390 = query.getOrDefault("Version")
  valid_614390 = validateParameter(valid_614390, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_614390 != nil:
    section.add "Version", valid_614390
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614391 = header.getOrDefault("X-Amz-Signature")
  valid_614391 = validateParameter(valid_614391, JString, required = false,
                                 default = nil)
  if valid_614391 != nil:
    section.add "X-Amz-Signature", valid_614391
  var valid_614392 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614392 = validateParameter(valid_614392, JString, required = false,
                                 default = nil)
  if valid_614392 != nil:
    section.add "X-Amz-Content-Sha256", valid_614392
  var valid_614393 = header.getOrDefault("X-Amz-Date")
  valid_614393 = validateParameter(valid_614393, JString, required = false,
                                 default = nil)
  if valid_614393 != nil:
    section.add "X-Amz-Date", valid_614393
  var valid_614394 = header.getOrDefault("X-Amz-Credential")
  valid_614394 = validateParameter(valid_614394, JString, required = false,
                                 default = nil)
  if valid_614394 != nil:
    section.add "X-Amz-Credential", valid_614394
  var valid_614395 = header.getOrDefault("X-Amz-Security-Token")
  valid_614395 = validateParameter(valid_614395, JString, required = false,
                                 default = nil)
  if valid_614395 != nil:
    section.add "X-Amz-Security-Token", valid_614395
  var valid_614396 = header.getOrDefault("X-Amz-Algorithm")
  valid_614396 = validateParameter(valid_614396, JString, required = false,
                                 default = nil)
  if valid_614396 != nil:
    section.add "X-Amz-Algorithm", valid_614396
  var valid_614397 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614397 = validateParameter(valid_614397, JString, required = false,
                                 default = nil)
  if valid_614397 != nil:
    section.add "X-Amz-SignedHeaders", valid_614397
  result.add "header", section
  ## parameters in `formData` object:
  ##   NodeType: JString
  ##           : The new node type for the nodes you are adding. If not specified, the cluster's current node type is used.
  ##   ClusterIdentifier: JString (required)
  ##                    : The unique identifier for the cluster to resize.
  ##   NumberOfNodes: JInt (required)
  ##                : The new number of nodes for the cluster.
  ##   ClusterType: JString
  ##              : The new cluster type for the specified cluster.
  ##   Classic: JBool
  ##          : A boolean value indicating whether the resize operation is using the classic resize process. If you don't provide this parameter or set the value to <code>false</code>, the resize type is elastic. 
  section = newJObject()
  var valid_614398 = formData.getOrDefault("NodeType")
  valid_614398 = validateParameter(valid_614398, JString, required = false,
                                 default = nil)
  if valid_614398 != nil:
    section.add "NodeType", valid_614398
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_614399 = formData.getOrDefault("ClusterIdentifier")
  valid_614399 = validateParameter(valid_614399, JString, required = true,
                                 default = nil)
  if valid_614399 != nil:
    section.add "ClusterIdentifier", valid_614399
  var valid_614400 = formData.getOrDefault("NumberOfNodes")
  valid_614400 = validateParameter(valid_614400, JInt, required = true, default = nil)
  if valid_614400 != nil:
    section.add "NumberOfNodes", valid_614400
  var valid_614401 = formData.getOrDefault("ClusterType")
  valid_614401 = validateParameter(valid_614401, JString, required = false,
                                 default = nil)
  if valid_614401 != nil:
    section.add "ClusterType", valid_614401
  var valid_614402 = formData.getOrDefault("Classic")
  valid_614402 = validateParameter(valid_614402, JBool, required = false, default = nil)
  if valid_614402 != nil:
    section.add "Classic", valid_614402
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614403: Call_PostResizeCluster_614386; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Changes the size of the cluster. You can change the cluster's type, or change the number or type of nodes. The default behavior is to use the elastic resize method. With an elastic resize, your cluster is available for read and write operations more quickly than with the classic resize method. </p> <p>Elastic resize operations have the following restrictions:</p> <ul> <li> <p>You can only resize clusters of the following types:</p> <ul> <li> <p>dc2.large</p> </li> <li> <p>dc2.8xlarge</p> </li> <li> <p>ds2.xlarge</p> </li> <li> <p>ds2.8xlarge</p> </li> <li> <p>ra3.16xlarge</p> </li> </ul> </li> <li> <p>The type of nodes that you add must match the node type for the cluster.</p> </li> </ul>
  ## 
  let valid = call_614403.validator(path, query, header, formData, body)
  let scheme = call_614403.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614403.url(scheme.get, call_614403.host, call_614403.base,
                         call_614403.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614403, url, valid)

proc call*(call_614404: Call_PostResizeCluster_614386; ClusterIdentifier: string;
          NumberOfNodes: int; NodeType: string = ""; Action: string = "ResizeCluster";
          ClusterType: string = ""; Version: string = "2012-12-01";
          Classic: bool = false): Recallable =
  ## postResizeCluster
  ## <p>Changes the size of the cluster. You can change the cluster's type, or change the number or type of nodes. The default behavior is to use the elastic resize method. With an elastic resize, your cluster is available for read and write operations more quickly than with the classic resize method. </p> <p>Elastic resize operations have the following restrictions:</p> <ul> <li> <p>You can only resize clusters of the following types:</p> <ul> <li> <p>dc2.large</p> </li> <li> <p>dc2.8xlarge</p> </li> <li> <p>ds2.xlarge</p> </li> <li> <p>ds2.8xlarge</p> </li> <li> <p>ra3.16xlarge</p> </li> </ul> </li> <li> <p>The type of nodes that you add must match the node type for the cluster.</p> </li> </ul>
  ##   NodeType: string
  ##           : The new node type for the nodes you are adding. If not specified, the cluster's current node type is used.
  ##   ClusterIdentifier: string (required)
  ##                    : The unique identifier for the cluster to resize.
  ##   NumberOfNodes: int (required)
  ##                : The new number of nodes for the cluster.
  ##   Action: string (required)
  ##   ClusterType: string
  ##              : The new cluster type for the specified cluster.
  ##   Version: string (required)
  ##   Classic: bool
  ##          : A boolean value indicating whether the resize operation is using the classic resize process. If you don't provide this parameter or set the value to <code>false</code>, the resize type is elastic. 
  var query_614405 = newJObject()
  var formData_614406 = newJObject()
  add(formData_614406, "NodeType", newJString(NodeType))
  add(formData_614406, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_614406, "NumberOfNodes", newJInt(NumberOfNodes))
  add(query_614405, "Action", newJString(Action))
  add(formData_614406, "ClusterType", newJString(ClusterType))
  add(query_614405, "Version", newJString(Version))
  add(formData_614406, "Classic", newJBool(Classic))
  result = call_614404.call(nil, query_614405, nil, formData_614406, nil)

var postResizeCluster* = Call_PostResizeCluster_614386(name: "postResizeCluster",
    meth: HttpMethod.HttpPost, host: "redshift.amazonaws.com",
    route: "/#Action=ResizeCluster", validator: validate_PostResizeCluster_614387,
    base: "/", url: url_PostResizeCluster_614388,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetResizeCluster_614366 = ref object of OpenApiRestCall_610642
proc url_GetResizeCluster_614368(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetResizeCluster_614367(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## <p>Changes the size of the cluster. You can change the cluster's type, or change the number or type of nodes. The default behavior is to use the elastic resize method. With an elastic resize, your cluster is available for read and write operations more quickly than with the classic resize method. </p> <p>Elastic resize operations have the following restrictions:</p> <ul> <li> <p>You can only resize clusters of the following types:</p> <ul> <li> <p>dc2.large</p> </li> <li> <p>dc2.8xlarge</p> </li> <li> <p>ds2.xlarge</p> </li> <li> <p>ds2.8xlarge</p> </li> <li> <p>ra3.16xlarge</p> </li> </ul> </li> <li> <p>The type of nodes that you add must match the node type for the cluster.</p> </li> </ul>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   NodeType: JString
  ##           : The new node type for the nodes you are adding. If not specified, the cluster's current node type is used.
  ##   ClusterType: JString
  ##              : The new cluster type for the specified cluster.
  ##   NumberOfNodes: JInt (required)
  ##                : The new number of nodes for the cluster.
  ##   Classic: JBool
  ##          : A boolean value indicating whether the resize operation is using the classic resize process. If you don't provide this parameter or set the value to <code>false</code>, the resize type is elastic. 
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : The unique identifier for the cluster to resize.
  ##   Version: JString (required)
  section = newJObject()
  var valid_614369 = query.getOrDefault("NodeType")
  valid_614369 = validateParameter(valid_614369, JString, required = false,
                                 default = nil)
  if valid_614369 != nil:
    section.add "NodeType", valid_614369
  var valid_614370 = query.getOrDefault("ClusterType")
  valid_614370 = validateParameter(valid_614370, JString, required = false,
                                 default = nil)
  if valid_614370 != nil:
    section.add "ClusterType", valid_614370
  assert query != nil,
        "query argument is necessary due to required `NumberOfNodes` field"
  var valid_614371 = query.getOrDefault("NumberOfNodes")
  valid_614371 = validateParameter(valid_614371, JInt, required = true, default = nil)
  if valid_614371 != nil:
    section.add "NumberOfNodes", valid_614371
  var valid_614372 = query.getOrDefault("Classic")
  valid_614372 = validateParameter(valid_614372, JBool, required = false, default = nil)
  if valid_614372 != nil:
    section.add "Classic", valid_614372
  var valid_614373 = query.getOrDefault("Action")
  valid_614373 = validateParameter(valid_614373, JString, required = true,
                                 default = newJString("ResizeCluster"))
  if valid_614373 != nil:
    section.add "Action", valid_614373
  var valid_614374 = query.getOrDefault("ClusterIdentifier")
  valid_614374 = validateParameter(valid_614374, JString, required = true,
                                 default = nil)
  if valid_614374 != nil:
    section.add "ClusterIdentifier", valid_614374
  var valid_614375 = query.getOrDefault("Version")
  valid_614375 = validateParameter(valid_614375, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_614375 != nil:
    section.add "Version", valid_614375
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614376 = header.getOrDefault("X-Amz-Signature")
  valid_614376 = validateParameter(valid_614376, JString, required = false,
                                 default = nil)
  if valid_614376 != nil:
    section.add "X-Amz-Signature", valid_614376
  var valid_614377 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614377 = validateParameter(valid_614377, JString, required = false,
                                 default = nil)
  if valid_614377 != nil:
    section.add "X-Amz-Content-Sha256", valid_614377
  var valid_614378 = header.getOrDefault("X-Amz-Date")
  valid_614378 = validateParameter(valid_614378, JString, required = false,
                                 default = nil)
  if valid_614378 != nil:
    section.add "X-Amz-Date", valid_614378
  var valid_614379 = header.getOrDefault("X-Amz-Credential")
  valid_614379 = validateParameter(valid_614379, JString, required = false,
                                 default = nil)
  if valid_614379 != nil:
    section.add "X-Amz-Credential", valid_614379
  var valid_614380 = header.getOrDefault("X-Amz-Security-Token")
  valid_614380 = validateParameter(valid_614380, JString, required = false,
                                 default = nil)
  if valid_614380 != nil:
    section.add "X-Amz-Security-Token", valid_614380
  var valid_614381 = header.getOrDefault("X-Amz-Algorithm")
  valid_614381 = validateParameter(valid_614381, JString, required = false,
                                 default = nil)
  if valid_614381 != nil:
    section.add "X-Amz-Algorithm", valid_614381
  var valid_614382 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614382 = validateParameter(valid_614382, JString, required = false,
                                 default = nil)
  if valid_614382 != nil:
    section.add "X-Amz-SignedHeaders", valid_614382
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614383: Call_GetResizeCluster_614366; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Changes the size of the cluster. You can change the cluster's type, or change the number or type of nodes. The default behavior is to use the elastic resize method. With an elastic resize, your cluster is available for read and write operations more quickly than with the classic resize method. </p> <p>Elastic resize operations have the following restrictions:</p> <ul> <li> <p>You can only resize clusters of the following types:</p> <ul> <li> <p>dc2.large</p> </li> <li> <p>dc2.8xlarge</p> </li> <li> <p>ds2.xlarge</p> </li> <li> <p>ds2.8xlarge</p> </li> <li> <p>ra3.16xlarge</p> </li> </ul> </li> <li> <p>The type of nodes that you add must match the node type for the cluster.</p> </li> </ul>
  ## 
  let valid = call_614383.validator(path, query, header, formData, body)
  let scheme = call_614383.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614383.url(scheme.get, call_614383.host, call_614383.base,
                         call_614383.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614383, url, valid)

proc call*(call_614384: Call_GetResizeCluster_614366; NumberOfNodes: int;
          ClusterIdentifier: string; NodeType: string = ""; ClusterType: string = "";
          Classic: bool = false; Action: string = "ResizeCluster";
          Version: string = "2012-12-01"): Recallable =
  ## getResizeCluster
  ## <p>Changes the size of the cluster. You can change the cluster's type, or change the number or type of nodes. The default behavior is to use the elastic resize method. With an elastic resize, your cluster is available for read and write operations more quickly than with the classic resize method. </p> <p>Elastic resize operations have the following restrictions:</p> <ul> <li> <p>You can only resize clusters of the following types:</p> <ul> <li> <p>dc2.large</p> </li> <li> <p>dc2.8xlarge</p> </li> <li> <p>ds2.xlarge</p> </li> <li> <p>ds2.8xlarge</p> </li> <li> <p>ra3.16xlarge</p> </li> </ul> </li> <li> <p>The type of nodes that you add must match the node type for the cluster.</p> </li> </ul>
  ##   NodeType: string
  ##           : The new node type for the nodes you are adding. If not specified, the cluster's current node type is used.
  ##   ClusterType: string
  ##              : The new cluster type for the specified cluster.
  ##   NumberOfNodes: int (required)
  ##                : The new number of nodes for the cluster.
  ##   Classic: bool
  ##          : A boolean value indicating whether the resize operation is using the classic resize process. If you don't provide this parameter or set the value to <code>false</code>, the resize type is elastic. 
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : The unique identifier for the cluster to resize.
  ##   Version: string (required)
  var query_614385 = newJObject()
  add(query_614385, "NodeType", newJString(NodeType))
  add(query_614385, "ClusterType", newJString(ClusterType))
  add(query_614385, "NumberOfNodes", newJInt(NumberOfNodes))
  add(query_614385, "Classic", newJBool(Classic))
  add(query_614385, "Action", newJString(Action))
  add(query_614385, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_614385, "Version", newJString(Version))
  result = call_614384.call(nil, query_614385, nil, nil, nil)

var getResizeCluster* = Call_GetResizeCluster_614366(name: "getResizeCluster",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=ResizeCluster", validator: validate_GetResizeCluster_614367,
    base: "/", url: url_GetResizeCluster_614368,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostRestoreFromClusterSnapshot_614448 = ref object of OpenApiRestCall_610642
proc url_PostRestoreFromClusterSnapshot_614450(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostRestoreFromClusterSnapshot_614449(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a new cluster from a snapshot. By default, Amazon Redshift creates the resulting cluster with the same configuration as the original cluster from which the snapshot was created, except that the new cluster is created with the default cluster security and parameter groups. After Amazon Redshift creates the cluster, you can use the <a>ModifyCluster</a> API to associate a different security group and different parameter group with the restored cluster. If you are using a DS node type, you can also choose to change to another DS node type of the same size during restore.</p> <p>If you restore a cluster into a VPC, you must provide a cluster subnet group where you want the cluster restored.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_614451 = query.getOrDefault("Action")
  valid_614451 = validateParameter(valid_614451, JString, required = true, default = newJString(
      "RestoreFromClusterSnapshot"))
  if valid_614451 != nil:
    section.add "Action", valid_614451
  var valid_614452 = query.getOrDefault("Version")
  valid_614452 = validateParameter(valid_614452, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_614452 != nil:
    section.add "Version", valid_614452
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614453 = header.getOrDefault("X-Amz-Signature")
  valid_614453 = validateParameter(valid_614453, JString, required = false,
                                 default = nil)
  if valid_614453 != nil:
    section.add "X-Amz-Signature", valid_614453
  var valid_614454 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614454 = validateParameter(valid_614454, JString, required = false,
                                 default = nil)
  if valid_614454 != nil:
    section.add "X-Amz-Content-Sha256", valid_614454
  var valid_614455 = header.getOrDefault("X-Amz-Date")
  valid_614455 = validateParameter(valid_614455, JString, required = false,
                                 default = nil)
  if valid_614455 != nil:
    section.add "X-Amz-Date", valid_614455
  var valid_614456 = header.getOrDefault("X-Amz-Credential")
  valid_614456 = validateParameter(valid_614456, JString, required = false,
                                 default = nil)
  if valid_614456 != nil:
    section.add "X-Amz-Credential", valid_614456
  var valid_614457 = header.getOrDefault("X-Amz-Security-Token")
  valid_614457 = validateParameter(valid_614457, JString, required = false,
                                 default = nil)
  if valid_614457 != nil:
    section.add "X-Amz-Security-Token", valid_614457
  var valid_614458 = header.getOrDefault("X-Amz-Algorithm")
  valid_614458 = validateParameter(valid_614458, JString, required = false,
                                 default = nil)
  if valid_614458 != nil:
    section.add "X-Amz-Algorithm", valid_614458
  var valid_614459 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614459 = validateParameter(valid_614459, JString, required = false,
                                 default = nil)
  if valid_614459 != nil:
    section.add "X-Amz-SignedHeaders", valid_614459
  result.add "header", section
  ## parameters in `formData` object:
  ##   Port: JInt
  ##       : <p>The port number on which the cluster accepts connections.</p> <p>Default: The same port as the original cluster.</p> <p>Constraints: Must be between <code>1115</code> and <code>65535</code>.</p>
  ##   PreferredMaintenanceWindow: JString
  ##                             : <p>The weekly time range (in UTC) during which automated cluster maintenance can occur.</p> <p> Format: <code>ddd:hh24:mi-ddd:hh24:mi</code> </p> <p> Default: The value selected for the cluster from which the snapshot was taken. For more information about the time blocks for each region, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-maintenance-windows">Maintenance Windows</a> in Amazon Redshift Cluster Management Guide. </p> <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p> <p>Constraints: Minimum 30-minute window.</p>
  ##   NodeType: JString
  ##           : <p>The node type that the restored cluster will be provisioned with.</p> <p>Default: The node type of the cluster from which the snapshot was taken. You can modify this if you are using any DS node type. In that case, you can choose to restore into another DS node type of the same size. For example, you can restore ds1.8xlarge into ds2.8xlarge, or ds1.xlarge into ds2.xlarge. If you have a DC instance type, you must restore into that same instance type and size. In other words, you can only restore a dc1.large instance type into another dc1.large instance type or dc2.large instance type. You can't restore dc1.8xlarge to dc2.8xlarge. First restore to a dc1.8xlareg cluster, then resize to a dc2.8large cluster. For more information about node types, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-about-clusters-and-nodes"> About Clusters and Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The identifier of the cluster that will be created from restoring the snapshot.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul>
  ##   MaintenanceTrackName: JString
  ##                       : The name of the maintenance track for the restored cluster. When you take a snapshot, the snapshot inherits the <code>MaintenanceTrack</code> value from the cluster. The snapshot might be on a different track than the cluster that was the source for the snapshot. For example, suppose that you take a snapshot of a cluster that is on the current track and then change the cluster to be on the trailing track. In this case, the snapshot and the source cluster are on different tracks.
  ##   ClusterSecurityGroups: JArray
  ##                        : <p>A list of security groups to be associated with this cluster.</p> <p>Default: The default cluster security group for Amazon Redshift.</p> <p>Cluster security groups only apply to clusters outside of VPCs.</p>
  ##   IamRoles: JArray
  ##           : <p>A list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services. You must supply the IAM roles in their Amazon Resource Name (ARN) format. You can supply up to 10 IAM roles in a single request.</p> <p>A cluster can have up to 10 IAM roles associated at any time.</p>
  ##   OwnerAccount: JString
  ##               : The AWS customer account used to create or copy the snapshot. Required if you are restoring a snapshot you do not own, optional if you own the snapshot.
  ##   VpcSecurityGroupIds: JArray
  ##                      : <p>A list of Virtual Private Cloud (VPC) security groups to be associated with the cluster.</p> <p>Default: The default VPC security group is associated with the cluster.</p> <p>VPC security groups only apply to clusters in VPCs.</p>
  ##   AutomatedSnapshotRetentionPeriod: JInt
  ##                                   : <p>The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p> <p>Default: The value selected for the cluster from which the snapshot was taken.</p> <p>Constraints: Must be a value from 0 to 35.</p>
  ##   AvailabilityZone: JString
  ##                   : <p>The Amazon EC2 Availability Zone in which to restore the cluster.</p> <p>Default: A random, system-chosen Availability Zone.</p> <p>Example: <code>us-east-2a</code> </p>
  ##   EnhancedVpcRouting: JBool
  ##                     : <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p> <p>Default: false</p>
  ##   KmsKeyId: JString
  ##           : The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster that you restore from a shared snapshot.
  ##   NumberOfNodes: JInt
  ##                : The number of nodes specified when provisioning the restored cluster.
  ##   ClusterSubnetGroupName: JString
  ##                         : <p>The name of the subnet group where you want to cluster restored.</p> <p>A snapshot of cluster in VPC can be restored only in VPC. Therefore, you must provide subnet group name where you want the cluster restored.</p>
  ##   AllowVersionUpgrade: JBool
  ##                      : <p>If <code>true</code>, major version upgrades can be applied during the maintenance window to the Amazon Redshift engine that is running on the cluster. </p> <p>Default: <code>true</code> </p>
  ##   SnapshotIdentifier: JString (required)
  ##                     : <p>The name of the snapshot from which to create the new cluster. This parameter isn't case sensitive.</p> <p>Example: <code>my-snapshot-id</code> </p>
  ##   PubliclyAccessible: JBool
  ##                     : If <code>true</code>, the cluster can be accessed from a public network. 
  ##   ClusterParameterGroupName: JString
  ##                            : <p>The name of the parameter group to be associated with this cluster.</p> <p>Default: The default Amazon Redshift cluster parameter group. For information about the default parameter group, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Working with Amazon Redshift Parameter Groups</a>.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   HsmClientCertificateIdentifier: JString
  ##                                 : Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM.
  ##   SnapshotClusterIdentifier: JString
  ##                            : The name of the cluster the source snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.
  ##   AdditionalInfo: JString
  ##                 : Reserved.
  ##   SnapshotScheduleIdentifier: JString
  ##                             : A unique identifier for the snapshot schedule.
  ##   ElasticIp: JString
  ##            : The elastic IP (EIP) address for the cluster.
  ##   HsmConfigurationIdentifier: JString
  ##                             : Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The default number of days to retain a manual snapshot. If the value is -1, the snapshot is retained indefinitely. This setting doesn't change the retention period of existing snapshots.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  section = newJObject()
  var valid_614460 = formData.getOrDefault("Port")
  valid_614460 = validateParameter(valid_614460, JInt, required = false, default = nil)
  if valid_614460 != nil:
    section.add "Port", valid_614460
  var valid_614461 = formData.getOrDefault("PreferredMaintenanceWindow")
  valid_614461 = validateParameter(valid_614461, JString, required = false,
                                 default = nil)
  if valid_614461 != nil:
    section.add "PreferredMaintenanceWindow", valid_614461
  var valid_614462 = formData.getOrDefault("NodeType")
  valid_614462 = validateParameter(valid_614462, JString, required = false,
                                 default = nil)
  if valid_614462 != nil:
    section.add "NodeType", valid_614462
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_614463 = formData.getOrDefault("ClusterIdentifier")
  valid_614463 = validateParameter(valid_614463, JString, required = true,
                                 default = nil)
  if valid_614463 != nil:
    section.add "ClusterIdentifier", valid_614463
  var valid_614464 = formData.getOrDefault("MaintenanceTrackName")
  valid_614464 = validateParameter(valid_614464, JString, required = false,
                                 default = nil)
  if valid_614464 != nil:
    section.add "MaintenanceTrackName", valid_614464
  var valid_614465 = formData.getOrDefault("ClusterSecurityGroups")
  valid_614465 = validateParameter(valid_614465, JArray, required = false,
                                 default = nil)
  if valid_614465 != nil:
    section.add "ClusterSecurityGroups", valid_614465
  var valid_614466 = formData.getOrDefault("IamRoles")
  valid_614466 = validateParameter(valid_614466, JArray, required = false,
                                 default = nil)
  if valid_614466 != nil:
    section.add "IamRoles", valid_614466
  var valid_614467 = formData.getOrDefault("OwnerAccount")
  valid_614467 = validateParameter(valid_614467, JString, required = false,
                                 default = nil)
  if valid_614467 != nil:
    section.add "OwnerAccount", valid_614467
  var valid_614468 = formData.getOrDefault("VpcSecurityGroupIds")
  valid_614468 = validateParameter(valid_614468, JArray, required = false,
                                 default = nil)
  if valid_614468 != nil:
    section.add "VpcSecurityGroupIds", valid_614468
  var valid_614469 = formData.getOrDefault("AutomatedSnapshotRetentionPeriod")
  valid_614469 = validateParameter(valid_614469, JInt, required = false, default = nil)
  if valid_614469 != nil:
    section.add "AutomatedSnapshotRetentionPeriod", valid_614469
  var valid_614470 = formData.getOrDefault("AvailabilityZone")
  valid_614470 = validateParameter(valid_614470, JString, required = false,
                                 default = nil)
  if valid_614470 != nil:
    section.add "AvailabilityZone", valid_614470
  var valid_614471 = formData.getOrDefault("EnhancedVpcRouting")
  valid_614471 = validateParameter(valid_614471, JBool, required = false, default = nil)
  if valid_614471 != nil:
    section.add "EnhancedVpcRouting", valid_614471
  var valid_614472 = formData.getOrDefault("KmsKeyId")
  valid_614472 = validateParameter(valid_614472, JString, required = false,
                                 default = nil)
  if valid_614472 != nil:
    section.add "KmsKeyId", valid_614472
  var valid_614473 = formData.getOrDefault("NumberOfNodes")
  valid_614473 = validateParameter(valid_614473, JInt, required = false, default = nil)
  if valid_614473 != nil:
    section.add "NumberOfNodes", valid_614473
  var valid_614474 = formData.getOrDefault("ClusterSubnetGroupName")
  valid_614474 = validateParameter(valid_614474, JString, required = false,
                                 default = nil)
  if valid_614474 != nil:
    section.add "ClusterSubnetGroupName", valid_614474
  var valid_614475 = formData.getOrDefault("AllowVersionUpgrade")
  valid_614475 = validateParameter(valid_614475, JBool, required = false, default = nil)
  if valid_614475 != nil:
    section.add "AllowVersionUpgrade", valid_614475
  var valid_614476 = formData.getOrDefault("SnapshotIdentifier")
  valid_614476 = validateParameter(valid_614476, JString, required = true,
                                 default = nil)
  if valid_614476 != nil:
    section.add "SnapshotIdentifier", valid_614476
  var valid_614477 = formData.getOrDefault("PubliclyAccessible")
  valid_614477 = validateParameter(valid_614477, JBool, required = false, default = nil)
  if valid_614477 != nil:
    section.add "PubliclyAccessible", valid_614477
  var valid_614478 = formData.getOrDefault("ClusterParameterGroupName")
  valid_614478 = validateParameter(valid_614478, JString, required = false,
                                 default = nil)
  if valid_614478 != nil:
    section.add "ClusterParameterGroupName", valid_614478
  var valid_614479 = formData.getOrDefault("HsmClientCertificateIdentifier")
  valid_614479 = validateParameter(valid_614479, JString, required = false,
                                 default = nil)
  if valid_614479 != nil:
    section.add "HsmClientCertificateIdentifier", valid_614479
  var valid_614480 = formData.getOrDefault("SnapshotClusterIdentifier")
  valid_614480 = validateParameter(valid_614480, JString, required = false,
                                 default = nil)
  if valid_614480 != nil:
    section.add "SnapshotClusterIdentifier", valid_614480
  var valid_614481 = formData.getOrDefault("AdditionalInfo")
  valid_614481 = validateParameter(valid_614481, JString, required = false,
                                 default = nil)
  if valid_614481 != nil:
    section.add "AdditionalInfo", valid_614481
  var valid_614482 = formData.getOrDefault("SnapshotScheduleIdentifier")
  valid_614482 = validateParameter(valid_614482, JString, required = false,
                                 default = nil)
  if valid_614482 != nil:
    section.add "SnapshotScheduleIdentifier", valid_614482
  var valid_614483 = formData.getOrDefault("ElasticIp")
  valid_614483 = validateParameter(valid_614483, JString, required = false,
                                 default = nil)
  if valid_614483 != nil:
    section.add "ElasticIp", valid_614483
  var valid_614484 = formData.getOrDefault("HsmConfigurationIdentifier")
  valid_614484 = validateParameter(valid_614484, JString, required = false,
                                 default = nil)
  if valid_614484 != nil:
    section.add "HsmConfigurationIdentifier", valid_614484
  var valid_614485 = formData.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_614485 = validateParameter(valid_614485, JInt, required = false, default = nil)
  if valid_614485 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_614485
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614486: Call_PostRestoreFromClusterSnapshot_614448; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a new cluster from a snapshot. By default, Amazon Redshift creates the resulting cluster with the same configuration as the original cluster from which the snapshot was created, except that the new cluster is created with the default cluster security and parameter groups. After Amazon Redshift creates the cluster, you can use the <a>ModifyCluster</a> API to associate a different security group and different parameter group with the restored cluster. If you are using a DS node type, you can also choose to change to another DS node type of the same size during restore.</p> <p>If you restore a cluster into a VPC, you must provide a cluster subnet group where you want the cluster restored.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_614486.validator(path, query, header, formData, body)
  let scheme = call_614486.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614486.url(scheme.get, call_614486.host, call_614486.base,
                         call_614486.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614486, url, valid)

proc call*(call_614487: Call_PostRestoreFromClusterSnapshot_614448;
          ClusterIdentifier: string; SnapshotIdentifier: string; Port: int = 0;
          PreferredMaintenanceWindow: string = ""; NodeType: string = "";
          MaintenanceTrackName: string = ""; ClusterSecurityGroups: JsonNode = nil;
          IamRoles: JsonNode = nil; OwnerAccount: string = "";
          VpcSecurityGroupIds: JsonNode = nil;
          AutomatedSnapshotRetentionPeriod: int = 0; AvailabilityZone: string = "";
          EnhancedVpcRouting: bool = false; KmsKeyId: string = "";
          NumberOfNodes: int = 0; ClusterSubnetGroupName: string = "";
          AllowVersionUpgrade: bool = false; PubliclyAccessible: bool = false;
          Action: string = "RestoreFromClusterSnapshot";
          ClusterParameterGroupName: string = "";
          HsmClientCertificateIdentifier: string = "";
          SnapshotClusterIdentifier: string = ""; AdditionalInfo: string = "";
          SnapshotScheduleIdentifier: string = ""; Version: string = "2012-12-01";
          ElasticIp: string = ""; HsmConfigurationIdentifier: string = "";
          ManualSnapshotRetentionPeriod: int = 0): Recallable =
  ## postRestoreFromClusterSnapshot
  ## <p>Creates a new cluster from a snapshot. By default, Amazon Redshift creates the resulting cluster with the same configuration as the original cluster from which the snapshot was created, except that the new cluster is created with the default cluster security and parameter groups. After Amazon Redshift creates the cluster, you can use the <a>ModifyCluster</a> API to associate a different security group and different parameter group with the restored cluster. If you are using a DS node type, you can also choose to change to another DS node type of the same size during restore.</p> <p>If you restore a cluster into a VPC, you must provide a cluster subnet group where you want the cluster restored.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   Port: int
  ##       : <p>The port number on which the cluster accepts connections.</p> <p>Default: The same port as the original cluster.</p> <p>Constraints: Must be between <code>1115</code> and <code>65535</code>.</p>
  ##   PreferredMaintenanceWindow: string
  ##                             : <p>The weekly time range (in UTC) during which automated cluster maintenance can occur.</p> <p> Format: <code>ddd:hh24:mi-ddd:hh24:mi</code> </p> <p> Default: The value selected for the cluster from which the snapshot was taken. For more information about the time blocks for each region, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-maintenance-windows">Maintenance Windows</a> in Amazon Redshift Cluster Management Guide. </p> <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p> <p>Constraints: Minimum 30-minute window.</p>
  ##   NodeType: string
  ##           : <p>The node type that the restored cluster will be provisioned with.</p> <p>Default: The node type of the cluster from which the snapshot was taken. You can modify this if you are using any DS node type. In that case, you can choose to restore into another DS node type of the same size. For example, you can restore ds1.8xlarge into ds2.8xlarge, or ds1.xlarge into ds2.xlarge. If you have a DC instance type, you must restore into that same instance type and size. In other words, you can only restore a dc1.large instance type into another dc1.large instance type or dc2.large instance type. You can't restore dc1.8xlarge to dc2.8xlarge. First restore to a dc1.8xlareg cluster, then resize to a dc2.8large cluster. For more information about node types, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-about-clusters-and-nodes"> About Clusters and Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The identifier of the cluster that will be created from restoring the snapshot.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul>
  ##   MaintenanceTrackName: string
  ##                       : The name of the maintenance track for the restored cluster. When you take a snapshot, the snapshot inherits the <code>MaintenanceTrack</code> value from the cluster. The snapshot might be on a different track than the cluster that was the source for the snapshot. For example, suppose that you take a snapshot of a cluster that is on the current track and then change the cluster to be on the trailing track. In this case, the snapshot and the source cluster are on different tracks.
  ##   ClusterSecurityGroups: JArray
  ##                        : <p>A list of security groups to be associated with this cluster.</p> <p>Default: The default cluster security group for Amazon Redshift.</p> <p>Cluster security groups only apply to clusters outside of VPCs.</p>
  ##   IamRoles: JArray
  ##           : <p>A list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services. You must supply the IAM roles in their Amazon Resource Name (ARN) format. You can supply up to 10 IAM roles in a single request.</p> <p>A cluster can have up to 10 IAM roles associated at any time.</p>
  ##   OwnerAccount: string
  ##               : The AWS customer account used to create or copy the snapshot. Required if you are restoring a snapshot you do not own, optional if you own the snapshot.
  ##   VpcSecurityGroupIds: JArray
  ##                      : <p>A list of Virtual Private Cloud (VPC) security groups to be associated with the cluster.</p> <p>Default: The default VPC security group is associated with the cluster.</p> <p>VPC security groups only apply to clusters in VPCs.</p>
  ##   AutomatedSnapshotRetentionPeriod: int
  ##                                   : <p>The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p> <p>Default: The value selected for the cluster from which the snapshot was taken.</p> <p>Constraints: Must be a value from 0 to 35.</p>
  ##   AvailabilityZone: string
  ##                   : <p>The Amazon EC2 Availability Zone in which to restore the cluster.</p> <p>Default: A random, system-chosen Availability Zone.</p> <p>Example: <code>us-east-2a</code> </p>
  ##   EnhancedVpcRouting: bool
  ##                     : <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p> <p>Default: false</p>
  ##   KmsKeyId: string
  ##           : The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster that you restore from a shared snapshot.
  ##   NumberOfNodes: int
  ##                : The number of nodes specified when provisioning the restored cluster.
  ##   ClusterSubnetGroupName: string
  ##                         : <p>The name of the subnet group where you want to cluster restored.</p> <p>A snapshot of cluster in VPC can be restored only in VPC. Therefore, you must provide subnet group name where you want the cluster restored.</p>
  ##   AllowVersionUpgrade: bool
  ##                      : <p>If <code>true</code>, major version upgrades can be applied during the maintenance window to the Amazon Redshift engine that is running on the cluster. </p> <p>Default: <code>true</code> </p>
  ##   SnapshotIdentifier: string (required)
  ##                     : <p>The name of the snapshot from which to create the new cluster. This parameter isn't case sensitive.</p> <p>Example: <code>my-snapshot-id</code> </p>
  ##   PubliclyAccessible: bool
  ##                     : If <code>true</code>, the cluster can be accessed from a public network. 
  ##   Action: string (required)
  ##   ClusterParameterGroupName: string
  ##                            : <p>The name of the parameter group to be associated with this cluster.</p> <p>Default: The default Amazon Redshift cluster parameter group. For information about the default parameter group, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Working with Amazon Redshift Parameter Groups</a>.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   HsmClientCertificateIdentifier: string
  ##                                 : Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM.
  ##   SnapshotClusterIdentifier: string
  ##                            : The name of the cluster the source snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.
  ##   AdditionalInfo: string
  ##                 : Reserved.
  ##   SnapshotScheduleIdentifier: string
  ##                             : A unique identifier for the snapshot schedule.
  ##   Version: string (required)
  ##   ElasticIp: string
  ##            : The elastic IP (EIP) address for the cluster.
  ##   HsmConfigurationIdentifier: string
  ##                             : Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The default number of days to retain a manual snapshot. If the value is -1, the snapshot is retained indefinitely. This setting doesn't change the retention period of existing snapshots.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  var query_614488 = newJObject()
  var formData_614489 = newJObject()
  add(formData_614489, "Port", newJInt(Port))
  add(formData_614489, "PreferredMaintenanceWindow",
      newJString(PreferredMaintenanceWindow))
  add(formData_614489, "NodeType", newJString(NodeType))
  add(formData_614489, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_614489, "MaintenanceTrackName", newJString(MaintenanceTrackName))
  if ClusterSecurityGroups != nil:
    formData_614489.add "ClusterSecurityGroups", ClusterSecurityGroups
  if IamRoles != nil:
    formData_614489.add "IamRoles", IamRoles
  add(formData_614489, "OwnerAccount", newJString(OwnerAccount))
  if VpcSecurityGroupIds != nil:
    formData_614489.add "VpcSecurityGroupIds", VpcSecurityGroupIds
  add(formData_614489, "AutomatedSnapshotRetentionPeriod",
      newJInt(AutomatedSnapshotRetentionPeriod))
  add(formData_614489, "AvailabilityZone", newJString(AvailabilityZone))
  add(formData_614489, "EnhancedVpcRouting", newJBool(EnhancedVpcRouting))
  add(formData_614489, "KmsKeyId", newJString(KmsKeyId))
  add(formData_614489, "NumberOfNodes", newJInt(NumberOfNodes))
  add(formData_614489, "ClusterSubnetGroupName",
      newJString(ClusterSubnetGroupName))
  add(formData_614489, "AllowVersionUpgrade", newJBool(AllowVersionUpgrade))
  add(formData_614489, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(formData_614489, "PubliclyAccessible", newJBool(PubliclyAccessible))
  add(query_614488, "Action", newJString(Action))
  add(formData_614489, "ClusterParameterGroupName",
      newJString(ClusterParameterGroupName))
  add(formData_614489, "HsmClientCertificateIdentifier",
      newJString(HsmClientCertificateIdentifier))
  add(formData_614489, "SnapshotClusterIdentifier",
      newJString(SnapshotClusterIdentifier))
  add(formData_614489, "AdditionalInfo", newJString(AdditionalInfo))
  add(formData_614489, "SnapshotScheduleIdentifier",
      newJString(SnapshotScheduleIdentifier))
  add(query_614488, "Version", newJString(Version))
  add(formData_614489, "ElasticIp", newJString(ElasticIp))
  add(formData_614489, "HsmConfigurationIdentifier",
      newJString(HsmConfigurationIdentifier))
  add(formData_614489, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  result = call_614487.call(nil, query_614488, nil, formData_614489, nil)

var postRestoreFromClusterSnapshot* = Call_PostRestoreFromClusterSnapshot_614448(
    name: "postRestoreFromClusterSnapshot", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=RestoreFromClusterSnapshot",
    validator: validate_PostRestoreFromClusterSnapshot_614449, base: "/",
    url: url_PostRestoreFromClusterSnapshot_614450,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetRestoreFromClusterSnapshot_614407 = ref object of OpenApiRestCall_610642
proc url_GetRestoreFromClusterSnapshot_614409(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetRestoreFromClusterSnapshot_614408(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a new cluster from a snapshot. By default, Amazon Redshift creates the resulting cluster with the same configuration as the original cluster from which the snapshot was created, except that the new cluster is created with the default cluster security and parameter groups. After Amazon Redshift creates the cluster, you can use the <a>ModifyCluster</a> API to associate a different security group and different parameter group with the restored cluster. If you are using a DS node type, you can also choose to change to another DS node type of the same size during restore.</p> <p>If you restore a cluster into a VPC, you must provide a cluster subnet group where you want the cluster restored.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ClusterSubnetGroupName: JString
  ##                         : <p>The name of the subnet group where you want to cluster restored.</p> <p>A snapshot of cluster in VPC can be restored only in VPC. Therefore, you must provide subnet group name where you want the cluster restored.</p>
  ##   MaintenanceTrackName: JString
  ##                       : The name of the maintenance track for the restored cluster. When you take a snapshot, the snapshot inherits the <code>MaintenanceTrack</code> value from the cluster. The snapshot might be on a different track than the cluster that was the source for the snapshot. For example, suppose that you take a snapshot of a cluster that is on the current track and then change the cluster to be on the trailing track. In this case, the snapshot and the source cluster are on different tracks.
  ##   SnapshotIdentifier: JString (required)
  ##                     : <p>The name of the snapshot from which to create the new cluster. This parameter isn't case sensitive.</p> <p>Example: <code>my-snapshot-id</code> </p>
  ##   HsmClientCertificateIdentifier: JString
  ##                                 : Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM.
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The default number of days to retain a manual snapshot. If the value is -1, the snapshot is retained indefinitely. This setting doesn't change the retention period of existing snapshots.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  ##   ClusterSecurityGroups: JArray
  ##                        : <p>A list of security groups to be associated with this cluster.</p> <p>Default: The default cluster security group for Amazon Redshift.</p> <p>Cluster security groups only apply to clusters outside of VPCs.</p>
  ##   KmsKeyId: JString
  ##           : The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster that you restore from a shared snapshot.
  ##   ClusterParameterGroupName: JString
  ##                            : <p>The name of the parameter group to be associated with this cluster.</p> <p>Default: The default Amazon Redshift cluster parameter group. For information about the default parameter group, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Working with Amazon Redshift Parameter Groups</a>.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   NodeType: JString
  ##           : <p>The node type that the restored cluster will be provisioned with.</p> <p>Default: The node type of the cluster from which the snapshot was taken. You can modify this if you are using any DS node type. In that case, you can choose to restore into another DS node type of the same size. For example, you can restore ds1.8xlarge into ds2.8xlarge, or ds1.xlarge into ds2.xlarge. If you have a DC instance type, you must restore into that same instance type and size. In other words, you can only restore a dc1.large instance type into another dc1.large instance type or dc2.large instance type. You can't restore dc1.8xlarge to dc2.8xlarge. First restore to a dc1.8xlareg cluster, then resize to a dc2.8large cluster. For more information about node types, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-about-clusters-and-nodes"> About Clusters and Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ##   SnapshotScheduleIdentifier: JString
  ##                             : A unique identifier for the snapshot schedule.
  ##   IamRoles: JArray
  ##           : <p>A list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services. You must supply the IAM roles in their Amazon Resource Name (ARN) format. You can supply up to 10 IAM roles in a single request.</p> <p>A cluster can have up to 10 IAM roles associated at any time.</p>
  ##   NumberOfNodes: JInt
  ##                : The number of nodes specified when provisioning the restored cluster.
  ##   AdditionalInfo: JString
  ##                 : Reserved.
  ##   SnapshotClusterIdentifier: JString
  ##                            : The name of the cluster the source snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.
  ##   AllowVersionUpgrade: JBool
  ##                      : <p>If <code>true</code>, major version upgrades can be applied during the maintenance window to the Amazon Redshift engine that is running on the cluster. </p> <p>Default: <code>true</code> </p>
  ##   ElasticIp: JString
  ##            : The elastic IP (EIP) address for the cluster.
  ##   AutomatedSnapshotRetentionPeriod: JInt
  ##                                   : <p>The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p> <p>Default: The value selected for the cluster from which the snapshot was taken.</p> <p>Constraints: Must be a value from 0 to 35.</p>
  ##   EnhancedVpcRouting: JBool
  ##                     : <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p> <p>Default: false</p>
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The identifier of the cluster that will be created from restoring the snapshot.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul>
  ##   Port: JInt
  ##       : <p>The port number on which the cluster accepts connections.</p> <p>Default: The same port as the original cluster.</p> <p>Constraints: Must be between <code>1115</code> and <code>65535</code>.</p>
  ##   VpcSecurityGroupIds: JArray
  ##                      : <p>A list of Virtual Private Cloud (VPC) security groups to be associated with the cluster.</p> <p>Default: The default VPC security group is associated with the cluster.</p> <p>VPC security groups only apply to clusters in VPCs.</p>
  ##   AvailabilityZone: JString
  ##                   : <p>The Amazon EC2 Availability Zone in which to restore the cluster.</p> <p>Default: A random, system-chosen Availability Zone.</p> <p>Example: <code>us-east-2a</code> </p>
  ##   HsmConfigurationIdentifier: JString
  ##                             : Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
  ##   OwnerAccount: JString
  ##               : The AWS customer account used to create or copy the snapshot. Required if you are restoring a snapshot you do not own, optional if you own the snapshot.
  ##   Version: JString (required)
  ##   PreferredMaintenanceWindow: JString
  ##                             : <p>The weekly time range (in UTC) during which automated cluster maintenance can occur.</p> <p> Format: <code>ddd:hh24:mi-ddd:hh24:mi</code> </p> <p> Default: The value selected for the cluster from which the snapshot was taken. For more information about the time blocks for each region, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-maintenance-windows">Maintenance Windows</a> in Amazon Redshift Cluster Management Guide. </p> <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p> <p>Constraints: Minimum 30-minute window.</p>
  ##   PubliclyAccessible: JBool
  ##                     : If <code>true</code>, the cluster can be accessed from a public network. 
  section = newJObject()
  var valid_614410 = query.getOrDefault("ClusterSubnetGroupName")
  valid_614410 = validateParameter(valid_614410, JString, required = false,
                                 default = nil)
  if valid_614410 != nil:
    section.add "ClusterSubnetGroupName", valid_614410
  var valid_614411 = query.getOrDefault("MaintenanceTrackName")
  valid_614411 = validateParameter(valid_614411, JString, required = false,
                                 default = nil)
  if valid_614411 != nil:
    section.add "MaintenanceTrackName", valid_614411
  assert query != nil, "query argument is necessary due to required `SnapshotIdentifier` field"
  var valid_614412 = query.getOrDefault("SnapshotIdentifier")
  valid_614412 = validateParameter(valid_614412, JString, required = true,
                                 default = nil)
  if valid_614412 != nil:
    section.add "SnapshotIdentifier", valid_614412
  var valid_614413 = query.getOrDefault("HsmClientCertificateIdentifier")
  valid_614413 = validateParameter(valid_614413, JString, required = false,
                                 default = nil)
  if valid_614413 != nil:
    section.add "HsmClientCertificateIdentifier", valid_614413
  var valid_614414 = query.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_614414 = validateParameter(valid_614414, JInt, required = false, default = nil)
  if valid_614414 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_614414
  var valid_614415 = query.getOrDefault("ClusterSecurityGroups")
  valid_614415 = validateParameter(valid_614415, JArray, required = false,
                                 default = nil)
  if valid_614415 != nil:
    section.add "ClusterSecurityGroups", valid_614415
  var valid_614416 = query.getOrDefault("KmsKeyId")
  valid_614416 = validateParameter(valid_614416, JString, required = false,
                                 default = nil)
  if valid_614416 != nil:
    section.add "KmsKeyId", valid_614416
  var valid_614417 = query.getOrDefault("ClusterParameterGroupName")
  valid_614417 = validateParameter(valid_614417, JString, required = false,
                                 default = nil)
  if valid_614417 != nil:
    section.add "ClusterParameterGroupName", valid_614417
  var valid_614418 = query.getOrDefault("NodeType")
  valid_614418 = validateParameter(valid_614418, JString, required = false,
                                 default = nil)
  if valid_614418 != nil:
    section.add "NodeType", valid_614418
  var valid_614419 = query.getOrDefault("SnapshotScheduleIdentifier")
  valid_614419 = validateParameter(valid_614419, JString, required = false,
                                 default = nil)
  if valid_614419 != nil:
    section.add "SnapshotScheduleIdentifier", valid_614419
  var valid_614420 = query.getOrDefault("IamRoles")
  valid_614420 = validateParameter(valid_614420, JArray, required = false,
                                 default = nil)
  if valid_614420 != nil:
    section.add "IamRoles", valid_614420
  var valid_614421 = query.getOrDefault("NumberOfNodes")
  valid_614421 = validateParameter(valid_614421, JInt, required = false, default = nil)
  if valid_614421 != nil:
    section.add "NumberOfNodes", valid_614421
  var valid_614422 = query.getOrDefault("AdditionalInfo")
  valid_614422 = validateParameter(valid_614422, JString, required = false,
                                 default = nil)
  if valid_614422 != nil:
    section.add "AdditionalInfo", valid_614422
  var valid_614423 = query.getOrDefault("SnapshotClusterIdentifier")
  valid_614423 = validateParameter(valid_614423, JString, required = false,
                                 default = nil)
  if valid_614423 != nil:
    section.add "SnapshotClusterIdentifier", valid_614423
  var valid_614424 = query.getOrDefault("AllowVersionUpgrade")
  valid_614424 = validateParameter(valid_614424, JBool, required = false, default = nil)
  if valid_614424 != nil:
    section.add "AllowVersionUpgrade", valid_614424
  var valid_614425 = query.getOrDefault("ElasticIp")
  valid_614425 = validateParameter(valid_614425, JString, required = false,
                                 default = nil)
  if valid_614425 != nil:
    section.add "ElasticIp", valid_614425
  var valid_614426 = query.getOrDefault("AutomatedSnapshotRetentionPeriod")
  valid_614426 = validateParameter(valid_614426, JInt, required = false, default = nil)
  if valid_614426 != nil:
    section.add "AutomatedSnapshotRetentionPeriod", valid_614426
  var valid_614427 = query.getOrDefault("EnhancedVpcRouting")
  valid_614427 = validateParameter(valid_614427, JBool, required = false, default = nil)
  if valid_614427 != nil:
    section.add "EnhancedVpcRouting", valid_614427
  var valid_614428 = query.getOrDefault("Action")
  valid_614428 = validateParameter(valid_614428, JString, required = true, default = newJString(
      "RestoreFromClusterSnapshot"))
  if valid_614428 != nil:
    section.add "Action", valid_614428
  var valid_614429 = query.getOrDefault("ClusterIdentifier")
  valid_614429 = validateParameter(valid_614429, JString, required = true,
                                 default = nil)
  if valid_614429 != nil:
    section.add "ClusterIdentifier", valid_614429
  var valid_614430 = query.getOrDefault("Port")
  valid_614430 = validateParameter(valid_614430, JInt, required = false, default = nil)
  if valid_614430 != nil:
    section.add "Port", valid_614430
  var valid_614431 = query.getOrDefault("VpcSecurityGroupIds")
  valid_614431 = validateParameter(valid_614431, JArray, required = false,
                                 default = nil)
  if valid_614431 != nil:
    section.add "VpcSecurityGroupIds", valid_614431
  var valid_614432 = query.getOrDefault("AvailabilityZone")
  valid_614432 = validateParameter(valid_614432, JString, required = false,
                                 default = nil)
  if valid_614432 != nil:
    section.add "AvailabilityZone", valid_614432
  var valid_614433 = query.getOrDefault("HsmConfigurationIdentifier")
  valid_614433 = validateParameter(valid_614433, JString, required = false,
                                 default = nil)
  if valid_614433 != nil:
    section.add "HsmConfigurationIdentifier", valid_614433
  var valid_614434 = query.getOrDefault("OwnerAccount")
  valid_614434 = validateParameter(valid_614434, JString, required = false,
                                 default = nil)
  if valid_614434 != nil:
    section.add "OwnerAccount", valid_614434
  var valid_614435 = query.getOrDefault("Version")
  valid_614435 = validateParameter(valid_614435, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_614435 != nil:
    section.add "Version", valid_614435
  var valid_614436 = query.getOrDefault("PreferredMaintenanceWindow")
  valid_614436 = validateParameter(valid_614436, JString, required = false,
                                 default = nil)
  if valid_614436 != nil:
    section.add "PreferredMaintenanceWindow", valid_614436
  var valid_614437 = query.getOrDefault("PubliclyAccessible")
  valid_614437 = validateParameter(valid_614437, JBool, required = false, default = nil)
  if valid_614437 != nil:
    section.add "PubliclyAccessible", valid_614437
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614438 = header.getOrDefault("X-Amz-Signature")
  valid_614438 = validateParameter(valid_614438, JString, required = false,
                                 default = nil)
  if valid_614438 != nil:
    section.add "X-Amz-Signature", valid_614438
  var valid_614439 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614439 = validateParameter(valid_614439, JString, required = false,
                                 default = nil)
  if valid_614439 != nil:
    section.add "X-Amz-Content-Sha256", valid_614439
  var valid_614440 = header.getOrDefault("X-Amz-Date")
  valid_614440 = validateParameter(valid_614440, JString, required = false,
                                 default = nil)
  if valid_614440 != nil:
    section.add "X-Amz-Date", valid_614440
  var valid_614441 = header.getOrDefault("X-Amz-Credential")
  valid_614441 = validateParameter(valid_614441, JString, required = false,
                                 default = nil)
  if valid_614441 != nil:
    section.add "X-Amz-Credential", valid_614441
  var valid_614442 = header.getOrDefault("X-Amz-Security-Token")
  valid_614442 = validateParameter(valid_614442, JString, required = false,
                                 default = nil)
  if valid_614442 != nil:
    section.add "X-Amz-Security-Token", valid_614442
  var valid_614443 = header.getOrDefault("X-Amz-Algorithm")
  valid_614443 = validateParameter(valid_614443, JString, required = false,
                                 default = nil)
  if valid_614443 != nil:
    section.add "X-Amz-Algorithm", valid_614443
  var valid_614444 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614444 = validateParameter(valid_614444, JString, required = false,
                                 default = nil)
  if valid_614444 != nil:
    section.add "X-Amz-SignedHeaders", valid_614444
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614445: Call_GetRestoreFromClusterSnapshot_614407; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a new cluster from a snapshot. By default, Amazon Redshift creates the resulting cluster with the same configuration as the original cluster from which the snapshot was created, except that the new cluster is created with the default cluster security and parameter groups. After Amazon Redshift creates the cluster, you can use the <a>ModifyCluster</a> API to associate a different security group and different parameter group with the restored cluster. If you are using a DS node type, you can also choose to change to another DS node type of the same size during restore.</p> <p>If you restore a cluster into a VPC, you must provide a cluster subnet group where you want the cluster restored.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_614445.validator(path, query, header, formData, body)
  let scheme = call_614445.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614445.url(scheme.get, call_614445.host, call_614445.base,
                         call_614445.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614445, url, valid)

proc call*(call_614446: Call_GetRestoreFromClusterSnapshot_614407;
          SnapshotIdentifier: string; ClusterIdentifier: string;
          ClusterSubnetGroupName: string = ""; MaintenanceTrackName: string = "";
          HsmClientCertificateIdentifier: string = "";
          ManualSnapshotRetentionPeriod: int = 0;
          ClusterSecurityGroups: JsonNode = nil; KmsKeyId: string = "";
          ClusterParameterGroupName: string = ""; NodeType: string = "";
          SnapshotScheduleIdentifier: string = ""; IamRoles: JsonNode = nil;
          NumberOfNodes: int = 0; AdditionalInfo: string = "";
          SnapshotClusterIdentifier: string = ""; AllowVersionUpgrade: bool = false;
          ElasticIp: string = ""; AutomatedSnapshotRetentionPeriod: int = 0;
          EnhancedVpcRouting: bool = false;
          Action: string = "RestoreFromClusterSnapshot"; Port: int = 0;
          VpcSecurityGroupIds: JsonNode = nil; AvailabilityZone: string = "";
          HsmConfigurationIdentifier: string = ""; OwnerAccount: string = "";
          Version: string = "2012-12-01"; PreferredMaintenanceWindow: string = "";
          PubliclyAccessible: bool = false): Recallable =
  ## getRestoreFromClusterSnapshot
  ## <p>Creates a new cluster from a snapshot. By default, Amazon Redshift creates the resulting cluster with the same configuration as the original cluster from which the snapshot was created, except that the new cluster is created with the default cluster security and parameter groups. After Amazon Redshift creates the cluster, you can use the <a>ModifyCluster</a> API to associate a different security group and different parameter group with the restored cluster. If you are using a DS node type, you can also choose to change to another DS node type of the same size during restore.</p> <p>If you restore a cluster into a VPC, you must provide a cluster subnet group where you want the cluster restored.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   ClusterSubnetGroupName: string
  ##                         : <p>The name of the subnet group where you want to cluster restored.</p> <p>A snapshot of cluster in VPC can be restored only in VPC. Therefore, you must provide subnet group name where you want the cluster restored.</p>
  ##   MaintenanceTrackName: string
  ##                       : The name of the maintenance track for the restored cluster. When you take a snapshot, the snapshot inherits the <code>MaintenanceTrack</code> value from the cluster. The snapshot might be on a different track than the cluster that was the source for the snapshot. For example, suppose that you take a snapshot of a cluster that is on the current track and then change the cluster to be on the trailing track. In this case, the snapshot and the source cluster are on different tracks.
  ##   SnapshotIdentifier: string (required)
  ##                     : <p>The name of the snapshot from which to create the new cluster. This parameter isn't case sensitive.</p> <p>Example: <code>my-snapshot-id</code> </p>
  ##   HsmClientCertificateIdentifier: string
  ##                                 : Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM.
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The default number of days to retain a manual snapshot. If the value is -1, the snapshot is retained indefinitely. This setting doesn't change the retention period of existing snapshots.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  ##   ClusterSecurityGroups: JArray
  ##                        : <p>A list of security groups to be associated with this cluster.</p> <p>Default: The default cluster security group for Amazon Redshift.</p> <p>Cluster security groups only apply to clusters outside of VPCs.</p>
  ##   KmsKeyId: string
  ##           : The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster that you restore from a shared snapshot.
  ##   ClusterParameterGroupName: string
  ##                            : <p>The name of the parameter group to be associated with this cluster.</p> <p>Default: The default Amazon Redshift cluster parameter group. For information about the default parameter group, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Working with Amazon Redshift Parameter Groups</a>.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   NodeType: string
  ##           : <p>The node type that the restored cluster will be provisioned with.</p> <p>Default: The node type of the cluster from which the snapshot was taken. You can modify this if you are using any DS node type. In that case, you can choose to restore into another DS node type of the same size. For example, you can restore ds1.8xlarge into ds2.8xlarge, or ds1.xlarge into ds2.xlarge. If you have a DC instance type, you must restore into that same instance type and size. In other words, you can only restore a dc1.large instance type into another dc1.large instance type or dc2.large instance type. You can't restore dc1.8xlarge to dc2.8xlarge. First restore to a dc1.8xlareg cluster, then resize to a dc2.8large cluster. For more information about node types, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-about-clusters-and-nodes"> About Clusters and Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ##   SnapshotScheduleIdentifier: string
  ##                             : A unique identifier for the snapshot schedule.
  ##   IamRoles: JArray
  ##           : <p>A list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services. You must supply the IAM roles in their Amazon Resource Name (ARN) format. You can supply up to 10 IAM roles in a single request.</p> <p>A cluster can have up to 10 IAM roles associated at any time.</p>
  ##   NumberOfNodes: int
  ##                : The number of nodes specified when provisioning the restored cluster.
  ##   AdditionalInfo: string
  ##                 : Reserved.
  ##   SnapshotClusterIdentifier: string
  ##                            : The name of the cluster the source snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.
  ##   AllowVersionUpgrade: bool
  ##                      : <p>If <code>true</code>, major version upgrades can be applied during the maintenance window to the Amazon Redshift engine that is running on the cluster. </p> <p>Default: <code>true</code> </p>
  ##   ElasticIp: string
  ##            : The elastic IP (EIP) address for the cluster.
  ##   AutomatedSnapshotRetentionPeriod: int
  ##                                   : <p>The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p> <p>Default: The value selected for the cluster from which the snapshot was taken.</p> <p>Constraints: Must be a value from 0 to 35.</p>
  ##   EnhancedVpcRouting: bool
  ##                     : <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p> <p>Default: false</p>
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The identifier of the cluster that will be created from restoring the snapshot.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul>
  ##   Port: int
  ##       : <p>The port number on which the cluster accepts connections.</p> <p>Default: The same port as the original cluster.</p> <p>Constraints: Must be between <code>1115</code> and <code>65535</code>.</p>
  ##   VpcSecurityGroupIds: JArray
  ##                      : <p>A list of Virtual Private Cloud (VPC) security groups to be associated with the cluster.</p> <p>Default: The default VPC security group is associated with the cluster.</p> <p>VPC security groups only apply to clusters in VPCs.</p>
  ##   AvailabilityZone: string
  ##                   : <p>The Amazon EC2 Availability Zone in which to restore the cluster.</p> <p>Default: A random, system-chosen Availability Zone.</p> <p>Example: <code>us-east-2a</code> </p>
  ##   HsmConfigurationIdentifier: string
  ##                             : Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
  ##   OwnerAccount: string
  ##               : The AWS customer account used to create or copy the snapshot. Required if you are restoring a snapshot you do not own, optional if you own the snapshot.
  ##   Version: string (required)
  ##   PreferredMaintenanceWindow: string
  ##                             : <p>The weekly time range (in UTC) during which automated cluster maintenance can occur.</p> <p> Format: <code>ddd:hh24:mi-ddd:hh24:mi</code> </p> <p> Default: The value selected for the cluster from which the snapshot was taken. For more information about the time blocks for each region, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-maintenance-windows">Maintenance Windows</a> in Amazon Redshift Cluster Management Guide. </p> <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p> <p>Constraints: Minimum 30-minute window.</p>
  ##   PubliclyAccessible: bool
  ##                     : If <code>true</code>, the cluster can be accessed from a public network. 
  var query_614447 = newJObject()
  add(query_614447, "ClusterSubnetGroupName", newJString(ClusterSubnetGroupName))
  add(query_614447, "MaintenanceTrackName", newJString(MaintenanceTrackName))
  add(query_614447, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_614447, "HsmClientCertificateIdentifier",
      newJString(HsmClientCertificateIdentifier))
  add(query_614447, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  if ClusterSecurityGroups != nil:
    query_614447.add "ClusterSecurityGroups", ClusterSecurityGroups
  add(query_614447, "KmsKeyId", newJString(KmsKeyId))
  add(query_614447, "ClusterParameterGroupName",
      newJString(ClusterParameterGroupName))
  add(query_614447, "NodeType", newJString(NodeType))
  add(query_614447, "SnapshotScheduleIdentifier",
      newJString(SnapshotScheduleIdentifier))
  if IamRoles != nil:
    query_614447.add "IamRoles", IamRoles
  add(query_614447, "NumberOfNodes", newJInt(NumberOfNodes))
  add(query_614447, "AdditionalInfo", newJString(AdditionalInfo))
  add(query_614447, "SnapshotClusterIdentifier",
      newJString(SnapshotClusterIdentifier))
  add(query_614447, "AllowVersionUpgrade", newJBool(AllowVersionUpgrade))
  add(query_614447, "ElasticIp", newJString(ElasticIp))
  add(query_614447, "AutomatedSnapshotRetentionPeriod",
      newJInt(AutomatedSnapshotRetentionPeriod))
  add(query_614447, "EnhancedVpcRouting", newJBool(EnhancedVpcRouting))
  add(query_614447, "Action", newJString(Action))
  add(query_614447, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_614447, "Port", newJInt(Port))
  if VpcSecurityGroupIds != nil:
    query_614447.add "VpcSecurityGroupIds", VpcSecurityGroupIds
  add(query_614447, "AvailabilityZone", newJString(AvailabilityZone))
  add(query_614447, "HsmConfigurationIdentifier",
      newJString(HsmConfigurationIdentifier))
  add(query_614447, "OwnerAccount", newJString(OwnerAccount))
  add(query_614447, "Version", newJString(Version))
  add(query_614447, "PreferredMaintenanceWindow",
      newJString(PreferredMaintenanceWindow))
  add(query_614447, "PubliclyAccessible", newJBool(PubliclyAccessible))
  result = call_614446.call(nil, query_614447, nil, nil, nil)

var getRestoreFromClusterSnapshot* = Call_GetRestoreFromClusterSnapshot_614407(
    name: "getRestoreFromClusterSnapshot", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=RestoreFromClusterSnapshot",
    validator: validate_GetRestoreFromClusterSnapshot_614408, base: "/",
    url: url_GetRestoreFromClusterSnapshot_614409,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostRestoreTableFromClusterSnapshot_614513 = ref object of OpenApiRestCall_610642
proc url_PostRestoreTableFromClusterSnapshot_614515(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostRestoreTableFromClusterSnapshot_614514(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a new table from a table in an Amazon Redshift cluster snapshot. You must create the new table within the Amazon Redshift cluster that the snapshot was taken from.</p> <p>You cannot use <code>RestoreTableFromClusterSnapshot</code> to restore a table with the same name as an existing table in an Amazon Redshift cluster. That is, you cannot overwrite an existing table in a cluster with a restored table. If you want to replace your original table with a new, restored table, then rename or drop your original table before you call <code>RestoreTableFromClusterSnapshot</code>. When you have renamed your original table, then you can pass the original name of the table as the <code>NewTableName</code> parameter value in the call to <code>RestoreTableFromClusterSnapshot</code>. This way, you can replace the original table with the table created from the snapshot.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_614516 = query.getOrDefault("Action")
  valid_614516 = validateParameter(valid_614516, JString, required = true, default = newJString(
      "RestoreTableFromClusterSnapshot"))
  if valid_614516 != nil:
    section.add "Action", valid_614516
  var valid_614517 = query.getOrDefault("Version")
  valid_614517 = validateParameter(valid_614517, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_614517 != nil:
    section.add "Version", valid_614517
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614518 = header.getOrDefault("X-Amz-Signature")
  valid_614518 = validateParameter(valid_614518, JString, required = false,
                                 default = nil)
  if valid_614518 != nil:
    section.add "X-Amz-Signature", valid_614518
  var valid_614519 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614519 = validateParameter(valid_614519, JString, required = false,
                                 default = nil)
  if valid_614519 != nil:
    section.add "X-Amz-Content-Sha256", valid_614519
  var valid_614520 = header.getOrDefault("X-Amz-Date")
  valid_614520 = validateParameter(valid_614520, JString, required = false,
                                 default = nil)
  if valid_614520 != nil:
    section.add "X-Amz-Date", valid_614520
  var valid_614521 = header.getOrDefault("X-Amz-Credential")
  valid_614521 = validateParameter(valid_614521, JString, required = false,
                                 default = nil)
  if valid_614521 != nil:
    section.add "X-Amz-Credential", valid_614521
  var valid_614522 = header.getOrDefault("X-Amz-Security-Token")
  valid_614522 = validateParameter(valid_614522, JString, required = false,
                                 default = nil)
  if valid_614522 != nil:
    section.add "X-Amz-Security-Token", valid_614522
  var valid_614523 = header.getOrDefault("X-Amz-Algorithm")
  valid_614523 = validateParameter(valid_614523, JString, required = false,
                                 default = nil)
  if valid_614523 != nil:
    section.add "X-Amz-Algorithm", valid_614523
  var valid_614524 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614524 = validateParameter(valid_614524, JString, required = false,
                                 default = nil)
  if valid_614524 != nil:
    section.add "X-Amz-SignedHeaders", valid_614524
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : The identifier of the Amazon Redshift cluster to restore the table to.
  ##   NewTableName: JString (required)
  ##               : The name of the table to create as a result of the current request.
  ##   TargetSchemaName: JString
  ##                   : The name of the schema to restore the table to.
  ##   TargetDatabaseName: JString
  ##                     : The name of the database to restore the table to.
  ##   SnapshotIdentifier: JString (required)
  ##                     : The identifier of the snapshot to restore the table from. This snapshot must have been created from the Amazon Redshift cluster specified by the <code>ClusterIdentifier</code> parameter.
  ##   SourceDatabaseName: JString (required)
  ##                     : The name of the source database that contains the table to restore from.
  ##   SourceSchemaName: JString
  ##                   : The name of the source schema that contains the table to restore from. If you do not specify a <code>SourceSchemaName</code> value, the default is <code>public</code>.
  ##   SourceTableName: JString (required)
  ##                  : The name of the source table to restore from.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_614525 = formData.getOrDefault("ClusterIdentifier")
  valid_614525 = validateParameter(valid_614525, JString, required = true,
                                 default = nil)
  if valid_614525 != nil:
    section.add "ClusterIdentifier", valid_614525
  var valid_614526 = formData.getOrDefault("NewTableName")
  valid_614526 = validateParameter(valid_614526, JString, required = true,
                                 default = nil)
  if valid_614526 != nil:
    section.add "NewTableName", valid_614526
  var valid_614527 = formData.getOrDefault("TargetSchemaName")
  valid_614527 = validateParameter(valid_614527, JString, required = false,
                                 default = nil)
  if valid_614527 != nil:
    section.add "TargetSchemaName", valid_614527
  var valid_614528 = formData.getOrDefault("TargetDatabaseName")
  valid_614528 = validateParameter(valid_614528, JString, required = false,
                                 default = nil)
  if valid_614528 != nil:
    section.add "TargetDatabaseName", valid_614528
  var valid_614529 = formData.getOrDefault("SnapshotIdentifier")
  valid_614529 = validateParameter(valid_614529, JString, required = true,
                                 default = nil)
  if valid_614529 != nil:
    section.add "SnapshotIdentifier", valid_614529
  var valid_614530 = formData.getOrDefault("SourceDatabaseName")
  valid_614530 = validateParameter(valid_614530, JString, required = true,
                                 default = nil)
  if valid_614530 != nil:
    section.add "SourceDatabaseName", valid_614530
  var valid_614531 = formData.getOrDefault("SourceSchemaName")
  valid_614531 = validateParameter(valid_614531, JString, required = false,
                                 default = nil)
  if valid_614531 != nil:
    section.add "SourceSchemaName", valid_614531
  var valid_614532 = formData.getOrDefault("SourceTableName")
  valid_614532 = validateParameter(valid_614532, JString, required = true,
                                 default = nil)
  if valid_614532 != nil:
    section.add "SourceTableName", valid_614532
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614533: Call_PostRestoreTableFromClusterSnapshot_614513;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Creates a new table from a table in an Amazon Redshift cluster snapshot. You must create the new table within the Amazon Redshift cluster that the snapshot was taken from.</p> <p>You cannot use <code>RestoreTableFromClusterSnapshot</code> to restore a table with the same name as an existing table in an Amazon Redshift cluster. That is, you cannot overwrite an existing table in a cluster with a restored table. If you want to replace your original table with a new, restored table, then rename or drop your original table before you call <code>RestoreTableFromClusterSnapshot</code>. When you have renamed your original table, then you can pass the original name of the table as the <code>NewTableName</code> parameter value in the call to <code>RestoreTableFromClusterSnapshot</code>. This way, you can replace the original table with the table created from the snapshot.</p>
  ## 
  let valid = call_614533.validator(path, query, header, formData, body)
  let scheme = call_614533.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614533.url(scheme.get, call_614533.host, call_614533.base,
                         call_614533.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614533, url, valid)

proc call*(call_614534: Call_PostRestoreTableFromClusterSnapshot_614513;
          ClusterIdentifier: string; NewTableName: string;
          SnapshotIdentifier: string; SourceDatabaseName: string;
          SourceTableName: string; TargetSchemaName: string = "";
          TargetDatabaseName: string = "";
          Action: string = "RestoreTableFromClusterSnapshot";
          Version: string = "2012-12-01"; SourceSchemaName: string = ""): Recallable =
  ## postRestoreTableFromClusterSnapshot
  ## <p>Creates a new table from a table in an Amazon Redshift cluster snapshot. You must create the new table within the Amazon Redshift cluster that the snapshot was taken from.</p> <p>You cannot use <code>RestoreTableFromClusterSnapshot</code> to restore a table with the same name as an existing table in an Amazon Redshift cluster. That is, you cannot overwrite an existing table in a cluster with a restored table. If you want to replace your original table with a new, restored table, then rename or drop your original table before you call <code>RestoreTableFromClusterSnapshot</code>. When you have renamed your original table, then you can pass the original name of the table as the <code>NewTableName</code> parameter value in the call to <code>RestoreTableFromClusterSnapshot</code>. This way, you can replace the original table with the table created from the snapshot.</p>
  ##   ClusterIdentifier: string (required)
  ##                    : The identifier of the Amazon Redshift cluster to restore the table to.
  ##   NewTableName: string (required)
  ##               : The name of the table to create as a result of the current request.
  ##   TargetSchemaName: string
  ##                   : The name of the schema to restore the table to.
  ##   TargetDatabaseName: string
  ##                     : The name of the database to restore the table to.
  ##   SnapshotIdentifier: string (required)
  ##                     : The identifier of the snapshot to restore the table from. This snapshot must have been created from the Amazon Redshift cluster specified by the <code>ClusterIdentifier</code> parameter.
  ##   SourceDatabaseName: string (required)
  ##                     : The name of the source database that contains the table to restore from.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   SourceSchemaName: string
  ##                   : The name of the source schema that contains the table to restore from. If you do not specify a <code>SourceSchemaName</code> value, the default is <code>public</code>.
  ##   SourceTableName: string (required)
  ##                  : The name of the source table to restore from.
  var query_614535 = newJObject()
  var formData_614536 = newJObject()
  add(formData_614536, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_614536, "NewTableName", newJString(NewTableName))
  add(formData_614536, "TargetSchemaName", newJString(TargetSchemaName))
  add(formData_614536, "TargetDatabaseName", newJString(TargetDatabaseName))
  add(formData_614536, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(formData_614536, "SourceDatabaseName", newJString(SourceDatabaseName))
  add(query_614535, "Action", newJString(Action))
  add(query_614535, "Version", newJString(Version))
  add(formData_614536, "SourceSchemaName", newJString(SourceSchemaName))
  add(formData_614536, "SourceTableName", newJString(SourceTableName))
  result = call_614534.call(nil, query_614535, nil, formData_614536, nil)

var postRestoreTableFromClusterSnapshot* = Call_PostRestoreTableFromClusterSnapshot_614513(
    name: "postRestoreTableFromClusterSnapshot", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=RestoreTableFromClusterSnapshot",
    validator: validate_PostRestoreTableFromClusterSnapshot_614514, base: "/",
    url: url_PostRestoreTableFromClusterSnapshot_614515,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetRestoreTableFromClusterSnapshot_614490 = ref object of OpenApiRestCall_610642
proc url_GetRestoreTableFromClusterSnapshot_614492(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetRestoreTableFromClusterSnapshot_614491(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a new table from a table in an Amazon Redshift cluster snapshot. You must create the new table within the Amazon Redshift cluster that the snapshot was taken from.</p> <p>You cannot use <code>RestoreTableFromClusterSnapshot</code> to restore a table with the same name as an existing table in an Amazon Redshift cluster. That is, you cannot overwrite an existing table in a cluster with a restored table. If you want to replace your original table with a new, restored table, then rename or drop your original table before you call <code>RestoreTableFromClusterSnapshot</code>. When you have renamed your original table, then you can pass the original name of the table as the <code>NewTableName</code> parameter value in the call to <code>RestoreTableFromClusterSnapshot</code>. This way, you can replace the original table with the table created from the snapshot.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   SnapshotIdentifier: JString (required)
  ##                     : The identifier of the snapshot to restore the table from. This snapshot must have been created from the Amazon Redshift cluster specified by the <code>ClusterIdentifier</code> parameter.
  ##   SourceTableName: JString (required)
  ##                  : The name of the source table to restore from.
  ##   SourceDatabaseName: JString (required)
  ##                     : The name of the source database that contains the table to restore from.
  ##   TargetSchemaName: JString
  ##                   : The name of the schema to restore the table to.
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : The identifier of the Amazon Redshift cluster to restore the table to.
  ##   SourceSchemaName: JString
  ##                   : The name of the source schema that contains the table to restore from. If you do not specify a <code>SourceSchemaName</code> value, the default is <code>public</code>.
  ##   Version: JString (required)
  ##   TargetDatabaseName: JString
  ##                     : The name of the database to restore the table to.
  ##   NewTableName: JString (required)
  ##               : The name of the table to create as a result of the current request.
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `SnapshotIdentifier` field"
  var valid_614493 = query.getOrDefault("SnapshotIdentifier")
  valid_614493 = validateParameter(valid_614493, JString, required = true,
                                 default = nil)
  if valid_614493 != nil:
    section.add "SnapshotIdentifier", valid_614493
  var valid_614494 = query.getOrDefault("SourceTableName")
  valid_614494 = validateParameter(valid_614494, JString, required = true,
                                 default = nil)
  if valid_614494 != nil:
    section.add "SourceTableName", valid_614494
  var valid_614495 = query.getOrDefault("SourceDatabaseName")
  valid_614495 = validateParameter(valid_614495, JString, required = true,
                                 default = nil)
  if valid_614495 != nil:
    section.add "SourceDatabaseName", valid_614495
  var valid_614496 = query.getOrDefault("TargetSchemaName")
  valid_614496 = validateParameter(valid_614496, JString, required = false,
                                 default = nil)
  if valid_614496 != nil:
    section.add "TargetSchemaName", valid_614496
  var valid_614497 = query.getOrDefault("Action")
  valid_614497 = validateParameter(valid_614497, JString, required = true, default = newJString(
      "RestoreTableFromClusterSnapshot"))
  if valid_614497 != nil:
    section.add "Action", valid_614497
  var valid_614498 = query.getOrDefault("ClusterIdentifier")
  valid_614498 = validateParameter(valid_614498, JString, required = true,
                                 default = nil)
  if valid_614498 != nil:
    section.add "ClusterIdentifier", valid_614498
  var valid_614499 = query.getOrDefault("SourceSchemaName")
  valid_614499 = validateParameter(valid_614499, JString, required = false,
                                 default = nil)
  if valid_614499 != nil:
    section.add "SourceSchemaName", valid_614499
  var valid_614500 = query.getOrDefault("Version")
  valid_614500 = validateParameter(valid_614500, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_614500 != nil:
    section.add "Version", valid_614500
  var valid_614501 = query.getOrDefault("TargetDatabaseName")
  valid_614501 = validateParameter(valid_614501, JString, required = false,
                                 default = nil)
  if valid_614501 != nil:
    section.add "TargetDatabaseName", valid_614501
  var valid_614502 = query.getOrDefault("NewTableName")
  valid_614502 = validateParameter(valid_614502, JString, required = true,
                                 default = nil)
  if valid_614502 != nil:
    section.add "NewTableName", valid_614502
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614503 = header.getOrDefault("X-Amz-Signature")
  valid_614503 = validateParameter(valid_614503, JString, required = false,
                                 default = nil)
  if valid_614503 != nil:
    section.add "X-Amz-Signature", valid_614503
  var valid_614504 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614504 = validateParameter(valid_614504, JString, required = false,
                                 default = nil)
  if valid_614504 != nil:
    section.add "X-Amz-Content-Sha256", valid_614504
  var valid_614505 = header.getOrDefault("X-Amz-Date")
  valid_614505 = validateParameter(valid_614505, JString, required = false,
                                 default = nil)
  if valid_614505 != nil:
    section.add "X-Amz-Date", valid_614505
  var valid_614506 = header.getOrDefault("X-Amz-Credential")
  valid_614506 = validateParameter(valid_614506, JString, required = false,
                                 default = nil)
  if valid_614506 != nil:
    section.add "X-Amz-Credential", valid_614506
  var valid_614507 = header.getOrDefault("X-Amz-Security-Token")
  valid_614507 = validateParameter(valid_614507, JString, required = false,
                                 default = nil)
  if valid_614507 != nil:
    section.add "X-Amz-Security-Token", valid_614507
  var valid_614508 = header.getOrDefault("X-Amz-Algorithm")
  valid_614508 = validateParameter(valid_614508, JString, required = false,
                                 default = nil)
  if valid_614508 != nil:
    section.add "X-Amz-Algorithm", valid_614508
  var valid_614509 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614509 = validateParameter(valid_614509, JString, required = false,
                                 default = nil)
  if valid_614509 != nil:
    section.add "X-Amz-SignedHeaders", valid_614509
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614510: Call_GetRestoreTableFromClusterSnapshot_614490;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Creates a new table from a table in an Amazon Redshift cluster snapshot. You must create the new table within the Amazon Redshift cluster that the snapshot was taken from.</p> <p>You cannot use <code>RestoreTableFromClusterSnapshot</code> to restore a table with the same name as an existing table in an Amazon Redshift cluster. That is, you cannot overwrite an existing table in a cluster with a restored table. If you want to replace your original table with a new, restored table, then rename or drop your original table before you call <code>RestoreTableFromClusterSnapshot</code>. When you have renamed your original table, then you can pass the original name of the table as the <code>NewTableName</code> parameter value in the call to <code>RestoreTableFromClusterSnapshot</code>. This way, you can replace the original table with the table created from the snapshot.</p>
  ## 
  let valid = call_614510.validator(path, query, header, formData, body)
  let scheme = call_614510.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614510.url(scheme.get, call_614510.host, call_614510.base,
                         call_614510.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614510, url, valid)

proc call*(call_614511: Call_GetRestoreTableFromClusterSnapshot_614490;
          SnapshotIdentifier: string; SourceTableName: string;
          SourceDatabaseName: string; ClusterIdentifier: string;
          NewTableName: string; TargetSchemaName: string = "";
          Action: string = "RestoreTableFromClusterSnapshot";
          SourceSchemaName: string = ""; Version: string = "2012-12-01";
          TargetDatabaseName: string = ""): Recallable =
  ## getRestoreTableFromClusterSnapshot
  ## <p>Creates a new table from a table in an Amazon Redshift cluster snapshot. You must create the new table within the Amazon Redshift cluster that the snapshot was taken from.</p> <p>You cannot use <code>RestoreTableFromClusterSnapshot</code> to restore a table with the same name as an existing table in an Amazon Redshift cluster. That is, you cannot overwrite an existing table in a cluster with a restored table. If you want to replace your original table with a new, restored table, then rename or drop your original table before you call <code>RestoreTableFromClusterSnapshot</code>. When you have renamed your original table, then you can pass the original name of the table as the <code>NewTableName</code> parameter value in the call to <code>RestoreTableFromClusterSnapshot</code>. This way, you can replace the original table with the table created from the snapshot.</p>
  ##   SnapshotIdentifier: string (required)
  ##                     : The identifier of the snapshot to restore the table from. This snapshot must have been created from the Amazon Redshift cluster specified by the <code>ClusterIdentifier</code> parameter.
  ##   SourceTableName: string (required)
  ##                  : The name of the source table to restore from.
  ##   SourceDatabaseName: string (required)
  ##                     : The name of the source database that contains the table to restore from.
  ##   TargetSchemaName: string
  ##                   : The name of the schema to restore the table to.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : The identifier of the Amazon Redshift cluster to restore the table to.
  ##   SourceSchemaName: string
  ##                   : The name of the source schema that contains the table to restore from. If you do not specify a <code>SourceSchemaName</code> value, the default is <code>public</code>.
  ##   Version: string (required)
  ##   TargetDatabaseName: string
  ##                     : The name of the database to restore the table to.
  ##   NewTableName: string (required)
  ##               : The name of the table to create as a result of the current request.
  var query_614512 = newJObject()
  add(query_614512, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_614512, "SourceTableName", newJString(SourceTableName))
  add(query_614512, "SourceDatabaseName", newJString(SourceDatabaseName))
  add(query_614512, "TargetSchemaName", newJString(TargetSchemaName))
  add(query_614512, "Action", newJString(Action))
  add(query_614512, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_614512, "SourceSchemaName", newJString(SourceSchemaName))
  add(query_614512, "Version", newJString(Version))
  add(query_614512, "TargetDatabaseName", newJString(TargetDatabaseName))
  add(query_614512, "NewTableName", newJString(NewTableName))
  result = call_614511.call(nil, query_614512, nil, nil, nil)

var getRestoreTableFromClusterSnapshot* = Call_GetRestoreTableFromClusterSnapshot_614490(
    name: "getRestoreTableFromClusterSnapshot", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=RestoreTableFromClusterSnapshot",
    validator: validate_GetRestoreTableFromClusterSnapshot_614491, base: "/",
    url: url_GetRestoreTableFromClusterSnapshot_614492,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostRevokeClusterSecurityGroupIngress_614556 = ref object of OpenApiRestCall_610642
proc url_PostRevokeClusterSecurityGroupIngress_614558(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostRevokeClusterSecurityGroupIngress_614557(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Revokes an ingress rule in an Amazon Redshift security group for a previously authorized IP range or Amazon EC2 security group. To add an ingress rule, see <a>AuthorizeClusterSecurityGroupIngress</a>. For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_614559 = query.getOrDefault("Action")
  valid_614559 = validateParameter(valid_614559, JString, required = true, default = newJString(
      "RevokeClusterSecurityGroupIngress"))
  if valid_614559 != nil:
    section.add "Action", valid_614559
  var valid_614560 = query.getOrDefault("Version")
  valid_614560 = validateParameter(valid_614560, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_614560 != nil:
    section.add "Version", valid_614560
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614561 = header.getOrDefault("X-Amz-Signature")
  valid_614561 = validateParameter(valid_614561, JString, required = false,
                                 default = nil)
  if valid_614561 != nil:
    section.add "X-Amz-Signature", valid_614561
  var valid_614562 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614562 = validateParameter(valid_614562, JString, required = false,
                                 default = nil)
  if valid_614562 != nil:
    section.add "X-Amz-Content-Sha256", valid_614562
  var valid_614563 = header.getOrDefault("X-Amz-Date")
  valid_614563 = validateParameter(valid_614563, JString, required = false,
                                 default = nil)
  if valid_614563 != nil:
    section.add "X-Amz-Date", valid_614563
  var valid_614564 = header.getOrDefault("X-Amz-Credential")
  valid_614564 = validateParameter(valid_614564, JString, required = false,
                                 default = nil)
  if valid_614564 != nil:
    section.add "X-Amz-Credential", valid_614564
  var valid_614565 = header.getOrDefault("X-Amz-Security-Token")
  valid_614565 = validateParameter(valid_614565, JString, required = false,
                                 default = nil)
  if valid_614565 != nil:
    section.add "X-Amz-Security-Token", valid_614565
  var valid_614566 = header.getOrDefault("X-Amz-Algorithm")
  valid_614566 = validateParameter(valid_614566, JString, required = false,
                                 default = nil)
  if valid_614566 != nil:
    section.add "X-Amz-Algorithm", valid_614566
  var valid_614567 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614567 = validateParameter(valid_614567, JString, required = false,
                                 default = nil)
  if valid_614567 != nil:
    section.add "X-Amz-SignedHeaders", valid_614567
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterSecurityGroupName: JString (required)
  ##                           : The name of the security Group from which to revoke the ingress rule.
  ##   EC2SecurityGroupName: JString
  ##                       : The name of the EC2 Security Group whose access is to be revoked. If <code>EC2SecurityGroupName</code> is specified, <code>EC2SecurityGroupOwnerId</code> must also be provided and <code>CIDRIP</code> cannot be provided. 
  ##   EC2SecurityGroupOwnerId: JString
  ##                          : <p>The AWS account number of the owner of the security group specified in the <code>EC2SecurityGroupName</code> parameter. The AWS access key ID is not an acceptable value. If <code>EC2SecurityGroupOwnerId</code> is specified, <code>EC2SecurityGroupName</code> must also be provided. and <code>CIDRIP</code> cannot be provided. </p> <p>Example: <code>111122223333</code> </p>
  ##   CIDRIP: JString
  ##         : The IP range for which to revoke access. This range must be a valid Classless Inter-Domain Routing (CIDR) block of IP addresses. If <code>CIDRIP</code> is specified, <code>EC2SecurityGroupName</code> and <code>EC2SecurityGroupOwnerId</code> cannot be provided. 
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterSecurityGroupName` field"
  var valid_614568 = formData.getOrDefault("ClusterSecurityGroupName")
  valid_614568 = validateParameter(valid_614568, JString, required = true,
                                 default = nil)
  if valid_614568 != nil:
    section.add "ClusterSecurityGroupName", valid_614568
  var valid_614569 = formData.getOrDefault("EC2SecurityGroupName")
  valid_614569 = validateParameter(valid_614569, JString, required = false,
                                 default = nil)
  if valid_614569 != nil:
    section.add "EC2SecurityGroupName", valid_614569
  var valid_614570 = formData.getOrDefault("EC2SecurityGroupOwnerId")
  valid_614570 = validateParameter(valid_614570, JString, required = false,
                                 default = nil)
  if valid_614570 != nil:
    section.add "EC2SecurityGroupOwnerId", valid_614570
  var valid_614571 = formData.getOrDefault("CIDRIP")
  valid_614571 = validateParameter(valid_614571, JString, required = false,
                                 default = nil)
  if valid_614571 != nil:
    section.add "CIDRIP", valid_614571
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614572: Call_PostRevokeClusterSecurityGroupIngress_614556;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Revokes an ingress rule in an Amazon Redshift security group for a previously authorized IP range or Amazon EC2 security group. To add an ingress rule, see <a>AuthorizeClusterSecurityGroupIngress</a>. For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>. 
  ## 
  let valid = call_614572.validator(path, query, header, formData, body)
  let scheme = call_614572.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614572.url(scheme.get, call_614572.host, call_614572.base,
                         call_614572.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614572, url, valid)

proc call*(call_614573: Call_PostRevokeClusterSecurityGroupIngress_614556;
          ClusterSecurityGroupName: string; EC2SecurityGroupName: string = "";
          EC2SecurityGroupOwnerId: string = ""; CIDRIP: string = "";
          Action: string = "RevokeClusterSecurityGroupIngress";
          Version: string = "2012-12-01"): Recallable =
  ## postRevokeClusterSecurityGroupIngress
  ## Revokes an ingress rule in an Amazon Redshift security group for a previously authorized IP range or Amazon EC2 security group. To add an ingress rule, see <a>AuthorizeClusterSecurityGroupIngress</a>. For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>. 
  ##   ClusterSecurityGroupName: string (required)
  ##                           : The name of the security Group from which to revoke the ingress rule.
  ##   EC2SecurityGroupName: string
  ##                       : The name of the EC2 Security Group whose access is to be revoked. If <code>EC2SecurityGroupName</code> is specified, <code>EC2SecurityGroupOwnerId</code> must also be provided and <code>CIDRIP</code> cannot be provided. 
  ##   EC2SecurityGroupOwnerId: string
  ##                          : <p>The AWS account number of the owner of the security group specified in the <code>EC2SecurityGroupName</code> parameter. The AWS access key ID is not an acceptable value. If <code>EC2SecurityGroupOwnerId</code> is specified, <code>EC2SecurityGroupName</code> must also be provided. and <code>CIDRIP</code> cannot be provided. </p> <p>Example: <code>111122223333</code> </p>
  ##   CIDRIP: string
  ##         : The IP range for which to revoke access. This range must be a valid Classless Inter-Domain Routing (CIDR) block of IP addresses. If <code>CIDRIP</code> is specified, <code>EC2SecurityGroupName</code> and <code>EC2SecurityGroupOwnerId</code> cannot be provided. 
  ##   Action: string (required)
  ##   Version: string (required)
  var query_614574 = newJObject()
  var formData_614575 = newJObject()
  add(formData_614575, "ClusterSecurityGroupName",
      newJString(ClusterSecurityGroupName))
  add(formData_614575, "EC2SecurityGroupName", newJString(EC2SecurityGroupName))
  add(formData_614575, "EC2SecurityGroupOwnerId",
      newJString(EC2SecurityGroupOwnerId))
  add(formData_614575, "CIDRIP", newJString(CIDRIP))
  add(query_614574, "Action", newJString(Action))
  add(query_614574, "Version", newJString(Version))
  result = call_614573.call(nil, query_614574, nil, formData_614575, nil)

var postRevokeClusterSecurityGroupIngress* = Call_PostRevokeClusterSecurityGroupIngress_614556(
    name: "postRevokeClusterSecurityGroupIngress", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=RevokeClusterSecurityGroupIngress",
    validator: validate_PostRevokeClusterSecurityGroupIngress_614557, base: "/",
    url: url_PostRevokeClusterSecurityGroupIngress_614558,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetRevokeClusterSecurityGroupIngress_614537 = ref object of OpenApiRestCall_610642
proc url_GetRevokeClusterSecurityGroupIngress_614539(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetRevokeClusterSecurityGroupIngress_614538(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Revokes an ingress rule in an Amazon Redshift security group for a previously authorized IP range or Amazon EC2 security group. To add an ingress rule, see <a>AuthorizeClusterSecurityGroupIngress</a>. For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   EC2SecurityGroupName: JString
  ##                       : The name of the EC2 Security Group whose access is to be revoked. If <code>EC2SecurityGroupName</code> is specified, <code>EC2SecurityGroupOwnerId</code> must also be provided and <code>CIDRIP</code> cannot be provided. 
  ##   EC2SecurityGroupOwnerId: JString
  ##                          : <p>The AWS account number of the owner of the security group specified in the <code>EC2SecurityGroupName</code> parameter. The AWS access key ID is not an acceptable value. If <code>EC2SecurityGroupOwnerId</code> is specified, <code>EC2SecurityGroupName</code> must also be provided. and <code>CIDRIP</code> cannot be provided. </p> <p>Example: <code>111122223333</code> </p>
  ##   ClusterSecurityGroupName: JString (required)
  ##                           : The name of the security Group from which to revoke the ingress rule.
  ##   Action: JString (required)
  ##   Version: JString (required)
  ##   CIDRIP: JString
  ##         : The IP range for which to revoke access. This range must be a valid Classless Inter-Domain Routing (CIDR) block of IP addresses. If <code>CIDRIP</code> is specified, <code>EC2SecurityGroupName</code> and <code>EC2SecurityGroupOwnerId</code> cannot be provided. 
  section = newJObject()
  var valid_614540 = query.getOrDefault("EC2SecurityGroupName")
  valid_614540 = validateParameter(valid_614540, JString, required = false,
                                 default = nil)
  if valid_614540 != nil:
    section.add "EC2SecurityGroupName", valid_614540
  var valid_614541 = query.getOrDefault("EC2SecurityGroupOwnerId")
  valid_614541 = validateParameter(valid_614541, JString, required = false,
                                 default = nil)
  if valid_614541 != nil:
    section.add "EC2SecurityGroupOwnerId", valid_614541
  assert query != nil, "query argument is necessary due to required `ClusterSecurityGroupName` field"
  var valid_614542 = query.getOrDefault("ClusterSecurityGroupName")
  valid_614542 = validateParameter(valid_614542, JString, required = true,
                                 default = nil)
  if valid_614542 != nil:
    section.add "ClusterSecurityGroupName", valid_614542
  var valid_614543 = query.getOrDefault("Action")
  valid_614543 = validateParameter(valid_614543, JString, required = true, default = newJString(
      "RevokeClusterSecurityGroupIngress"))
  if valid_614543 != nil:
    section.add "Action", valid_614543
  var valid_614544 = query.getOrDefault("Version")
  valid_614544 = validateParameter(valid_614544, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_614544 != nil:
    section.add "Version", valid_614544
  var valid_614545 = query.getOrDefault("CIDRIP")
  valid_614545 = validateParameter(valid_614545, JString, required = false,
                                 default = nil)
  if valid_614545 != nil:
    section.add "CIDRIP", valid_614545
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614546 = header.getOrDefault("X-Amz-Signature")
  valid_614546 = validateParameter(valid_614546, JString, required = false,
                                 default = nil)
  if valid_614546 != nil:
    section.add "X-Amz-Signature", valid_614546
  var valid_614547 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614547 = validateParameter(valid_614547, JString, required = false,
                                 default = nil)
  if valid_614547 != nil:
    section.add "X-Amz-Content-Sha256", valid_614547
  var valid_614548 = header.getOrDefault("X-Amz-Date")
  valid_614548 = validateParameter(valid_614548, JString, required = false,
                                 default = nil)
  if valid_614548 != nil:
    section.add "X-Amz-Date", valid_614548
  var valid_614549 = header.getOrDefault("X-Amz-Credential")
  valid_614549 = validateParameter(valid_614549, JString, required = false,
                                 default = nil)
  if valid_614549 != nil:
    section.add "X-Amz-Credential", valid_614549
  var valid_614550 = header.getOrDefault("X-Amz-Security-Token")
  valid_614550 = validateParameter(valid_614550, JString, required = false,
                                 default = nil)
  if valid_614550 != nil:
    section.add "X-Amz-Security-Token", valid_614550
  var valid_614551 = header.getOrDefault("X-Amz-Algorithm")
  valid_614551 = validateParameter(valid_614551, JString, required = false,
                                 default = nil)
  if valid_614551 != nil:
    section.add "X-Amz-Algorithm", valid_614551
  var valid_614552 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614552 = validateParameter(valid_614552, JString, required = false,
                                 default = nil)
  if valid_614552 != nil:
    section.add "X-Amz-SignedHeaders", valid_614552
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614553: Call_GetRevokeClusterSecurityGroupIngress_614537;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Revokes an ingress rule in an Amazon Redshift security group for a previously authorized IP range or Amazon EC2 security group. To add an ingress rule, see <a>AuthorizeClusterSecurityGroupIngress</a>. For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>. 
  ## 
  let valid = call_614553.validator(path, query, header, formData, body)
  let scheme = call_614553.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614553.url(scheme.get, call_614553.host, call_614553.base,
                         call_614553.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614553, url, valid)

proc call*(call_614554: Call_GetRevokeClusterSecurityGroupIngress_614537;
          ClusterSecurityGroupName: string; EC2SecurityGroupName: string = "";
          EC2SecurityGroupOwnerId: string = "";
          Action: string = "RevokeClusterSecurityGroupIngress";
          Version: string = "2012-12-01"; CIDRIP: string = ""): Recallable =
  ## getRevokeClusterSecurityGroupIngress
  ## Revokes an ingress rule in an Amazon Redshift security group for a previously authorized IP range or Amazon EC2 security group. To add an ingress rule, see <a>AuthorizeClusterSecurityGroupIngress</a>. For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>. 
  ##   EC2SecurityGroupName: string
  ##                       : The name of the EC2 Security Group whose access is to be revoked. If <code>EC2SecurityGroupName</code> is specified, <code>EC2SecurityGroupOwnerId</code> must also be provided and <code>CIDRIP</code> cannot be provided. 
  ##   EC2SecurityGroupOwnerId: string
  ##                          : <p>The AWS account number of the owner of the security group specified in the <code>EC2SecurityGroupName</code> parameter. The AWS access key ID is not an acceptable value. If <code>EC2SecurityGroupOwnerId</code> is specified, <code>EC2SecurityGroupName</code> must also be provided. and <code>CIDRIP</code> cannot be provided. </p> <p>Example: <code>111122223333</code> </p>
  ##   ClusterSecurityGroupName: string (required)
  ##                           : The name of the security Group from which to revoke the ingress rule.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   CIDRIP: string
  ##         : The IP range for which to revoke access. This range must be a valid Classless Inter-Domain Routing (CIDR) block of IP addresses. If <code>CIDRIP</code> is specified, <code>EC2SecurityGroupName</code> and <code>EC2SecurityGroupOwnerId</code> cannot be provided. 
  var query_614555 = newJObject()
  add(query_614555, "EC2SecurityGroupName", newJString(EC2SecurityGroupName))
  add(query_614555, "EC2SecurityGroupOwnerId", newJString(EC2SecurityGroupOwnerId))
  add(query_614555, "ClusterSecurityGroupName",
      newJString(ClusterSecurityGroupName))
  add(query_614555, "Action", newJString(Action))
  add(query_614555, "Version", newJString(Version))
  add(query_614555, "CIDRIP", newJString(CIDRIP))
  result = call_614554.call(nil, query_614555, nil, nil, nil)

var getRevokeClusterSecurityGroupIngress* = Call_GetRevokeClusterSecurityGroupIngress_614537(
    name: "getRevokeClusterSecurityGroupIngress", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=RevokeClusterSecurityGroupIngress",
    validator: validate_GetRevokeClusterSecurityGroupIngress_614538, base: "/",
    url: url_GetRevokeClusterSecurityGroupIngress_614539,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostRevokeSnapshotAccess_614594 = ref object of OpenApiRestCall_610642
proc url_PostRevokeSnapshotAccess_614596(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostRevokeSnapshotAccess_614595(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Removes the ability of the specified AWS customer account to restore the specified snapshot. If the account is currently restoring the snapshot, the restore will run to completion.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_614597 = query.getOrDefault("Action")
  valid_614597 = validateParameter(valid_614597, JString, required = true,
                                 default = newJString("RevokeSnapshotAccess"))
  if valid_614597 != nil:
    section.add "Action", valid_614597
  var valid_614598 = query.getOrDefault("Version")
  valid_614598 = validateParameter(valid_614598, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_614598 != nil:
    section.add "Version", valid_614598
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614599 = header.getOrDefault("X-Amz-Signature")
  valid_614599 = validateParameter(valid_614599, JString, required = false,
                                 default = nil)
  if valid_614599 != nil:
    section.add "X-Amz-Signature", valid_614599
  var valid_614600 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614600 = validateParameter(valid_614600, JString, required = false,
                                 default = nil)
  if valid_614600 != nil:
    section.add "X-Amz-Content-Sha256", valid_614600
  var valid_614601 = header.getOrDefault("X-Amz-Date")
  valid_614601 = validateParameter(valid_614601, JString, required = false,
                                 default = nil)
  if valid_614601 != nil:
    section.add "X-Amz-Date", valid_614601
  var valid_614602 = header.getOrDefault("X-Amz-Credential")
  valid_614602 = validateParameter(valid_614602, JString, required = false,
                                 default = nil)
  if valid_614602 != nil:
    section.add "X-Amz-Credential", valid_614602
  var valid_614603 = header.getOrDefault("X-Amz-Security-Token")
  valid_614603 = validateParameter(valid_614603, JString, required = false,
                                 default = nil)
  if valid_614603 != nil:
    section.add "X-Amz-Security-Token", valid_614603
  var valid_614604 = header.getOrDefault("X-Amz-Algorithm")
  valid_614604 = validateParameter(valid_614604, JString, required = false,
                                 default = nil)
  if valid_614604 != nil:
    section.add "X-Amz-Algorithm", valid_614604
  var valid_614605 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614605 = validateParameter(valid_614605, JString, required = false,
                                 default = nil)
  if valid_614605 != nil:
    section.add "X-Amz-SignedHeaders", valid_614605
  result.add "header", section
  ## parameters in `formData` object:
  ##   SnapshotIdentifier: JString (required)
  ##                     : The identifier of the snapshot that the account can no longer access.
  ##   AccountWithRestoreAccess: JString (required)
  ##                           : The identifier of the AWS customer account that can no longer restore the specified snapshot.
  ##   SnapshotClusterIdentifier: JString
  ##                            : The identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `SnapshotIdentifier` field"
  var valid_614606 = formData.getOrDefault("SnapshotIdentifier")
  valid_614606 = validateParameter(valid_614606, JString, required = true,
                                 default = nil)
  if valid_614606 != nil:
    section.add "SnapshotIdentifier", valid_614606
  var valid_614607 = formData.getOrDefault("AccountWithRestoreAccess")
  valid_614607 = validateParameter(valid_614607, JString, required = true,
                                 default = nil)
  if valid_614607 != nil:
    section.add "AccountWithRestoreAccess", valid_614607
  var valid_614608 = formData.getOrDefault("SnapshotClusterIdentifier")
  valid_614608 = validateParameter(valid_614608, JString, required = false,
                                 default = nil)
  if valid_614608 != nil:
    section.add "SnapshotClusterIdentifier", valid_614608
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614609: Call_PostRevokeSnapshotAccess_614594; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Removes the ability of the specified AWS customer account to restore the specified snapshot. If the account is currently restoring the snapshot, the restore will run to completion.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_614609.validator(path, query, header, formData, body)
  let scheme = call_614609.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614609.url(scheme.get, call_614609.host, call_614609.base,
                         call_614609.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614609, url, valid)

proc call*(call_614610: Call_PostRevokeSnapshotAccess_614594;
          SnapshotIdentifier: string; AccountWithRestoreAccess: string;
          Action: string = "RevokeSnapshotAccess";
          SnapshotClusterIdentifier: string = ""; Version: string = "2012-12-01"): Recallable =
  ## postRevokeSnapshotAccess
  ## <p>Removes the ability of the specified AWS customer account to restore the specified snapshot. If the account is currently restoring the snapshot, the restore will run to completion.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   SnapshotIdentifier: string (required)
  ##                     : The identifier of the snapshot that the account can no longer access.
  ##   Action: string (required)
  ##   AccountWithRestoreAccess: string (required)
  ##                           : The identifier of the AWS customer account that can no longer restore the specified snapshot.
  ##   SnapshotClusterIdentifier: string
  ##                            : The identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.
  ##   Version: string (required)
  var query_614611 = newJObject()
  var formData_614612 = newJObject()
  add(formData_614612, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_614611, "Action", newJString(Action))
  add(formData_614612, "AccountWithRestoreAccess",
      newJString(AccountWithRestoreAccess))
  add(formData_614612, "SnapshotClusterIdentifier",
      newJString(SnapshotClusterIdentifier))
  add(query_614611, "Version", newJString(Version))
  result = call_614610.call(nil, query_614611, nil, formData_614612, nil)

var postRevokeSnapshotAccess* = Call_PostRevokeSnapshotAccess_614594(
    name: "postRevokeSnapshotAccess", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=RevokeSnapshotAccess",
    validator: validate_PostRevokeSnapshotAccess_614595, base: "/",
    url: url_PostRevokeSnapshotAccess_614596, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetRevokeSnapshotAccess_614576 = ref object of OpenApiRestCall_610642
proc url_GetRevokeSnapshotAccess_614578(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetRevokeSnapshotAccess_614577(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Removes the ability of the specified AWS customer account to restore the specified snapshot. If the account is currently restoring the snapshot, the restore will run to completion.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   SnapshotIdentifier: JString (required)
  ##                     : The identifier of the snapshot that the account can no longer access.
  ##   SnapshotClusterIdentifier: JString
  ##                            : The identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.
  ##   Action: JString (required)
  ##   Version: JString (required)
  ##   AccountWithRestoreAccess: JString (required)
  ##                           : The identifier of the AWS customer account that can no longer restore the specified snapshot.
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `SnapshotIdentifier` field"
  var valid_614579 = query.getOrDefault("SnapshotIdentifier")
  valid_614579 = validateParameter(valid_614579, JString, required = true,
                                 default = nil)
  if valid_614579 != nil:
    section.add "SnapshotIdentifier", valid_614579
  var valid_614580 = query.getOrDefault("SnapshotClusterIdentifier")
  valid_614580 = validateParameter(valid_614580, JString, required = false,
                                 default = nil)
  if valid_614580 != nil:
    section.add "SnapshotClusterIdentifier", valid_614580
  var valid_614581 = query.getOrDefault("Action")
  valid_614581 = validateParameter(valid_614581, JString, required = true,
                                 default = newJString("RevokeSnapshotAccess"))
  if valid_614581 != nil:
    section.add "Action", valid_614581
  var valid_614582 = query.getOrDefault("Version")
  valid_614582 = validateParameter(valid_614582, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_614582 != nil:
    section.add "Version", valid_614582
  var valid_614583 = query.getOrDefault("AccountWithRestoreAccess")
  valid_614583 = validateParameter(valid_614583, JString, required = true,
                                 default = nil)
  if valid_614583 != nil:
    section.add "AccountWithRestoreAccess", valid_614583
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614584 = header.getOrDefault("X-Amz-Signature")
  valid_614584 = validateParameter(valid_614584, JString, required = false,
                                 default = nil)
  if valid_614584 != nil:
    section.add "X-Amz-Signature", valid_614584
  var valid_614585 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614585 = validateParameter(valid_614585, JString, required = false,
                                 default = nil)
  if valid_614585 != nil:
    section.add "X-Amz-Content-Sha256", valid_614585
  var valid_614586 = header.getOrDefault("X-Amz-Date")
  valid_614586 = validateParameter(valid_614586, JString, required = false,
                                 default = nil)
  if valid_614586 != nil:
    section.add "X-Amz-Date", valid_614586
  var valid_614587 = header.getOrDefault("X-Amz-Credential")
  valid_614587 = validateParameter(valid_614587, JString, required = false,
                                 default = nil)
  if valid_614587 != nil:
    section.add "X-Amz-Credential", valid_614587
  var valid_614588 = header.getOrDefault("X-Amz-Security-Token")
  valid_614588 = validateParameter(valid_614588, JString, required = false,
                                 default = nil)
  if valid_614588 != nil:
    section.add "X-Amz-Security-Token", valid_614588
  var valid_614589 = header.getOrDefault("X-Amz-Algorithm")
  valid_614589 = validateParameter(valid_614589, JString, required = false,
                                 default = nil)
  if valid_614589 != nil:
    section.add "X-Amz-Algorithm", valid_614589
  var valid_614590 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614590 = validateParameter(valid_614590, JString, required = false,
                                 default = nil)
  if valid_614590 != nil:
    section.add "X-Amz-SignedHeaders", valid_614590
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614591: Call_GetRevokeSnapshotAccess_614576; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Removes the ability of the specified AWS customer account to restore the specified snapshot. If the account is currently restoring the snapshot, the restore will run to completion.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_614591.validator(path, query, header, formData, body)
  let scheme = call_614591.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614591.url(scheme.get, call_614591.host, call_614591.base,
                         call_614591.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614591, url, valid)

proc call*(call_614592: Call_GetRevokeSnapshotAccess_614576;
          SnapshotIdentifier: string; AccountWithRestoreAccess: string;
          SnapshotClusterIdentifier: string = "";
          Action: string = "RevokeSnapshotAccess"; Version: string = "2012-12-01"): Recallable =
  ## getRevokeSnapshotAccess
  ## <p>Removes the ability of the specified AWS customer account to restore the specified snapshot. If the account is currently restoring the snapshot, the restore will run to completion.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   SnapshotIdentifier: string (required)
  ##                     : The identifier of the snapshot that the account can no longer access.
  ##   SnapshotClusterIdentifier: string
  ##                            : The identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   AccountWithRestoreAccess: string (required)
  ##                           : The identifier of the AWS customer account that can no longer restore the specified snapshot.
  var query_614593 = newJObject()
  add(query_614593, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_614593, "SnapshotClusterIdentifier",
      newJString(SnapshotClusterIdentifier))
  add(query_614593, "Action", newJString(Action))
  add(query_614593, "Version", newJString(Version))
  add(query_614593, "AccountWithRestoreAccess",
      newJString(AccountWithRestoreAccess))
  result = call_614592.call(nil, query_614593, nil, nil, nil)

var getRevokeSnapshotAccess* = Call_GetRevokeSnapshotAccess_614576(
    name: "getRevokeSnapshotAccess", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=RevokeSnapshotAccess",
    validator: validate_GetRevokeSnapshotAccess_614577, base: "/",
    url: url_GetRevokeSnapshotAccess_614578, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostRotateEncryptionKey_614629 = ref object of OpenApiRestCall_610642
proc url_PostRotateEncryptionKey_614631(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostRotateEncryptionKey_614630(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Rotates the encryption keys for a cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_614632 = query.getOrDefault("Action")
  valid_614632 = validateParameter(valid_614632, JString, required = true,
                                 default = newJString("RotateEncryptionKey"))
  if valid_614632 != nil:
    section.add "Action", valid_614632
  var valid_614633 = query.getOrDefault("Version")
  valid_614633 = validateParameter(valid_614633, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_614633 != nil:
    section.add "Version", valid_614633
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614634 = header.getOrDefault("X-Amz-Signature")
  valid_614634 = validateParameter(valid_614634, JString, required = false,
                                 default = nil)
  if valid_614634 != nil:
    section.add "X-Amz-Signature", valid_614634
  var valid_614635 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614635 = validateParameter(valid_614635, JString, required = false,
                                 default = nil)
  if valid_614635 != nil:
    section.add "X-Amz-Content-Sha256", valid_614635
  var valid_614636 = header.getOrDefault("X-Amz-Date")
  valid_614636 = validateParameter(valid_614636, JString, required = false,
                                 default = nil)
  if valid_614636 != nil:
    section.add "X-Amz-Date", valid_614636
  var valid_614637 = header.getOrDefault("X-Amz-Credential")
  valid_614637 = validateParameter(valid_614637, JString, required = false,
                                 default = nil)
  if valid_614637 != nil:
    section.add "X-Amz-Credential", valid_614637
  var valid_614638 = header.getOrDefault("X-Amz-Security-Token")
  valid_614638 = validateParameter(valid_614638, JString, required = false,
                                 default = nil)
  if valid_614638 != nil:
    section.add "X-Amz-Security-Token", valid_614638
  var valid_614639 = header.getOrDefault("X-Amz-Algorithm")
  valid_614639 = validateParameter(valid_614639, JString, required = false,
                                 default = nil)
  if valid_614639 != nil:
    section.add "X-Amz-Algorithm", valid_614639
  var valid_614640 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614640 = validateParameter(valid_614640, JString, required = false,
                                 default = nil)
  if valid_614640 != nil:
    section.add "X-Amz-SignedHeaders", valid_614640
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of the cluster that you want to rotate the encryption keys for.</p> <p>Constraints: Must be the name of valid cluster that has encryption enabled.</p>
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_614641 = formData.getOrDefault("ClusterIdentifier")
  valid_614641 = validateParameter(valid_614641, JString, required = true,
                                 default = nil)
  if valid_614641 != nil:
    section.add "ClusterIdentifier", valid_614641
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614642: Call_PostRotateEncryptionKey_614629; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Rotates the encryption keys for a cluster.
  ## 
  let valid = call_614642.validator(path, query, header, formData, body)
  let scheme = call_614642.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614642.url(scheme.get, call_614642.host, call_614642.base,
                         call_614642.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614642, url, valid)

proc call*(call_614643: Call_PostRotateEncryptionKey_614629;
          ClusterIdentifier: string; Action: string = "RotateEncryptionKey";
          Version: string = "2012-12-01"): Recallable =
  ## postRotateEncryptionKey
  ## Rotates the encryption keys for a cluster.
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of the cluster that you want to rotate the encryption keys for.</p> <p>Constraints: Must be the name of valid cluster that has encryption enabled.</p>
  ##   Action: string (required)
  ##   Version: string (required)
  var query_614644 = newJObject()
  var formData_614645 = newJObject()
  add(formData_614645, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_614644, "Action", newJString(Action))
  add(query_614644, "Version", newJString(Version))
  result = call_614643.call(nil, query_614644, nil, formData_614645, nil)

var postRotateEncryptionKey* = Call_PostRotateEncryptionKey_614629(
    name: "postRotateEncryptionKey", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=RotateEncryptionKey",
    validator: validate_PostRotateEncryptionKey_614630, base: "/",
    url: url_PostRotateEncryptionKey_614631, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetRotateEncryptionKey_614613 = ref object of OpenApiRestCall_610642
proc url_GetRotateEncryptionKey_614615(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetRotateEncryptionKey_614614(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Rotates the encryption keys for a cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of the cluster that you want to rotate the encryption keys for.</p> <p>Constraints: Must be the name of valid cluster that has encryption enabled.</p>
  ##   Version: JString (required)
  section = newJObject()
  var valid_614616 = query.getOrDefault("Action")
  valid_614616 = validateParameter(valid_614616, JString, required = true,
                                 default = newJString("RotateEncryptionKey"))
  if valid_614616 != nil:
    section.add "Action", valid_614616
  var valid_614617 = query.getOrDefault("ClusterIdentifier")
  valid_614617 = validateParameter(valid_614617, JString, required = true,
                                 default = nil)
  if valid_614617 != nil:
    section.add "ClusterIdentifier", valid_614617
  var valid_614618 = query.getOrDefault("Version")
  valid_614618 = validateParameter(valid_614618, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_614618 != nil:
    section.add "Version", valid_614618
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614619 = header.getOrDefault("X-Amz-Signature")
  valid_614619 = validateParameter(valid_614619, JString, required = false,
                                 default = nil)
  if valid_614619 != nil:
    section.add "X-Amz-Signature", valid_614619
  var valid_614620 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614620 = validateParameter(valid_614620, JString, required = false,
                                 default = nil)
  if valid_614620 != nil:
    section.add "X-Amz-Content-Sha256", valid_614620
  var valid_614621 = header.getOrDefault("X-Amz-Date")
  valid_614621 = validateParameter(valid_614621, JString, required = false,
                                 default = nil)
  if valid_614621 != nil:
    section.add "X-Amz-Date", valid_614621
  var valid_614622 = header.getOrDefault("X-Amz-Credential")
  valid_614622 = validateParameter(valid_614622, JString, required = false,
                                 default = nil)
  if valid_614622 != nil:
    section.add "X-Amz-Credential", valid_614622
  var valid_614623 = header.getOrDefault("X-Amz-Security-Token")
  valid_614623 = validateParameter(valid_614623, JString, required = false,
                                 default = nil)
  if valid_614623 != nil:
    section.add "X-Amz-Security-Token", valid_614623
  var valid_614624 = header.getOrDefault("X-Amz-Algorithm")
  valid_614624 = validateParameter(valid_614624, JString, required = false,
                                 default = nil)
  if valid_614624 != nil:
    section.add "X-Amz-Algorithm", valid_614624
  var valid_614625 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614625 = validateParameter(valid_614625, JString, required = false,
                                 default = nil)
  if valid_614625 != nil:
    section.add "X-Amz-SignedHeaders", valid_614625
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614626: Call_GetRotateEncryptionKey_614613; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Rotates the encryption keys for a cluster.
  ## 
  let valid = call_614626.validator(path, query, header, formData, body)
  let scheme = call_614626.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614626.url(scheme.get, call_614626.host, call_614626.base,
                         call_614626.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614626, url, valid)

proc call*(call_614627: Call_GetRotateEncryptionKey_614613;
          ClusterIdentifier: string; Action: string = "RotateEncryptionKey";
          Version: string = "2012-12-01"): Recallable =
  ## getRotateEncryptionKey
  ## Rotates the encryption keys for a cluster.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of the cluster that you want to rotate the encryption keys for.</p> <p>Constraints: Must be the name of valid cluster that has encryption enabled.</p>
  ##   Version: string (required)
  var query_614628 = newJObject()
  add(query_614628, "Action", newJString(Action))
  add(query_614628, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_614628, "Version", newJString(Version))
  result = call_614627.call(nil, query_614628, nil, nil, nil)

var getRotateEncryptionKey* = Call_GetRotateEncryptionKey_614613(
    name: "getRotateEncryptionKey", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=RotateEncryptionKey",
    validator: validate_GetRotateEncryptionKey_614614, base: "/",
    url: url_GetRotateEncryptionKey_614615, schemes: {Scheme.Https, Scheme.Http})
export
  rest

type
  EnvKind = enum
    BakeIntoBinary = "Baking $1 into the binary",
    FetchFromEnv = "Fetch $1 from the environment"
template sloppyConst(via: EnvKind; name: untyped): untyped =
  import
    macros

  const
    name {.strdefine.}: string = case via
    of BakeIntoBinary:
      getEnv(astToStr(name), "")
    of FetchFromEnv:
      ""
  static :
    let msg = block:
      if name == "":
        "Missing $1 in the environment"
      else:
        $via
    warning msg % [astToStr(name)]

sloppyConst FetchFromEnv, AWS_ACCESS_KEY_ID
sloppyConst FetchFromEnv, AWS_SECRET_ACCESS_KEY
sloppyConst BakeIntoBinary, AWS_REGION
sloppyConst FetchFromEnv, AWS_ACCOUNT_ID
proc atozSign(recall: var Recallable; query: JsonNode; algo: SigningAlgo = SHA256) =
  let
    date = makeDateTime()
    access = os.getEnv("AWS_ACCESS_KEY_ID", AWS_ACCESS_KEY_ID)
    secret = os.getEnv("AWS_SECRET_ACCESS_KEY", AWS_SECRET_ACCESS_KEY)
    region = os.getEnv("AWS_REGION", AWS_REGION)
  assert secret != "", "need $AWS_SECRET_ACCESS_KEY in environment"
  assert access != "", "need $AWS_ACCESS_KEY_ID in environment"
  assert region != "", "need $AWS_REGION in environment"
  var
    normal: PathNormal
    url = normalizeUrl(recall.url, query, normalize = normal)
    scheme = parseEnum[Scheme](url.scheme)
  assert scheme in awsServers, "unknown scheme `" & $scheme & "`"
  assert region in awsServers[scheme], "unknown region `" & region & "`"
  url.hostname = awsServers[scheme][region]
  case awsServiceName.toLowerAscii
  of "s3":
    normal = PathNormal.S3
  else:
    normal = PathNormal.Default
  recall.headers["Host"] = url.hostname
  recall.headers["X-Amz-Date"] = date
  let
    algo = SHA256
    scope = credentialScope(region = region, service = awsServiceName, date = date)
    request = canonicalRequest(recall.meth, $url, query, recall.headers, recall.body,
                             normalize = normal, digest = algo)
    sts = stringToSign(request.hash(algo), scope, date = date, digest = algo)
    signature = calculateSignature(secret = secret, date = date, region = region,
                                 service = awsServiceName, sts, digest = algo)
  var auth = $algo & " "
  auth &= "Credential=" & access / scope & ", "
  auth &= "SignedHeaders=" & recall.headers.signedHeaders & ", "
  auth &= "Signature=" & signature
  recall.headers["Authorization"] = auth
  recall.headers.del "Host"
  recall.url = $url

type
  XAmz = enum
    SecurityToken = "X-Amz-Security-Token", ContentSha256 = "X-Amz-Content-Sha256"
method atozHook(call: OpenApiRestCall; url: Uri; input: JsonNode): Recallable {.base.} =
  ## the hook is a terrible earworm
  var headers = newHttpHeaders(massageHeaders(input.getOrDefault("header")))
  let
    body = input.getOrDefault("body")
    text = if body == nil:
      "" elif body.kind == JString:
      body.getStr else:
      $body
  if body != nil and body.kind != JString:
    if not headers.hasKey("content-type"):
      headers["content-type"] = "application/x-amz-json-1.0"
  if not headers.hasKey($SecurityToken):
    let session = getEnv("AWS_SESSION_TOKEN", "")
    if session != "":
      headers[$SecurityToken] = session
  headers[$ContentSha256] = hash(text, SHA256)
  result = newRecallable(call, url, headers, text)
  result.atozSign(input.getOrDefault("query"), SHA256)
