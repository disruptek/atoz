
import
  json, options, hashes, uri, strutils, tables, rest, os, uri, strutils, httpcore, sigv4

## auto-generated via openapi macro
## title: Amazon Redshift
## version: 2012-12-01
## termsOfService: https://aws.amazon.com/service-terms/
## license:
##     name: Apache 2.0 License
##     url: http://www.apache.org/licenses/
## 
## <fullname>Amazon Redshift</fullname> <p> <b>Overview</b> </p> <p>This is an interface reference for Amazon Redshift. It contains documentation for one of the programming or command line interfaces you can use to manage Amazon Redshift clusters. Note that Amazon Redshift is asynchronous, which means that some interfaces may require techniques, such as polling or asynchronous callback handlers, to determine when a command has been applied. In this reference, the parameter descriptions indicate whether a change is applied immediately, on the next instance reboot, or during the next maintenance window. For a summary of the Amazon Redshift cluster management interfaces, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/using-aws-sdk.html">Using the Amazon Redshift Management Interfaces</a>.</p> <p>Amazon Redshift manages all the work of setting up, operating, and scaling a data warehouse: provisioning capacity, monitoring and backing up the cluster, and applying patches and upgrades to the Amazon Redshift engine. You can focus on using your data to acquire new insights for your business and customers.</p> <p>If you are a first-time user of Amazon Redshift, we recommend that you begin by reading the <a href="https://docs.aws.amazon.com/redshift/latest/gsg/getting-started.html">Amazon Redshift Getting Started Guide</a>.</p> <p>If you are a database developer, the <a href="https://docs.aws.amazon.com/redshift/latest/dg/welcome.html">Amazon Redshift Database Developer Guide</a> explains how to design, build, query, and maintain the databases that make up your data warehouse. </p>
## 
## Amazon Web Services documentation
## https://docs.aws.amazon.com/redshift/
type
  Scheme {.pure.} = enum
    Https = "https", Http = "http", Wss = "wss", Ws = "ws"
  ValidatorSignature = proc (query: JsonNode = nil; body: JsonNode = nil;
                          header: JsonNode = nil; path: JsonNode = nil;
                          formData: JsonNode = nil): JsonNode
  OpenApiRestCall = ref object of RestCall
    validator*: ValidatorSignature
    route*: string
    base*: string
    host*: string
    schemes*: set[Scheme]
    url*: proc (protocol: Scheme; host: string; base: string; route: string;
              path: JsonNode; query: JsonNode): Uri

  OpenApiRestCall_605573 = ref object of OpenApiRestCall
proc hash(scheme: Scheme): Hash {.used.} =
  result = hash(ord(scheme))

proc clone[T: OpenApiRestCall_605573](t: T): T {.used.} =
  result = T(name: t.name, meth: t.meth, host: t.host, base: t.base, route: t.route,
           schemes: t.schemes, validator: t.validator, url: t.url)

proc pickScheme(t: OpenApiRestCall_605573): Option[Scheme] {.used.} =
  ## select a supported scheme from a set of candidates
  for scheme in Scheme.low ..
      Scheme.high:
    if scheme notin t.schemes:
      continue
    if scheme in [Scheme.Https, Scheme.Wss]:
      when defined(ssl):
        return some(scheme)
      else:
        continue
    return some(scheme)

proc validateParameter(js: JsonNode; kind: JsonNodeKind; required: bool;
                      default: JsonNode = nil): JsonNode =
  ## ensure an input is of the correct json type and yield
  ## a suitable default value when appropriate
  if js ==
      nil:
    if default != nil:
      return validateParameter(default, kind, required = required)
  result = js
  if result ==
      nil:
    assert not required, $kind & " expected; received nil"
    if required:
      result = newJNull()
  else:
    assert js.kind ==
        kind, $kind & " expected; received " &
        $js.kind

type
  KeyVal {.used.} = tuple[key: string, val: string]
  PathTokenKind = enum
    ConstantSegment, VariableSegment
  PathToken = tuple[kind: PathTokenKind, value: string]
proc queryString(query: JsonNode): string {.used.} =
  var qs: seq[KeyVal]
  if query == nil:
    return ""
  for k, v in query.pairs:
    qs.add (key: k, val: v.getStr)
  result = encodeQuery(qs)

proc hydratePath(input: JsonNode; segments: seq[PathToken]): Option[string] {.used.} =
  ## reconstitute a path with constants and variable values taken from json
  var head: string
  if segments.len == 0:
    return some("")
  head = segments[0].value
  case segments[0].kind
  of ConstantSegment:
    discard
  of VariableSegment:
    if head notin input:
      return
    let js = input[head]
    case js.kind
    of JInt, JFloat, JNull, JBool:
      head = $js
    of JString:
      head = js.getStr
    else:
      return
  var remainder = input.hydratePath(segments[1 ..^ 1])
  if remainder.isNone:
    return
  result = some(head & remainder.get)

const
  awsServers = {Scheme.Http: {"ap-northeast-1": "redshift.ap-northeast-1.amazonaws.com", "ap-southeast-1": "redshift.ap-southeast-1.amazonaws.com",
                           "us-west-2": "redshift.us-west-2.amazonaws.com",
                           "eu-west-2": "redshift.eu-west-2.amazonaws.com", "ap-northeast-3": "redshift.ap-northeast-3.amazonaws.com", "eu-central-1": "redshift.eu-central-1.amazonaws.com",
                           "us-east-2": "redshift.us-east-2.amazonaws.com",
                           "us-east-1": "redshift.us-east-1.amazonaws.com", "cn-northwest-1": "redshift.cn-northwest-1.amazonaws.com.cn",
                           "ap-south-1": "redshift.ap-south-1.amazonaws.com",
                           "eu-north-1": "redshift.eu-north-1.amazonaws.com", "ap-northeast-2": "redshift.ap-northeast-2.amazonaws.com",
                           "us-west-1": "redshift.us-west-1.amazonaws.com", "us-gov-east-1": "redshift.us-gov-east-1.amazonaws.com",
                           "eu-west-3": "redshift.eu-west-3.amazonaws.com", "cn-north-1": "redshift.cn-north-1.amazonaws.com.cn",
                           "sa-east-1": "redshift.sa-east-1.amazonaws.com",
                           "eu-west-1": "redshift.eu-west-1.amazonaws.com", "us-gov-west-1": "redshift.us-gov-west-1.amazonaws.com", "ap-southeast-2": "redshift.ap-southeast-2.amazonaws.com", "ca-central-1": "redshift.ca-central-1.amazonaws.com"}.toTable, Scheme.Https: {
      "ap-northeast-1": "redshift.ap-northeast-1.amazonaws.com",
      "ap-southeast-1": "redshift.ap-southeast-1.amazonaws.com",
      "us-west-2": "redshift.us-west-2.amazonaws.com",
      "eu-west-2": "redshift.eu-west-2.amazonaws.com",
      "ap-northeast-3": "redshift.ap-northeast-3.amazonaws.com",
      "eu-central-1": "redshift.eu-central-1.amazonaws.com",
      "us-east-2": "redshift.us-east-2.amazonaws.com",
      "us-east-1": "redshift.us-east-1.amazonaws.com",
      "cn-northwest-1": "redshift.cn-northwest-1.amazonaws.com.cn",
      "ap-south-1": "redshift.ap-south-1.amazonaws.com",
      "eu-north-1": "redshift.eu-north-1.amazonaws.com",
      "ap-northeast-2": "redshift.ap-northeast-2.amazonaws.com",
      "us-west-1": "redshift.us-west-1.amazonaws.com",
      "us-gov-east-1": "redshift.us-gov-east-1.amazonaws.com",
      "eu-west-3": "redshift.eu-west-3.amazonaws.com",
      "cn-north-1": "redshift.cn-north-1.amazonaws.com.cn",
      "sa-east-1": "redshift.sa-east-1.amazonaws.com",
      "eu-west-1": "redshift.eu-west-1.amazonaws.com",
      "us-gov-west-1": "redshift.us-gov-west-1.amazonaws.com",
      "ap-southeast-2": "redshift.ap-southeast-2.amazonaws.com",
      "ca-central-1": "redshift.ca-central-1.amazonaws.com"}.toTable}.toTable
const
  awsServiceName = "redshift"
method atozHook(call: OpenApiRestCall; url: Uri; input: JsonNode): Recallable {.base.}
type
  Call_PostAcceptReservedNodeExchange_606183 = ref object of OpenApiRestCall_605573
proc url_PostAcceptReservedNodeExchange_606185(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostAcceptReservedNodeExchange_606184(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Exchanges a DC1 Reserved Node for a DC2 Reserved Node with no changes to the configuration (term, payment type, or number of nodes) and no additional costs. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_606186 = query.getOrDefault("Action")
  valid_606186 = validateParameter(valid_606186, JString, required = true, default = newJString(
      "AcceptReservedNodeExchange"))
  if valid_606186 != nil:
    section.add "Action", valid_606186
  var valid_606187 = query.getOrDefault("Version")
  valid_606187 = validateParameter(valid_606187, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_606187 != nil:
    section.add "Version", valid_606187
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_606188 = header.getOrDefault("X-Amz-Signature")
  valid_606188 = validateParameter(valid_606188, JString, required = false,
                                 default = nil)
  if valid_606188 != nil:
    section.add "X-Amz-Signature", valid_606188
  var valid_606189 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_606189 = validateParameter(valid_606189, JString, required = false,
                                 default = nil)
  if valid_606189 != nil:
    section.add "X-Amz-Content-Sha256", valid_606189
  var valid_606190 = header.getOrDefault("X-Amz-Date")
  valid_606190 = validateParameter(valid_606190, JString, required = false,
                                 default = nil)
  if valid_606190 != nil:
    section.add "X-Amz-Date", valid_606190
  var valid_606191 = header.getOrDefault("X-Amz-Credential")
  valid_606191 = validateParameter(valid_606191, JString, required = false,
                                 default = nil)
  if valid_606191 != nil:
    section.add "X-Amz-Credential", valid_606191
  var valid_606192 = header.getOrDefault("X-Amz-Security-Token")
  valid_606192 = validateParameter(valid_606192, JString, required = false,
                                 default = nil)
  if valid_606192 != nil:
    section.add "X-Amz-Security-Token", valid_606192
  var valid_606193 = header.getOrDefault("X-Amz-Algorithm")
  valid_606193 = validateParameter(valid_606193, JString, required = false,
                                 default = nil)
  if valid_606193 != nil:
    section.add "X-Amz-Algorithm", valid_606193
  var valid_606194 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_606194 = validateParameter(valid_606194, JString, required = false,
                                 default = nil)
  if valid_606194 != nil:
    section.add "X-Amz-SignedHeaders", valid_606194
  result.add "header", section
  ## parameters in `formData` object:
  ##   ReservedNodeId: JString (required)
  ##                 : A string representing the node identifier of the DC1 Reserved Node to be exchanged.
  ##   TargetReservedNodeOfferingId: JString (required)
  ##                               : The unique identifier of the DC2 Reserved Node offering to be used for the exchange. You can obtain the value for the parameter by calling <a>GetReservedNodeExchangeOfferings</a> 
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `ReservedNodeId` field"
  var valid_606195 = formData.getOrDefault("ReservedNodeId")
  valid_606195 = validateParameter(valid_606195, JString, required = true,
                                 default = nil)
  if valid_606195 != nil:
    section.add "ReservedNodeId", valid_606195
  var valid_606196 = formData.getOrDefault("TargetReservedNodeOfferingId")
  valid_606196 = validateParameter(valid_606196, JString, required = true,
                                 default = nil)
  if valid_606196 != nil:
    section.add "TargetReservedNodeOfferingId", valid_606196
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_606197: Call_PostAcceptReservedNodeExchange_606183; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Exchanges a DC1 Reserved Node for a DC2 Reserved Node with no changes to the configuration (term, payment type, or number of nodes) and no additional costs. 
  ## 
  let valid = call_606197.validator(path, query, header, formData, body)
  let scheme = call_606197.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_606197.url(scheme.get, call_606197.host, call_606197.base,
                         call_606197.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_606197, url, valid)

proc call*(call_606198: Call_PostAcceptReservedNodeExchange_606183;
          ReservedNodeId: string; TargetReservedNodeOfferingId: string;
          Action: string = "AcceptReservedNodeExchange";
          Version: string = "2012-12-01"): Recallable =
  ## postAcceptReservedNodeExchange
  ## Exchanges a DC1 Reserved Node for a DC2 Reserved Node with no changes to the configuration (term, payment type, or number of nodes) and no additional costs. 
  ##   ReservedNodeId: string (required)
  ##                 : A string representing the node identifier of the DC1 Reserved Node to be exchanged.
  ##   TargetReservedNodeOfferingId: string (required)
  ##                               : The unique identifier of the DC2 Reserved Node offering to be used for the exchange. You can obtain the value for the parameter by calling <a>GetReservedNodeExchangeOfferings</a> 
  ##   Action: string (required)
  ##   Version: string (required)
  var query_606199 = newJObject()
  var formData_606200 = newJObject()
  add(formData_606200, "ReservedNodeId", newJString(ReservedNodeId))
  add(formData_606200, "TargetReservedNodeOfferingId",
      newJString(TargetReservedNodeOfferingId))
  add(query_606199, "Action", newJString(Action))
  add(query_606199, "Version", newJString(Version))
  result = call_606198.call(nil, query_606199, nil, formData_606200, nil)

var postAcceptReservedNodeExchange* = Call_PostAcceptReservedNodeExchange_606183(
    name: "postAcceptReservedNodeExchange", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=AcceptReservedNodeExchange",
    validator: validate_PostAcceptReservedNodeExchange_606184, base: "/",
    url: url_PostAcceptReservedNodeExchange_606185,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetAcceptReservedNodeExchange_605911 = ref object of OpenApiRestCall_605573
proc url_GetAcceptReservedNodeExchange_605913(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetAcceptReservedNodeExchange_605912(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Exchanges a DC1 Reserved Node for a DC2 Reserved Node with no changes to the configuration (term, payment type, or number of nodes) and no additional costs. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   ReservedNodeId: JString (required)
  ##                 : A string representing the node identifier of the DC1 Reserved Node to be exchanged.
  ##   Version: JString (required)
  ##   TargetReservedNodeOfferingId: JString (required)
  ##                               : The unique identifier of the DC2 Reserved Node offering to be used for the exchange. You can obtain the value for the parameter by calling <a>GetReservedNodeExchangeOfferings</a> 
  section = newJObject()
  var valid_606038 = query.getOrDefault("Action")
  valid_606038 = validateParameter(valid_606038, JString, required = true, default = newJString(
      "AcceptReservedNodeExchange"))
  if valid_606038 != nil:
    section.add "Action", valid_606038
  var valid_606039 = query.getOrDefault("ReservedNodeId")
  valid_606039 = validateParameter(valid_606039, JString, required = true,
                                 default = nil)
  if valid_606039 != nil:
    section.add "ReservedNodeId", valid_606039
  var valid_606040 = query.getOrDefault("Version")
  valid_606040 = validateParameter(valid_606040, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_606040 != nil:
    section.add "Version", valid_606040
  var valid_606041 = query.getOrDefault("TargetReservedNodeOfferingId")
  valid_606041 = validateParameter(valid_606041, JString, required = true,
                                 default = nil)
  if valid_606041 != nil:
    section.add "TargetReservedNodeOfferingId", valid_606041
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_606042 = header.getOrDefault("X-Amz-Signature")
  valid_606042 = validateParameter(valid_606042, JString, required = false,
                                 default = nil)
  if valid_606042 != nil:
    section.add "X-Amz-Signature", valid_606042
  var valid_606043 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_606043 = validateParameter(valid_606043, JString, required = false,
                                 default = nil)
  if valid_606043 != nil:
    section.add "X-Amz-Content-Sha256", valid_606043
  var valid_606044 = header.getOrDefault("X-Amz-Date")
  valid_606044 = validateParameter(valid_606044, JString, required = false,
                                 default = nil)
  if valid_606044 != nil:
    section.add "X-Amz-Date", valid_606044
  var valid_606045 = header.getOrDefault("X-Amz-Credential")
  valid_606045 = validateParameter(valid_606045, JString, required = false,
                                 default = nil)
  if valid_606045 != nil:
    section.add "X-Amz-Credential", valid_606045
  var valid_606046 = header.getOrDefault("X-Amz-Security-Token")
  valid_606046 = validateParameter(valid_606046, JString, required = false,
                                 default = nil)
  if valid_606046 != nil:
    section.add "X-Amz-Security-Token", valid_606046
  var valid_606047 = header.getOrDefault("X-Amz-Algorithm")
  valid_606047 = validateParameter(valid_606047, JString, required = false,
                                 default = nil)
  if valid_606047 != nil:
    section.add "X-Amz-Algorithm", valid_606047
  var valid_606048 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_606048 = validateParameter(valid_606048, JString, required = false,
                                 default = nil)
  if valid_606048 != nil:
    section.add "X-Amz-SignedHeaders", valid_606048
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_606071: Call_GetAcceptReservedNodeExchange_605911; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Exchanges a DC1 Reserved Node for a DC2 Reserved Node with no changes to the configuration (term, payment type, or number of nodes) and no additional costs. 
  ## 
  let valid = call_606071.validator(path, query, header, formData, body)
  let scheme = call_606071.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_606071.url(scheme.get, call_606071.host, call_606071.base,
                         call_606071.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_606071, url, valid)

proc call*(call_606142: Call_GetAcceptReservedNodeExchange_605911;
          ReservedNodeId: string; TargetReservedNodeOfferingId: string;
          Action: string = "AcceptReservedNodeExchange";
          Version: string = "2012-12-01"): Recallable =
  ## getAcceptReservedNodeExchange
  ## Exchanges a DC1 Reserved Node for a DC2 Reserved Node with no changes to the configuration (term, payment type, or number of nodes) and no additional costs. 
  ##   Action: string (required)
  ##   ReservedNodeId: string (required)
  ##                 : A string representing the node identifier of the DC1 Reserved Node to be exchanged.
  ##   Version: string (required)
  ##   TargetReservedNodeOfferingId: string (required)
  ##                               : The unique identifier of the DC2 Reserved Node offering to be used for the exchange. You can obtain the value for the parameter by calling <a>GetReservedNodeExchangeOfferings</a> 
  var query_606143 = newJObject()
  add(query_606143, "Action", newJString(Action))
  add(query_606143, "ReservedNodeId", newJString(ReservedNodeId))
  add(query_606143, "Version", newJString(Version))
  add(query_606143, "TargetReservedNodeOfferingId",
      newJString(TargetReservedNodeOfferingId))
  result = call_606142.call(nil, query_606143, nil, nil, nil)

var getAcceptReservedNodeExchange* = Call_GetAcceptReservedNodeExchange_605911(
    name: "getAcceptReservedNodeExchange", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=AcceptReservedNodeExchange",
    validator: validate_GetAcceptReservedNodeExchange_605912, base: "/",
    url: url_GetAcceptReservedNodeExchange_605913,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostAuthorizeClusterSecurityGroupIngress_606220 = ref object of OpenApiRestCall_605573
proc url_PostAuthorizeClusterSecurityGroupIngress_606222(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostAuthorizeClusterSecurityGroupIngress_606221(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Adds an inbound (ingress) rule to an Amazon Redshift security group. Depending on whether the application accessing your cluster is running on the Internet or an Amazon EC2 instance, you can authorize inbound access to either a Classless Interdomain Routing (CIDR)/Internet Protocol (IP) range or to an Amazon EC2 security group. You can add as many as 20 ingress rules to an Amazon Redshift security group.</p> <p>If you authorize access to an Amazon EC2 security group, specify <i>EC2SecurityGroupName</i> and <i>EC2SecurityGroupOwnerId</i>. The Amazon EC2 security group and Amazon Redshift cluster must be in the same AWS Region. </p> <p>If you authorize access to a CIDR/IP address range, specify <i>CIDRIP</i>. For an overview of CIDR blocks, see the Wikipedia article on <a href="http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing">Classless Inter-Domain Routing</a>. </p> <p>You must also associate the security group with a cluster so that clients running on these IP addresses or the EC2 instance are authorized to connect to the cluster. For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Working with Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_606223 = query.getOrDefault("Action")
  valid_606223 = validateParameter(valid_606223, JString, required = true, default = newJString(
      "AuthorizeClusterSecurityGroupIngress"))
  if valid_606223 != nil:
    section.add "Action", valid_606223
  var valid_606224 = query.getOrDefault("Version")
  valid_606224 = validateParameter(valid_606224, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_606224 != nil:
    section.add "Version", valid_606224
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_606225 = header.getOrDefault("X-Amz-Signature")
  valid_606225 = validateParameter(valid_606225, JString, required = false,
                                 default = nil)
  if valid_606225 != nil:
    section.add "X-Amz-Signature", valid_606225
  var valid_606226 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_606226 = validateParameter(valid_606226, JString, required = false,
                                 default = nil)
  if valid_606226 != nil:
    section.add "X-Amz-Content-Sha256", valid_606226
  var valid_606227 = header.getOrDefault("X-Amz-Date")
  valid_606227 = validateParameter(valid_606227, JString, required = false,
                                 default = nil)
  if valid_606227 != nil:
    section.add "X-Amz-Date", valid_606227
  var valid_606228 = header.getOrDefault("X-Amz-Credential")
  valid_606228 = validateParameter(valid_606228, JString, required = false,
                                 default = nil)
  if valid_606228 != nil:
    section.add "X-Amz-Credential", valid_606228
  var valid_606229 = header.getOrDefault("X-Amz-Security-Token")
  valid_606229 = validateParameter(valid_606229, JString, required = false,
                                 default = nil)
  if valid_606229 != nil:
    section.add "X-Amz-Security-Token", valid_606229
  var valid_606230 = header.getOrDefault("X-Amz-Algorithm")
  valid_606230 = validateParameter(valid_606230, JString, required = false,
                                 default = nil)
  if valid_606230 != nil:
    section.add "X-Amz-Algorithm", valid_606230
  var valid_606231 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_606231 = validateParameter(valid_606231, JString, required = false,
                                 default = nil)
  if valid_606231 != nil:
    section.add "X-Amz-SignedHeaders", valid_606231
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterSecurityGroupName: JString (required)
  ##                           : The name of the security group to which the ingress rule is added.
  ##   EC2SecurityGroupName: JString
  ##                       : The EC2 security group to be added the Amazon Redshift security group.
  ##   EC2SecurityGroupOwnerId: JString
  ##                          : <p>The AWS account number of the owner of the security group specified by the <i>EC2SecurityGroupName</i> parameter. The AWS Access Key ID is not an acceptable value. </p> <p>Example: <code>111122223333</code> </p>
  ##   CIDRIP: JString
  ##         : The IP range to be added the Amazon Redshift security group.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterSecurityGroupName` field"
  var valid_606232 = formData.getOrDefault("ClusterSecurityGroupName")
  valid_606232 = validateParameter(valid_606232, JString, required = true,
                                 default = nil)
  if valid_606232 != nil:
    section.add "ClusterSecurityGroupName", valid_606232
  var valid_606233 = formData.getOrDefault("EC2SecurityGroupName")
  valid_606233 = validateParameter(valid_606233, JString, required = false,
                                 default = nil)
  if valid_606233 != nil:
    section.add "EC2SecurityGroupName", valid_606233
  var valid_606234 = formData.getOrDefault("EC2SecurityGroupOwnerId")
  valid_606234 = validateParameter(valid_606234, JString, required = false,
                                 default = nil)
  if valid_606234 != nil:
    section.add "EC2SecurityGroupOwnerId", valid_606234
  var valid_606235 = formData.getOrDefault("CIDRIP")
  valid_606235 = validateParameter(valid_606235, JString, required = false,
                                 default = nil)
  if valid_606235 != nil:
    section.add "CIDRIP", valid_606235
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_606236: Call_PostAuthorizeClusterSecurityGroupIngress_606220;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Adds an inbound (ingress) rule to an Amazon Redshift security group. Depending on whether the application accessing your cluster is running on the Internet or an Amazon EC2 instance, you can authorize inbound access to either a Classless Interdomain Routing (CIDR)/Internet Protocol (IP) range or to an Amazon EC2 security group. You can add as many as 20 ingress rules to an Amazon Redshift security group.</p> <p>If you authorize access to an Amazon EC2 security group, specify <i>EC2SecurityGroupName</i> and <i>EC2SecurityGroupOwnerId</i>. The Amazon EC2 security group and Amazon Redshift cluster must be in the same AWS Region. </p> <p>If you authorize access to a CIDR/IP address range, specify <i>CIDRIP</i>. For an overview of CIDR blocks, see the Wikipedia article on <a href="http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing">Classless Inter-Domain Routing</a>. </p> <p>You must also associate the security group with a cluster so that clients running on these IP addresses or the EC2 instance are authorized to connect to the cluster. For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Working with Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_606236.validator(path, query, header, formData, body)
  let scheme = call_606236.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_606236.url(scheme.get, call_606236.host, call_606236.base,
                         call_606236.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_606236, url, valid)

proc call*(call_606237: Call_PostAuthorizeClusterSecurityGroupIngress_606220;
          ClusterSecurityGroupName: string; EC2SecurityGroupName: string = "";
          EC2SecurityGroupOwnerId: string = ""; CIDRIP: string = "";
          Action: string = "AuthorizeClusterSecurityGroupIngress";
          Version: string = "2012-12-01"): Recallable =
  ## postAuthorizeClusterSecurityGroupIngress
  ## <p>Adds an inbound (ingress) rule to an Amazon Redshift security group. Depending on whether the application accessing your cluster is running on the Internet or an Amazon EC2 instance, you can authorize inbound access to either a Classless Interdomain Routing (CIDR)/Internet Protocol (IP) range or to an Amazon EC2 security group. You can add as many as 20 ingress rules to an Amazon Redshift security group.</p> <p>If you authorize access to an Amazon EC2 security group, specify <i>EC2SecurityGroupName</i> and <i>EC2SecurityGroupOwnerId</i>. The Amazon EC2 security group and Amazon Redshift cluster must be in the same AWS Region. </p> <p>If you authorize access to a CIDR/IP address range, specify <i>CIDRIP</i>. For an overview of CIDR blocks, see the Wikipedia article on <a href="http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing">Classless Inter-Domain Routing</a>. </p> <p>You must also associate the security group with a cluster so that clients running on these IP addresses or the EC2 instance are authorized to connect to the cluster. For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Working with Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   ClusterSecurityGroupName: string (required)
  ##                           : The name of the security group to which the ingress rule is added.
  ##   EC2SecurityGroupName: string
  ##                       : The EC2 security group to be added the Amazon Redshift security group.
  ##   EC2SecurityGroupOwnerId: string
  ##                          : <p>The AWS account number of the owner of the security group specified by the <i>EC2SecurityGroupName</i> parameter. The AWS Access Key ID is not an acceptable value. </p> <p>Example: <code>111122223333</code> </p>
  ##   CIDRIP: string
  ##         : The IP range to be added the Amazon Redshift security group.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_606238 = newJObject()
  var formData_606239 = newJObject()
  add(formData_606239, "ClusterSecurityGroupName",
      newJString(ClusterSecurityGroupName))
  add(formData_606239, "EC2SecurityGroupName", newJString(EC2SecurityGroupName))
  add(formData_606239, "EC2SecurityGroupOwnerId",
      newJString(EC2SecurityGroupOwnerId))
  add(formData_606239, "CIDRIP", newJString(CIDRIP))
  add(query_606238, "Action", newJString(Action))
  add(query_606238, "Version", newJString(Version))
  result = call_606237.call(nil, query_606238, nil, formData_606239, nil)

var postAuthorizeClusterSecurityGroupIngress* = Call_PostAuthorizeClusterSecurityGroupIngress_606220(
    name: "postAuthorizeClusterSecurityGroupIngress", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=AuthorizeClusterSecurityGroupIngress",
    validator: validate_PostAuthorizeClusterSecurityGroupIngress_606221,
    base: "/", url: url_PostAuthorizeClusterSecurityGroupIngress_606222,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetAuthorizeClusterSecurityGroupIngress_606201 = ref object of OpenApiRestCall_605573
proc url_GetAuthorizeClusterSecurityGroupIngress_606203(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetAuthorizeClusterSecurityGroupIngress_606202(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Adds an inbound (ingress) rule to an Amazon Redshift security group. Depending on whether the application accessing your cluster is running on the Internet or an Amazon EC2 instance, you can authorize inbound access to either a Classless Interdomain Routing (CIDR)/Internet Protocol (IP) range or to an Amazon EC2 security group. You can add as many as 20 ingress rules to an Amazon Redshift security group.</p> <p>If you authorize access to an Amazon EC2 security group, specify <i>EC2SecurityGroupName</i> and <i>EC2SecurityGroupOwnerId</i>. The Amazon EC2 security group and Amazon Redshift cluster must be in the same AWS Region. </p> <p>If you authorize access to a CIDR/IP address range, specify <i>CIDRIP</i>. For an overview of CIDR blocks, see the Wikipedia article on <a href="http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing">Classless Inter-Domain Routing</a>. </p> <p>You must also associate the security group with a cluster so that clients running on these IP addresses or the EC2 instance are authorized to connect to the cluster. For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Working with Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   EC2SecurityGroupName: JString
  ##                       : The EC2 security group to be added the Amazon Redshift security group.
  ##   EC2SecurityGroupOwnerId: JString
  ##                          : <p>The AWS account number of the owner of the security group specified by the <i>EC2SecurityGroupName</i> parameter. The AWS Access Key ID is not an acceptable value. </p> <p>Example: <code>111122223333</code> </p>
  ##   ClusterSecurityGroupName: JString (required)
  ##                           : The name of the security group to which the ingress rule is added.
  ##   Action: JString (required)
  ##   Version: JString (required)
  ##   CIDRIP: JString
  ##         : The IP range to be added the Amazon Redshift security group.
  section = newJObject()
  var valid_606204 = query.getOrDefault("EC2SecurityGroupName")
  valid_606204 = validateParameter(valid_606204, JString, required = false,
                                 default = nil)
  if valid_606204 != nil:
    section.add "EC2SecurityGroupName", valid_606204
  var valid_606205 = query.getOrDefault("EC2SecurityGroupOwnerId")
  valid_606205 = validateParameter(valid_606205, JString, required = false,
                                 default = nil)
  if valid_606205 != nil:
    section.add "EC2SecurityGroupOwnerId", valid_606205
  assert query != nil, "query argument is necessary due to required `ClusterSecurityGroupName` field"
  var valid_606206 = query.getOrDefault("ClusterSecurityGroupName")
  valid_606206 = validateParameter(valid_606206, JString, required = true,
                                 default = nil)
  if valid_606206 != nil:
    section.add "ClusterSecurityGroupName", valid_606206
  var valid_606207 = query.getOrDefault("Action")
  valid_606207 = validateParameter(valid_606207, JString, required = true, default = newJString(
      "AuthorizeClusterSecurityGroupIngress"))
  if valid_606207 != nil:
    section.add "Action", valid_606207
  var valid_606208 = query.getOrDefault("Version")
  valid_606208 = validateParameter(valid_606208, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_606208 != nil:
    section.add "Version", valid_606208
  var valid_606209 = query.getOrDefault("CIDRIP")
  valid_606209 = validateParameter(valid_606209, JString, required = false,
                                 default = nil)
  if valid_606209 != nil:
    section.add "CIDRIP", valid_606209
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_606210 = header.getOrDefault("X-Amz-Signature")
  valid_606210 = validateParameter(valid_606210, JString, required = false,
                                 default = nil)
  if valid_606210 != nil:
    section.add "X-Amz-Signature", valid_606210
  var valid_606211 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_606211 = validateParameter(valid_606211, JString, required = false,
                                 default = nil)
  if valid_606211 != nil:
    section.add "X-Amz-Content-Sha256", valid_606211
  var valid_606212 = header.getOrDefault("X-Amz-Date")
  valid_606212 = validateParameter(valid_606212, JString, required = false,
                                 default = nil)
  if valid_606212 != nil:
    section.add "X-Amz-Date", valid_606212
  var valid_606213 = header.getOrDefault("X-Amz-Credential")
  valid_606213 = validateParameter(valid_606213, JString, required = false,
                                 default = nil)
  if valid_606213 != nil:
    section.add "X-Amz-Credential", valid_606213
  var valid_606214 = header.getOrDefault("X-Amz-Security-Token")
  valid_606214 = validateParameter(valid_606214, JString, required = false,
                                 default = nil)
  if valid_606214 != nil:
    section.add "X-Amz-Security-Token", valid_606214
  var valid_606215 = header.getOrDefault("X-Amz-Algorithm")
  valid_606215 = validateParameter(valid_606215, JString, required = false,
                                 default = nil)
  if valid_606215 != nil:
    section.add "X-Amz-Algorithm", valid_606215
  var valid_606216 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_606216 = validateParameter(valid_606216, JString, required = false,
                                 default = nil)
  if valid_606216 != nil:
    section.add "X-Amz-SignedHeaders", valid_606216
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_606217: Call_GetAuthorizeClusterSecurityGroupIngress_606201;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Adds an inbound (ingress) rule to an Amazon Redshift security group. Depending on whether the application accessing your cluster is running on the Internet or an Amazon EC2 instance, you can authorize inbound access to either a Classless Interdomain Routing (CIDR)/Internet Protocol (IP) range or to an Amazon EC2 security group. You can add as many as 20 ingress rules to an Amazon Redshift security group.</p> <p>If you authorize access to an Amazon EC2 security group, specify <i>EC2SecurityGroupName</i> and <i>EC2SecurityGroupOwnerId</i>. The Amazon EC2 security group and Amazon Redshift cluster must be in the same AWS Region. </p> <p>If you authorize access to a CIDR/IP address range, specify <i>CIDRIP</i>. For an overview of CIDR blocks, see the Wikipedia article on <a href="http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing">Classless Inter-Domain Routing</a>. </p> <p>You must also associate the security group with a cluster so that clients running on these IP addresses or the EC2 instance are authorized to connect to the cluster. For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Working with Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_606217.validator(path, query, header, formData, body)
  let scheme = call_606217.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_606217.url(scheme.get, call_606217.host, call_606217.base,
                         call_606217.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_606217, url, valid)

proc call*(call_606218: Call_GetAuthorizeClusterSecurityGroupIngress_606201;
          ClusterSecurityGroupName: string; EC2SecurityGroupName: string = "";
          EC2SecurityGroupOwnerId: string = "";
          Action: string = "AuthorizeClusterSecurityGroupIngress";
          Version: string = "2012-12-01"; CIDRIP: string = ""): Recallable =
  ## getAuthorizeClusterSecurityGroupIngress
  ## <p>Adds an inbound (ingress) rule to an Amazon Redshift security group. Depending on whether the application accessing your cluster is running on the Internet or an Amazon EC2 instance, you can authorize inbound access to either a Classless Interdomain Routing (CIDR)/Internet Protocol (IP) range or to an Amazon EC2 security group. You can add as many as 20 ingress rules to an Amazon Redshift security group.</p> <p>If you authorize access to an Amazon EC2 security group, specify <i>EC2SecurityGroupName</i> and <i>EC2SecurityGroupOwnerId</i>. The Amazon EC2 security group and Amazon Redshift cluster must be in the same AWS Region. </p> <p>If you authorize access to a CIDR/IP address range, specify <i>CIDRIP</i>. For an overview of CIDR blocks, see the Wikipedia article on <a href="http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing">Classless Inter-Domain Routing</a>. </p> <p>You must also associate the security group with a cluster so that clients running on these IP addresses or the EC2 instance are authorized to connect to the cluster. For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Working with Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   EC2SecurityGroupName: string
  ##                       : The EC2 security group to be added the Amazon Redshift security group.
  ##   EC2SecurityGroupOwnerId: string
  ##                          : <p>The AWS account number of the owner of the security group specified by the <i>EC2SecurityGroupName</i> parameter. The AWS Access Key ID is not an acceptable value. </p> <p>Example: <code>111122223333</code> </p>
  ##   ClusterSecurityGroupName: string (required)
  ##                           : The name of the security group to which the ingress rule is added.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   CIDRIP: string
  ##         : The IP range to be added the Amazon Redshift security group.
  var query_606219 = newJObject()
  add(query_606219, "EC2SecurityGroupName", newJString(EC2SecurityGroupName))
  add(query_606219, "EC2SecurityGroupOwnerId", newJString(EC2SecurityGroupOwnerId))
  add(query_606219, "ClusterSecurityGroupName",
      newJString(ClusterSecurityGroupName))
  add(query_606219, "Action", newJString(Action))
  add(query_606219, "Version", newJString(Version))
  add(query_606219, "CIDRIP", newJString(CIDRIP))
  result = call_606218.call(nil, query_606219, nil, nil, nil)

var getAuthorizeClusterSecurityGroupIngress* = Call_GetAuthorizeClusterSecurityGroupIngress_606201(
    name: "getAuthorizeClusterSecurityGroupIngress", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=AuthorizeClusterSecurityGroupIngress",
    validator: validate_GetAuthorizeClusterSecurityGroupIngress_606202, base: "/",
    url: url_GetAuthorizeClusterSecurityGroupIngress_606203,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostAuthorizeSnapshotAccess_606258 = ref object of OpenApiRestCall_605573
proc url_PostAuthorizeSnapshotAccess_606260(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostAuthorizeSnapshotAccess_606259(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Authorizes the specified AWS customer account to restore the specified snapshot.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_606261 = query.getOrDefault("Action")
  valid_606261 = validateParameter(valid_606261, JString, required = true, default = newJString(
      "AuthorizeSnapshotAccess"))
  if valid_606261 != nil:
    section.add "Action", valid_606261
  var valid_606262 = query.getOrDefault("Version")
  valid_606262 = validateParameter(valid_606262, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_606262 != nil:
    section.add "Version", valid_606262
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_606263 = header.getOrDefault("X-Amz-Signature")
  valid_606263 = validateParameter(valid_606263, JString, required = false,
                                 default = nil)
  if valid_606263 != nil:
    section.add "X-Amz-Signature", valid_606263
  var valid_606264 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_606264 = validateParameter(valid_606264, JString, required = false,
                                 default = nil)
  if valid_606264 != nil:
    section.add "X-Amz-Content-Sha256", valid_606264
  var valid_606265 = header.getOrDefault("X-Amz-Date")
  valid_606265 = validateParameter(valid_606265, JString, required = false,
                                 default = nil)
  if valid_606265 != nil:
    section.add "X-Amz-Date", valid_606265
  var valid_606266 = header.getOrDefault("X-Amz-Credential")
  valid_606266 = validateParameter(valid_606266, JString, required = false,
                                 default = nil)
  if valid_606266 != nil:
    section.add "X-Amz-Credential", valid_606266
  var valid_606267 = header.getOrDefault("X-Amz-Security-Token")
  valid_606267 = validateParameter(valid_606267, JString, required = false,
                                 default = nil)
  if valid_606267 != nil:
    section.add "X-Amz-Security-Token", valid_606267
  var valid_606268 = header.getOrDefault("X-Amz-Algorithm")
  valid_606268 = validateParameter(valid_606268, JString, required = false,
                                 default = nil)
  if valid_606268 != nil:
    section.add "X-Amz-Algorithm", valid_606268
  var valid_606269 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_606269 = validateParameter(valid_606269, JString, required = false,
                                 default = nil)
  if valid_606269 != nil:
    section.add "X-Amz-SignedHeaders", valid_606269
  result.add "header", section
  ## parameters in `formData` object:
  ##   SnapshotIdentifier: JString (required)
  ##                     : The identifier of the snapshot the account is authorized to restore.
  ##   AccountWithRestoreAccess: JString (required)
  ##                           : <p>The identifier of the AWS customer account authorized to restore the specified snapshot.</p> <p>To share a snapshot with AWS support, specify amazon-redshift-support.</p>
  ##   SnapshotClusterIdentifier: JString
  ##                            : The identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `SnapshotIdentifier` field"
  var valid_606270 = formData.getOrDefault("SnapshotIdentifier")
  valid_606270 = validateParameter(valid_606270, JString, required = true,
                                 default = nil)
  if valid_606270 != nil:
    section.add "SnapshotIdentifier", valid_606270
  var valid_606271 = formData.getOrDefault("AccountWithRestoreAccess")
  valid_606271 = validateParameter(valid_606271, JString, required = true,
                                 default = nil)
  if valid_606271 != nil:
    section.add "AccountWithRestoreAccess", valid_606271
  var valid_606272 = formData.getOrDefault("SnapshotClusterIdentifier")
  valid_606272 = validateParameter(valid_606272, JString, required = false,
                                 default = nil)
  if valid_606272 != nil:
    section.add "SnapshotClusterIdentifier", valid_606272
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_606273: Call_PostAuthorizeSnapshotAccess_606258; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Authorizes the specified AWS customer account to restore the specified snapshot.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_606273.validator(path, query, header, formData, body)
  let scheme = call_606273.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_606273.url(scheme.get, call_606273.host, call_606273.base,
                         call_606273.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_606273, url, valid)

proc call*(call_606274: Call_PostAuthorizeSnapshotAccess_606258;
          SnapshotIdentifier: string; AccountWithRestoreAccess: string;
          Action: string = "AuthorizeSnapshotAccess";
          SnapshotClusterIdentifier: string = ""; Version: string = "2012-12-01"): Recallable =
  ## postAuthorizeSnapshotAccess
  ## <p>Authorizes the specified AWS customer account to restore the specified snapshot.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   SnapshotIdentifier: string (required)
  ##                     : The identifier of the snapshot the account is authorized to restore.
  ##   Action: string (required)
  ##   AccountWithRestoreAccess: string (required)
  ##                           : <p>The identifier of the AWS customer account authorized to restore the specified snapshot.</p> <p>To share a snapshot with AWS support, specify amazon-redshift-support.</p>
  ##   SnapshotClusterIdentifier: string
  ##                            : The identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.
  ##   Version: string (required)
  var query_606275 = newJObject()
  var formData_606276 = newJObject()
  add(formData_606276, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_606275, "Action", newJString(Action))
  add(formData_606276, "AccountWithRestoreAccess",
      newJString(AccountWithRestoreAccess))
  add(formData_606276, "SnapshotClusterIdentifier",
      newJString(SnapshotClusterIdentifier))
  add(query_606275, "Version", newJString(Version))
  result = call_606274.call(nil, query_606275, nil, formData_606276, nil)

var postAuthorizeSnapshotAccess* = Call_PostAuthorizeSnapshotAccess_606258(
    name: "postAuthorizeSnapshotAccess", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=AuthorizeSnapshotAccess",
    validator: validate_PostAuthorizeSnapshotAccess_606259, base: "/",
    url: url_PostAuthorizeSnapshotAccess_606260,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetAuthorizeSnapshotAccess_606240 = ref object of OpenApiRestCall_605573
proc url_GetAuthorizeSnapshotAccess_606242(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetAuthorizeSnapshotAccess_606241(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Authorizes the specified AWS customer account to restore the specified snapshot.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   SnapshotIdentifier: JString (required)
  ##                     : The identifier of the snapshot the account is authorized to restore.
  ##   SnapshotClusterIdentifier: JString
  ##                            : The identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.
  ##   Action: JString (required)
  ##   Version: JString (required)
  ##   AccountWithRestoreAccess: JString (required)
  ##                           : <p>The identifier of the AWS customer account authorized to restore the specified snapshot.</p> <p>To share a snapshot with AWS support, specify amazon-redshift-support.</p>
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `SnapshotIdentifier` field"
  var valid_606243 = query.getOrDefault("SnapshotIdentifier")
  valid_606243 = validateParameter(valid_606243, JString, required = true,
                                 default = nil)
  if valid_606243 != nil:
    section.add "SnapshotIdentifier", valid_606243
  var valid_606244 = query.getOrDefault("SnapshotClusterIdentifier")
  valid_606244 = validateParameter(valid_606244, JString, required = false,
                                 default = nil)
  if valid_606244 != nil:
    section.add "SnapshotClusterIdentifier", valid_606244
  var valid_606245 = query.getOrDefault("Action")
  valid_606245 = validateParameter(valid_606245, JString, required = true, default = newJString(
      "AuthorizeSnapshotAccess"))
  if valid_606245 != nil:
    section.add "Action", valid_606245
  var valid_606246 = query.getOrDefault("Version")
  valid_606246 = validateParameter(valid_606246, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_606246 != nil:
    section.add "Version", valid_606246
  var valid_606247 = query.getOrDefault("AccountWithRestoreAccess")
  valid_606247 = validateParameter(valid_606247, JString, required = true,
                                 default = nil)
  if valid_606247 != nil:
    section.add "AccountWithRestoreAccess", valid_606247
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_606248 = header.getOrDefault("X-Amz-Signature")
  valid_606248 = validateParameter(valid_606248, JString, required = false,
                                 default = nil)
  if valid_606248 != nil:
    section.add "X-Amz-Signature", valid_606248
  var valid_606249 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_606249 = validateParameter(valid_606249, JString, required = false,
                                 default = nil)
  if valid_606249 != nil:
    section.add "X-Amz-Content-Sha256", valid_606249
  var valid_606250 = header.getOrDefault("X-Amz-Date")
  valid_606250 = validateParameter(valid_606250, JString, required = false,
                                 default = nil)
  if valid_606250 != nil:
    section.add "X-Amz-Date", valid_606250
  var valid_606251 = header.getOrDefault("X-Amz-Credential")
  valid_606251 = validateParameter(valid_606251, JString, required = false,
                                 default = nil)
  if valid_606251 != nil:
    section.add "X-Amz-Credential", valid_606251
  var valid_606252 = header.getOrDefault("X-Amz-Security-Token")
  valid_606252 = validateParameter(valid_606252, JString, required = false,
                                 default = nil)
  if valid_606252 != nil:
    section.add "X-Amz-Security-Token", valid_606252
  var valid_606253 = header.getOrDefault("X-Amz-Algorithm")
  valid_606253 = validateParameter(valid_606253, JString, required = false,
                                 default = nil)
  if valid_606253 != nil:
    section.add "X-Amz-Algorithm", valid_606253
  var valid_606254 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_606254 = validateParameter(valid_606254, JString, required = false,
                                 default = nil)
  if valid_606254 != nil:
    section.add "X-Amz-SignedHeaders", valid_606254
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_606255: Call_GetAuthorizeSnapshotAccess_606240; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Authorizes the specified AWS customer account to restore the specified snapshot.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_606255.validator(path, query, header, formData, body)
  let scheme = call_606255.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_606255.url(scheme.get, call_606255.host, call_606255.base,
                         call_606255.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_606255, url, valid)

proc call*(call_606256: Call_GetAuthorizeSnapshotAccess_606240;
          SnapshotIdentifier: string; AccountWithRestoreAccess: string;
          SnapshotClusterIdentifier: string = "";
          Action: string = "AuthorizeSnapshotAccess"; Version: string = "2012-12-01"): Recallable =
  ## getAuthorizeSnapshotAccess
  ## <p>Authorizes the specified AWS customer account to restore the specified snapshot.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   SnapshotIdentifier: string (required)
  ##                     : The identifier of the snapshot the account is authorized to restore.
  ##   SnapshotClusterIdentifier: string
  ##                            : The identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   AccountWithRestoreAccess: string (required)
  ##                           : <p>The identifier of the AWS customer account authorized to restore the specified snapshot.</p> <p>To share a snapshot with AWS support, specify amazon-redshift-support.</p>
  var query_606257 = newJObject()
  add(query_606257, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_606257, "SnapshotClusterIdentifier",
      newJString(SnapshotClusterIdentifier))
  add(query_606257, "Action", newJString(Action))
  add(query_606257, "Version", newJString(Version))
  add(query_606257, "AccountWithRestoreAccess",
      newJString(AccountWithRestoreAccess))
  result = call_606256.call(nil, query_606257, nil, nil, nil)

var getAuthorizeSnapshotAccess* = Call_GetAuthorizeSnapshotAccess_606240(
    name: "getAuthorizeSnapshotAccess", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=AuthorizeSnapshotAccess",
    validator: validate_GetAuthorizeSnapshotAccess_606241, base: "/",
    url: url_GetAuthorizeSnapshotAccess_606242,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostBatchDeleteClusterSnapshots_606293 = ref object of OpenApiRestCall_605573
proc url_PostBatchDeleteClusterSnapshots_606295(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostBatchDeleteClusterSnapshots_606294(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a set of cluster snapshots.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_606296 = query.getOrDefault("Action")
  valid_606296 = validateParameter(valid_606296, JString, required = true, default = newJString(
      "BatchDeleteClusterSnapshots"))
  if valid_606296 != nil:
    section.add "Action", valid_606296
  var valid_606297 = query.getOrDefault("Version")
  valid_606297 = validateParameter(valid_606297, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_606297 != nil:
    section.add "Version", valid_606297
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_606298 = header.getOrDefault("X-Amz-Signature")
  valid_606298 = validateParameter(valid_606298, JString, required = false,
                                 default = nil)
  if valid_606298 != nil:
    section.add "X-Amz-Signature", valid_606298
  var valid_606299 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_606299 = validateParameter(valid_606299, JString, required = false,
                                 default = nil)
  if valid_606299 != nil:
    section.add "X-Amz-Content-Sha256", valid_606299
  var valid_606300 = header.getOrDefault("X-Amz-Date")
  valid_606300 = validateParameter(valid_606300, JString, required = false,
                                 default = nil)
  if valid_606300 != nil:
    section.add "X-Amz-Date", valid_606300
  var valid_606301 = header.getOrDefault("X-Amz-Credential")
  valid_606301 = validateParameter(valid_606301, JString, required = false,
                                 default = nil)
  if valid_606301 != nil:
    section.add "X-Amz-Credential", valid_606301
  var valid_606302 = header.getOrDefault("X-Amz-Security-Token")
  valid_606302 = validateParameter(valid_606302, JString, required = false,
                                 default = nil)
  if valid_606302 != nil:
    section.add "X-Amz-Security-Token", valid_606302
  var valid_606303 = header.getOrDefault("X-Amz-Algorithm")
  valid_606303 = validateParameter(valid_606303, JString, required = false,
                                 default = nil)
  if valid_606303 != nil:
    section.add "X-Amz-Algorithm", valid_606303
  var valid_606304 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_606304 = validateParameter(valid_606304, JString, required = false,
                                 default = nil)
  if valid_606304 != nil:
    section.add "X-Amz-SignedHeaders", valid_606304
  result.add "header", section
  ## parameters in `formData` object:
  ##   Identifiers: JArray (required)
  ##              : A list of identifiers for the snapshots that you want to delete.
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `Identifiers` field"
  var valid_606305 = formData.getOrDefault("Identifiers")
  valid_606305 = validateParameter(valid_606305, JArray, required = true, default = nil)
  if valid_606305 != nil:
    section.add "Identifiers", valid_606305
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_606306: Call_PostBatchDeleteClusterSnapshots_606293;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Deletes a set of cluster snapshots.
  ## 
  let valid = call_606306.validator(path, query, header, formData, body)
  let scheme = call_606306.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_606306.url(scheme.get, call_606306.host, call_606306.base,
                         call_606306.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_606306, url, valid)

proc call*(call_606307: Call_PostBatchDeleteClusterSnapshots_606293;
          Identifiers: JsonNode; Action: string = "BatchDeleteClusterSnapshots";
          Version: string = "2012-12-01"): Recallable =
  ## postBatchDeleteClusterSnapshots
  ## Deletes a set of cluster snapshots.
  ##   Identifiers: JArray (required)
  ##              : A list of identifiers for the snapshots that you want to delete.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_606308 = newJObject()
  var formData_606309 = newJObject()
  if Identifiers != nil:
    formData_606309.add "Identifiers", Identifiers
  add(query_606308, "Action", newJString(Action))
  add(query_606308, "Version", newJString(Version))
  result = call_606307.call(nil, query_606308, nil, formData_606309, nil)

var postBatchDeleteClusterSnapshots* = Call_PostBatchDeleteClusterSnapshots_606293(
    name: "postBatchDeleteClusterSnapshots", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=BatchDeleteClusterSnapshots",
    validator: validate_PostBatchDeleteClusterSnapshots_606294, base: "/",
    url: url_PostBatchDeleteClusterSnapshots_606295,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetBatchDeleteClusterSnapshots_606277 = ref object of OpenApiRestCall_605573
proc url_GetBatchDeleteClusterSnapshots_606279(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetBatchDeleteClusterSnapshots_606278(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a set of cluster snapshots.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Identifiers: JArray (required)
  ##              : A list of identifiers for the snapshots that you want to delete.
  ##   Version: JString (required)
  section = newJObject()
  var valid_606280 = query.getOrDefault("Action")
  valid_606280 = validateParameter(valid_606280, JString, required = true, default = newJString(
      "BatchDeleteClusterSnapshots"))
  if valid_606280 != nil:
    section.add "Action", valid_606280
  var valid_606281 = query.getOrDefault("Identifiers")
  valid_606281 = validateParameter(valid_606281, JArray, required = true, default = nil)
  if valid_606281 != nil:
    section.add "Identifiers", valid_606281
  var valid_606282 = query.getOrDefault("Version")
  valid_606282 = validateParameter(valid_606282, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_606282 != nil:
    section.add "Version", valid_606282
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_606283 = header.getOrDefault("X-Amz-Signature")
  valid_606283 = validateParameter(valid_606283, JString, required = false,
                                 default = nil)
  if valid_606283 != nil:
    section.add "X-Amz-Signature", valid_606283
  var valid_606284 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_606284 = validateParameter(valid_606284, JString, required = false,
                                 default = nil)
  if valid_606284 != nil:
    section.add "X-Amz-Content-Sha256", valid_606284
  var valid_606285 = header.getOrDefault("X-Amz-Date")
  valid_606285 = validateParameter(valid_606285, JString, required = false,
                                 default = nil)
  if valid_606285 != nil:
    section.add "X-Amz-Date", valid_606285
  var valid_606286 = header.getOrDefault("X-Amz-Credential")
  valid_606286 = validateParameter(valid_606286, JString, required = false,
                                 default = nil)
  if valid_606286 != nil:
    section.add "X-Amz-Credential", valid_606286
  var valid_606287 = header.getOrDefault("X-Amz-Security-Token")
  valid_606287 = validateParameter(valid_606287, JString, required = false,
                                 default = nil)
  if valid_606287 != nil:
    section.add "X-Amz-Security-Token", valid_606287
  var valid_606288 = header.getOrDefault("X-Amz-Algorithm")
  valid_606288 = validateParameter(valid_606288, JString, required = false,
                                 default = nil)
  if valid_606288 != nil:
    section.add "X-Amz-Algorithm", valid_606288
  var valid_606289 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_606289 = validateParameter(valid_606289, JString, required = false,
                                 default = nil)
  if valid_606289 != nil:
    section.add "X-Amz-SignedHeaders", valid_606289
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_606290: Call_GetBatchDeleteClusterSnapshots_606277; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a set of cluster snapshots.
  ## 
  let valid = call_606290.validator(path, query, header, formData, body)
  let scheme = call_606290.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_606290.url(scheme.get, call_606290.host, call_606290.base,
                         call_606290.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_606290, url, valid)

proc call*(call_606291: Call_GetBatchDeleteClusterSnapshots_606277;
          Identifiers: JsonNode; Action: string = "BatchDeleteClusterSnapshots";
          Version: string = "2012-12-01"): Recallable =
  ## getBatchDeleteClusterSnapshots
  ## Deletes a set of cluster snapshots.
  ##   Action: string (required)
  ##   Identifiers: JArray (required)
  ##              : A list of identifiers for the snapshots that you want to delete.
  ##   Version: string (required)
  var query_606292 = newJObject()
  add(query_606292, "Action", newJString(Action))
  if Identifiers != nil:
    query_606292.add "Identifiers", Identifiers
  add(query_606292, "Version", newJString(Version))
  result = call_606291.call(nil, query_606292, nil, nil, nil)

var getBatchDeleteClusterSnapshots* = Call_GetBatchDeleteClusterSnapshots_606277(
    name: "getBatchDeleteClusterSnapshots", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=BatchDeleteClusterSnapshots",
    validator: validate_GetBatchDeleteClusterSnapshots_606278, base: "/",
    url: url_GetBatchDeleteClusterSnapshots_606279,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostBatchModifyClusterSnapshots_606328 = ref object of OpenApiRestCall_605573
proc url_PostBatchModifyClusterSnapshots_606330(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostBatchModifyClusterSnapshots_606329(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies the settings for a set of cluster snapshots.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_606331 = query.getOrDefault("Action")
  valid_606331 = validateParameter(valid_606331, JString, required = true, default = newJString(
      "BatchModifyClusterSnapshots"))
  if valid_606331 != nil:
    section.add "Action", valid_606331
  var valid_606332 = query.getOrDefault("Version")
  valid_606332 = validateParameter(valid_606332, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_606332 != nil:
    section.add "Version", valid_606332
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_606333 = header.getOrDefault("X-Amz-Signature")
  valid_606333 = validateParameter(valid_606333, JString, required = false,
                                 default = nil)
  if valid_606333 != nil:
    section.add "X-Amz-Signature", valid_606333
  var valid_606334 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_606334 = validateParameter(valid_606334, JString, required = false,
                                 default = nil)
  if valid_606334 != nil:
    section.add "X-Amz-Content-Sha256", valid_606334
  var valid_606335 = header.getOrDefault("X-Amz-Date")
  valid_606335 = validateParameter(valid_606335, JString, required = false,
                                 default = nil)
  if valid_606335 != nil:
    section.add "X-Amz-Date", valid_606335
  var valid_606336 = header.getOrDefault("X-Amz-Credential")
  valid_606336 = validateParameter(valid_606336, JString, required = false,
                                 default = nil)
  if valid_606336 != nil:
    section.add "X-Amz-Credential", valid_606336
  var valid_606337 = header.getOrDefault("X-Amz-Security-Token")
  valid_606337 = validateParameter(valid_606337, JString, required = false,
                                 default = nil)
  if valid_606337 != nil:
    section.add "X-Amz-Security-Token", valid_606337
  var valid_606338 = header.getOrDefault("X-Amz-Algorithm")
  valid_606338 = validateParameter(valid_606338, JString, required = false,
                                 default = nil)
  if valid_606338 != nil:
    section.add "X-Amz-Algorithm", valid_606338
  var valid_606339 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_606339 = validateParameter(valid_606339, JString, required = false,
                                 default = nil)
  if valid_606339 != nil:
    section.add "X-Amz-SignedHeaders", valid_606339
  result.add "header", section
  ## parameters in `formData` object:
  ##   Force: JBool
  ##        : A boolean value indicating whether to override an exception if the retention period has passed. 
  ##   SnapshotIdentifierList: JArray (required)
  ##                         : A list of snapshot identifiers you want to modify.
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The number of days that a manual snapshot is retained. If you specify the value -1, the manual snapshot is retained indefinitely.</p> <p>The number must be either -1 or an integer between 1 and 3,653.</p> <p>If you decrease the manual snapshot retention period from its current value, existing manual snapshots that fall outside of the new retention period will return an error. If you want to suppress the errors and delete the snapshots, use the force option. </p>
  section = newJObject()
  var valid_606340 = formData.getOrDefault("Force")
  valid_606340 = validateParameter(valid_606340, JBool, required = false, default = nil)
  if valid_606340 != nil:
    section.add "Force", valid_606340
  assert formData != nil, "formData argument is necessary due to required `SnapshotIdentifierList` field"
  var valid_606341 = formData.getOrDefault("SnapshotIdentifierList")
  valid_606341 = validateParameter(valid_606341, JArray, required = true, default = nil)
  if valid_606341 != nil:
    section.add "SnapshotIdentifierList", valid_606341
  var valid_606342 = formData.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_606342 = validateParameter(valid_606342, JInt, required = false, default = nil)
  if valid_606342 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_606342
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_606343: Call_PostBatchModifyClusterSnapshots_606328;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Modifies the settings for a set of cluster snapshots.
  ## 
  let valid = call_606343.validator(path, query, header, formData, body)
  let scheme = call_606343.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_606343.url(scheme.get, call_606343.host, call_606343.base,
                         call_606343.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_606343, url, valid)

proc call*(call_606344: Call_PostBatchModifyClusterSnapshots_606328;
          SnapshotIdentifierList: JsonNode; Force: bool = false;
          Action: string = "BatchModifyClusterSnapshots";
          Version: string = "2012-12-01"; ManualSnapshotRetentionPeriod: int = 0): Recallable =
  ## postBatchModifyClusterSnapshots
  ## Modifies the settings for a set of cluster snapshots.
  ##   Force: bool
  ##        : A boolean value indicating whether to override an exception if the retention period has passed. 
  ##   SnapshotIdentifierList: JArray (required)
  ##                         : A list of snapshot identifiers you want to modify.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The number of days that a manual snapshot is retained. If you specify the value -1, the manual snapshot is retained indefinitely.</p> <p>The number must be either -1 or an integer between 1 and 3,653.</p> <p>If you decrease the manual snapshot retention period from its current value, existing manual snapshots that fall outside of the new retention period will return an error. If you want to suppress the errors and delete the snapshots, use the force option. </p>
  var query_606345 = newJObject()
  var formData_606346 = newJObject()
  add(formData_606346, "Force", newJBool(Force))
  if SnapshotIdentifierList != nil:
    formData_606346.add "SnapshotIdentifierList", SnapshotIdentifierList
  add(query_606345, "Action", newJString(Action))
  add(query_606345, "Version", newJString(Version))
  add(formData_606346, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  result = call_606344.call(nil, query_606345, nil, formData_606346, nil)

var postBatchModifyClusterSnapshots* = Call_PostBatchModifyClusterSnapshots_606328(
    name: "postBatchModifyClusterSnapshots", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=BatchModifyClusterSnapshots",
    validator: validate_PostBatchModifyClusterSnapshots_606329, base: "/",
    url: url_PostBatchModifyClusterSnapshots_606330,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetBatchModifyClusterSnapshots_606310 = ref object of OpenApiRestCall_605573
proc url_GetBatchModifyClusterSnapshots_606312(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetBatchModifyClusterSnapshots_606311(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies the settings for a set of cluster snapshots.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The number of days that a manual snapshot is retained. If you specify the value -1, the manual snapshot is retained indefinitely.</p> <p>The number must be either -1 or an integer between 1 and 3,653.</p> <p>If you decrease the manual snapshot retention period from its current value, existing manual snapshots that fall outside of the new retention period will return an error. If you want to suppress the errors and delete the snapshots, use the force option. </p>
  ##   Force: JBool
  ##        : A boolean value indicating whether to override an exception if the retention period has passed. 
  ##   Action: JString (required)
  ##   SnapshotIdentifierList: JArray (required)
  ##                         : A list of snapshot identifiers you want to modify.
  ##   Version: JString (required)
  section = newJObject()
  var valid_606313 = query.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_606313 = validateParameter(valid_606313, JInt, required = false, default = nil)
  if valid_606313 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_606313
  var valid_606314 = query.getOrDefault("Force")
  valid_606314 = validateParameter(valid_606314, JBool, required = false, default = nil)
  if valid_606314 != nil:
    section.add "Force", valid_606314
  var valid_606315 = query.getOrDefault("Action")
  valid_606315 = validateParameter(valid_606315, JString, required = true, default = newJString(
      "BatchModifyClusterSnapshots"))
  if valid_606315 != nil:
    section.add "Action", valid_606315
  var valid_606316 = query.getOrDefault("SnapshotIdentifierList")
  valid_606316 = validateParameter(valid_606316, JArray, required = true, default = nil)
  if valid_606316 != nil:
    section.add "SnapshotIdentifierList", valid_606316
  var valid_606317 = query.getOrDefault("Version")
  valid_606317 = validateParameter(valid_606317, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_606317 != nil:
    section.add "Version", valid_606317
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_606318 = header.getOrDefault("X-Amz-Signature")
  valid_606318 = validateParameter(valid_606318, JString, required = false,
                                 default = nil)
  if valid_606318 != nil:
    section.add "X-Amz-Signature", valid_606318
  var valid_606319 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_606319 = validateParameter(valid_606319, JString, required = false,
                                 default = nil)
  if valid_606319 != nil:
    section.add "X-Amz-Content-Sha256", valid_606319
  var valid_606320 = header.getOrDefault("X-Amz-Date")
  valid_606320 = validateParameter(valid_606320, JString, required = false,
                                 default = nil)
  if valid_606320 != nil:
    section.add "X-Amz-Date", valid_606320
  var valid_606321 = header.getOrDefault("X-Amz-Credential")
  valid_606321 = validateParameter(valid_606321, JString, required = false,
                                 default = nil)
  if valid_606321 != nil:
    section.add "X-Amz-Credential", valid_606321
  var valid_606322 = header.getOrDefault("X-Amz-Security-Token")
  valid_606322 = validateParameter(valid_606322, JString, required = false,
                                 default = nil)
  if valid_606322 != nil:
    section.add "X-Amz-Security-Token", valid_606322
  var valid_606323 = header.getOrDefault("X-Amz-Algorithm")
  valid_606323 = validateParameter(valid_606323, JString, required = false,
                                 default = nil)
  if valid_606323 != nil:
    section.add "X-Amz-Algorithm", valid_606323
  var valid_606324 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_606324 = validateParameter(valid_606324, JString, required = false,
                                 default = nil)
  if valid_606324 != nil:
    section.add "X-Amz-SignedHeaders", valid_606324
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_606325: Call_GetBatchModifyClusterSnapshots_606310; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Modifies the settings for a set of cluster snapshots.
  ## 
  let valid = call_606325.validator(path, query, header, formData, body)
  let scheme = call_606325.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_606325.url(scheme.get, call_606325.host, call_606325.base,
                         call_606325.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_606325, url, valid)

proc call*(call_606326: Call_GetBatchModifyClusterSnapshots_606310;
          SnapshotIdentifierList: JsonNode;
          ManualSnapshotRetentionPeriod: int = 0; Force: bool = false;
          Action: string = "BatchModifyClusterSnapshots";
          Version: string = "2012-12-01"): Recallable =
  ## getBatchModifyClusterSnapshots
  ## Modifies the settings for a set of cluster snapshots.
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The number of days that a manual snapshot is retained. If you specify the value -1, the manual snapshot is retained indefinitely.</p> <p>The number must be either -1 or an integer between 1 and 3,653.</p> <p>If you decrease the manual snapshot retention period from its current value, existing manual snapshots that fall outside of the new retention period will return an error. If you want to suppress the errors and delete the snapshots, use the force option. </p>
  ##   Force: bool
  ##        : A boolean value indicating whether to override an exception if the retention period has passed. 
  ##   Action: string (required)
  ##   SnapshotIdentifierList: JArray (required)
  ##                         : A list of snapshot identifiers you want to modify.
  ##   Version: string (required)
  var query_606327 = newJObject()
  add(query_606327, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  add(query_606327, "Force", newJBool(Force))
  add(query_606327, "Action", newJString(Action))
  if SnapshotIdentifierList != nil:
    query_606327.add "SnapshotIdentifierList", SnapshotIdentifierList
  add(query_606327, "Version", newJString(Version))
  result = call_606326.call(nil, query_606327, nil, nil, nil)

var getBatchModifyClusterSnapshots* = Call_GetBatchModifyClusterSnapshots_606310(
    name: "getBatchModifyClusterSnapshots", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=BatchModifyClusterSnapshots",
    validator: validate_GetBatchModifyClusterSnapshots_606311, base: "/",
    url: url_GetBatchModifyClusterSnapshots_606312,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCancelResize_606363 = ref object of OpenApiRestCall_605573
proc url_PostCancelResize_606365(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostCancelResize_606364(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Cancels a resize operation for a cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_606366 = query.getOrDefault("Action")
  valid_606366 = validateParameter(valid_606366, JString, required = true,
                                 default = newJString("CancelResize"))
  if valid_606366 != nil:
    section.add "Action", valid_606366
  var valid_606367 = query.getOrDefault("Version")
  valid_606367 = validateParameter(valid_606367, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_606367 != nil:
    section.add "Version", valid_606367
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_606368 = header.getOrDefault("X-Amz-Signature")
  valid_606368 = validateParameter(valid_606368, JString, required = false,
                                 default = nil)
  if valid_606368 != nil:
    section.add "X-Amz-Signature", valid_606368
  var valid_606369 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_606369 = validateParameter(valid_606369, JString, required = false,
                                 default = nil)
  if valid_606369 != nil:
    section.add "X-Amz-Content-Sha256", valid_606369
  var valid_606370 = header.getOrDefault("X-Amz-Date")
  valid_606370 = validateParameter(valid_606370, JString, required = false,
                                 default = nil)
  if valid_606370 != nil:
    section.add "X-Amz-Date", valid_606370
  var valid_606371 = header.getOrDefault("X-Amz-Credential")
  valid_606371 = validateParameter(valid_606371, JString, required = false,
                                 default = nil)
  if valid_606371 != nil:
    section.add "X-Amz-Credential", valid_606371
  var valid_606372 = header.getOrDefault("X-Amz-Security-Token")
  valid_606372 = validateParameter(valid_606372, JString, required = false,
                                 default = nil)
  if valid_606372 != nil:
    section.add "X-Amz-Security-Token", valid_606372
  var valid_606373 = header.getOrDefault("X-Amz-Algorithm")
  valid_606373 = validateParameter(valid_606373, JString, required = false,
                                 default = nil)
  if valid_606373 != nil:
    section.add "X-Amz-Algorithm", valid_606373
  var valid_606374 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_606374 = validateParameter(valid_606374, JString, required = false,
                                 default = nil)
  if valid_606374 != nil:
    section.add "X-Amz-SignedHeaders", valid_606374
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : The unique identifier for the cluster that you want to cancel a resize operation for.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_606375 = formData.getOrDefault("ClusterIdentifier")
  valid_606375 = validateParameter(valid_606375, JString, required = true,
                                 default = nil)
  if valid_606375 != nil:
    section.add "ClusterIdentifier", valid_606375
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_606376: Call_PostCancelResize_606363; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Cancels a resize operation for a cluster.
  ## 
  let valid = call_606376.validator(path, query, header, formData, body)
  let scheme = call_606376.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_606376.url(scheme.get, call_606376.host, call_606376.base,
                         call_606376.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_606376, url, valid)

proc call*(call_606377: Call_PostCancelResize_606363; ClusterIdentifier: string;
          Action: string = "CancelResize"; Version: string = "2012-12-01"): Recallable =
  ## postCancelResize
  ## Cancels a resize operation for a cluster.
  ##   ClusterIdentifier: string (required)
  ##                    : The unique identifier for the cluster that you want to cancel a resize operation for.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_606378 = newJObject()
  var formData_606379 = newJObject()
  add(formData_606379, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_606378, "Action", newJString(Action))
  add(query_606378, "Version", newJString(Version))
  result = call_606377.call(nil, query_606378, nil, formData_606379, nil)

var postCancelResize* = Call_PostCancelResize_606363(name: "postCancelResize",
    meth: HttpMethod.HttpPost, host: "redshift.amazonaws.com",
    route: "/#Action=CancelResize", validator: validate_PostCancelResize_606364,
    base: "/", url: url_PostCancelResize_606365,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCancelResize_606347 = ref object of OpenApiRestCall_605573
proc url_GetCancelResize_606349(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetCancelResize_606348(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Cancels a resize operation for a cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : The unique identifier for the cluster that you want to cancel a resize operation for.
  ##   Version: JString (required)
  section = newJObject()
  var valid_606350 = query.getOrDefault("Action")
  valid_606350 = validateParameter(valid_606350, JString, required = true,
                                 default = newJString("CancelResize"))
  if valid_606350 != nil:
    section.add "Action", valid_606350
  var valid_606351 = query.getOrDefault("ClusterIdentifier")
  valid_606351 = validateParameter(valid_606351, JString, required = true,
                                 default = nil)
  if valid_606351 != nil:
    section.add "ClusterIdentifier", valid_606351
  var valid_606352 = query.getOrDefault("Version")
  valid_606352 = validateParameter(valid_606352, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_606352 != nil:
    section.add "Version", valid_606352
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_606353 = header.getOrDefault("X-Amz-Signature")
  valid_606353 = validateParameter(valid_606353, JString, required = false,
                                 default = nil)
  if valid_606353 != nil:
    section.add "X-Amz-Signature", valid_606353
  var valid_606354 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_606354 = validateParameter(valid_606354, JString, required = false,
                                 default = nil)
  if valid_606354 != nil:
    section.add "X-Amz-Content-Sha256", valid_606354
  var valid_606355 = header.getOrDefault("X-Amz-Date")
  valid_606355 = validateParameter(valid_606355, JString, required = false,
                                 default = nil)
  if valid_606355 != nil:
    section.add "X-Amz-Date", valid_606355
  var valid_606356 = header.getOrDefault("X-Amz-Credential")
  valid_606356 = validateParameter(valid_606356, JString, required = false,
                                 default = nil)
  if valid_606356 != nil:
    section.add "X-Amz-Credential", valid_606356
  var valid_606357 = header.getOrDefault("X-Amz-Security-Token")
  valid_606357 = validateParameter(valid_606357, JString, required = false,
                                 default = nil)
  if valid_606357 != nil:
    section.add "X-Amz-Security-Token", valid_606357
  var valid_606358 = header.getOrDefault("X-Amz-Algorithm")
  valid_606358 = validateParameter(valid_606358, JString, required = false,
                                 default = nil)
  if valid_606358 != nil:
    section.add "X-Amz-Algorithm", valid_606358
  var valid_606359 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_606359 = validateParameter(valid_606359, JString, required = false,
                                 default = nil)
  if valid_606359 != nil:
    section.add "X-Amz-SignedHeaders", valid_606359
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_606360: Call_GetCancelResize_606347; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Cancels a resize operation for a cluster.
  ## 
  let valid = call_606360.validator(path, query, header, formData, body)
  let scheme = call_606360.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_606360.url(scheme.get, call_606360.host, call_606360.base,
                         call_606360.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_606360, url, valid)

proc call*(call_606361: Call_GetCancelResize_606347; ClusterIdentifier: string;
          Action: string = "CancelResize"; Version: string = "2012-12-01"): Recallable =
  ## getCancelResize
  ## Cancels a resize operation for a cluster.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : The unique identifier for the cluster that you want to cancel a resize operation for.
  ##   Version: string (required)
  var query_606362 = newJObject()
  add(query_606362, "Action", newJString(Action))
  add(query_606362, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_606362, "Version", newJString(Version))
  result = call_606361.call(nil, query_606362, nil, nil, nil)

var getCancelResize* = Call_GetCancelResize_606347(name: "getCancelResize",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=CancelResize", validator: validate_GetCancelResize_606348,
    base: "/", url: url_GetCancelResize_606349, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCopyClusterSnapshot_606399 = ref object of OpenApiRestCall_605573
proc url_PostCopyClusterSnapshot_606401(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostCopyClusterSnapshot_606400(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Copies the specified automated cluster snapshot to a new manual cluster snapshot. The source must be an automated snapshot and it must be in the available state.</p> <p>When you delete a cluster, Amazon Redshift deletes any automated snapshots of the cluster. Also, when the retention period of the snapshot expires, Amazon Redshift automatically deletes it. If you want to keep an automated snapshot for a longer period, you can make a manual copy of the snapshot. Manual snapshots are retained until you delete them.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_606402 = query.getOrDefault("Action")
  valid_606402 = validateParameter(valid_606402, JString, required = true,
                                 default = newJString("CopyClusterSnapshot"))
  if valid_606402 != nil:
    section.add "Action", valid_606402
  var valid_606403 = query.getOrDefault("Version")
  valid_606403 = validateParameter(valid_606403, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_606403 != nil:
    section.add "Version", valid_606403
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_606404 = header.getOrDefault("X-Amz-Signature")
  valid_606404 = validateParameter(valid_606404, JString, required = false,
                                 default = nil)
  if valid_606404 != nil:
    section.add "X-Amz-Signature", valid_606404
  var valid_606405 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_606405 = validateParameter(valid_606405, JString, required = false,
                                 default = nil)
  if valid_606405 != nil:
    section.add "X-Amz-Content-Sha256", valid_606405
  var valid_606406 = header.getOrDefault("X-Amz-Date")
  valid_606406 = validateParameter(valid_606406, JString, required = false,
                                 default = nil)
  if valid_606406 != nil:
    section.add "X-Amz-Date", valid_606406
  var valid_606407 = header.getOrDefault("X-Amz-Credential")
  valid_606407 = validateParameter(valid_606407, JString, required = false,
                                 default = nil)
  if valid_606407 != nil:
    section.add "X-Amz-Credential", valid_606407
  var valid_606408 = header.getOrDefault("X-Amz-Security-Token")
  valid_606408 = validateParameter(valid_606408, JString, required = false,
                                 default = nil)
  if valid_606408 != nil:
    section.add "X-Amz-Security-Token", valid_606408
  var valid_606409 = header.getOrDefault("X-Amz-Algorithm")
  valid_606409 = validateParameter(valid_606409, JString, required = false,
                                 default = nil)
  if valid_606409 != nil:
    section.add "X-Amz-Algorithm", valid_606409
  var valid_606410 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_606410 = validateParameter(valid_606410, JString, required = false,
                                 default = nil)
  if valid_606410 != nil:
    section.add "X-Amz-SignedHeaders", valid_606410
  result.add "header", section
  ## parameters in `formData` object:
  ##   SourceSnapshotIdentifier: JString (required)
  ##                           : <p>The identifier for the source snapshot.</p> <p>Constraints:</p> <ul> <li> <p>Must be the identifier for a valid automated snapshot whose state is <code>available</code>.</p> </li> </ul>
  ##   SourceSnapshotClusterIdentifier: JString
  ##                                  : <p>The identifier of the cluster the source snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.</p> <p>Constraints:</p> <ul> <li> <p>Must be the identifier for a valid cluster.</p> </li> </ul>
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. </p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  ##   TargetSnapshotIdentifier: JString (required)
  ##                           : <p>The identifier given to the new manual snapshot.</p> <p>Constraints:</p> <ul> <li> <p>Cannot be null, empty, or blank.</p> </li> <li> <p>Must contain from 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for the AWS account that is making the request.</p> </li> </ul>
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `SourceSnapshotIdentifier` field"
  var valid_606411 = formData.getOrDefault("SourceSnapshotIdentifier")
  valid_606411 = validateParameter(valid_606411, JString, required = true,
                                 default = nil)
  if valid_606411 != nil:
    section.add "SourceSnapshotIdentifier", valid_606411
  var valid_606412 = formData.getOrDefault("SourceSnapshotClusterIdentifier")
  valid_606412 = validateParameter(valid_606412, JString, required = false,
                                 default = nil)
  if valid_606412 != nil:
    section.add "SourceSnapshotClusterIdentifier", valid_606412
  var valid_606413 = formData.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_606413 = validateParameter(valid_606413, JInt, required = false, default = nil)
  if valid_606413 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_606413
  var valid_606414 = formData.getOrDefault("TargetSnapshotIdentifier")
  valid_606414 = validateParameter(valid_606414, JString, required = true,
                                 default = nil)
  if valid_606414 != nil:
    section.add "TargetSnapshotIdentifier", valid_606414
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_606415: Call_PostCopyClusterSnapshot_606399; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Copies the specified automated cluster snapshot to a new manual cluster snapshot. The source must be an automated snapshot and it must be in the available state.</p> <p>When you delete a cluster, Amazon Redshift deletes any automated snapshots of the cluster. Also, when the retention period of the snapshot expires, Amazon Redshift automatically deletes it. If you want to keep an automated snapshot for a longer period, you can make a manual copy of the snapshot. Manual snapshots are retained until you delete them.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_606415.validator(path, query, header, formData, body)
  let scheme = call_606415.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_606415.url(scheme.get, call_606415.host, call_606415.base,
                         call_606415.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_606415, url, valid)

proc call*(call_606416: Call_PostCopyClusterSnapshot_606399;
          SourceSnapshotIdentifier: string; TargetSnapshotIdentifier: string;
          SourceSnapshotClusterIdentifier: string = "";
          Action: string = "CopyClusterSnapshot"; Version: string = "2012-12-01";
          ManualSnapshotRetentionPeriod: int = 0): Recallable =
  ## postCopyClusterSnapshot
  ## <p>Copies the specified automated cluster snapshot to a new manual cluster snapshot. The source must be an automated snapshot and it must be in the available state.</p> <p>When you delete a cluster, Amazon Redshift deletes any automated snapshots of the cluster. Also, when the retention period of the snapshot expires, Amazon Redshift automatically deletes it. If you want to keep an automated snapshot for a longer period, you can make a manual copy of the snapshot. Manual snapshots are retained until you delete them.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   SourceSnapshotIdentifier: string (required)
  ##                           : <p>The identifier for the source snapshot.</p> <p>Constraints:</p> <ul> <li> <p>Must be the identifier for a valid automated snapshot whose state is <code>available</code>.</p> </li> </ul>
  ##   SourceSnapshotClusterIdentifier: string
  ##                                  : <p>The identifier of the cluster the source snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.</p> <p>Constraints:</p> <ul> <li> <p>Must be the identifier for a valid cluster.</p> </li> </ul>
  ##   Action: string (required)
  ##   Version: string (required)
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. </p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  ##   TargetSnapshotIdentifier: string (required)
  ##                           : <p>The identifier given to the new manual snapshot.</p> <p>Constraints:</p> <ul> <li> <p>Cannot be null, empty, or blank.</p> </li> <li> <p>Must contain from 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for the AWS account that is making the request.</p> </li> </ul>
  var query_606417 = newJObject()
  var formData_606418 = newJObject()
  add(formData_606418, "SourceSnapshotIdentifier",
      newJString(SourceSnapshotIdentifier))
  add(formData_606418, "SourceSnapshotClusterIdentifier",
      newJString(SourceSnapshotClusterIdentifier))
  add(query_606417, "Action", newJString(Action))
  add(query_606417, "Version", newJString(Version))
  add(formData_606418, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  add(formData_606418, "TargetSnapshotIdentifier",
      newJString(TargetSnapshotIdentifier))
  result = call_606416.call(nil, query_606417, nil, formData_606418, nil)

var postCopyClusterSnapshot* = Call_PostCopyClusterSnapshot_606399(
    name: "postCopyClusterSnapshot", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=CopyClusterSnapshot",
    validator: validate_PostCopyClusterSnapshot_606400, base: "/",
    url: url_PostCopyClusterSnapshot_606401, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCopyClusterSnapshot_606380 = ref object of OpenApiRestCall_605573
proc url_GetCopyClusterSnapshot_606382(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetCopyClusterSnapshot_606381(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Copies the specified automated cluster snapshot to a new manual cluster snapshot. The source must be an automated snapshot and it must be in the available state.</p> <p>When you delete a cluster, Amazon Redshift deletes any automated snapshots of the cluster. Also, when the retention period of the snapshot expires, Amazon Redshift automatically deletes it. If you want to keep an automated snapshot for a longer period, you can make a manual copy of the snapshot. Manual snapshots are retained until you delete them.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. </p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  ##   SourceSnapshotIdentifier: JString (required)
  ##                           : <p>The identifier for the source snapshot.</p> <p>Constraints:</p> <ul> <li> <p>Must be the identifier for a valid automated snapshot whose state is <code>available</code>.</p> </li> </ul>
  ##   TargetSnapshotIdentifier: JString (required)
  ##                           : <p>The identifier given to the new manual snapshot.</p> <p>Constraints:</p> <ul> <li> <p>Cannot be null, empty, or blank.</p> </li> <li> <p>Must contain from 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for the AWS account that is making the request.</p> </li> </ul>
  ##   Action: JString (required)
  ##   Version: JString (required)
  ##   SourceSnapshotClusterIdentifier: JString
  ##                                  : <p>The identifier of the cluster the source snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.</p> <p>Constraints:</p> <ul> <li> <p>Must be the identifier for a valid cluster.</p> </li> </ul>
  section = newJObject()
  var valid_606383 = query.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_606383 = validateParameter(valid_606383, JInt, required = false, default = nil)
  if valid_606383 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_606383
  assert query != nil, "query argument is necessary due to required `SourceSnapshotIdentifier` field"
  var valid_606384 = query.getOrDefault("SourceSnapshotIdentifier")
  valid_606384 = validateParameter(valid_606384, JString, required = true,
                                 default = nil)
  if valid_606384 != nil:
    section.add "SourceSnapshotIdentifier", valid_606384
  var valid_606385 = query.getOrDefault("TargetSnapshotIdentifier")
  valid_606385 = validateParameter(valid_606385, JString, required = true,
                                 default = nil)
  if valid_606385 != nil:
    section.add "TargetSnapshotIdentifier", valid_606385
  var valid_606386 = query.getOrDefault("Action")
  valid_606386 = validateParameter(valid_606386, JString, required = true,
                                 default = newJString("CopyClusterSnapshot"))
  if valid_606386 != nil:
    section.add "Action", valid_606386
  var valid_606387 = query.getOrDefault("Version")
  valid_606387 = validateParameter(valid_606387, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_606387 != nil:
    section.add "Version", valid_606387
  var valid_606388 = query.getOrDefault("SourceSnapshotClusterIdentifier")
  valid_606388 = validateParameter(valid_606388, JString, required = false,
                                 default = nil)
  if valid_606388 != nil:
    section.add "SourceSnapshotClusterIdentifier", valid_606388
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_606389 = header.getOrDefault("X-Amz-Signature")
  valid_606389 = validateParameter(valid_606389, JString, required = false,
                                 default = nil)
  if valid_606389 != nil:
    section.add "X-Amz-Signature", valid_606389
  var valid_606390 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_606390 = validateParameter(valid_606390, JString, required = false,
                                 default = nil)
  if valid_606390 != nil:
    section.add "X-Amz-Content-Sha256", valid_606390
  var valid_606391 = header.getOrDefault("X-Amz-Date")
  valid_606391 = validateParameter(valid_606391, JString, required = false,
                                 default = nil)
  if valid_606391 != nil:
    section.add "X-Amz-Date", valid_606391
  var valid_606392 = header.getOrDefault("X-Amz-Credential")
  valid_606392 = validateParameter(valid_606392, JString, required = false,
                                 default = nil)
  if valid_606392 != nil:
    section.add "X-Amz-Credential", valid_606392
  var valid_606393 = header.getOrDefault("X-Amz-Security-Token")
  valid_606393 = validateParameter(valid_606393, JString, required = false,
                                 default = nil)
  if valid_606393 != nil:
    section.add "X-Amz-Security-Token", valid_606393
  var valid_606394 = header.getOrDefault("X-Amz-Algorithm")
  valid_606394 = validateParameter(valid_606394, JString, required = false,
                                 default = nil)
  if valid_606394 != nil:
    section.add "X-Amz-Algorithm", valid_606394
  var valid_606395 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_606395 = validateParameter(valid_606395, JString, required = false,
                                 default = nil)
  if valid_606395 != nil:
    section.add "X-Amz-SignedHeaders", valid_606395
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_606396: Call_GetCopyClusterSnapshot_606380; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Copies the specified automated cluster snapshot to a new manual cluster snapshot. The source must be an automated snapshot and it must be in the available state.</p> <p>When you delete a cluster, Amazon Redshift deletes any automated snapshots of the cluster. Also, when the retention period of the snapshot expires, Amazon Redshift automatically deletes it. If you want to keep an automated snapshot for a longer period, you can make a manual copy of the snapshot. Manual snapshots are retained until you delete them.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_606396.validator(path, query, header, formData, body)
  let scheme = call_606396.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_606396.url(scheme.get, call_606396.host, call_606396.base,
                         call_606396.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_606396, url, valid)

proc call*(call_606397: Call_GetCopyClusterSnapshot_606380;
          SourceSnapshotIdentifier: string; TargetSnapshotIdentifier: string;
          ManualSnapshotRetentionPeriod: int = 0;
          Action: string = "CopyClusterSnapshot"; Version: string = "2012-12-01";
          SourceSnapshotClusterIdentifier: string = ""): Recallable =
  ## getCopyClusterSnapshot
  ## <p>Copies the specified automated cluster snapshot to a new manual cluster snapshot. The source must be an automated snapshot and it must be in the available state.</p> <p>When you delete a cluster, Amazon Redshift deletes any automated snapshots of the cluster. Also, when the retention period of the snapshot expires, Amazon Redshift automatically deletes it. If you want to keep an automated snapshot for a longer period, you can make a manual copy of the snapshot. Manual snapshots are retained until you delete them.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. </p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  ##   SourceSnapshotIdentifier: string (required)
  ##                           : <p>The identifier for the source snapshot.</p> <p>Constraints:</p> <ul> <li> <p>Must be the identifier for a valid automated snapshot whose state is <code>available</code>.</p> </li> </ul>
  ##   TargetSnapshotIdentifier: string (required)
  ##                           : <p>The identifier given to the new manual snapshot.</p> <p>Constraints:</p> <ul> <li> <p>Cannot be null, empty, or blank.</p> </li> <li> <p>Must contain from 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for the AWS account that is making the request.</p> </li> </ul>
  ##   Action: string (required)
  ##   Version: string (required)
  ##   SourceSnapshotClusterIdentifier: string
  ##                                  : <p>The identifier of the cluster the source snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.</p> <p>Constraints:</p> <ul> <li> <p>Must be the identifier for a valid cluster.</p> </li> </ul>
  var query_606398 = newJObject()
  add(query_606398, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  add(query_606398, "SourceSnapshotIdentifier",
      newJString(SourceSnapshotIdentifier))
  add(query_606398, "TargetSnapshotIdentifier",
      newJString(TargetSnapshotIdentifier))
  add(query_606398, "Action", newJString(Action))
  add(query_606398, "Version", newJString(Version))
  add(query_606398, "SourceSnapshotClusterIdentifier",
      newJString(SourceSnapshotClusterIdentifier))
  result = call_606397.call(nil, query_606398, nil, nil, nil)

var getCopyClusterSnapshot* = Call_GetCopyClusterSnapshot_606380(
    name: "getCopyClusterSnapshot", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=CopyClusterSnapshot",
    validator: validate_GetCopyClusterSnapshot_606381, base: "/",
    url: url_GetCopyClusterSnapshot_606382, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCreateCluster_606464 = ref object of OpenApiRestCall_605573
proc url_PostCreateCluster_606466(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostCreateCluster_606465(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## <p>Creates a new cluster with the specified parameters.</p> <p>To create a cluster in Virtual Private Cloud (VPC), you must provide a cluster subnet group name. The cluster subnet group identifies the subnets of your VPC that Amazon Redshift uses when creating the cluster. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_606467 = query.getOrDefault("Action")
  valid_606467 = validateParameter(valid_606467, JString, required = true,
                                 default = newJString("CreateCluster"))
  if valid_606467 != nil:
    section.add "Action", valid_606467
  var valid_606468 = query.getOrDefault("Version")
  valid_606468 = validateParameter(valid_606468, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_606468 != nil:
    section.add "Version", valid_606468
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_606469 = header.getOrDefault("X-Amz-Signature")
  valid_606469 = validateParameter(valid_606469, JString, required = false,
                                 default = nil)
  if valid_606469 != nil:
    section.add "X-Amz-Signature", valid_606469
  var valid_606470 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_606470 = validateParameter(valid_606470, JString, required = false,
                                 default = nil)
  if valid_606470 != nil:
    section.add "X-Amz-Content-Sha256", valid_606470
  var valid_606471 = header.getOrDefault("X-Amz-Date")
  valid_606471 = validateParameter(valid_606471, JString, required = false,
                                 default = nil)
  if valid_606471 != nil:
    section.add "X-Amz-Date", valid_606471
  var valid_606472 = header.getOrDefault("X-Amz-Credential")
  valid_606472 = validateParameter(valid_606472, JString, required = false,
                                 default = nil)
  if valid_606472 != nil:
    section.add "X-Amz-Credential", valid_606472
  var valid_606473 = header.getOrDefault("X-Amz-Security-Token")
  valid_606473 = validateParameter(valid_606473, JString, required = false,
                                 default = nil)
  if valid_606473 != nil:
    section.add "X-Amz-Security-Token", valid_606473
  var valid_606474 = header.getOrDefault("X-Amz-Algorithm")
  valid_606474 = validateParameter(valid_606474, JString, required = false,
                                 default = nil)
  if valid_606474 != nil:
    section.add "X-Amz-Algorithm", valid_606474
  var valid_606475 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_606475 = validateParameter(valid_606475, JString, required = false,
                                 default = nil)
  if valid_606475 != nil:
    section.add "X-Amz-SignedHeaders", valid_606475
  result.add "header", section
  ## parameters in `formData` object:
  ##   PreferredMaintenanceWindow: JString
  ##                             : <p>The weekly time range (in UTC) during which automated cluster maintenance can occur.</p> <p> Format: <code>ddd:hh24:mi-ddd:hh24:mi</code> </p> <p> Default: A 30-minute window selected at random from an 8-hour block of time per region, occurring on a random day of the week. For more information about the time blocks for each region, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-maintenance-windows">Maintenance Windows</a> in Amazon Redshift Cluster Management Guide.</p> <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p> <p>Constraints: Minimum 30-minute window.</p>
  ##   Port: JInt
  ##       : <p>The port number on which the cluster accepts incoming connections.</p> <p>The cluster is accessible only via the JDBC and ODBC connection strings. Part of the connection string requires the port on which the cluster will listen for incoming connections.</p> <p>Default: <code>5439</code> </p> <p>Valid Values: <code>1150-65535</code> </p>
  ##   NodeType: JString (required)
  ##           : <p>The node type to be provisioned for the cluster. For information about node types, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#how-many-nodes"> Working with Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p> <p>Valid Values: <code>ds2.xlarge</code> | <code>ds2.8xlarge</code> | <code>dc1.large</code> | <code>dc1.8xlarge</code> | <code>dc2.large</code> | <code>dc2.8xlarge</code> | <code>ra3.16xlarge</code> </p>
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>A unique identifier for the cluster. You use this identifier to refer to the cluster for any subsequent cluster operations such as deleting or modifying. The identifier also appears in the Amazon Redshift console.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul> <p>Example: <code>myexamplecluster</code> </p>
  ##   MasterUserPassword: JString (required)
  ##                     : <p>The password associated with the master user account for the cluster that is being created.</p> <p>Constraints:</p> <ul> <li> <p>Must be between 8 and 64 characters in length.</p> </li> <li> <p>Must contain at least one uppercase letter.</p> </li> <li> <p>Must contain at least one lowercase letter.</p> </li> <li> <p>Must contain one number.</p> </li> <li> <p>Can be any printable ASCII character (ASCII code 33 to 126) except ' (single quote), " (double quote), \, /, @, or space.</p> </li> </ul>
  ##   MaintenanceTrackName: JString
  ##                       : An optional parameter for the name of the maintenance track for the cluster. If you don't provide a maintenance track name, the cluster is assigned to the <code>current</code> track.
  ##   MasterUsername: JString (required)
  ##                 : <p>The user name associated with the master user account for the cluster that is being created.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 - 128 alphanumeric characters. The user name can't be <code>PUBLIC</code>.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide. </p> </li> </ul>
  ##   ClusterSecurityGroups: JArray
  ##                        : <p>A list of security groups to be associated with this cluster.</p> <p>Default: The default cluster security group for Amazon Redshift.</p>
  ##   IamRoles: JArray
  ##           : <p>A list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services. You must supply the IAM roles in their Amazon Resource Name (ARN) format. You can supply up to 10 IAM roles in a single request.</p> <p>A cluster can have up to 10 IAM roles associated with it at any time.</p>
  ##   VpcSecurityGroupIds: JArray
  ##                      : <p>A list of Virtual Private Cloud (VPC) security groups to be associated with the cluster.</p> <p>Default: The default VPC security group is associated with the cluster.</p>
  ##   AutomatedSnapshotRetentionPeriod: JInt
  ##                                   : <p>The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p> <p>Default: <code>1</code> </p> <p>Constraints: Must be a value from 0 to 35.</p>
  ##   AvailabilityZone: JString
  ##                   : <p>The EC2 Availability Zone (AZ) in which you want Amazon Redshift to provision the cluster. For example, if you have several EC2 instances running in a specific Availability Zone, then you might want the cluster to be provisioned in the same zone in order to decrease network latency.</p> <p>Default: A random, system-chosen Availability Zone in the region that is specified by the endpoint.</p> <p>Example: <code>us-east-2d</code> </p> <p>Constraint: The specified Availability Zone must be in the same region as the current endpoint.</p>
  ##   NumberOfNodes: JInt
  ##                : <p>The number of compute nodes in the cluster. This parameter is required when the <b>ClusterType</b> parameter is specified as <code>multi-node</code>. </p> <p>For information about determining how many nodes you need, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#how-many-nodes"> Working with Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p> <p>If you don't specify this parameter, you get a single-node cluster. When requesting a multi-node cluster, you must specify the number of nodes that you want in the cluster.</p> <p>Default: <code>1</code> </p> <p>Constraints: Value must be at least 1 and no more than 100.</p>
  ##   KmsKeyId: JString
  ##           : The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster.
  ##   EnhancedVpcRouting: JBool
  ##                     : <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p> <p>Default: false</p>
  ##   ClusterSubnetGroupName: JString
  ##                         : <p>The name of a cluster subnet group to be associated with this cluster.</p> <p>If this parameter is not provided the resulting cluster will be deployed outside virtual private cloud (VPC).</p>
  ##   AllowVersionUpgrade: JBool
  ##                      : <p>If <code>true</code>, major version upgrades can be applied during the maintenance window to the Amazon Redshift engine that is running on the cluster.</p> <p>When a new major version of the Amazon Redshift engine is released, you can request that the service automatically apply upgrades during the maintenance window to the Amazon Redshift engine that is running on your cluster.</p> <p>Default: <code>true</code> </p>
  ##   DBName: JString
  ##         : <p>The name of the first database to be created when the cluster is created.</p> <p>To create additional databases after the cluster is created, connect to the cluster with a SQL client and use SQL commands to create a database. For more information, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/t_creating_database.html">Create a Database</a> in the Amazon Redshift Database Developer Guide. </p> <p>Default: <code>dev</code> </p> <p>Constraints:</p> <ul> <li> <p>Must contain 1 to 64 alphanumeric characters.</p> </li> <li> <p>Must contain only lowercase letters.</p> </li> <li> <p>Cannot be a word that is reserved by the service. A list of reserved words can be found in <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide. </p> </li> </ul>
  ##   PubliclyAccessible: JBool
  ##                     : If <code>true</code>, the cluster can be accessed from a public network. 
  ##   ClusterParameterGroupName: JString
  ##                            : <p>The name of the parameter group to be associated with this cluster.</p> <p>Default: The default Amazon Redshift cluster parameter group. For information about the default parameter group, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Working with Amazon Redshift Parameter Groups</a> </p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   ClusterVersion: JString
  ##                 : <p>The version of the Amazon Redshift engine software that you want to deploy on the cluster.</p> <p>The version selected runs on all the nodes in the cluster.</p> <p>Constraints: Only version 1.0 is currently available.</p> <p>Example: <code>1.0</code> </p>
  ##   ClusterType: JString
  ##              : <p>The type of the cluster. When cluster type is specified as</p> <ul> <li> <p> <code>single-node</code>, the <b>NumberOfNodes</b> parameter is not required.</p> </li> <li> <p> <code>multi-node</code>, the <b>NumberOfNodes</b> parameter is required.</p> </li> </ul> <p>Valid Values: <code>multi-node</code> | <code>single-node</code> </p> <p>Default: <code>multi-node</code> </p>
  ##   Encrypted: JBool
  ##            : <p>If <code>true</code>, the data in the cluster is encrypted at rest. </p> <p>Default: false</p>
  ##   HsmClientCertificateIdentifier: JString
  ##                                 : Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM.
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   AdditionalInfo: JString
  ##                 : Reserved.
  ##   SnapshotScheduleIdentifier: JString
  ##                             : A unique identifier for the snapshot schedule.
  ##   ElasticIp: JString
  ##            : <p>The Elastic IP (EIP) address for the cluster.</p> <p>Constraints: The cluster must be provisioned in EC2-VPC and publicly-accessible through an Internet gateway. For more information about provisioning clusters in EC2-VPC, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#cluster-platforms">Supported Platforms to Launch Your Cluster</a> in the Amazon Redshift Cluster Management Guide.</p>
  ##   HsmConfigurationIdentifier: JString
  ##                             : Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The default number of days to retain a manual snapshot. If the value is -1, the snapshot is retained indefinitely. This setting doesn't change the retention period of existing snapshots.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  section = newJObject()
  var valid_606476 = formData.getOrDefault("PreferredMaintenanceWindow")
  valid_606476 = validateParameter(valid_606476, JString, required = false,
                                 default = nil)
  if valid_606476 != nil:
    section.add "PreferredMaintenanceWindow", valid_606476
  var valid_606477 = formData.getOrDefault("Port")
  valid_606477 = validateParameter(valid_606477, JInt, required = false, default = nil)
  if valid_606477 != nil:
    section.add "Port", valid_606477
  assert formData != nil,
        "formData argument is necessary due to required `NodeType` field"
  var valid_606478 = formData.getOrDefault("NodeType")
  valid_606478 = validateParameter(valid_606478, JString, required = true,
                                 default = nil)
  if valid_606478 != nil:
    section.add "NodeType", valid_606478
  var valid_606479 = formData.getOrDefault("ClusterIdentifier")
  valid_606479 = validateParameter(valid_606479, JString, required = true,
                                 default = nil)
  if valid_606479 != nil:
    section.add "ClusterIdentifier", valid_606479
  var valid_606480 = formData.getOrDefault("MasterUserPassword")
  valid_606480 = validateParameter(valid_606480, JString, required = true,
                                 default = nil)
  if valid_606480 != nil:
    section.add "MasterUserPassword", valid_606480
  var valid_606481 = formData.getOrDefault("MaintenanceTrackName")
  valid_606481 = validateParameter(valid_606481, JString, required = false,
                                 default = nil)
  if valid_606481 != nil:
    section.add "MaintenanceTrackName", valid_606481
  var valid_606482 = formData.getOrDefault("MasterUsername")
  valid_606482 = validateParameter(valid_606482, JString, required = true,
                                 default = nil)
  if valid_606482 != nil:
    section.add "MasterUsername", valid_606482
  var valid_606483 = formData.getOrDefault("ClusterSecurityGroups")
  valid_606483 = validateParameter(valid_606483, JArray, required = false,
                                 default = nil)
  if valid_606483 != nil:
    section.add "ClusterSecurityGroups", valid_606483
  var valid_606484 = formData.getOrDefault("IamRoles")
  valid_606484 = validateParameter(valid_606484, JArray, required = false,
                                 default = nil)
  if valid_606484 != nil:
    section.add "IamRoles", valid_606484
  var valid_606485 = formData.getOrDefault("VpcSecurityGroupIds")
  valid_606485 = validateParameter(valid_606485, JArray, required = false,
                                 default = nil)
  if valid_606485 != nil:
    section.add "VpcSecurityGroupIds", valid_606485
  var valid_606486 = formData.getOrDefault("AutomatedSnapshotRetentionPeriod")
  valid_606486 = validateParameter(valid_606486, JInt, required = false, default = nil)
  if valid_606486 != nil:
    section.add "AutomatedSnapshotRetentionPeriod", valid_606486
  var valid_606487 = formData.getOrDefault("AvailabilityZone")
  valid_606487 = validateParameter(valid_606487, JString, required = false,
                                 default = nil)
  if valid_606487 != nil:
    section.add "AvailabilityZone", valid_606487
  var valid_606488 = formData.getOrDefault("NumberOfNodes")
  valid_606488 = validateParameter(valid_606488, JInt, required = false, default = nil)
  if valid_606488 != nil:
    section.add "NumberOfNodes", valid_606488
  var valid_606489 = formData.getOrDefault("KmsKeyId")
  valid_606489 = validateParameter(valid_606489, JString, required = false,
                                 default = nil)
  if valid_606489 != nil:
    section.add "KmsKeyId", valid_606489
  var valid_606490 = formData.getOrDefault("EnhancedVpcRouting")
  valid_606490 = validateParameter(valid_606490, JBool, required = false, default = nil)
  if valid_606490 != nil:
    section.add "EnhancedVpcRouting", valid_606490
  var valid_606491 = formData.getOrDefault("ClusterSubnetGroupName")
  valid_606491 = validateParameter(valid_606491, JString, required = false,
                                 default = nil)
  if valid_606491 != nil:
    section.add "ClusterSubnetGroupName", valid_606491
  var valid_606492 = formData.getOrDefault("AllowVersionUpgrade")
  valid_606492 = validateParameter(valid_606492, JBool, required = false, default = nil)
  if valid_606492 != nil:
    section.add "AllowVersionUpgrade", valid_606492
  var valid_606493 = formData.getOrDefault("DBName")
  valid_606493 = validateParameter(valid_606493, JString, required = false,
                                 default = nil)
  if valid_606493 != nil:
    section.add "DBName", valid_606493
  var valid_606494 = formData.getOrDefault("PubliclyAccessible")
  valid_606494 = validateParameter(valid_606494, JBool, required = false, default = nil)
  if valid_606494 != nil:
    section.add "PubliclyAccessible", valid_606494
  var valid_606495 = formData.getOrDefault("ClusterParameterGroupName")
  valid_606495 = validateParameter(valid_606495, JString, required = false,
                                 default = nil)
  if valid_606495 != nil:
    section.add "ClusterParameterGroupName", valid_606495
  var valid_606496 = formData.getOrDefault("ClusterVersion")
  valid_606496 = validateParameter(valid_606496, JString, required = false,
                                 default = nil)
  if valid_606496 != nil:
    section.add "ClusterVersion", valid_606496
  var valid_606497 = formData.getOrDefault("ClusterType")
  valid_606497 = validateParameter(valid_606497, JString, required = false,
                                 default = nil)
  if valid_606497 != nil:
    section.add "ClusterType", valid_606497
  var valid_606498 = formData.getOrDefault("Encrypted")
  valid_606498 = validateParameter(valid_606498, JBool, required = false, default = nil)
  if valid_606498 != nil:
    section.add "Encrypted", valid_606498
  var valid_606499 = formData.getOrDefault("HsmClientCertificateIdentifier")
  valid_606499 = validateParameter(valid_606499, JString, required = false,
                                 default = nil)
  if valid_606499 != nil:
    section.add "HsmClientCertificateIdentifier", valid_606499
  var valid_606500 = formData.getOrDefault("Tags")
  valid_606500 = validateParameter(valid_606500, JArray, required = false,
                                 default = nil)
  if valid_606500 != nil:
    section.add "Tags", valid_606500
  var valid_606501 = formData.getOrDefault("AdditionalInfo")
  valid_606501 = validateParameter(valid_606501, JString, required = false,
                                 default = nil)
  if valid_606501 != nil:
    section.add "AdditionalInfo", valid_606501
  var valid_606502 = formData.getOrDefault("SnapshotScheduleIdentifier")
  valid_606502 = validateParameter(valid_606502, JString, required = false,
                                 default = nil)
  if valid_606502 != nil:
    section.add "SnapshotScheduleIdentifier", valid_606502
  var valid_606503 = formData.getOrDefault("ElasticIp")
  valid_606503 = validateParameter(valid_606503, JString, required = false,
                                 default = nil)
  if valid_606503 != nil:
    section.add "ElasticIp", valid_606503
  var valid_606504 = formData.getOrDefault("HsmConfigurationIdentifier")
  valid_606504 = validateParameter(valid_606504, JString, required = false,
                                 default = nil)
  if valid_606504 != nil:
    section.add "HsmConfigurationIdentifier", valid_606504
  var valid_606505 = formData.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_606505 = validateParameter(valid_606505, JInt, required = false, default = nil)
  if valid_606505 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_606505
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_606506: Call_PostCreateCluster_606464; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a new cluster with the specified parameters.</p> <p>To create a cluster in Virtual Private Cloud (VPC), you must provide a cluster subnet group name. The cluster subnet group identifies the subnets of your VPC that Amazon Redshift uses when creating the cluster. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_606506.validator(path, query, header, formData, body)
  let scheme = call_606506.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_606506.url(scheme.get, call_606506.host, call_606506.base,
                         call_606506.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_606506, url, valid)

proc call*(call_606507: Call_PostCreateCluster_606464; NodeType: string;
          ClusterIdentifier: string; MasterUserPassword: string;
          MasterUsername: string; PreferredMaintenanceWindow: string = "";
          Port: int = 0; MaintenanceTrackName: string = "";
          ClusterSecurityGroups: JsonNode = nil; IamRoles: JsonNode = nil;
          VpcSecurityGroupIds: JsonNode = nil;
          AutomatedSnapshotRetentionPeriod: int = 0; AvailabilityZone: string = "";
          NumberOfNodes: int = 0; KmsKeyId: string = "";
          EnhancedVpcRouting: bool = false; ClusterSubnetGroupName: string = "";
          AllowVersionUpgrade: bool = false; DBName: string = "";
          PubliclyAccessible: bool = false; Action: string = "CreateCluster";
          ClusterParameterGroupName: string = ""; ClusterVersion: string = "";
          ClusterType: string = ""; Encrypted: bool = false;
          HsmClientCertificateIdentifier: string = ""; Tags: JsonNode = nil;
          AdditionalInfo: string = ""; SnapshotScheduleIdentifier: string = "";
          Version: string = "2012-12-01"; ElasticIp: string = "";
          HsmConfigurationIdentifier: string = "";
          ManualSnapshotRetentionPeriod: int = 0): Recallable =
  ## postCreateCluster
  ## <p>Creates a new cluster with the specified parameters.</p> <p>To create a cluster in Virtual Private Cloud (VPC), you must provide a cluster subnet group name. The cluster subnet group identifies the subnets of your VPC that Amazon Redshift uses when creating the cluster. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   PreferredMaintenanceWindow: string
  ##                             : <p>The weekly time range (in UTC) during which automated cluster maintenance can occur.</p> <p> Format: <code>ddd:hh24:mi-ddd:hh24:mi</code> </p> <p> Default: A 30-minute window selected at random from an 8-hour block of time per region, occurring on a random day of the week. For more information about the time blocks for each region, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-maintenance-windows">Maintenance Windows</a> in Amazon Redshift Cluster Management Guide.</p> <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p> <p>Constraints: Minimum 30-minute window.</p>
  ##   Port: int
  ##       : <p>The port number on which the cluster accepts incoming connections.</p> <p>The cluster is accessible only via the JDBC and ODBC connection strings. Part of the connection string requires the port on which the cluster will listen for incoming connections.</p> <p>Default: <code>5439</code> </p> <p>Valid Values: <code>1150-65535</code> </p>
  ##   NodeType: string (required)
  ##           : <p>The node type to be provisioned for the cluster. For information about node types, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#how-many-nodes"> Working with Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p> <p>Valid Values: <code>ds2.xlarge</code> | <code>ds2.8xlarge</code> | <code>dc1.large</code> | <code>dc1.8xlarge</code> | <code>dc2.large</code> | <code>dc2.8xlarge</code> | <code>ra3.16xlarge</code> </p>
  ##   ClusterIdentifier: string (required)
  ##                    : <p>A unique identifier for the cluster. You use this identifier to refer to the cluster for any subsequent cluster operations such as deleting or modifying. The identifier also appears in the Amazon Redshift console.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul> <p>Example: <code>myexamplecluster</code> </p>
  ##   MasterUserPassword: string (required)
  ##                     : <p>The password associated with the master user account for the cluster that is being created.</p> <p>Constraints:</p> <ul> <li> <p>Must be between 8 and 64 characters in length.</p> </li> <li> <p>Must contain at least one uppercase letter.</p> </li> <li> <p>Must contain at least one lowercase letter.</p> </li> <li> <p>Must contain one number.</p> </li> <li> <p>Can be any printable ASCII character (ASCII code 33 to 126) except ' (single quote), " (double quote), \, /, @, or space.</p> </li> </ul>
  ##   MaintenanceTrackName: string
  ##                       : An optional parameter for the name of the maintenance track for the cluster. If you don't provide a maintenance track name, the cluster is assigned to the <code>current</code> track.
  ##   MasterUsername: string (required)
  ##                 : <p>The user name associated with the master user account for the cluster that is being created.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 - 128 alphanumeric characters. The user name can't be <code>PUBLIC</code>.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide. </p> </li> </ul>
  ##   ClusterSecurityGroups: JArray
  ##                        : <p>A list of security groups to be associated with this cluster.</p> <p>Default: The default cluster security group for Amazon Redshift.</p>
  ##   IamRoles: JArray
  ##           : <p>A list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services. You must supply the IAM roles in their Amazon Resource Name (ARN) format. You can supply up to 10 IAM roles in a single request.</p> <p>A cluster can have up to 10 IAM roles associated with it at any time.</p>
  ##   VpcSecurityGroupIds: JArray
  ##                      : <p>A list of Virtual Private Cloud (VPC) security groups to be associated with the cluster.</p> <p>Default: The default VPC security group is associated with the cluster.</p>
  ##   AutomatedSnapshotRetentionPeriod: int
  ##                                   : <p>The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p> <p>Default: <code>1</code> </p> <p>Constraints: Must be a value from 0 to 35.</p>
  ##   AvailabilityZone: string
  ##                   : <p>The EC2 Availability Zone (AZ) in which you want Amazon Redshift to provision the cluster. For example, if you have several EC2 instances running in a specific Availability Zone, then you might want the cluster to be provisioned in the same zone in order to decrease network latency.</p> <p>Default: A random, system-chosen Availability Zone in the region that is specified by the endpoint.</p> <p>Example: <code>us-east-2d</code> </p> <p>Constraint: The specified Availability Zone must be in the same region as the current endpoint.</p>
  ##   NumberOfNodes: int
  ##                : <p>The number of compute nodes in the cluster. This parameter is required when the <b>ClusterType</b> parameter is specified as <code>multi-node</code>. </p> <p>For information about determining how many nodes you need, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#how-many-nodes"> Working with Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p> <p>If you don't specify this parameter, you get a single-node cluster. When requesting a multi-node cluster, you must specify the number of nodes that you want in the cluster.</p> <p>Default: <code>1</code> </p> <p>Constraints: Value must be at least 1 and no more than 100.</p>
  ##   KmsKeyId: string
  ##           : The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster.
  ##   EnhancedVpcRouting: bool
  ##                     : <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p> <p>Default: false</p>
  ##   ClusterSubnetGroupName: string
  ##                         : <p>The name of a cluster subnet group to be associated with this cluster.</p> <p>If this parameter is not provided the resulting cluster will be deployed outside virtual private cloud (VPC).</p>
  ##   AllowVersionUpgrade: bool
  ##                      : <p>If <code>true</code>, major version upgrades can be applied during the maintenance window to the Amazon Redshift engine that is running on the cluster.</p> <p>When a new major version of the Amazon Redshift engine is released, you can request that the service automatically apply upgrades during the maintenance window to the Amazon Redshift engine that is running on your cluster.</p> <p>Default: <code>true</code> </p>
  ##   DBName: string
  ##         : <p>The name of the first database to be created when the cluster is created.</p> <p>To create additional databases after the cluster is created, connect to the cluster with a SQL client and use SQL commands to create a database. For more information, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/t_creating_database.html">Create a Database</a> in the Amazon Redshift Database Developer Guide. </p> <p>Default: <code>dev</code> </p> <p>Constraints:</p> <ul> <li> <p>Must contain 1 to 64 alphanumeric characters.</p> </li> <li> <p>Must contain only lowercase letters.</p> </li> <li> <p>Cannot be a word that is reserved by the service. A list of reserved words can be found in <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide. </p> </li> </ul>
  ##   PubliclyAccessible: bool
  ##                     : If <code>true</code>, the cluster can be accessed from a public network. 
  ##   Action: string (required)
  ##   ClusterParameterGroupName: string
  ##                            : <p>The name of the parameter group to be associated with this cluster.</p> <p>Default: The default Amazon Redshift cluster parameter group. For information about the default parameter group, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Working with Amazon Redshift Parameter Groups</a> </p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   ClusterVersion: string
  ##                 : <p>The version of the Amazon Redshift engine software that you want to deploy on the cluster.</p> <p>The version selected runs on all the nodes in the cluster.</p> <p>Constraints: Only version 1.0 is currently available.</p> <p>Example: <code>1.0</code> </p>
  ##   ClusterType: string
  ##              : <p>The type of the cluster. When cluster type is specified as</p> <ul> <li> <p> <code>single-node</code>, the <b>NumberOfNodes</b> parameter is not required.</p> </li> <li> <p> <code>multi-node</code>, the <b>NumberOfNodes</b> parameter is required.</p> </li> </ul> <p>Valid Values: <code>multi-node</code> | <code>single-node</code> </p> <p>Default: <code>multi-node</code> </p>
  ##   Encrypted: bool
  ##            : <p>If <code>true</code>, the data in the cluster is encrypted at rest. </p> <p>Default: false</p>
  ##   HsmClientCertificateIdentifier: string
  ##                                 : Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM.
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   AdditionalInfo: string
  ##                 : Reserved.
  ##   SnapshotScheduleIdentifier: string
  ##                             : A unique identifier for the snapshot schedule.
  ##   Version: string (required)
  ##   ElasticIp: string
  ##            : <p>The Elastic IP (EIP) address for the cluster.</p> <p>Constraints: The cluster must be provisioned in EC2-VPC and publicly-accessible through an Internet gateway. For more information about provisioning clusters in EC2-VPC, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#cluster-platforms">Supported Platforms to Launch Your Cluster</a> in the Amazon Redshift Cluster Management Guide.</p>
  ##   HsmConfigurationIdentifier: string
  ##                             : Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The default number of days to retain a manual snapshot. If the value is -1, the snapshot is retained indefinitely. This setting doesn't change the retention period of existing snapshots.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  var query_606508 = newJObject()
  var formData_606509 = newJObject()
  add(formData_606509, "PreferredMaintenanceWindow",
      newJString(PreferredMaintenanceWindow))
  add(formData_606509, "Port", newJInt(Port))
  add(formData_606509, "NodeType", newJString(NodeType))
  add(formData_606509, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_606509, "MasterUserPassword", newJString(MasterUserPassword))
  add(formData_606509, "MaintenanceTrackName", newJString(MaintenanceTrackName))
  add(formData_606509, "MasterUsername", newJString(MasterUsername))
  if ClusterSecurityGroups != nil:
    formData_606509.add "ClusterSecurityGroups", ClusterSecurityGroups
  if IamRoles != nil:
    formData_606509.add "IamRoles", IamRoles
  if VpcSecurityGroupIds != nil:
    formData_606509.add "VpcSecurityGroupIds", VpcSecurityGroupIds
  add(formData_606509, "AutomatedSnapshotRetentionPeriod",
      newJInt(AutomatedSnapshotRetentionPeriod))
  add(formData_606509, "AvailabilityZone", newJString(AvailabilityZone))
  add(formData_606509, "NumberOfNodes", newJInt(NumberOfNodes))
  add(formData_606509, "KmsKeyId", newJString(KmsKeyId))
  add(formData_606509, "EnhancedVpcRouting", newJBool(EnhancedVpcRouting))
  add(formData_606509, "ClusterSubnetGroupName",
      newJString(ClusterSubnetGroupName))
  add(formData_606509, "AllowVersionUpgrade", newJBool(AllowVersionUpgrade))
  add(formData_606509, "DBName", newJString(DBName))
  add(formData_606509, "PubliclyAccessible", newJBool(PubliclyAccessible))
  add(query_606508, "Action", newJString(Action))
  add(formData_606509, "ClusterParameterGroupName",
      newJString(ClusterParameterGroupName))
  add(formData_606509, "ClusterVersion", newJString(ClusterVersion))
  add(formData_606509, "ClusterType", newJString(ClusterType))
  add(formData_606509, "Encrypted", newJBool(Encrypted))
  add(formData_606509, "HsmClientCertificateIdentifier",
      newJString(HsmClientCertificateIdentifier))
  if Tags != nil:
    formData_606509.add "Tags", Tags
  add(formData_606509, "AdditionalInfo", newJString(AdditionalInfo))
  add(formData_606509, "SnapshotScheduleIdentifier",
      newJString(SnapshotScheduleIdentifier))
  add(query_606508, "Version", newJString(Version))
  add(formData_606509, "ElasticIp", newJString(ElasticIp))
  add(formData_606509, "HsmConfigurationIdentifier",
      newJString(HsmConfigurationIdentifier))
  add(formData_606509, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  result = call_606507.call(nil, query_606508, nil, formData_606509, nil)

var postCreateCluster* = Call_PostCreateCluster_606464(name: "postCreateCluster",
    meth: HttpMethod.HttpPost, host: "redshift.amazonaws.com",
    route: "/#Action=CreateCluster", validator: validate_PostCreateCluster_606465,
    base: "/", url: url_PostCreateCluster_606466,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCreateCluster_606419 = ref object of OpenApiRestCall_605573
proc url_GetCreateCluster_606421(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetCreateCluster_606420(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## <p>Creates a new cluster with the specified parameters.</p> <p>To create a cluster in Virtual Private Cloud (VPC), you must provide a cluster subnet group name. The cluster subnet group identifies the subnets of your VPC that Amazon Redshift uses when creating the cluster. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ClusterSubnetGroupName: JString
  ##                         : <p>The name of a cluster subnet group to be associated with this cluster.</p> <p>If this parameter is not provided the resulting cluster will be deployed outside virtual private cloud (VPC).</p>
  ##   MaintenanceTrackName: JString
  ##                       : An optional parameter for the name of the maintenance track for the cluster. If you don't provide a maintenance track name, the cluster is assigned to the <code>current</code> track.
  ##   DBName: JString
  ##         : <p>The name of the first database to be created when the cluster is created.</p> <p>To create additional databases after the cluster is created, connect to the cluster with a SQL client and use SQL commands to create a database. For more information, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/t_creating_database.html">Create a Database</a> in the Amazon Redshift Database Developer Guide. </p> <p>Default: <code>dev</code> </p> <p>Constraints:</p> <ul> <li> <p>Must contain 1 to 64 alphanumeric characters.</p> </li> <li> <p>Must contain only lowercase letters.</p> </li> <li> <p>Cannot be a word that is reserved by the service. A list of reserved words can be found in <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide. </p> </li> </ul>
  ##   Encrypted: JBool
  ##            : <p>If <code>true</code>, the data in the cluster is encrypted at rest. </p> <p>Default: false</p>
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The default number of days to retain a manual snapshot. If the value is -1, the snapshot is retained indefinitely. This setting doesn't change the retention period of existing snapshots.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  ##   HsmClientCertificateIdentifier: JString
  ##                                 : Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM.
  ##   ClusterSecurityGroups: JArray
  ##                        : <p>A list of security groups to be associated with this cluster.</p> <p>Default: The default cluster security group for Amazon Redshift.</p>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   KmsKeyId: JString
  ##           : The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster.
  ##   ClusterParameterGroupName: JString
  ##                            : <p>The name of the parameter group to be associated with this cluster.</p> <p>Default: The default Amazon Redshift cluster parameter group. For information about the default parameter group, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Working with Amazon Redshift Parameter Groups</a> </p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   NodeType: JString (required)
  ##           : <p>The node type to be provisioned for the cluster. For information about node types, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#how-many-nodes"> Working with Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p> <p>Valid Values: <code>ds2.xlarge</code> | <code>ds2.8xlarge</code> | <code>dc1.large</code> | <code>dc1.8xlarge</code> | <code>dc2.large</code> | <code>dc2.8xlarge</code> | <code>ra3.16xlarge</code> </p>
  ##   ClusterVersion: JString
  ##                 : <p>The version of the Amazon Redshift engine software that you want to deploy on the cluster.</p> <p>The version selected runs on all the nodes in the cluster.</p> <p>Constraints: Only version 1.0 is currently available.</p> <p>Example: <code>1.0</code> </p>
  ##   IamRoles: JArray
  ##           : <p>A list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services. You must supply the IAM roles in their Amazon Resource Name (ARN) format. You can supply up to 10 IAM roles in a single request.</p> <p>A cluster can have up to 10 IAM roles associated with it at any time.</p>
  ##   SnapshotScheduleIdentifier: JString
  ##                             : A unique identifier for the snapshot schedule.
  ##   ClusterType: JString
  ##              : <p>The type of the cluster. When cluster type is specified as</p> <ul> <li> <p> <code>single-node</code>, the <b>NumberOfNodes</b> parameter is not required.</p> </li> <li> <p> <code>multi-node</code>, the <b>NumberOfNodes</b> parameter is required.</p> </li> </ul> <p>Valid Values: <code>multi-node</code> | <code>single-node</code> </p> <p>Default: <code>multi-node</code> </p>
  ##   NumberOfNodes: JInt
  ##                : <p>The number of compute nodes in the cluster. This parameter is required when the <b>ClusterType</b> parameter is specified as <code>multi-node</code>. </p> <p>For information about determining how many nodes you need, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#how-many-nodes"> Working with Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p> <p>If you don't specify this parameter, you get a single-node cluster. When requesting a multi-node cluster, you must specify the number of nodes that you want in the cluster.</p> <p>Default: <code>1</code> </p> <p>Constraints: Value must be at least 1 and no more than 100.</p>
  ##   MasterUsername: JString (required)
  ##                 : <p>The user name associated with the master user account for the cluster that is being created.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 - 128 alphanumeric characters. The user name can't be <code>PUBLIC</code>.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide. </p> </li> </ul>
  ##   AdditionalInfo: JString
  ##                 : Reserved.
  ##   AllowVersionUpgrade: JBool
  ##                      : <p>If <code>true</code>, major version upgrades can be applied during the maintenance window to the Amazon Redshift engine that is running on the cluster.</p> <p>When a new major version of the Amazon Redshift engine is released, you can request that the service automatically apply upgrades during the maintenance window to the Amazon Redshift engine that is running on your cluster.</p> <p>Default: <code>true</code> </p>
  ##   ElasticIp: JString
  ##            : <p>The Elastic IP (EIP) address for the cluster.</p> <p>Constraints: The cluster must be provisioned in EC2-VPC and publicly-accessible through an Internet gateway. For more information about provisioning clusters in EC2-VPC, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#cluster-platforms">Supported Platforms to Launch Your Cluster</a> in the Amazon Redshift Cluster Management Guide.</p>
  ##   AutomatedSnapshotRetentionPeriod: JInt
  ##                                   : <p>The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p> <p>Default: <code>1</code> </p> <p>Constraints: Must be a value from 0 to 35.</p>
  ##   EnhancedVpcRouting: JBool
  ##                     : <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p> <p>Default: false</p>
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>A unique identifier for the cluster. You use this identifier to refer to the cluster for any subsequent cluster operations such as deleting or modifying. The identifier also appears in the Amazon Redshift console.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul> <p>Example: <code>myexamplecluster</code> </p>
  ##   Port: JInt
  ##       : <p>The port number on which the cluster accepts incoming connections.</p> <p>The cluster is accessible only via the JDBC and ODBC connection strings. Part of the connection string requires the port on which the cluster will listen for incoming connections.</p> <p>Default: <code>5439</code> </p> <p>Valid Values: <code>1150-65535</code> </p>
  ##   VpcSecurityGroupIds: JArray
  ##                      : <p>A list of Virtual Private Cloud (VPC) security groups to be associated with the cluster.</p> <p>Default: The default VPC security group is associated with the cluster.</p>
  ##   MasterUserPassword: JString (required)
  ##                     : <p>The password associated with the master user account for the cluster that is being created.</p> <p>Constraints:</p> <ul> <li> <p>Must be between 8 and 64 characters in length.</p> </li> <li> <p>Must contain at least one uppercase letter.</p> </li> <li> <p>Must contain at least one lowercase letter.</p> </li> <li> <p>Must contain one number.</p> </li> <li> <p>Can be any printable ASCII character (ASCII code 33 to 126) except ' (single quote), " (double quote), \, /, @, or space.</p> </li> </ul>
  ##   AvailabilityZone: JString
  ##                   : <p>The EC2 Availability Zone (AZ) in which you want Amazon Redshift to provision the cluster. For example, if you have several EC2 instances running in a specific Availability Zone, then you might want the cluster to be provisioned in the same zone in order to decrease network latency.</p> <p>Default: A random, system-chosen Availability Zone in the region that is specified by the endpoint.</p> <p>Example: <code>us-east-2d</code> </p> <p>Constraint: The specified Availability Zone must be in the same region as the current endpoint.</p>
  ##   HsmConfigurationIdentifier: JString
  ##                             : Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
  ##   Version: JString (required)
  ##   PreferredMaintenanceWindow: JString
  ##                             : <p>The weekly time range (in UTC) during which automated cluster maintenance can occur.</p> <p> Format: <code>ddd:hh24:mi-ddd:hh24:mi</code> </p> <p> Default: A 30-minute window selected at random from an 8-hour block of time per region, occurring on a random day of the week. For more information about the time blocks for each region, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-maintenance-windows">Maintenance Windows</a> in Amazon Redshift Cluster Management Guide.</p> <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p> <p>Constraints: Minimum 30-minute window.</p>
  ##   PubliclyAccessible: JBool
  ##                     : If <code>true</code>, the cluster can be accessed from a public network. 
  section = newJObject()
  var valid_606422 = query.getOrDefault("ClusterSubnetGroupName")
  valid_606422 = validateParameter(valid_606422, JString, required = false,
                                 default = nil)
  if valid_606422 != nil:
    section.add "ClusterSubnetGroupName", valid_606422
  var valid_606423 = query.getOrDefault("MaintenanceTrackName")
  valid_606423 = validateParameter(valid_606423, JString, required = false,
                                 default = nil)
  if valid_606423 != nil:
    section.add "MaintenanceTrackName", valid_606423
  var valid_606424 = query.getOrDefault("DBName")
  valid_606424 = validateParameter(valid_606424, JString, required = false,
                                 default = nil)
  if valid_606424 != nil:
    section.add "DBName", valid_606424
  var valid_606425 = query.getOrDefault("Encrypted")
  valid_606425 = validateParameter(valid_606425, JBool, required = false, default = nil)
  if valid_606425 != nil:
    section.add "Encrypted", valid_606425
  var valid_606426 = query.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_606426 = validateParameter(valid_606426, JInt, required = false, default = nil)
  if valid_606426 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_606426
  var valid_606427 = query.getOrDefault("HsmClientCertificateIdentifier")
  valid_606427 = validateParameter(valid_606427, JString, required = false,
                                 default = nil)
  if valid_606427 != nil:
    section.add "HsmClientCertificateIdentifier", valid_606427
  var valid_606428 = query.getOrDefault("ClusterSecurityGroups")
  valid_606428 = validateParameter(valid_606428, JArray, required = false,
                                 default = nil)
  if valid_606428 != nil:
    section.add "ClusterSecurityGroups", valid_606428
  var valid_606429 = query.getOrDefault("Tags")
  valid_606429 = validateParameter(valid_606429, JArray, required = false,
                                 default = nil)
  if valid_606429 != nil:
    section.add "Tags", valid_606429
  var valid_606430 = query.getOrDefault("KmsKeyId")
  valid_606430 = validateParameter(valid_606430, JString, required = false,
                                 default = nil)
  if valid_606430 != nil:
    section.add "KmsKeyId", valid_606430
  var valid_606431 = query.getOrDefault("ClusterParameterGroupName")
  valid_606431 = validateParameter(valid_606431, JString, required = false,
                                 default = nil)
  if valid_606431 != nil:
    section.add "ClusterParameterGroupName", valid_606431
  assert query != nil,
        "query argument is necessary due to required `NodeType` field"
  var valid_606432 = query.getOrDefault("NodeType")
  valid_606432 = validateParameter(valid_606432, JString, required = true,
                                 default = nil)
  if valid_606432 != nil:
    section.add "NodeType", valid_606432
  var valid_606433 = query.getOrDefault("ClusterVersion")
  valid_606433 = validateParameter(valid_606433, JString, required = false,
                                 default = nil)
  if valid_606433 != nil:
    section.add "ClusterVersion", valid_606433
  var valid_606434 = query.getOrDefault("IamRoles")
  valid_606434 = validateParameter(valid_606434, JArray, required = false,
                                 default = nil)
  if valid_606434 != nil:
    section.add "IamRoles", valid_606434
  var valid_606435 = query.getOrDefault("SnapshotScheduleIdentifier")
  valid_606435 = validateParameter(valid_606435, JString, required = false,
                                 default = nil)
  if valid_606435 != nil:
    section.add "SnapshotScheduleIdentifier", valid_606435
  var valid_606436 = query.getOrDefault("ClusterType")
  valid_606436 = validateParameter(valid_606436, JString, required = false,
                                 default = nil)
  if valid_606436 != nil:
    section.add "ClusterType", valid_606436
  var valid_606437 = query.getOrDefault("NumberOfNodes")
  valid_606437 = validateParameter(valid_606437, JInt, required = false, default = nil)
  if valid_606437 != nil:
    section.add "NumberOfNodes", valid_606437
  var valid_606438 = query.getOrDefault("MasterUsername")
  valid_606438 = validateParameter(valid_606438, JString, required = true,
                                 default = nil)
  if valid_606438 != nil:
    section.add "MasterUsername", valid_606438
  var valid_606439 = query.getOrDefault("AdditionalInfo")
  valid_606439 = validateParameter(valid_606439, JString, required = false,
                                 default = nil)
  if valid_606439 != nil:
    section.add "AdditionalInfo", valid_606439
  var valid_606440 = query.getOrDefault("AllowVersionUpgrade")
  valid_606440 = validateParameter(valid_606440, JBool, required = false, default = nil)
  if valid_606440 != nil:
    section.add "AllowVersionUpgrade", valid_606440
  var valid_606441 = query.getOrDefault("ElasticIp")
  valid_606441 = validateParameter(valid_606441, JString, required = false,
                                 default = nil)
  if valid_606441 != nil:
    section.add "ElasticIp", valid_606441
  var valid_606442 = query.getOrDefault("AutomatedSnapshotRetentionPeriod")
  valid_606442 = validateParameter(valid_606442, JInt, required = false, default = nil)
  if valid_606442 != nil:
    section.add "AutomatedSnapshotRetentionPeriod", valid_606442
  var valid_606443 = query.getOrDefault("EnhancedVpcRouting")
  valid_606443 = validateParameter(valid_606443, JBool, required = false, default = nil)
  if valid_606443 != nil:
    section.add "EnhancedVpcRouting", valid_606443
  var valid_606444 = query.getOrDefault("Action")
  valid_606444 = validateParameter(valid_606444, JString, required = true,
                                 default = newJString("CreateCluster"))
  if valid_606444 != nil:
    section.add "Action", valid_606444
  var valid_606445 = query.getOrDefault("ClusterIdentifier")
  valid_606445 = validateParameter(valid_606445, JString, required = true,
                                 default = nil)
  if valid_606445 != nil:
    section.add "ClusterIdentifier", valid_606445
  var valid_606446 = query.getOrDefault("Port")
  valid_606446 = validateParameter(valid_606446, JInt, required = false, default = nil)
  if valid_606446 != nil:
    section.add "Port", valid_606446
  var valid_606447 = query.getOrDefault("VpcSecurityGroupIds")
  valid_606447 = validateParameter(valid_606447, JArray, required = false,
                                 default = nil)
  if valid_606447 != nil:
    section.add "VpcSecurityGroupIds", valid_606447
  var valid_606448 = query.getOrDefault("MasterUserPassword")
  valid_606448 = validateParameter(valid_606448, JString, required = true,
                                 default = nil)
  if valid_606448 != nil:
    section.add "MasterUserPassword", valid_606448
  var valid_606449 = query.getOrDefault("AvailabilityZone")
  valid_606449 = validateParameter(valid_606449, JString, required = false,
                                 default = nil)
  if valid_606449 != nil:
    section.add "AvailabilityZone", valid_606449
  var valid_606450 = query.getOrDefault("HsmConfigurationIdentifier")
  valid_606450 = validateParameter(valid_606450, JString, required = false,
                                 default = nil)
  if valid_606450 != nil:
    section.add "HsmConfigurationIdentifier", valid_606450
  var valid_606451 = query.getOrDefault("Version")
  valid_606451 = validateParameter(valid_606451, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_606451 != nil:
    section.add "Version", valid_606451
  var valid_606452 = query.getOrDefault("PreferredMaintenanceWindow")
  valid_606452 = validateParameter(valid_606452, JString, required = false,
                                 default = nil)
  if valid_606452 != nil:
    section.add "PreferredMaintenanceWindow", valid_606452
  var valid_606453 = query.getOrDefault("PubliclyAccessible")
  valid_606453 = validateParameter(valid_606453, JBool, required = false, default = nil)
  if valid_606453 != nil:
    section.add "PubliclyAccessible", valid_606453
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_606454 = header.getOrDefault("X-Amz-Signature")
  valid_606454 = validateParameter(valid_606454, JString, required = false,
                                 default = nil)
  if valid_606454 != nil:
    section.add "X-Amz-Signature", valid_606454
  var valid_606455 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_606455 = validateParameter(valid_606455, JString, required = false,
                                 default = nil)
  if valid_606455 != nil:
    section.add "X-Amz-Content-Sha256", valid_606455
  var valid_606456 = header.getOrDefault("X-Amz-Date")
  valid_606456 = validateParameter(valid_606456, JString, required = false,
                                 default = nil)
  if valid_606456 != nil:
    section.add "X-Amz-Date", valid_606456
  var valid_606457 = header.getOrDefault("X-Amz-Credential")
  valid_606457 = validateParameter(valid_606457, JString, required = false,
                                 default = nil)
  if valid_606457 != nil:
    section.add "X-Amz-Credential", valid_606457
  var valid_606458 = header.getOrDefault("X-Amz-Security-Token")
  valid_606458 = validateParameter(valid_606458, JString, required = false,
                                 default = nil)
  if valid_606458 != nil:
    section.add "X-Amz-Security-Token", valid_606458
  var valid_606459 = header.getOrDefault("X-Amz-Algorithm")
  valid_606459 = validateParameter(valid_606459, JString, required = false,
                                 default = nil)
  if valid_606459 != nil:
    section.add "X-Amz-Algorithm", valid_606459
  var valid_606460 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_606460 = validateParameter(valid_606460, JString, required = false,
                                 default = nil)
  if valid_606460 != nil:
    section.add "X-Amz-SignedHeaders", valid_606460
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_606461: Call_GetCreateCluster_606419; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a new cluster with the specified parameters.</p> <p>To create a cluster in Virtual Private Cloud (VPC), you must provide a cluster subnet group name. The cluster subnet group identifies the subnets of your VPC that Amazon Redshift uses when creating the cluster. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_606461.validator(path, query, header, formData, body)
  let scheme = call_606461.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_606461.url(scheme.get, call_606461.host, call_606461.base,
                         call_606461.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_606461, url, valid)

proc call*(call_606462: Call_GetCreateCluster_606419; NodeType: string;
          MasterUsername: string; ClusterIdentifier: string;
          MasterUserPassword: string; ClusterSubnetGroupName: string = "";
          MaintenanceTrackName: string = ""; DBName: string = "";
          Encrypted: bool = false; ManualSnapshotRetentionPeriod: int = 0;
          HsmClientCertificateIdentifier: string = "";
          ClusterSecurityGroups: JsonNode = nil; Tags: JsonNode = nil;
          KmsKeyId: string = ""; ClusterParameterGroupName: string = "";
          ClusterVersion: string = ""; IamRoles: JsonNode = nil;
          SnapshotScheduleIdentifier: string = ""; ClusterType: string = "";
          NumberOfNodes: int = 0; AdditionalInfo: string = "";
          AllowVersionUpgrade: bool = false; ElasticIp: string = "";
          AutomatedSnapshotRetentionPeriod: int = 0;
          EnhancedVpcRouting: bool = false; Action: string = "CreateCluster";
          Port: int = 0; VpcSecurityGroupIds: JsonNode = nil;
          AvailabilityZone: string = ""; HsmConfigurationIdentifier: string = "";
          Version: string = "2012-12-01"; PreferredMaintenanceWindow: string = "";
          PubliclyAccessible: bool = false): Recallable =
  ## getCreateCluster
  ## <p>Creates a new cluster with the specified parameters.</p> <p>To create a cluster in Virtual Private Cloud (VPC), you must provide a cluster subnet group name. The cluster subnet group identifies the subnets of your VPC that Amazon Redshift uses when creating the cluster. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   ClusterSubnetGroupName: string
  ##                         : <p>The name of a cluster subnet group to be associated with this cluster.</p> <p>If this parameter is not provided the resulting cluster will be deployed outside virtual private cloud (VPC).</p>
  ##   MaintenanceTrackName: string
  ##                       : An optional parameter for the name of the maintenance track for the cluster. If you don't provide a maintenance track name, the cluster is assigned to the <code>current</code> track.
  ##   DBName: string
  ##         : <p>The name of the first database to be created when the cluster is created.</p> <p>To create additional databases after the cluster is created, connect to the cluster with a SQL client and use SQL commands to create a database. For more information, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/t_creating_database.html">Create a Database</a> in the Amazon Redshift Database Developer Guide. </p> <p>Default: <code>dev</code> </p> <p>Constraints:</p> <ul> <li> <p>Must contain 1 to 64 alphanumeric characters.</p> </li> <li> <p>Must contain only lowercase letters.</p> </li> <li> <p>Cannot be a word that is reserved by the service. A list of reserved words can be found in <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide. </p> </li> </ul>
  ##   Encrypted: bool
  ##            : <p>If <code>true</code>, the data in the cluster is encrypted at rest. </p> <p>Default: false</p>
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The default number of days to retain a manual snapshot. If the value is -1, the snapshot is retained indefinitely. This setting doesn't change the retention period of existing snapshots.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  ##   HsmClientCertificateIdentifier: string
  ##                                 : Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM.
  ##   ClusterSecurityGroups: JArray
  ##                        : <p>A list of security groups to be associated with this cluster.</p> <p>Default: The default cluster security group for Amazon Redshift.</p>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   KmsKeyId: string
  ##           : The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster.
  ##   ClusterParameterGroupName: string
  ##                            : <p>The name of the parameter group to be associated with this cluster.</p> <p>Default: The default Amazon Redshift cluster parameter group. For information about the default parameter group, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Working with Amazon Redshift Parameter Groups</a> </p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   NodeType: string (required)
  ##           : <p>The node type to be provisioned for the cluster. For information about node types, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#how-many-nodes"> Working with Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p> <p>Valid Values: <code>ds2.xlarge</code> | <code>ds2.8xlarge</code> | <code>dc1.large</code> | <code>dc1.8xlarge</code> | <code>dc2.large</code> | <code>dc2.8xlarge</code> | <code>ra3.16xlarge</code> </p>
  ##   ClusterVersion: string
  ##                 : <p>The version of the Amazon Redshift engine software that you want to deploy on the cluster.</p> <p>The version selected runs on all the nodes in the cluster.</p> <p>Constraints: Only version 1.0 is currently available.</p> <p>Example: <code>1.0</code> </p>
  ##   IamRoles: JArray
  ##           : <p>A list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services. You must supply the IAM roles in their Amazon Resource Name (ARN) format. You can supply up to 10 IAM roles in a single request.</p> <p>A cluster can have up to 10 IAM roles associated with it at any time.</p>
  ##   SnapshotScheduleIdentifier: string
  ##                             : A unique identifier for the snapshot schedule.
  ##   ClusterType: string
  ##              : <p>The type of the cluster. When cluster type is specified as</p> <ul> <li> <p> <code>single-node</code>, the <b>NumberOfNodes</b> parameter is not required.</p> </li> <li> <p> <code>multi-node</code>, the <b>NumberOfNodes</b> parameter is required.</p> </li> </ul> <p>Valid Values: <code>multi-node</code> | <code>single-node</code> </p> <p>Default: <code>multi-node</code> </p>
  ##   NumberOfNodes: int
  ##                : <p>The number of compute nodes in the cluster. This parameter is required when the <b>ClusterType</b> parameter is specified as <code>multi-node</code>. </p> <p>For information about determining how many nodes you need, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#how-many-nodes"> Working with Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p> <p>If you don't specify this parameter, you get a single-node cluster. When requesting a multi-node cluster, you must specify the number of nodes that you want in the cluster.</p> <p>Default: <code>1</code> </p> <p>Constraints: Value must be at least 1 and no more than 100.</p>
  ##   MasterUsername: string (required)
  ##                 : <p>The user name associated with the master user account for the cluster that is being created.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 - 128 alphanumeric characters. The user name can't be <code>PUBLIC</code>.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide. </p> </li> </ul>
  ##   AdditionalInfo: string
  ##                 : Reserved.
  ##   AllowVersionUpgrade: bool
  ##                      : <p>If <code>true</code>, major version upgrades can be applied during the maintenance window to the Amazon Redshift engine that is running on the cluster.</p> <p>When a new major version of the Amazon Redshift engine is released, you can request that the service automatically apply upgrades during the maintenance window to the Amazon Redshift engine that is running on your cluster.</p> <p>Default: <code>true</code> </p>
  ##   ElasticIp: string
  ##            : <p>The Elastic IP (EIP) address for the cluster.</p> <p>Constraints: The cluster must be provisioned in EC2-VPC and publicly-accessible through an Internet gateway. For more information about provisioning clusters in EC2-VPC, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#cluster-platforms">Supported Platforms to Launch Your Cluster</a> in the Amazon Redshift Cluster Management Guide.</p>
  ##   AutomatedSnapshotRetentionPeriod: int
  ##                                   : <p>The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p> <p>Default: <code>1</code> </p> <p>Constraints: Must be a value from 0 to 35.</p>
  ##   EnhancedVpcRouting: bool
  ##                     : <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p> <p>Default: false</p>
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>A unique identifier for the cluster. You use this identifier to refer to the cluster for any subsequent cluster operations such as deleting or modifying. The identifier also appears in the Amazon Redshift console.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul> <p>Example: <code>myexamplecluster</code> </p>
  ##   Port: int
  ##       : <p>The port number on which the cluster accepts incoming connections.</p> <p>The cluster is accessible only via the JDBC and ODBC connection strings. Part of the connection string requires the port on which the cluster will listen for incoming connections.</p> <p>Default: <code>5439</code> </p> <p>Valid Values: <code>1150-65535</code> </p>
  ##   VpcSecurityGroupIds: JArray
  ##                      : <p>A list of Virtual Private Cloud (VPC) security groups to be associated with the cluster.</p> <p>Default: The default VPC security group is associated with the cluster.</p>
  ##   MasterUserPassword: string (required)
  ##                     : <p>The password associated with the master user account for the cluster that is being created.</p> <p>Constraints:</p> <ul> <li> <p>Must be between 8 and 64 characters in length.</p> </li> <li> <p>Must contain at least one uppercase letter.</p> </li> <li> <p>Must contain at least one lowercase letter.</p> </li> <li> <p>Must contain one number.</p> </li> <li> <p>Can be any printable ASCII character (ASCII code 33 to 126) except ' (single quote), " (double quote), \, /, @, or space.</p> </li> </ul>
  ##   AvailabilityZone: string
  ##                   : <p>The EC2 Availability Zone (AZ) in which you want Amazon Redshift to provision the cluster. For example, if you have several EC2 instances running in a specific Availability Zone, then you might want the cluster to be provisioned in the same zone in order to decrease network latency.</p> <p>Default: A random, system-chosen Availability Zone in the region that is specified by the endpoint.</p> <p>Example: <code>us-east-2d</code> </p> <p>Constraint: The specified Availability Zone must be in the same region as the current endpoint.</p>
  ##   HsmConfigurationIdentifier: string
  ##                             : Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
  ##   Version: string (required)
  ##   PreferredMaintenanceWindow: string
  ##                             : <p>The weekly time range (in UTC) during which automated cluster maintenance can occur.</p> <p> Format: <code>ddd:hh24:mi-ddd:hh24:mi</code> </p> <p> Default: A 30-minute window selected at random from an 8-hour block of time per region, occurring on a random day of the week. For more information about the time blocks for each region, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-maintenance-windows">Maintenance Windows</a> in Amazon Redshift Cluster Management Guide.</p> <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p> <p>Constraints: Minimum 30-minute window.</p>
  ##   PubliclyAccessible: bool
  ##                     : If <code>true</code>, the cluster can be accessed from a public network. 
  var query_606463 = newJObject()
  add(query_606463, "ClusterSubnetGroupName", newJString(ClusterSubnetGroupName))
  add(query_606463, "MaintenanceTrackName", newJString(MaintenanceTrackName))
  add(query_606463, "DBName", newJString(DBName))
  add(query_606463, "Encrypted", newJBool(Encrypted))
  add(query_606463, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  add(query_606463, "HsmClientCertificateIdentifier",
      newJString(HsmClientCertificateIdentifier))
  if ClusterSecurityGroups != nil:
    query_606463.add "ClusterSecurityGroups", ClusterSecurityGroups
  if Tags != nil:
    query_606463.add "Tags", Tags
  add(query_606463, "KmsKeyId", newJString(KmsKeyId))
  add(query_606463, "ClusterParameterGroupName",
      newJString(ClusterParameterGroupName))
  add(query_606463, "NodeType", newJString(NodeType))
  add(query_606463, "ClusterVersion", newJString(ClusterVersion))
  if IamRoles != nil:
    query_606463.add "IamRoles", IamRoles
  add(query_606463, "SnapshotScheduleIdentifier",
      newJString(SnapshotScheduleIdentifier))
  add(query_606463, "ClusterType", newJString(ClusterType))
  add(query_606463, "NumberOfNodes", newJInt(NumberOfNodes))
  add(query_606463, "MasterUsername", newJString(MasterUsername))
  add(query_606463, "AdditionalInfo", newJString(AdditionalInfo))
  add(query_606463, "AllowVersionUpgrade", newJBool(AllowVersionUpgrade))
  add(query_606463, "ElasticIp", newJString(ElasticIp))
  add(query_606463, "AutomatedSnapshotRetentionPeriod",
      newJInt(AutomatedSnapshotRetentionPeriod))
  add(query_606463, "EnhancedVpcRouting", newJBool(EnhancedVpcRouting))
  add(query_606463, "Action", newJString(Action))
  add(query_606463, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_606463, "Port", newJInt(Port))
  if VpcSecurityGroupIds != nil:
    query_606463.add "VpcSecurityGroupIds", VpcSecurityGroupIds
  add(query_606463, "MasterUserPassword", newJString(MasterUserPassword))
  add(query_606463, "AvailabilityZone", newJString(AvailabilityZone))
  add(query_606463, "HsmConfigurationIdentifier",
      newJString(HsmConfigurationIdentifier))
  add(query_606463, "Version", newJString(Version))
  add(query_606463, "PreferredMaintenanceWindow",
      newJString(PreferredMaintenanceWindow))
  add(query_606463, "PubliclyAccessible", newJBool(PubliclyAccessible))
  result = call_606462.call(nil, query_606463, nil, nil, nil)

var getCreateCluster* = Call_GetCreateCluster_606419(name: "getCreateCluster",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=CreateCluster", validator: validate_GetCreateCluster_606420,
    base: "/", url: url_GetCreateCluster_606421,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCreateClusterParameterGroup_606529 = ref object of OpenApiRestCall_605573
proc url_PostCreateClusterParameterGroup_606531(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostCreateClusterParameterGroup_606530(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates an Amazon Redshift parameter group.</p> <p>Creating parameter groups is independent of creating clusters. You can associate a cluster with a parameter group when you create the cluster. You can also associate an existing cluster with a parameter group after the cluster is created by using <a>ModifyCluster</a>. </p> <p>Parameters in the parameter group define specific behavior that applies to the databases you create on the cluster. For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_606532 = query.getOrDefault("Action")
  valid_606532 = validateParameter(valid_606532, JString, required = true, default = newJString(
      "CreateClusterParameterGroup"))
  if valid_606532 != nil:
    section.add "Action", valid_606532
  var valid_606533 = query.getOrDefault("Version")
  valid_606533 = validateParameter(valid_606533, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_606533 != nil:
    section.add "Version", valid_606533
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_606534 = header.getOrDefault("X-Amz-Signature")
  valid_606534 = validateParameter(valid_606534, JString, required = false,
                                 default = nil)
  if valid_606534 != nil:
    section.add "X-Amz-Signature", valid_606534
  var valid_606535 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_606535 = validateParameter(valid_606535, JString, required = false,
                                 default = nil)
  if valid_606535 != nil:
    section.add "X-Amz-Content-Sha256", valid_606535
  var valid_606536 = header.getOrDefault("X-Amz-Date")
  valid_606536 = validateParameter(valid_606536, JString, required = false,
                                 default = nil)
  if valid_606536 != nil:
    section.add "X-Amz-Date", valid_606536
  var valid_606537 = header.getOrDefault("X-Amz-Credential")
  valid_606537 = validateParameter(valid_606537, JString, required = false,
                                 default = nil)
  if valid_606537 != nil:
    section.add "X-Amz-Credential", valid_606537
  var valid_606538 = header.getOrDefault("X-Amz-Security-Token")
  valid_606538 = validateParameter(valid_606538, JString, required = false,
                                 default = nil)
  if valid_606538 != nil:
    section.add "X-Amz-Security-Token", valid_606538
  var valid_606539 = header.getOrDefault("X-Amz-Algorithm")
  valid_606539 = validateParameter(valid_606539, JString, required = false,
                                 default = nil)
  if valid_606539 != nil:
    section.add "X-Amz-Algorithm", valid_606539
  var valid_606540 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_606540 = validateParameter(valid_606540, JString, required = false,
                                 default = nil)
  if valid_606540 != nil:
    section.add "X-Amz-SignedHeaders", valid_606540
  result.add "header", section
  ## parameters in `formData` object:
  ##   Description: JString (required)
  ##              : A description of the parameter group.
  ##   ParameterGroupFamily: JString (required)
  ##                       : <p>The Amazon Redshift engine version to which the cluster parameter group applies. The cluster engine version determines the set of parameters.</p> <p>To get a list of valid parameter group family names, you can call <a>DescribeClusterParameterGroups</a>. By default, Amazon Redshift returns a list of all the parameter groups that are owned by your AWS account, including the default parameter groups for each Amazon Redshift engine version. The parameter group family names associated with the default parameter groups provide you the valid values. For example, a valid family name is "redshift-1.0". </p>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   ParameterGroupName: JString (required)
  ##                     : <p>The name of the cluster parameter group.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique withing your AWS account.</p> </li> </ul> <note> <p>This value is stored as a lower-case string.</p> </note>
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `Description` field"
  var valid_606541 = formData.getOrDefault("Description")
  valid_606541 = validateParameter(valid_606541, JString, required = true,
                                 default = nil)
  if valid_606541 != nil:
    section.add "Description", valid_606541
  var valid_606542 = formData.getOrDefault("ParameterGroupFamily")
  valid_606542 = validateParameter(valid_606542, JString, required = true,
                                 default = nil)
  if valid_606542 != nil:
    section.add "ParameterGroupFamily", valid_606542
  var valid_606543 = formData.getOrDefault("Tags")
  valid_606543 = validateParameter(valid_606543, JArray, required = false,
                                 default = nil)
  if valid_606543 != nil:
    section.add "Tags", valid_606543
  var valid_606544 = formData.getOrDefault("ParameterGroupName")
  valid_606544 = validateParameter(valid_606544, JString, required = true,
                                 default = nil)
  if valid_606544 != nil:
    section.add "ParameterGroupName", valid_606544
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_606545: Call_PostCreateClusterParameterGroup_606529;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Creates an Amazon Redshift parameter group.</p> <p>Creating parameter groups is independent of creating clusters. You can associate a cluster with a parameter group when you create the cluster. You can also associate an existing cluster with a parameter group after the cluster is created by using <a>ModifyCluster</a>. </p> <p>Parameters in the parameter group define specific behavior that applies to the databases you create on the cluster. For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_606545.validator(path, query, header, formData, body)
  let scheme = call_606545.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_606545.url(scheme.get, call_606545.host, call_606545.base,
                         call_606545.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_606545, url, valid)

proc call*(call_606546: Call_PostCreateClusterParameterGroup_606529;
          Description: string; ParameterGroupFamily: string;
          ParameterGroupName: string;
          Action: string = "CreateClusterParameterGroup"; Tags: JsonNode = nil;
          Version: string = "2012-12-01"): Recallable =
  ## postCreateClusterParameterGroup
  ## <p>Creates an Amazon Redshift parameter group.</p> <p>Creating parameter groups is independent of creating clusters. You can associate a cluster with a parameter group when you create the cluster. You can also associate an existing cluster with a parameter group after the cluster is created by using <a>ModifyCluster</a>. </p> <p>Parameters in the parameter group define specific behavior that applies to the databases you create on the cluster. For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   Description: string (required)
  ##              : A description of the parameter group.
  ##   ParameterGroupFamily: string (required)
  ##                       : <p>The Amazon Redshift engine version to which the cluster parameter group applies. The cluster engine version determines the set of parameters.</p> <p>To get a list of valid parameter group family names, you can call <a>DescribeClusterParameterGroups</a>. By default, Amazon Redshift returns a list of all the parameter groups that are owned by your AWS account, including the default parameter groups for each Amazon Redshift engine version. The parameter group family names associated with the default parameter groups provide you the valid values. For example, a valid family name is "redshift-1.0". </p>
  ##   Action: string (required)
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   ParameterGroupName: string (required)
  ##                     : <p>The name of the cluster parameter group.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique withing your AWS account.</p> </li> </ul> <note> <p>This value is stored as a lower-case string.</p> </note>
  ##   Version: string (required)
  var query_606547 = newJObject()
  var formData_606548 = newJObject()
  add(formData_606548, "Description", newJString(Description))
  add(formData_606548, "ParameterGroupFamily", newJString(ParameterGroupFamily))
  add(query_606547, "Action", newJString(Action))
  if Tags != nil:
    formData_606548.add "Tags", Tags
  add(formData_606548, "ParameterGroupName", newJString(ParameterGroupName))
  add(query_606547, "Version", newJString(Version))
  result = call_606546.call(nil, query_606547, nil, formData_606548, nil)

var postCreateClusterParameterGroup* = Call_PostCreateClusterParameterGroup_606529(
    name: "postCreateClusterParameterGroup", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=CreateClusterParameterGroup",
    validator: validate_PostCreateClusterParameterGroup_606530, base: "/",
    url: url_PostCreateClusterParameterGroup_606531,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCreateClusterParameterGroup_606510 = ref object of OpenApiRestCall_605573
proc url_GetCreateClusterParameterGroup_606512(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetCreateClusterParameterGroup_606511(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates an Amazon Redshift parameter group.</p> <p>Creating parameter groups is independent of creating clusters. You can associate a cluster with a parameter group when you create the cluster. You can also associate an existing cluster with a parameter group after the cluster is created by using <a>ModifyCluster</a>. </p> <p>Parameters in the parameter group define specific behavior that applies to the databases you create on the cluster. For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   ParameterGroupFamily: JString (required)
  ##                       : <p>The Amazon Redshift engine version to which the cluster parameter group applies. The cluster engine version determines the set of parameters.</p> <p>To get a list of valid parameter group family names, you can call <a>DescribeClusterParameterGroups</a>. By default, Amazon Redshift returns a list of all the parameter groups that are owned by your AWS account, including the default parameter groups for each Amazon Redshift engine version. The parameter group family names associated with the default parameter groups provide you the valid values. For example, a valid family name is "redshift-1.0". </p>
  ##   Action: JString (required)
  ##   Description: JString (required)
  ##              : A description of the parameter group.
  ##   ParameterGroupName: JString (required)
  ##                     : <p>The name of the cluster parameter group.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique withing your AWS account.</p> </li> </ul> <note> <p>This value is stored as a lower-case string.</p> </note>
  ##   Version: JString (required)
  section = newJObject()
  var valid_606513 = query.getOrDefault("Tags")
  valid_606513 = validateParameter(valid_606513, JArray, required = false,
                                 default = nil)
  if valid_606513 != nil:
    section.add "Tags", valid_606513
  assert query != nil, "query argument is necessary due to required `ParameterGroupFamily` field"
  var valid_606514 = query.getOrDefault("ParameterGroupFamily")
  valid_606514 = validateParameter(valid_606514, JString, required = true,
                                 default = nil)
  if valid_606514 != nil:
    section.add "ParameterGroupFamily", valid_606514
  var valid_606515 = query.getOrDefault("Action")
  valid_606515 = validateParameter(valid_606515, JString, required = true, default = newJString(
      "CreateClusterParameterGroup"))
  if valid_606515 != nil:
    section.add "Action", valid_606515
  var valid_606516 = query.getOrDefault("Description")
  valid_606516 = validateParameter(valid_606516, JString, required = true,
                                 default = nil)
  if valid_606516 != nil:
    section.add "Description", valid_606516
  var valid_606517 = query.getOrDefault("ParameterGroupName")
  valid_606517 = validateParameter(valid_606517, JString, required = true,
                                 default = nil)
  if valid_606517 != nil:
    section.add "ParameterGroupName", valid_606517
  var valid_606518 = query.getOrDefault("Version")
  valid_606518 = validateParameter(valid_606518, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_606518 != nil:
    section.add "Version", valid_606518
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_606519 = header.getOrDefault("X-Amz-Signature")
  valid_606519 = validateParameter(valid_606519, JString, required = false,
                                 default = nil)
  if valid_606519 != nil:
    section.add "X-Amz-Signature", valid_606519
  var valid_606520 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_606520 = validateParameter(valid_606520, JString, required = false,
                                 default = nil)
  if valid_606520 != nil:
    section.add "X-Amz-Content-Sha256", valid_606520
  var valid_606521 = header.getOrDefault("X-Amz-Date")
  valid_606521 = validateParameter(valid_606521, JString, required = false,
                                 default = nil)
  if valid_606521 != nil:
    section.add "X-Amz-Date", valid_606521
  var valid_606522 = header.getOrDefault("X-Amz-Credential")
  valid_606522 = validateParameter(valid_606522, JString, required = false,
                                 default = nil)
  if valid_606522 != nil:
    section.add "X-Amz-Credential", valid_606522
  var valid_606523 = header.getOrDefault("X-Amz-Security-Token")
  valid_606523 = validateParameter(valid_606523, JString, required = false,
                                 default = nil)
  if valid_606523 != nil:
    section.add "X-Amz-Security-Token", valid_606523
  var valid_606524 = header.getOrDefault("X-Amz-Algorithm")
  valid_606524 = validateParameter(valid_606524, JString, required = false,
                                 default = nil)
  if valid_606524 != nil:
    section.add "X-Amz-Algorithm", valid_606524
  var valid_606525 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_606525 = validateParameter(valid_606525, JString, required = false,
                                 default = nil)
  if valid_606525 != nil:
    section.add "X-Amz-SignedHeaders", valid_606525
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_606526: Call_GetCreateClusterParameterGroup_606510; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates an Amazon Redshift parameter group.</p> <p>Creating parameter groups is independent of creating clusters. You can associate a cluster with a parameter group when you create the cluster. You can also associate an existing cluster with a parameter group after the cluster is created by using <a>ModifyCluster</a>. </p> <p>Parameters in the parameter group define specific behavior that applies to the databases you create on the cluster. For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_606526.validator(path, query, header, formData, body)
  let scheme = call_606526.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_606526.url(scheme.get, call_606526.host, call_606526.base,
                         call_606526.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_606526, url, valid)

proc call*(call_606527: Call_GetCreateClusterParameterGroup_606510;
          ParameterGroupFamily: string; Description: string;
          ParameterGroupName: string; Tags: JsonNode = nil;
          Action: string = "CreateClusterParameterGroup";
          Version: string = "2012-12-01"): Recallable =
  ## getCreateClusterParameterGroup
  ## <p>Creates an Amazon Redshift parameter group.</p> <p>Creating parameter groups is independent of creating clusters. You can associate a cluster with a parameter group when you create the cluster. You can also associate an existing cluster with a parameter group after the cluster is created by using <a>ModifyCluster</a>. </p> <p>Parameters in the parameter group define specific behavior that applies to the databases you create on the cluster. For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   ParameterGroupFamily: string (required)
  ##                       : <p>The Amazon Redshift engine version to which the cluster parameter group applies. The cluster engine version determines the set of parameters.</p> <p>To get a list of valid parameter group family names, you can call <a>DescribeClusterParameterGroups</a>. By default, Amazon Redshift returns a list of all the parameter groups that are owned by your AWS account, including the default parameter groups for each Amazon Redshift engine version. The parameter group family names associated with the default parameter groups provide you the valid values. For example, a valid family name is "redshift-1.0". </p>
  ##   Action: string (required)
  ##   Description: string (required)
  ##              : A description of the parameter group.
  ##   ParameterGroupName: string (required)
  ##                     : <p>The name of the cluster parameter group.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique withing your AWS account.</p> </li> </ul> <note> <p>This value is stored as a lower-case string.</p> </note>
  ##   Version: string (required)
  var query_606528 = newJObject()
  if Tags != nil:
    query_606528.add "Tags", Tags
  add(query_606528, "ParameterGroupFamily", newJString(ParameterGroupFamily))
  add(query_606528, "Action", newJString(Action))
  add(query_606528, "Description", newJString(Description))
  add(query_606528, "ParameterGroupName", newJString(ParameterGroupName))
  add(query_606528, "Version", newJString(Version))
  result = call_606527.call(nil, query_606528, nil, nil, nil)

var getCreateClusterParameterGroup* = Call_GetCreateClusterParameterGroup_606510(
    name: "getCreateClusterParameterGroup", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=CreateClusterParameterGroup",
    validator: validate_GetCreateClusterParameterGroup_606511, base: "/",
    url: url_GetCreateClusterParameterGroup_606512,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCreateClusterSecurityGroup_606567 = ref object of OpenApiRestCall_605573
proc url_PostCreateClusterSecurityGroup_606569(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostCreateClusterSecurityGroup_606568(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a new Amazon Redshift security group. You use security groups to control access to non-VPC clusters.</p> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_606570 = query.getOrDefault("Action")
  valid_606570 = validateParameter(valid_606570, JString, required = true, default = newJString(
      "CreateClusterSecurityGroup"))
  if valid_606570 != nil:
    section.add "Action", valid_606570
  var valid_606571 = query.getOrDefault("Version")
  valid_606571 = validateParameter(valid_606571, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_606571 != nil:
    section.add "Version", valid_606571
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_606572 = header.getOrDefault("X-Amz-Signature")
  valid_606572 = validateParameter(valid_606572, JString, required = false,
                                 default = nil)
  if valid_606572 != nil:
    section.add "X-Amz-Signature", valid_606572
  var valid_606573 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_606573 = validateParameter(valid_606573, JString, required = false,
                                 default = nil)
  if valid_606573 != nil:
    section.add "X-Amz-Content-Sha256", valid_606573
  var valid_606574 = header.getOrDefault("X-Amz-Date")
  valid_606574 = validateParameter(valid_606574, JString, required = false,
                                 default = nil)
  if valid_606574 != nil:
    section.add "X-Amz-Date", valid_606574
  var valid_606575 = header.getOrDefault("X-Amz-Credential")
  valid_606575 = validateParameter(valid_606575, JString, required = false,
                                 default = nil)
  if valid_606575 != nil:
    section.add "X-Amz-Credential", valid_606575
  var valid_606576 = header.getOrDefault("X-Amz-Security-Token")
  valid_606576 = validateParameter(valid_606576, JString, required = false,
                                 default = nil)
  if valid_606576 != nil:
    section.add "X-Amz-Security-Token", valid_606576
  var valid_606577 = header.getOrDefault("X-Amz-Algorithm")
  valid_606577 = validateParameter(valid_606577, JString, required = false,
                                 default = nil)
  if valid_606577 != nil:
    section.add "X-Amz-Algorithm", valid_606577
  var valid_606578 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_606578 = validateParameter(valid_606578, JString, required = false,
                                 default = nil)
  if valid_606578 != nil:
    section.add "X-Amz-SignedHeaders", valid_606578
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterSecurityGroupName: JString (required)
  ##                           : <p>The name for the security group. Amazon Redshift stores the value as a lowercase string.</p> <p>Constraints:</p> <ul> <li> <p>Must contain no more than 255 alphanumeric characters or hyphens.</p> </li> <li> <p>Must not be "Default".</p> </li> <li> <p>Must be unique for all security groups that are created by your AWS account.</p> </li> </ul> <p>Example: <code>examplesecuritygroup</code> </p>
  ##   Description: JString (required)
  ##              : A description for the security group.
  ##   Tags: JArray
  ##       : A list of tag instances.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterSecurityGroupName` field"
  var valid_606579 = formData.getOrDefault("ClusterSecurityGroupName")
  valid_606579 = validateParameter(valid_606579, JString, required = true,
                                 default = nil)
  if valid_606579 != nil:
    section.add "ClusterSecurityGroupName", valid_606579
  var valid_606580 = formData.getOrDefault("Description")
  valid_606580 = validateParameter(valid_606580, JString, required = true,
                                 default = nil)
  if valid_606580 != nil:
    section.add "Description", valid_606580
  var valid_606581 = formData.getOrDefault("Tags")
  valid_606581 = validateParameter(valid_606581, JArray, required = false,
                                 default = nil)
  if valid_606581 != nil:
    section.add "Tags", valid_606581
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_606582: Call_PostCreateClusterSecurityGroup_606567; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a new Amazon Redshift security group. You use security groups to control access to non-VPC clusters.</p> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_606582.validator(path, query, header, formData, body)
  let scheme = call_606582.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_606582.url(scheme.get, call_606582.host, call_606582.base,
                         call_606582.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_606582, url, valid)

proc call*(call_606583: Call_PostCreateClusterSecurityGroup_606567;
          ClusterSecurityGroupName: string; Description: string;
          Action: string = "CreateClusterSecurityGroup"; Tags: JsonNode = nil;
          Version: string = "2012-12-01"): Recallable =
  ## postCreateClusterSecurityGroup
  ## <p>Creates a new Amazon Redshift security group. You use security groups to control access to non-VPC clusters.</p> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   ClusterSecurityGroupName: string (required)
  ##                           : <p>The name for the security group. Amazon Redshift stores the value as a lowercase string.</p> <p>Constraints:</p> <ul> <li> <p>Must contain no more than 255 alphanumeric characters or hyphens.</p> </li> <li> <p>Must not be "Default".</p> </li> <li> <p>Must be unique for all security groups that are created by your AWS account.</p> </li> </ul> <p>Example: <code>examplesecuritygroup</code> </p>
  ##   Description: string (required)
  ##              : A description for the security group.
  ##   Action: string (required)
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Version: string (required)
  var query_606584 = newJObject()
  var formData_606585 = newJObject()
  add(formData_606585, "ClusterSecurityGroupName",
      newJString(ClusterSecurityGroupName))
  add(formData_606585, "Description", newJString(Description))
  add(query_606584, "Action", newJString(Action))
  if Tags != nil:
    formData_606585.add "Tags", Tags
  add(query_606584, "Version", newJString(Version))
  result = call_606583.call(nil, query_606584, nil, formData_606585, nil)

var postCreateClusterSecurityGroup* = Call_PostCreateClusterSecurityGroup_606567(
    name: "postCreateClusterSecurityGroup", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=CreateClusterSecurityGroup",
    validator: validate_PostCreateClusterSecurityGroup_606568, base: "/",
    url: url_PostCreateClusterSecurityGroup_606569,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCreateClusterSecurityGroup_606549 = ref object of OpenApiRestCall_605573
proc url_GetCreateClusterSecurityGroup_606551(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetCreateClusterSecurityGroup_606550(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a new Amazon Redshift security group. You use security groups to control access to non-VPC clusters.</p> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   ClusterSecurityGroupName: JString (required)
  ##                           : <p>The name for the security group. Amazon Redshift stores the value as a lowercase string.</p> <p>Constraints:</p> <ul> <li> <p>Must contain no more than 255 alphanumeric characters or hyphens.</p> </li> <li> <p>Must not be "Default".</p> </li> <li> <p>Must be unique for all security groups that are created by your AWS account.</p> </li> </ul> <p>Example: <code>examplesecuritygroup</code> </p>
  ##   Action: JString (required)
  ##   Description: JString (required)
  ##              : A description for the security group.
  ##   Version: JString (required)
  section = newJObject()
  var valid_606552 = query.getOrDefault("Tags")
  valid_606552 = validateParameter(valid_606552, JArray, required = false,
                                 default = nil)
  if valid_606552 != nil:
    section.add "Tags", valid_606552
  assert query != nil, "query argument is necessary due to required `ClusterSecurityGroupName` field"
  var valid_606553 = query.getOrDefault("ClusterSecurityGroupName")
  valid_606553 = validateParameter(valid_606553, JString, required = true,
                                 default = nil)
  if valid_606553 != nil:
    section.add "ClusterSecurityGroupName", valid_606553
  var valid_606554 = query.getOrDefault("Action")
  valid_606554 = validateParameter(valid_606554, JString, required = true, default = newJString(
      "CreateClusterSecurityGroup"))
  if valid_606554 != nil:
    section.add "Action", valid_606554
  var valid_606555 = query.getOrDefault("Description")
  valid_606555 = validateParameter(valid_606555, JString, required = true,
                                 default = nil)
  if valid_606555 != nil:
    section.add "Description", valid_606555
  var valid_606556 = query.getOrDefault("Version")
  valid_606556 = validateParameter(valid_606556, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_606556 != nil:
    section.add "Version", valid_606556
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_606557 = header.getOrDefault("X-Amz-Signature")
  valid_606557 = validateParameter(valid_606557, JString, required = false,
                                 default = nil)
  if valid_606557 != nil:
    section.add "X-Amz-Signature", valid_606557
  var valid_606558 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_606558 = validateParameter(valid_606558, JString, required = false,
                                 default = nil)
  if valid_606558 != nil:
    section.add "X-Amz-Content-Sha256", valid_606558
  var valid_606559 = header.getOrDefault("X-Amz-Date")
  valid_606559 = validateParameter(valid_606559, JString, required = false,
                                 default = nil)
  if valid_606559 != nil:
    section.add "X-Amz-Date", valid_606559
  var valid_606560 = header.getOrDefault("X-Amz-Credential")
  valid_606560 = validateParameter(valid_606560, JString, required = false,
                                 default = nil)
  if valid_606560 != nil:
    section.add "X-Amz-Credential", valid_606560
  var valid_606561 = header.getOrDefault("X-Amz-Security-Token")
  valid_606561 = validateParameter(valid_606561, JString, required = false,
                                 default = nil)
  if valid_606561 != nil:
    section.add "X-Amz-Security-Token", valid_606561
  var valid_606562 = header.getOrDefault("X-Amz-Algorithm")
  valid_606562 = validateParameter(valid_606562, JString, required = false,
                                 default = nil)
  if valid_606562 != nil:
    section.add "X-Amz-Algorithm", valid_606562
  var valid_606563 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_606563 = validateParameter(valid_606563, JString, required = false,
                                 default = nil)
  if valid_606563 != nil:
    section.add "X-Amz-SignedHeaders", valid_606563
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_606564: Call_GetCreateClusterSecurityGroup_606549; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a new Amazon Redshift security group. You use security groups to control access to non-VPC clusters.</p> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_606564.validator(path, query, header, formData, body)
  let scheme = call_606564.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_606564.url(scheme.get, call_606564.host, call_606564.base,
                         call_606564.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_606564, url, valid)

proc call*(call_606565: Call_GetCreateClusterSecurityGroup_606549;
          ClusterSecurityGroupName: string; Description: string;
          Tags: JsonNode = nil; Action: string = "CreateClusterSecurityGroup";
          Version: string = "2012-12-01"): Recallable =
  ## getCreateClusterSecurityGroup
  ## <p>Creates a new Amazon Redshift security group. You use security groups to control access to non-VPC clusters.</p> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   ClusterSecurityGroupName: string (required)
  ##                           : <p>The name for the security group. Amazon Redshift stores the value as a lowercase string.</p> <p>Constraints:</p> <ul> <li> <p>Must contain no more than 255 alphanumeric characters or hyphens.</p> </li> <li> <p>Must not be "Default".</p> </li> <li> <p>Must be unique for all security groups that are created by your AWS account.</p> </li> </ul> <p>Example: <code>examplesecuritygroup</code> </p>
  ##   Action: string (required)
  ##   Description: string (required)
  ##              : A description for the security group.
  ##   Version: string (required)
  var query_606566 = newJObject()
  if Tags != nil:
    query_606566.add "Tags", Tags
  add(query_606566, "ClusterSecurityGroupName",
      newJString(ClusterSecurityGroupName))
  add(query_606566, "Action", newJString(Action))
  add(query_606566, "Description", newJString(Description))
  add(query_606566, "Version", newJString(Version))
  result = call_606565.call(nil, query_606566, nil, nil, nil)

var getCreateClusterSecurityGroup* = Call_GetCreateClusterSecurityGroup_606549(
    name: "getCreateClusterSecurityGroup", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=CreateClusterSecurityGroup",
    validator: validate_GetCreateClusterSecurityGroup_606550, base: "/",
    url: url_GetCreateClusterSecurityGroup_606551,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCreateClusterSnapshot_606605 = ref object of OpenApiRestCall_605573
proc url_PostCreateClusterSnapshot_606607(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostCreateClusterSnapshot_606606(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a manual snapshot of the specified cluster. The cluster must be in the <code>available</code> state. </p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_606608 = query.getOrDefault("Action")
  valid_606608 = validateParameter(valid_606608, JString, required = true,
                                 default = newJString("CreateClusterSnapshot"))
  if valid_606608 != nil:
    section.add "Action", valid_606608
  var valid_606609 = query.getOrDefault("Version")
  valid_606609 = validateParameter(valid_606609, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_606609 != nil:
    section.add "Version", valid_606609
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_606610 = header.getOrDefault("X-Amz-Signature")
  valid_606610 = validateParameter(valid_606610, JString, required = false,
                                 default = nil)
  if valid_606610 != nil:
    section.add "X-Amz-Signature", valid_606610
  var valid_606611 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_606611 = validateParameter(valid_606611, JString, required = false,
                                 default = nil)
  if valid_606611 != nil:
    section.add "X-Amz-Content-Sha256", valid_606611
  var valid_606612 = header.getOrDefault("X-Amz-Date")
  valid_606612 = validateParameter(valid_606612, JString, required = false,
                                 default = nil)
  if valid_606612 != nil:
    section.add "X-Amz-Date", valid_606612
  var valid_606613 = header.getOrDefault("X-Amz-Credential")
  valid_606613 = validateParameter(valid_606613, JString, required = false,
                                 default = nil)
  if valid_606613 != nil:
    section.add "X-Amz-Credential", valid_606613
  var valid_606614 = header.getOrDefault("X-Amz-Security-Token")
  valid_606614 = validateParameter(valid_606614, JString, required = false,
                                 default = nil)
  if valid_606614 != nil:
    section.add "X-Amz-Security-Token", valid_606614
  var valid_606615 = header.getOrDefault("X-Amz-Algorithm")
  valid_606615 = validateParameter(valid_606615, JString, required = false,
                                 default = nil)
  if valid_606615 != nil:
    section.add "X-Amz-Algorithm", valid_606615
  var valid_606616 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_606616 = validateParameter(valid_606616, JString, required = false,
                                 default = nil)
  if valid_606616 != nil:
    section.add "X-Amz-SignedHeaders", valid_606616
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : The cluster identifier for which you want a snapshot.
  ##   SnapshotIdentifier: JString (required)
  ##                     : <p>A unique identifier for the snapshot that you are requesting. This identifier must be unique for all snapshots within the AWS account.</p> <p>Constraints:</p> <ul> <li> <p>Cannot be null, empty, or blank</p> </li> <li> <p>Must contain from 1 to 255 alphanumeric characters or hyphens</p> </li> <li> <p>First character must be a letter</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens</p> </li> </ul> <p>Example: <code>my-snapshot-id</code> </p>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. </p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_606617 = formData.getOrDefault("ClusterIdentifier")
  valid_606617 = validateParameter(valid_606617, JString, required = true,
                                 default = nil)
  if valid_606617 != nil:
    section.add "ClusterIdentifier", valid_606617
  var valid_606618 = formData.getOrDefault("SnapshotIdentifier")
  valid_606618 = validateParameter(valid_606618, JString, required = true,
                                 default = nil)
  if valid_606618 != nil:
    section.add "SnapshotIdentifier", valid_606618
  var valid_606619 = formData.getOrDefault("Tags")
  valid_606619 = validateParameter(valid_606619, JArray, required = false,
                                 default = nil)
  if valid_606619 != nil:
    section.add "Tags", valid_606619
  var valid_606620 = formData.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_606620 = validateParameter(valid_606620, JInt, required = false, default = nil)
  if valid_606620 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_606620
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_606621: Call_PostCreateClusterSnapshot_606605; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a manual snapshot of the specified cluster. The cluster must be in the <code>available</code> state. </p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_606621.validator(path, query, header, formData, body)
  let scheme = call_606621.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_606621.url(scheme.get, call_606621.host, call_606621.base,
                         call_606621.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_606621, url, valid)

proc call*(call_606622: Call_PostCreateClusterSnapshot_606605;
          ClusterIdentifier: string; SnapshotIdentifier: string;
          Action: string = "CreateClusterSnapshot"; Tags: JsonNode = nil;
          Version: string = "2012-12-01"; ManualSnapshotRetentionPeriod: int = 0): Recallable =
  ## postCreateClusterSnapshot
  ## <p>Creates a manual snapshot of the specified cluster. The cluster must be in the <code>available</code> state. </p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   ClusterIdentifier: string (required)
  ##                    : The cluster identifier for which you want a snapshot.
  ##   SnapshotIdentifier: string (required)
  ##                     : <p>A unique identifier for the snapshot that you are requesting. This identifier must be unique for all snapshots within the AWS account.</p> <p>Constraints:</p> <ul> <li> <p>Cannot be null, empty, or blank</p> </li> <li> <p>Must contain from 1 to 255 alphanumeric characters or hyphens</p> </li> <li> <p>First character must be a letter</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens</p> </li> </ul> <p>Example: <code>my-snapshot-id</code> </p>
  ##   Action: string (required)
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Version: string (required)
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. </p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  var query_606623 = newJObject()
  var formData_606624 = newJObject()
  add(formData_606624, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_606624, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_606623, "Action", newJString(Action))
  if Tags != nil:
    formData_606624.add "Tags", Tags
  add(query_606623, "Version", newJString(Version))
  add(formData_606624, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  result = call_606622.call(nil, query_606623, nil, formData_606624, nil)

var postCreateClusterSnapshot* = Call_PostCreateClusterSnapshot_606605(
    name: "postCreateClusterSnapshot", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=CreateClusterSnapshot",
    validator: validate_PostCreateClusterSnapshot_606606, base: "/",
    url: url_PostCreateClusterSnapshot_606607,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCreateClusterSnapshot_606586 = ref object of OpenApiRestCall_605573
proc url_GetCreateClusterSnapshot_606588(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetCreateClusterSnapshot_606587(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a manual snapshot of the specified cluster. The cluster must be in the <code>available</code> state. </p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   SnapshotIdentifier: JString (required)
  ##                     : <p>A unique identifier for the snapshot that you are requesting. This identifier must be unique for all snapshots within the AWS account.</p> <p>Constraints:</p> <ul> <li> <p>Cannot be null, empty, or blank</p> </li> <li> <p>Must contain from 1 to 255 alphanumeric characters or hyphens</p> </li> <li> <p>First character must be a letter</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens</p> </li> </ul> <p>Example: <code>my-snapshot-id</code> </p>
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. </p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : The cluster identifier for which you want a snapshot.
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `SnapshotIdentifier` field"
  var valid_606589 = query.getOrDefault("SnapshotIdentifier")
  valid_606589 = validateParameter(valid_606589, JString, required = true,
                                 default = nil)
  if valid_606589 != nil:
    section.add "SnapshotIdentifier", valid_606589
  var valid_606590 = query.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_606590 = validateParameter(valid_606590, JInt, required = false, default = nil)
  if valid_606590 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_606590
  var valid_606591 = query.getOrDefault("Tags")
  valid_606591 = validateParameter(valid_606591, JArray, required = false,
                                 default = nil)
  if valid_606591 != nil:
    section.add "Tags", valid_606591
  var valid_606592 = query.getOrDefault("Action")
  valid_606592 = validateParameter(valid_606592, JString, required = true,
                                 default = newJString("CreateClusterSnapshot"))
  if valid_606592 != nil:
    section.add "Action", valid_606592
  var valid_606593 = query.getOrDefault("ClusterIdentifier")
  valid_606593 = validateParameter(valid_606593, JString, required = true,
                                 default = nil)
  if valid_606593 != nil:
    section.add "ClusterIdentifier", valid_606593
  var valid_606594 = query.getOrDefault("Version")
  valid_606594 = validateParameter(valid_606594, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_606594 != nil:
    section.add "Version", valid_606594
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_606595 = header.getOrDefault("X-Amz-Signature")
  valid_606595 = validateParameter(valid_606595, JString, required = false,
                                 default = nil)
  if valid_606595 != nil:
    section.add "X-Amz-Signature", valid_606595
  var valid_606596 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_606596 = validateParameter(valid_606596, JString, required = false,
                                 default = nil)
  if valid_606596 != nil:
    section.add "X-Amz-Content-Sha256", valid_606596
  var valid_606597 = header.getOrDefault("X-Amz-Date")
  valid_606597 = validateParameter(valid_606597, JString, required = false,
                                 default = nil)
  if valid_606597 != nil:
    section.add "X-Amz-Date", valid_606597
  var valid_606598 = header.getOrDefault("X-Amz-Credential")
  valid_606598 = validateParameter(valid_606598, JString, required = false,
                                 default = nil)
  if valid_606598 != nil:
    section.add "X-Amz-Credential", valid_606598
  var valid_606599 = header.getOrDefault("X-Amz-Security-Token")
  valid_606599 = validateParameter(valid_606599, JString, required = false,
                                 default = nil)
  if valid_606599 != nil:
    section.add "X-Amz-Security-Token", valid_606599
  var valid_606600 = header.getOrDefault("X-Amz-Algorithm")
  valid_606600 = validateParameter(valid_606600, JString, required = false,
                                 default = nil)
  if valid_606600 != nil:
    section.add "X-Amz-Algorithm", valid_606600
  var valid_606601 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_606601 = validateParameter(valid_606601, JString, required = false,
                                 default = nil)
  if valid_606601 != nil:
    section.add "X-Amz-SignedHeaders", valid_606601
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_606602: Call_GetCreateClusterSnapshot_606586; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a manual snapshot of the specified cluster. The cluster must be in the <code>available</code> state. </p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_606602.validator(path, query, header, formData, body)
  let scheme = call_606602.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_606602.url(scheme.get, call_606602.host, call_606602.base,
                         call_606602.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_606602, url, valid)

proc call*(call_606603: Call_GetCreateClusterSnapshot_606586;
          SnapshotIdentifier: string; ClusterIdentifier: string;
          ManualSnapshotRetentionPeriod: int = 0; Tags: JsonNode = nil;
          Action: string = "CreateClusterSnapshot"; Version: string = "2012-12-01"): Recallable =
  ## getCreateClusterSnapshot
  ## <p>Creates a manual snapshot of the specified cluster. The cluster must be in the <code>available</code> state. </p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   SnapshotIdentifier: string (required)
  ##                     : <p>A unique identifier for the snapshot that you are requesting. This identifier must be unique for all snapshots within the AWS account.</p> <p>Constraints:</p> <ul> <li> <p>Cannot be null, empty, or blank</p> </li> <li> <p>Must contain from 1 to 255 alphanumeric characters or hyphens</p> </li> <li> <p>First character must be a letter</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens</p> </li> </ul> <p>Example: <code>my-snapshot-id</code> </p>
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. </p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : The cluster identifier for which you want a snapshot.
  ##   Version: string (required)
  var query_606604 = newJObject()
  add(query_606604, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_606604, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  if Tags != nil:
    query_606604.add "Tags", Tags
  add(query_606604, "Action", newJString(Action))
  add(query_606604, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_606604, "Version", newJString(Version))
  result = call_606603.call(nil, query_606604, nil, nil, nil)

var getCreateClusterSnapshot* = Call_GetCreateClusterSnapshot_606586(
    name: "getCreateClusterSnapshot", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=CreateClusterSnapshot",
    validator: validate_GetCreateClusterSnapshot_606587, base: "/",
    url: url_GetCreateClusterSnapshot_606588, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCreateClusterSubnetGroup_606644 = ref object of OpenApiRestCall_605573
proc url_PostCreateClusterSubnetGroup_606646(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostCreateClusterSubnetGroup_606645(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a new Amazon Redshift subnet group. You must provide a list of one or more subnets in your existing Amazon Virtual Private Cloud (Amazon VPC) when creating Amazon Redshift subnet group.</p> <p> For information about subnet groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-cluster-subnet-groups.html">Amazon Redshift Cluster Subnet Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_606647 = query.getOrDefault("Action")
  valid_606647 = validateParameter(valid_606647, JString, required = true, default = newJString(
      "CreateClusterSubnetGroup"))
  if valid_606647 != nil:
    section.add "Action", valid_606647
  var valid_606648 = query.getOrDefault("Version")
  valid_606648 = validateParameter(valid_606648, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_606648 != nil:
    section.add "Version", valid_606648
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_606649 = header.getOrDefault("X-Amz-Signature")
  valid_606649 = validateParameter(valid_606649, JString, required = false,
                                 default = nil)
  if valid_606649 != nil:
    section.add "X-Amz-Signature", valid_606649
  var valid_606650 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_606650 = validateParameter(valid_606650, JString, required = false,
                                 default = nil)
  if valid_606650 != nil:
    section.add "X-Amz-Content-Sha256", valid_606650
  var valid_606651 = header.getOrDefault("X-Amz-Date")
  valid_606651 = validateParameter(valid_606651, JString, required = false,
                                 default = nil)
  if valid_606651 != nil:
    section.add "X-Amz-Date", valid_606651
  var valid_606652 = header.getOrDefault("X-Amz-Credential")
  valid_606652 = validateParameter(valid_606652, JString, required = false,
                                 default = nil)
  if valid_606652 != nil:
    section.add "X-Amz-Credential", valid_606652
  var valid_606653 = header.getOrDefault("X-Amz-Security-Token")
  valid_606653 = validateParameter(valid_606653, JString, required = false,
                                 default = nil)
  if valid_606653 != nil:
    section.add "X-Amz-Security-Token", valid_606653
  var valid_606654 = header.getOrDefault("X-Amz-Algorithm")
  valid_606654 = validateParameter(valid_606654, JString, required = false,
                                 default = nil)
  if valid_606654 != nil:
    section.add "X-Amz-Algorithm", valid_606654
  var valid_606655 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_606655 = validateParameter(valid_606655, JString, required = false,
                                 default = nil)
  if valid_606655 != nil:
    section.add "X-Amz-SignedHeaders", valid_606655
  result.add "header", section
  ## parameters in `formData` object:
  ##   Description: JString (required)
  ##              : A description for the subnet group.
  ##   ClusterSubnetGroupName: JString (required)
  ##                         : <p>The name for the subnet group. Amazon Redshift stores the value as a lowercase string.</p> <p>Constraints:</p> <ul> <li> <p>Must contain no more than 255 alphanumeric characters or hyphens.</p> </li> <li> <p>Must not be "Default".</p> </li> <li> <p>Must be unique for all subnet groups that are created by your AWS account.</p> </li> </ul> <p>Example: <code>examplesubnetgroup</code> </p>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   SubnetIds: JArray (required)
  ##            : An array of VPC subnet IDs. A maximum of 20 subnets can be modified in a single request.
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `Description` field"
  var valid_606656 = formData.getOrDefault("Description")
  valid_606656 = validateParameter(valid_606656, JString, required = true,
                                 default = nil)
  if valid_606656 != nil:
    section.add "Description", valid_606656
  var valid_606657 = formData.getOrDefault("ClusterSubnetGroupName")
  valid_606657 = validateParameter(valid_606657, JString, required = true,
                                 default = nil)
  if valid_606657 != nil:
    section.add "ClusterSubnetGroupName", valid_606657
  var valid_606658 = formData.getOrDefault("Tags")
  valid_606658 = validateParameter(valid_606658, JArray, required = false,
                                 default = nil)
  if valid_606658 != nil:
    section.add "Tags", valid_606658
  var valid_606659 = formData.getOrDefault("SubnetIds")
  valid_606659 = validateParameter(valid_606659, JArray, required = true, default = nil)
  if valid_606659 != nil:
    section.add "SubnetIds", valid_606659
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_606660: Call_PostCreateClusterSubnetGroup_606644; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a new Amazon Redshift subnet group. You must provide a list of one or more subnets in your existing Amazon Virtual Private Cloud (Amazon VPC) when creating Amazon Redshift subnet group.</p> <p> For information about subnet groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-cluster-subnet-groups.html">Amazon Redshift Cluster Subnet Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_606660.validator(path, query, header, formData, body)
  let scheme = call_606660.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_606660.url(scheme.get, call_606660.host, call_606660.base,
                         call_606660.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_606660, url, valid)

proc call*(call_606661: Call_PostCreateClusterSubnetGroup_606644;
          Description: string; ClusterSubnetGroupName: string; SubnetIds: JsonNode;
          Action: string = "CreateClusterSubnetGroup"; Tags: JsonNode = nil;
          Version: string = "2012-12-01"): Recallable =
  ## postCreateClusterSubnetGroup
  ## <p>Creates a new Amazon Redshift subnet group. You must provide a list of one or more subnets in your existing Amazon Virtual Private Cloud (Amazon VPC) when creating Amazon Redshift subnet group.</p> <p> For information about subnet groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-cluster-subnet-groups.html">Amazon Redshift Cluster Subnet Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   Description: string (required)
  ##              : A description for the subnet group.
  ##   ClusterSubnetGroupName: string (required)
  ##                         : <p>The name for the subnet group. Amazon Redshift stores the value as a lowercase string.</p> <p>Constraints:</p> <ul> <li> <p>Must contain no more than 255 alphanumeric characters or hyphens.</p> </li> <li> <p>Must not be "Default".</p> </li> <li> <p>Must be unique for all subnet groups that are created by your AWS account.</p> </li> </ul> <p>Example: <code>examplesubnetgroup</code> </p>
  ##   Action: string (required)
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Version: string (required)
  ##   SubnetIds: JArray (required)
  ##            : An array of VPC subnet IDs. A maximum of 20 subnets can be modified in a single request.
  var query_606662 = newJObject()
  var formData_606663 = newJObject()
  add(formData_606663, "Description", newJString(Description))
  add(formData_606663, "ClusterSubnetGroupName",
      newJString(ClusterSubnetGroupName))
  add(query_606662, "Action", newJString(Action))
  if Tags != nil:
    formData_606663.add "Tags", Tags
  add(query_606662, "Version", newJString(Version))
  if SubnetIds != nil:
    formData_606663.add "SubnetIds", SubnetIds
  result = call_606661.call(nil, query_606662, nil, formData_606663, nil)

var postCreateClusterSubnetGroup* = Call_PostCreateClusterSubnetGroup_606644(
    name: "postCreateClusterSubnetGroup", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=CreateClusterSubnetGroup",
    validator: validate_PostCreateClusterSubnetGroup_606645, base: "/",
    url: url_PostCreateClusterSubnetGroup_606646,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCreateClusterSubnetGroup_606625 = ref object of OpenApiRestCall_605573
proc url_GetCreateClusterSubnetGroup_606627(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetCreateClusterSubnetGroup_606626(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a new Amazon Redshift subnet group. You must provide a list of one or more subnets in your existing Amazon Virtual Private Cloud (Amazon VPC) when creating Amazon Redshift subnet group.</p> <p> For information about subnet groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-cluster-subnet-groups.html">Amazon Redshift Cluster Subnet Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ClusterSubnetGroupName: JString (required)
  ##                         : <p>The name for the subnet group. Amazon Redshift stores the value as a lowercase string.</p> <p>Constraints:</p> <ul> <li> <p>Must contain no more than 255 alphanumeric characters or hyphens.</p> </li> <li> <p>Must not be "Default".</p> </li> <li> <p>Must be unique for all subnet groups that are created by your AWS account.</p> </li> </ul> <p>Example: <code>examplesubnetgroup</code> </p>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   SubnetIds: JArray (required)
  ##            : An array of VPC subnet IDs. A maximum of 20 subnets can be modified in a single request.
  ##   Action: JString (required)
  ##   Description: JString (required)
  ##              : A description for the subnet group.
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `ClusterSubnetGroupName` field"
  var valid_606628 = query.getOrDefault("ClusterSubnetGroupName")
  valid_606628 = validateParameter(valid_606628, JString, required = true,
                                 default = nil)
  if valid_606628 != nil:
    section.add "ClusterSubnetGroupName", valid_606628
  var valid_606629 = query.getOrDefault("Tags")
  valid_606629 = validateParameter(valid_606629, JArray, required = false,
                                 default = nil)
  if valid_606629 != nil:
    section.add "Tags", valid_606629
  var valid_606630 = query.getOrDefault("SubnetIds")
  valid_606630 = validateParameter(valid_606630, JArray, required = true, default = nil)
  if valid_606630 != nil:
    section.add "SubnetIds", valid_606630
  var valid_606631 = query.getOrDefault("Action")
  valid_606631 = validateParameter(valid_606631, JString, required = true, default = newJString(
      "CreateClusterSubnetGroup"))
  if valid_606631 != nil:
    section.add "Action", valid_606631
  var valid_606632 = query.getOrDefault("Description")
  valid_606632 = validateParameter(valid_606632, JString, required = true,
                                 default = nil)
  if valid_606632 != nil:
    section.add "Description", valid_606632
  var valid_606633 = query.getOrDefault("Version")
  valid_606633 = validateParameter(valid_606633, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_606633 != nil:
    section.add "Version", valid_606633
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_606634 = header.getOrDefault("X-Amz-Signature")
  valid_606634 = validateParameter(valid_606634, JString, required = false,
                                 default = nil)
  if valid_606634 != nil:
    section.add "X-Amz-Signature", valid_606634
  var valid_606635 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_606635 = validateParameter(valid_606635, JString, required = false,
                                 default = nil)
  if valid_606635 != nil:
    section.add "X-Amz-Content-Sha256", valid_606635
  var valid_606636 = header.getOrDefault("X-Amz-Date")
  valid_606636 = validateParameter(valid_606636, JString, required = false,
                                 default = nil)
  if valid_606636 != nil:
    section.add "X-Amz-Date", valid_606636
  var valid_606637 = header.getOrDefault("X-Amz-Credential")
  valid_606637 = validateParameter(valid_606637, JString, required = false,
                                 default = nil)
  if valid_606637 != nil:
    section.add "X-Amz-Credential", valid_606637
  var valid_606638 = header.getOrDefault("X-Amz-Security-Token")
  valid_606638 = validateParameter(valid_606638, JString, required = false,
                                 default = nil)
  if valid_606638 != nil:
    section.add "X-Amz-Security-Token", valid_606638
  var valid_606639 = header.getOrDefault("X-Amz-Algorithm")
  valid_606639 = validateParameter(valid_606639, JString, required = false,
                                 default = nil)
  if valid_606639 != nil:
    section.add "X-Amz-Algorithm", valid_606639
  var valid_606640 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_606640 = validateParameter(valid_606640, JString, required = false,
                                 default = nil)
  if valid_606640 != nil:
    section.add "X-Amz-SignedHeaders", valid_606640
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_606641: Call_GetCreateClusterSubnetGroup_606625; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a new Amazon Redshift subnet group. You must provide a list of one or more subnets in your existing Amazon Virtual Private Cloud (Amazon VPC) when creating Amazon Redshift subnet group.</p> <p> For information about subnet groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-cluster-subnet-groups.html">Amazon Redshift Cluster Subnet Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_606641.validator(path, query, header, formData, body)
  let scheme = call_606641.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_606641.url(scheme.get, call_606641.host, call_606641.base,
                         call_606641.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_606641, url, valid)

proc call*(call_606642: Call_GetCreateClusterSubnetGroup_606625;
          ClusterSubnetGroupName: string; SubnetIds: JsonNode; Description: string;
          Tags: JsonNode = nil; Action: string = "CreateClusterSubnetGroup";
          Version: string = "2012-12-01"): Recallable =
  ## getCreateClusterSubnetGroup
  ## <p>Creates a new Amazon Redshift subnet group. You must provide a list of one or more subnets in your existing Amazon Virtual Private Cloud (Amazon VPC) when creating Amazon Redshift subnet group.</p> <p> For information about subnet groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-cluster-subnet-groups.html">Amazon Redshift Cluster Subnet Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   ClusterSubnetGroupName: string (required)
  ##                         : <p>The name for the subnet group. Amazon Redshift stores the value as a lowercase string.</p> <p>Constraints:</p> <ul> <li> <p>Must contain no more than 255 alphanumeric characters or hyphens.</p> </li> <li> <p>Must not be "Default".</p> </li> <li> <p>Must be unique for all subnet groups that are created by your AWS account.</p> </li> </ul> <p>Example: <code>examplesubnetgroup</code> </p>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   SubnetIds: JArray (required)
  ##            : An array of VPC subnet IDs. A maximum of 20 subnets can be modified in a single request.
  ##   Action: string (required)
  ##   Description: string (required)
  ##              : A description for the subnet group.
  ##   Version: string (required)
  var query_606643 = newJObject()
  add(query_606643, "ClusterSubnetGroupName", newJString(ClusterSubnetGroupName))
  if Tags != nil:
    query_606643.add "Tags", Tags
  if SubnetIds != nil:
    query_606643.add "SubnetIds", SubnetIds
  add(query_606643, "Action", newJString(Action))
  add(query_606643, "Description", newJString(Description))
  add(query_606643, "Version", newJString(Version))
  result = call_606642.call(nil, query_606643, nil, nil, nil)

var getCreateClusterSubnetGroup* = Call_GetCreateClusterSubnetGroup_606625(
    name: "getCreateClusterSubnetGroup", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=CreateClusterSubnetGroup",
    validator: validate_GetCreateClusterSubnetGroup_606626, base: "/",
    url: url_GetCreateClusterSubnetGroup_606627,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCreateEventSubscription_606687 = ref object of OpenApiRestCall_605573
proc url_PostCreateEventSubscription_606689(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostCreateEventSubscription_606688(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates an Amazon Redshift event notification subscription. This action requires an ARN (Amazon Resource Name) of an Amazon SNS topic created by either the Amazon Redshift console, the Amazon SNS console, or the Amazon SNS API. To obtain an ARN with Amazon SNS, you must create a topic in Amazon SNS and subscribe to the topic. The ARN is displayed in the SNS console.</p> <p>You can specify the source type, and lists of Amazon Redshift source IDs, event categories, and event severities. Notifications will be sent for all events you want that match those criteria. For example, you can specify source type = cluster, source ID = my-cluster-1 and mycluster2, event categories = Availability, Backup, and severity = ERROR. The subscription will only send notifications for those ERROR events in the Availability and Backup categories for the specified clusters.</p> <p>If you specify both the source type and source IDs, such as source type = cluster and source identifier = my-cluster-1, notifications will be sent for all the cluster events for my-cluster-1. If you specify a source type but do not specify a source identifier, you will receive notice of the events for the objects of that type in your AWS account. If you do not specify either the SourceType nor the SourceIdentifier, you will be notified of events generated from all Amazon Redshift sources belonging to your AWS account. You must specify a source type if you specify a source ID.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_606690 = query.getOrDefault("Action")
  valid_606690 = validateParameter(valid_606690, JString, required = true, default = newJString(
      "CreateEventSubscription"))
  if valid_606690 != nil:
    section.add "Action", valid_606690
  var valid_606691 = query.getOrDefault("Version")
  valid_606691 = validateParameter(valid_606691, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_606691 != nil:
    section.add "Version", valid_606691
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_606692 = header.getOrDefault("X-Amz-Signature")
  valid_606692 = validateParameter(valid_606692, JString, required = false,
                                 default = nil)
  if valid_606692 != nil:
    section.add "X-Amz-Signature", valid_606692
  var valid_606693 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_606693 = validateParameter(valid_606693, JString, required = false,
                                 default = nil)
  if valid_606693 != nil:
    section.add "X-Amz-Content-Sha256", valid_606693
  var valid_606694 = header.getOrDefault("X-Amz-Date")
  valid_606694 = validateParameter(valid_606694, JString, required = false,
                                 default = nil)
  if valid_606694 != nil:
    section.add "X-Amz-Date", valid_606694
  var valid_606695 = header.getOrDefault("X-Amz-Credential")
  valid_606695 = validateParameter(valid_606695, JString, required = false,
                                 default = nil)
  if valid_606695 != nil:
    section.add "X-Amz-Credential", valid_606695
  var valid_606696 = header.getOrDefault("X-Amz-Security-Token")
  valid_606696 = validateParameter(valid_606696, JString, required = false,
                                 default = nil)
  if valid_606696 != nil:
    section.add "X-Amz-Security-Token", valid_606696
  var valid_606697 = header.getOrDefault("X-Amz-Algorithm")
  valid_606697 = validateParameter(valid_606697, JString, required = false,
                                 default = nil)
  if valid_606697 != nil:
    section.add "X-Amz-Algorithm", valid_606697
  var valid_606698 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_606698 = validateParameter(valid_606698, JString, required = false,
                                 default = nil)
  if valid_606698 != nil:
    section.add "X-Amz-SignedHeaders", valid_606698
  result.add "header", section
  ## parameters in `formData` object:
  ##   SourceIds: JArray
  ##            : <p>A list of one or more identifiers of Amazon Redshift source objects. All of the objects must be of the same type as was specified in the source type parameter. The event subscription will return only events generated by the specified objects. If not specified, then events are returned for all objects within the source type specified.</p> <p>Example: my-cluster-1, my-cluster-2</p> <p>Example: my-snapshot-20131010</p>
  ##   SnsTopicArn: JString (required)
  ##              : The Amazon Resource Name (ARN) of the Amazon SNS topic used to transmit the event notifications. The ARN is created by Amazon SNS when you create a topic and subscribe to it.
  ##   Enabled: JBool
  ##          : A boolean value; set to <code>true</code> to activate the subscription, and set to <code>false</code> to create the subscription but not activate it. 
  ##   SubscriptionName: JString (required)
  ##                   : <p>The name of the event subscription to be created.</p> <p>Constraints:</p> <ul> <li> <p>Cannot be null, empty, or blank.</p> </li> <li> <p>Must contain from 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   SourceType: JString
  ##             : <p>The type of source that will be generating the events. For example, if you want to be notified of events generated by a cluster, you would set this parameter to cluster. If this value is not specified, events are returned for all Amazon Redshift objects in your AWS account. You must specify a source type in order to specify source IDs.</p> <p>Valid values: cluster, cluster-parameter-group, cluster-security-group, cluster-snapshot, and scheduled-action.</p>
  ##   Severity: JString
  ##           : <p>Specifies the Amazon Redshift event severity to be published by the event notification subscription.</p> <p>Values: ERROR, INFO</p>
  ##   EventCategories: JArray
  ##                  : <p>Specifies the Amazon Redshift event categories to be published by the event notification subscription.</p> <p>Values: configuration, management, monitoring, security</p>
  ##   Tags: JArray
  ##       : A list of tag instances.
  section = newJObject()
  var valid_606699 = formData.getOrDefault("SourceIds")
  valid_606699 = validateParameter(valid_606699, JArray, required = false,
                                 default = nil)
  if valid_606699 != nil:
    section.add "SourceIds", valid_606699
  assert formData != nil,
        "formData argument is necessary due to required `SnsTopicArn` field"
  var valid_606700 = formData.getOrDefault("SnsTopicArn")
  valid_606700 = validateParameter(valid_606700, JString, required = true,
                                 default = nil)
  if valid_606700 != nil:
    section.add "SnsTopicArn", valid_606700
  var valid_606701 = formData.getOrDefault("Enabled")
  valid_606701 = validateParameter(valid_606701, JBool, required = false, default = nil)
  if valid_606701 != nil:
    section.add "Enabled", valid_606701
  var valid_606702 = formData.getOrDefault("SubscriptionName")
  valid_606702 = validateParameter(valid_606702, JString, required = true,
                                 default = nil)
  if valid_606702 != nil:
    section.add "SubscriptionName", valid_606702
  var valid_606703 = formData.getOrDefault("SourceType")
  valid_606703 = validateParameter(valid_606703, JString, required = false,
                                 default = nil)
  if valid_606703 != nil:
    section.add "SourceType", valid_606703
  var valid_606704 = formData.getOrDefault("Severity")
  valid_606704 = validateParameter(valid_606704, JString, required = false,
                                 default = nil)
  if valid_606704 != nil:
    section.add "Severity", valid_606704
  var valid_606705 = formData.getOrDefault("EventCategories")
  valid_606705 = validateParameter(valid_606705, JArray, required = false,
                                 default = nil)
  if valid_606705 != nil:
    section.add "EventCategories", valid_606705
  var valid_606706 = formData.getOrDefault("Tags")
  valid_606706 = validateParameter(valid_606706, JArray, required = false,
                                 default = nil)
  if valid_606706 != nil:
    section.add "Tags", valid_606706
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_606707: Call_PostCreateEventSubscription_606687; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates an Amazon Redshift event notification subscription. This action requires an ARN (Amazon Resource Name) of an Amazon SNS topic created by either the Amazon Redshift console, the Amazon SNS console, or the Amazon SNS API. To obtain an ARN with Amazon SNS, you must create a topic in Amazon SNS and subscribe to the topic. The ARN is displayed in the SNS console.</p> <p>You can specify the source type, and lists of Amazon Redshift source IDs, event categories, and event severities. Notifications will be sent for all events you want that match those criteria. For example, you can specify source type = cluster, source ID = my-cluster-1 and mycluster2, event categories = Availability, Backup, and severity = ERROR. The subscription will only send notifications for those ERROR events in the Availability and Backup categories for the specified clusters.</p> <p>If you specify both the source type and source IDs, such as source type = cluster and source identifier = my-cluster-1, notifications will be sent for all the cluster events for my-cluster-1. If you specify a source type but do not specify a source identifier, you will receive notice of the events for the objects of that type in your AWS account. If you do not specify either the SourceType nor the SourceIdentifier, you will be notified of events generated from all Amazon Redshift sources belonging to your AWS account. You must specify a source type if you specify a source ID.</p>
  ## 
  let valid = call_606707.validator(path, query, header, formData, body)
  let scheme = call_606707.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_606707.url(scheme.get, call_606707.host, call_606707.base,
                         call_606707.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_606707, url, valid)

proc call*(call_606708: Call_PostCreateEventSubscription_606687;
          SnsTopicArn: string; SubscriptionName: string; SourceIds: JsonNode = nil;
          Enabled: bool = false; SourceType: string = ""; Severity: string = "";
          EventCategories: JsonNode = nil;
          Action: string = "CreateEventSubscription"; Tags: JsonNode = nil;
          Version: string = "2012-12-01"): Recallable =
  ## postCreateEventSubscription
  ## <p>Creates an Amazon Redshift event notification subscription. This action requires an ARN (Amazon Resource Name) of an Amazon SNS topic created by either the Amazon Redshift console, the Amazon SNS console, or the Amazon SNS API. To obtain an ARN with Amazon SNS, you must create a topic in Amazon SNS and subscribe to the topic. The ARN is displayed in the SNS console.</p> <p>You can specify the source type, and lists of Amazon Redshift source IDs, event categories, and event severities. Notifications will be sent for all events you want that match those criteria. For example, you can specify source type = cluster, source ID = my-cluster-1 and mycluster2, event categories = Availability, Backup, and severity = ERROR. The subscription will only send notifications for those ERROR events in the Availability and Backup categories for the specified clusters.</p> <p>If you specify both the source type and source IDs, such as source type = cluster and source identifier = my-cluster-1, notifications will be sent for all the cluster events for my-cluster-1. If you specify a source type but do not specify a source identifier, you will receive notice of the events for the objects of that type in your AWS account. If you do not specify either the SourceType nor the SourceIdentifier, you will be notified of events generated from all Amazon Redshift sources belonging to your AWS account. You must specify a source type if you specify a source ID.</p>
  ##   SourceIds: JArray
  ##            : <p>A list of one or more identifiers of Amazon Redshift source objects. All of the objects must be of the same type as was specified in the source type parameter. The event subscription will return only events generated by the specified objects. If not specified, then events are returned for all objects within the source type specified.</p> <p>Example: my-cluster-1, my-cluster-2</p> <p>Example: my-snapshot-20131010</p>
  ##   SnsTopicArn: string (required)
  ##              : The Amazon Resource Name (ARN) of the Amazon SNS topic used to transmit the event notifications. The ARN is created by Amazon SNS when you create a topic and subscribe to it.
  ##   Enabled: bool
  ##          : A boolean value; set to <code>true</code> to activate the subscription, and set to <code>false</code> to create the subscription but not activate it. 
  ##   SubscriptionName: string (required)
  ##                   : <p>The name of the event subscription to be created.</p> <p>Constraints:</p> <ul> <li> <p>Cannot be null, empty, or blank.</p> </li> <li> <p>Must contain from 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   SourceType: string
  ##             : <p>The type of source that will be generating the events. For example, if you want to be notified of events generated by a cluster, you would set this parameter to cluster. If this value is not specified, events are returned for all Amazon Redshift objects in your AWS account. You must specify a source type in order to specify source IDs.</p> <p>Valid values: cluster, cluster-parameter-group, cluster-security-group, cluster-snapshot, and scheduled-action.</p>
  ##   Severity: string
  ##           : <p>Specifies the Amazon Redshift event severity to be published by the event notification subscription.</p> <p>Values: ERROR, INFO</p>
  ##   EventCategories: JArray
  ##                  : <p>Specifies the Amazon Redshift event categories to be published by the event notification subscription.</p> <p>Values: configuration, management, monitoring, security</p>
  ##   Action: string (required)
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Version: string (required)
  var query_606709 = newJObject()
  var formData_606710 = newJObject()
  if SourceIds != nil:
    formData_606710.add "SourceIds", SourceIds
  add(formData_606710, "SnsTopicArn", newJString(SnsTopicArn))
  add(formData_606710, "Enabled", newJBool(Enabled))
  add(formData_606710, "SubscriptionName", newJString(SubscriptionName))
  add(formData_606710, "SourceType", newJString(SourceType))
  add(formData_606710, "Severity", newJString(Severity))
  if EventCategories != nil:
    formData_606710.add "EventCategories", EventCategories
  add(query_606709, "Action", newJString(Action))
  if Tags != nil:
    formData_606710.add "Tags", Tags
  add(query_606709, "Version", newJString(Version))
  result = call_606708.call(nil, query_606709, nil, formData_606710, nil)

var postCreateEventSubscription* = Call_PostCreateEventSubscription_606687(
    name: "postCreateEventSubscription", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=CreateEventSubscription",
    validator: validate_PostCreateEventSubscription_606688, base: "/",
    url: url_PostCreateEventSubscription_606689,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCreateEventSubscription_606664 = ref object of OpenApiRestCall_605573
proc url_GetCreateEventSubscription_606666(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetCreateEventSubscription_606665(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates an Amazon Redshift event notification subscription. This action requires an ARN (Amazon Resource Name) of an Amazon SNS topic created by either the Amazon Redshift console, the Amazon SNS console, or the Amazon SNS API. To obtain an ARN with Amazon SNS, you must create a topic in Amazon SNS and subscribe to the topic. The ARN is displayed in the SNS console.</p> <p>You can specify the source type, and lists of Amazon Redshift source IDs, event categories, and event severities. Notifications will be sent for all events you want that match those criteria. For example, you can specify source type = cluster, source ID = my-cluster-1 and mycluster2, event categories = Availability, Backup, and severity = ERROR. The subscription will only send notifications for those ERROR events in the Availability and Backup categories for the specified clusters.</p> <p>If you specify both the source type and source IDs, such as source type = cluster and source identifier = my-cluster-1, notifications will be sent for all the cluster events for my-cluster-1. If you specify a source type but do not specify a source identifier, you will receive notice of the events for the objects of that type in your AWS account. If you do not specify either the SourceType nor the SourceIdentifier, you will be notified of events generated from all Amazon Redshift sources belonging to your AWS account. You must specify a source type if you specify a source ID.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   SourceType: JString
  ##             : <p>The type of source that will be generating the events. For example, if you want to be notified of events generated by a cluster, you would set this parameter to cluster. If this value is not specified, events are returned for all Amazon Redshift objects in your AWS account. You must specify a source type in order to specify source IDs.</p> <p>Valid values: cluster, cluster-parameter-group, cluster-security-group, cluster-snapshot, and scheduled-action.</p>
  ##   Enabled: JBool
  ##          : A boolean value; set to <code>true</code> to activate the subscription, and set to <code>false</code> to create the subscription but not activate it. 
  ##   Severity: JString
  ##           : <p>Specifies the Amazon Redshift event severity to be published by the event notification subscription.</p> <p>Values: ERROR, INFO</p>
  ##   SubscriptionName: JString (required)
  ##                   : <p>The name of the event subscription to be created.</p> <p>Constraints:</p> <ul> <li> <p>Cannot be null, empty, or blank.</p> </li> <li> <p>Must contain from 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   EventCategories: JArray
  ##                  : <p>Specifies the Amazon Redshift event categories to be published by the event notification subscription.</p> <p>Values: configuration, management, monitoring, security</p>
  ##   SourceIds: JArray
  ##            : <p>A list of one or more identifiers of Amazon Redshift source objects. All of the objects must be of the same type as was specified in the source type parameter. The event subscription will return only events generated by the specified objects. If not specified, then events are returned for all objects within the source type specified.</p> <p>Example: my-cluster-1, my-cluster-2</p> <p>Example: my-snapshot-20131010</p>
  ##   Action: JString (required)
  ##   SnsTopicArn: JString (required)
  ##              : The Amazon Resource Name (ARN) of the Amazon SNS topic used to transmit the event notifications. The ARN is created by Amazon SNS when you create a topic and subscribe to it.
  ##   Version: JString (required)
  section = newJObject()
  var valid_606667 = query.getOrDefault("Tags")
  valid_606667 = validateParameter(valid_606667, JArray, required = false,
                                 default = nil)
  if valid_606667 != nil:
    section.add "Tags", valid_606667
  var valid_606668 = query.getOrDefault("SourceType")
  valid_606668 = validateParameter(valid_606668, JString, required = false,
                                 default = nil)
  if valid_606668 != nil:
    section.add "SourceType", valid_606668
  var valid_606669 = query.getOrDefault("Enabled")
  valid_606669 = validateParameter(valid_606669, JBool, required = false, default = nil)
  if valid_606669 != nil:
    section.add "Enabled", valid_606669
  var valid_606670 = query.getOrDefault("Severity")
  valid_606670 = validateParameter(valid_606670, JString, required = false,
                                 default = nil)
  if valid_606670 != nil:
    section.add "Severity", valid_606670
  assert query != nil,
        "query argument is necessary due to required `SubscriptionName` field"
  var valid_606671 = query.getOrDefault("SubscriptionName")
  valid_606671 = validateParameter(valid_606671, JString, required = true,
                                 default = nil)
  if valid_606671 != nil:
    section.add "SubscriptionName", valid_606671
  var valid_606672 = query.getOrDefault("EventCategories")
  valid_606672 = validateParameter(valid_606672, JArray, required = false,
                                 default = nil)
  if valid_606672 != nil:
    section.add "EventCategories", valid_606672
  var valid_606673 = query.getOrDefault("SourceIds")
  valid_606673 = validateParameter(valid_606673, JArray, required = false,
                                 default = nil)
  if valid_606673 != nil:
    section.add "SourceIds", valid_606673
  var valid_606674 = query.getOrDefault("Action")
  valid_606674 = validateParameter(valid_606674, JString, required = true, default = newJString(
      "CreateEventSubscription"))
  if valid_606674 != nil:
    section.add "Action", valid_606674
  var valid_606675 = query.getOrDefault("SnsTopicArn")
  valid_606675 = validateParameter(valid_606675, JString, required = true,
                                 default = nil)
  if valid_606675 != nil:
    section.add "SnsTopicArn", valid_606675
  var valid_606676 = query.getOrDefault("Version")
  valid_606676 = validateParameter(valid_606676, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_606676 != nil:
    section.add "Version", valid_606676
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_606677 = header.getOrDefault("X-Amz-Signature")
  valid_606677 = validateParameter(valid_606677, JString, required = false,
                                 default = nil)
  if valid_606677 != nil:
    section.add "X-Amz-Signature", valid_606677
  var valid_606678 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_606678 = validateParameter(valid_606678, JString, required = false,
                                 default = nil)
  if valid_606678 != nil:
    section.add "X-Amz-Content-Sha256", valid_606678
  var valid_606679 = header.getOrDefault("X-Amz-Date")
  valid_606679 = validateParameter(valid_606679, JString, required = false,
                                 default = nil)
  if valid_606679 != nil:
    section.add "X-Amz-Date", valid_606679
  var valid_606680 = header.getOrDefault("X-Amz-Credential")
  valid_606680 = validateParameter(valid_606680, JString, required = false,
                                 default = nil)
  if valid_606680 != nil:
    section.add "X-Amz-Credential", valid_606680
  var valid_606681 = header.getOrDefault("X-Amz-Security-Token")
  valid_606681 = validateParameter(valid_606681, JString, required = false,
                                 default = nil)
  if valid_606681 != nil:
    section.add "X-Amz-Security-Token", valid_606681
  var valid_606682 = header.getOrDefault("X-Amz-Algorithm")
  valid_606682 = validateParameter(valid_606682, JString, required = false,
                                 default = nil)
  if valid_606682 != nil:
    section.add "X-Amz-Algorithm", valid_606682
  var valid_606683 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_606683 = validateParameter(valid_606683, JString, required = false,
                                 default = nil)
  if valid_606683 != nil:
    section.add "X-Amz-SignedHeaders", valid_606683
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_606684: Call_GetCreateEventSubscription_606664; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates an Amazon Redshift event notification subscription. This action requires an ARN (Amazon Resource Name) of an Amazon SNS topic created by either the Amazon Redshift console, the Amazon SNS console, or the Amazon SNS API. To obtain an ARN with Amazon SNS, you must create a topic in Amazon SNS and subscribe to the topic. The ARN is displayed in the SNS console.</p> <p>You can specify the source type, and lists of Amazon Redshift source IDs, event categories, and event severities. Notifications will be sent for all events you want that match those criteria. For example, you can specify source type = cluster, source ID = my-cluster-1 and mycluster2, event categories = Availability, Backup, and severity = ERROR. The subscription will only send notifications for those ERROR events in the Availability and Backup categories for the specified clusters.</p> <p>If you specify both the source type and source IDs, such as source type = cluster and source identifier = my-cluster-1, notifications will be sent for all the cluster events for my-cluster-1. If you specify a source type but do not specify a source identifier, you will receive notice of the events for the objects of that type in your AWS account. If you do not specify either the SourceType nor the SourceIdentifier, you will be notified of events generated from all Amazon Redshift sources belonging to your AWS account. You must specify a source type if you specify a source ID.</p>
  ## 
  let valid = call_606684.validator(path, query, header, formData, body)
  let scheme = call_606684.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_606684.url(scheme.get, call_606684.host, call_606684.base,
                         call_606684.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_606684, url, valid)

proc call*(call_606685: Call_GetCreateEventSubscription_606664;
          SubscriptionName: string; SnsTopicArn: string; Tags: JsonNode = nil;
          SourceType: string = ""; Enabled: bool = false; Severity: string = "";
          EventCategories: JsonNode = nil; SourceIds: JsonNode = nil;
          Action: string = "CreateEventSubscription"; Version: string = "2012-12-01"): Recallable =
  ## getCreateEventSubscription
  ## <p>Creates an Amazon Redshift event notification subscription. This action requires an ARN (Amazon Resource Name) of an Amazon SNS topic created by either the Amazon Redshift console, the Amazon SNS console, or the Amazon SNS API. To obtain an ARN with Amazon SNS, you must create a topic in Amazon SNS and subscribe to the topic. The ARN is displayed in the SNS console.</p> <p>You can specify the source type, and lists of Amazon Redshift source IDs, event categories, and event severities. Notifications will be sent for all events you want that match those criteria. For example, you can specify source type = cluster, source ID = my-cluster-1 and mycluster2, event categories = Availability, Backup, and severity = ERROR. The subscription will only send notifications for those ERROR events in the Availability and Backup categories for the specified clusters.</p> <p>If you specify both the source type and source IDs, such as source type = cluster and source identifier = my-cluster-1, notifications will be sent for all the cluster events for my-cluster-1. If you specify a source type but do not specify a source identifier, you will receive notice of the events for the objects of that type in your AWS account. If you do not specify either the SourceType nor the SourceIdentifier, you will be notified of events generated from all Amazon Redshift sources belonging to your AWS account. You must specify a source type if you specify a source ID.</p>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   SourceType: string
  ##             : <p>The type of source that will be generating the events. For example, if you want to be notified of events generated by a cluster, you would set this parameter to cluster. If this value is not specified, events are returned for all Amazon Redshift objects in your AWS account. You must specify a source type in order to specify source IDs.</p> <p>Valid values: cluster, cluster-parameter-group, cluster-security-group, cluster-snapshot, and scheduled-action.</p>
  ##   Enabled: bool
  ##          : A boolean value; set to <code>true</code> to activate the subscription, and set to <code>false</code> to create the subscription but not activate it. 
  ##   Severity: string
  ##           : <p>Specifies the Amazon Redshift event severity to be published by the event notification subscription.</p> <p>Values: ERROR, INFO</p>
  ##   SubscriptionName: string (required)
  ##                   : <p>The name of the event subscription to be created.</p> <p>Constraints:</p> <ul> <li> <p>Cannot be null, empty, or blank.</p> </li> <li> <p>Must contain from 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   EventCategories: JArray
  ##                  : <p>Specifies the Amazon Redshift event categories to be published by the event notification subscription.</p> <p>Values: configuration, management, monitoring, security</p>
  ##   SourceIds: JArray
  ##            : <p>A list of one or more identifiers of Amazon Redshift source objects. All of the objects must be of the same type as was specified in the source type parameter. The event subscription will return only events generated by the specified objects. If not specified, then events are returned for all objects within the source type specified.</p> <p>Example: my-cluster-1, my-cluster-2</p> <p>Example: my-snapshot-20131010</p>
  ##   Action: string (required)
  ##   SnsTopicArn: string (required)
  ##              : The Amazon Resource Name (ARN) of the Amazon SNS topic used to transmit the event notifications. The ARN is created by Amazon SNS when you create a topic and subscribe to it.
  ##   Version: string (required)
  var query_606686 = newJObject()
  if Tags != nil:
    query_606686.add "Tags", Tags
  add(query_606686, "SourceType", newJString(SourceType))
  add(query_606686, "Enabled", newJBool(Enabled))
  add(query_606686, "Severity", newJString(Severity))
  add(query_606686, "SubscriptionName", newJString(SubscriptionName))
  if EventCategories != nil:
    query_606686.add "EventCategories", EventCategories
  if SourceIds != nil:
    query_606686.add "SourceIds", SourceIds
  add(query_606686, "Action", newJString(Action))
  add(query_606686, "SnsTopicArn", newJString(SnsTopicArn))
  add(query_606686, "Version", newJString(Version))
  result = call_606685.call(nil, query_606686, nil, nil, nil)

var getCreateEventSubscription* = Call_GetCreateEventSubscription_606664(
    name: "getCreateEventSubscription", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=CreateEventSubscription",
    validator: validate_GetCreateEventSubscription_606665, base: "/",
    url: url_GetCreateEventSubscription_606666,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCreateHsmClientCertificate_606728 = ref object of OpenApiRestCall_605573
proc url_PostCreateHsmClientCertificate_606730(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostCreateHsmClientCertificate_606729(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates an HSM client certificate that an Amazon Redshift cluster will use to connect to the client's HSM in order to store and retrieve the keys used to encrypt the cluster databases.</p> <p>The command returns a public key, which you must store in the HSM. In addition to creating the HSM certificate, you must create an Amazon Redshift HSM configuration that provides a cluster the information needed to store and use encryption keys in the HSM. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a> in the Amazon Redshift Cluster Management Guide.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_606731 = query.getOrDefault("Action")
  valid_606731 = validateParameter(valid_606731, JString, required = true, default = newJString(
      "CreateHsmClientCertificate"))
  if valid_606731 != nil:
    section.add "Action", valid_606731
  var valid_606732 = query.getOrDefault("Version")
  valid_606732 = validateParameter(valid_606732, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_606732 != nil:
    section.add "Version", valid_606732
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_606733 = header.getOrDefault("X-Amz-Signature")
  valid_606733 = validateParameter(valid_606733, JString, required = false,
                                 default = nil)
  if valid_606733 != nil:
    section.add "X-Amz-Signature", valid_606733
  var valid_606734 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_606734 = validateParameter(valid_606734, JString, required = false,
                                 default = nil)
  if valid_606734 != nil:
    section.add "X-Amz-Content-Sha256", valid_606734
  var valid_606735 = header.getOrDefault("X-Amz-Date")
  valid_606735 = validateParameter(valid_606735, JString, required = false,
                                 default = nil)
  if valid_606735 != nil:
    section.add "X-Amz-Date", valid_606735
  var valid_606736 = header.getOrDefault("X-Amz-Credential")
  valid_606736 = validateParameter(valid_606736, JString, required = false,
                                 default = nil)
  if valid_606736 != nil:
    section.add "X-Amz-Credential", valid_606736
  var valid_606737 = header.getOrDefault("X-Amz-Security-Token")
  valid_606737 = validateParameter(valid_606737, JString, required = false,
                                 default = nil)
  if valid_606737 != nil:
    section.add "X-Amz-Security-Token", valid_606737
  var valid_606738 = header.getOrDefault("X-Amz-Algorithm")
  valid_606738 = validateParameter(valid_606738, JString, required = false,
                                 default = nil)
  if valid_606738 != nil:
    section.add "X-Amz-Algorithm", valid_606738
  var valid_606739 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_606739 = validateParameter(valid_606739, JString, required = false,
                                 default = nil)
  if valid_606739 != nil:
    section.add "X-Amz-SignedHeaders", valid_606739
  result.add "header", section
  ## parameters in `formData` object:
  ##   HsmClientCertificateIdentifier: JString (required)
  ##                                 : The identifier to be assigned to the new HSM client certificate that the cluster will use to connect to the HSM to use the database encryption keys.
  ##   Tags: JArray
  ##       : A list of tag instances.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `HsmClientCertificateIdentifier` field"
  var valid_606740 = formData.getOrDefault("HsmClientCertificateIdentifier")
  valid_606740 = validateParameter(valid_606740, JString, required = true,
                                 default = nil)
  if valid_606740 != nil:
    section.add "HsmClientCertificateIdentifier", valid_606740
  var valid_606741 = formData.getOrDefault("Tags")
  valid_606741 = validateParameter(valid_606741, JArray, required = false,
                                 default = nil)
  if valid_606741 != nil:
    section.add "Tags", valid_606741
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_606742: Call_PostCreateHsmClientCertificate_606728; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates an HSM client certificate that an Amazon Redshift cluster will use to connect to the client's HSM in order to store and retrieve the keys used to encrypt the cluster databases.</p> <p>The command returns a public key, which you must store in the HSM. In addition to creating the HSM certificate, you must create an Amazon Redshift HSM configuration that provides a cluster the information needed to store and use encryption keys in the HSM. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a> in the Amazon Redshift Cluster Management Guide.</p>
  ## 
  let valid = call_606742.validator(path, query, header, formData, body)
  let scheme = call_606742.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_606742.url(scheme.get, call_606742.host, call_606742.base,
                         call_606742.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_606742, url, valid)

proc call*(call_606743: Call_PostCreateHsmClientCertificate_606728;
          HsmClientCertificateIdentifier: string;
          Action: string = "CreateHsmClientCertificate"; Tags: JsonNode = nil;
          Version: string = "2012-12-01"): Recallable =
  ## postCreateHsmClientCertificate
  ## <p>Creates an HSM client certificate that an Amazon Redshift cluster will use to connect to the client's HSM in order to store and retrieve the keys used to encrypt the cluster databases.</p> <p>The command returns a public key, which you must store in the HSM. In addition to creating the HSM certificate, you must create an Amazon Redshift HSM configuration that provides a cluster the information needed to store and use encryption keys in the HSM. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a> in the Amazon Redshift Cluster Management Guide.</p>
  ##   Action: string (required)
  ##   HsmClientCertificateIdentifier: string (required)
  ##                                 : The identifier to be assigned to the new HSM client certificate that the cluster will use to connect to the HSM to use the database encryption keys.
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Version: string (required)
  var query_606744 = newJObject()
  var formData_606745 = newJObject()
  add(query_606744, "Action", newJString(Action))
  add(formData_606745, "HsmClientCertificateIdentifier",
      newJString(HsmClientCertificateIdentifier))
  if Tags != nil:
    formData_606745.add "Tags", Tags
  add(query_606744, "Version", newJString(Version))
  result = call_606743.call(nil, query_606744, nil, formData_606745, nil)

var postCreateHsmClientCertificate* = Call_PostCreateHsmClientCertificate_606728(
    name: "postCreateHsmClientCertificate", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=CreateHsmClientCertificate",
    validator: validate_PostCreateHsmClientCertificate_606729, base: "/",
    url: url_PostCreateHsmClientCertificate_606730,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCreateHsmClientCertificate_606711 = ref object of OpenApiRestCall_605573
proc url_GetCreateHsmClientCertificate_606713(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetCreateHsmClientCertificate_606712(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates an HSM client certificate that an Amazon Redshift cluster will use to connect to the client's HSM in order to store and retrieve the keys used to encrypt the cluster databases.</p> <p>The command returns a public key, which you must store in the HSM. In addition to creating the HSM certificate, you must create an Amazon Redshift HSM configuration that provides a cluster the information needed to store and use encryption keys in the HSM. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a> in the Amazon Redshift Cluster Management Guide.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   HsmClientCertificateIdentifier: JString (required)
  ##                                 : The identifier to be assigned to the new HSM client certificate that the cluster will use to connect to the HSM to use the database encryption keys.
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `HsmClientCertificateIdentifier` field"
  var valid_606714 = query.getOrDefault("HsmClientCertificateIdentifier")
  valid_606714 = validateParameter(valid_606714, JString, required = true,
                                 default = nil)
  if valid_606714 != nil:
    section.add "HsmClientCertificateIdentifier", valid_606714
  var valid_606715 = query.getOrDefault("Tags")
  valid_606715 = validateParameter(valid_606715, JArray, required = false,
                                 default = nil)
  if valid_606715 != nil:
    section.add "Tags", valid_606715
  var valid_606716 = query.getOrDefault("Action")
  valid_606716 = validateParameter(valid_606716, JString, required = true, default = newJString(
      "CreateHsmClientCertificate"))
  if valid_606716 != nil:
    section.add "Action", valid_606716
  var valid_606717 = query.getOrDefault("Version")
  valid_606717 = validateParameter(valid_606717, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_606717 != nil:
    section.add "Version", valid_606717
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_606718 = header.getOrDefault("X-Amz-Signature")
  valid_606718 = validateParameter(valid_606718, JString, required = false,
                                 default = nil)
  if valid_606718 != nil:
    section.add "X-Amz-Signature", valid_606718
  var valid_606719 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_606719 = validateParameter(valid_606719, JString, required = false,
                                 default = nil)
  if valid_606719 != nil:
    section.add "X-Amz-Content-Sha256", valid_606719
  var valid_606720 = header.getOrDefault("X-Amz-Date")
  valid_606720 = validateParameter(valid_606720, JString, required = false,
                                 default = nil)
  if valid_606720 != nil:
    section.add "X-Amz-Date", valid_606720
  var valid_606721 = header.getOrDefault("X-Amz-Credential")
  valid_606721 = validateParameter(valid_606721, JString, required = false,
                                 default = nil)
  if valid_606721 != nil:
    section.add "X-Amz-Credential", valid_606721
  var valid_606722 = header.getOrDefault("X-Amz-Security-Token")
  valid_606722 = validateParameter(valid_606722, JString, required = false,
                                 default = nil)
  if valid_606722 != nil:
    section.add "X-Amz-Security-Token", valid_606722
  var valid_606723 = header.getOrDefault("X-Amz-Algorithm")
  valid_606723 = validateParameter(valid_606723, JString, required = false,
                                 default = nil)
  if valid_606723 != nil:
    section.add "X-Amz-Algorithm", valid_606723
  var valid_606724 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_606724 = validateParameter(valid_606724, JString, required = false,
                                 default = nil)
  if valid_606724 != nil:
    section.add "X-Amz-SignedHeaders", valid_606724
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_606725: Call_GetCreateHsmClientCertificate_606711; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates an HSM client certificate that an Amazon Redshift cluster will use to connect to the client's HSM in order to store and retrieve the keys used to encrypt the cluster databases.</p> <p>The command returns a public key, which you must store in the HSM. In addition to creating the HSM certificate, you must create an Amazon Redshift HSM configuration that provides a cluster the information needed to store and use encryption keys in the HSM. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a> in the Amazon Redshift Cluster Management Guide.</p>
  ## 
  let valid = call_606725.validator(path, query, header, formData, body)
  let scheme = call_606725.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_606725.url(scheme.get, call_606725.host, call_606725.base,
                         call_606725.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_606725, url, valid)

proc call*(call_606726: Call_GetCreateHsmClientCertificate_606711;
          HsmClientCertificateIdentifier: string; Tags: JsonNode = nil;
          Action: string = "CreateHsmClientCertificate";
          Version: string = "2012-12-01"): Recallable =
  ## getCreateHsmClientCertificate
  ## <p>Creates an HSM client certificate that an Amazon Redshift cluster will use to connect to the client's HSM in order to store and retrieve the keys used to encrypt the cluster databases.</p> <p>The command returns a public key, which you must store in the HSM. In addition to creating the HSM certificate, you must create an Amazon Redshift HSM configuration that provides a cluster the information needed to store and use encryption keys in the HSM. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a> in the Amazon Redshift Cluster Management Guide.</p>
  ##   HsmClientCertificateIdentifier: string (required)
  ##                                 : The identifier to be assigned to the new HSM client certificate that the cluster will use to connect to the HSM to use the database encryption keys.
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_606727 = newJObject()
  add(query_606727, "HsmClientCertificateIdentifier",
      newJString(HsmClientCertificateIdentifier))
  if Tags != nil:
    query_606727.add "Tags", Tags
  add(query_606727, "Action", newJString(Action))
  add(query_606727, "Version", newJString(Version))
  result = call_606726.call(nil, query_606727, nil, nil, nil)

var getCreateHsmClientCertificate* = Call_GetCreateHsmClientCertificate_606711(
    name: "getCreateHsmClientCertificate", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=CreateHsmClientCertificate",
    validator: validate_GetCreateHsmClientCertificate_606712, base: "/",
    url: url_GetCreateHsmClientCertificate_606713,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCreateHsmConfiguration_606768 = ref object of OpenApiRestCall_605573
proc url_PostCreateHsmConfiguration_606770(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostCreateHsmConfiguration_606769(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates an HSM configuration that contains the information required by an Amazon Redshift cluster to store and use database encryption keys in a Hardware Security Module (HSM). After creating the HSM configuration, you can specify it as a parameter when creating a cluster. The cluster will then store its encryption keys in the HSM.</p> <p>In addition to creating an HSM configuration, you must also create an HSM client certificate. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a> in the Amazon Redshift Cluster Management Guide.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_606771 = query.getOrDefault("Action")
  valid_606771 = validateParameter(valid_606771, JString, required = true,
                                 default = newJString("CreateHsmConfiguration"))
  if valid_606771 != nil:
    section.add "Action", valid_606771
  var valid_606772 = query.getOrDefault("Version")
  valid_606772 = validateParameter(valid_606772, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_606772 != nil:
    section.add "Version", valid_606772
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_606773 = header.getOrDefault("X-Amz-Signature")
  valid_606773 = validateParameter(valid_606773, JString, required = false,
                                 default = nil)
  if valid_606773 != nil:
    section.add "X-Amz-Signature", valid_606773
  var valid_606774 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_606774 = validateParameter(valid_606774, JString, required = false,
                                 default = nil)
  if valid_606774 != nil:
    section.add "X-Amz-Content-Sha256", valid_606774
  var valid_606775 = header.getOrDefault("X-Amz-Date")
  valid_606775 = validateParameter(valid_606775, JString, required = false,
                                 default = nil)
  if valid_606775 != nil:
    section.add "X-Amz-Date", valid_606775
  var valid_606776 = header.getOrDefault("X-Amz-Credential")
  valid_606776 = validateParameter(valid_606776, JString, required = false,
                                 default = nil)
  if valid_606776 != nil:
    section.add "X-Amz-Credential", valid_606776
  var valid_606777 = header.getOrDefault("X-Amz-Security-Token")
  valid_606777 = validateParameter(valid_606777, JString, required = false,
                                 default = nil)
  if valid_606777 != nil:
    section.add "X-Amz-Security-Token", valid_606777
  var valid_606778 = header.getOrDefault("X-Amz-Algorithm")
  valid_606778 = validateParameter(valid_606778, JString, required = false,
                                 default = nil)
  if valid_606778 != nil:
    section.add "X-Amz-Algorithm", valid_606778
  var valid_606779 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_606779 = validateParameter(valid_606779, JString, required = false,
                                 default = nil)
  if valid_606779 != nil:
    section.add "X-Amz-SignedHeaders", valid_606779
  result.add "header", section
  ## parameters in `formData` object:
  ##   Description: JString (required)
  ##              : A text description of the HSM configuration to be created.
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   HsmPartitionPassword: JString (required)
  ##                       : The password required to access the HSM partition.
  ##   HsmPartitionName: JString (required)
  ##                   : The name of the partition in the HSM where the Amazon Redshift clusters will store their database encryption keys.
  ##   HsmServerPublicCertificate: JString (required)
  ##                             : The HSMs public certificate file. When using Cloud HSM, the file name is server.pem.
  ##   HsmConfigurationIdentifier: JString (required)
  ##                             : The identifier to be assigned to the new Amazon Redshift HSM configuration.
  ##   HsmIpAddress: JString (required)
  ##               : The IP address that the Amazon Redshift cluster must use to access the HSM.
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `Description` field"
  var valid_606780 = formData.getOrDefault("Description")
  valid_606780 = validateParameter(valid_606780, JString, required = true,
                                 default = nil)
  if valid_606780 != nil:
    section.add "Description", valid_606780
  var valid_606781 = formData.getOrDefault("Tags")
  valid_606781 = validateParameter(valid_606781, JArray, required = false,
                                 default = nil)
  if valid_606781 != nil:
    section.add "Tags", valid_606781
  var valid_606782 = formData.getOrDefault("HsmPartitionPassword")
  valid_606782 = validateParameter(valid_606782, JString, required = true,
                                 default = nil)
  if valid_606782 != nil:
    section.add "HsmPartitionPassword", valid_606782
  var valid_606783 = formData.getOrDefault("HsmPartitionName")
  valid_606783 = validateParameter(valid_606783, JString, required = true,
                                 default = nil)
  if valid_606783 != nil:
    section.add "HsmPartitionName", valid_606783
  var valid_606784 = formData.getOrDefault("HsmServerPublicCertificate")
  valid_606784 = validateParameter(valid_606784, JString, required = true,
                                 default = nil)
  if valid_606784 != nil:
    section.add "HsmServerPublicCertificate", valid_606784
  var valid_606785 = formData.getOrDefault("HsmConfigurationIdentifier")
  valid_606785 = validateParameter(valid_606785, JString, required = true,
                                 default = nil)
  if valid_606785 != nil:
    section.add "HsmConfigurationIdentifier", valid_606785
  var valid_606786 = formData.getOrDefault("HsmIpAddress")
  valid_606786 = validateParameter(valid_606786, JString, required = true,
                                 default = nil)
  if valid_606786 != nil:
    section.add "HsmIpAddress", valid_606786
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_606787: Call_PostCreateHsmConfiguration_606768; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates an HSM configuration that contains the information required by an Amazon Redshift cluster to store and use database encryption keys in a Hardware Security Module (HSM). After creating the HSM configuration, you can specify it as a parameter when creating a cluster. The cluster will then store its encryption keys in the HSM.</p> <p>In addition to creating an HSM configuration, you must also create an HSM client certificate. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a> in the Amazon Redshift Cluster Management Guide.</p>
  ## 
  let valid = call_606787.validator(path, query, header, formData, body)
  let scheme = call_606787.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_606787.url(scheme.get, call_606787.host, call_606787.base,
                         call_606787.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_606787, url, valid)

proc call*(call_606788: Call_PostCreateHsmConfiguration_606768;
          Description: string; HsmPartitionPassword: string;
          HsmPartitionName: string; HsmServerPublicCertificate: string;
          HsmConfigurationIdentifier: string; HsmIpAddress: string;
          Action: string = "CreateHsmConfiguration"; Tags: JsonNode = nil;
          Version: string = "2012-12-01"): Recallable =
  ## postCreateHsmConfiguration
  ## <p>Creates an HSM configuration that contains the information required by an Amazon Redshift cluster to store and use database encryption keys in a Hardware Security Module (HSM). After creating the HSM configuration, you can specify it as a parameter when creating a cluster. The cluster will then store its encryption keys in the HSM.</p> <p>In addition to creating an HSM configuration, you must also create an HSM client certificate. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a> in the Amazon Redshift Cluster Management Guide.</p>
  ##   Description: string (required)
  ##              : A text description of the HSM configuration to be created.
  ##   Action: string (required)
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   HsmPartitionPassword: string (required)
  ##                       : The password required to access the HSM partition.
  ##   Version: string (required)
  ##   HsmPartitionName: string (required)
  ##                   : The name of the partition in the HSM where the Amazon Redshift clusters will store their database encryption keys.
  ##   HsmServerPublicCertificate: string (required)
  ##                             : The HSMs public certificate file. When using Cloud HSM, the file name is server.pem.
  ##   HsmConfigurationIdentifier: string (required)
  ##                             : The identifier to be assigned to the new Amazon Redshift HSM configuration.
  ##   HsmIpAddress: string (required)
  ##               : The IP address that the Amazon Redshift cluster must use to access the HSM.
  var query_606789 = newJObject()
  var formData_606790 = newJObject()
  add(formData_606790, "Description", newJString(Description))
  add(query_606789, "Action", newJString(Action))
  if Tags != nil:
    formData_606790.add "Tags", Tags
  add(formData_606790, "HsmPartitionPassword", newJString(HsmPartitionPassword))
  add(query_606789, "Version", newJString(Version))
  add(formData_606790, "HsmPartitionName", newJString(HsmPartitionName))
  add(formData_606790, "HsmServerPublicCertificate",
      newJString(HsmServerPublicCertificate))
  add(formData_606790, "HsmConfigurationIdentifier",
      newJString(HsmConfigurationIdentifier))
  add(formData_606790, "HsmIpAddress", newJString(HsmIpAddress))
  result = call_606788.call(nil, query_606789, nil, formData_606790, nil)

var postCreateHsmConfiguration* = Call_PostCreateHsmConfiguration_606768(
    name: "postCreateHsmConfiguration", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=CreateHsmConfiguration",
    validator: validate_PostCreateHsmConfiguration_606769, base: "/",
    url: url_PostCreateHsmConfiguration_606770,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCreateHsmConfiguration_606746 = ref object of OpenApiRestCall_605573
proc url_GetCreateHsmConfiguration_606748(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetCreateHsmConfiguration_606747(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates an HSM configuration that contains the information required by an Amazon Redshift cluster to store and use database encryption keys in a Hardware Security Module (HSM). After creating the HSM configuration, you can specify it as a parameter when creating a cluster. The cluster will then store its encryption keys in the HSM.</p> <p>In addition to creating an HSM configuration, you must also create an HSM client certificate. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a> in the Amazon Redshift Cluster Management Guide.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   HsmIpAddress: JString (required)
  ##               : The IP address that the Amazon Redshift cluster must use to access the HSM.
  ##   HsmPartitionPassword: JString (required)
  ##                       : The password required to access the HSM partition.
  ##   HsmServerPublicCertificate: JString (required)
  ##                             : The HSMs public certificate file. When using Cloud HSM, the file name is server.pem.
  ##   HsmPartitionName: JString (required)
  ##                   : The name of the partition in the HSM where the Amazon Redshift clusters will store their database encryption keys.
  ##   Action: JString (required)
  ##   Description: JString (required)
  ##              : A text description of the HSM configuration to be created.
  ##   HsmConfigurationIdentifier: JString (required)
  ##                             : The identifier to be assigned to the new Amazon Redshift HSM configuration.
  ##   Version: JString (required)
  section = newJObject()
  var valid_606749 = query.getOrDefault("Tags")
  valid_606749 = validateParameter(valid_606749, JArray, required = false,
                                 default = nil)
  if valid_606749 != nil:
    section.add "Tags", valid_606749
  assert query != nil,
        "query argument is necessary due to required `HsmIpAddress` field"
  var valid_606750 = query.getOrDefault("HsmIpAddress")
  valid_606750 = validateParameter(valid_606750, JString, required = true,
                                 default = nil)
  if valid_606750 != nil:
    section.add "HsmIpAddress", valid_606750
  var valid_606751 = query.getOrDefault("HsmPartitionPassword")
  valid_606751 = validateParameter(valid_606751, JString, required = true,
                                 default = nil)
  if valid_606751 != nil:
    section.add "HsmPartitionPassword", valid_606751
  var valid_606752 = query.getOrDefault("HsmServerPublicCertificate")
  valid_606752 = validateParameter(valid_606752, JString, required = true,
                                 default = nil)
  if valid_606752 != nil:
    section.add "HsmServerPublicCertificate", valid_606752
  var valid_606753 = query.getOrDefault("HsmPartitionName")
  valid_606753 = validateParameter(valid_606753, JString, required = true,
                                 default = nil)
  if valid_606753 != nil:
    section.add "HsmPartitionName", valid_606753
  var valid_606754 = query.getOrDefault("Action")
  valid_606754 = validateParameter(valid_606754, JString, required = true,
                                 default = newJString("CreateHsmConfiguration"))
  if valid_606754 != nil:
    section.add "Action", valid_606754
  var valid_606755 = query.getOrDefault("Description")
  valid_606755 = validateParameter(valid_606755, JString, required = true,
                                 default = nil)
  if valid_606755 != nil:
    section.add "Description", valid_606755
  var valid_606756 = query.getOrDefault("HsmConfigurationIdentifier")
  valid_606756 = validateParameter(valid_606756, JString, required = true,
                                 default = nil)
  if valid_606756 != nil:
    section.add "HsmConfigurationIdentifier", valid_606756
  var valid_606757 = query.getOrDefault("Version")
  valid_606757 = validateParameter(valid_606757, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_606757 != nil:
    section.add "Version", valid_606757
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_606758 = header.getOrDefault("X-Amz-Signature")
  valid_606758 = validateParameter(valid_606758, JString, required = false,
                                 default = nil)
  if valid_606758 != nil:
    section.add "X-Amz-Signature", valid_606758
  var valid_606759 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_606759 = validateParameter(valid_606759, JString, required = false,
                                 default = nil)
  if valid_606759 != nil:
    section.add "X-Amz-Content-Sha256", valid_606759
  var valid_606760 = header.getOrDefault("X-Amz-Date")
  valid_606760 = validateParameter(valid_606760, JString, required = false,
                                 default = nil)
  if valid_606760 != nil:
    section.add "X-Amz-Date", valid_606760
  var valid_606761 = header.getOrDefault("X-Amz-Credential")
  valid_606761 = validateParameter(valid_606761, JString, required = false,
                                 default = nil)
  if valid_606761 != nil:
    section.add "X-Amz-Credential", valid_606761
  var valid_606762 = header.getOrDefault("X-Amz-Security-Token")
  valid_606762 = validateParameter(valid_606762, JString, required = false,
                                 default = nil)
  if valid_606762 != nil:
    section.add "X-Amz-Security-Token", valid_606762
  var valid_606763 = header.getOrDefault("X-Amz-Algorithm")
  valid_606763 = validateParameter(valid_606763, JString, required = false,
                                 default = nil)
  if valid_606763 != nil:
    section.add "X-Amz-Algorithm", valid_606763
  var valid_606764 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_606764 = validateParameter(valid_606764, JString, required = false,
                                 default = nil)
  if valid_606764 != nil:
    section.add "X-Amz-SignedHeaders", valid_606764
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_606765: Call_GetCreateHsmConfiguration_606746; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates an HSM configuration that contains the information required by an Amazon Redshift cluster to store and use database encryption keys in a Hardware Security Module (HSM). After creating the HSM configuration, you can specify it as a parameter when creating a cluster. The cluster will then store its encryption keys in the HSM.</p> <p>In addition to creating an HSM configuration, you must also create an HSM client certificate. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a> in the Amazon Redshift Cluster Management Guide.</p>
  ## 
  let valid = call_606765.validator(path, query, header, formData, body)
  let scheme = call_606765.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_606765.url(scheme.get, call_606765.host, call_606765.base,
                         call_606765.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_606765, url, valid)

proc call*(call_606766: Call_GetCreateHsmConfiguration_606746;
          HsmIpAddress: string; HsmPartitionPassword: string;
          HsmServerPublicCertificate: string; HsmPartitionName: string;
          Description: string; HsmConfigurationIdentifier: string;
          Tags: JsonNode = nil; Action: string = "CreateHsmConfiguration";
          Version: string = "2012-12-01"): Recallable =
  ## getCreateHsmConfiguration
  ## <p>Creates an HSM configuration that contains the information required by an Amazon Redshift cluster to store and use database encryption keys in a Hardware Security Module (HSM). After creating the HSM configuration, you can specify it as a parameter when creating a cluster. The cluster will then store its encryption keys in the HSM.</p> <p>In addition to creating an HSM configuration, you must also create an HSM client certificate. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a> in the Amazon Redshift Cluster Management Guide.</p>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   HsmIpAddress: string (required)
  ##               : The IP address that the Amazon Redshift cluster must use to access the HSM.
  ##   HsmPartitionPassword: string (required)
  ##                       : The password required to access the HSM partition.
  ##   HsmServerPublicCertificate: string (required)
  ##                             : The HSMs public certificate file. When using Cloud HSM, the file name is server.pem.
  ##   HsmPartitionName: string (required)
  ##                   : The name of the partition in the HSM where the Amazon Redshift clusters will store their database encryption keys.
  ##   Action: string (required)
  ##   Description: string (required)
  ##              : A text description of the HSM configuration to be created.
  ##   HsmConfigurationIdentifier: string (required)
  ##                             : The identifier to be assigned to the new Amazon Redshift HSM configuration.
  ##   Version: string (required)
  var query_606767 = newJObject()
  if Tags != nil:
    query_606767.add "Tags", Tags
  add(query_606767, "HsmIpAddress", newJString(HsmIpAddress))
  add(query_606767, "HsmPartitionPassword", newJString(HsmPartitionPassword))
  add(query_606767, "HsmServerPublicCertificate",
      newJString(HsmServerPublicCertificate))
  add(query_606767, "HsmPartitionName", newJString(HsmPartitionName))
  add(query_606767, "Action", newJString(Action))
  add(query_606767, "Description", newJString(Description))
  add(query_606767, "HsmConfigurationIdentifier",
      newJString(HsmConfigurationIdentifier))
  add(query_606767, "Version", newJString(Version))
  result = call_606766.call(nil, query_606767, nil, nil, nil)

var getCreateHsmConfiguration* = Call_GetCreateHsmConfiguration_606746(
    name: "getCreateHsmConfiguration", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=CreateHsmConfiguration",
    validator: validate_GetCreateHsmConfiguration_606747, base: "/",
    url: url_GetCreateHsmConfiguration_606748,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCreateScheduledAction_606814 = ref object of OpenApiRestCall_605573
proc url_PostCreateScheduledAction_606816(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostCreateScheduledAction_606815(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Creates a scheduled action. A scheduled action contains a schedule and an Amazon Redshift API action. For example, you can create a schedule of when to run the <code>ResizeCluster</code> API operation. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_606817 = query.getOrDefault("Action")
  valid_606817 = validateParameter(valid_606817, JString, required = true,
                                 default = newJString("CreateScheduledAction"))
  if valid_606817 != nil:
    section.add "Action", valid_606817
  var valid_606818 = query.getOrDefault("Version")
  valid_606818 = validateParameter(valid_606818, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_606818 != nil:
    section.add "Version", valid_606818
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_606819 = header.getOrDefault("X-Amz-Signature")
  valid_606819 = validateParameter(valid_606819, JString, required = false,
                                 default = nil)
  if valid_606819 != nil:
    section.add "X-Amz-Signature", valid_606819
  var valid_606820 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_606820 = validateParameter(valid_606820, JString, required = false,
                                 default = nil)
  if valid_606820 != nil:
    section.add "X-Amz-Content-Sha256", valid_606820
  var valid_606821 = header.getOrDefault("X-Amz-Date")
  valid_606821 = validateParameter(valid_606821, JString, required = false,
                                 default = nil)
  if valid_606821 != nil:
    section.add "X-Amz-Date", valid_606821
  var valid_606822 = header.getOrDefault("X-Amz-Credential")
  valid_606822 = validateParameter(valid_606822, JString, required = false,
                                 default = nil)
  if valid_606822 != nil:
    section.add "X-Amz-Credential", valid_606822
  var valid_606823 = header.getOrDefault("X-Amz-Security-Token")
  valid_606823 = validateParameter(valid_606823, JString, required = false,
                                 default = nil)
  if valid_606823 != nil:
    section.add "X-Amz-Security-Token", valid_606823
  var valid_606824 = header.getOrDefault("X-Amz-Algorithm")
  valid_606824 = validateParameter(valid_606824, JString, required = false,
                                 default = nil)
  if valid_606824 != nil:
    section.add "X-Amz-Algorithm", valid_606824
  var valid_606825 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_606825 = validateParameter(valid_606825, JString, required = false,
                                 default = nil)
  if valid_606825 != nil:
    section.add "X-Amz-SignedHeaders", valid_606825
  result.add "header", section
  ## parameters in `formData` object:
  ##   Enable: JBool
  ##         : If true, the schedule is enabled. If false, the scheduled action does not trigger. For more information about <code>state</code> of the scheduled action, see <a>ScheduledAction</a>. 
  ##   TargetAction.ResizeCluster: JString
  ##                             : The action type that specifies an Amazon Redshift API operation that is supported by the Amazon Redshift scheduler. 
  ## An action that runs a <code>ResizeCluster</code> API operation. 
  ##   ScheduledActionName: JString (required)
  ##                      : The name of the scheduled action. The name must be unique within an account. For more information about this parameter, see <a>ScheduledAction</a>. 
  ##   ScheduledActionDescription: JString
  ##                             : The description of the scheduled action. 
  ##   Schedule: JString (required)
  ##           : The schedule in <code>at( )</code> or <code>cron( )</code> format. For more information about this parameter, see <a>ScheduledAction</a>.
  ##   EndTime: JString
  ##          : The end time in UTC of the scheduled action. After this time, the scheduled action does not trigger. For more information about this parameter, see <a>ScheduledAction</a>. 
  ##   StartTime: JString
  ##            : The start time in UTC of the scheduled action. Before this time, the scheduled action does not trigger. For more information about this parameter, see <a>ScheduledAction</a>.
  ##   IamRole: JString (required)
  ##          : The IAM role to assume to run the target action. For more information about this parameter, see <a>ScheduledAction</a>. 
  section = newJObject()
  var valid_606826 = formData.getOrDefault("Enable")
  valid_606826 = validateParameter(valid_606826, JBool, required = false, default = nil)
  if valid_606826 != nil:
    section.add "Enable", valid_606826
  var valid_606827 = formData.getOrDefault("TargetAction.ResizeCluster")
  valid_606827 = validateParameter(valid_606827, JString, required = false,
                                 default = nil)
  if valid_606827 != nil:
    section.add "TargetAction.ResizeCluster", valid_606827
  assert formData != nil, "formData argument is necessary due to required `ScheduledActionName` field"
  var valid_606828 = formData.getOrDefault("ScheduledActionName")
  valid_606828 = validateParameter(valid_606828, JString, required = true,
                                 default = nil)
  if valid_606828 != nil:
    section.add "ScheduledActionName", valid_606828
  var valid_606829 = formData.getOrDefault("ScheduledActionDescription")
  valid_606829 = validateParameter(valid_606829, JString, required = false,
                                 default = nil)
  if valid_606829 != nil:
    section.add "ScheduledActionDescription", valid_606829
  var valid_606830 = formData.getOrDefault("Schedule")
  valid_606830 = validateParameter(valid_606830, JString, required = true,
                                 default = nil)
  if valid_606830 != nil:
    section.add "Schedule", valid_606830
  var valid_606831 = formData.getOrDefault("EndTime")
  valid_606831 = validateParameter(valid_606831, JString, required = false,
                                 default = nil)
  if valid_606831 != nil:
    section.add "EndTime", valid_606831
  var valid_606832 = formData.getOrDefault("StartTime")
  valid_606832 = validateParameter(valid_606832, JString, required = false,
                                 default = nil)
  if valid_606832 != nil:
    section.add "StartTime", valid_606832
  var valid_606833 = formData.getOrDefault("IamRole")
  valid_606833 = validateParameter(valid_606833, JString, required = true,
                                 default = nil)
  if valid_606833 != nil:
    section.add "IamRole", valid_606833
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_606834: Call_PostCreateScheduledAction_606814; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a scheduled action. A scheduled action contains a schedule and an Amazon Redshift API action. For example, you can create a schedule of when to run the <code>ResizeCluster</code> API operation. 
  ## 
  let valid = call_606834.validator(path, query, header, formData, body)
  let scheme = call_606834.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_606834.url(scheme.get, call_606834.host, call_606834.base,
                         call_606834.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_606834, url, valid)

proc call*(call_606835: Call_PostCreateScheduledAction_606814;
          ScheduledActionName: string; Schedule: string; IamRole: string;
          Enable: bool = false; TargetActionResizeCluster: string = "";
          ScheduledActionDescription: string = ""; EndTime: string = "";
          StartTime: string = ""; Action: string = "CreateScheduledAction";
          Version: string = "2012-12-01"): Recallable =
  ## postCreateScheduledAction
  ## Creates a scheduled action. A scheduled action contains a schedule and an Amazon Redshift API action. For example, you can create a schedule of when to run the <code>ResizeCluster</code> API operation. 
  ##   Enable: bool
  ##         : If true, the schedule is enabled. If false, the scheduled action does not trigger. For more information about <code>state</code> of the scheduled action, see <a>ScheduledAction</a>. 
  ##   TargetActionResizeCluster: string
  ##                            : The action type that specifies an Amazon Redshift API operation that is supported by the Amazon Redshift scheduler. 
  ## An action that runs a <code>ResizeCluster</code> API operation. 
  ##   ScheduledActionName: string (required)
  ##                      : The name of the scheduled action. The name must be unique within an account. For more information about this parameter, see <a>ScheduledAction</a>. 
  ##   ScheduledActionDescription: string
  ##                             : The description of the scheduled action. 
  ##   Schedule: string (required)
  ##           : The schedule in <code>at( )</code> or <code>cron( )</code> format. For more information about this parameter, see <a>ScheduledAction</a>.
  ##   EndTime: string
  ##          : The end time in UTC of the scheduled action. After this time, the scheduled action does not trigger. For more information about this parameter, see <a>ScheduledAction</a>. 
  ##   StartTime: string
  ##            : The start time in UTC of the scheduled action. Before this time, the scheduled action does not trigger. For more information about this parameter, see <a>ScheduledAction</a>.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   IamRole: string (required)
  ##          : The IAM role to assume to run the target action. For more information about this parameter, see <a>ScheduledAction</a>. 
  var query_606836 = newJObject()
  var formData_606837 = newJObject()
  add(formData_606837, "Enable", newJBool(Enable))
  add(formData_606837, "TargetAction.ResizeCluster",
      newJString(TargetActionResizeCluster))
  add(formData_606837, "ScheduledActionName", newJString(ScheduledActionName))
  add(formData_606837, "ScheduledActionDescription",
      newJString(ScheduledActionDescription))
  add(formData_606837, "Schedule", newJString(Schedule))
  add(formData_606837, "EndTime", newJString(EndTime))
  add(formData_606837, "StartTime", newJString(StartTime))
  add(query_606836, "Action", newJString(Action))
  add(query_606836, "Version", newJString(Version))
  add(formData_606837, "IamRole", newJString(IamRole))
  result = call_606835.call(nil, query_606836, nil, formData_606837, nil)

var postCreateScheduledAction* = Call_PostCreateScheduledAction_606814(
    name: "postCreateScheduledAction", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=CreateScheduledAction",
    validator: validate_PostCreateScheduledAction_606815, base: "/",
    url: url_PostCreateScheduledAction_606816,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCreateScheduledAction_606791 = ref object of OpenApiRestCall_605573
proc url_GetCreateScheduledAction_606793(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetCreateScheduledAction_606792(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Creates a scheduled action. A scheduled action contains a schedule and an Amazon Redshift API action. For example, you can create a schedule of when to run the <code>ResizeCluster</code> API operation. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Schedule: JString (required)
  ##           : The schedule in <code>at( )</code> or <code>cron( )</code> format. For more information about this parameter, see <a>ScheduledAction</a>.
  ##   Enable: JBool
  ##         : If true, the schedule is enabled. If false, the scheduled action does not trigger. For more information about <code>state</code> of the scheduled action, see <a>ScheduledAction</a>. 
  ##   ScheduledActionName: JString (required)
  ##                      : The name of the scheduled action. The name must be unique within an account. For more information about this parameter, see <a>ScheduledAction</a>. 
  ##   IamRole: JString (required)
  ##          : The IAM role to assume to run the target action. For more information about this parameter, see <a>ScheduledAction</a>. 
  ##   TargetAction.ResizeCluster: JString
  ##                             : The action type that specifies an Amazon Redshift API operation that is supported by the Amazon Redshift scheduler. 
  ## An action that runs a <code>ResizeCluster</code> API operation. 
  ##   ScheduledActionDescription: JString
  ##                             : The description of the scheduled action. 
  ##   Action: JString (required)
  ##   StartTime: JString
  ##            : The start time in UTC of the scheduled action. Before this time, the scheduled action does not trigger. For more information about this parameter, see <a>ScheduledAction</a>.
  ##   EndTime: JString
  ##          : The end time in UTC of the scheduled action. After this time, the scheduled action does not trigger. For more information about this parameter, see <a>ScheduledAction</a>. 
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `Schedule` field"
  var valid_606794 = query.getOrDefault("Schedule")
  valid_606794 = validateParameter(valid_606794, JString, required = true,
                                 default = nil)
  if valid_606794 != nil:
    section.add "Schedule", valid_606794
  var valid_606795 = query.getOrDefault("Enable")
  valid_606795 = validateParameter(valid_606795, JBool, required = false, default = nil)
  if valid_606795 != nil:
    section.add "Enable", valid_606795
  var valid_606796 = query.getOrDefault("ScheduledActionName")
  valid_606796 = validateParameter(valid_606796, JString, required = true,
                                 default = nil)
  if valid_606796 != nil:
    section.add "ScheduledActionName", valid_606796
  var valid_606797 = query.getOrDefault("IamRole")
  valid_606797 = validateParameter(valid_606797, JString, required = true,
                                 default = nil)
  if valid_606797 != nil:
    section.add "IamRole", valid_606797
  var valid_606798 = query.getOrDefault("TargetAction.ResizeCluster")
  valid_606798 = validateParameter(valid_606798, JString, required = false,
                                 default = nil)
  if valid_606798 != nil:
    section.add "TargetAction.ResizeCluster", valid_606798
  var valid_606799 = query.getOrDefault("ScheduledActionDescription")
  valid_606799 = validateParameter(valid_606799, JString, required = false,
                                 default = nil)
  if valid_606799 != nil:
    section.add "ScheduledActionDescription", valid_606799
  var valid_606800 = query.getOrDefault("Action")
  valid_606800 = validateParameter(valid_606800, JString, required = true,
                                 default = newJString("CreateScheduledAction"))
  if valid_606800 != nil:
    section.add "Action", valid_606800
  var valid_606801 = query.getOrDefault("StartTime")
  valid_606801 = validateParameter(valid_606801, JString, required = false,
                                 default = nil)
  if valid_606801 != nil:
    section.add "StartTime", valid_606801
  var valid_606802 = query.getOrDefault("EndTime")
  valid_606802 = validateParameter(valid_606802, JString, required = false,
                                 default = nil)
  if valid_606802 != nil:
    section.add "EndTime", valid_606802
  var valid_606803 = query.getOrDefault("Version")
  valid_606803 = validateParameter(valid_606803, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_606803 != nil:
    section.add "Version", valid_606803
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_606804 = header.getOrDefault("X-Amz-Signature")
  valid_606804 = validateParameter(valid_606804, JString, required = false,
                                 default = nil)
  if valid_606804 != nil:
    section.add "X-Amz-Signature", valid_606804
  var valid_606805 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_606805 = validateParameter(valid_606805, JString, required = false,
                                 default = nil)
  if valid_606805 != nil:
    section.add "X-Amz-Content-Sha256", valid_606805
  var valid_606806 = header.getOrDefault("X-Amz-Date")
  valid_606806 = validateParameter(valid_606806, JString, required = false,
                                 default = nil)
  if valid_606806 != nil:
    section.add "X-Amz-Date", valid_606806
  var valid_606807 = header.getOrDefault("X-Amz-Credential")
  valid_606807 = validateParameter(valid_606807, JString, required = false,
                                 default = nil)
  if valid_606807 != nil:
    section.add "X-Amz-Credential", valid_606807
  var valid_606808 = header.getOrDefault("X-Amz-Security-Token")
  valid_606808 = validateParameter(valid_606808, JString, required = false,
                                 default = nil)
  if valid_606808 != nil:
    section.add "X-Amz-Security-Token", valid_606808
  var valid_606809 = header.getOrDefault("X-Amz-Algorithm")
  valid_606809 = validateParameter(valid_606809, JString, required = false,
                                 default = nil)
  if valid_606809 != nil:
    section.add "X-Amz-Algorithm", valid_606809
  var valid_606810 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_606810 = validateParameter(valid_606810, JString, required = false,
                                 default = nil)
  if valid_606810 != nil:
    section.add "X-Amz-SignedHeaders", valid_606810
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_606811: Call_GetCreateScheduledAction_606791; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a scheduled action. A scheduled action contains a schedule and an Amazon Redshift API action. For example, you can create a schedule of when to run the <code>ResizeCluster</code> API operation. 
  ## 
  let valid = call_606811.validator(path, query, header, formData, body)
  let scheme = call_606811.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_606811.url(scheme.get, call_606811.host, call_606811.base,
                         call_606811.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_606811, url, valid)

proc call*(call_606812: Call_GetCreateScheduledAction_606791; Schedule: string;
          ScheduledActionName: string; IamRole: string; Enable: bool = false;
          TargetActionResizeCluster: string = "";
          ScheduledActionDescription: string = "";
          Action: string = "CreateScheduledAction"; StartTime: string = "";
          EndTime: string = ""; Version: string = "2012-12-01"): Recallable =
  ## getCreateScheduledAction
  ## Creates a scheduled action. A scheduled action contains a schedule and an Amazon Redshift API action. For example, you can create a schedule of when to run the <code>ResizeCluster</code> API operation. 
  ##   Schedule: string (required)
  ##           : The schedule in <code>at( )</code> or <code>cron( )</code> format. For more information about this parameter, see <a>ScheduledAction</a>.
  ##   Enable: bool
  ##         : If true, the schedule is enabled. If false, the scheduled action does not trigger. For more information about <code>state</code> of the scheduled action, see <a>ScheduledAction</a>. 
  ##   ScheduledActionName: string (required)
  ##                      : The name of the scheduled action. The name must be unique within an account. For more information about this parameter, see <a>ScheduledAction</a>. 
  ##   IamRole: string (required)
  ##          : The IAM role to assume to run the target action. For more information about this parameter, see <a>ScheduledAction</a>. 
  ##   TargetActionResizeCluster: string
  ##                            : The action type that specifies an Amazon Redshift API operation that is supported by the Amazon Redshift scheduler. 
  ## An action that runs a <code>ResizeCluster</code> API operation. 
  ##   ScheduledActionDescription: string
  ##                             : The description of the scheduled action. 
  ##   Action: string (required)
  ##   StartTime: string
  ##            : The start time in UTC of the scheduled action. Before this time, the scheduled action does not trigger. For more information about this parameter, see <a>ScheduledAction</a>.
  ##   EndTime: string
  ##          : The end time in UTC of the scheduled action. After this time, the scheduled action does not trigger. For more information about this parameter, see <a>ScheduledAction</a>. 
  ##   Version: string (required)
  var query_606813 = newJObject()
  add(query_606813, "Schedule", newJString(Schedule))
  add(query_606813, "Enable", newJBool(Enable))
  add(query_606813, "ScheduledActionName", newJString(ScheduledActionName))
  add(query_606813, "IamRole", newJString(IamRole))
  add(query_606813, "TargetAction.ResizeCluster",
      newJString(TargetActionResizeCluster))
  add(query_606813, "ScheduledActionDescription",
      newJString(ScheduledActionDescription))
  add(query_606813, "Action", newJString(Action))
  add(query_606813, "StartTime", newJString(StartTime))
  add(query_606813, "EndTime", newJString(EndTime))
  add(query_606813, "Version", newJString(Version))
  result = call_606812.call(nil, query_606813, nil, nil, nil)

var getCreateScheduledAction* = Call_GetCreateScheduledAction_606791(
    name: "getCreateScheduledAction", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=CreateScheduledAction",
    validator: validate_GetCreateScheduledAction_606792, base: "/",
    url: url_GetCreateScheduledAction_606793, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCreateSnapshotCopyGrant_606856 = ref object of OpenApiRestCall_605573
proc url_PostCreateSnapshotCopyGrant_606858(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostCreateSnapshotCopyGrant_606857(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a snapshot copy grant that permits Amazon Redshift to use a customer master key (CMK) from AWS Key Management Service (AWS KMS) to encrypt copied snapshots in a destination region.</p> <p> For more information about managing snapshot copy grants, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_606859 = query.getOrDefault("Action")
  valid_606859 = validateParameter(valid_606859, JString, required = true, default = newJString(
      "CreateSnapshotCopyGrant"))
  if valid_606859 != nil:
    section.add "Action", valid_606859
  var valid_606860 = query.getOrDefault("Version")
  valid_606860 = validateParameter(valid_606860, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_606860 != nil:
    section.add "Version", valid_606860
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_606861 = header.getOrDefault("X-Amz-Signature")
  valid_606861 = validateParameter(valid_606861, JString, required = false,
                                 default = nil)
  if valid_606861 != nil:
    section.add "X-Amz-Signature", valid_606861
  var valid_606862 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_606862 = validateParameter(valid_606862, JString, required = false,
                                 default = nil)
  if valid_606862 != nil:
    section.add "X-Amz-Content-Sha256", valid_606862
  var valid_606863 = header.getOrDefault("X-Amz-Date")
  valid_606863 = validateParameter(valid_606863, JString, required = false,
                                 default = nil)
  if valid_606863 != nil:
    section.add "X-Amz-Date", valid_606863
  var valid_606864 = header.getOrDefault("X-Amz-Credential")
  valid_606864 = validateParameter(valid_606864, JString, required = false,
                                 default = nil)
  if valid_606864 != nil:
    section.add "X-Amz-Credential", valid_606864
  var valid_606865 = header.getOrDefault("X-Amz-Security-Token")
  valid_606865 = validateParameter(valid_606865, JString, required = false,
                                 default = nil)
  if valid_606865 != nil:
    section.add "X-Amz-Security-Token", valid_606865
  var valid_606866 = header.getOrDefault("X-Amz-Algorithm")
  valid_606866 = validateParameter(valid_606866, JString, required = false,
                                 default = nil)
  if valid_606866 != nil:
    section.add "X-Amz-Algorithm", valid_606866
  var valid_606867 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_606867 = validateParameter(valid_606867, JString, required = false,
                                 default = nil)
  if valid_606867 != nil:
    section.add "X-Amz-SignedHeaders", valid_606867
  result.add "header", section
  ## parameters in `formData` object:
  ##   KmsKeyId: JString
  ##           : The unique identifier of the customer master key (CMK) to which to grant Amazon Redshift permission. If no key is specified, the default key is used.
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   SnapshotCopyGrantName: JString (required)
  ##                        : <p>The name of the snapshot copy grant. This name must be unique in the region for the AWS account.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul>
  section = newJObject()
  var valid_606868 = formData.getOrDefault("KmsKeyId")
  valid_606868 = validateParameter(valid_606868, JString, required = false,
                                 default = nil)
  if valid_606868 != nil:
    section.add "KmsKeyId", valid_606868
  var valid_606869 = formData.getOrDefault("Tags")
  valid_606869 = validateParameter(valid_606869, JArray, required = false,
                                 default = nil)
  if valid_606869 != nil:
    section.add "Tags", valid_606869
  assert formData != nil, "formData argument is necessary due to required `SnapshotCopyGrantName` field"
  var valid_606870 = formData.getOrDefault("SnapshotCopyGrantName")
  valid_606870 = validateParameter(valid_606870, JString, required = true,
                                 default = nil)
  if valid_606870 != nil:
    section.add "SnapshotCopyGrantName", valid_606870
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_606871: Call_PostCreateSnapshotCopyGrant_606856; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a snapshot copy grant that permits Amazon Redshift to use a customer master key (CMK) from AWS Key Management Service (AWS KMS) to encrypt copied snapshots in a destination region.</p> <p> For more information about managing snapshot copy grants, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ## 
  let valid = call_606871.validator(path, query, header, formData, body)
  let scheme = call_606871.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_606871.url(scheme.get, call_606871.host, call_606871.base,
                         call_606871.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_606871, url, valid)

proc call*(call_606872: Call_PostCreateSnapshotCopyGrant_606856;
          SnapshotCopyGrantName: string; KmsKeyId: string = "";
          Action: string = "CreateSnapshotCopyGrant"; Tags: JsonNode = nil;
          Version: string = "2012-12-01"): Recallable =
  ## postCreateSnapshotCopyGrant
  ## <p>Creates a snapshot copy grant that permits Amazon Redshift to use a customer master key (CMK) from AWS Key Management Service (AWS KMS) to encrypt copied snapshots in a destination region.</p> <p> For more information about managing snapshot copy grants, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ##   KmsKeyId: string
  ##           : The unique identifier of the customer master key (CMK) to which to grant Amazon Redshift permission. If no key is specified, the default key is used.
  ##   Action: string (required)
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   SnapshotCopyGrantName: string (required)
  ##                        : <p>The name of the snapshot copy grant. This name must be unique in the region for the AWS account.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul>
  ##   Version: string (required)
  var query_606873 = newJObject()
  var formData_606874 = newJObject()
  add(formData_606874, "KmsKeyId", newJString(KmsKeyId))
  add(query_606873, "Action", newJString(Action))
  if Tags != nil:
    formData_606874.add "Tags", Tags
  add(formData_606874, "SnapshotCopyGrantName", newJString(SnapshotCopyGrantName))
  add(query_606873, "Version", newJString(Version))
  result = call_606872.call(nil, query_606873, nil, formData_606874, nil)

var postCreateSnapshotCopyGrant* = Call_PostCreateSnapshotCopyGrant_606856(
    name: "postCreateSnapshotCopyGrant", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=CreateSnapshotCopyGrant",
    validator: validate_PostCreateSnapshotCopyGrant_606857, base: "/",
    url: url_PostCreateSnapshotCopyGrant_606858,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCreateSnapshotCopyGrant_606838 = ref object of OpenApiRestCall_605573
proc url_GetCreateSnapshotCopyGrant_606840(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetCreateSnapshotCopyGrant_606839(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a snapshot copy grant that permits Amazon Redshift to use a customer master key (CMK) from AWS Key Management Service (AWS KMS) to encrypt copied snapshots in a destination region.</p> <p> For more information about managing snapshot copy grants, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   KmsKeyId: JString
  ##           : The unique identifier of the customer master key (CMK) to which to grant Amazon Redshift permission. If no key is specified, the default key is used.
  ##   Action: JString (required)
  ##   Version: JString (required)
  ##   SnapshotCopyGrantName: JString (required)
  ##                        : <p>The name of the snapshot copy grant. This name must be unique in the region for the AWS account.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul>
  section = newJObject()
  var valid_606841 = query.getOrDefault("Tags")
  valid_606841 = validateParameter(valid_606841, JArray, required = false,
                                 default = nil)
  if valid_606841 != nil:
    section.add "Tags", valid_606841
  var valid_606842 = query.getOrDefault("KmsKeyId")
  valid_606842 = validateParameter(valid_606842, JString, required = false,
                                 default = nil)
  if valid_606842 != nil:
    section.add "KmsKeyId", valid_606842
  var valid_606843 = query.getOrDefault("Action")
  valid_606843 = validateParameter(valid_606843, JString, required = true, default = newJString(
      "CreateSnapshotCopyGrant"))
  if valid_606843 != nil:
    section.add "Action", valid_606843
  var valid_606844 = query.getOrDefault("Version")
  valid_606844 = validateParameter(valid_606844, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_606844 != nil:
    section.add "Version", valid_606844
  var valid_606845 = query.getOrDefault("SnapshotCopyGrantName")
  valid_606845 = validateParameter(valid_606845, JString, required = true,
                                 default = nil)
  if valid_606845 != nil:
    section.add "SnapshotCopyGrantName", valid_606845
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_606846 = header.getOrDefault("X-Amz-Signature")
  valid_606846 = validateParameter(valid_606846, JString, required = false,
                                 default = nil)
  if valid_606846 != nil:
    section.add "X-Amz-Signature", valid_606846
  var valid_606847 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_606847 = validateParameter(valid_606847, JString, required = false,
                                 default = nil)
  if valid_606847 != nil:
    section.add "X-Amz-Content-Sha256", valid_606847
  var valid_606848 = header.getOrDefault("X-Amz-Date")
  valid_606848 = validateParameter(valid_606848, JString, required = false,
                                 default = nil)
  if valid_606848 != nil:
    section.add "X-Amz-Date", valid_606848
  var valid_606849 = header.getOrDefault("X-Amz-Credential")
  valid_606849 = validateParameter(valid_606849, JString, required = false,
                                 default = nil)
  if valid_606849 != nil:
    section.add "X-Amz-Credential", valid_606849
  var valid_606850 = header.getOrDefault("X-Amz-Security-Token")
  valid_606850 = validateParameter(valid_606850, JString, required = false,
                                 default = nil)
  if valid_606850 != nil:
    section.add "X-Amz-Security-Token", valid_606850
  var valid_606851 = header.getOrDefault("X-Amz-Algorithm")
  valid_606851 = validateParameter(valid_606851, JString, required = false,
                                 default = nil)
  if valid_606851 != nil:
    section.add "X-Amz-Algorithm", valid_606851
  var valid_606852 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_606852 = validateParameter(valid_606852, JString, required = false,
                                 default = nil)
  if valid_606852 != nil:
    section.add "X-Amz-SignedHeaders", valid_606852
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_606853: Call_GetCreateSnapshotCopyGrant_606838; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a snapshot copy grant that permits Amazon Redshift to use a customer master key (CMK) from AWS Key Management Service (AWS KMS) to encrypt copied snapshots in a destination region.</p> <p> For more information about managing snapshot copy grants, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ## 
  let valid = call_606853.validator(path, query, header, formData, body)
  let scheme = call_606853.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_606853.url(scheme.get, call_606853.host, call_606853.base,
                         call_606853.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_606853, url, valid)

proc call*(call_606854: Call_GetCreateSnapshotCopyGrant_606838;
          SnapshotCopyGrantName: string; Tags: JsonNode = nil; KmsKeyId: string = "";
          Action: string = "CreateSnapshotCopyGrant"; Version: string = "2012-12-01"): Recallable =
  ## getCreateSnapshotCopyGrant
  ## <p>Creates a snapshot copy grant that permits Amazon Redshift to use a customer master key (CMK) from AWS Key Management Service (AWS KMS) to encrypt copied snapshots in a destination region.</p> <p> For more information about managing snapshot copy grants, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   KmsKeyId: string
  ##           : The unique identifier of the customer master key (CMK) to which to grant Amazon Redshift permission. If no key is specified, the default key is used.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   SnapshotCopyGrantName: string (required)
  ##                        : <p>The name of the snapshot copy grant. This name must be unique in the region for the AWS account.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul>
  var query_606855 = newJObject()
  if Tags != nil:
    query_606855.add "Tags", Tags
  add(query_606855, "KmsKeyId", newJString(KmsKeyId))
  add(query_606855, "Action", newJString(Action))
  add(query_606855, "Version", newJString(Version))
  add(query_606855, "SnapshotCopyGrantName", newJString(SnapshotCopyGrantName))
  result = call_606854.call(nil, query_606855, nil, nil, nil)

var getCreateSnapshotCopyGrant* = Call_GetCreateSnapshotCopyGrant_606838(
    name: "getCreateSnapshotCopyGrant", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=CreateSnapshotCopyGrant",
    validator: validate_GetCreateSnapshotCopyGrant_606839, base: "/",
    url: url_GetCreateSnapshotCopyGrant_606840,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCreateSnapshotSchedule_606896 = ref object of OpenApiRestCall_605573
proc url_PostCreateSnapshotSchedule_606898(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostCreateSnapshotSchedule_606897(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Creates a snapshot schedule with the rate of every 12 hours.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_606899 = query.getOrDefault("Action")
  valid_606899 = validateParameter(valid_606899, JString, required = true,
                                 default = newJString("CreateSnapshotSchedule"))
  if valid_606899 != nil:
    section.add "Action", valid_606899
  var valid_606900 = query.getOrDefault("Version")
  valid_606900 = validateParameter(valid_606900, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_606900 != nil:
    section.add "Version", valid_606900
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_606901 = header.getOrDefault("X-Amz-Signature")
  valid_606901 = validateParameter(valid_606901, JString, required = false,
                                 default = nil)
  if valid_606901 != nil:
    section.add "X-Amz-Signature", valid_606901
  var valid_606902 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_606902 = validateParameter(valid_606902, JString, required = false,
                                 default = nil)
  if valid_606902 != nil:
    section.add "X-Amz-Content-Sha256", valid_606902
  var valid_606903 = header.getOrDefault("X-Amz-Date")
  valid_606903 = validateParameter(valid_606903, JString, required = false,
                                 default = nil)
  if valid_606903 != nil:
    section.add "X-Amz-Date", valid_606903
  var valid_606904 = header.getOrDefault("X-Amz-Credential")
  valid_606904 = validateParameter(valid_606904, JString, required = false,
                                 default = nil)
  if valid_606904 != nil:
    section.add "X-Amz-Credential", valid_606904
  var valid_606905 = header.getOrDefault("X-Amz-Security-Token")
  valid_606905 = validateParameter(valid_606905, JString, required = false,
                                 default = nil)
  if valid_606905 != nil:
    section.add "X-Amz-Security-Token", valid_606905
  var valid_606906 = header.getOrDefault("X-Amz-Algorithm")
  valid_606906 = validateParameter(valid_606906, JString, required = false,
                                 default = nil)
  if valid_606906 != nil:
    section.add "X-Amz-Algorithm", valid_606906
  var valid_606907 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_606907 = validateParameter(valid_606907, JString, required = false,
                                 default = nil)
  if valid_606907 != nil:
    section.add "X-Amz-SignedHeaders", valid_606907
  result.add "header", section
  ## parameters in `formData` object:
  ##   ScheduleDefinitions: JArray
  ##                      : The definition of the snapshot schedule. The definition is made up of schedule expressions, for example "cron(30 12 *)" or "rate(12 hours)". 
  ##   ScheduleDescription: JString
  ##                      : The description of the snapshot schedule.
  ##   DryRun: JBool
  ##         : <p/>
  ##   NextInvocations: JInt
  ##                  : <p/>
  ##   Tags: JArray
  ##       : An optional set of tags you can use to search for the schedule.
  ##   ScheduleIdentifier: JString
  ##                     : A unique identifier for a snapshot schedule. Only alphanumeric characters are allowed for the identifier.
  section = newJObject()
  var valid_606908 = formData.getOrDefault("ScheduleDefinitions")
  valid_606908 = validateParameter(valid_606908, JArray, required = false,
                                 default = nil)
  if valid_606908 != nil:
    section.add "ScheduleDefinitions", valid_606908
  var valid_606909 = formData.getOrDefault("ScheduleDescription")
  valid_606909 = validateParameter(valid_606909, JString, required = false,
                                 default = nil)
  if valid_606909 != nil:
    section.add "ScheduleDescription", valid_606909
  var valid_606910 = formData.getOrDefault("DryRun")
  valid_606910 = validateParameter(valid_606910, JBool, required = false, default = nil)
  if valid_606910 != nil:
    section.add "DryRun", valid_606910
  var valid_606911 = formData.getOrDefault("NextInvocations")
  valid_606911 = validateParameter(valid_606911, JInt, required = false, default = nil)
  if valid_606911 != nil:
    section.add "NextInvocations", valid_606911
  var valid_606912 = formData.getOrDefault("Tags")
  valid_606912 = validateParameter(valid_606912, JArray, required = false,
                                 default = nil)
  if valid_606912 != nil:
    section.add "Tags", valid_606912
  var valid_606913 = formData.getOrDefault("ScheduleIdentifier")
  valid_606913 = validateParameter(valid_606913, JString, required = false,
                                 default = nil)
  if valid_606913 != nil:
    section.add "ScheduleIdentifier", valid_606913
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_606914: Call_PostCreateSnapshotSchedule_606896; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a snapshot schedule with the rate of every 12 hours.
  ## 
  let valid = call_606914.validator(path, query, header, formData, body)
  let scheme = call_606914.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_606914.url(scheme.get, call_606914.host, call_606914.base,
                         call_606914.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_606914, url, valid)

proc call*(call_606915: Call_PostCreateSnapshotSchedule_606896;
          ScheduleDefinitions: JsonNode = nil; ScheduleDescription: string = "";
          DryRun: bool = false; NextInvocations: int = 0;
          Action: string = "CreateSnapshotSchedule"; Tags: JsonNode = nil;
          ScheduleIdentifier: string = ""; Version: string = "2012-12-01"): Recallable =
  ## postCreateSnapshotSchedule
  ## Creates a snapshot schedule with the rate of every 12 hours.
  ##   ScheduleDefinitions: JArray
  ##                      : The definition of the snapshot schedule. The definition is made up of schedule expressions, for example "cron(30 12 *)" or "rate(12 hours)". 
  ##   ScheduleDescription: string
  ##                      : The description of the snapshot schedule.
  ##   DryRun: bool
  ##         : <p/>
  ##   NextInvocations: int
  ##                  : <p/>
  ##   Action: string (required)
  ##   Tags: JArray
  ##       : An optional set of tags you can use to search for the schedule.
  ##   ScheduleIdentifier: string
  ##                     : A unique identifier for a snapshot schedule. Only alphanumeric characters are allowed for the identifier.
  ##   Version: string (required)
  var query_606916 = newJObject()
  var formData_606917 = newJObject()
  if ScheduleDefinitions != nil:
    formData_606917.add "ScheduleDefinitions", ScheduleDefinitions
  add(formData_606917, "ScheduleDescription", newJString(ScheduleDescription))
  add(formData_606917, "DryRun", newJBool(DryRun))
  add(formData_606917, "NextInvocations", newJInt(NextInvocations))
  add(query_606916, "Action", newJString(Action))
  if Tags != nil:
    formData_606917.add "Tags", Tags
  add(formData_606917, "ScheduleIdentifier", newJString(ScheduleIdentifier))
  add(query_606916, "Version", newJString(Version))
  result = call_606915.call(nil, query_606916, nil, formData_606917, nil)

var postCreateSnapshotSchedule* = Call_PostCreateSnapshotSchedule_606896(
    name: "postCreateSnapshotSchedule", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=CreateSnapshotSchedule",
    validator: validate_PostCreateSnapshotSchedule_606897, base: "/",
    url: url_PostCreateSnapshotSchedule_606898,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCreateSnapshotSchedule_606875 = ref object of OpenApiRestCall_605573
proc url_GetCreateSnapshotSchedule_606877(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetCreateSnapshotSchedule_606876(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Creates a snapshot schedule with the rate of every 12 hours.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Tags: JArray
  ##       : An optional set of tags you can use to search for the schedule.
  ##   ScheduleIdentifier: JString
  ##                     : A unique identifier for a snapshot schedule. Only alphanumeric characters are allowed for the identifier.
  ##   DryRun: JBool
  ##         : <p/>
  ##   NextInvocations: JInt
  ##                  : <p/>
  ##   ScheduleDefinitions: JArray
  ##                      : The definition of the snapshot schedule. The definition is made up of schedule expressions, for example "cron(30 12 *)" or "rate(12 hours)". 
  ##   ScheduleDescription: JString
  ##                      : The description of the snapshot schedule.
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_606878 = query.getOrDefault("Tags")
  valid_606878 = validateParameter(valid_606878, JArray, required = false,
                                 default = nil)
  if valid_606878 != nil:
    section.add "Tags", valid_606878
  var valid_606879 = query.getOrDefault("ScheduleIdentifier")
  valid_606879 = validateParameter(valid_606879, JString, required = false,
                                 default = nil)
  if valid_606879 != nil:
    section.add "ScheduleIdentifier", valid_606879
  var valid_606880 = query.getOrDefault("DryRun")
  valid_606880 = validateParameter(valid_606880, JBool, required = false, default = nil)
  if valid_606880 != nil:
    section.add "DryRun", valid_606880
  var valid_606881 = query.getOrDefault("NextInvocations")
  valid_606881 = validateParameter(valid_606881, JInt, required = false, default = nil)
  if valid_606881 != nil:
    section.add "NextInvocations", valid_606881
  var valid_606882 = query.getOrDefault("ScheduleDefinitions")
  valid_606882 = validateParameter(valid_606882, JArray, required = false,
                                 default = nil)
  if valid_606882 != nil:
    section.add "ScheduleDefinitions", valid_606882
  var valid_606883 = query.getOrDefault("ScheduleDescription")
  valid_606883 = validateParameter(valid_606883, JString, required = false,
                                 default = nil)
  if valid_606883 != nil:
    section.add "ScheduleDescription", valid_606883
  var valid_606884 = query.getOrDefault("Action")
  valid_606884 = validateParameter(valid_606884, JString, required = true,
                                 default = newJString("CreateSnapshotSchedule"))
  if valid_606884 != nil:
    section.add "Action", valid_606884
  var valid_606885 = query.getOrDefault("Version")
  valid_606885 = validateParameter(valid_606885, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_606885 != nil:
    section.add "Version", valid_606885
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_606886 = header.getOrDefault("X-Amz-Signature")
  valid_606886 = validateParameter(valid_606886, JString, required = false,
                                 default = nil)
  if valid_606886 != nil:
    section.add "X-Amz-Signature", valid_606886
  var valid_606887 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_606887 = validateParameter(valid_606887, JString, required = false,
                                 default = nil)
  if valid_606887 != nil:
    section.add "X-Amz-Content-Sha256", valid_606887
  var valid_606888 = header.getOrDefault("X-Amz-Date")
  valid_606888 = validateParameter(valid_606888, JString, required = false,
                                 default = nil)
  if valid_606888 != nil:
    section.add "X-Amz-Date", valid_606888
  var valid_606889 = header.getOrDefault("X-Amz-Credential")
  valid_606889 = validateParameter(valid_606889, JString, required = false,
                                 default = nil)
  if valid_606889 != nil:
    section.add "X-Amz-Credential", valid_606889
  var valid_606890 = header.getOrDefault("X-Amz-Security-Token")
  valid_606890 = validateParameter(valid_606890, JString, required = false,
                                 default = nil)
  if valid_606890 != nil:
    section.add "X-Amz-Security-Token", valid_606890
  var valid_606891 = header.getOrDefault("X-Amz-Algorithm")
  valid_606891 = validateParameter(valid_606891, JString, required = false,
                                 default = nil)
  if valid_606891 != nil:
    section.add "X-Amz-Algorithm", valid_606891
  var valid_606892 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_606892 = validateParameter(valid_606892, JString, required = false,
                                 default = nil)
  if valid_606892 != nil:
    section.add "X-Amz-SignedHeaders", valid_606892
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_606893: Call_GetCreateSnapshotSchedule_606875; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a snapshot schedule with the rate of every 12 hours.
  ## 
  let valid = call_606893.validator(path, query, header, formData, body)
  let scheme = call_606893.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_606893.url(scheme.get, call_606893.host, call_606893.base,
                         call_606893.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_606893, url, valid)

proc call*(call_606894: Call_GetCreateSnapshotSchedule_606875;
          Tags: JsonNode = nil; ScheduleIdentifier: string = ""; DryRun: bool = false;
          NextInvocations: int = 0; ScheduleDefinitions: JsonNode = nil;
          ScheduleDescription: string = "";
          Action: string = "CreateSnapshotSchedule"; Version: string = "2012-12-01"): Recallable =
  ## getCreateSnapshotSchedule
  ## Creates a snapshot schedule with the rate of every 12 hours.
  ##   Tags: JArray
  ##       : An optional set of tags you can use to search for the schedule.
  ##   ScheduleIdentifier: string
  ##                     : A unique identifier for a snapshot schedule. Only alphanumeric characters are allowed for the identifier.
  ##   DryRun: bool
  ##         : <p/>
  ##   NextInvocations: int
  ##                  : <p/>
  ##   ScheduleDefinitions: JArray
  ##                      : The definition of the snapshot schedule. The definition is made up of schedule expressions, for example "cron(30 12 *)" or "rate(12 hours)". 
  ##   ScheduleDescription: string
  ##                      : The description of the snapshot schedule.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_606895 = newJObject()
  if Tags != nil:
    query_606895.add "Tags", Tags
  add(query_606895, "ScheduleIdentifier", newJString(ScheduleIdentifier))
  add(query_606895, "DryRun", newJBool(DryRun))
  add(query_606895, "NextInvocations", newJInt(NextInvocations))
  if ScheduleDefinitions != nil:
    query_606895.add "ScheduleDefinitions", ScheduleDefinitions
  add(query_606895, "ScheduleDescription", newJString(ScheduleDescription))
  add(query_606895, "Action", newJString(Action))
  add(query_606895, "Version", newJString(Version))
  result = call_606894.call(nil, query_606895, nil, nil, nil)

var getCreateSnapshotSchedule* = Call_GetCreateSnapshotSchedule_606875(
    name: "getCreateSnapshotSchedule", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=CreateSnapshotSchedule",
    validator: validate_GetCreateSnapshotSchedule_606876, base: "/",
    url: url_GetCreateSnapshotSchedule_606877,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCreateTags_606935 = ref object of OpenApiRestCall_605573
proc url_PostCreateTags_606937(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostCreateTags_606936(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode): JsonNode =
  ## <p>Adds tags to a cluster.</p> <p>A resource can have up to 50 tags. If you try to create more than 50 tags for a resource, you will receive an error and the attempt will fail.</p> <p>If you specify a key that already exists for the resource, the value for that key will be updated with the new value.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_606938 = query.getOrDefault("Action")
  valid_606938 = validateParameter(valid_606938, JString, required = true,
                                 default = newJString("CreateTags"))
  if valid_606938 != nil:
    section.add "Action", valid_606938
  var valid_606939 = query.getOrDefault("Version")
  valid_606939 = validateParameter(valid_606939, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_606939 != nil:
    section.add "Version", valid_606939
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_606940 = header.getOrDefault("X-Amz-Signature")
  valid_606940 = validateParameter(valid_606940, JString, required = false,
                                 default = nil)
  if valid_606940 != nil:
    section.add "X-Amz-Signature", valid_606940
  var valid_606941 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_606941 = validateParameter(valid_606941, JString, required = false,
                                 default = nil)
  if valid_606941 != nil:
    section.add "X-Amz-Content-Sha256", valid_606941
  var valid_606942 = header.getOrDefault("X-Amz-Date")
  valid_606942 = validateParameter(valid_606942, JString, required = false,
                                 default = nil)
  if valid_606942 != nil:
    section.add "X-Amz-Date", valid_606942
  var valid_606943 = header.getOrDefault("X-Amz-Credential")
  valid_606943 = validateParameter(valid_606943, JString, required = false,
                                 default = nil)
  if valid_606943 != nil:
    section.add "X-Amz-Credential", valid_606943
  var valid_606944 = header.getOrDefault("X-Amz-Security-Token")
  valid_606944 = validateParameter(valid_606944, JString, required = false,
                                 default = nil)
  if valid_606944 != nil:
    section.add "X-Amz-Security-Token", valid_606944
  var valid_606945 = header.getOrDefault("X-Amz-Algorithm")
  valid_606945 = validateParameter(valid_606945, JString, required = false,
                                 default = nil)
  if valid_606945 != nil:
    section.add "X-Amz-Algorithm", valid_606945
  var valid_606946 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_606946 = validateParameter(valid_606946, JString, required = false,
                                 default = nil)
  if valid_606946 != nil:
    section.add "X-Amz-SignedHeaders", valid_606946
  result.add "header", section
  ## parameters in `formData` object:
  ##   Tags: JArray (required)
  ##       : One or more name/value pairs to add as tags to the specified resource. Each tag name is passed in with the parameter <code>Key</code> and the corresponding value is passed in with the parameter <code>Value</code>. The <code>Key</code> and <code>Value</code> parameters are separated by a comma (,). Separate multiple tags with a space. For example, <code>--tags "Key"="owner","Value"="admin" "Key"="environment","Value"="test" "Key"="version","Value"="1.0"</code>. 
  ##   ResourceName: JString (required)
  ##               : The Amazon Resource Name (ARN) to which you want to add the tag or tags. For example, <code>arn:aws:redshift:us-east-2:123456789:cluster:t1</code>. 
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `Tags` field"
  var valid_606947 = formData.getOrDefault("Tags")
  valid_606947 = validateParameter(valid_606947, JArray, required = true, default = nil)
  if valid_606947 != nil:
    section.add "Tags", valid_606947
  var valid_606948 = formData.getOrDefault("ResourceName")
  valid_606948 = validateParameter(valid_606948, JString, required = true,
                                 default = nil)
  if valid_606948 != nil:
    section.add "ResourceName", valid_606948
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_606949: Call_PostCreateTags_606935; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Adds tags to a cluster.</p> <p>A resource can have up to 50 tags. If you try to create more than 50 tags for a resource, you will receive an error and the attempt will fail.</p> <p>If you specify a key that already exists for the resource, the value for that key will be updated with the new value.</p>
  ## 
  let valid = call_606949.validator(path, query, header, formData, body)
  let scheme = call_606949.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_606949.url(scheme.get, call_606949.host, call_606949.base,
                         call_606949.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_606949, url, valid)

proc call*(call_606950: Call_PostCreateTags_606935; Tags: JsonNode;
          ResourceName: string; Action: string = "CreateTags";
          Version: string = "2012-12-01"): Recallable =
  ## postCreateTags
  ## <p>Adds tags to a cluster.</p> <p>A resource can have up to 50 tags. If you try to create more than 50 tags for a resource, you will receive an error and the attempt will fail.</p> <p>If you specify a key that already exists for the resource, the value for that key will be updated with the new value.</p>
  ##   Action: string (required)
  ##   Tags: JArray (required)
  ##       : One or more name/value pairs to add as tags to the specified resource. Each tag name is passed in with the parameter <code>Key</code> and the corresponding value is passed in with the parameter <code>Value</code>. The <code>Key</code> and <code>Value</code> parameters are separated by a comma (,). Separate multiple tags with a space. For example, <code>--tags "Key"="owner","Value"="admin" "Key"="environment","Value"="test" "Key"="version","Value"="1.0"</code>. 
  ##   Version: string (required)
  ##   ResourceName: string (required)
  ##               : The Amazon Resource Name (ARN) to which you want to add the tag or tags. For example, <code>arn:aws:redshift:us-east-2:123456789:cluster:t1</code>. 
  var query_606951 = newJObject()
  var formData_606952 = newJObject()
  add(query_606951, "Action", newJString(Action))
  if Tags != nil:
    formData_606952.add "Tags", Tags
  add(query_606951, "Version", newJString(Version))
  add(formData_606952, "ResourceName", newJString(ResourceName))
  result = call_606950.call(nil, query_606951, nil, formData_606952, nil)

var postCreateTags* = Call_PostCreateTags_606935(name: "postCreateTags",
    meth: HttpMethod.HttpPost, host: "redshift.amazonaws.com",
    route: "/#Action=CreateTags", validator: validate_PostCreateTags_606936,
    base: "/", url: url_PostCreateTags_606937, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCreateTags_606918 = ref object of OpenApiRestCall_605573
proc url_GetCreateTags_606920(protocol: Scheme; host: string; base: string;
                             route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetCreateTags_606919(path: JsonNode; query: JsonNode; header: JsonNode;
                                  formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Adds tags to a cluster.</p> <p>A resource can have up to 50 tags. If you try to create more than 50 tags for a resource, you will receive an error and the attempt will fail.</p> <p>If you specify a key that already exists for the resource, the value for that key will be updated with the new value.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Tags: JArray (required)
  ##       : One or more name/value pairs to add as tags to the specified resource. Each tag name is passed in with the parameter <code>Key</code> and the corresponding value is passed in with the parameter <code>Value</code>. The <code>Key</code> and <code>Value</code> parameters are separated by a comma (,). Separate multiple tags with a space. For example, <code>--tags "Key"="owner","Value"="admin" "Key"="environment","Value"="test" "Key"="version","Value"="1.0"</code>. 
  ##   ResourceName: JString (required)
  ##               : The Amazon Resource Name (ARN) to which you want to add the tag or tags. For example, <code>arn:aws:redshift:us-east-2:123456789:cluster:t1</code>. 
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Tags` field"
  var valid_606921 = query.getOrDefault("Tags")
  valid_606921 = validateParameter(valid_606921, JArray, required = true, default = nil)
  if valid_606921 != nil:
    section.add "Tags", valid_606921
  var valid_606922 = query.getOrDefault("ResourceName")
  valid_606922 = validateParameter(valid_606922, JString, required = true,
                                 default = nil)
  if valid_606922 != nil:
    section.add "ResourceName", valid_606922
  var valid_606923 = query.getOrDefault("Action")
  valid_606923 = validateParameter(valid_606923, JString, required = true,
                                 default = newJString("CreateTags"))
  if valid_606923 != nil:
    section.add "Action", valid_606923
  var valid_606924 = query.getOrDefault("Version")
  valid_606924 = validateParameter(valid_606924, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_606924 != nil:
    section.add "Version", valid_606924
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_606925 = header.getOrDefault("X-Amz-Signature")
  valid_606925 = validateParameter(valid_606925, JString, required = false,
                                 default = nil)
  if valid_606925 != nil:
    section.add "X-Amz-Signature", valid_606925
  var valid_606926 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_606926 = validateParameter(valid_606926, JString, required = false,
                                 default = nil)
  if valid_606926 != nil:
    section.add "X-Amz-Content-Sha256", valid_606926
  var valid_606927 = header.getOrDefault("X-Amz-Date")
  valid_606927 = validateParameter(valid_606927, JString, required = false,
                                 default = nil)
  if valid_606927 != nil:
    section.add "X-Amz-Date", valid_606927
  var valid_606928 = header.getOrDefault("X-Amz-Credential")
  valid_606928 = validateParameter(valid_606928, JString, required = false,
                                 default = nil)
  if valid_606928 != nil:
    section.add "X-Amz-Credential", valid_606928
  var valid_606929 = header.getOrDefault("X-Amz-Security-Token")
  valid_606929 = validateParameter(valid_606929, JString, required = false,
                                 default = nil)
  if valid_606929 != nil:
    section.add "X-Amz-Security-Token", valid_606929
  var valid_606930 = header.getOrDefault("X-Amz-Algorithm")
  valid_606930 = validateParameter(valid_606930, JString, required = false,
                                 default = nil)
  if valid_606930 != nil:
    section.add "X-Amz-Algorithm", valid_606930
  var valid_606931 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_606931 = validateParameter(valid_606931, JString, required = false,
                                 default = nil)
  if valid_606931 != nil:
    section.add "X-Amz-SignedHeaders", valid_606931
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_606932: Call_GetCreateTags_606918; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Adds tags to a cluster.</p> <p>A resource can have up to 50 tags. If you try to create more than 50 tags for a resource, you will receive an error and the attempt will fail.</p> <p>If you specify a key that already exists for the resource, the value for that key will be updated with the new value.</p>
  ## 
  let valid = call_606932.validator(path, query, header, formData, body)
  let scheme = call_606932.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_606932.url(scheme.get, call_606932.host, call_606932.base,
                         call_606932.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_606932, url, valid)

proc call*(call_606933: Call_GetCreateTags_606918; Tags: JsonNode;
          ResourceName: string; Action: string = "CreateTags";
          Version: string = "2012-12-01"): Recallable =
  ## getCreateTags
  ## <p>Adds tags to a cluster.</p> <p>A resource can have up to 50 tags. If you try to create more than 50 tags for a resource, you will receive an error and the attempt will fail.</p> <p>If you specify a key that already exists for the resource, the value for that key will be updated with the new value.</p>
  ##   Tags: JArray (required)
  ##       : One or more name/value pairs to add as tags to the specified resource. Each tag name is passed in with the parameter <code>Key</code> and the corresponding value is passed in with the parameter <code>Value</code>. The <code>Key</code> and <code>Value</code> parameters are separated by a comma (,). Separate multiple tags with a space. For example, <code>--tags "Key"="owner","Value"="admin" "Key"="environment","Value"="test" "Key"="version","Value"="1.0"</code>. 
  ##   ResourceName: string (required)
  ##               : The Amazon Resource Name (ARN) to which you want to add the tag or tags. For example, <code>arn:aws:redshift:us-east-2:123456789:cluster:t1</code>. 
  ##   Action: string (required)
  ##   Version: string (required)
  var query_606934 = newJObject()
  if Tags != nil:
    query_606934.add "Tags", Tags
  add(query_606934, "ResourceName", newJString(ResourceName))
  add(query_606934, "Action", newJString(Action))
  add(query_606934, "Version", newJString(Version))
  result = call_606933.call(nil, query_606934, nil, nil, nil)

var getCreateTags* = Call_GetCreateTags_606918(name: "getCreateTags",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=CreateTags", validator: validate_GetCreateTags_606919,
    base: "/", url: url_GetCreateTags_606920, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDeleteCluster_606972 = ref object of OpenApiRestCall_605573
proc url_PostDeleteCluster_606974(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDeleteCluster_606973(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## <p>Deletes a previously provisioned cluster without its final snapshot being created. A successful response from the web service indicates that the request was received correctly. Use <a>DescribeClusters</a> to monitor the status of the deletion. The delete operation cannot be canceled or reverted once submitted. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you want to shut down the cluster and retain it for future use, set <i>SkipFinalClusterSnapshot</i> to <code>false</code> and specify a name for <i>FinalClusterSnapshotIdentifier</i>. You can later restore this snapshot to resume using the cluster. If a final cluster snapshot is requested, the status of the cluster will be "final-snapshot" while the snapshot is being taken, then it's "deleting" once Amazon Redshift begins deleting the cluster. </p> <p> For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_606975 = query.getOrDefault("Action")
  valid_606975 = validateParameter(valid_606975, JString, required = true,
                                 default = newJString("DeleteCluster"))
  if valid_606975 != nil:
    section.add "Action", valid_606975
  var valid_606976 = query.getOrDefault("Version")
  valid_606976 = validateParameter(valid_606976, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_606976 != nil:
    section.add "Version", valid_606976
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_606977 = header.getOrDefault("X-Amz-Signature")
  valid_606977 = validateParameter(valid_606977, JString, required = false,
                                 default = nil)
  if valid_606977 != nil:
    section.add "X-Amz-Signature", valid_606977
  var valid_606978 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_606978 = validateParameter(valid_606978, JString, required = false,
                                 default = nil)
  if valid_606978 != nil:
    section.add "X-Amz-Content-Sha256", valid_606978
  var valid_606979 = header.getOrDefault("X-Amz-Date")
  valid_606979 = validateParameter(valid_606979, JString, required = false,
                                 default = nil)
  if valid_606979 != nil:
    section.add "X-Amz-Date", valid_606979
  var valid_606980 = header.getOrDefault("X-Amz-Credential")
  valid_606980 = validateParameter(valid_606980, JString, required = false,
                                 default = nil)
  if valid_606980 != nil:
    section.add "X-Amz-Credential", valid_606980
  var valid_606981 = header.getOrDefault("X-Amz-Security-Token")
  valid_606981 = validateParameter(valid_606981, JString, required = false,
                                 default = nil)
  if valid_606981 != nil:
    section.add "X-Amz-Security-Token", valid_606981
  var valid_606982 = header.getOrDefault("X-Amz-Algorithm")
  valid_606982 = validateParameter(valid_606982, JString, required = false,
                                 default = nil)
  if valid_606982 != nil:
    section.add "X-Amz-Algorithm", valid_606982
  var valid_606983 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_606983 = validateParameter(valid_606983, JString, required = false,
                                 default = nil)
  if valid_606983 != nil:
    section.add "X-Amz-SignedHeaders", valid_606983
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The identifier of the cluster to be deleted.</p> <p>Constraints:</p> <ul> <li> <p>Must contain lowercase characters.</p> </li> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   FinalClusterSnapshotIdentifier: JString
  ##                                 : <p>The identifier of the final snapshot that is to be created immediately before deleting the cluster. If this parameter is provided, <i>SkipFinalClusterSnapshot</i> must be <code>false</code>. </p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   FinalClusterSnapshotRetentionPeriod: JInt
  ##                                      : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  ##   SkipFinalClusterSnapshot: JBool
  ##                           : <p>Determines whether a final snapshot of the cluster is created before Amazon Redshift deletes the cluster. If <code>true</code>, a final cluster snapshot is not created. If <code>false</code>, a final cluster snapshot is created before the cluster is deleted. </p> <note> <p>The <i>FinalClusterSnapshotIdentifier</i> parameter must be specified if <i>SkipFinalClusterSnapshot</i> is <code>false</code>.</p> </note> <p>Default: <code>false</code> </p>
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_606984 = formData.getOrDefault("ClusterIdentifier")
  valid_606984 = validateParameter(valid_606984, JString, required = true,
                                 default = nil)
  if valid_606984 != nil:
    section.add "ClusterIdentifier", valid_606984
  var valid_606985 = formData.getOrDefault("FinalClusterSnapshotIdentifier")
  valid_606985 = validateParameter(valid_606985, JString, required = false,
                                 default = nil)
  if valid_606985 != nil:
    section.add "FinalClusterSnapshotIdentifier", valid_606985
  var valid_606986 = formData.getOrDefault("FinalClusterSnapshotRetentionPeriod")
  valid_606986 = validateParameter(valid_606986, JInt, required = false, default = nil)
  if valid_606986 != nil:
    section.add "FinalClusterSnapshotRetentionPeriod", valid_606986
  var valid_606987 = formData.getOrDefault("SkipFinalClusterSnapshot")
  valid_606987 = validateParameter(valid_606987, JBool, required = false, default = nil)
  if valid_606987 != nil:
    section.add "SkipFinalClusterSnapshot", valid_606987
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_606988: Call_PostDeleteCluster_606972; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Deletes a previously provisioned cluster without its final snapshot being created. A successful response from the web service indicates that the request was received correctly. Use <a>DescribeClusters</a> to monitor the status of the deletion. The delete operation cannot be canceled or reverted once submitted. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you want to shut down the cluster and retain it for future use, set <i>SkipFinalClusterSnapshot</i> to <code>false</code> and specify a name for <i>FinalClusterSnapshotIdentifier</i>. You can later restore this snapshot to resume using the cluster. If a final cluster snapshot is requested, the status of the cluster will be "final-snapshot" while the snapshot is being taken, then it's "deleting" once Amazon Redshift begins deleting the cluster. </p> <p> For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_606988.validator(path, query, header, formData, body)
  let scheme = call_606988.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_606988.url(scheme.get, call_606988.host, call_606988.base,
                         call_606988.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_606988, url, valid)

proc call*(call_606989: Call_PostDeleteCluster_606972; ClusterIdentifier: string;
          FinalClusterSnapshotIdentifier: string = "";
          Action: string = "DeleteCluster";
          FinalClusterSnapshotRetentionPeriod: int = 0;
          Version: string = "2012-12-01"; SkipFinalClusterSnapshot: bool = false): Recallable =
  ## postDeleteCluster
  ## <p>Deletes a previously provisioned cluster without its final snapshot being created. A successful response from the web service indicates that the request was received correctly. Use <a>DescribeClusters</a> to monitor the status of the deletion. The delete operation cannot be canceled or reverted once submitted. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you want to shut down the cluster and retain it for future use, set <i>SkipFinalClusterSnapshot</i> to <code>false</code> and specify a name for <i>FinalClusterSnapshotIdentifier</i>. You can later restore this snapshot to resume using the cluster. If a final cluster snapshot is requested, the status of the cluster will be "final-snapshot" while the snapshot is being taken, then it's "deleting" once Amazon Redshift begins deleting the cluster. </p> <p> For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The identifier of the cluster to be deleted.</p> <p>Constraints:</p> <ul> <li> <p>Must contain lowercase characters.</p> </li> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   FinalClusterSnapshotIdentifier: string
  ##                                 : <p>The identifier of the final snapshot that is to be created immediately before deleting the cluster. If this parameter is provided, <i>SkipFinalClusterSnapshot</i> must be <code>false</code>. </p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   Action: string (required)
  ##   FinalClusterSnapshotRetentionPeriod: int
  ##                                      : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  ##   Version: string (required)
  ##   SkipFinalClusterSnapshot: bool
  ##                           : <p>Determines whether a final snapshot of the cluster is created before Amazon Redshift deletes the cluster. If <code>true</code>, a final cluster snapshot is not created. If <code>false</code>, a final cluster snapshot is created before the cluster is deleted. </p> <note> <p>The <i>FinalClusterSnapshotIdentifier</i> parameter must be specified if <i>SkipFinalClusterSnapshot</i> is <code>false</code>.</p> </note> <p>Default: <code>false</code> </p>
  var query_606990 = newJObject()
  var formData_606991 = newJObject()
  add(formData_606991, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_606991, "FinalClusterSnapshotIdentifier",
      newJString(FinalClusterSnapshotIdentifier))
  add(query_606990, "Action", newJString(Action))
  add(formData_606991, "FinalClusterSnapshotRetentionPeriod",
      newJInt(FinalClusterSnapshotRetentionPeriod))
  add(query_606990, "Version", newJString(Version))
  add(formData_606991, "SkipFinalClusterSnapshot",
      newJBool(SkipFinalClusterSnapshot))
  result = call_606989.call(nil, query_606990, nil, formData_606991, nil)

var postDeleteCluster* = Call_PostDeleteCluster_606972(name: "postDeleteCluster",
    meth: HttpMethod.HttpPost, host: "redshift.amazonaws.com",
    route: "/#Action=DeleteCluster", validator: validate_PostDeleteCluster_606973,
    base: "/", url: url_PostDeleteCluster_606974,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeleteCluster_606953 = ref object of OpenApiRestCall_605573
proc url_GetDeleteCluster_606955(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDeleteCluster_606954(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## <p>Deletes a previously provisioned cluster without its final snapshot being created. A successful response from the web service indicates that the request was received correctly. Use <a>DescribeClusters</a> to monitor the status of the deletion. The delete operation cannot be canceled or reverted once submitted. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you want to shut down the cluster and retain it for future use, set <i>SkipFinalClusterSnapshot</i> to <code>false</code> and specify a name for <i>FinalClusterSnapshotIdentifier</i>. You can later restore this snapshot to resume using the cluster. If a final cluster snapshot is requested, the status of the cluster will be "final-snapshot" while the snapshot is being taken, then it's "deleting" once Amazon Redshift begins deleting the cluster. </p> <p> For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   SkipFinalClusterSnapshot: JBool
  ##                           : <p>Determines whether a final snapshot of the cluster is created before Amazon Redshift deletes the cluster. If <code>true</code>, a final cluster snapshot is not created. If <code>false</code>, a final cluster snapshot is created before the cluster is deleted. </p> <note> <p>The <i>FinalClusterSnapshotIdentifier</i> parameter must be specified if <i>SkipFinalClusterSnapshot</i> is <code>false</code>.</p> </note> <p>Default: <code>false</code> </p>
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The identifier of the cluster to be deleted.</p> <p>Constraints:</p> <ul> <li> <p>Must contain lowercase characters.</p> </li> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   Version: JString (required)
  ##   FinalClusterSnapshotIdentifier: JString
  ##                                 : <p>The identifier of the final snapshot that is to be created immediately before deleting the cluster. If this parameter is provided, <i>SkipFinalClusterSnapshot</i> must be <code>false</code>. </p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   FinalClusterSnapshotRetentionPeriod: JInt
  ##                                      : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  section = newJObject()
  var valid_606956 = query.getOrDefault("Action")
  valid_606956 = validateParameter(valid_606956, JString, required = true,
                                 default = newJString("DeleteCluster"))
  if valid_606956 != nil:
    section.add "Action", valid_606956
  var valid_606957 = query.getOrDefault("SkipFinalClusterSnapshot")
  valid_606957 = validateParameter(valid_606957, JBool, required = false, default = nil)
  if valid_606957 != nil:
    section.add "SkipFinalClusterSnapshot", valid_606957
  var valid_606958 = query.getOrDefault("ClusterIdentifier")
  valid_606958 = validateParameter(valid_606958, JString, required = true,
                                 default = nil)
  if valid_606958 != nil:
    section.add "ClusterIdentifier", valid_606958
  var valid_606959 = query.getOrDefault("Version")
  valid_606959 = validateParameter(valid_606959, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_606959 != nil:
    section.add "Version", valid_606959
  var valid_606960 = query.getOrDefault("FinalClusterSnapshotIdentifier")
  valid_606960 = validateParameter(valid_606960, JString, required = false,
                                 default = nil)
  if valid_606960 != nil:
    section.add "FinalClusterSnapshotIdentifier", valid_606960
  var valid_606961 = query.getOrDefault("FinalClusterSnapshotRetentionPeriod")
  valid_606961 = validateParameter(valid_606961, JInt, required = false, default = nil)
  if valid_606961 != nil:
    section.add "FinalClusterSnapshotRetentionPeriod", valid_606961
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_606962 = header.getOrDefault("X-Amz-Signature")
  valid_606962 = validateParameter(valid_606962, JString, required = false,
                                 default = nil)
  if valid_606962 != nil:
    section.add "X-Amz-Signature", valid_606962
  var valid_606963 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_606963 = validateParameter(valid_606963, JString, required = false,
                                 default = nil)
  if valid_606963 != nil:
    section.add "X-Amz-Content-Sha256", valid_606963
  var valid_606964 = header.getOrDefault("X-Amz-Date")
  valid_606964 = validateParameter(valid_606964, JString, required = false,
                                 default = nil)
  if valid_606964 != nil:
    section.add "X-Amz-Date", valid_606964
  var valid_606965 = header.getOrDefault("X-Amz-Credential")
  valid_606965 = validateParameter(valid_606965, JString, required = false,
                                 default = nil)
  if valid_606965 != nil:
    section.add "X-Amz-Credential", valid_606965
  var valid_606966 = header.getOrDefault("X-Amz-Security-Token")
  valid_606966 = validateParameter(valid_606966, JString, required = false,
                                 default = nil)
  if valid_606966 != nil:
    section.add "X-Amz-Security-Token", valid_606966
  var valid_606967 = header.getOrDefault("X-Amz-Algorithm")
  valid_606967 = validateParameter(valid_606967, JString, required = false,
                                 default = nil)
  if valid_606967 != nil:
    section.add "X-Amz-Algorithm", valid_606967
  var valid_606968 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_606968 = validateParameter(valid_606968, JString, required = false,
                                 default = nil)
  if valid_606968 != nil:
    section.add "X-Amz-SignedHeaders", valid_606968
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_606969: Call_GetDeleteCluster_606953; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Deletes a previously provisioned cluster without its final snapshot being created. A successful response from the web service indicates that the request was received correctly. Use <a>DescribeClusters</a> to monitor the status of the deletion. The delete operation cannot be canceled or reverted once submitted. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you want to shut down the cluster and retain it for future use, set <i>SkipFinalClusterSnapshot</i> to <code>false</code> and specify a name for <i>FinalClusterSnapshotIdentifier</i>. You can later restore this snapshot to resume using the cluster. If a final cluster snapshot is requested, the status of the cluster will be "final-snapshot" while the snapshot is being taken, then it's "deleting" once Amazon Redshift begins deleting the cluster. </p> <p> For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_606969.validator(path, query, header, formData, body)
  let scheme = call_606969.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_606969.url(scheme.get, call_606969.host, call_606969.base,
                         call_606969.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_606969, url, valid)

proc call*(call_606970: Call_GetDeleteCluster_606953; ClusterIdentifier: string;
          Action: string = "DeleteCluster"; SkipFinalClusterSnapshot: bool = false;
          Version: string = "2012-12-01";
          FinalClusterSnapshotIdentifier: string = "";
          FinalClusterSnapshotRetentionPeriod: int = 0): Recallable =
  ## getDeleteCluster
  ## <p>Deletes a previously provisioned cluster without its final snapshot being created. A successful response from the web service indicates that the request was received correctly. Use <a>DescribeClusters</a> to monitor the status of the deletion. The delete operation cannot be canceled or reverted once submitted. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you want to shut down the cluster and retain it for future use, set <i>SkipFinalClusterSnapshot</i> to <code>false</code> and specify a name for <i>FinalClusterSnapshotIdentifier</i>. You can later restore this snapshot to resume using the cluster. If a final cluster snapshot is requested, the status of the cluster will be "final-snapshot" while the snapshot is being taken, then it's "deleting" once Amazon Redshift begins deleting the cluster. </p> <p> For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   Action: string (required)
  ##   SkipFinalClusterSnapshot: bool
  ##                           : <p>Determines whether a final snapshot of the cluster is created before Amazon Redshift deletes the cluster. If <code>true</code>, a final cluster snapshot is not created. If <code>false</code>, a final cluster snapshot is created before the cluster is deleted. </p> <note> <p>The <i>FinalClusterSnapshotIdentifier</i> parameter must be specified if <i>SkipFinalClusterSnapshot</i> is <code>false</code>.</p> </note> <p>Default: <code>false</code> </p>
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The identifier of the cluster to be deleted.</p> <p>Constraints:</p> <ul> <li> <p>Must contain lowercase characters.</p> </li> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   Version: string (required)
  ##   FinalClusterSnapshotIdentifier: string
  ##                                 : <p>The identifier of the final snapshot that is to be created immediately before deleting the cluster. If this parameter is provided, <i>SkipFinalClusterSnapshot</i> must be <code>false</code>. </p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   FinalClusterSnapshotRetentionPeriod: int
  ##                                      : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  var query_606971 = newJObject()
  add(query_606971, "Action", newJString(Action))
  add(query_606971, "SkipFinalClusterSnapshot", newJBool(SkipFinalClusterSnapshot))
  add(query_606971, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_606971, "Version", newJString(Version))
  add(query_606971, "FinalClusterSnapshotIdentifier",
      newJString(FinalClusterSnapshotIdentifier))
  add(query_606971, "FinalClusterSnapshotRetentionPeriod",
      newJInt(FinalClusterSnapshotRetentionPeriod))
  result = call_606970.call(nil, query_606971, nil, nil, nil)

var getDeleteCluster* = Call_GetDeleteCluster_606953(name: "getDeleteCluster",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=DeleteCluster", validator: validate_GetDeleteCluster_606954,
    base: "/", url: url_GetDeleteCluster_606955,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDeleteClusterParameterGroup_607008 = ref object of OpenApiRestCall_605573
proc url_PostDeleteClusterParameterGroup_607010(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDeleteClusterParameterGroup_607009(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Deletes a specified Amazon Redshift parameter group.</p> <note> <p>You cannot delete a parameter group if it is associated with a cluster.</p> </note>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_607011 = query.getOrDefault("Action")
  valid_607011 = validateParameter(valid_607011, JString, required = true, default = newJString(
      "DeleteClusterParameterGroup"))
  if valid_607011 != nil:
    section.add "Action", valid_607011
  var valid_607012 = query.getOrDefault("Version")
  valid_607012 = validateParameter(valid_607012, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_607012 != nil:
    section.add "Version", valid_607012
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_607013 = header.getOrDefault("X-Amz-Signature")
  valid_607013 = validateParameter(valid_607013, JString, required = false,
                                 default = nil)
  if valid_607013 != nil:
    section.add "X-Amz-Signature", valid_607013
  var valid_607014 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_607014 = validateParameter(valid_607014, JString, required = false,
                                 default = nil)
  if valid_607014 != nil:
    section.add "X-Amz-Content-Sha256", valid_607014
  var valid_607015 = header.getOrDefault("X-Amz-Date")
  valid_607015 = validateParameter(valid_607015, JString, required = false,
                                 default = nil)
  if valid_607015 != nil:
    section.add "X-Amz-Date", valid_607015
  var valid_607016 = header.getOrDefault("X-Amz-Credential")
  valid_607016 = validateParameter(valid_607016, JString, required = false,
                                 default = nil)
  if valid_607016 != nil:
    section.add "X-Amz-Credential", valid_607016
  var valid_607017 = header.getOrDefault("X-Amz-Security-Token")
  valid_607017 = validateParameter(valid_607017, JString, required = false,
                                 default = nil)
  if valid_607017 != nil:
    section.add "X-Amz-Security-Token", valid_607017
  var valid_607018 = header.getOrDefault("X-Amz-Algorithm")
  valid_607018 = validateParameter(valid_607018, JString, required = false,
                                 default = nil)
  if valid_607018 != nil:
    section.add "X-Amz-Algorithm", valid_607018
  var valid_607019 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_607019 = validateParameter(valid_607019, JString, required = false,
                                 default = nil)
  if valid_607019 != nil:
    section.add "X-Amz-SignedHeaders", valid_607019
  result.add "header", section
  ## parameters in `formData` object:
  ##   ParameterGroupName: JString (required)
  ##                     : <p>The name of the parameter group to be deleted.</p> <p>Constraints:</p> <ul> <li> <p>Must be the name of an existing cluster parameter group.</p> </li> <li> <p>Cannot delete a default cluster parameter group.</p> </li> </ul>
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ParameterGroupName` field"
  var valid_607020 = formData.getOrDefault("ParameterGroupName")
  valid_607020 = validateParameter(valid_607020, JString, required = true,
                                 default = nil)
  if valid_607020 != nil:
    section.add "ParameterGroupName", valid_607020
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_607021: Call_PostDeleteClusterParameterGroup_607008;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Deletes a specified Amazon Redshift parameter group.</p> <note> <p>You cannot delete a parameter group if it is associated with a cluster.</p> </note>
  ## 
  let valid = call_607021.validator(path, query, header, formData, body)
  let scheme = call_607021.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_607021.url(scheme.get, call_607021.host, call_607021.base,
                         call_607021.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_607021, url, valid)

proc call*(call_607022: Call_PostDeleteClusterParameterGroup_607008;
          ParameterGroupName: string;
          Action: string = "DeleteClusterParameterGroup";
          Version: string = "2012-12-01"): Recallable =
  ## postDeleteClusterParameterGroup
  ## <p>Deletes a specified Amazon Redshift parameter group.</p> <note> <p>You cannot delete a parameter group if it is associated with a cluster.</p> </note>
  ##   Action: string (required)
  ##   ParameterGroupName: string (required)
  ##                     : <p>The name of the parameter group to be deleted.</p> <p>Constraints:</p> <ul> <li> <p>Must be the name of an existing cluster parameter group.</p> </li> <li> <p>Cannot delete a default cluster parameter group.</p> </li> </ul>
  ##   Version: string (required)
  var query_607023 = newJObject()
  var formData_607024 = newJObject()
  add(query_607023, "Action", newJString(Action))
  add(formData_607024, "ParameterGroupName", newJString(ParameterGroupName))
  add(query_607023, "Version", newJString(Version))
  result = call_607022.call(nil, query_607023, nil, formData_607024, nil)

var postDeleteClusterParameterGroup* = Call_PostDeleteClusterParameterGroup_607008(
    name: "postDeleteClusterParameterGroup", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteClusterParameterGroup",
    validator: validate_PostDeleteClusterParameterGroup_607009, base: "/",
    url: url_PostDeleteClusterParameterGroup_607010,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeleteClusterParameterGroup_606992 = ref object of OpenApiRestCall_605573
proc url_GetDeleteClusterParameterGroup_606994(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDeleteClusterParameterGroup_606993(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Deletes a specified Amazon Redshift parameter group.</p> <note> <p>You cannot delete a parameter group if it is associated with a cluster.</p> </note>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   ParameterGroupName: JString (required)
  ##                     : <p>The name of the parameter group to be deleted.</p> <p>Constraints:</p> <ul> <li> <p>Must be the name of an existing cluster parameter group.</p> </li> <li> <p>Cannot delete a default cluster parameter group.</p> </li> </ul>
  ##   Version: JString (required)
  section = newJObject()
  var valid_606995 = query.getOrDefault("Action")
  valid_606995 = validateParameter(valid_606995, JString, required = true, default = newJString(
      "DeleteClusterParameterGroup"))
  if valid_606995 != nil:
    section.add "Action", valid_606995
  var valid_606996 = query.getOrDefault("ParameterGroupName")
  valid_606996 = validateParameter(valid_606996, JString, required = true,
                                 default = nil)
  if valid_606996 != nil:
    section.add "ParameterGroupName", valid_606996
  var valid_606997 = query.getOrDefault("Version")
  valid_606997 = validateParameter(valid_606997, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_606997 != nil:
    section.add "Version", valid_606997
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_606998 = header.getOrDefault("X-Amz-Signature")
  valid_606998 = validateParameter(valid_606998, JString, required = false,
                                 default = nil)
  if valid_606998 != nil:
    section.add "X-Amz-Signature", valid_606998
  var valid_606999 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_606999 = validateParameter(valid_606999, JString, required = false,
                                 default = nil)
  if valid_606999 != nil:
    section.add "X-Amz-Content-Sha256", valid_606999
  var valid_607000 = header.getOrDefault("X-Amz-Date")
  valid_607000 = validateParameter(valid_607000, JString, required = false,
                                 default = nil)
  if valid_607000 != nil:
    section.add "X-Amz-Date", valid_607000
  var valid_607001 = header.getOrDefault("X-Amz-Credential")
  valid_607001 = validateParameter(valid_607001, JString, required = false,
                                 default = nil)
  if valid_607001 != nil:
    section.add "X-Amz-Credential", valid_607001
  var valid_607002 = header.getOrDefault("X-Amz-Security-Token")
  valid_607002 = validateParameter(valid_607002, JString, required = false,
                                 default = nil)
  if valid_607002 != nil:
    section.add "X-Amz-Security-Token", valid_607002
  var valid_607003 = header.getOrDefault("X-Amz-Algorithm")
  valid_607003 = validateParameter(valid_607003, JString, required = false,
                                 default = nil)
  if valid_607003 != nil:
    section.add "X-Amz-Algorithm", valid_607003
  var valid_607004 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_607004 = validateParameter(valid_607004, JString, required = false,
                                 default = nil)
  if valid_607004 != nil:
    section.add "X-Amz-SignedHeaders", valid_607004
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_607005: Call_GetDeleteClusterParameterGroup_606992; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Deletes a specified Amazon Redshift parameter group.</p> <note> <p>You cannot delete a parameter group if it is associated with a cluster.</p> </note>
  ## 
  let valid = call_607005.validator(path, query, header, formData, body)
  let scheme = call_607005.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_607005.url(scheme.get, call_607005.host, call_607005.base,
                         call_607005.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_607005, url, valid)

proc call*(call_607006: Call_GetDeleteClusterParameterGroup_606992;
          ParameterGroupName: string;
          Action: string = "DeleteClusterParameterGroup";
          Version: string = "2012-12-01"): Recallable =
  ## getDeleteClusterParameterGroup
  ## <p>Deletes a specified Amazon Redshift parameter group.</p> <note> <p>You cannot delete a parameter group if it is associated with a cluster.</p> </note>
  ##   Action: string (required)
  ##   ParameterGroupName: string (required)
  ##                     : <p>The name of the parameter group to be deleted.</p> <p>Constraints:</p> <ul> <li> <p>Must be the name of an existing cluster parameter group.</p> </li> <li> <p>Cannot delete a default cluster parameter group.</p> </li> </ul>
  ##   Version: string (required)
  var query_607007 = newJObject()
  add(query_607007, "Action", newJString(Action))
  add(query_607007, "ParameterGroupName", newJString(ParameterGroupName))
  add(query_607007, "Version", newJString(Version))
  result = call_607006.call(nil, query_607007, nil, nil, nil)

var getDeleteClusterParameterGroup* = Call_GetDeleteClusterParameterGroup_606992(
    name: "getDeleteClusterParameterGroup", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteClusterParameterGroup",
    validator: validate_GetDeleteClusterParameterGroup_606993, base: "/",
    url: url_GetDeleteClusterParameterGroup_606994,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDeleteClusterSecurityGroup_607041 = ref object of OpenApiRestCall_605573
proc url_PostDeleteClusterSecurityGroup_607043(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDeleteClusterSecurityGroup_607042(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Deletes an Amazon Redshift security group.</p> <note> <p>You cannot delete a security group that is associated with any clusters. You cannot delete the default security group.</p> </note> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_607044 = query.getOrDefault("Action")
  valid_607044 = validateParameter(valid_607044, JString, required = true, default = newJString(
      "DeleteClusterSecurityGroup"))
  if valid_607044 != nil:
    section.add "Action", valid_607044
  var valid_607045 = query.getOrDefault("Version")
  valid_607045 = validateParameter(valid_607045, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_607045 != nil:
    section.add "Version", valid_607045
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_607046 = header.getOrDefault("X-Amz-Signature")
  valid_607046 = validateParameter(valid_607046, JString, required = false,
                                 default = nil)
  if valid_607046 != nil:
    section.add "X-Amz-Signature", valid_607046
  var valid_607047 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_607047 = validateParameter(valid_607047, JString, required = false,
                                 default = nil)
  if valid_607047 != nil:
    section.add "X-Amz-Content-Sha256", valid_607047
  var valid_607048 = header.getOrDefault("X-Amz-Date")
  valid_607048 = validateParameter(valid_607048, JString, required = false,
                                 default = nil)
  if valid_607048 != nil:
    section.add "X-Amz-Date", valid_607048
  var valid_607049 = header.getOrDefault("X-Amz-Credential")
  valid_607049 = validateParameter(valid_607049, JString, required = false,
                                 default = nil)
  if valid_607049 != nil:
    section.add "X-Amz-Credential", valid_607049
  var valid_607050 = header.getOrDefault("X-Amz-Security-Token")
  valid_607050 = validateParameter(valid_607050, JString, required = false,
                                 default = nil)
  if valid_607050 != nil:
    section.add "X-Amz-Security-Token", valid_607050
  var valid_607051 = header.getOrDefault("X-Amz-Algorithm")
  valid_607051 = validateParameter(valid_607051, JString, required = false,
                                 default = nil)
  if valid_607051 != nil:
    section.add "X-Amz-Algorithm", valid_607051
  var valid_607052 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_607052 = validateParameter(valid_607052, JString, required = false,
                                 default = nil)
  if valid_607052 != nil:
    section.add "X-Amz-SignedHeaders", valid_607052
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterSecurityGroupName: JString (required)
  ##                           : The name of the cluster security group to be deleted.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterSecurityGroupName` field"
  var valid_607053 = formData.getOrDefault("ClusterSecurityGroupName")
  valid_607053 = validateParameter(valid_607053, JString, required = true,
                                 default = nil)
  if valid_607053 != nil:
    section.add "ClusterSecurityGroupName", valid_607053
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_607054: Call_PostDeleteClusterSecurityGroup_607041; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Deletes an Amazon Redshift security group.</p> <note> <p>You cannot delete a security group that is associated with any clusters. You cannot delete the default security group.</p> </note> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_607054.validator(path, query, header, formData, body)
  let scheme = call_607054.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_607054.url(scheme.get, call_607054.host, call_607054.base,
                         call_607054.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_607054, url, valid)

proc call*(call_607055: Call_PostDeleteClusterSecurityGroup_607041;
          ClusterSecurityGroupName: string;
          Action: string = "DeleteClusterSecurityGroup";
          Version: string = "2012-12-01"): Recallable =
  ## postDeleteClusterSecurityGroup
  ## <p>Deletes an Amazon Redshift security group.</p> <note> <p>You cannot delete a security group that is associated with any clusters. You cannot delete the default security group.</p> </note> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   ClusterSecurityGroupName: string (required)
  ##                           : The name of the cluster security group to be deleted.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_607056 = newJObject()
  var formData_607057 = newJObject()
  add(formData_607057, "ClusterSecurityGroupName",
      newJString(ClusterSecurityGroupName))
  add(query_607056, "Action", newJString(Action))
  add(query_607056, "Version", newJString(Version))
  result = call_607055.call(nil, query_607056, nil, formData_607057, nil)

var postDeleteClusterSecurityGroup* = Call_PostDeleteClusterSecurityGroup_607041(
    name: "postDeleteClusterSecurityGroup", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteClusterSecurityGroup",
    validator: validate_PostDeleteClusterSecurityGroup_607042, base: "/",
    url: url_PostDeleteClusterSecurityGroup_607043,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeleteClusterSecurityGroup_607025 = ref object of OpenApiRestCall_605573
proc url_GetDeleteClusterSecurityGroup_607027(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDeleteClusterSecurityGroup_607026(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Deletes an Amazon Redshift security group.</p> <note> <p>You cannot delete a security group that is associated with any clusters. You cannot delete the default security group.</p> </note> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ClusterSecurityGroupName: JString (required)
  ##                           : The name of the cluster security group to be deleted.
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `ClusterSecurityGroupName` field"
  var valid_607028 = query.getOrDefault("ClusterSecurityGroupName")
  valid_607028 = validateParameter(valid_607028, JString, required = true,
                                 default = nil)
  if valid_607028 != nil:
    section.add "ClusterSecurityGroupName", valid_607028
  var valid_607029 = query.getOrDefault("Action")
  valid_607029 = validateParameter(valid_607029, JString, required = true, default = newJString(
      "DeleteClusterSecurityGroup"))
  if valid_607029 != nil:
    section.add "Action", valid_607029
  var valid_607030 = query.getOrDefault("Version")
  valid_607030 = validateParameter(valid_607030, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_607030 != nil:
    section.add "Version", valid_607030
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_607031 = header.getOrDefault("X-Amz-Signature")
  valid_607031 = validateParameter(valid_607031, JString, required = false,
                                 default = nil)
  if valid_607031 != nil:
    section.add "X-Amz-Signature", valid_607031
  var valid_607032 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_607032 = validateParameter(valid_607032, JString, required = false,
                                 default = nil)
  if valid_607032 != nil:
    section.add "X-Amz-Content-Sha256", valid_607032
  var valid_607033 = header.getOrDefault("X-Amz-Date")
  valid_607033 = validateParameter(valid_607033, JString, required = false,
                                 default = nil)
  if valid_607033 != nil:
    section.add "X-Amz-Date", valid_607033
  var valid_607034 = header.getOrDefault("X-Amz-Credential")
  valid_607034 = validateParameter(valid_607034, JString, required = false,
                                 default = nil)
  if valid_607034 != nil:
    section.add "X-Amz-Credential", valid_607034
  var valid_607035 = header.getOrDefault("X-Amz-Security-Token")
  valid_607035 = validateParameter(valid_607035, JString, required = false,
                                 default = nil)
  if valid_607035 != nil:
    section.add "X-Amz-Security-Token", valid_607035
  var valid_607036 = header.getOrDefault("X-Amz-Algorithm")
  valid_607036 = validateParameter(valid_607036, JString, required = false,
                                 default = nil)
  if valid_607036 != nil:
    section.add "X-Amz-Algorithm", valid_607036
  var valid_607037 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_607037 = validateParameter(valid_607037, JString, required = false,
                                 default = nil)
  if valid_607037 != nil:
    section.add "X-Amz-SignedHeaders", valid_607037
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_607038: Call_GetDeleteClusterSecurityGroup_607025; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Deletes an Amazon Redshift security group.</p> <note> <p>You cannot delete a security group that is associated with any clusters. You cannot delete the default security group.</p> </note> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_607038.validator(path, query, header, formData, body)
  let scheme = call_607038.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_607038.url(scheme.get, call_607038.host, call_607038.base,
                         call_607038.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_607038, url, valid)

proc call*(call_607039: Call_GetDeleteClusterSecurityGroup_607025;
          ClusterSecurityGroupName: string;
          Action: string = "DeleteClusterSecurityGroup";
          Version: string = "2012-12-01"): Recallable =
  ## getDeleteClusterSecurityGroup
  ## <p>Deletes an Amazon Redshift security group.</p> <note> <p>You cannot delete a security group that is associated with any clusters. You cannot delete the default security group.</p> </note> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   ClusterSecurityGroupName: string (required)
  ##                           : The name of the cluster security group to be deleted.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_607040 = newJObject()
  add(query_607040, "ClusterSecurityGroupName",
      newJString(ClusterSecurityGroupName))
  add(query_607040, "Action", newJString(Action))
  add(query_607040, "Version", newJString(Version))
  result = call_607039.call(nil, query_607040, nil, nil, nil)

var getDeleteClusterSecurityGroup* = Call_GetDeleteClusterSecurityGroup_607025(
    name: "getDeleteClusterSecurityGroup", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteClusterSecurityGroup",
    validator: validate_GetDeleteClusterSecurityGroup_607026, base: "/",
    url: url_GetDeleteClusterSecurityGroup_607027,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDeleteClusterSnapshot_607075 = ref object of OpenApiRestCall_605573
proc url_PostDeleteClusterSnapshot_607077(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDeleteClusterSnapshot_607076(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Deletes the specified manual snapshot. The snapshot must be in the <code>available</code> state, with no other users authorized to access the snapshot. </p> <p>Unlike automated snapshots, manual snapshots are retained even after you delete your cluster. Amazon Redshift does not delete your manual snapshots. You must delete manual snapshot explicitly to avoid getting charged. If other accounts are authorized to access the snapshot, you must revoke all of the authorizations before you can delete the snapshot.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_607078 = query.getOrDefault("Action")
  valid_607078 = validateParameter(valid_607078, JString, required = true,
                                 default = newJString("DeleteClusterSnapshot"))
  if valid_607078 != nil:
    section.add "Action", valid_607078
  var valid_607079 = query.getOrDefault("Version")
  valid_607079 = validateParameter(valid_607079, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_607079 != nil:
    section.add "Version", valid_607079
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_607080 = header.getOrDefault("X-Amz-Signature")
  valid_607080 = validateParameter(valid_607080, JString, required = false,
                                 default = nil)
  if valid_607080 != nil:
    section.add "X-Amz-Signature", valid_607080
  var valid_607081 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_607081 = validateParameter(valid_607081, JString, required = false,
                                 default = nil)
  if valid_607081 != nil:
    section.add "X-Amz-Content-Sha256", valid_607081
  var valid_607082 = header.getOrDefault("X-Amz-Date")
  valid_607082 = validateParameter(valid_607082, JString, required = false,
                                 default = nil)
  if valid_607082 != nil:
    section.add "X-Amz-Date", valid_607082
  var valid_607083 = header.getOrDefault("X-Amz-Credential")
  valid_607083 = validateParameter(valid_607083, JString, required = false,
                                 default = nil)
  if valid_607083 != nil:
    section.add "X-Amz-Credential", valid_607083
  var valid_607084 = header.getOrDefault("X-Amz-Security-Token")
  valid_607084 = validateParameter(valid_607084, JString, required = false,
                                 default = nil)
  if valid_607084 != nil:
    section.add "X-Amz-Security-Token", valid_607084
  var valid_607085 = header.getOrDefault("X-Amz-Algorithm")
  valid_607085 = validateParameter(valid_607085, JString, required = false,
                                 default = nil)
  if valid_607085 != nil:
    section.add "X-Amz-Algorithm", valid_607085
  var valid_607086 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_607086 = validateParameter(valid_607086, JString, required = false,
                                 default = nil)
  if valid_607086 != nil:
    section.add "X-Amz-SignedHeaders", valid_607086
  result.add "header", section
  ## parameters in `formData` object:
  ##   SnapshotIdentifier: JString (required)
  ##                     : <p>The unique identifier of the manual snapshot to be deleted.</p> <p>Constraints: Must be the name of an existing snapshot that is in the <code>available</code>, <code>failed</code>, or <code>cancelled</code> state.</p>
  ##   SnapshotClusterIdentifier: JString
  ##                            : <p>The unique identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.</p> <p>Constraints: Must be the name of valid cluster.</p>
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `SnapshotIdentifier` field"
  var valid_607087 = formData.getOrDefault("SnapshotIdentifier")
  valid_607087 = validateParameter(valid_607087, JString, required = true,
                                 default = nil)
  if valid_607087 != nil:
    section.add "SnapshotIdentifier", valid_607087
  var valid_607088 = formData.getOrDefault("SnapshotClusterIdentifier")
  valid_607088 = validateParameter(valid_607088, JString, required = false,
                                 default = nil)
  if valid_607088 != nil:
    section.add "SnapshotClusterIdentifier", valid_607088
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_607089: Call_PostDeleteClusterSnapshot_607075; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Deletes the specified manual snapshot. The snapshot must be in the <code>available</code> state, with no other users authorized to access the snapshot. </p> <p>Unlike automated snapshots, manual snapshots are retained even after you delete your cluster. Amazon Redshift does not delete your manual snapshots. You must delete manual snapshot explicitly to avoid getting charged. If other accounts are authorized to access the snapshot, you must revoke all of the authorizations before you can delete the snapshot.</p>
  ## 
  let valid = call_607089.validator(path, query, header, formData, body)
  let scheme = call_607089.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_607089.url(scheme.get, call_607089.host, call_607089.base,
                         call_607089.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_607089, url, valid)

proc call*(call_607090: Call_PostDeleteClusterSnapshot_607075;
          SnapshotIdentifier: string; Action: string = "DeleteClusterSnapshot";
          SnapshotClusterIdentifier: string = ""; Version: string = "2012-12-01"): Recallable =
  ## postDeleteClusterSnapshot
  ## <p>Deletes the specified manual snapshot. The snapshot must be in the <code>available</code> state, with no other users authorized to access the snapshot. </p> <p>Unlike automated snapshots, manual snapshots are retained even after you delete your cluster. Amazon Redshift does not delete your manual snapshots. You must delete manual snapshot explicitly to avoid getting charged. If other accounts are authorized to access the snapshot, you must revoke all of the authorizations before you can delete the snapshot.</p>
  ##   SnapshotIdentifier: string (required)
  ##                     : <p>The unique identifier of the manual snapshot to be deleted.</p> <p>Constraints: Must be the name of an existing snapshot that is in the <code>available</code>, <code>failed</code>, or <code>cancelled</code> state.</p>
  ##   Action: string (required)
  ##   SnapshotClusterIdentifier: string
  ##                            : <p>The unique identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.</p> <p>Constraints: Must be the name of valid cluster.</p>
  ##   Version: string (required)
  var query_607091 = newJObject()
  var formData_607092 = newJObject()
  add(formData_607092, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_607091, "Action", newJString(Action))
  add(formData_607092, "SnapshotClusterIdentifier",
      newJString(SnapshotClusterIdentifier))
  add(query_607091, "Version", newJString(Version))
  result = call_607090.call(nil, query_607091, nil, formData_607092, nil)

var postDeleteClusterSnapshot* = Call_PostDeleteClusterSnapshot_607075(
    name: "postDeleteClusterSnapshot", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteClusterSnapshot",
    validator: validate_PostDeleteClusterSnapshot_607076, base: "/",
    url: url_PostDeleteClusterSnapshot_607077,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeleteClusterSnapshot_607058 = ref object of OpenApiRestCall_605573
proc url_GetDeleteClusterSnapshot_607060(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDeleteClusterSnapshot_607059(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Deletes the specified manual snapshot. The snapshot must be in the <code>available</code> state, with no other users authorized to access the snapshot. </p> <p>Unlike automated snapshots, manual snapshots are retained even after you delete your cluster. Amazon Redshift does not delete your manual snapshots. You must delete manual snapshot explicitly to avoid getting charged. If other accounts are authorized to access the snapshot, you must revoke all of the authorizations before you can delete the snapshot.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   SnapshotIdentifier: JString (required)
  ##                     : <p>The unique identifier of the manual snapshot to be deleted.</p> <p>Constraints: Must be the name of an existing snapshot that is in the <code>available</code>, <code>failed</code>, or <code>cancelled</code> state.</p>
  ##   SnapshotClusterIdentifier: JString
  ##                            : <p>The unique identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.</p> <p>Constraints: Must be the name of valid cluster.</p>
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `SnapshotIdentifier` field"
  var valid_607061 = query.getOrDefault("SnapshotIdentifier")
  valid_607061 = validateParameter(valid_607061, JString, required = true,
                                 default = nil)
  if valid_607061 != nil:
    section.add "SnapshotIdentifier", valid_607061
  var valid_607062 = query.getOrDefault("SnapshotClusterIdentifier")
  valid_607062 = validateParameter(valid_607062, JString, required = false,
                                 default = nil)
  if valid_607062 != nil:
    section.add "SnapshotClusterIdentifier", valid_607062
  var valid_607063 = query.getOrDefault("Action")
  valid_607063 = validateParameter(valid_607063, JString, required = true,
                                 default = newJString("DeleteClusterSnapshot"))
  if valid_607063 != nil:
    section.add "Action", valid_607063
  var valid_607064 = query.getOrDefault("Version")
  valid_607064 = validateParameter(valid_607064, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_607064 != nil:
    section.add "Version", valid_607064
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_607065 = header.getOrDefault("X-Amz-Signature")
  valid_607065 = validateParameter(valid_607065, JString, required = false,
                                 default = nil)
  if valid_607065 != nil:
    section.add "X-Amz-Signature", valid_607065
  var valid_607066 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_607066 = validateParameter(valid_607066, JString, required = false,
                                 default = nil)
  if valid_607066 != nil:
    section.add "X-Amz-Content-Sha256", valid_607066
  var valid_607067 = header.getOrDefault("X-Amz-Date")
  valid_607067 = validateParameter(valid_607067, JString, required = false,
                                 default = nil)
  if valid_607067 != nil:
    section.add "X-Amz-Date", valid_607067
  var valid_607068 = header.getOrDefault("X-Amz-Credential")
  valid_607068 = validateParameter(valid_607068, JString, required = false,
                                 default = nil)
  if valid_607068 != nil:
    section.add "X-Amz-Credential", valid_607068
  var valid_607069 = header.getOrDefault("X-Amz-Security-Token")
  valid_607069 = validateParameter(valid_607069, JString, required = false,
                                 default = nil)
  if valid_607069 != nil:
    section.add "X-Amz-Security-Token", valid_607069
  var valid_607070 = header.getOrDefault("X-Amz-Algorithm")
  valid_607070 = validateParameter(valid_607070, JString, required = false,
                                 default = nil)
  if valid_607070 != nil:
    section.add "X-Amz-Algorithm", valid_607070
  var valid_607071 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_607071 = validateParameter(valid_607071, JString, required = false,
                                 default = nil)
  if valid_607071 != nil:
    section.add "X-Amz-SignedHeaders", valid_607071
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_607072: Call_GetDeleteClusterSnapshot_607058; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Deletes the specified manual snapshot. The snapshot must be in the <code>available</code> state, with no other users authorized to access the snapshot. </p> <p>Unlike automated snapshots, manual snapshots are retained even after you delete your cluster. Amazon Redshift does not delete your manual snapshots. You must delete manual snapshot explicitly to avoid getting charged. If other accounts are authorized to access the snapshot, you must revoke all of the authorizations before you can delete the snapshot.</p>
  ## 
  let valid = call_607072.validator(path, query, header, formData, body)
  let scheme = call_607072.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_607072.url(scheme.get, call_607072.host, call_607072.base,
                         call_607072.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_607072, url, valid)

proc call*(call_607073: Call_GetDeleteClusterSnapshot_607058;
          SnapshotIdentifier: string; SnapshotClusterIdentifier: string = "";
          Action: string = "DeleteClusterSnapshot"; Version: string = "2012-12-01"): Recallable =
  ## getDeleteClusterSnapshot
  ## <p>Deletes the specified manual snapshot. The snapshot must be in the <code>available</code> state, with no other users authorized to access the snapshot. </p> <p>Unlike automated snapshots, manual snapshots are retained even after you delete your cluster. Amazon Redshift does not delete your manual snapshots. You must delete manual snapshot explicitly to avoid getting charged. If other accounts are authorized to access the snapshot, you must revoke all of the authorizations before you can delete the snapshot.</p>
  ##   SnapshotIdentifier: string (required)
  ##                     : <p>The unique identifier of the manual snapshot to be deleted.</p> <p>Constraints: Must be the name of an existing snapshot that is in the <code>available</code>, <code>failed</code>, or <code>cancelled</code> state.</p>
  ##   SnapshotClusterIdentifier: string
  ##                            : <p>The unique identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.</p> <p>Constraints: Must be the name of valid cluster.</p>
  ##   Action: string (required)
  ##   Version: string (required)
  var query_607074 = newJObject()
  add(query_607074, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_607074, "SnapshotClusterIdentifier",
      newJString(SnapshotClusterIdentifier))
  add(query_607074, "Action", newJString(Action))
  add(query_607074, "Version", newJString(Version))
  result = call_607073.call(nil, query_607074, nil, nil, nil)

var getDeleteClusterSnapshot* = Call_GetDeleteClusterSnapshot_607058(
    name: "getDeleteClusterSnapshot", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteClusterSnapshot",
    validator: validate_GetDeleteClusterSnapshot_607059, base: "/",
    url: url_GetDeleteClusterSnapshot_607060, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDeleteClusterSubnetGroup_607109 = ref object of OpenApiRestCall_605573
proc url_PostDeleteClusterSubnetGroup_607111(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDeleteClusterSubnetGroup_607110(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes the specified cluster subnet group.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_607112 = query.getOrDefault("Action")
  valid_607112 = validateParameter(valid_607112, JString, required = true, default = newJString(
      "DeleteClusterSubnetGroup"))
  if valid_607112 != nil:
    section.add "Action", valid_607112
  var valid_607113 = query.getOrDefault("Version")
  valid_607113 = validateParameter(valid_607113, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_607113 != nil:
    section.add "Version", valid_607113
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_607114 = header.getOrDefault("X-Amz-Signature")
  valid_607114 = validateParameter(valid_607114, JString, required = false,
                                 default = nil)
  if valid_607114 != nil:
    section.add "X-Amz-Signature", valid_607114
  var valid_607115 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_607115 = validateParameter(valid_607115, JString, required = false,
                                 default = nil)
  if valid_607115 != nil:
    section.add "X-Amz-Content-Sha256", valid_607115
  var valid_607116 = header.getOrDefault("X-Amz-Date")
  valid_607116 = validateParameter(valid_607116, JString, required = false,
                                 default = nil)
  if valid_607116 != nil:
    section.add "X-Amz-Date", valid_607116
  var valid_607117 = header.getOrDefault("X-Amz-Credential")
  valid_607117 = validateParameter(valid_607117, JString, required = false,
                                 default = nil)
  if valid_607117 != nil:
    section.add "X-Amz-Credential", valid_607117
  var valid_607118 = header.getOrDefault("X-Amz-Security-Token")
  valid_607118 = validateParameter(valid_607118, JString, required = false,
                                 default = nil)
  if valid_607118 != nil:
    section.add "X-Amz-Security-Token", valid_607118
  var valid_607119 = header.getOrDefault("X-Amz-Algorithm")
  valid_607119 = validateParameter(valid_607119, JString, required = false,
                                 default = nil)
  if valid_607119 != nil:
    section.add "X-Amz-Algorithm", valid_607119
  var valid_607120 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_607120 = validateParameter(valid_607120, JString, required = false,
                                 default = nil)
  if valid_607120 != nil:
    section.add "X-Amz-SignedHeaders", valid_607120
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterSubnetGroupName: JString (required)
  ##                         : The name of the cluster subnet group name to be deleted.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterSubnetGroupName` field"
  var valid_607121 = formData.getOrDefault("ClusterSubnetGroupName")
  valid_607121 = validateParameter(valid_607121, JString, required = true,
                                 default = nil)
  if valid_607121 != nil:
    section.add "ClusterSubnetGroupName", valid_607121
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_607122: Call_PostDeleteClusterSubnetGroup_607109; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes the specified cluster subnet group.
  ## 
  let valid = call_607122.validator(path, query, header, formData, body)
  let scheme = call_607122.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_607122.url(scheme.get, call_607122.host, call_607122.base,
                         call_607122.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_607122, url, valid)

proc call*(call_607123: Call_PostDeleteClusterSubnetGroup_607109;
          ClusterSubnetGroupName: string;
          Action: string = "DeleteClusterSubnetGroup";
          Version: string = "2012-12-01"): Recallable =
  ## postDeleteClusterSubnetGroup
  ## Deletes the specified cluster subnet group.
  ##   ClusterSubnetGroupName: string (required)
  ##                         : The name of the cluster subnet group name to be deleted.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_607124 = newJObject()
  var formData_607125 = newJObject()
  add(formData_607125, "ClusterSubnetGroupName",
      newJString(ClusterSubnetGroupName))
  add(query_607124, "Action", newJString(Action))
  add(query_607124, "Version", newJString(Version))
  result = call_607123.call(nil, query_607124, nil, formData_607125, nil)

var postDeleteClusterSubnetGroup* = Call_PostDeleteClusterSubnetGroup_607109(
    name: "postDeleteClusterSubnetGroup", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteClusterSubnetGroup",
    validator: validate_PostDeleteClusterSubnetGroup_607110, base: "/",
    url: url_PostDeleteClusterSubnetGroup_607111,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeleteClusterSubnetGroup_607093 = ref object of OpenApiRestCall_605573
proc url_GetDeleteClusterSubnetGroup_607095(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDeleteClusterSubnetGroup_607094(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes the specified cluster subnet group.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ClusterSubnetGroupName: JString (required)
  ##                         : The name of the cluster subnet group name to be deleted.
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `ClusterSubnetGroupName` field"
  var valid_607096 = query.getOrDefault("ClusterSubnetGroupName")
  valid_607096 = validateParameter(valid_607096, JString, required = true,
                                 default = nil)
  if valid_607096 != nil:
    section.add "ClusterSubnetGroupName", valid_607096
  var valid_607097 = query.getOrDefault("Action")
  valid_607097 = validateParameter(valid_607097, JString, required = true, default = newJString(
      "DeleteClusterSubnetGroup"))
  if valid_607097 != nil:
    section.add "Action", valid_607097
  var valid_607098 = query.getOrDefault("Version")
  valid_607098 = validateParameter(valid_607098, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_607098 != nil:
    section.add "Version", valid_607098
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_607099 = header.getOrDefault("X-Amz-Signature")
  valid_607099 = validateParameter(valid_607099, JString, required = false,
                                 default = nil)
  if valid_607099 != nil:
    section.add "X-Amz-Signature", valid_607099
  var valid_607100 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_607100 = validateParameter(valid_607100, JString, required = false,
                                 default = nil)
  if valid_607100 != nil:
    section.add "X-Amz-Content-Sha256", valid_607100
  var valid_607101 = header.getOrDefault("X-Amz-Date")
  valid_607101 = validateParameter(valid_607101, JString, required = false,
                                 default = nil)
  if valid_607101 != nil:
    section.add "X-Amz-Date", valid_607101
  var valid_607102 = header.getOrDefault("X-Amz-Credential")
  valid_607102 = validateParameter(valid_607102, JString, required = false,
                                 default = nil)
  if valid_607102 != nil:
    section.add "X-Amz-Credential", valid_607102
  var valid_607103 = header.getOrDefault("X-Amz-Security-Token")
  valid_607103 = validateParameter(valid_607103, JString, required = false,
                                 default = nil)
  if valid_607103 != nil:
    section.add "X-Amz-Security-Token", valid_607103
  var valid_607104 = header.getOrDefault("X-Amz-Algorithm")
  valid_607104 = validateParameter(valid_607104, JString, required = false,
                                 default = nil)
  if valid_607104 != nil:
    section.add "X-Amz-Algorithm", valid_607104
  var valid_607105 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_607105 = validateParameter(valid_607105, JString, required = false,
                                 default = nil)
  if valid_607105 != nil:
    section.add "X-Amz-SignedHeaders", valid_607105
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_607106: Call_GetDeleteClusterSubnetGroup_607093; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes the specified cluster subnet group.
  ## 
  let valid = call_607106.validator(path, query, header, formData, body)
  let scheme = call_607106.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_607106.url(scheme.get, call_607106.host, call_607106.base,
                         call_607106.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_607106, url, valid)

proc call*(call_607107: Call_GetDeleteClusterSubnetGroup_607093;
          ClusterSubnetGroupName: string;
          Action: string = "DeleteClusterSubnetGroup";
          Version: string = "2012-12-01"): Recallable =
  ## getDeleteClusterSubnetGroup
  ## Deletes the specified cluster subnet group.
  ##   ClusterSubnetGroupName: string (required)
  ##                         : The name of the cluster subnet group name to be deleted.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_607108 = newJObject()
  add(query_607108, "ClusterSubnetGroupName", newJString(ClusterSubnetGroupName))
  add(query_607108, "Action", newJString(Action))
  add(query_607108, "Version", newJString(Version))
  result = call_607107.call(nil, query_607108, nil, nil, nil)

var getDeleteClusterSubnetGroup* = Call_GetDeleteClusterSubnetGroup_607093(
    name: "getDeleteClusterSubnetGroup", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteClusterSubnetGroup",
    validator: validate_GetDeleteClusterSubnetGroup_607094, base: "/",
    url: url_GetDeleteClusterSubnetGroup_607095,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDeleteEventSubscription_607142 = ref object of OpenApiRestCall_605573
proc url_PostDeleteEventSubscription_607144(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDeleteEventSubscription_607143(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes an Amazon Redshift event notification subscription.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_607145 = query.getOrDefault("Action")
  valid_607145 = validateParameter(valid_607145, JString, required = true, default = newJString(
      "DeleteEventSubscription"))
  if valid_607145 != nil:
    section.add "Action", valid_607145
  var valid_607146 = query.getOrDefault("Version")
  valid_607146 = validateParameter(valid_607146, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_607146 != nil:
    section.add "Version", valid_607146
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_607147 = header.getOrDefault("X-Amz-Signature")
  valid_607147 = validateParameter(valid_607147, JString, required = false,
                                 default = nil)
  if valid_607147 != nil:
    section.add "X-Amz-Signature", valid_607147
  var valid_607148 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_607148 = validateParameter(valid_607148, JString, required = false,
                                 default = nil)
  if valid_607148 != nil:
    section.add "X-Amz-Content-Sha256", valid_607148
  var valid_607149 = header.getOrDefault("X-Amz-Date")
  valid_607149 = validateParameter(valid_607149, JString, required = false,
                                 default = nil)
  if valid_607149 != nil:
    section.add "X-Amz-Date", valid_607149
  var valid_607150 = header.getOrDefault("X-Amz-Credential")
  valid_607150 = validateParameter(valid_607150, JString, required = false,
                                 default = nil)
  if valid_607150 != nil:
    section.add "X-Amz-Credential", valid_607150
  var valid_607151 = header.getOrDefault("X-Amz-Security-Token")
  valid_607151 = validateParameter(valid_607151, JString, required = false,
                                 default = nil)
  if valid_607151 != nil:
    section.add "X-Amz-Security-Token", valid_607151
  var valid_607152 = header.getOrDefault("X-Amz-Algorithm")
  valid_607152 = validateParameter(valid_607152, JString, required = false,
                                 default = nil)
  if valid_607152 != nil:
    section.add "X-Amz-Algorithm", valid_607152
  var valid_607153 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_607153 = validateParameter(valid_607153, JString, required = false,
                                 default = nil)
  if valid_607153 != nil:
    section.add "X-Amz-SignedHeaders", valid_607153
  result.add "header", section
  ## parameters in `formData` object:
  ##   SubscriptionName: JString (required)
  ##                   : The name of the Amazon Redshift event notification subscription to be deleted.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `SubscriptionName` field"
  var valid_607154 = formData.getOrDefault("SubscriptionName")
  valid_607154 = validateParameter(valid_607154, JString, required = true,
                                 default = nil)
  if valid_607154 != nil:
    section.add "SubscriptionName", valid_607154
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_607155: Call_PostDeleteEventSubscription_607142; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes an Amazon Redshift event notification subscription.
  ## 
  let valid = call_607155.validator(path, query, header, formData, body)
  let scheme = call_607155.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_607155.url(scheme.get, call_607155.host, call_607155.base,
                         call_607155.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_607155, url, valid)

proc call*(call_607156: Call_PostDeleteEventSubscription_607142;
          SubscriptionName: string; Action: string = "DeleteEventSubscription";
          Version: string = "2012-12-01"): Recallable =
  ## postDeleteEventSubscription
  ## Deletes an Amazon Redshift event notification subscription.
  ##   SubscriptionName: string (required)
  ##                   : The name of the Amazon Redshift event notification subscription to be deleted.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_607157 = newJObject()
  var formData_607158 = newJObject()
  add(formData_607158, "SubscriptionName", newJString(SubscriptionName))
  add(query_607157, "Action", newJString(Action))
  add(query_607157, "Version", newJString(Version))
  result = call_607156.call(nil, query_607157, nil, formData_607158, nil)

var postDeleteEventSubscription* = Call_PostDeleteEventSubscription_607142(
    name: "postDeleteEventSubscription", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteEventSubscription",
    validator: validate_PostDeleteEventSubscription_607143, base: "/",
    url: url_PostDeleteEventSubscription_607144,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeleteEventSubscription_607126 = ref object of OpenApiRestCall_605573
proc url_GetDeleteEventSubscription_607128(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDeleteEventSubscription_607127(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes an Amazon Redshift event notification subscription.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   SubscriptionName: JString (required)
  ##                   : The name of the Amazon Redshift event notification subscription to be deleted.
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `SubscriptionName` field"
  var valid_607129 = query.getOrDefault("SubscriptionName")
  valid_607129 = validateParameter(valid_607129, JString, required = true,
                                 default = nil)
  if valid_607129 != nil:
    section.add "SubscriptionName", valid_607129
  var valid_607130 = query.getOrDefault("Action")
  valid_607130 = validateParameter(valid_607130, JString, required = true, default = newJString(
      "DeleteEventSubscription"))
  if valid_607130 != nil:
    section.add "Action", valid_607130
  var valid_607131 = query.getOrDefault("Version")
  valid_607131 = validateParameter(valid_607131, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_607131 != nil:
    section.add "Version", valid_607131
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_607132 = header.getOrDefault("X-Amz-Signature")
  valid_607132 = validateParameter(valid_607132, JString, required = false,
                                 default = nil)
  if valid_607132 != nil:
    section.add "X-Amz-Signature", valid_607132
  var valid_607133 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_607133 = validateParameter(valid_607133, JString, required = false,
                                 default = nil)
  if valid_607133 != nil:
    section.add "X-Amz-Content-Sha256", valid_607133
  var valid_607134 = header.getOrDefault("X-Amz-Date")
  valid_607134 = validateParameter(valid_607134, JString, required = false,
                                 default = nil)
  if valid_607134 != nil:
    section.add "X-Amz-Date", valid_607134
  var valid_607135 = header.getOrDefault("X-Amz-Credential")
  valid_607135 = validateParameter(valid_607135, JString, required = false,
                                 default = nil)
  if valid_607135 != nil:
    section.add "X-Amz-Credential", valid_607135
  var valid_607136 = header.getOrDefault("X-Amz-Security-Token")
  valid_607136 = validateParameter(valid_607136, JString, required = false,
                                 default = nil)
  if valid_607136 != nil:
    section.add "X-Amz-Security-Token", valid_607136
  var valid_607137 = header.getOrDefault("X-Amz-Algorithm")
  valid_607137 = validateParameter(valid_607137, JString, required = false,
                                 default = nil)
  if valid_607137 != nil:
    section.add "X-Amz-Algorithm", valid_607137
  var valid_607138 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_607138 = validateParameter(valid_607138, JString, required = false,
                                 default = nil)
  if valid_607138 != nil:
    section.add "X-Amz-SignedHeaders", valid_607138
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_607139: Call_GetDeleteEventSubscription_607126; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes an Amazon Redshift event notification subscription.
  ## 
  let valid = call_607139.validator(path, query, header, formData, body)
  let scheme = call_607139.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_607139.url(scheme.get, call_607139.host, call_607139.base,
                         call_607139.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_607139, url, valid)

proc call*(call_607140: Call_GetDeleteEventSubscription_607126;
          SubscriptionName: string; Action: string = "DeleteEventSubscription";
          Version: string = "2012-12-01"): Recallable =
  ## getDeleteEventSubscription
  ## Deletes an Amazon Redshift event notification subscription.
  ##   SubscriptionName: string (required)
  ##                   : The name of the Amazon Redshift event notification subscription to be deleted.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_607141 = newJObject()
  add(query_607141, "SubscriptionName", newJString(SubscriptionName))
  add(query_607141, "Action", newJString(Action))
  add(query_607141, "Version", newJString(Version))
  result = call_607140.call(nil, query_607141, nil, nil, nil)

var getDeleteEventSubscription* = Call_GetDeleteEventSubscription_607126(
    name: "getDeleteEventSubscription", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteEventSubscription",
    validator: validate_GetDeleteEventSubscription_607127, base: "/",
    url: url_GetDeleteEventSubscription_607128,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDeleteHsmClientCertificate_607175 = ref object of OpenApiRestCall_605573
proc url_PostDeleteHsmClientCertificate_607177(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDeleteHsmClientCertificate_607176(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes the specified HSM client certificate.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_607178 = query.getOrDefault("Action")
  valid_607178 = validateParameter(valid_607178, JString, required = true, default = newJString(
      "DeleteHsmClientCertificate"))
  if valid_607178 != nil:
    section.add "Action", valid_607178
  var valid_607179 = query.getOrDefault("Version")
  valid_607179 = validateParameter(valid_607179, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_607179 != nil:
    section.add "Version", valid_607179
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_607180 = header.getOrDefault("X-Amz-Signature")
  valid_607180 = validateParameter(valid_607180, JString, required = false,
                                 default = nil)
  if valid_607180 != nil:
    section.add "X-Amz-Signature", valid_607180
  var valid_607181 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_607181 = validateParameter(valid_607181, JString, required = false,
                                 default = nil)
  if valid_607181 != nil:
    section.add "X-Amz-Content-Sha256", valid_607181
  var valid_607182 = header.getOrDefault("X-Amz-Date")
  valid_607182 = validateParameter(valid_607182, JString, required = false,
                                 default = nil)
  if valid_607182 != nil:
    section.add "X-Amz-Date", valid_607182
  var valid_607183 = header.getOrDefault("X-Amz-Credential")
  valid_607183 = validateParameter(valid_607183, JString, required = false,
                                 default = nil)
  if valid_607183 != nil:
    section.add "X-Amz-Credential", valid_607183
  var valid_607184 = header.getOrDefault("X-Amz-Security-Token")
  valid_607184 = validateParameter(valid_607184, JString, required = false,
                                 default = nil)
  if valid_607184 != nil:
    section.add "X-Amz-Security-Token", valid_607184
  var valid_607185 = header.getOrDefault("X-Amz-Algorithm")
  valid_607185 = validateParameter(valid_607185, JString, required = false,
                                 default = nil)
  if valid_607185 != nil:
    section.add "X-Amz-Algorithm", valid_607185
  var valid_607186 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_607186 = validateParameter(valid_607186, JString, required = false,
                                 default = nil)
  if valid_607186 != nil:
    section.add "X-Amz-SignedHeaders", valid_607186
  result.add "header", section
  ## parameters in `formData` object:
  ##   HsmClientCertificateIdentifier: JString (required)
  ##                                 : The identifier of the HSM client certificate to be deleted.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `HsmClientCertificateIdentifier` field"
  var valid_607187 = formData.getOrDefault("HsmClientCertificateIdentifier")
  valid_607187 = validateParameter(valid_607187, JString, required = true,
                                 default = nil)
  if valid_607187 != nil:
    section.add "HsmClientCertificateIdentifier", valid_607187
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_607188: Call_PostDeleteHsmClientCertificate_607175; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes the specified HSM client certificate.
  ## 
  let valid = call_607188.validator(path, query, header, formData, body)
  let scheme = call_607188.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_607188.url(scheme.get, call_607188.host, call_607188.base,
                         call_607188.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_607188, url, valid)

proc call*(call_607189: Call_PostDeleteHsmClientCertificate_607175;
          HsmClientCertificateIdentifier: string;
          Action: string = "DeleteHsmClientCertificate";
          Version: string = "2012-12-01"): Recallable =
  ## postDeleteHsmClientCertificate
  ## Deletes the specified HSM client certificate.
  ##   Action: string (required)
  ##   HsmClientCertificateIdentifier: string (required)
  ##                                 : The identifier of the HSM client certificate to be deleted.
  ##   Version: string (required)
  var query_607190 = newJObject()
  var formData_607191 = newJObject()
  add(query_607190, "Action", newJString(Action))
  add(formData_607191, "HsmClientCertificateIdentifier",
      newJString(HsmClientCertificateIdentifier))
  add(query_607190, "Version", newJString(Version))
  result = call_607189.call(nil, query_607190, nil, formData_607191, nil)

var postDeleteHsmClientCertificate* = Call_PostDeleteHsmClientCertificate_607175(
    name: "postDeleteHsmClientCertificate", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteHsmClientCertificate",
    validator: validate_PostDeleteHsmClientCertificate_607176, base: "/",
    url: url_PostDeleteHsmClientCertificate_607177,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeleteHsmClientCertificate_607159 = ref object of OpenApiRestCall_605573
proc url_GetDeleteHsmClientCertificate_607161(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDeleteHsmClientCertificate_607160(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes the specified HSM client certificate.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   HsmClientCertificateIdentifier: JString (required)
  ##                                 : The identifier of the HSM client certificate to be deleted.
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `HsmClientCertificateIdentifier` field"
  var valid_607162 = query.getOrDefault("HsmClientCertificateIdentifier")
  valid_607162 = validateParameter(valid_607162, JString, required = true,
                                 default = nil)
  if valid_607162 != nil:
    section.add "HsmClientCertificateIdentifier", valid_607162
  var valid_607163 = query.getOrDefault("Action")
  valid_607163 = validateParameter(valid_607163, JString, required = true, default = newJString(
      "DeleteHsmClientCertificate"))
  if valid_607163 != nil:
    section.add "Action", valid_607163
  var valid_607164 = query.getOrDefault("Version")
  valid_607164 = validateParameter(valid_607164, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_607164 != nil:
    section.add "Version", valid_607164
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_607165 = header.getOrDefault("X-Amz-Signature")
  valid_607165 = validateParameter(valid_607165, JString, required = false,
                                 default = nil)
  if valid_607165 != nil:
    section.add "X-Amz-Signature", valid_607165
  var valid_607166 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_607166 = validateParameter(valid_607166, JString, required = false,
                                 default = nil)
  if valid_607166 != nil:
    section.add "X-Amz-Content-Sha256", valid_607166
  var valid_607167 = header.getOrDefault("X-Amz-Date")
  valid_607167 = validateParameter(valid_607167, JString, required = false,
                                 default = nil)
  if valid_607167 != nil:
    section.add "X-Amz-Date", valid_607167
  var valid_607168 = header.getOrDefault("X-Amz-Credential")
  valid_607168 = validateParameter(valid_607168, JString, required = false,
                                 default = nil)
  if valid_607168 != nil:
    section.add "X-Amz-Credential", valid_607168
  var valid_607169 = header.getOrDefault("X-Amz-Security-Token")
  valid_607169 = validateParameter(valid_607169, JString, required = false,
                                 default = nil)
  if valid_607169 != nil:
    section.add "X-Amz-Security-Token", valid_607169
  var valid_607170 = header.getOrDefault("X-Amz-Algorithm")
  valid_607170 = validateParameter(valid_607170, JString, required = false,
                                 default = nil)
  if valid_607170 != nil:
    section.add "X-Amz-Algorithm", valid_607170
  var valid_607171 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_607171 = validateParameter(valid_607171, JString, required = false,
                                 default = nil)
  if valid_607171 != nil:
    section.add "X-Amz-SignedHeaders", valid_607171
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_607172: Call_GetDeleteHsmClientCertificate_607159; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes the specified HSM client certificate.
  ## 
  let valid = call_607172.validator(path, query, header, formData, body)
  let scheme = call_607172.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_607172.url(scheme.get, call_607172.host, call_607172.base,
                         call_607172.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_607172, url, valid)

proc call*(call_607173: Call_GetDeleteHsmClientCertificate_607159;
          HsmClientCertificateIdentifier: string;
          Action: string = "DeleteHsmClientCertificate";
          Version: string = "2012-12-01"): Recallable =
  ## getDeleteHsmClientCertificate
  ## Deletes the specified HSM client certificate.
  ##   HsmClientCertificateIdentifier: string (required)
  ##                                 : The identifier of the HSM client certificate to be deleted.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_607174 = newJObject()
  add(query_607174, "HsmClientCertificateIdentifier",
      newJString(HsmClientCertificateIdentifier))
  add(query_607174, "Action", newJString(Action))
  add(query_607174, "Version", newJString(Version))
  result = call_607173.call(nil, query_607174, nil, nil, nil)

var getDeleteHsmClientCertificate* = Call_GetDeleteHsmClientCertificate_607159(
    name: "getDeleteHsmClientCertificate", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteHsmClientCertificate",
    validator: validate_GetDeleteHsmClientCertificate_607160, base: "/",
    url: url_GetDeleteHsmClientCertificate_607161,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDeleteHsmConfiguration_607208 = ref object of OpenApiRestCall_605573
proc url_PostDeleteHsmConfiguration_607210(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDeleteHsmConfiguration_607209(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes the specified Amazon Redshift HSM configuration.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_607211 = query.getOrDefault("Action")
  valid_607211 = validateParameter(valid_607211, JString, required = true,
                                 default = newJString("DeleteHsmConfiguration"))
  if valid_607211 != nil:
    section.add "Action", valid_607211
  var valid_607212 = query.getOrDefault("Version")
  valid_607212 = validateParameter(valid_607212, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_607212 != nil:
    section.add "Version", valid_607212
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_607213 = header.getOrDefault("X-Amz-Signature")
  valid_607213 = validateParameter(valid_607213, JString, required = false,
                                 default = nil)
  if valid_607213 != nil:
    section.add "X-Amz-Signature", valid_607213
  var valid_607214 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_607214 = validateParameter(valid_607214, JString, required = false,
                                 default = nil)
  if valid_607214 != nil:
    section.add "X-Amz-Content-Sha256", valid_607214
  var valid_607215 = header.getOrDefault("X-Amz-Date")
  valid_607215 = validateParameter(valid_607215, JString, required = false,
                                 default = nil)
  if valid_607215 != nil:
    section.add "X-Amz-Date", valid_607215
  var valid_607216 = header.getOrDefault("X-Amz-Credential")
  valid_607216 = validateParameter(valid_607216, JString, required = false,
                                 default = nil)
  if valid_607216 != nil:
    section.add "X-Amz-Credential", valid_607216
  var valid_607217 = header.getOrDefault("X-Amz-Security-Token")
  valid_607217 = validateParameter(valid_607217, JString, required = false,
                                 default = nil)
  if valid_607217 != nil:
    section.add "X-Amz-Security-Token", valid_607217
  var valid_607218 = header.getOrDefault("X-Amz-Algorithm")
  valid_607218 = validateParameter(valid_607218, JString, required = false,
                                 default = nil)
  if valid_607218 != nil:
    section.add "X-Amz-Algorithm", valid_607218
  var valid_607219 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_607219 = validateParameter(valid_607219, JString, required = false,
                                 default = nil)
  if valid_607219 != nil:
    section.add "X-Amz-SignedHeaders", valid_607219
  result.add "header", section
  ## parameters in `formData` object:
  ##   HsmConfigurationIdentifier: JString (required)
  ##                             : The identifier of the Amazon Redshift HSM configuration to be deleted.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `HsmConfigurationIdentifier` field"
  var valid_607220 = formData.getOrDefault("HsmConfigurationIdentifier")
  valid_607220 = validateParameter(valid_607220, JString, required = true,
                                 default = nil)
  if valid_607220 != nil:
    section.add "HsmConfigurationIdentifier", valid_607220
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_607221: Call_PostDeleteHsmConfiguration_607208; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes the specified Amazon Redshift HSM configuration.
  ## 
  let valid = call_607221.validator(path, query, header, formData, body)
  let scheme = call_607221.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_607221.url(scheme.get, call_607221.host, call_607221.base,
                         call_607221.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_607221, url, valid)

proc call*(call_607222: Call_PostDeleteHsmConfiguration_607208;
          HsmConfigurationIdentifier: string;
          Action: string = "DeleteHsmConfiguration"; Version: string = "2012-12-01"): Recallable =
  ## postDeleteHsmConfiguration
  ## Deletes the specified Amazon Redshift HSM configuration.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   HsmConfigurationIdentifier: string (required)
  ##                             : The identifier of the Amazon Redshift HSM configuration to be deleted.
  var query_607223 = newJObject()
  var formData_607224 = newJObject()
  add(query_607223, "Action", newJString(Action))
  add(query_607223, "Version", newJString(Version))
  add(formData_607224, "HsmConfigurationIdentifier",
      newJString(HsmConfigurationIdentifier))
  result = call_607222.call(nil, query_607223, nil, formData_607224, nil)

var postDeleteHsmConfiguration* = Call_PostDeleteHsmConfiguration_607208(
    name: "postDeleteHsmConfiguration", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteHsmConfiguration",
    validator: validate_PostDeleteHsmConfiguration_607209, base: "/",
    url: url_PostDeleteHsmConfiguration_607210,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeleteHsmConfiguration_607192 = ref object of OpenApiRestCall_605573
proc url_GetDeleteHsmConfiguration_607194(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDeleteHsmConfiguration_607193(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes the specified Amazon Redshift HSM configuration.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   HsmConfigurationIdentifier: JString (required)
  ##                             : The identifier of the Amazon Redshift HSM configuration to be deleted.
  ##   Version: JString (required)
  section = newJObject()
  var valid_607195 = query.getOrDefault("Action")
  valid_607195 = validateParameter(valid_607195, JString, required = true,
                                 default = newJString("DeleteHsmConfiguration"))
  if valid_607195 != nil:
    section.add "Action", valid_607195
  var valid_607196 = query.getOrDefault("HsmConfigurationIdentifier")
  valid_607196 = validateParameter(valid_607196, JString, required = true,
                                 default = nil)
  if valid_607196 != nil:
    section.add "HsmConfigurationIdentifier", valid_607196
  var valid_607197 = query.getOrDefault("Version")
  valid_607197 = validateParameter(valid_607197, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_607197 != nil:
    section.add "Version", valid_607197
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_607198 = header.getOrDefault("X-Amz-Signature")
  valid_607198 = validateParameter(valid_607198, JString, required = false,
                                 default = nil)
  if valid_607198 != nil:
    section.add "X-Amz-Signature", valid_607198
  var valid_607199 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_607199 = validateParameter(valid_607199, JString, required = false,
                                 default = nil)
  if valid_607199 != nil:
    section.add "X-Amz-Content-Sha256", valid_607199
  var valid_607200 = header.getOrDefault("X-Amz-Date")
  valid_607200 = validateParameter(valid_607200, JString, required = false,
                                 default = nil)
  if valid_607200 != nil:
    section.add "X-Amz-Date", valid_607200
  var valid_607201 = header.getOrDefault("X-Amz-Credential")
  valid_607201 = validateParameter(valid_607201, JString, required = false,
                                 default = nil)
  if valid_607201 != nil:
    section.add "X-Amz-Credential", valid_607201
  var valid_607202 = header.getOrDefault("X-Amz-Security-Token")
  valid_607202 = validateParameter(valid_607202, JString, required = false,
                                 default = nil)
  if valid_607202 != nil:
    section.add "X-Amz-Security-Token", valid_607202
  var valid_607203 = header.getOrDefault("X-Amz-Algorithm")
  valid_607203 = validateParameter(valid_607203, JString, required = false,
                                 default = nil)
  if valid_607203 != nil:
    section.add "X-Amz-Algorithm", valid_607203
  var valid_607204 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_607204 = validateParameter(valid_607204, JString, required = false,
                                 default = nil)
  if valid_607204 != nil:
    section.add "X-Amz-SignedHeaders", valid_607204
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_607205: Call_GetDeleteHsmConfiguration_607192; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes the specified Amazon Redshift HSM configuration.
  ## 
  let valid = call_607205.validator(path, query, header, formData, body)
  let scheme = call_607205.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_607205.url(scheme.get, call_607205.host, call_607205.base,
                         call_607205.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_607205, url, valid)

proc call*(call_607206: Call_GetDeleteHsmConfiguration_607192;
          HsmConfigurationIdentifier: string;
          Action: string = "DeleteHsmConfiguration"; Version: string = "2012-12-01"): Recallable =
  ## getDeleteHsmConfiguration
  ## Deletes the specified Amazon Redshift HSM configuration.
  ##   Action: string (required)
  ##   HsmConfigurationIdentifier: string (required)
  ##                             : The identifier of the Amazon Redshift HSM configuration to be deleted.
  ##   Version: string (required)
  var query_607207 = newJObject()
  add(query_607207, "Action", newJString(Action))
  add(query_607207, "HsmConfigurationIdentifier",
      newJString(HsmConfigurationIdentifier))
  add(query_607207, "Version", newJString(Version))
  result = call_607206.call(nil, query_607207, nil, nil, nil)

var getDeleteHsmConfiguration* = Call_GetDeleteHsmConfiguration_607192(
    name: "getDeleteHsmConfiguration", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteHsmConfiguration",
    validator: validate_GetDeleteHsmConfiguration_607193, base: "/",
    url: url_GetDeleteHsmConfiguration_607194,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDeleteScheduledAction_607241 = ref object of OpenApiRestCall_605573
proc url_PostDeleteScheduledAction_607243(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDeleteScheduledAction_607242(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a scheduled action. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_607244 = query.getOrDefault("Action")
  valid_607244 = validateParameter(valid_607244, JString, required = true,
                                 default = newJString("DeleteScheduledAction"))
  if valid_607244 != nil:
    section.add "Action", valid_607244
  var valid_607245 = query.getOrDefault("Version")
  valid_607245 = validateParameter(valid_607245, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_607245 != nil:
    section.add "Version", valid_607245
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_607246 = header.getOrDefault("X-Amz-Signature")
  valid_607246 = validateParameter(valid_607246, JString, required = false,
                                 default = nil)
  if valid_607246 != nil:
    section.add "X-Amz-Signature", valid_607246
  var valid_607247 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_607247 = validateParameter(valid_607247, JString, required = false,
                                 default = nil)
  if valid_607247 != nil:
    section.add "X-Amz-Content-Sha256", valid_607247
  var valid_607248 = header.getOrDefault("X-Amz-Date")
  valid_607248 = validateParameter(valid_607248, JString, required = false,
                                 default = nil)
  if valid_607248 != nil:
    section.add "X-Amz-Date", valid_607248
  var valid_607249 = header.getOrDefault("X-Amz-Credential")
  valid_607249 = validateParameter(valid_607249, JString, required = false,
                                 default = nil)
  if valid_607249 != nil:
    section.add "X-Amz-Credential", valid_607249
  var valid_607250 = header.getOrDefault("X-Amz-Security-Token")
  valid_607250 = validateParameter(valid_607250, JString, required = false,
                                 default = nil)
  if valid_607250 != nil:
    section.add "X-Amz-Security-Token", valid_607250
  var valid_607251 = header.getOrDefault("X-Amz-Algorithm")
  valid_607251 = validateParameter(valid_607251, JString, required = false,
                                 default = nil)
  if valid_607251 != nil:
    section.add "X-Amz-Algorithm", valid_607251
  var valid_607252 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_607252 = validateParameter(valid_607252, JString, required = false,
                                 default = nil)
  if valid_607252 != nil:
    section.add "X-Amz-SignedHeaders", valid_607252
  result.add "header", section
  ## parameters in `formData` object:
  ##   ScheduledActionName: JString (required)
  ##                      : The name of the scheduled action to delete. 
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ScheduledActionName` field"
  var valid_607253 = formData.getOrDefault("ScheduledActionName")
  valid_607253 = validateParameter(valid_607253, JString, required = true,
                                 default = nil)
  if valid_607253 != nil:
    section.add "ScheduledActionName", valid_607253
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_607254: Call_PostDeleteScheduledAction_607241; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a scheduled action. 
  ## 
  let valid = call_607254.validator(path, query, header, formData, body)
  let scheme = call_607254.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_607254.url(scheme.get, call_607254.host, call_607254.base,
                         call_607254.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_607254, url, valid)

proc call*(call_607255: Call_PostDeleteScheduledAction_607241;
          ScheduledActionName: string; Action: string = "DeleteScheduledAction";
          Version: string = "2012-12-01"): Recallable =
  ## postDeleteScheduledAction
  ## Deletes a scheduled action. 
  ##   ScheduledActionName: string (required)
  ##                      : The name of the scheduled action to delete. 
  ##   Action: string (required)
  ##   Version: string (required)
  var query_607256 = newJObject()
  var formData_607257 = newJObject()
  add(formData_607257, "ScheduledActionName", newJString(ScheduledActionName))
  add(query_607256, "Action", newJString(Action))
  add(query_607256, "Version", newJString(Version))
  result = call_607255.call(nil, query_607256, nil, formData_607257, nil)

var postDeleteScheduledAction* = Call_PostDeleteScheduledAction_607241(
    name: "postDeleteScheduledAction", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteScheduledAction",
    validator: validate_PostDeleteScheduledAction_607242, base: "/",
    url: url_PostDeleteScheduledAction_607243,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeleteScheduledAction_607225 = ref object of OpenApiRestCall_605573
proc url_GetDeleteScheduledAction_607227(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDeleteScheduledAction_607226(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a scheduled action. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ScheduledActionName: JString (required)
  ##                      : The name of the scheduled action to delete. 
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `ScheduledActionName` field"
  var valid_607228 = query.getOrDefault("ScheduledActionName")
  valid_607228 = validateParameter(valid_607228, JString, required = true,
                                 default = nil)
  if valid_607228 != nil:
    section.add "ScheduledActionName", valid_607228
  var valid_607229 = query.getOrDefault("Action")
  valid_607229 = validateParameter(valid_607229, JString, required = true,
                                 default = newJString("DeleteScheduledAction"))
  if valid_607229 != nil:
    section.add "Action", valid_607229
  var valid_607230 = query.getOrDefault("Version")
  valid_607230 = validateParameter(valid_607230, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_607230 != nil:
    section.add "Version", valid_607230
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_607231 = header.getOrDefault("X-Amz-Signature")
  valid_607231 = validateParameter(valid_607231, JString, required = false,
                                 default = nil)
  if valid_607231 != nil:
    section.add "X-Amz-Signature", valid_607231
  var valid_607232 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_607232 = validateParameter(valid_607232, JString, required = false,
                                 default = nil)
  if valid_607232 != nil:
    section.add "X-Amz-Content-Sha256", valid_607232
  var valid_607233 = header.getOrDefault("X-Amz-Date")
  valid_607233 = validateParameter(valid_607233, JString, required = false,
                                 default = nil)
  if valid_607233 != nil:
    section.add "X-Amz-Date", valid_607233
  var valid_607234 = header.getOrDefault("X-Amz-Credential")
  valid_607234 = validateParameter(valid_607234, JString, required = false,
                                 default = nil)
  if valid_607234 != nil:
    section.add "X-Amz-Credential", valid_607234
  var valid_607235 = header.getOrDefault("X-Amz-Security-Token")
  valid_607235 = validateParameter(valid_607235, JString, required = false,
                                 default = nil)
  if valid_607235 != nil:
    section.add "X-Amz-Security-Token", valid_607235
  var valid_607236 = header.getOrDefault("X-Amz-Algorithm")
  valid_607236 = validateParameter(valid_607236, JString, required = false,
                                 default = nil)
  if valid_607236 != nil:
    section.add "X-Amz-Algorithm", valid_607236
  var valid_607237 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_607237 = validateParameter(valid_607237, JString, required = false,
                                 default = nil)
  if valid_607237 != nil:
    section.add "X-Amz-SignedHeaders", valid_607237
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_607238: Call_GetDeleteScheduledAction_607225; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a scheduled action. 
  ## 
  let valid = call_607238.validator(path, query, header, formData, body)
  let scheme = call_607238.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_607238.url(scheme.get, call_607238.host, call_607238.base,
                         call_607238.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_607238, url, valid)

proc call*(call_607239: Call_GetDeleteScheduledAction_607225;
          ScheduledActionName: string; Action: string = "DeleteScheduledAction";
          Version: string = "2012-12-01"): Recallable =
  ## getDeleteScheduledAction
  ## Deletes a scheduled action. 
  ##   ScheduledActionName: string (required)
  ##                      : The name of the scheduled action to delete. 
  ##   Action: string (required)
  ##   Version: string (required)
  var query_607240 = newJObject()
  add(query_607240, "ScheduledActionName", newJString(ScheduledActionName))
  add(query_607240, "Action", newJString(Action))
  add(query_607240, "Version", newJString(Version))
  result = call_607239.call(nil, query_607240, nil, nil, nil)

var getDeleteScheduledAction* = Call_GetDeleteScheduledAction_607225(
    name: "getDeleteScheduledAction", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteScheduledAction",
    validator: validate_GetDeleteScheduledAction_607226, base: "/",
    url: url_GetDeleteScheduledAction_607227, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDeleteSnapshotCopyGrant_607274 = ref object of OpenApiRestCall_605573
proc url_PostDeleteSnapshotCopyGrant_607276(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDeleteSnapshotCopyGrant_607275(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes the specified snapshot copy grant.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_607277 = query.getOrDefault("Action")
  valid_607277 = validateParameter(valid_607277, JString, required = true, default = newJString(
      "DeleteSnapshotCopyGrant"))
  if valid_607277 != nil:
    section.add "Action", valid_607277
  var valid_607278 = query.getOrDefault("Version")
  valid_607278 = validateParameter(valid_607278, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_607278 != nil:
    section.add "Version", valid_607278
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_607279 = header.getOrDefault("X-Amz-Signature")
  valid_607279 = validateParameter(valid_607279, JString, required = false,
                                 default = nil)
  if valid_607279 != nil:
    section.add "X-Amz-Signature", valid_607279
  var valid_607280 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_607280 = validateParameter(valid_607280, JString, required = false,
                                 default = nil)
  if valid_607280 != nil:
    section.add "X-Amz-Content-Sha256", valid_607280
  var valid_607281 = header.getOrDefault("X-Amz-Date")
  valid_607281 = validateParameter(valid_607281, JString, required = false,
                                 default = nil)
  if valid_607281 != nil:
    section.add "X-Amz-Date", valid_607281
  var valid_607282 = header.getOrDefault("X-Amz-Credential")
  valid_607282 = validateParameter(valid_607282, JString, required = false,
                                 default = nil)
  if valid_607282 != nil:
    section.add "X-Amz-Credential", valid_607282
  var valid_607283 = header.getOrDefault("X-Amz-Security-Token")
  valid_607283 = validateParameter(valid_607283, JString, required = false,
                                 default = nil)
  if valid_607283 != nil:
    section.add "X-Amz-Security-Token", valid_607283
  var valid_607284 = header.getOrDefault("X-Amz-Algorithm")
  valid_607284 = validateParameter(valid_607284, JString, required = false,
                                 default = nil)
  if valid_607284 != nil:
    section.add "X-Amz-Algorithm", valid_607284
  var valid_607285 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_607285 = validateParameter(valid_607285, JString, required = false,
                                 default = nil)
  if valid_607285 != nil:
    section.add "X-Amz-SignedHeaders", valid_607285
  result.add "header", section
  ## parameters in `formData` object:
  ##   SnapshotCopyGrantName: JString (required)
  ##                        : The name of the snapshot copy grant to delete.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `SnapshotCopyGrantName` field"
  var valid_607286 = formData.getOrDefault("SnapshotCopyGrantName")
  valid_607286 = validateParameter(valid_607286, JString, required = true,
                                 default = nil)
  if valid_607286 != nil:
    section.add "SnapshotCopyGrantName", valid_607286
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_607287: Call_PostDeleteSnapshotCopyGrant_607274; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes the specified snapshot copy grant.
  ## 
  let valid = call_607287.validator(path, query, header, formData, body)
  let scheme = call_607287.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_607287.url(scheme.get, call_607287.host, call_607287.base,
                         call_607287.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_607287, url, valid)

proc call*(call_607288: Call_PostDeleteSnapshotCopyGrant_607274;
          SnapshotCopyGrantName: string;
          Action: string = "DeleteSnapshotCopyGrant"; Version: string = "2012-12-01"): Recallable =
  ## postDeleteSnapshotCopyGrant
  ## Deletes the specified snapshot copy grant.
  ##   Action: string (required)
  ##   SnapshotCopyGrantName: string (required)
  ##                        : The name of the snapshot copy grant to delete.
  ##   Version: string (required)
  var query_607289 = newJObject()
  var formData_607290 = newJObject()
  add(query_607289, "Action", newJString(Action))
  add(formData_607290, "SnapshotCopyGrantName", newJString(SnapshotCopyGrantName))
  add(query_607289, "Version", newJString(Version))
  result = call_607288.call(nil, query_607289, nil, formData_607290, nil)

var postDeleteSnapshotCopyGrant* = Call_PostDeleteSnapshotCopyGrant_607274(
    name: "postDeleteSnapshotCopyGrant", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteSnapshotCopyGrant",
    validator: validate_PostDeleteSnapshotCopyGrant_607275, base: "/",
    url: url_PostDeleteSnapshotCopyGrant_607276,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeleteSnapshotCopyGrant_607258 = ref object of OpenApiRestCall_605573
proc url_GetDeleteSnapshotCopyGrant_607260(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDeleteSnapshotCopyGrant_607259(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes the specified snapshot copy grant.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  ##   SnapshotCopyGrantName: JString (required)
  ##                        : The name of the snapshot copy grant to delete.
  section = newJObject()
  var valid_607261 = query.getOrDefault("Action")
  valid_607261 = validateParameter(valid_607261, JString, required = true, default = newJString(
      "DeleteSnapshotCopyGrant"))
  if valid_607261 != nil:
    section.add "Action", valid_607261
  var valid_607262 = query.getOrDefault("Version")
  valid_607262 = validateParameter(valid_607262, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_607262 != nil:
    section.add "Version", valid_607262
  var valid_607263 = query.getOrDefault("SnapshotCopyGrantName")
  valid_607263 = validateParameter(valid_607263, JString, required = true,
                                 default = nil)
  if valid_607263 != nil:
    section.add "SnapshotCopyGrantName", valid_607263
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_607264 = header.getOrDefault("X-Amz-Signature")
  valid_607264 = validateParameter(valid_607264, JString, required = false,
                                 default = nil)
  if valid_607264 != nil:
    section.add "X-Amz-Signature", valid_607264
  var valid_607265 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_607265 = validateParameter(valid_607265, JString, required = false,
                                 default = nil)
  if valid_607265 != nil:
    section.add "X-Amz-Content-Sha256", valid_607265
  var valid_607266 = header.getOrDefault("X-Amz-Date")
  valid_607266 = validateParameter(valid_607266, JString, required = false,
                                 default = nil)
  if valid_607266 != nil:
    section.add "X-Amz-Date", valid_607266
  var valid_607267 = header.getOrDefault("X-Amz-Credential")
  valid_607267 = validateParameter(valid_607267, JString, required = false,
                                 default = nil)
  if valid_607267 != nil:
    section.add "X-Amz-Credential", valid_607267
  var valid_607268 = header.getOrDefault("X-Amz-Security-Token")
  valid_607268 = validateParameter(valid_607268, JString, required = false,
                                 default = nil)
  if valid_607268 != nil:
    section.add "X-Amz-Security-Token", valid_607268
  var valid_607269 = header.getOrDefault("X-Amz-Algorithm")
  valid_607269 = validateParameter(valid_607269, JString, required = false,
                                 default = nil)
  if valid_607269 != nil:
    section.add "X-Amz-Algorithm", valid_607269
  var valid_607270 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_607270 = validateParameter(valid_607270, JString, required = false,
                                 default = nil)
  if valid_607270 != nil:
    section.add "X-Amz-SignedHeaders", valid_607270
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_607271: Call_GetDeleteSnapshotCopyGrant_607258; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes the specified snapshot copy grant.
  ## 
  let valid = call_607271.validator(path, query, header, formData, body)
  let scheme = call_607271.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_607271.url(scheme.get, call_607271.host, call_607271.base,
                         call_607271.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_607271, url, valid)

proc call*(call_607272: Call_GetDeleteSnapshotCopyGrant_607258;
          SnapshotCopyGrantName: string;
          Action: string = "DeleteSnapshotCopyGrant"; Version: string = "2012-12-01"): Recallable =
  ## getDeleteSnapshotCopyGrant
  ## Deletes the specified snapshot copy grant.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   SnapshotCopyGrantName: string (required)
  ##                        : The name of the snapshot copy grant to delete.
  var query_607273 = newJObject()
  add(query_607273, "Action", newJString(Action))
  add(query_607273, "Version", newJString(Version))
  add(query_607273, "SnapshotCopyGrantName", newJString(SnapshotCopyGrantName))
  result = call_607272.call(nil, query_607273, nil, nil, nil)

var getDeleteSnapshotCopyGrant* = Call_GetDeleteSnapshotCopyGrant_607258(
    name: "getDeleteSnapshotCopyGrant", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteSnapshotCopyGrant",
    validator: validate_GetDeleteSnapshotCopyGrant_607259, base: "/",
    url: url_GetDeleteSnapshotCopyGrant_607260,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDeleteSnapshotSchedule_607307 = ref object of OpenApiRestCall_605573
proc url_PostDeleteSnapshotSchedule_607309(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDeleteSnapshotSchedule_607308(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a snapshot schedule.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_607310 = query.getOrDefault("Action")
  valid_607310 = validateParameter(valid_607310, JString, required = true,
                                 default = newJString("DeleteSnapshotSchedule"))
  if valid_607310 != nil:
    section.add "Action", valid_607310
  var valid_607311 = query.getOrDefault("Version")
  valid_607311 = validateParameter(valid_607311, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_607311 != nil:
    section.add "Version", valid_607311
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_607312 = header.getOrDefault("X-Amz-Signature")
  valid_607312 = validateParameter(valid_607312, JString, required = false,
                                 default = nil)
  if valid_607312 != nil:
    section.add "X-Amz-Signature", valid_607312
  var valid_607313 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_607313 = validateParameter(valid_607313, JString, required = false,
                                 default = nil)
  if valid_607313 != nil:
    section.add "X-Amz-Content-Sha256", valid_607313
  var valid_607314 = header.getOrDefault("X-Amz-Date")
  valid_607314 = validateParameter(valid_607314, JString, required = false,
                                 default = nil)
  if valid_607314 != nil:
    section.add "X-Amz-Date", valid_607314
  var valid_607315 = header.getOrDefault("X-Amz-Credential")
  valid_607315 = validateParameter(valid_607315, JString, required = false,
                                 default = nil)
  if valid_607315 != nil:
    section.add "X-Amz-Credential", valid_607315
  var valid_607316 = header.getOrDefault("X-Amz-Security-Token")
  valid_607316 = validateParameter(valid_607316, JString, required = false,
                                 default = nil)
  if valid_607316 != nil:
    section.add "X-Amz-Security-Token", valid_607316
  var valid_607317 = header.getOrDefault("X-Amz-Algorithm")
  valid_607317 = validateParameter(valid_607317, JString, required = false,
                                 default = nil)
  if valid_607317 != nil:
    section.add "X-Amz-Algorithm", valid_607317
  var valid_607318 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_607318 = validateParameter(valid_607318, JString, required = false,
                                 default = nil)
  if valid_607318 != nil:
    section.add "X-Amz-SignedHeaders", valid_607318
  result.add "header", section
  ## parameters in `formData` object:
  ##   ScheduleIdentifier: JString (required)
  ##                     : A unique identifier of the snapshot schedule to delete.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ScheduleIdentifier` field"
  var valid_607319 = formData.getOrDefault("ScheduleIdentifier")
  valid_607319 = validateParameter(valid_607319, JString, required = true,
                                 default = nil)
  if valid_607319 != nil:
    section.add "ScheduleIdentifier", valid_607319
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_607320: Call_PostDeleteSnapshotSchedule_607307; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a snapshot schedule.
  ## 
  let valid = call_607320.validator(path, query, header, formData, body)
  let scheme = call_607320.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_607320.url(scheme.get, call_607320.host, call_607320.base,
                         call_607320.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_607320, url, valid)

proc call*(call_607321: Call_PostDeleteSnapshotSchedule_607307;
          ScheduleIdentifier: string; Action: string = "DeleteSnapshotSchedule";
          Version: string = "2012-12-01"): Recallable =
  ## postDeleteSnapshotSchedule
  ## Deletes a snapshot schedule.
  ##   Action: string (required)
  ##   ScheduleIdentifier: string (required)
  ##                     : A unique identifier of the snapshot schedule to delete.
  ##   Version: string (required)
  var query_607322 = newJObject()
  var formData_607323 = newJObject()
  add(query_607322, "Action", newJString(Action))
  add(formData_607323, "ScheduleIdentifier", newJString(ScheduleIdentifier))
  add(query_607322, "Version", newJString(Version))
  result = call_607321.call(nil, query_607322, nil, formData_607323, nil)

var postDeleteSnapshotSchedule* = Call_PostDeleteSnapshotSchedule_607307(
    name: "postDeleteSnapshotSchedule", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteSnapshotSchedule",
    validator: validate_PostDeleteSnapshotSchedule_607308, base: "/",
    url: url_PostDeleteSnapshotSchedule_607309,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeleteSnapshotSchedule_607291 = ref object of OpenApiRestCall_605573
proc url_GetDeleteSnapshotSchedule_607293(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDeleteSnapshotSchedule_607292(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a snapshot schedule.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ScheduleIdentifier: JString (required)
  ##                     : A unique identifier of the snapshot schedule to delete.
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `ScheduleIdentifier` field"
  var valid_607294 = query.getOrDefault("ScheduleIdentifier")
  valid_607294 = validateParameter(valid_607294, JString, required = true,
                                 default = nil)
  if valid_607294 != nil:
    section.add "ScheduleIdentifier", valid_607294
  var valid_607295 = query.getOrDefault("Action")
  valid_607295 = validateParameter(valid_607295, JString, required = true,
                                 default = newJString("DeleteSnapshotSchedule"))
  if valid_607295 != nil:
    section.add "Action", valid_607295
  var valid_607296 = query.getOrDefault("Version")
  valid_607296 = validateParameter(valid_607296, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_607296 != nil:
    section.add "Version", valid_607296
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_607297 = header.getOrDefault("X-Amz-Signature")
  valid_607297 = validateParameter(valid_607297, JString, required = false,
                                 default = nil)
  if valid_607297 != nil:
    section.add "X-Amz-Signature", valid_607297
  var valid_607298 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_607298 = validateParameter(valid_607298, JString, required = false,
                                 default = nil)
  if valid_607298 != nil:
    section.add "X-Amz-Content-Sha256", valid_607298
  var valid_607299 = header.getOrDefault("X-Amz-Date")
  valid_607299 = validateParameter(valid_607299, JString, required = false,
                                 default = nil)
  if valid_607299 != nil:
    section.add "X-Amz-Date", valid_607299
  var valid_607300 = header.getOrDefault("X-Amz-Credential")
  valid_607300 = validateParameter(valid_607300, JString, required = false,
                                 default = nil)
  if valid_607300 != nil:
    section.add "X-Amz-Credential", valid_607300
  var valid_607301 = header.getOrDefault("X-Amz-Security-Token")
  valid_607301 = validateParameter(valid_607301, JString, required = false,
                                 default = nil)
  if valid_607301 != nil:
    section.add "X-Amz-Security-Token", valid_607301
  var valid_607302 = header.getOrDefault("X-Amz-Algorithm")
  valid_607302 = validateParameter(valid_607302, JString, required = false,
                                 default = nil)
  if valid_607302 != nil:
    section.add "X-Amz-Algorithm", valid_607302
  var valid_607303 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_607303 = validateParameter(valid_607303, JString, required = false,
                                 default = nil)
  if valid_607303 != nil:
    section.add "X-Amz-SignedHeaders", valid_607303
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_607304: Call_GetDeleteSnapshotSchedule_607291; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a snapshot schedule.
  ## 
  let valid = call_607304.validator(path, query, header, formData, body)
  let scheme = call_607304.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_607304.url(scheme.get, call_607304.host, call_607304.base,
                         call_607304.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_607304, url, valid)

proc call*(call_607305: Call_GetDeleteSnapshotSchedule_607291;
          ScheduleIdentifier: string; Action: string = "DeleteSnapshotSchedule";
          Version: string = "2012-12-01"): Recallable =
  ## getDeleteSnapshotSchedule
  ## Deletes a snapshot schedule.
  ##   ScheduleIdentifier: string (required)
  ##                     : A unique identifier of the snapshot schedule to delete.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_607306 = newJObject()
  add(query_607306, "ScheduleIdentifier", newJString(ScheduleIdentifier))
  add(query_607306, "Action", newJString(Action))
  add(query_607306, "Version", newJString(Version))
  result = call_607305.call(nil, query_607306, nil, nil, nil)

var getDeleteSnapshotSchedule* = Call_GetDeleteSnapshotSchedule_607291(
    name: "getDeleteSnapshotSchedule", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteSnapshotSchedule",
    validator: validate_GetDeleteSnapshotSchedule_607292, base: "/",
    url: url_GetDeleteSnapshotSchedule_607293,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDeleteTags_607341 = ref object of OpenApiRestCall_605573
proc url_PostDeleteTags_607343(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDeleteTags_607342(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode): JsonNode =
  ## Deletes tags from a resource. You must provide the ARN of the resource from which you want to delete the tag or tags.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_607344 = query.getOrDefault("Action")
  valid_607344 = validateParameter(valid_607344, JString, required = true,
                                 default = newJString("DeleteTags"))
  if valid_607344 != nil:
    section.add "Action", valid_607344
  var valid_607345 = query.getOrDefault("Version")
  valid_607345 = validateParameter(valid_607345, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_607345 != nil:
    section.add "Version", valid_607345
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_607346 = header.getOrDefault("X-Amz-Signature")
  valid_607346 = validateParameter(valid_607346, JString, required = false,
                                 default = nil)
  if valid_607346 != nil:
    section.add "X-Amz-Signature", valid_607346
  var valid_607347 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_607347 = validateParameter(valid_607347, JString, required = false,
                                 default = nil)
  if valid_607347 != nil:
    section.add "X-Amz-Content-Sha256", valid_607347
  var valid_607348 = header.getOrDefault("X-Amz-Date")
  valid_607348 = validateParameter(valid_607348, JString, required = false,
                                 default = nil)
  if valid_607348 != nil:
    section.add "X-Amz-Date", valid_607348
  var valid_607349 = header.getOrDefault("X-Amz-Credential")
  valid_607349 = validateParameter(valid_607349, JString, required = false,
                                 default = nil)
  if valid_607349 != nil:
    section.add "X-Amz-Credential", valid_607349
  var valid_607350 = header.getOrDefault("X-Amz-Security-Token")
  valid_607350 = validateParameter(valid_607350, JString, required = false,
                                 default = nil)
  if valid_607350 != nil:
    section.add "X-Amz-Security-Token", valid_607350
  var valid_607351 = header.getOrDefault("X-Amz-Algorithm")
  valid_607351 = validateParameter(valid_607351, JString, required = false,
                                 default = nil)
  if valid_607351 != nil:
    section.add "X-Amz-Algorithm", valid_607351
  var valid_607352 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_607352 = validateParameter(valid_607352, JString, required = false,
                                 default = nil)
  if valid_607352 != nil:
    section.add "X-Amz-SignedHeaders", valid_607352
  result.add "header", section
  ## parameters in `formData` object:
  ##   TagKeys: JArray (required)
  ##          : The tag key that you want to delete.
  ##   ResourceName: JString (required)
  ##               : The Amazon Resource Name (ARN) from which you want to remove the tag or tags. For example, <code>arn:aws:redshift:us-east-2:123456789:cluster:t1</code>. 
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `TagKeys` field"
  var valid_607353 = formData.getOrDefault("TagKeys")
  valid_607353 = validateParameter(valid_607353, JArray, required = true, default = nil)
  if valid_607353 != nil:
    section.add "TagKeys", valid_607353
  var valid_607354 = formData.getOrDefault("ResourceName")
  valid_607354 = validateParameter(valid_607354, JString, required = true,
                                 default = nil)
  if valid_607354 != nil:
    section.add "ResourceName", valid_607354
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_607355: Call_PostDeleteTags_607341; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes tags from a resource. You must provide the ARN of the resource from which you want to delete the tag or tags.
  ## 
  let valid = call_607355.validator(path, query, header, formData, body)
  let scheme = call_607355.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_607355.url(scheme.get, call_607355.host, call_607355.base,
                         call_607355.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_607355, url, valid)

proc call*(call_607356: Call_PostDeleteTags_607341; TagKeys: JsonNode;
          ResourceName: string; Action: string = "DeleteTags";
          Version: string = "2012-12-01"): Recallable =
  ## postDeleteTags
  ## Deletes tags from a resource. You must provide the ARN of the resource from which you want to delete the tag or tags.
  ##   TagKeys: JArray (required)
  ##          : The tag key that you want to delete.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   ResourceName: string (required)
  ##               : The Amazon Resource Name (ARN) from which you want to remove the tag or tags. For example, <code>arn:aws:redshift:us-east-2:123456789:cluster:t1</code>. 
  var query_607357 = newJObject()
  var formData_607358 = newJObject()
  if TagKeys != nil:
    formData_607358.add "TagKeys", TagKeys
  add(query_607357, "Action", newJString(Action))
  add(query_607357, "Version", newJString(Version))
  add(formData_607358, "ResourceName", newJString(ResourceName))
  result = call_607356.call(nil, query_607357, nil, formData_607358, nil)

var postDeleteTags* = Call_PostDeleteTags_607341(name: "postDeleteTags",
    meth: HttpMethod.HttpPost, host: "redshift.amazonaws.com",
    route: "/#Action=DeleteTags", validator: validate_PostDeleteTags_607342,
    base: "/", url: url_PostDeleteTags_607343, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeleteTags_607324 = ref object of OpenApiRestCall_605573
proc url_GetDeleteTags_607326(protocol: Scheme; host: string; base: string;
                             route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDeleteTags_607325(path: JsonNode; query: JsonNode; header: JsonNode;
                                  formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes tags from a resource. You must provide the ARN of the resource from which you want to delete the tag or tags.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ResourceName: JString (required)
  ##               : The Amazon Resource Name (ARN) from which you want to remove the tag or tags. For example, <code>arn:aws:redshift:us-east-2:123456789:cluster:t1</code>. 
  ##   TagKeys: JArray (required)
  ##          : The tag key that you want to delete.
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `ResourceName` field"
  var valid_607327 = query.getOrDefault("ResourceName")
  valid_607327 = validateParameter(valid_607327, JString, required = true,
                                 default = nil)
  if valid_607327 != nil:
    section.add "ResourceName", valid_607327
  var valid_607328 = query.getOrDefault("TagKeys")
  valid_607328 = validateParameter(valid_607328, JArray, required = true, default = nil)
  if valid_607328 != nil:
    section.add "TagKeys", valid_607328
  var valid_607329 = query.getOrDefault("Action")
  valid_607329 = validateParameter(valid_607329, JString, required = true,
                                 default = newJString("DeleteTags"))
  if valid_607329 != nil:
    section.add "Action", valid_607329
  var valid_607330 = query.getOrDefault("Version")
  valid_607330 = validateParameter(valid_607330, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_607330 != nil:
    section.add "Version", valid_607330
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_607331 = header.getOrDefault("X-Amz-Signature")
  valid_607331 = validateParameter(valid_607331, JString, required = false,
                                 default = nil)
  if valid_607331 != nil:
    section.add "X-Amz-Signature", valid_607331
  var valid_607332 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_607332 = validateParameter(valid_607332, JString, required = false,
                                 default = nil)
  if valid_607332 != nil:
    section.add "X-Amz-Content-Sha256", valid_607332
  var valid_607333 = header.getOrDefault("X-Amz-Date")
  valid_607333 = validateParameter(valid_607333, JString, required = false,
                                 default = nil)
  if valid_607333 != nil:
    section.add "X-Amz-Date", valid_607333
  var valid_607334 = header.getOrDefault("X-Amz-Credential")
  valid_607334 = validateParameter(valid_607334, JString, required = false,
                                 default = nil)
  if valid_607334 != nil:
    section.add "X-Amz-Credential", valid_607334
  var valid_607335 = header.getOrDefault("X-Amz-Security-Token")
  valid_607335 = validateParameter(valid_607335, JString, required = false,
                                 default = nil)
  if valid_607335 != nil:
    section.add "X-Amz-Security-Token", valid_607335
  var valid_607336 = header.getOrDefault("X-Amz-Algorithm")
  valid_607336 = validateParameter(valid_607336, JString, required = false,
                                 default = nil)
  if valid_607336 != nil:
    section.add "X-Amz-Algorithm", valid_607336
  var valid_607337 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_607337 = validateParameter(valid_607337, JString, required = false,
                                 default = nil)
  if valid_607337 != nil:
    section.add "X-Amz-SignedHeaders", valid_607337
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_607338: Call_GetDeleteTags_607324; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes tags from a resource. You must provide the ARN of the resource from which you want to delete the tag or tags.
  ## 
  let valid = call_607338.validator(path, query, header, formData, body)
  let scheme = call_607338.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_607338.url(scheme.get, call_607338.host, call_607338.base,
                         call_607338.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_607338, url, valid)

proc call*(call_607339: Call_GetDeleteTags_607324; ResourceName: string;
          TagKeys: JsonNode; Action: string = "DeleteTags";
          Version: string = "2012-12-01"): Recallable =
  ## getDeleteTags
  ## Deletes tags from a resource. You must provide the ARN of the resource from which you want to delete the tag or tags.
  ##   ResourceName: string (required)
  ##               : The Amazon Resource Name (ARN) from which you want to remove the tag or tags. For example, <code>arn:aws:redshift:us-east-2:123456789:cluster:t1</code>. 
  ##   TagKeys: JArray (required)
  ##          : The tag key that you want to delete.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_607340 = newJObject()
  add(query_607340, "ResourceName", newJString(ResourceName))
  if TagKeys != nil:
    query_607340.add "TagKeys", TagKeys
  add(query_607340, "Action", newJString(Action))
  add(query_607340, "Version", newJString(Version))
  result = call_607339.call(nil, query_607340, nil, nil, nil)

var getDeleteTags* = Call_GetDeleteTags_607324(name: "getDeleteTags",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=DeleteTags", validator: validate_GetDeleteTags_607325,
    base: "/", url: url_GetDeleteTags_607326, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeAccountAttributes_607375 = ref object of OpenApiRestCall_605573
proc url_PostDescribeAccountAttributes_607377(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeAccountAttributes_607376(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns a list of attributes attached to an account
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_607378 = query.getOrDefault("Action")
  valid_607378 = validateParameter(valid_607378, JString, required = true, default = newJString(
      "DescribeAccountAttributes"))
  if valid_607378 != nil:
    section.add "Action", valid_607378
  var valid_607379 = query.getOrDefault("Version")
  valid_607379 = validateParameter(valid_607379, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_607379 != nil:
    section.add "Version", valid_607379
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_607380 = header.getOrDefault("X-Amz-Signature")
  valid_607380 = validateParameter(valid_607380, JString, required = false,
                                 default = nil)
  if valid_607380 != nil:
    section.add "X-Amz-Signature", valid_607380
  var valid_607381 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_607381 = validateParameter(valid_607381, JString, required = false,
                                 default = nil)
  if valid_607381 != nil:
    section.add "X-Amz-Content-Sha256", valid_607381
  var valid_607382 = header.getOrDefault("X-Amz-Date")
  valid_607382 = validateParameter(valid_607382, JString, required = false,
                                 default = nil)
  if valid_607382 != nil:
    section.add "X-Amz-Date", valid_607382
  var valid_607383 = header.getOrDefault("X-Amz-Credential")
  valid_607383 = validateParameter(valid_607383, JString, required = false,
                                 default = nil)
  if valid_607383 != nil:
    section.add "X-Amz-Credential", valid_607383
  var valid_607384 = header.getOrDefault("X-Amz-Security-Token")
  valid_607384 = validateParameter(valid_607384, JString, required = false,
                                 default = nil)
  if valid_607384 != nil:
    section.add "X-Amz-Security-Token", valid_607384
  var valid_607385 = header.getOrDefault("X-Amz-Algorithm")
  valid_607385 = validateParameter(valid_607385, JString, required = false,
                                 default = nil)
  if valid_607385 != nil:
    section.add "X-Amz-Algorithm", valid_607385
  var valid_607386 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_607386 = validateParameter(valid_607386, JString, required = false,
                                 default = nil)
  if valid_607386 != nil:
    section.add "X-Amz-SignedHeaders", valid_607386
  result.add "header", section
  ## parameters in `formData` object:
  ##   AttributeNames: JArray
  ##                 : A list of attribute names.
  section = newJObject()
  var valid_607387 = formData.getOrDefault("AttributeNames")
  valid_607387 = validateParameter(valid_607387, JArray, required = false,
                                 default = nil)
  if valid_607387 != nil:
    section.add "AttributeNames", valid_607387
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_607388: Call_PostDescribeAccountAttributes_607375; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns a list of attributes attached to an account
  ## 
  let valid = call_607388.validator(path, query, header, formData, body)
  let scheme = call_607388.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_607388.url(scheme.get, call_607388.host, call_607388.base,
                         call_607388.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_607388, url, valid)

proc call*(call_607389: Call_PostDescribeAccountAttributes_607375;
          AttributeNames: JsonNode = nil;
          Action: string = "DescribeAccountAttributes";
          Version: string = "2012-12-01"): Recallable =
  ## postDescribeAccountAttributes
  ## Returns a list of attributes attached to an account
  ##   AttributeNames: JArray
  ##                 : A list of attribute names.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_607390 = newJObject()
  var formData_607391 = newJObject()
  if AttributeNames != nil:
    formData_607391.add "AttributeNames", AttributeNames
  add(query_607390, "Action", newJString(Action))
  add(query_607390, "Version", newJString(Version))
  result = call_607389.call(nil, query_607390, nil, formData_607391, nil)

var postDescribeAccountAttributes* = Call_PostDescribeAccountAttributes_607375(
    name: "postDescribeAccountAttributes", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeAccountAttributes",
    validator: validate_PostDescribeAccountAttributes_607376, base: "/",
    url: url_PostDescribeAccountAttributes_607377,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeAccountAttributes_607359 = ref object of OpenApiRestCall_605573
proc url_GetDescribeAccountAttributes_607361(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeAccountAttributes_607360(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns a list of attributes attached to an account
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   AttributeNames: JArray
  ##                 : A list of attribute names.
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_607362 = query.getOrDefault("AttributeNames")
  valid_607362 = validateParameter(valid_607362, JArray, required = false,
                                 default = nil)
  if valid_607362 != nil:
    section.add "AttributeNames", valid_607362
  var valid_607363 = query.getOrDefault("Action")
  valid_607363 = validateParameter(valid_607363, JString, required = true, default = newJString(
      "DescribeAccountAttributes"))
  if valid_607363 != nil:
    section.add "Action", valid_607363
  var valid_607364 = query.getOrDefault("Version")
  valid_607364 = validateParameter(valid_607364, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_607364 != nil:
    section.add "Version", valid_607364
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_607365 = header.getOrDefault("X-Amz-Signature")
  valid_607365 = validateParameter(valid_607365, JString, required = false,
                                 default = nil)
  if valid_607365 != nil:
    section.add "X-Amz-Signature", valid_607365
  var valid_607366 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_607366 = validateParameter(valid_607366, JString, required = false,
                                 default = nil)
  if valid_607366 != nil:
    section.add "X-Amz-Content-Sha256", valid_607366
  var valid_607367 = header.getOrDefault("X-Amz-Date")
  valid_607367 = validateParameter(valid_607367, JString, required = false,
                                 default = nil)
  if valid_607367 != nil:
    section.add "X-Amz-Date", valid_607367
  var valid_607368 = header.getOrDefault("X-Amz-Credential")
  valid_607368 = validateParameter(valid_607368, JString, required = false,
                                 default = nil)
  if valid_607368 != nil:
    section.add "X-Amz-Credential", valid_607368
  var valid_607369 = header.getOrDefault("X-Amz-Security-Token")
  valid_607369 = validateParameter(valid_607369, JString, required = false,
                                 default = nil)
  if valid_607369 != nil:
    section.add "X-Amz-Security-Token", valid_607369
  var valid_607370 = header.getOrDefault("X-Amz-Algorithm")
  valid_607370 = validateParameter(valid_607370, JString, required = false,
                                 default = nil)
  if valid_607370 != nil:
    section.add "X-Amz-Algorithm", valid_607370
  var valid_607371 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_607371 = validateParameter(valid_607371, JString, required = false,
                                 default = nil)
  if valid_607371 != nil:
    section.add "X-Amz-SignedHeaders", valid_607371
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_607372: Call_GetDescribeAccountAttributes_607359; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns a list of attributes attached to an account
  ## 
  let valid = call_607372.validator(path, query, header, formData, body)
  let scheme = call_607372.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_607372.url(scheme.get, call_607372.host, call_607372.base,
                         call_607372.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_607372, url, valid)

proc call*(call_607373: Call_GetDescribeAccountAttributes_607359;
          AttributeNames: JsonNode = nil;
          Action: string = "DescribeAccountAttributes";
          Version: string = "2012-12-01"): Recallable =
  ## getDescribeAccountAttributes
  ## Returns a list of attributes attached to an account
  ##   AttributeNames: JArray
  ##                 : A list of attribute names.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_607374 = newJObject()
  if AttributeNames != nil:
    query_607374.add "AttributeNames", AttributeNames
  add(query_607374, "Action", newJString(Action))
  add(query_607374, "Version", newJString(Version))
  result = call_607373.call(nil, query_607374, nil, nil, nil)

var getDescribeAccountAttributes* = Call_GetDescribeAccountAttributes_607359(
    name: "getDescribeAccountAttributes", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeAccountAttributes",
    validator: validate_GetDescribeAccountAttributes_607360, base: "/",
    url: url_GetDescribeAccountAttributes_607361,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeClusterDbRevisions_607410 = ref object of OpenApiRestCall_605573
proc url_PostDescribeClusterDbRevisions_607412(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeClusterDbRevisions_607411(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns an array of <code>ClusterDbRevision</code> objects.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_607413 = query.getOrDefault("Action")
  valid_607413 = validateParameter(valid_607413, JString, required = true, default = newJString(
      "DescribeClusterDbRevisions"))
  if valid_607413 != nil:
    section.add "Action", valid_607413
  var valid_607414 = query.getOrDefault("Version")
  valid_607414 = validateParameter(valid_607414, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_607414 != nil:
    section.add "Version", valid_607414
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_607415 = header.getOrDefault("X-Amz-Signature")
  valid_607415 = validateParameter(valid_607415, JString, required = false,
                                 default = nil)
  if valid_607415 != nil:
    section.add "X-Amz-Signature", valid_607415
  var valid_607416 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_607416 = validateParameter(valid_607416, JString, required = false,
                                 default = nil)
  if valid_607416 != nil:
    section.add "X-Amz-Content-Sha256", valid_607416
  var valid_607417 = header.getOrDefault("X-Amz-Date")
  valid_607417 = validateParameter(valid_607417, JString, required = false,
                                 default = nil)
  if valid_607417 != nil:
    section.add "X-Amz-Date", valid_607417
  var valid_607418 = header.getOrDefault("X-Amz-Credential")
  valid_607418 = validateParameter(valid_607418, JString, required = false,
                                 default = nil)
  if valid_607418 != nil:
    section.add "X-Amz-Credential", valid_607418
  var valid_607419 = header.getOrDefault("X-Amz-Security-Token")
  valid_607419 = validateParameter(valid_607419, JString, required = false,
                                 default = nil)
  if valid_607419 != nil:
    section.add "X-Amz-Security-Token", valid_607419
  var valid_607420 = header.getOrDefault("X-Amz-Algorithm")
  valid_607420 = validateParameter(valid_607420, JString, required = false,
                                 default = nil)
  if valid_607420 != nil:
    section.add "X-Amz-Algorithm", valid_607420
  var valid_607421 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_607421 = validateParameter(valid_607421, JString, required = false,
                                 default = nil)
  if valid_607421 != nil:
    section.add "X-Amz-SignedHeaders", valid_607421
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString
  ##                    : A unique identifier for a cluster whose <code>ClusterDbRevisions</code> you are requesting. This parameter is case sensitive. All clusters defined for an account are returned by default.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified MaxRecords value, a value is returned in the <code>marker</code> field of the response. You can retrieve the next set of response records by providing the returned <code>marker</code> value in the <code>marker</code> parameter and retrying the request. </p> <p>Default: 100</p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: JString
  ##         : <p>An optional parameter that specifies the starting point for returning a set of response records. When the results of a <code>DescribeClusterDbRevisions</code> request exceed the value specified in <code>MaxRecords</code>, Amazon Redshift returns a value in the <code>marker</code> field of the response. You can retrieve the next set of response records by providing the returned <code>marker</code> value in the <code>marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <code>ClusterIdentifier</code> parameter, or the <code>marker</code> parameter, but not both.</p>
  section = newJObject()
  var valid_607422 = formData.getOrDefault("ClusterIdentifier")
  valid_607422 = validateParameter(valid_607422, JString, required = false,
                                 default = nil)
  if valid_607422 != nil:
    section.add "ClusterIdentifier", valid_607422
  var valid_607423 = formData.getOrDefault("MaxRecords")
  valid_607423 = validateParameter(valid_607423, JInt, required = false, default = nil)
  if valid_607423 != nil:
    section.add "MaxRecords", valid_607423
  var valid_607424 = formData.getOrDefault("Marker")
  valid_607424 = validateParameter(valid_607424, JString, required = false,
                                 default = nil)
  if valid_607424 != nil:
    section.add "Marker", valid_607424
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_607425: Call_PostDescribeClusterDbRevisions_607410; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns an array of <code>ClusterDbRevision</code> objects.
  ## 
  let valid = call_607425.validator(path, query, header, formData, body)
  let scheme = call_607425.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_607425.url(scheme.get, call_607425.host, call_607425.base,
                         call_607425.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_607425, url, valid)

proc call*(call_607426: Call_PostDescribeClusterDbRevisions_607410;
          ClusterIdentifier: string = ""; MaxRecords: int = 0; Marker: string = "";
          Action: string = "DescribeClusterDbRevisions";
          Version: string = "2012-12-01"): Recallable =
  ## postDescribeClusterDbRevisions
  ## Returns an array of <code>ClusterDbRevision</code> objects.
  ##   ClusterIdentifier: string
  ##                    : A unique identifier for a cluster whose <code>ClusterDbRevisions</code> you are requesting. This parameter is case sensitive. All clusters defined for an account are returned by default.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified MaxRecords value, a value is returned in the <code>marker</code> field of the response. You can retrieve the next set of response records by providing the returned <code>marker</code> value in the <code>marker</code> parameter and retrying the request. </p> <p>Default: 100</p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: string
  ##         : <p>An optional parameter that specifies the starting point for returning a set of response records. When the results of a <code>DescribeClusterDbRevisions</code> request exceed the value specified in <code>MaxRecords</code>, Amazon Redshift returns a value in the <code>marker</code> field of the response. You can retrieve the next set of response records by providing the returned <code>marker</code> value in the <code>marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <code>ClusterIdentifier</code> parameter, or the <code>marker</code> parameter, but not both.</p>
  ##   Action: string (required)
  ##   Version: string (required)
  var query_607427 = newJObject()
  var formData_607428 = newJObject()
  add(formData_607428, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_607428, "MaxRecords", newJInt(MaxRecords))
  add(formData_607428, "Marker", newJString(Marker))
  add(query_607427, "Action", newJString(Action))
  add(query_607427, "Version", newJString(Version))
  result = call_607426.call(nil, query_607427, nil, formData_607428, nil)

var postDescribeClusterDbRevisions* = Call_PostDescribeClusterDbRevisions_607410(
    name: "postDescribeClusterDbRevisions", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusterDbRevisions",
    validator: validate_PostDescribeClusterDbRevisions_607411, base: "/",
    url: url_PostDescribeClusterDbRevisions_607412,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeClusterDbRevisions_607392 = ref object of OpenApiRestCall_605573
proc url_GetDescribeClusterDbRevisions_607394(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeClusterDbRevisions_607393(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns an array of <code>ClusterDbRevision</code> objects.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Marker: JString
  ##         : <p>An optional parameter that specifies the starting point for returning a set of response records. When the results of a <code>DescribeClusterDbRevisions</code> request exceed the value specified in <code>MaxRecords</code>, Amazon Redshift returns a value in the <code>marker</code> field of the response. You can retrieve the next set of response records by providing the returned <code>marker</code> value in the <code>marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <code>ClusterIdentifier</code> parameter, or the <code>marker</code> parameter, but not both.</p>
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString
  ##                    : A unique identifier for a cluster whose <code>ClusterDbRevisions</code> you are requesting. This parameter is case sensitive. All clusters defined for an account are returned by default.
  ##   Version: JString (required)
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified MaxRecords value, a value is returned in the <code>marker</code> field of the response. You can retrieve the next set of response records by providing the returned <code>marker</code> value in the <code>marker</code> parameter and retrying the request. </p> <p>Default: 100</p> <p>Constraints: minimum 20, maximum 100.</p>
  section = newJObject()
  var valid_607395 = query.getOrDefault("Marker")
  valid_607395 = validateParameter(valid_607395, JString, required = false,
                                 default = nil)
  if valid_607395 != nil:
    section.add "Marker", valid_607395
  var valid_607396 = query.getOrDefault("Action")
  valid_607396 = validateParameter(valid_607396, JString, required = true, default = newJString(
      "DescribeClusterDbRevisions"))
  if valid_607396 != nil:
    section.add "Action", valid_607396
  var valid_607397 = query.getOrDefault("ClusterIdentifier")
  valid_607397 = validateParameter(valid_607397, JString, required = false,
                                 default = nil)
  if valid_607397 != nil:
    section.add "ClusterIdentifier", valid_607397
  var valid_607398 = query.getOrDefault("Version")
  valid_607398 = validateParameter(valid_607398, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_607398 != nil:
    section.add "Version", valid_607398
  var valid_607399 = query.getOrDefault("MaxRecords")
  valid_607399 = validateParameter(valid_607399, JInt, required = false, default = nil)
  if valid_607399 != nil:
    section.add "MaxRecords", valid_607399
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_607400 = header.getOrDefault("X-Amz-Signature")
  valid_607400 = validateParameter(valid_607400, JString, required = false,
                                 default = nil)
  if valid_607400 != nil:
    section.add "X-Amz-Signature", valid_607400
  var valid_607401 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_607401 = validateParameter(valid_607401, JString, required = false,
                                 default = nil)
  if valid_607401 != nil:
    section.add "X-Amz-Content-Sha256", valid_607401
  var valid_607402 = header.getOrDefault("X-Amz-Date")
  valid_607402 = validateParameter(valid_607402, JString, required = false,
                                 default = nil)
  if valid_607402 != nil:
    section.add "X-Amz-Date", valid_607402
  var valid_607403 = header.getOrDefault("X-Amz-Credential")
  valid_607403 = validateParameter(valid_607403, JString, required = false,
                                 default = nil)
  if valid_607403 != nil:
    section.add "X-Amz-Credential", valid_607403
  var valid_607404 = header.getOrDefault("X-Amz-Security-Token")
  valid_607404 = validateParameter(valid_607404, JString, required = false,
                                 default = nil)
  if valid_607404 != nil:
    section.add "X-Amz-Security-Token", valid_607404
  var valid_607405 = header.getOrDefault("X-Amz-Algorithm")
  valid_607405 = validateParameter(valid_607405, JString, required = false,
                                 default = nil)
  if valid_607405 != nil:
    section.add "X-Amz-Algorithm", valid_607405
  var valid_607406 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_607406 = validateParameter(valid_607406, JString, required = false,
                                 default = nil)
  if valid_607406 != nil:
    section.add "X-Amz-SignedHeaders", valid_607406
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_607407: Call_GetDescribeClusterDbRevisions_607392; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns an array of <code>ClusterDbRevision</code> objects.
  ## 
  let valid = call_607407.validator(path, query, header, formData, body)
  let scheme = call_607407.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_607407.url(scheme.get, call_607407.host, call_607407.base,
                         call_607407.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_607407, url, valid)

proc call*(call_607408: Call_GetDescribeClusterDbRevisions_607392;
          Marker: string = ""; Action: string = "DescribeClusterDbRevisions";
          ClusterIdentifier: string = ""; Version: string = "2012-12-01";
          MaxRecords: int = 0): Recallable =
  ## getDescribeClusterDbRevisions
  ## Returns an array of <code>ClusterDbRevision</code> objects.
  ##   Marker: string
  ##         : <p>An optional parameter that specifies the starting point for returning a set of response records. When the results of a <code>DescribeClusterDbRevisions</code> request exceed the value specified in <code>MaxRecords</code>, Amazon Redshift returns a value in the <code>marker</code> field of the response. You can retrieve the next set of response records by providing the returned <code>marker</code> value in the <code>marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <code>ClusterIdentifier</code> parameter, or the <code>marker</code> parameter, but not both.</p>
  ##   Action: string (required)
  ##   ClusterIdentifier: string
  ##                    : A unique identifier for a cluster whose <code>ClusterDbRevisions</code> you are requesting. This parameter is case sensitive. All clusters defined for an account are returned by default.
  ##   Version: string (required)
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified MaxRecords value, a value is returned in the <code>marker</code> field of the response. You can retrieve the next set of response records by providing the returned <code>marker</code> value in the <code>marker</code> parameter and retrying the request. </p> <p>Default: 100</p> <p>Constraints: minimum 20, maximum 100.</p>
  var query_607409 = newJObject()
  add(query_607409, "Marker", newJString(Marker))
  add(query_607409, "Action", newJString(Action))
  add(query_607409, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_607409, "Version", newJString(Version))
  add(query_607409, "MaxRecords", newJInt(MaxRecords))
  result = call_607408.call(nil, query_607409, nil, nil, nil)

var getDescribeClusterDbRevisions* = Call_GetDescribeClusterDbRevisions_607392(
    name: "getDescribeClusterDbRevisions", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusterDbRevisions",
    validator: validate_GetDescribeClusterDbRevisions_607393, base: "/",
    url: url_GetDescribeClusterDbRevisions_607394,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeClusterParameterGroups_607449 = ref object of OpenApiRestCall_605573
proc url_PostDescribeClusterParameterGroups_607451(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeClusterParameterGroups_607450(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns a list of Amazon Redshift parameter groups, including parameter groups you created and the default parameter group. For each parameter group, the response includes the parameter group name, description, and parameter group family name. You can optionally specify a name to retrieve the description of a specific parameter group.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all parameter groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all parameter groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, parameter groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_607452 = query.getOrDefault("Action")
  valid_607452 = validateParameter(valid_607452, JString, required = true, default = newJString(
      "DescribeClusterParameterGroups"))
  if valid_607452 != nil:
    section.add "Action", valid_607452
  var valid_607453 = query.getOrDefault("Version")
  valid_607453 = validateParameter(valid_607453, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_607453 != nil:
    section.add "Version", valid_607453
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_607454 = header.getOrDefault("X-Amz-Signature")
  valid_607454 = validateParameter(valid_607454, JString, required = false,
                                 default = nil)
  if valid_607454 != nil:
    section.add "X-Amz-Signature", valid_607454
  var valid_607455 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_607455 = validateParameter(valid_607455, JString, required = false,
                                 default = nil)
  if valid_607455 != nil:
    section.add "X-Amz-Content-Sha256", valid_607455
  var valid_607456 = header.getOrDefault("X-Amz-Date")
  valid_607456 = validateParameter(valid_607456, JString, required = false,
                                 default = nil)
  if valid_607456 != nil:
    section.add "X-Amz-Date", valid_607456
  var valid_607457 = header.getOrDefault("X-Amz-Credential")
  valid_607457 = validateParameter(valid_607457, JString, required = false,
                                 default = nil)
  if valid_607457 != nil:
    section.add "X-Amz-Credential", valid_607457
  var valid_607458 = header.getOrDefault("X-Amz-Security-Token")
  valid_607458 = validateParameter(valid_607458, JString, required = false,
                                 default = nil)
  if valid_607458 != nil:
    section.add "X-Amz-Security-Token", valid_607458
  var valid_607459 = header.getOrDefault("X-Amz-Algorithm")
  valid_607459 = validateParameter(valid_607459, JString, required = false,
                                 default = nil)
  if valid_607459 != nil:
    section.add "X-Amz-Algorithm", valid_607459
  var valid_607460 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_607460 = validateParameter(valid_607460, JString, required = false,
                                 default = nil)
  if valid_607460 != nil:
    section.add "X-Amz-SignedHeaders", valid_607460
  result.add "header", section
  ## parameters in `formData` object:
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster parameter groups that are associated with the specified key or keys. For example, suppose that you have parameter groups that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the parameter groups that have either or both of these tag keys associated with them.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterParameterGroups</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster parameter groups that are associated with the specified tag value or values. For example, suppose that you have parameter groups that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the parameter groups that have either or both of these tag values associated with them.
  ##   ParameterGroupName: JString
  ##                     : The name of a specific parameter group for which to return details. By default, details about all parameter groups and the default parameter group are returned.
  section = newJObject()
  var valid_607461 = formData.getOrDefault("TagKeys")
  valid_607461 = validateParameter(valid_607461, JArray, required = false,
                                 default = nil)
  if valid_607461 != nil:
    section.add "TagKeys", valid_607461
  var valid_607462 = formData.getOrDefault("MaxRecords")
  valid_607462 = validateParameter(valid_607462, JInt, required = false, default = nil)
  if valid_607462 != nil:
    section.add "MaxRecords", valid_607462
  var valid_607463 = formData.getOrDefault("Marker")
  valid_607463 = validateParameter(valid_607463, JString, required = false,
                                 default = nil)
  if valid_607463 != nil:
    section.add "Marker", valid_607463
  var valid_607464 = formData.getOrDefault("TagValues")
  valid_607464 = validateParameter(valid_607464, JArray, required = false,
                                 default = nil)
  if valid_607464 != nil:
    section.add "TagValues", valid_607464
  var valid_607465 = formData.getOrDefault("ParameterGroupName")
  valid_607465 = validateParameter(valid_607465, JString, required = false,
                                 default = nil)
  if valid_607465 != nil:
    section.add "ParameterGroupName", valid_607465
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_607466: Call_PostDescribeClusterParameterGroups_607449;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Returns a list of Amazon Redshift parameter groups, including parameter groups you created and the default parameter group. For each parameter group, the response includes the parameter group name, description, and parameter group family name. You can optionally specify a name to retrieve the description of a specific parameter group.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all parameter groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all parameter groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, parameter groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_607466.validator(path, query, header, formData, body)
  let scheme = call_607466.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_607466.url(scheme.get, call_607466.host, call_607466.base,
                         call_607466.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_607466, url, valid)

proc call*(call_607467: Call_PostDescribeClusterParameterGroups_607449;
          TagKeys: JsonNode = nil; MaxRecords: int = 0; Marker: string = "";
          TagValues: JsonNode = nil;
          Action: string = "DescribeClusterParameterGroups";
          ParameterGroupName: string = ""; Version: string = "2012-12-01"): Recallable =
  ## postDescribeClusterParameterGroups
  ## <p>Returns a list of Amazon Redshift parameter groups, including parameter groups you created and the default parameter group. For each parameter group, the response includes the parameter group name, description, and parameter group family name. You can optionally specify a name to retrieve the description of a specific parameter group.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all parameter groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all parameter groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, parameter groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster parameter groups that are associated with the specified key or keys. For example, suppose that you have parameter groups that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the parameter groups that have either or both of these tag keys associated with them.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterParameterGroups</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster parameter groups that are associated with the specified tag value or values. For example, suppose that you have parameter groups that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the parameter groups that have either or both of these tag values associated with them.
  ##   Action: string (required)
  ##   ParameterGroupName: string
  ##                     : The name of a specific parameter group for which to return details. By default, details about all parameter groups and the default parameter group are returned.
  ##   Version: string (required)
  var query_607468 = newJObject()
  var formData_607469 = newJObject()
  if TagKeys != nil:
    formData_607469.add "TagKeys", TagKeys
  add(formData_607469, "MaxRecords", newJInt(MaxRecords))
  add(formData_607469, "Marker", newJString(Marker))
  if TagValues != nil:
    formData_607469.add "TagValues", TagValues
  add(query_607468, "Action", newJString(Action))
  add(formData_607469, "ParameterGroupName", newJString(ParameterGroupName))
  add(query_607468, "Version", newJString(Version))
  result = call_607467.call(nil, query_607468, nil, formData_607469, nil)

var postDescribeClusterParameterGroups* = Call_PostDescribeClusterParameterGroups_607449(
    name: "postDescribeClusterParameterGroups", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeClusterParameterGroups",
    validator: validate_PostDescribeClusterParameterGroups_607450, base: "/",
    url: url_PostDescribeClusterParameterGroups_607451,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeClusterParameterGroups_607429 = ref object of OpenApiRestCall_605573
proc url_GetDescribeClusterParameterGroups_607431(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeClusterParameterGroups_607430(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns a list of Amazon Redshift parameter groups, including parameter groups you created and the default parameter group. For each parameter group, the response includes the parameter group name, description, and parameter group family name. You can optionally specify a name to retrieve the description of a specific parameter group.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all parameter groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all parameter groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, parameter groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterParameterGroups</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster parameter groups that are associated with the specified key or keys. For example, suppose that you have parameter groups that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the parameter groups that have either or both of these tag keys associated with them.
  ##   Action: JString (required)
  ##   ParameterGroupName: JString
  ##                     : The name of a specific parameter group for which to return details. By default, details about all parameter groups and the default parameter group are returned.
  ##   Version: JString (required)
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster parameter groups that are associated with the specified tag value or values. For example, suppose that you have parameter groups that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the parameter groups that have either or both of these tag values associated with them.
  section = newJObject()
  var valid_607432 = query.getOrDefault("Marker")
  valid_607432 = validateParameter(valid_607432, JString, required = false,
                                 default = nil)
  if valid_607432 != nil:
    section.add "Marker", valid_607432
  var valid_607433 = query.getOrDefault("TagKeys")
  valid_607433 = validateParameter(valid_607433, JArray, required = false,
                                 default = nil)
  if valid_607433 != nil:
    section.add "TagKeys", valid_607433
  var valid_607434 = query.getOrDefault("Action")
  valid_607434 = validateParameter(valid_607434, JString, required = true, default = newJString(
      "DescribeClusterParameterGroups"))
  if valid_607434 != nil:
    section.add "Action", valid_607434
  var valid_607435 = query.getOrDefault("ParameterGroupName")
  valid_607435 = validateParameter(valid_607435, JString, required = false,
                                 default = nil)
  if valid_607435 != nil:
    section.add "ParameterGroupName", valid_607435
  var valid_607436 = query.getOrDefault("Version")
  valid_607436 = validateParameter(valid_607436, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_607436 != nil:
    section.add "Version", valid_607436
  var valid_607437 = query.getOrDefault("MaxRecords")
  valid_607437 = validateParameter(valid_607437, JInt, required = false, default = nil)
  if valid_607437 != nil:
    section.add "MaxRecords", valid_607437
  var valid_607438 = query.getOrDefault("TagValues")
  valid_607438 = validateParameter(valid_607438, JArray, required = false,
                                 default = nil)
  if valid_607438 != nil:
    section.add "TagValues", valid_607438
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_607439 = header.getOrDefault("X-Amz-Signature")
  valid_607439 = validateParameter(valid_607439, JString, required = false,
                                 default = nil)
  if valid_607439 != nil:
    section.add "X-Amz-Signature", valid_607439
  var valid_607440 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_607440 = validateParameter(valid_607440, JString, required = false,
                                 default = nil)
  if valid_607440 != nil:
    section.add "X-Amz-Content-Sha256", valid_607440
  var valid_607441 = header.getOrDefault("X-Amz-Date")
  valid_607441 = validateParameter(valid_607441, JString, required = false,
                                 default = nil)
  if valid_607441 != nil:
    section.add "X-Amz-Date", valid_607441
  var valid_607442 = header.getOrDefault("X-Amz-Credential")
  valid_607442 = validateParameter(valid_607442, JString, required = false,
                                 default = nil)
  if valid_607442 != nil:
    section.add "X-Amz-Credential", valid_607442
  var valid_607443 = header.getOrDefault("X-Amz-Security-Token")
  valid_607443 = validateParameter(valid_607443, JString, required = false,
                                 default = nil)
  if valid_607443 != nil:
    section.add "X-Amz-Security-Token", valid_607443
  var valid_607444 = header.getOrDefault("X-Amz-Algorithm")
  valid_607444 = validateParameter(valid_607444, JString, required = false,
                                 default = nil)
  if valid_607444 != nil:
    section.add "X-Amz-Algorithm", valid_607444
  var valid_607445 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_607445 = validateParameter(valid_607445, JString, required = false,
                                 default = nil)
  if valid_607445 != nil:
    section.add "X-Amz-SignedHeaders", valid_607445
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_607446: Call_GetDescribeClusterParameterGroups_607429;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Returns a list of Amazon Redshift parameter groups, including parameter groups you created and the default parameter group. For each parameter group, the response includes the parameter group name, description, and parameter group family name. You can optionally specify a name to retrieve the description of a specific parameter group.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all parameter groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all parameter groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, parameter groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_607446.validator(path, query, header, formData, body)
  let scheme = call_607446.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_607446.url(scheme.get, call_607446.host, call_607446.base,
                         call_607446.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_607446, url, valid)

proc call*(call_607447: Call_GetDescribeClusterParameterGroups_607429;
          Marker: string = ""; TagKeys: JsonNode = nil;
          Action: string = "DescribeClusterParameterGroups";
          ParameterGroupName: string = ""; Version: string = "2012-12-01";
          MaxRecords: int = 0; TagValues: JsonNode = nil): Recallable =
  ## getDescribeClusterParameterGroups
  ## <p>Returns a list of Amazon Redshift parameter groups, including parameter groups you created and the default parameter group. For each parameter group, the response includes the parameter group name, description, and parameter group family name. You can optionally specify a name to retrieve the description of a specific parameter group.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all parameter groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all parameter groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, parameter groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterParameterGroups</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster parameter groups that are associated with the specified key or keys. For example, suppose that you have parameter groups that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the parameter groups that have either or both of these tag keys associated with them.
  ##   Action: string (required)
  ##   ParameterGroupName: string
  ##                     : The name of a specific parameter group for which to return details. By default, details about all parameter groups and the default parameter group are returned.
  ##   Version: string (required)
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster parameter groups that are associated with the specified tag value or values. For example, suppose that you have parameter groups that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the parameter groups that have either or both of these tag values associated with them.
  var query_607448 = newJObject()
  add(query_607448, "Marker", newJString(Marker))
  if TagKeys != nil:
    query_607448.add "TagKeys", TagKeys
  add(query_607448, "Action", newJString(Action))
  add(query_607448, "ParameterGroupName", newJString(ParameterGroupName))
  add(query_607448, "Version", newJString(Version))
  add(query_607448, "MaxRecords", newJInt(MaxRecords))
  if TagValues != nil:
    query_607448.add "TagValues", TagValues
  result = call_607447.call(nil, query_607448, nil, nil, nil)

var getDescribeClusterParameterGroups* = Call_GetDescribeClusterParameterGroups_607429(
    name: "getDescribeClusterParameterGroups", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeClusterParameterGroups",
    validator: validate_GetDescribeClusterParameterGroups_607430, base: "/",
    url: url_GetDescribeClusterParameterGroups_607431,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeClusterParameters_607489 = ref object of OpenApiRestCall_605573
proc url_PostDescribeClusterParameters_607491(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeClusterParameters_607490(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns a detailed list of parameters contained within the specified Amazon Redshift parameter group. For each parameter the response includes information such as parameter name, description, data type, value, whether the parameter value is modifiable, and so on.</p> <p>You can specify <i>source</i> filter to retrieve parameters of only specific type. For example, to retrieve parameters that were modified by a user action such as from <a>ModifyClusterParameterGroup</a>, you can specify <i>source</i> equal to <i>user</i>.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_607492 = query.getOrDefault("Action")
  valid_607492 = validateParameter(valid_607492, JString, required = true, default = newJString(
      "DescribeClusterParameters"))
  if valid_607492 != nil:
    section.add "Action", valid_607492
  var valid_607493 = query.getOrDefault("Version")
  valid_607493 = validateParameter(valid_607493, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_607493 != nil:
    section.add "Version", valid_607493
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_607494 = header.getOrDefault("X-Amz-Signature")
  valid_607494 = validateParameter(valid_607494, JString, required = false,
                                 default = nil)
  if valid_607494 != nil:
    section.add "X-Amz-Signature", valid_607494
  var valid_607495 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_607495 = validateParameter(valid_607495, JString, required = false,
                                 default = nil)
  if valid_607495 != nil:
    section.add "X-Amz-Content-Sha256", valid_607495
  var valid_607496 = header.getOrDefault("X-Amz-Date")
  valid_607496 = validateParameter(valid_607496, JString, required = false,
                                 default = nil)
  if valid_607496 != nil:
    section.add "X-Amz-Date", valid_607496
  var valid_607497 = header.getOrDefault("X-Amz-Credential")
  valid_607497 = validateParameter(valid_607497, JString, required = false,
                                 default = nil)
  if valid_607497 != nil:
    section.add "X-Amz-Credential", valid_607497
  var valid_607498 = header.getOrDefault("X-Amz-Security-Token")
  valid_607498 = validateParameter(valid_607498, JString, required = false,
                                 default = nil)
  if valid_607498 != nil:
    section.add "X-Amz-Security-Token", valid_607498
  var valid_607499 = header.getOrDefault("X-Amz-Algorithm")
  valid_607499 = validateParameter(valid_607499, JString, required = false,
                                 default = nil)
  if valid_607499 != nil:
    section.add "X-Amz-Algorithm", valid_607499
  var valid_607500 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_607500 = validateParameter(valid_607500, JString, required = false,
                                 default = nil)
  if valid_607500 != nil:
    section.add "X-Amz-SignedHeaders", valid_607500
  result.add "header", section
  ## parameters in `formData` object:
  ##   Source: JString
  ##         : <p>The parameter types to return. Specify <code>user</code> to show parameters that are different form the default. Similarly, specify <code>engine-default</code> to show parameters that are the same as the default parameter group. </p> <p>Default: All parameter types returned.</p> <p>Valid Values: <code>user</code> | <code>engine-default</code> </p>
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterParameters</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   ParameterGroupName: JString (required)
  ##                     : The name of a cluster parameter group for which to return details.
  section = newJObject()
  var valid_607501 = formData.getOrDefault("Source")
  valid_607501 = validateParameter(valid_607501, JString, required = false,
                                 default = nil)
  if valid_607501 != nil:
    section.add "Source", valid_607501
  var valid_607502 = formData.getOrDefault("MaxRecords")
  valid_607502 = validateParameter(valid_607502, JInt, required = false, default = nil)
  if valid_607502 != nil:
    section.add "MaxRecords", valid_607502
  var valid_607503 = formData.getOrDefault("Marker")
  valid_607503 = validateParameter(valid_607503, JString, required = false,
                                 default = nil)
  if valid_607503 != nil:
    section.add "Marker", valid_607503
  assert formData != nil, "formData argument is necessary due to required `ParameterGroupName` field"
  var valid_607504 = formData.getOrDefault("ParameterGroupName")
  valid_607504 = validateParameter(valid_607504, JString, required = true,
                                 default = nil)
  if valid_607504 != nil:
    section.add "ParameterGroupName", valid_607504
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_607505: Call_PostDescribeClusterParameters_607489; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns a detailed list of parameters contained within the specified Amazon Redshift parameter group. For each parameter the response includes information such as parameter name, description, data type, value, whether the parameter value is modifiable, and so on.</p> <p>You can specify <i>source</i> filter to retrieve parameters of only specific type. For example, to retrieve parameters that were modified by a user action such as from <a>ModifyClusterParameterGroup</a>, you can specify <i>source</i> equal to <i>user</i>.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_607505.validator(path, query, header, formData, body)
  let scheme = call_607505.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_607505.url(scheme.get, call_607505.host, call_607505.base,
                         call_607505.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_607505, url, valid)

proc call*(call_607506: Call_PostDescribeClusterParameters_607489;
          ParameterGroupName: string; Source: string = ""; MaxRecords: int = 0;
          Marker: string = ""; Action: string = "DescribeClusterParameters";
          Version: string = "2012-12-01"): Recallable =
  ## postDescribeClusterParameters
  ## <p>Returns a detailed list of parameters contained within the specified Amazon Redshift parameter group. For each parameter the response includes information such as parameter name, description, data type, value, whether the parameter value is modifiable, and so on.</p> <p>You can specify <i>source</i> filter to retrieve parameters of only specific type. For example, to retrieve parameters that were modified by a user action such as from <a>ModifyClusterParameterGroup</a>, you can specify <i>source</i> equal to <i>user</i>.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   Source: string
  ##         : <p>The parameter types to return. Specify <code>user</code> to show parameters that are different form the default. Similarly, specify <code>engine-default</code> to show parameters that are the same as the default parameter group. </p> <p>Default: All parameter types returned.</p> <p>Valid Values: <code>user</code> | <code>engine-default</code> </p>
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterParameters</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Action: string (required)
  ##   ParameterGroupName: string (required)
  ##                     : The name of a cluster parameter group for which to return details.
  ##   Version: string (required)
  var query_607507 = newJObject()
  var formData_607508 = newJObject()
  add(formData_607508, "Source", newJString(Source))
  add(formData_607508, "MaxRecords", newJInt(MaxRecords))
  add(formData_607508, "Marker", newJString(Marker))
  add(query_607507, "Action", newJString(Action))
  add(formData_607508, "ParameterGroupName", newJString(ParameterGroupName))
  add(query_607507, "Version", newJString(Version))
  result = call_607506.call(nil, query_607507, nil, formData_607508, nil)

var postDescribeClusterParameters* = Call_PostDescribeClusterParameters_607489(
    name: "postDescribeClusterParameters", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusterParameters",
    validator: validate_PostDescribeClusterParameters_607490, base: "/",
    url: url_PostDescribeClusterParameters_607491,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeClusterParameters_607470 = ref object of OpenApiRestCall_605573
proc url_GetDescribeClusterParameters_607472(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeClusterParameters_607471(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns a detailed list of parameters contained within the specified Amazon Redshift parameter group. For each parameter the response includes information such as parameter name, description, data type, value, whether the parameter value is modifiable, and so on.</p> <p>You can specify <i>source</i> filter to retrieve parameters of only specific type. For example, to retrieve parameters that were modified by a user action such as from <a>ModifyClusterParameterGroup</a>, you can specify <i>source</i> equal to <i>user</i>.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterParameters</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Source: JString
  ##         : <p>The parameter types to return. Specify <code>user</code> to show parameters that are different form the default. Similarly, specify <code>engine-default</code> to show parameters that are the same as the default parameter group. </p> <p>Default: All parameter types returned.</p> <p>Valid Values: <code>user</code> | <code>engine-default</code> </p>
  ##   Action: JString (required)
  ##   ParameterGroupName: JString (required)
  ##                     : The name of a cluster parameter group for which to return details.
  ##   Version: JString (required)
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  section = newJObject()
  var valid_607473 = query.getOrDefault("Marker")
  valid_607473 = validateParameter(valid_607473, JString, required = false,
                                 default = nil)
  if valid_607473 != nil:
    section.add "Marker", valid_607473
  var valid_607474 = query.getOrDefault("Source")
  valid_607474 = validateParameter(valid_607474, JString, required = false,
                                 default = nil)
  if valid_607474 != nil:
    section.add "Source", valid_607474
  var valid_607475 = query.getOrDefault("Action")
  valid_607475 = validateParameter(valid_607475, JString, required = true, default = newJString(
      "DescribeClusterParameters"))
  if valid_607475 != nil:
    section.add "Action", valid_607475
  var valid_607476 = query.getOrDefault("ParameterGroupName")
  valid_607476 = validateParameter(valid_607476, JString, required = true,
                                 default = nil)
  if valid_607476 != nil:
    section.add "ParameterGroupName", valid_607476
  var valid_607477 = query.getOrDefault("Version")
  valid_607477 = validateParameter(valid_607477, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_607477 != nil:
    section.add "Version", valid_607477
  var valid_607478 = query.getOrDefault("MaxRecords")
  valid_607478 = validateParameter(valid_607478, JInt, required = false, default = nil)
  if valid_607478 != nil:
    section.add "MaxRecords", valid_607478
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_607479 = header.getOrDefault("X-Amz-Signature")
  valid_607479 = validateParameter(valid_607479, JString, required = false,
                                 default = nil)
  if valid_607479 != nil:
    section.add "X-Amz-Signature", valid_607479
  var valid_607480 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_607480 = validateParameter(valid_607480, JString, required = false,
                                 default = nil)
  if valid_607480 != nil:
    section.add "X-Amz-Content-Sha256", valid_607480
  var valid_607481 = header.getOrDefault("X-Amz-Date")
  valid_607481 = validateParameter(valid_607481, JString, required = false,
                                 default = nil)
  if valid_607481 != nil:
    section.add "X-Amz-Date", valid_607481
  var valid_607482 = header.getOrDefault("X-Amz-Credential")
  valid_607482 = validateParameter(valid_607482, JString, required = false,
                                 default = nil)
  if valid_607482 != nil:
    section.add "X-Amz-Credential", valid_607482
  var valid_607483 = header.getOrDefault("X-Amz-Security-Token")
  valid_607483 = validateParameter(valid_607483, JString, required = false,
                                 default = nil)
  if valid_607483 != nil:
    section.add "X-Amz-Security-Token", valid_607483
  var valid_607484 = header.getOrDefault("X-Amz-Algorithm")
  valid_607484 = validateParameter(valid_607484, JString, required = false,
                                 default = nil)
  if valid_607484 != nil:
    section.add "X-Amz-Algorithm", valid_607484
  var valid_607485 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_607485 = validateParameter(valid_607485, JString, required = false,
                                 default = nil)
  if valid_607485 != nil:
    section.add "X-Amz-SignedHeaders", valid_607485
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_607486: Call_GetDescribeClusterParameters_607470; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns a detailed list of parameters contained within the specified Amazon Redshift parameter group. For each parameter the response includes information such as parameter name, description, data type, value, whether the parameter value is modifiable, and so on.</p> <p>You can specify <i>source</i> filter to retrieve parameters of only specific type. For example, to retrieve parameters that were modified by a user action such as from <a>ModifyClusterParameterGroup</a>, you can specify <i>source</i> equal to <i>user</i>.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_607486.validator(path, query, header, formData, body)
  let scheme = call_607486.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_607486.url(scheme.get, call_607486.host, call_607486.base,
                         call_607486.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_607486, url, valid)

proc call*(call_607487: Call_GetDescribeClusterParameters_607470;
          ParameterGroupName: string; Marker: string = ""; Source: string = "";
          Action: string = "DescribeClusterParameters";
          Version: string = "2012-12-01"; MaxRecords: int = 0): Recallable =
  ## getDescribeClusterParameters
  ## <p>Returns a detailed list of parameters contained within the specified Amazon Redshift parameter group. For each parameter the response includes information such as parameter name, description, data type, value, whether the parameter value is modifiable, and so on.</p> <p>You can specify <i>source</i> filter to retrieve parameters of only specific type. For example, to retrieve parameters that were modified by a user action such as from <a>ModifyClusterParameterGroup</a>, you can specify <i>source</i> equal to <i>user</i>.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterParameters</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Source: string
  ##         : <p>The parameter types to return. Specify <code>user</code> to show parameters that are different form the default. Similarly, specify <code>engine-default</code> to show parameters that are the same as the default parameter group. </p> <p>Default: All parameter types returned.</p> <p>Valid Values: <code>user</code> | <code>engine-default</code> </p>
  ##   Action: string (required)
  ##   ParameterGroupName: string (required)
  ##                     : The name of a cluster parameter group for which to return details.
  ##   Version: string (required)
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  var query_607488 = newJObject()
  add(query_607488, "Marker", newJString(Marker))
  add(query_607488, "Source", newJString(Source))
  add(query_607488, "Action", newJString(Action))
  add(query_607488, "ParameterGroupName", newJString(ParameterGroupName))
  add(query_607488, "Version", newJString(Version))
  add(query_607488, "MaxRecords", newJInt(MaxRecords))
  result = call_607487.call(nil, query_607488, nil, nil, nil)

var getDescribeClusterParameters* = Call_GetDescribeClusterParameters_607470(
    name: "getDescribeClusterParameters", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusterParameters",
    validator: validate_GetDescribeClusterParameters_607471, base: "/",
    url: url_GetDescribeClusterParameters_607472,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeClusterSecurityGroups_607529 = ref object of OpenApiRestCall_605573
proc url_PostDescribeClusterSecurityGroups_607531(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeClusterSecurityGroups_607530(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns information about Amazon Redshift security groups. If the name of a security group is specified, the response will contain only information about only that security group.</p> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all security groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all security groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, security groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_607532 = query.getOrDefault("Action")
  valid_607532 = validateParameter(valid_607532, JString, required = true, default = newJString(
      "DescribeClusterSecurityGroups"))
  if valid_607532 != nil:
    section.add "Action", valid_607532
  var valid_607533 = query.getOrDefault("Version")
  valid_607533 = validateParameter(valid_607533, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_607533 != nil:
    section.add "Version", valid_607533
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_607534 = header.getOrDefault("X-Amz-Signature")
  valid_607534 = validateParameter(valid_607534, JString, required = false,
                                 default = nil)
  if valid_607534 != nil:
    section.add "X-Amz-Signature", valid_607534
  var valid_607535 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_607535 = validateParameter(valid_607535, JString, required = false,
                                 default = nil)
  if valid_607535 != nil:
    section.add "X-Amz-Content-Sha256", valid_607535
  var valid_607536 = header.getOrDefault("X-Amz-Date")
  valid_607536 = validateParameter(valid_607536, JString, required = false,
                                 default = nil)
  if valid_607536 != nil:
    section.add "X-Amz-Date", valid_607536
  var valid_607537 = header.getOrDefault("X-Amz-Credential")
  valid_607537 = validateParameter(valid_607537, JString, required = false,
                                 default = nil)
  if valid_607537 != nil:
    section.add "X-Amz-Credential", valid_607537
  var valid_607538 = header.getOrDefault("X-Amz-Security-Token")
  valid_607538 = validateParameter(valid_607538, JString, required = false,
                                 default = nil)
  if valid_607538 != nil:
    section.add "X-Amz-Security-Token", valid_607538
  var valid_607539 = header.getOrDefault("X-Amz-Algorithm")
  valid_607539 = validateParameter(valid_607539, JString, required = false,
                                 default = nil)
  if valid_607539 != nil:
    section.add "X-Amz-Algorithm", valid_607539
  var valid_607540 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_607540 = validateParameter(valid_607540, JString, required = false,
                                 default = nil)
  if valid_607540 != nil:
    section.add "X-Amz-SignedHeaders", valid_607540
  result.add "header", section
  ## parameters in `formData` object:
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster security groups that are associated with the specified key or keys. For example, suppose that you have security groups that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the security groups that have either or both of these tag keys associated with them.
  ##   ClusterSecurityGroupName: JString
  ##                           : <p>The name of a cluster security group for which you are requesting details. You can specify either the <b>Marker</b> parameter or a <b>ClusterSecurityGroupName</b> parameter, but not both. </p> <p> Example: <code>securitygroup1</code> </p>
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: JString
  ##         : <p>An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterSecurityGroups</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <b>ClusterSecurityGroupName</b> parameter or the <b>Marker</b> parameter, but not both. </p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster security groups that are associated with the specified tag value or values. For example, suppose that you have security groups that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the security groups that have either or both of these tag values associated with them.
  section = newJObject()
  var valid_607541 = formData.getOrDefault("TagKeys")
  valid_607541 = validateParameter(valid_607541, JArray, required = false,
                                 default = nil)
  if valid_607541 != nil:
    section.add "TagKeys", valid_607541
  var valid_607542 = formData.getOrDefault("ClusterSecurityGroupName")
  valid_607542 = validateParameter(valid_607542, JString, required = false,
                                 default = nil)
  if valid_607542 != nil:
    section.add "ClusterSecurityGroupName", valid_607542
  var valid_607543 = formData.getOrDefault("MaxRecords")
  valid_607543 = validateParameter(valid_607543, JInt, required = false, default = nil)
  if valid_607543 != nil:
    section.add "MaxRecords", valid_607543
  var valid_607544 = formData.getOrDefault("Marker")
  valid_607544 = validateParameter(valid_607544, JString, required = false,
                                 default = nil)
  if valid_607544 != nil:
    section.add "Marker", valid_607544
  var valid_607545 = formData.getOrDefault("TagValues")
  valid_607545 = validateParameter(valid_607545, JArray, required = false,
                                 default = nil)
  if valid_607545 != nil:
    section.add "TagValues", valid_607545
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_607546: Call_PostDescribeClusterSecurityGroups_607529;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Returns information about Amazon Redshift security groups. If the name of a security group is specified, the response will contain only information about only that security group.</p> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all security groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all security groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, security groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_607546.validator(path, query, header, formData, body)
  let scheme = call_607546.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_607546.url(scheme.get, call_607546.host, call_607546.base,
                         call_607546.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_607546, url, valid)

proc call*(call_607547: Call_PostDescribeClusterSecurityGroups_607529;
          TagKeys: JsonNode = nil; ClusterSecurityGroupName: string = "";
          MaxRecords: int = 0; Marker: string = ""; TagValues: JsonNode = nil;
          Action: string = "DescribeClusterSecurityGroups";
          Version: string = "2012-12-01"): Recallable =
  ## postDescribeClusterSecurityGroups
  ## <p>Returns information about Amazon Redshift security groups. If the name of a security group is specified, the response will contain only information about only that security group.</p> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all security groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all security groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, security groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster security groups that are associated with the specified key or keys. For example, suppose that you have security groups that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the security groups that have either or both of these tag keys associated with them.
  ##   ClusterSecurityGroupName: string
  ##                           : <p>The name of a cluster security group for which you are requesting details. You can specify either the <b>Marker</b> parameter or a <b>ClusterSecurityGroupName</b> parameter, but not both. </p> <p> Example: <code>securitygroup1</code> </p>
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: string
  ##         : <p>An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterSecurityGroups</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <b>ClusterSecurityGroupName</b> parameter or the <b>Marker</b> parameter, but not both. </p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster security groups that are associated with the specified tag value or values. For example, suppose that you have security groups that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the security groups that have either or both of these tag values associated with them.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_607548 = newJObject()
  var formData_607549 = newJObject()
  if TagKeys != nil:
    formData_607549.add "TagKeys", TagKeys
  add(formData_607549, "ClusterSecurityGroupName",
      newJString(ClusterSecurityGroupName))
  add(formData_607549, "MaxRecords", newJInt(MaxRecords))
  add(formData_607549, "Marker", newJString(Marker))
  if TagValues != nil:
    formData_607549.add "TagValues", TagValues
  add(query_607548, "Action", newJString(Action))
  add(query_607548, "Version", newJString(Version))
  result = call_607547.call(nil, query_607548, nil, formData_607549, nil)

var postDescribeClusterSecurityGroups* = Call_PostDescribeClusterSecurityGroups_607529(
    name: "postDescribeClusterSecurityGroups", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeClusterSecurityGroups",
    validator: validate_PostDescribeClusterSecurityGroups_607530, base: "/",
    url: url_PostDescribeClusterSecurityGroups_607531,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeClusterSecurityGroups_607509 = ref object of OpenApiRestCall_605573
proc url_GetDescribeClusterSecurityGroups_607511(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeClusterSecurityGroups_607510(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns information about Amazon Redshift security groups. If the name of a security group is specified, the response will contain only information about only that security group.</p> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all security groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all security groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, security groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Marker: JString
  ##         : <p>An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterSecurityGroups</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <b>ClusterSecurityGroupName</b> parameter or the <b>Marker</b> parameter, but not both. </p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster security groups that are associated with the specified key or keys. For example, suppose that you have security groups that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the security groups that have either or both of these tag keys associated with them.
  ##   ClusterSecurityGroupName: JString
  ##                           : <p>The name of a cluster security group for which you are requesting details. You can specify either the <b>Marker</b> parameter or a <b>ClusterSecurityGroupName</b> parameter, but not both. </p> <p> Example: <code>securitygroup1</code> </p>
  ##   Action: JString (required)
  ##   Version: JString (required)
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster security groups that are associated with the specified tag value or values. For example, suppose that you have security groups that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the security groups that have either or both of these tag values associated with them.
  section = newJObject()
  var valid_607512 = query.getOrDefault("Marker")
  valid_607512 = validateParameter(valid_607512, JString, required = false,
                                 default = nil)
  if valid_607512 != nil:
    section.add "Marker", valid_607512
  var valid_607513 = query.getOrDefault("TagKeys")
  valid_607513 = validateParameter(valid_607513, JArray, required = false,
                                 default = nil)
  if valid_607513 != nil:
    section.add "TagKeys", valid_607513
  var valid_607514 = query.getOrDefault("ClusterSecurityGroupName")
  valid_607514 = validateParameter(valid_607514, JString, required = false,
                                 default = nil)
  if valid_607514 != nil:
    section.add "ClusterSecurityGroupName", valid_607514
  var valid_607515 = query.getOrDefault("Action")
  valid_607515 = validateParameter(valid_607515, JString, required = true, default = newJString(
      "DescribeClusterSecurityGroups"))
  if valid_607515 != nil:
    section.add "Action", valid_607515
  var valid_607516 = query.getOrDefault("Version")
  valid_607516 = validateParameter(valid_607516, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_607516 != nil:
    section.add "Version", valid_607516
  var valid_607517 = query.getOrDefault("MaxRecords")
  valid_607517 = validateParameter(valid_607517, JInt, required = false, default = nil)
  if valid_607517 != nil:
    section.add "MaxRecords", valid_607517
  var valid_607518 = query.getOrDefault("TagValues")
  valid_607518 = validateParameter(valid_607518, JArray, required = false,
                                 default = nil)
  if valid_607518 != nil:
    section.add "TagValues", valid_607518
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_607519 = header.getOrDefault("X-Amz-Signature")
  valid_607519 = validateParameter(valid_607519, JString, required = false,
                                 default = nil)
  if valid_607519 != nil:
    section.add "X-Amz-Signature", valid_607519
  var valid_607520 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_607520 = validateParameter(valid_607520, JString, required = false,
                                 default = nil)
  if valid_607520 != nil:
    section.add "X-Amz-Content-Sha256", valid_607520
  var valid_607521 = header.getOrDefault("X-Amz-Date")
  valid_607521 = validateParameter(valid_607521, JString, required = false,
                                 default = nil)
  if valid_607521 != nil:
    section.add "X-Amz-Date", valid_607521
  var valid_607522 = header.getOrDefault("X-Amz-Credential")
  valid_607522 = validateParameter(valid_607522, JString, required = false,
                                 default = nil)
  if valid_607522 != nil:
    section.add "X-Amz-Credential", valid_607522
  var valid_607523 = header.getOrDefault("X-Amz-Security-Token")
  valid_607523 = validateParameter(valid_607523, JString, required = false,
                                 default = nil)
  if valid_607523 != nil:
    section.add "X-Amz-Security-Token", valid_607523
  var valid_607524 = header.getOrDefault("X-Amz-Algorithm")
  valid_607524 = validateParameter(valid_607524, JString, required = false,
                                 default = nil)
  if valid_607524 != nil:
    section.add "X-Amz-Algorithm", valid_607524
  var valid_607525 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_607525 = validateParameter(valid_607525, JString, required = false,
                                 default = nil)
  if valid_607525 != nil:
    section.add "X-Amz-SignedHeaders", valid_607525
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_607526: Call_GetDescribeClusterSecurityGroups_607509;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Returns information about Amazon Redshift security groups. If the name of a security group is specified, the response will contain only information about only that security group.</p> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all security groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all security groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, security groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_607526.validator(path, query, header, formData, body)
  let scheme = call_607526.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_607526.url(scheme.get, call_607526.host, call_607526.base,
                         call_607526.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_607526, url, valid)

proc call*(call_607527: Call_GetDescribeClusterSecurityGroups_607509;
          Marker: string = ""; TagKeys: JsonNode = nil;
          ClusterSecurityGroupName: string = "";
          Action: string = "DescribeClusterSecurityGroups";
          Version: string = "2012-12-01"; MaxRecords: int = 0; TagValues: JsonNode = nil): Recallable =
  ## getDescribeClusterSecurityGroups
  ## <p>Returns information about Amazon Redshift security groups. If the name of a security group is specified, the response will contain only information about only that security group.</p> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all security groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all security groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, security groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   Marker: string
  ##         : <p>An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterSecurityGroups</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <b>ClusterSecurityGroupName</b> parameter or the <b>Marker</b> parameter, but not both. </p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster security groups that are associated with the specified key or keys. For example, suppose that you have security groups that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the security groups that have either or both of these tag keys associated with them.
  ##   ClusterSecurityGroupName: string
  ##                           : <p>The name of a cluster security group for which you are requesting details. You can specify either the <b>Marker</b> parameter or a <b>ClusterSecurityGroupName</b> parameter, but not both. </p> <p> Example: <code>securitygroup1</code> </p>
  ##   Action: string (required)
  ##   Version: string (required)
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster security groups that are associated with the specified tag value or values. For example, suppose that you have security groups that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the security groups that have either or both of these tag values associated with them.
  var query_607528 = newJObject()
  add(query_607528, "Marker", newJString(Marker))
  if TagKeys != nil:
    query_607528.add "TagKeys", TagKeys
  add(query_607528, "ClusterSecurityGroupName",
      newJString(ClusterSecurityGroupName))
  add(query_607528, "Action", newJString(Action))
  add(query_607528, "Version", newJString(Version))
  add(query_607528, "MaxRecords", newJInt(MaxRecords))
  if TagValues != nil:
    query_607528.add "TagValues", TagValues
  result = call_607527.call(nil, query_607528, nil, nil, nil)

var getDescribeClusterSecurityGroups* = Call_GetDescribeClusterSecurityGroups_607509(
    name: "getDescribeClusterSecurityGroups", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeClusterSecurityGroups",
    validator: validate_GetDescribeClusterSecurityGroups_607510, base: "/",
    url: url_GetDescribeClusterSecurityGroups_607511,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeClusterSnapshots_607577 = ref object of OpenApiRestCall_605573
proc url_PostDescribeClusterSnapshots_607579(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeClusterSnapshots_607578(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns one or more snapshot objects, which contain metadata about your cluster snapshots. By default, this operation returns information about all snapshots of all clusters that are owned by you AWS customer account. No information is returned for snapshots owned by inactive AWS customer accounts.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all snapshots that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all snapshots that have any combination of those values are returned. Only snapshots that you own are returned in the response; shared snapshots are not returned with the tag key and tag value request parameters.</p> <p>If both tag keys and values are omitted from the request, snapshots are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_607580 = query.getOrDefault("Action")
  valid_607580 = validateParameter(valid_607580, JString, required = true, default = newJString(
      "DescribeClusterSnapshots"))
  if valid_607580 != nil:
    section.add "Action", valid_607580
  var valid_607581 = query.getOrDefault("Version")
  valid_607581 = validateParameter(valid_607581, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_607581 != nil:
    section.add "Version", valid_607581
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_607582 = header.getOrDefault("X-Amz-Signature")
  valid_607582 = validateParameter(valid_607582, JString, required = false,
                                 default = nil)
  if valid_607582 != nil:
    section.add "X-Amz-Signature", valid_607582
  var valid_607583 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_607583 = validateParameter(valid_607583, JString, required = false,
                                 default = nil)
  if valid_607583 != nil:
    section.add "X-Amz-Content-Sha256", valid_607583
  var valid_607584 = header.getOrDefault("X-Amz-Date")
  valid_607584 = validateParameter(valid_607584, JString, required = false,
                                 default = nil)
  if valid_607584 != nil:
    section.add "X-Amz-Date", valid_607584
  var valid_607585 = header.getOrDefault("X-Amz-Credential")
  valid_607585 = validateParameter(valid_607585, JString, required = false,
                                 default = nil)
  if valid_607585 != nil:
    section.add "X-Amz-Credential", valid_607585
  var valid_607586 = header.getOrDefault("X-Amz-Security-Token")
  valid_607586 = validateParameter(valid_607586, JString, required = false,
                                 default = nil)
  if valid_607586 != nil:
    section.add "X-Amz-Security-Token", valid_607586
  var valid_607587 = header.getOrDefault("X-Amz-Algorithm")
  valid_607587 = validateParameter(valid_607587, JString, required = false,
                                 default = nil)
  if valid_607587 != nil:
    section.add "X-Amz-Algorithm", valid_607587
  var valid_607588 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_607588 = validateParameter(valid_607588, JString, required = false,
                                 default = nil)
  if valid_607588 != nil:
    section.add "X-Amz-SignedHeaders", valid_607588
  result.add "header", section
  ## parameters in `formData` object:
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster snapshots that are associated with the specified key or keys. For example, suppose that you have snapshots that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the snapshots that have either or both of these tag keys associated with them.
  ##   ClusterIdentifier: JString
  ##                    : The identifier of the cluster which generated the requested snapshots.
  ##   SnapshotType: JString
  ##               : <p>The type of snapshots for which you are requesting information. By default, snapshots of all types are returned.</p> <p>Valid Values: <code>automated</code> | <code>manual</code> </p>
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   OwnerAccount: JString
  ##               : The AWS customer account used to create or copy the snapshot. Use this field to filter the results to snapshots owned by a particular account. To describe snapshots you own, either specify your AWS customer account, or do not specify the parameter.
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterSnapshots</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   ClusterExists: JBool
  ##                : <p>A value that indicates whether to return snapshots only for an existing cluster. You can perform table-level restore only by using a snapshot of an existing cluster, that is, a cluster that has not been deleted. Values for this parameter work as follows: </p> <ul> <li> <p>If <code>ClusterExists</code> is set to <code>true</code>, <code>ClusterIdentifier</code> is required.</p> </li> <li> <p>If <code>ClusterExists</code> is set to <code>false</code> and <code>ClusterIdentifier</code> isn't specified, all snapshots associated with deleted clusters (orphaned snapshots) are returned. </p> </li> <li> <p>If <code>ClusterExists</code> is set to <code>false</code> and <code>ClusterIdentifier</code> is specified for a deleted cluster, snapshots associated with that cluster are returned.</p> </li> <li> <p>If <code>ClusterExists</code> is set to <code>false</code> and <code>ClusterIdentifier</code> is specified for an existing cluster, no snapshots are returned. </p> </li> </ul>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster snapshots that are associated with the specified tag value or values. For example, suppose that you have snapshots that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the snapshots that have either or both of these tag values associated with them.
  ##   EndTime: JString
  ##          : <p>A time value that requests only snapshots created at or before the specified time. The time value is specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2012-07-16T18:00:00Z</code> </p>
  ##   StartTime: JString
  ##            : <p>A value that requests only snapshots created at or after the specified time. The time value is specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2012-07-16T18:00:00Z</code> </p>
  ##   SnapshotIdentifier: JString
  ##                     : The snapshot identifier of the snapshot about which to return information.
  ##   SortingEntities: JArray
  ##                  : <p/>
  section = newJObject()
  var valid_607589 = formData.getOrDefault("TagKeys")
  valid_607589 = validateParameter(valid_607589, JArray, required = false,
                                 default = nil)
  if valid_607589 != nil:
    section.add "TagKeys", valid_607589
  var valid_607590 = formData.getOrDefault("ClusterIdentifier")
  valid_607590 = validateParameter(valid_607590, JString, required = false,
                                 default = nil)
  if valid_607590 != nil:
    section.add "ClusterIdentifier", valid_607590
  var valid_607591 = formData.getOrDefault("SnapshotType")
  valid_607591 = validateParameter(valid_607591, JString, required = false,
                                 default = nil)
  if valid_607591 != nil:
    section.add "SnapshotType", valid_607591
  var valid_607592 = formData.getOrDefault("MaxRecords")
  valid_607592 = validateParameter(valid_607592, JInt, required = false, default = nil)
  if valid_607592 != nil:
    section.add "MaxRecords", valid_607592
  var valid_607593 = formData.getOrDefault("OwnerAccount")
  valid_607593 = validateParameter(valid_607593, JString, required = false,
                                 default = nil)
  if valid_607593 != nil:
    section.add "OwnerAccount", valid_607593
  var valid_607594 = formData.getOrDefault("Marker")
  valid_607594 = validateParameter(valid_607594, JString, required = false,
                                 default = nil)
  if valid_607594 != nil:
    section.add "Marker", valid_607594
  var valid_607595 = formData.getOrDefault("ClusterExists")
  valid_607595 = validateParameter(valid_607595, JBool, required = false, default = nil)
  if valid_607595 != nil:
    section.add "ClusterExists", valid_607595
  var valid_607596 = formData.getOrDefault("TagValues")
  valid_607596 = validateParameter(valid_607596, JArray, required = false,
                                 default = nil)
  if valid_607596 != nil:
    section.add "TagValues", valid_607596
  var valid_607597 = formData.getOrDefault("EndTime")
  valid_607597 = validateParameter(valid_607597, JString, required = false,
                                 default = nil)
  if valid_607597 != nil:
    section.add "EndTime", valid_607597
  var valid_607598 = formData.getOrDefault("StartTime")
  valid_607598 = validateParameter(valid_607598, JString, required = false,
                                 default = nil)
  if valid_607598 != nil:
    section.add "StartTime", valid_607598
  var valid_607599 = formData.getOrDefault("SnapshotIdentifier")
  valid_607599 = validateParameter(valid_607599, JString, required = false,
                                 default = nil)
  if valid_607599 != nil:
    section.add "SnapshotIdentifier", valid_607599
  var valid_607600 = formData.getOrDefault("SortingEntities")
  valid_607600 = validateParameter(valid_607600, JArray, required = false,
                                 default = nil)
  if valid_607600 != nil:
    section.add "SortingEntities", valid_607600
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_607601: Call_PostDescribeClusterSnapshots_607577; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns one or more snapshot objects, which contain metadata about your cluster snapshots. By default, this operation returns information about all snapshots of all clusters that are owned by you AWS customer account. No information is returned for snapshots owned by inactive AWS customer accounts.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all snapshots that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all snapshots that have any combination of those values are returned. Only snapshots that you own are returned in the response; shared snapshots are not returned with the tag key and tag value request parameters.</p> <p>If both tag keys and values are omitted from the request, snapshots are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_607601.validator(path, query, header, formData, body)
  let scheme = call_607601.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_607601.url(scheme.get, call_607601.host, call_607601.base,
                         call_607601.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_607601, url, valid)

proc call*(call_607602: Call_PostDescribeClusterSnapshots_607577;
          TagKeys: JsonNode = nil; ClusterIdentifier: string = "";
          SnapshotType: string = ""; MaxRecords: int = 0; OwnerAccount: string = "";
          Marker: string = ""; ClusterExists: bool = false; TagValues: JsonNode = nil;
          EndTime: string = ""; StartTime: string = ""; SnapshotIdentifier: string = "";
          Action: string = "DescribeClusterSnapshots";
          SortingEntities: JsonNode = nil; Version: string = "2012-12-01"): Recallable =
  ## postDescribeClusterSnapshots
  ## <p>Returns one or more snapshot objects, which contain metadata about your cluster snapshots. By default, this operation returns information about all snapshots of all clusters that are owned by you AWS customer account. No information is returned for snapshots owned by inactive AWS customer accounts.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all snapshots that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all snapshots that have any combination of those values are returned. Only snapshots that you own are returned in the response; shared snapshots are not returned with the tag key and tag value request parameters.</p> <p>If both tag keys and values are omitted from the request, snapshots are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster snapshots that are associated with the specified key or keys. For example, suppose that you have snapshots that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the snapshots that have either or both of these tag keys associated with them.
  ##   ClusterIdentifier: string
  ##                    : The identifier of the cluster which generated the requested snapshots.
  ##   SnapshotType: string
  ##               : <p>The type of snapshots for which you are requesting information. By default, snapshots of all types are returned.</p> <p>Valid Values: <code>automated</code> | <code>manual</code> </p>
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   OwnerAccount: string
  ##               : The AWS customer account used to create or copy the snapshot. Use this field to filter the results to snapshots owned by a particular account. To describe snapshots you own, either specify your AWS customer account, or do not specify the parameter.
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterSnapshots</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   ClusterExists: bool
  ##                : <p>A value that indicates whether to return snapshots only for an existing cluster. You can perform table-level restore only by using a snapshot of an existing cluster, that is, a cluster that has not been deleted. Values for this parameter work as follows: </p> <ul> <li> <p>If <code>ClusterExists</code> is set to <code>true</code>, <code>ClusterIdentifier</code> is required.</p> </li> <li> <p>If <code>ClusterExists</code> is set to <code>false</code> and <code>ClusterIdentifier</code> isn't specified, all snapshots associated with deleted clusters (orphaned snapshots) are returned. </p> </li> <li> <p>If <code>ClusterExists</code> is set to <code>false</code> and <code>ClusterIdentifier</code> is specified for a deleted cluster, snapshots associated with that cluster are returned.</p> </li> <li> <p>If <code>ClusterExists</code> is set to <code>false</code> and <code>ClusterIdentifier</code> is specified for an existing cluster, no snapshots are returned. </p> </li> </ul>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster snapshots that are associated with the specified tag value or values. For example, suppose that you have snapshots that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the snapshots that have either or both of these tag values associated with them.
  ##   EndTime: string
  ##          : <p>A time value that requests only snapshots created at or before the specified time. The time value is specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2012-07-16T18:00:00Z</code> </p>
  ##   StartTime: string
  ##            : <p>A value that requests only snapshots created at or after the specified time. The time value is specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2012-07-16T18:00:00Z</code> </p>
  ##   SnapshotIdentifier: string
  ##                     : The snapshot identifier of the snapshot about which to return information.
  ##   Action: string (required)
  ##   SortingEntities: JArray
  ##                  : <p/>
  ##   Version: string (required)
  var query_607603 = newJObject()
  var formData_607604 = newJObject()
  if TagKeys != nil:
    formData_607604.add "TagKeys", TagKeys
  add(formData_607604, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_607604, "SnapshotType", newJString(SnapshotType))
  add(formData_607604, "MaxRecords", newJInt(MaxRecords))
  add(formData_607604, "OwnerAccount", newJString(OwnerAccount))
  add(formData_607604, "Marker", newJString(Marker))
  add(formData_607604, "ClusterExists", newJBool(ClusterExists))
  if TagValues != nil:
    formData_607604.add "TagValues", TagValues
  add(formData_607604, "EndTime", newJString(EndTime))
  add(formData_607604, "StartTime", newJString(StartTime))
  add(formData_607604, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_607603, "Action", newJString(Action))
  if SortingEntities != nil:
    formData_607604.add "SortingEntities", SortingEntities
  add(query_607603, "Version", newJString(Version))
  result = call_607602.call(nil, query_607603, nil, formData_607604, nil)

var postDescribeClusterSnapshots* = Call_PostDescribeClusterSnapshots_607577(
    name: "postDescribeClusterSnapshots", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusterSnapshots",
    validator: validate_PostDescribeClusterSnapshots_607578, base: "/",
    url: url_PostDescribeClusterSnapshots_607579,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeClusterSnapshots_607550 = ref object of OpenApiRestCall_605573
proc url_GetDescribeClusterSnapshots_607552(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeClusterSnapshots_607551(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns one or more snapshot objects, which contain metadata about your cluster snapshots. By default, this operation returns information about all snapshots of all clusters that are owned by you AWS customer account. No information is returned for snapshots owned by inactive AWS customer accounts.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all snapshots that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all snapshots that have any combination of those values are returned. Only snapshots that you own are returned in the response; shared snapshots are not returned with the tag key and tag value request parameters.</p> <p>If both tag keys and values are omitted from the request, snapshots are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterSnapshots</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   SortingEntities: JArray
  ##                  : <p/>
  ##   SnapshotIdentifier: JString
  ##                     : The snapshot identifier of the snapshot about which to return information.
  ##   ClusterExists: JBool
  ##                : <p>A value that indicates whether to return snapshots only for an existing cluster. You can perform table-level restore only by using a snapshot of an existing cluster, that is, a cluster that has not been deleted. Values for this parameter work as follows: </p> <ul> <li> <p>If <code>ClusterExists</code> is set to <code>true</code>, <code>ClusterIdentifier</code> is required.</p> </li> <li> <p>If <code>ClusterExists</code> is set to <code>false</code> and <code>ClusterIdentifier</code> isn't specified, all snapshots associated with deleted clusters (orphaned snapshots) are returned. </p> </li> <li> <p>If <code>ClusterExists</code> is set to <code>false</code> and <code>ClusterIdentifier</code> is specified for a deleted cluster, snapshots associated with that cluster are returned.</p> </li> <li> <p>If <code>ClusterExists</code> is set to <code>false</code> and <code>ClusterIdentifier</code> is specified for an existing cluster, no snapshots are returned. </p> </li> </ul>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster snapshots that are associated with the specified key or keys. For example, suppose that you have snapshots that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the snapshots that have either or both of these tag keys associated with them.
  ##   SnapshotType: JString
  ##               : <p>The type of snapshots for which you are requesting information. By default, snapshots of all types are returned.</p> <p>Valid Values: <code>automated</code> | <code>manual</code> </p>
  ##   Action: JString (required)
  ##   StartTime: JString
  ##            : <p>A value that requests only snapshots created at or after the specified time. The time value is specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2012-07-16T18:00:00Z</code> </p>
  ##   ClusterIdentifier: JString
  ##                    : The identifier of the cluster which generated the requested snapshots.
  ##   EndTime: JString
  ##          : <p>A time value that requests only snapshots created at or before the specified time. The time value is specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2012-07-16T18:00:00Z</code> </p>
  ##   OwnerAccount: JString
  ##               : The AWS customer account used to create or copy the snapshot. Use this field to filter the results to snapshots owned by a particular account. To describe snapshots you own, either specify your AWS customer account, or do not specify the parameter.
  ##   Version: JString (required)
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster snapshots that are associated with the specified tag value or values. For example, suppose that you have snapshots that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the snapshots that have either or both of these tag values associated with them.
  section = newJObject()
  var valid_607553 = query.getOrDefault("Marker")
  valid_607553 = validateParameter(valid_607553, JString, required = false,
                                 default = nil)
  if valid_607553 != nil:
    section.add "Marker", valid_607553
  var valid_607554 = query.getOrDefault("SortingEntities")
  valid_607554 = validateParameter(valid_607554, JArray, required = false,
                                 default = nil)
  if valid_607554 != nil:
    section.add "SortingEntities", valid_607554
  var valid_607555 = query.getOrDefault("SnapshotIdentifier")
  valid_607555 = validateParameter(valid_607555, JString, required = false,
                                 default = nil)
  if valid_607555 != nil:
    section.add "SnapshotIdentifier", valid_607555
  var valid_607556 = query.getOrDefault("ClusterExists")
  valid_607556 = validateParameter(valid_607556, JBool, required = false, default = nil)
  if valid_607556 != nil:
    section.add "ClusterExists", valid_607556
  var valid_607557 = query.getOrDefault("TagKeys")
  valid_607557 = validateParameter(valid_607557, JArray, required = false,
                                 default = nil)
  if valid_607557 != nil:
    section.add "TagKeys", valid_607557
  var valid_607558 = query.getOrDefault("SnapshotType")
  valid_607558 = validateParameter(valid_607558, JString, required = false,
                                 default = nil)
  if valid_607558 != nil:
    section.add "SnapshotType", valid_607558
  var valid_607559 = query.getOrDefault("Action")
  valid_607559 = validateParameter(valid_607559, JString, required = true, default = newJString(
      "DescribeClusterSnapshots"))
  if valid_607559 != nil:
    section.add "Action", valid_607559
  var valid_607560 = query.getOrDefault("StartTime")
  valid_607560 = validateParameter(valid_607560, JString, required = false,
                                 default = nil)
  if valid_607560 != nil:
    section.add "StartTime", valid_607560
  var valid_607561 = query.getOrDefault("ClusterIdentifier")
  valid_607561 = validateParameter(valid_607561, JString, required = false,
                                 default = nil)
  if valid_607561 != nil:
    section.add "ClusterIdentifier", valid_607561
  var valid_607562 = query.getOrDefault("EndTime")
  valid_607562 = validateParameter(valid_607562, JString, required = false,
                                 default = nil)
  if valid_607562 != nil:
    section.add "EndTime", valid_607562
  var valid_607563 = query.getOrDefault("OwnerAccount")
  valid_607563 = validateParameter(valid_607563, JString, required = false,
                                 default = nil)
  if valid_607563 != nil:
    section.add "OwnerAccount", valid_607563
  var valid_607564 = query.getOrDefault("Version")
  valid_607564 = validateParameter(valid_607564, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_607564 != nil:
    section.add "Version", valid_607564
  var valid_607565 = query.getOrDefault("MaxRecords")
  valid_607565 = validateParameter(valid_607565, JInt, required = false, default = nil)
  if valid_607565 != nil:
    section.add "MaxRecords", valid_607565
  var valid_607566 = query.getOrDefault("TagValues")
  valid_607566 = validateParameter(valid_607566, JArray, required = false,
                                 default = nil)
  if valid_607566 != nil:
    section.add "TagValues", valid_607566
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_607567 = header.getOrDefault("X-Amz-Signature")
  valid_607567 = validateParameter(valid_607567, JString, required = false,
                                 default = nil)
  if valid_607567 != nil:
    section.add "X-Amz-Signature", valid_607567
  var valid_607568 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_607568 = validateParameter(valid_607568, JString, required = false,
                                 default = nil)
  if valid_607568 != nil:
    section.add "X-Amz-Content-Sha256", valid_607568
  var valid_607569 = header.getOrDefault("X-Amz-Date")
  valid_607569 = validateParameter(valid_607569, JString, required = false,
                                 default = nil)
  if valid_607569 != nil:
    section.add "X-Amz-Date", valid_607569
  var valid_607570 = header.getOrDefault("X-Amz-Credential")
  valid_607570 = validateParameter(valid_607570, JString, required = false,
                                 default = nil)
  if valid_607570 != nil:
    section.add "X-Amz-Credential", valid_607570
  var valid_607571 = header.getOrDefault("X-Amz-Security-Token")
  valid_607571 = validateParameter(valid_607571, JString, required = false,
                                 default = nil)
  if valid_607571 != nil:
    section.add "X-Amz-Security-Token", valid_607571
  var valid_607572 = header.getOrDefault("X-Amz-Algorithm")
  valid_607572 = validateParameter(valid_607572, JString, required = false,
                                 default = nil)
  if valid_607572 != nil:
    section.add "X-Amz-Algorithm", valid_607572
  var valid_607573 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_607573 = validateParameter(valid_607573, JString, required = false,
                                 default = nil)
  if valid_607573 != nil:
    section.add "X-Amz-SignedHeaders", valid_607573
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_607574: Call_GetDescribeClusterSnapshots_607550; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns one or more snapshot objects, which contain metadata about your cluster snapshots. By default, this operation returns information about all snapshots of all clusters that are owned by you AWS customer account. No information is returned for snapshots owned by inactive AWS customer accounts.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all snapshots that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all snapshots that have any combination of those values are returned. Only snapshots that you own are returned in the response; shared snapshots are not returned with the tag key and tag value request parameters.</p> <p>If both tag keys and values are omitted from the request, snapshots are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_607574.validator(path, query, header, formData, body)
  let scheme = call_607574.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_607574.url(scheme.get, call_607574.host, call_607574.base,
                         call_607574.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_607574, url, valid)

proc call*(call_607575: Call_GetDescribeClusterSnapshots_607550;
          Marker: string = ""; SortingEntities: JsonNode = nil;
          SnapshotIdentifier: string = ""; ClusterExists: bool = false;
          TagKeys: JsonNode = nil; SnapshotType: string = "";
          Action: string = "DescribeClusterSnapshots"; StartTime: string = "";
          ClusterIdentifier: string = ""; EndTime: string = "";
          OwnerAccount: string = ""; Version: string = "2012-12-01";
          MaxRecords: int = 0; TagValues: JsonNode = nil): Recallable =
  ## getDescribeClusterSnapshots
  ## <p>Returns one or more snapshot objects, which contain metadata about your cluster snapshots. By default, this operation returns information about all snapshots of all clusters that are owned by you AWS customer account. No information is returned for snapshots owned by inactive AWS customer accounts.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all snapshots that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all snapshots that have any combination of those values are returned. Only snapshots that you own are returned in the response; shared snapshots are not returned with the tag key and tag value request parameters.</p> <p>If both tag keys and values are omitted from the request, snapshots are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterSnapshots</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   SortingEntities: JArray
  ##                  : <p/>
  ##   SnapshotIdentifier: string
  ##                     : The snapshot identifier of the snapshot about which to return information.
  ##   ClusterExists: bool
  ##                : <p>A value that indicates whether to return snapshots only for an existing cluster. You can perform table-level restore only by using a snapshot of an existing cluster, that is, a cluster that has not been deleted. Values for this parameter work as follows: </p> <ul> <li> <p>If <code>ClusterExists</code> is set to <code>true</code>, <code>ClusterIdentifier</code> is required.</p> </li> <li> <p>If <code>ClusterExists</code> is set to <code>false</code> and <code>ClusterIdentifier</code> isn't specified, all snapshots associated with deleted clusters (orphaned snapshots) are returned. </p> </li> <li> <p>If <code>ClusterExists</code> is set to <code>false</code> and <code>ClusterIdentifier</code> is specified for a deleted cluster, snapshots associated with that cluster are returned.</p> </li> <li> <p>If <code>ClusterExists</code> is set to <code>false</code> and <code>ClusterIdentifier</code> is specified for an existing cluster, no snapshots are returned. </p> </li> </ul>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster snapshots that are associated with the specified key or keys. For example, suppose that you have snapshots that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the snapshots that have either or both of these tag keys associated with them.
  ##   SnapshotType: string
  ##               : <p>The type of snapshots for which you are requesting information. By default, snapshots of all types are returned.</p> <p>Valid Values: <code>automated</code> | <code>manual</code> </p>
  ##   Action: string (required)
  ##   StartTime: string
  ##            : <p>A value that requests only snapshots created at or after the specified time. The time value is specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2012-07-16T18:00:00Z</code> </p>
  ##   ClusterIdentifier: string
  ##                    : The identifier of the cluster which generated the requested snapshots.
  ##   EndTime: string
  ##          : <p>A time value that requests only snapshots created at or before the specified time. The time value is specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2012-07-16T18:00:00Z</code> </p>
  ##   OwnerAccount: string
  ##               : The AWS customer account used to create or copy the snapshot. Use this field to filter the results to snapshots owned by a particular account. To describe snapshots you own, either specify your AWS customer account, or do not specify the parameter.
  ##   Version: string (required)
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster snapshots that are associated with the specified tag value or values. For example, suppose that you have snapshots that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the snapshots that have either or both of these tag values associated with them.
  var query_607576 = newJObject()
  add(query_607576, "Marker", newJString(Marker))
  if SortingEntities != nil:
    query_607576.add "SortingEntities", SortingEntities
  add(query_607576, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_607576, "ClusterExists", newJBool(ClusterExists))
  if TagKeys != nil:
    query_607576.add "TagKeys", TagKeys
  add(query_607576, "SnapshotType", newJString(SnapshotType))
  add(query_607576, "Action", newJString(Action))
  add(query_607576, "StartTime", newJString(StartTime))
  add(query_607576, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_607576, "EndTime", newJString(EndTime))
  add(query_607576, "OwnerAccount", newJString(OwnerAccount))
  add(query_607576, "Version", newJString(Version))
  add(query_607576, "MaxRecords", newJInt(MaxRecords))
  if TagValues != nil:
    query_607576.add "TagValues", TagValues
  result = call_607575.call(nil, query_607576, nil, nil, nil)

var getDescribeClusterSnapshots* = Call_GetDescribeClusterSnapshots_607550(
    name: "getDescribeClusterSnapshots", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusterSnapshots",
    validator: validate_GetDescribeClusterSnapshots_607551, base: "/",
    url: url_GetDescribeClusterSnapshots_607552,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeClusterSubnetGroups_607625 = ref object of OpenApiRestCall_605573
proc url_PostDescribeClusterSubnetGroups_607627(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeClusterSubnetGroups_607626(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns one or more cluster subnet group objects, which contain metadata about your cluster subnet groups. By default, this operation returns information about all cluster subnet groups that are defined in you AWS account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all subnet groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all subnet groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, subnet groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_607628 = query.getOrDefault("Action")
  valid_607628 = validateParameter(valid_607628, JString, required = true, default = newJString(
      "DescribeClusterSubnetGroups"))
  if valid_607628 != nil:
    section.add "Action", valid_607628
  var valid_607629 = query.getOrDefault("Version")
  valid_607629 = validateParameter(valid_607629, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_607629 != nil:
    section.add "Version", valid_607629
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_607630 = header.getOrDefault("X-Amz-Signature")
  valid_607630 = validateParameter(valid_607630, JString, required = false,
                                 default = nil)
  if valid_607630 != nil:
    section.add "X-Amz-Signature", valid_607630
  var valid_607631 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_607631 = validateParameter(valid_607631, JString, required = false,
                                 default = nil)
  if valid_607631 != nil:
    section.add "X-Amz-Content-Sha256", valid_607631
  var valid_607632 = header.getOrDefault("X-Amz-Date")
  valid_607632 = validateParameter(valid_607632, JString, required = false,
                                 default = nil)
  if valid_607632 != nil:
    section.add "X-Amz-Date", valid_607632
  var valid_607633 = header.getOrDefault("X-Amz-Credential")
  valid_607633 = validateParameter(valid_607633, JString, required = false,
                                 default = nil)
  if valid_607633 != nil:
    section.add "X-Amz-Credential", valid_607633
  var valid_607634 = header.getOrDefault("X-Amz-Security-Token")
  valid_607634 = validateParameter(valid_607634, JString, required = false,
                                 default = nil)
  if valid_607634 != nil:
    section.add "X-Amz-Security-Token", valid_607634
  var valid_607635 = header.getOrDefault("X-Amz-Algorithm")
  valid_607635 = validateParameter(valid_607635, JString, required = false,
                                 default = nil)
  if valid_607635 != nil:
    section.add "X-Amz-Algorithm", valid_607635
  var valid_607636 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_607636 = validateParameter(valid_607636, JString, required = false,
                                 default = nil)
  if valid_607636 != nil:
    section.add "X-Amz-SignedHeaders", valid_607636
  result.add "header", section
  ## parameters in `formData` object:
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster subnet groups that are associated with the specified key or keys. For example, suppose that you have subnet groups that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the subnet groups that have either or both of these tag keys associated with them.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterSubnetGroups</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   ClusterSubnetGroupName: JString
  ##                         : The name of the cluster subnet group for which information is requested.
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster subnet groups that are associated with the specified tag value or values. For example, suppose that you have subnet groups that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the subnet groups that have either or both of these tag values associated with them.
  section = newJObject()
  var valid_607637 = formData.getOrDefault("TagKeys")
  valid_607637 = validateParameter(valid_607637, JArray, required = false,
                                 default = nil)
  if valid_607637 != nil:
    section.add "TagKeys", valid_607637
  var valid_607638 = formData.getOrDefault("MaxRecords")
  valid_607638 = validateParameter(valid_607638, JInt, required = false, default = nil)
  if valid_607638 != nil:
    section.add "MaxRecords", valid_607638
  var valid_607639 = formData.getOrDefault("Marker")
  valid_607639 = validateParameter(valid_607639, JString, required = false,
                                 default = nil)
  if valid_607639 != nil:
    section.add "Marker", valid_607639
  var valid_607640 = formData.getOrDefault("ClusterSubnetGroupName")
  valid_607640 = validateParameter(valid_607640, JString, required = false,
                                 default = nil)
  if valid_607640 != nil:
    section.add "ClusterSubnetGroupName", valid_607640
  var valid_607641 = formData.getOrDefault("TagValues")
  valid_607641 = validateParameter(valid_607641, JArray, required = false,
                                 default = nil)
  if valid_607641 != nil:
    section.add "TagValues", valid_607641
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_607642: Call_PostDescribeClusterSubnetGroups_607625;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Returns one or more cluster subnet group objects, which contain metadata about your cluster subnet groups. By default, this operation returns information about all cluster subnet groups that are defined in you AWS account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all subnet groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all subnet groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, subnet groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_607642.validator(path, query, header, formData, body)
  let scheme = call_607642.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_607642.url(scheme.get, call_607642.host, call_607642.base,
                         call_607642.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_607642, url, valid)

proc call*(call_607643: Call_PostDescribeClusterSubnetGroups_607625;
          TagKeys: JsonNode = nil; MaxRecords: int = 0; Marker: string = "";
          ClusterSubnetGroupName: string = ""; TagValues: JsonNode = nil;
          Action: string = "DescribeClusterSubnetGroups";
          Version: string = "2012-12-01"): Recallable =
  ## postDescribeClusterSubnetGroups
  ## <p>Returns one or more cluster subnet group objects, which contain metadata about your cluster subnet groups. By default, this operation returns information about all cluster subnet groups that are defined in you AWS account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all subnet groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all subnet groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, subnet groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster subnet groups that are associated with the specified key or keys. For example, suppose that you have subnet groups that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the subnet groups that have either or both of these tag keys associated with them.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterSubnetGroups</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   ClusterSubnetGroupName: string
  ##                         : The name of the cluster subnet group for which information is requested.
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster subnet groups that are associated with the specified tag value or values. For example, suppose that you have subnet groups that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the subnet groups that have either or both of these tag values associated with them.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_607644 = newJObject()
  var formData_607645 = newJObject()
  if TagKeys != nil:
    formData_607645.add "TagKeys", TagKeys
  add(formData_607645, "MaxRecords", newJInt(MaxRecords))
  add(formData_607645, "Marker", newJString(Marker))
  add(formData_607645, "ClusterSubnetGroupName",
      newJString(ClusterSubnetGroupName))
  if TagValues != nil:
    formData_607645.add "TagValues", TagValues
  add(query_607644, "Action", newJString(Action))
  add(query_607644, "Version", newJString(Version))
  result = call_607643.call(nil, query_607644, nil, formData_607645, nil)

var postDescribeClusterSubnetGroups* = Call_PostDescribeClusterSubnetGroups_607625(
    name: "postDescribeClusterSubnetGroups", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusterSubnetGroups",
    validator: validate_PostDescribeClusterSubnetGroups_607626, base: "/",
    url: url_PostDescribeClusterSubnetGroups_607627,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeClusterSubnetGroups_607605 = ref object of OpenApiRestCall_605573
proc url_GetDescribeClusterSubnetGroups_607607(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeClusterSubnetGroups_607606(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns one or more cluster subnet group objects, which contain metadata about your cluster subnet groups. By default, this operation returns information about all cluster subnet groups that are defined in you AWS account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all subnet groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all subnet groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, subnet groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ClusterSubnetGroupName: JString
  ##                         : The name of the cluster subnet group for which information is requested.
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterSubnetGroups</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster subnet groups that are associated with the specified key or keys. For example, suppose that you have subnet groups that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the subnet groups that have either or both of these tag keys associated with them.
  ##   Action: JString (required)
  ##   Version: JString (required)
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster subnet groups that are associated with the specified tag value or values. For example, suppose that you have subnet groups that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the subnet groups that have either or both of these tag values associated with them.
  section = newJObject()
  var valid_607608 = query.getOrDefault("ClusterSubnetGroupName")
  valid_607608 = validateParameter(valid_607608, JString, required = false,
                                 default = nil)
  if valid_607608 != nil:
    section.add "ClusterSubnetGroupName", valid_607608
  var valid_607609 = query.getOrDefault("Marker")
  valid_607609 = validateParameter(valid_607609, JString, required = false,
                                 default = nil)
  if valid_607609 != nil:
    section.add "Marker", valid_607609
  var valid_607610 = query.getOrDefault("TagKeys")
  valid_607610 = validateParameter(valid_607610, JArray, required = false,
                                 default = nil)
  if valid_607610 != nil:
    section.add "TagKeys", valid_607610
  var valid_607611 = query.getOrDefault("Action")
  valid_607611 = validateParameter(valid_607611, JString, required = true, default = newJString(
      "DescribeClusterSubnetGroups"))
  if valid_607611 != nil:
    section.add "Action", valid_607611
  var valid_607612 = query.getOrDefault("Version")
  valid_607612 = validateParameter(valid_607612, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_607612 != nil:
    section.add "Version", valid_607612
  var valid_607613 = query.getOrDefault("MaxRecords")
  valid_607613 = validateParameter(valid_607613, JInt, required = false, default = nil)
  if valid_607613 != nil:
    section.add "MaxRecords", valid_607613
  var valid_607614 = query.getOrDefault("TagValues")
  valid_607614 = validateParameter(valid_607614, JArray, required = false,
                                 default = nil)
  if valid_607614 != nil:
    section.add "TagValues", valid_607614
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_607615 = header.getOrDefault("X-Amz-Signature")
  valid_607615 = validateParameter(valid_607615, JString, required = false,
                                 default = nil)
  if valid_607615 != nil:
    section.add "X-Amz-Signature", valid_607615
  var valid_607616 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_607616 = validateParameter(valid_607616, JString, required = false,
                                 default = nil)
  if valid_607616 != nil:
    section.add "X-Amz-Content-Sha256", valid_607616
  var valid_607617 = header.getOrDefault("X-Amz-Date")
  valid_607617 = validateParameter(valid_607617, JString, required = false,
                                 default = nil)
  if valid_607617 != nil:
    section.add "X-Amz-Date", valid_607617
  var valid_607618 = header.getOrDefault("X-Amz-Credential")
  valid_607618 = validateParameter(valid_607618, JString, required = false,
                                 default = nil)
  if valid_607618 != nil:
    section.add "X-Amz-Credential", valid_607618
  var valid_607619 = header.getOrDefault("X-Amz-Security-Token")
  valid_607619 = validateParameter(valid_607619, JString, required = false,
                                 default = nil)
  if valid_607619 != nil:
    section.add "X-Amz-Security-Token", valid_607619
  var valid_607620 = header.getOrDefault("X-Amz-Algorithm")
  valid_607620 = validateParameter(valid_607620, JString, required = false,
                                 default = nil)
  if valid_607620 != nil:
    section.add "X-Amz-Algorithm", valid_607620
  var valid_607621 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_607621 = validateParameter(valid_607621, JString, required = false,
                                 default = nil)
  if valid_607621 != nil:
    section.add "X-Amz-SignedHeaders", valid_607621
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_607622: Call_GetDescribeClusterSubnetGroups_607605; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns one or more cluster subnet group objects, which contain metadata about your cluster subnet groups. By default, this operation returns information about all cluster subnet groups that are defined in you AWS account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all subnet groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all subnet groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, subnet groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_607622.validator(path, query, header, formData, body)
  let scheme = call_607622.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_607622.url(scheme.get, call_607622.host, call_607622.base,
                         call_607622.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_607622, url, valid)

proc call*(call_607623: Call_GetDescribeClusterSubnetGroups_607605;
          ClusterSubnetGroupName: string = ""; Marker: string = "";
          TagKeys: JsonNode = nil; Action: string = "DescribeClusterSubnetGroups";
          Version: string = "2012-12-01"; MaxRecords: int = 0; TagValues: JsonNode = nil): Recallable =
  ## getDescribeClusterSubnetGroups
  ## <p>Returns one or more cluster subnet group objects, which contain metadata about your cluster subnet groups. By default, this operation returns information about all cluster subnet groups that are defined in you AWS account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all subnet groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all subnet groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, subnet groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   ClusterSubnetGroupName: string
  ##                         : The name of the cluster subnet group for which information is requested.
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterSubnetGroups</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster subnet groups that are associated with the specified key or keys. For example, suppose that you have subnet groups that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the subnet groups that have either or both of these tag keys associated with them.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster subnet groups that are associated with the specified tag value or values. For example, suppose that you have subnet groups that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the subnet groups that have either or both of these tag values associated with them.
  var query_607624 = newJObject()
  add(query_607624, "ClusterSubnetGroupName", newJString(ClusterSubnetGroupName))
  add(query_607624, "Marker", newJString(Marker))
  if TagKeys != nil:
    query_607624.add "TagKeys", TagKeys
  add(query_607624, "Action", newJString(Action))
  add(query_607624, "Version", newJString(Version))
  add(query_607624, "MaxRecords", newJInt(MaxRecords))
  if TagValues != nil:
    query_607624.add "TagValues", TagValues
  result = call_607623.call(nil, query_607624, nil, nil, nil)

var getDescribeClusterSubnetGroups* = Call_GetDescribeClusterSubnetGroups_607605(
    name: "getDescribeClusterSubnetGroups", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusterSubnetGroups",
    validator: validate_GetDescribeClusterSubnetGroups_607606, base: "/",
    url: url_GetDescribeClusterSubnetGroups_607607,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeClusterTracks_607664 = ref object of OpenApiRestCall_605573
proc url_PostDescribeClusterTracks_607666(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeClusterTracks_607665(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns a list of all the available maintenance tracks.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_607667 = query.getOrDefault("Action")
  valid_607667 = validateParameter(valid_607667, JString, required = true,
                                 default = newJString("DescribeClusterTracks"))
  if valid_607667 != nil:
    section.add "Action", valid_607667
  var valid_607668 = query.getOrDefault("Version")
  valid_607668 = validateParameter(valid_607668, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_607668 != nil:
    section.add "Version", valid_607668
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_607669 = header.getOrDefault("X-Amz-Signature")
  valid_607669 = validateParameter(valid_607669, JString, required = false,
                                 default = nil)
  if valid_607669 != nil:
    section.add "X-Amz-Signature", valid_607669
  var valid_607670 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_607670 = validateParameter(valid_607670, JString, required = false,
                                 default = nil)
  if valid_607670 != nil:
    section.add "X-Amz-Content-Sha256", valid_607670
  var valid_607671 = header.getOrDefault("X-Amz-Date")
  valid_607671 = validateParameter(valid_607671, JString, required = false,
                                 default = nil)
  if valid_607671 != nil:
    section.add "X-Amz-Date", valid_607671
  var valid_607672 = header.getOrDefault("X-Amz-Credential")
  valid_607672 = validateParameter(valid_607672, JString, required = false,
                                 default = nil)
  if valid_607672 != nil:
    section.add "X-Amz-Credential", valid_607672
  var valid_607673 = header.getOrDefault("X-Amz-Security-Token")
  valid_607673 = validateParameter(valid_607673, JString, required = false,
                                 default = nil)
  if valid_607673 != nil:
    section.add "X-Amz-Security-Token", valid_607673
  var valid_607674 = header.getOrDefault("X-Amz-Algorithm")
  valid_607674 = validateParameter(valid_607674, JString, required = false,
                                 default = nil)
  if valid_607674 != nil:
    section.add "X-Amz-Algorithm", valid_607674
  var valid_607675 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_607675 = validateParameter(valid_607675, JString, required = false,
                                 default = nil)
  if valid_607675 != nil:
    section.add "X-Amz-SignedHeaders", valid_607675
  result.add "header", section
  ## parameters in `formData` object:
  ##   MaintenanceTrackName: JString
  ##                       : The name of the maintenance track. 
  ##   MaxRecords: JInt
  ##             : An integer value for the maximum number of maintenance tracks to return.
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <code>DescribeClusterTracks</code> request exceed the value specified in <code>MaxRecords</code>, Amazon Redshift returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  section = newJObject()
  var valid_607676 = formData.getOrDefault("MaintenanceTrackName")
  valid_607676 = validateParameter(valid_607676, JString, required = false,
                                 default = nil)
  if valid_607676 != nil:
    section.add "MaintenanceTrackName", valid_607676
  var valid_607677 = formData.getOrDefault("MaxRecords")
  valid_607677 = validateParameter(valid_607677, JInt, required = false, default = nil)
  if valid_607677 != nil:
    section.add "MaxRecords", valid_607677
  var valid_607678 = formData.getOrDefault("Marker")
  valid_607678 = validateParameter(valid_607678, JString, required = false,
                                 default = nil)
  if valid_607678 != nil:
    section.add "Marker", valid_607678
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_607679: Call_PostDescribeClusterTracks_607664; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns a list of all the available maintenance tracks.
  ## 
  let valid = call_607679.validator(path, query, header, formData, body)
  let scheme = call_607679.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_607679.url(scheme.get, call_607679.host, call_607679.base,
                         call_607679.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_607679, url, valid)

proc call*(call_607680: Call_PostDescribeClusterTracks_607664;
          MaintenanceTrackName: string = ""; MaxRecords: int = 0; Marker: string = "";
          Action: string = "DescribeClusterTracks"; Version: string = "2012-12-01"): Recallable =
  ## postDescribeClusterTracks
  ## Returns a list of all the available maintenance tracks.
  ##   MaintenanceTrackName: string
  ##                       : The name of the maintenance track. 
  ##   MaxRecords: int
  ##             : An integer value for the maximum number of maintenance tracks to return.
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <code>DescribeClusterTracks</code> request exceed the value specified in <code>MaxRecords</code>, Amazon Redshift returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Action: string (required)
  ##   Version: string (required)
  var query_607681 = newJObject()
  var formData_607682 = newJObject()
  add(formData_607682, "MaintenanceTrackName", newJString(MaintenanceTrackName))
  add(formData_607682, "MaxRecords", newJInt(MaxRecords))
  add(formData_607682, "Marker", newJString(Marker))
  add(query_607681, "Action", newJString(Action))
  add(query_607681, "Version", newJString(Version))
  result = call_607680.call(nil, query_607681, nil, formData_607682, nil)

var postDescribeClusterTracks* = Call_PostDescribeClusterTracks_607664(
    name: "postDescribeClusterTracks", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusterTracks",
    validator: validate_PostDescribeClusterTracks_607665, base: "/",
    url: url_PostDescribeClusterTracks_607666,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeClusterTracks_607646 = ref object of OpenApiRestCall_605573
proc url_GetDescribeClusterTracks_607648(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeClusterTracks_607647(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns a list of all the available maintenance tracks.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <code>DescribeClusterTracks</code> request exceed the value specified in <code>MaxRecords</code>, Amazon Redshift returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   MaintenanceTrackName: JString
  ##                       : The name of the maintenance track. 
  ##   Action: JString (required)
  ##   Version: JString (required)
  ##   MaxRecords: JInt
  ##             : An integer value for the maximum number of maintenance tracks to return.
  section = newJObject()
  var valid_607649 = query.getOrDefault("Marker")
  valid_607649 = validateParameter(valid_607649, JString, required = false,
                                 default = nil)
  if valid_607649 != nil:
    section.add "Marker", valid_607649
  var valid_607650 = query.getOrDefault("MaintenanceTrackName")
  valid_607650 = validateParameter(valid_607650, JString, required = false,
                                 default = nil)
  if valid_607650 != nil:
    section.add "MaintenanceTrackName", valid_607650
  var valid_607651 = query.getOrDefault("Action")
  valid_607651 = validateParameter(valid_607651, JString, required = true,
                                 default = newJString("DescribeClusterTracks"))
  if valid_607651 != nil:
    section.add "Action", valid_607651
  var valid_607652 = query.getOrDefault("Version")
  valid_607652 = validateParameter(valid_607652, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_607652 != nil:
    section.add "Version", valid_607652
  var valid_607653 = query.getOrDefault("MaxRecords")
  valid_607653 = validateParameter(valid_607653, JInt, required = false, default = nil)
  if valid_607653 != nil:
    section.add "MaxRecords", valid_607653
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_607654 = header.getOrDefault("X-Amz-Signature")
  valid_607654 = validateParameter(valid_607654, JString, required = false,
                                 default = nil)
  if valid_607654 != nil:
    section.add "X-Amz-Signature", valid_607654
  var valid_607655 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_607655 = validateParameter(valid_607655, JString, required = false,
                                 default = nil)
  if valid_607655 != nil:
    section.add "X-Amz-Content-Sha256", valid_607655
  var valid_607656 = header.getOrDefault("X-Amz-Date")
  valid_607656 = validateParameter(valid_607656, JString, required = false,
                                 default = nil)
  if valid_607656 != nil:
    section.add "X-Amz-Date", valid_607656
  var valid_607657 = header.getOrDefault("X-Amz-Credential")
  valid_607657 = validateParameter(valid_607657, JString, required = false,
                                 default = nil)
  if valid_607657 != nil:
    section.add "X-Amz-Credential", valid_607657
  var valid_607658 = header.getOrDefault("X-Amz-Security-Token")
  valid_607658 = validateParameter(valid_607658, JString, required = false,
                                 default = nil)
  if valid_607658 != nil:
    section.add "X-Amz-Security-Token", valid_607658
  var valid_607659 = header.getOrDefault("X-Amz-Algorithm")
  valid_607659 = validateParameter(valid_607659, JString, required = false,
                                 default = nil)
  if valid_607659 != nil:
    section.add "X-Amz-Algorithm", valid_607659
  var valid_607660 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_607660 = validateParameter(valid_607660, JString, required = false,
                                 default = nil)
  if valid_607660 != nil:
    section.add "X-Amz-SignedHeaders", valid_607660
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_607661: Call_GetDescribeClusterTracks_607646; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns a list of all the available maintenance tracks.
  ## 
  let valid = call_607661.validator(path, query, header, formData, body)
  let scheme = call_607661.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_607661.url(scheme.get, call_607661.host, call_607661.base,
                         call_607661.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_607661, url, valid)

proc call*(call_607662: Call_GetDescribeClusterTracks_607646; Marker: string = "";
          MaintenanceTrackName: string = "";
          Action: string = "DescribeClusterTracks"; Version: string = "2012-12-01";
          MaxRecords: int = 0): Recallable =
  ## getDescribeClusterTracks
  ## Returns a list of all the available maintenance tracks.
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <code>DescribeClusterTracks</code> request exceed the value specified in <code>MaxRecords</code>, Amazon Redshift returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   MaintenanceTrackName: string
  ##                       : The name of the maintenance track. 
  ##   Action: string (required)
  ##   Version: string (required)
  ##   MaxRecords: int
  ##             : An integer value for the maximum number of maintenance tracks to return.
  var query_607663 = newJObject()
  add(query_607663, "Marker", newJString(Marker))
  add(query_607663, "MaintenanceTrackName", newJString(MaintenanceTrackName))
  add(query_607663, "Action", newJString(Action))
  add(query_607663, "Version", newJString(Version))
  add(query_607663, "MaxRecords", newJInt(MaxRecords))
  result = call_607662.call(nil, query_607663, nil, nil, nil)

var getDescribeClusterTracks* = Call_GetDescribeClusterTracks_607646(
    name: "getDescribeClusterTracks", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusterTracks",
    validator: validate_GetDescribeClusterTracks_607647, base: "/",
    url: url_GetDescribeClusterTracks_607648, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeClusterVersions_607702 = ref object of OpenApiRestCall_605573
proc url_PostDescribeClusterVersions_607704(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeClusterVersions_607703(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns descriptions of the available Amazon Redshift cluster versions. You can call this operation even before creating any clusters to learn more about the Amazon Redshift versions. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_607705 = query.getOrDefault("Action")
  valid_607705 = validateParameter(valid_607705, JString, required = true, default = newJString(
      "DescribeClusterVersions"))
  if valid_607705 != nil:
    section.add "Action", valid_607705
  var valid_607706 = query.getOrDefault("Version")
  valid_607706 = validateParameter(valid_607706, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_607706 != nil:
    section.add "Version", valid_607706
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_607707 = header.getOrDefault("X-Amz-Signature")
  valid_607707 = validateParameter(valid_607707, JString, required = false,
                                 default = nil)
  if valid_607707 != nil:
    section.add "X-Amz-Signature", valid_607707
  var valid_607708 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_607708 = validateParameter(valid_607708, JString, required = false,
                                 default = nil)
  if valid_607708 != nil:
    section.add "X-Amz-Content-Sha256", valid_607708
  var valid_607709 = header.getOrDefault("X-Amz-Date")
  valid_607709 = validateParameter(valid_607709, JString, required = false,
                                 default = nil)
  if valid_607709 != nil:
    section.add "X-Amz-Date", valid_607709
  var valid_607710 = header.getOrDefault("X-Amz-Credential")
  valid_607710 = validateParameter(valid_607710, JString, required = false,
                                 default = nil)
  if valid_607710 != nil:
    section.add "X-Amz-Credential", valid_607710
  var valid_607711 = header.getOrDefault("X-Amz-Security-Token")
  valid_607711 = validateParameter(valid_607711, JString, required = false,
                                 default = nil)
  if valid_607711 != nil:
    section.add "X-Amz-Security-Token", valid_607711
  var valid_607712 = header.getOrDefault("X-Amz-Algorithm")
  valid_607712 = validateParameter(valid_607712, JString, required = false,
                                 default = nil)
  if valid_607712 != nil:
    section.add "X-Amz-Algorithm", valid_607712
  var valid_607713 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_607713 = validateParameter(valid_607713, JString, required = false,
                                 default = nil)
  if valid_607713 != nil:
    section.add "X-Amz-SignedHeaders", valid_607713
  result.add "header", section
  ## parameters in `formData` object:
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   ClusterParameterGroupFamily: JString
  ##                              : <p>The name of a specific cluster parameter group family to return details for.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters</p> </li> <li> <p>First character must be a letter</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens</p> </li> </ul>
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterVersions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   ClusterVersion: JString
  ##                 : <p>The specific cluster version to return.</p> <p>Example: <code>1.0</code> </p>
  section = newJObject()
  var valid_607714 = formData.getOrDefault("MaxRecords")
  valid_607714 = validateParameter(valid_607714, JInt, required = false, default = nil)
  if valid_607714 != nil:
    section.add "MaxRecords", valid_607714
  var valid_607715 = formData.getOrDefault("ClusterParameterGroupFamily")
  valid_607715 = validateParameter(valid_607715, JString, required = false,
                                 default = nil)
  if valid_607715 != nil:
    section.add "ClusterParameterGroupFamily", valid_607715
  var valid_607716 = formData.getOrDefault("Marker")
  valid_607716 = validateParameter(valid_607716, JString, required = false,
                                 default = nil)
  if valid_607716 != nil:
    section.add "Marker", valid_607716
  var valid_607717 = formData.getOrDefault("ClusterVersion")
  valid_607717 = validateParameter(valid_607717, JString, required = false,
                                 default = nil)
  if valid_607717 != nil:
    section.add "ClusterVersion", valid_607717
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_607718: Call_PostDescribeClusterVersions_607702; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns descriptions of the available Amazon Redshift cluster versions. You can call this operation even before creating any clusters to learn more about the Amazon Redshift versions. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.
  ## 
  let valid = call_607718.validator(path, query, header, formData, body)
  let scheme = call_607718.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_607718.url(scheme.get, call_607718.host, call_607718.base,
                         call_607718.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_607718, url, valid)

proc call*(call_607719: Call_PostDescribeClusterVersions_607702;
          MaxRecords: int = 0; ClusterParameterGroupFamily: string = "";
          Marker: string = ""; Action: string = "DescribeClusterVersions";
          ClusterVersion: string = ""; Version: string = "2012-12-01"): Recallable =
  ## postDescribeClusterVersions
  ## Returns descriptions of the available Amazon Redshift cluster versions. You can call this operation even before creating any clusters to learn more about the Amazon Redshift versions. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   ClusterParameterGroupFamily: string
  ##                              : <p>The name of a specific cluster parameter group family to return details for.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters</p> </li> <li> <p>First character must be a letter</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens</p> </li> </ul>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterVersions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Action: string (required)
  ##   ClusterVersion: string
  ##                 : <p>The specific cluster version to return.</p> <p>Example: <code>1.0</code> </p>
  ##   Version: string (required)
  var query_607720 = newJObject()
  var formData_607721 = newJObject()
  add(formData_607721, "MaxRecords", newJInt(MaxRecords))
  add(formData_607721, "ClusterParameterGroupFamily",
      newJString(ClusterParameterGroupFamily))
  add(formData_607721, "Marker", newJString(Marker))
  add(query_607720, "Action", newJString(Action))
  add(formData_607721, "ClusterVersion", newJString(ClusterVersion))
  add(query_607720, "Version", newJString(Version))
  result = call_607719.call(nil, query_607720, nil, formData_607721, nil)

var postDescribeClusterVersions* = Call_PostDescribeClusterVersions_607702(
    name: "postDescribeClusterVersions", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusterVersions",
    validator: validate_PostDescribeClusterVersions_607703, base: "/",
    url: url_PostDescribeClusterVersions_607704,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeClusterVersions_607683 = ref object of OpenApiRestCall_605573
proc url_GetDescribeClusterVersions_607685(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeClusterVersions_607684(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns descriptions of the available Amazon Redshift cluster versions. You can call this operation even before creating any clusters to learn more about the Amazon Redshift versions. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterVersions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   ClusterParameterGroupFamily: JString
  ##                              : <p>The name of a specific cluster parameter group family to return details for.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters</p> </li> <li> <p>First character must be a letter</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens</p> </li> </ul>
  ##   ClusterVersion: JString
  ##                 : <p>The specific cluster version to return.</p> <p>Example: <code>1.0</code> </p>
  ##   Action: JString (required)
  ##   Version: JString (required)
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  section = newJObject()
  var valid_607686 = query.getOrDefault("Marker")
  valid_607686 = validateParameter(valid_607686, JString, required = false,
                                 default = nil)
  if valid_607686 != nil:
    section.add "Marker", valid_607686
  var valid_607687 = query.getOrDefault("ClusterParameterGroupFamily")
  valid_607687 = validateParameter(valid_607687, JString, required = false,
                                 default = nil)
  if valid_607687 != nil:
    section.add "ClusterParameterGroupFamily", valid_607687
  var valid_607688 = query.getOrDefault("ClusterVersion")
  valid_607688 = validateParameter(valid_607688, JString, required = false,
                                 default = nil)
  if valid_607688 != nil:
    section.add "ClusterVersion", valid_607688
  var valid_607689 = query.getOrDefault("Action")
  valid_607689 = validateParameter(valid_607689, JString, required = true, default = newJString(
      "DescribeClusterVersions"))
  if valid_607689 != nil:
    section.add "Action", valid_607689
  var valid_607690 = query.getOrDefault("Version")
  valid_607690 = validateParameter(valid_607690, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_607690 != nil:
    section.add "Version", valid_607690
  var valid_607691 = query.getOrDefault("MaxRecords")
  valid_607691 = validateParameter(valid_607691, JInt, required = false, default = nil)
  if valid_607691 != nil:
    section.add "MaxRecords", valid_607691
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_607692 = header.getOrDefault("X-Amz-Signature")
  valid_607692 = validateParameter(valid_607692, JString, required = false,
                                 default = nil)
  if valid_607692 != nil:
    section.add "X-Amz-Signature", valid_607692
  var valid_607693 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_607693 = validateParameter(valid_607693, JString, required = false,
                                 default = nil)
  if valid_607693 != nil:
    section.add "X-Amz-Content-Sha256", valid_607693
  var valid_607694 = header.getOrDefault("X-Amz-Date")
  valid_607694 = validateParameter(valid_607694, JString, required = false,
                                 default = nil)
  if valid_607694 != nil:
    section.add "X-Amz-Date", valid_607694
  var valid_607695 = header.getOrDefault("X-Amz-Credential")
  valid_607695 = validateParameter(valid_607695, JString, required = false,
                                 default = nil)
  if valid_607695 != nil:
    section.add "X-Amz-Credential", valid_607695
  var valid_607696 = header.getOrDefault("X-Amz-Security-Token")
  valid_607696 = validateParameter(valid_607696, JString, required = false,
                                 default = nil)
  if valid_607696 != nil:
    section.add "X-Amz-Security-Token", valid_607696
  var valid_607697 = header.getOrDefault("X-Amz-Algorithm")
  valid_607697 = validateParameter(valid_607697, JString, required = false,
                                 default = nil)
  if valid_607697 != nil:
    section.add "X-Amz-Algorithm", valid_607697
  var valid_607698 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_607698 = validateParameter(valid_607698, JString, required = false,
                                 default = nil)
  if valid_607698 != nil:
    section.add "X-Amz-SignedHeaders", valid_607698
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_607699: Call_GetDescribeClusterVersions_607683; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns descriptions of the available Amazon Redshift cluster versions. You can call this operation even before creating any clusters to learn more about the Amazon Redshift versions. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.
  ## 
  let valid = call_607699.validator(path, query, header, formData, body)
  let scheme = call_607699.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_607699.url(scheme.get, call_607699.host, call_607699.base,
                         call_607699.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_607699, url, valid)

proc call*(call_607700: Call_GetDescribeClusterVersions_607683;
          Marker: string = ""; ClusterParameterGroupFamily: string = "";
          ClusterVersion: string = ""; Action: string = "DescribeClusterVersions";
          Version: string = "2012-12-01"; MaxRecords: int = 0): Recallable =
  ## getDescribeClusterVersions
  ## Returns descriptions of the available Amazon Redshift cluster versions. You can call this operation even before creating any clusters to learn more about the Amazon Redshift versions. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterVersions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   ClusterParameterGroupFamily: string
  ##                              : <p>The name of a specific cluster parameter group family to return details for.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters</p> </li> <li> <p>First character must be a letter</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens</p> </li> </ul>
  ##   ClusterVersion: string
  ##                 : <p>The specific cluster version to return.</p> <p>Example: <code>1.0</code> </p>
  ##   Action: string (required)
  ##   Version: string (required)
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  var query_607701 = newJObject()
  add(query_607701, "Marker", newJString(Marker))
  add(query_607701, "ClusterParameterGroupFamily",
      newJString(ClusterParameterGroupFamily))
  add(query_607701, "ClusterVersion", newJString(ClusterVersion))
  add(query_607701, "Action", newJString(Action))
  add(query_607701, "Version", newJString(Version))
  add(query_607701, "MaxRecords", newJInt(MaxRecords))
  result = call_607700.call(nil, query_607701, nil, nil, nil)

var getDescribeClusterVersions* = Call_GetDescribeClusterVersions_607683(
    name: "getDescribeClusterVersions", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusterVersions",
    validator: validate_GetDescribeClusterVersions_607684, base: "/",
    url: url_GetDescribeClusterVersions_607685,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeClusters_607742 = ref object of OpenApiRestCall_605573
proc url_PostDescribeClusters_607744(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeClusters_607743(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns properties of provisioned clusters including general cluster properties, cluster database properties, maintenance and backup properties, and security and access properties. This operation supports pagination. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all clusters that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all clusters that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, clusters are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_607745 = query.getOrDefault("Action")
  valid_607745 = validateParameter(valid_607745, JString, required = true,
                                 default = newJString("DescribeClusters"))
  if valid_607745 != nil:
    section.add "Action", valid_607745
  var valid_607746 = query.getOrDefault("Version")
  valid_607746 = validateParameter(valid_607746, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_607746 != nil:
    section.add "Version", valid_607746
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_607747 = header.getOrDefault("X-Amz-Signature")
  valid_607747 = validateParameter(valid_607747, JString, required = false,
                                 default = nil)
  if valid_607747 != nil:
    section.add "X-Amz-Signature", valid_607747
  var valid_607748 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_607748 = validateParameter(valid_607748, JString, required = false,
                                 default = nil)
  if valid_607748 != nil:
    section.add "X-Amz-Content-Sha256", valid_607748
  var valid_607749 = header.getOrDefault("X-Amz-Date")
  valid_607749 = validateParameter(valid_607749, JString, required = false,
                                 default = nil)
  if valid_607749 != nil:
    section.add "X-Amz-Date", valid_607749
  var valid_607750 = header.getOrDefault("X-Amz-Credential")
  valid_607750 = validateParameter(valid_607750, JString, required = false,
                                 default = nil)
  if valid_607750 != nil:
    section.add "X-Amz-Credential", valid_607750
  var valid_607751 = header.getOrDefault("X-Amz-Security-Token")
  valid_607751 = validateParameter(valid_607751, JString, required = false,
                                 default = nil)
  if valid_607751 != nil:
    section.add "X-Amz-Security-Token", valid_607751
  var valid_607752 = header.getOrDefault("X-Amz-Algorithm")
  valid_607752 = validateParameter(valid_607752, JString, required = false,
                                 default = nil)
  if valid_607752 != nil:
    section.add "X-Amz-Algorithm", valid_607752
  var valid_607753 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_607753 = validateParameter(valid_607753, JString, required = false,
                                 default = nil)
  if valid_607753 != nil:
    section.add "X-Amz-SignedHeaders", valid_607753
  result.add "header", section
  ## parameters in `formData` object:
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching clusters that are associated with the specified key or keys. For example, suppose that you have clusters that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the clusters that have either or both of these tag keys associated with them.
  ##   ClusterIdentifier: JString
  ##                    : <p>The unique identifier of a cluster whose properties you are requesting. This parameter is case sensitive.</p> <p>The default is that all clusters defined for an account are returned.</p>
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: JString
  ##         : <p>An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusters</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <b>ClusterIdentifier</b> parameter or the <b>Marker</b> parameter, but not both. </p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching clusters that are associated with the specified tag value or values. For example, suppose that you have clusters that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the clusters that have either or both of these tag values associated with them.
  section = newJObject()
  var valid_607754 = formData.getOrDefault("TagKeys")
  valid_607754 = validateParameter(valid_607754, JArray, required = false,
                                 default = nil)
  if valid_607754 != nil:
    section.add "TagKeys", valid_607754
  var valid_607755 = formData.getOrDefault("ClusterIdentifier")
  valid_607755 = validateParameter(valid_607755, JString, required = false,
                                 default = nil)
  if valid_607755 != nil:
    section.add "ClusterIdentifier", valid_607755
  var valid_607756 = formData.getOrDefault("MaxRecords")
  valid_607756 = validateParameter(valid_607756, JInt, required = false, default = nil)
  if valid_607756 != nil:
    section.add "MaxRecords", valid_607756
  var valid_607757 = formData.getOrDefault("Marker")
  valid_607757 = validateParameter(valid_607757, JString, required = false,
                                 default = nil)
  if valid_607757 != nil:
    section.add "Marker", valid_607757
  var valid_607758 = formData.getOrDefault("TagValues")
  valid_607758 = validateParameter(valid_607758, JArray, required = false,
                                 default = nil)
  if valid_607758 != nil:
    section.add "TagValues", valid_607758
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_607759: Call_PostDescribeClusters_607742; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns properties of provisioned clusters including general cluster properties, cluster database properties, maintenance and backup properties, and security and access properties. This operation supports pagination. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all clusters that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all clusters that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, clusters are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_607759.validator(path, query, header, formData, body)
  let scheme = call_607759.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_607759.url(scheme.get, call_607759.host, call_607759.base,
                         call_607759.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_607759, url, valid)

proc call*(call_607760: Call_PostDescribeClusters_607742; TagKeys: JsonNode = nil;
          ClusterIdentifier: string = ""; MaxRecords: int = 0; Marker: string = "";
          TagValues: JsonNode = nil; Action: string = "DescribeClusters";
          Version: string = "2012-12-01"): Recallable =
  ## postDescribeClusters
  ## <p>Returns properties of provisioned clusters including general cluster properties, cluster database properties, maintenance and backup properties, and security and access properties. This operation supports pagination. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all clusters that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all clusters that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, clusters are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching clusters that are associated with the specified key or keys. For example, suppose that you have clusters that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the clusters that have either or both of these tag keys associated with them.
  ##   ClusterIdentifier: string
  ##                    : <p>The unique identifier of a cluster whose properties you are requesting. This parameter is case sensitive.</p> <p>The default is that all clusters defined for an account are returned.</p>
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: string
  ##         : <p>An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusters</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <b>ClusterIdentifier</b> parameter or the <b>Marker</b> parameter, but not both. </p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching clusters that are associated with the specified tag value or values. For example, suppose that you have clusters that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the clusters that have either or both of these tag values associated with them.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_607761 = newJObject()
  var formData_607762 = newJObject()
  if TagKeys != nil:
    formData_607762.add "TagKeys", TagKeys
  add(formData_607762, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_607762, "MaxRecords", newJInt(MaxRecords))
  add(formData_607762, "Marker", newJString(Marker))
  if TagValues != nil:
    formData_607762.add "TagValues", TagValues
  add(query_607761, "Action", newJString(Action))
  add(query_607761, "Version", newJString(Version))
  result = call_607760.call(nil, query_607761, nil, formData_607762, nil)

var postDescribeClusters* = Call_PostDescribeClusters_607742(
    name: "postDescribeClusters", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusters",
    validator: validate_PostDescribeClusters_607743, base: "/",
    url: url_PostDescribeClusters_607744, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeClusters_607722 = ref object of OpenApiRestCall_605573
proc url_GetDescribeClusters_607724(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeClusters_607723(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## <p>Returns properties of provisioned clusters including general cluster properties, cluster database properties, maintenance and backup properties, and security and access properties. This operation supports pagination. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all clusters that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all clusters that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, clusters are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Marker: JString
  ##         : <p>An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusters</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <b>ClusterIdentifier</b> parameter or the <b>Marker</b> parameter, but not both. </p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching clusters that are associated with the specified key or keys. For example, suppose that you have clusters that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the clusters that have either or both of these tag keys associated with them.
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString
  ##                    : <p>The unique identifier of a cluster whose properties you are requesting. This parameter is case sensitive.</p> <p>The default is that all clusters defined for an account are returned.</p>
  ##   Version: JString (required)
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching clusters that are associated with the specified tag value or values. For example, suppose that you have clusters that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the clusters that have either or both of these tag values associated with them.
  section = newJObject()
  var valid_607725 = query.getOrDefault("Marker")
  valid_607725 = validateParameter(valid_607725, JString, required = false,
                                 default = nil)
  if valid_607725 != nil:
    section.add "Marker", valid_607725
  var valid_607726 = query.getOrDefault("TagKeys")
  valid_607726 = validateParameter(valid_607726, JArray, required = false,
                                 default = nil)
  if valid_607726 != nil:
    section.add "TagKeys", valid_607726
  var valid_607727 = query.getOrDefault("Action")
  valid_607727 = validateParameter(valid_607727, JString, required = true,
                                 default = newJString("DescribeClusters"))
  if valid_607727 != nil:
    section.add "Action", valid_607727
  var valid_607728 = query.getOrDefault("ClusterIdentifier")
  valid_607728 = validateParameter(valid_607728, JString, required = false,
                                 default = nil)
  if valid_607728 != nil:
    section.add "ClusterIdentifier", valid_607728
  var valid_607729 = query.getOrDefault("Version")
  valid_607729 = validateParameter(valid_607729, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_607729 != nil:
    section.add "Version", valid_607729
  var valid_607730 = query.getOrDefault("MaxRecords")
  valid_607730 = validateParameter(valid_607730, JInt, required = false, default = nil)
  if valid_607730 != nil:
    section.add "MaxRecords", valid_607730
  var valid_607731 = query.getOrDefault("TagValues")
  valid_607731 = validateParameter(valid_607731, JArray, required = false,
                                 default = nil)
  if valid_607731 != nil:
    section.add "TagValues", valid_607731
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_607732 = header.getOrDefault("X-Amz-Signature")
  valid_607732 = validateParameter(valid_607732, JString, required = false,
                                 default = nil)
  if valid_607732 != nil:
    section.add "X-Amz-Signature", valid_607732
  var valid_607733 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_607733 = validateParameter(valid_607733, JString, required = false,
                                 default = nil)
  if valid_607733 != nil:
    section.add "X-Amz-Content-Sha256", valid_607733
  var valid_607734 = header.getOrDefault("X-Amz-Date")
  valid_607734 = validateParameter(valid_607734, JString, required = false,
                                 default = nil)
  if valid_607734 != nil:
    section.add "X-Amz-Date", valid_607734
  var valid_607735 = header.getOrDefault("X-Amz-Credential")
  valid_607735 = validateParameter(valid_607735, JString, required = false,
                                 default = nil)
  if valid_607735 != nil:
    section.add "X-Amz-Credential", valid_607735
  var valid_607736 = header.getOrDefault("X-Amz-Security-Token")
  valid_607736 = validateParameter(valid_607736, JString, required = false,
                                 default = nil)
  if valid_607736 != nil:
    section.add "X-Amz-Security-Token", valid_607736
  var valid_607737 = header.getOrDefault("X-Amz-Algorithm")
  valid_607737 = validateParameter(valid_607737, JString, required = false,
                                 default = nil)
  if valid_607737 != nil:
    section.add "X-Amz-Algorithm", valid_607737
  var valid_607738 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_607738 = validateParameter(valid_607738, JString, required = false,
                                 default = nil)
  if valid_607738 != nil:
    section.add "X-Amz-SignedHeaders", valid_607738
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_607739: Call_GetDescribeClusters_607722; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns properties of provisioned clusters including general cluster properties, cluster database properties, maintenance and backup properties, and security and access properties. This operation supports pagination. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all clusters that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all clusters that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, clusters are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_607739.validator(path, query, header, formData, body)
  let scheme = call_607739.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_607739.url(scheme.get, call_607739.host, call_607739.base,
                         call_607739.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_607739, url, valid)

proc call*(call_607740: Call_GetDescribeClusters_607722; Marker: string = "";
          TagKeys: JsonNode = nil; Action: string = "DescribeClusters";
          ClusterIdentifier: string = ""; Version: string = "2012-12-01";
          MaxRecords: int = 0; TagValues: JsonNode = nil): Recallable =
  ## getDescribeClusters
  ## <p>Returns properties of provisioned clusters including general cluster properties, cluster database properties, maintenance and backup properties, and security and access properties. This operation supports pagination. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all clusters that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all clusters that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, clusters are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   Marker: string
  ##         : <p>An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusters</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <b>ClusterIdentifier</b> parameter or the <b>Marker</b> parameter, but not both. </p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching clusters that are associated with the specified key or keys. For example, suppose that you have clusters that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the clusters that have either or both of these tag keys associated with them.
  ##   Action: string (required)
  ##   ClusterIdentifier: string
  ##                    : <p>The unique identifier of a cluster whose properties you are requesting. This parameter is case sensitive.</p> <p>The default is that all clusters defined for an account are returned.</p>
  ##   Version: string (required)
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching clusters that are associated with the specified tag value or values. For example, suppose that you have clusters that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the clusters that have either or both of these tag values associated with them.
  var query_607741 = newJObject()
  add(query_607741, "Marker", newJString(Marker))
  if TagKeys != nil:
    query_607741.add "TagKeys", TagKeys
  add(query_607741, "Action", newJString(Action))
  add(query_607741, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_607741, "Version", newJString(Version))
  add(query_607741, "MaxRecords", newJInt(MaxRecords))
  if TagValues != nil:
    query_607741.add "TagValues", TagValues
  result = call_607740.call(nil, query_607741, nil, nil, nil)

var getDescribeClusters* = Call_GetDescribeClusters_607722(
    name: "getDescribeClusters", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusters",
    validator: validate_GetDescribeClusters_607723, base: "/",
    url: url_GetDescribeClusters_607724, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeDefaultClusterParameters_607781 = ref object of OpenApiRestCall_605573
proc url_PostDescribeDefaultClusterParameters_607783(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeDefaultClusterParameters_607782(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns a list of parameter settings for the specified parameter group family.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_607784 = query.getOrDefault("Action")
  valid_607784 = validateParameter(valid_607784, JString, required = true, default = newJString(
      "DescribeDefaultClusterParameters"))
  if valid_607784 != nil:
    section.add "Action", valid_607784
  var valid_607785 = query.getOrDefault("Version")
  valid_607785 = validateParameter(valid_607785, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_607785 != nil:
    section.add "Version", valid_607785
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_607786 = header.getOrDefault("X-Amz-Signature")
  valid_607786 = validateParameter(valid_607786, JString, required = false,
                                 default = nil)
  if valid_607786 != nil:
    section.add "X-Amz-Signature", valid_607786
  var valid_607787 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_607787 = validateParameter(valid_607787, JString, required = false,
                                 default = nil)
  if valid_607787 != nil:
    section.add "X-Amz-Content-Sha256", valid_607787
  var valid_607788 = header.getOrDefault("X-Amz-Date")
  valid_607788 = validateParameter(valid_607788, JString, required = false,
                                 default = nil)
  if valid_607788 != nil:
    section.add "X-Amz-Date", valid_607788
  var valid_607789 = header.getOrDefault("X-Amz-Credential")
  valid_607789 = validateParameter(valid_607789, JString, required = false,
                                 default = nil)
  if valid_607789 != nil:
    section.add "X-Amz-Credential", valid_607789
  var valid_607790 = header.getOrDefault("X-Amz-Security-Token")
  valid_607790 = validateParameter(valid_607790, JString, required = false,
                                 default = nil)
  if valid_607790 != nil:
    section.add "X-Amz-Security-Token", valid_607790
  var valid_607791 = header.getOrDefault("X-Amz-Algorithm")
  valid_607791 = validateParameter(valid_607791, JString, required = false,
                                 default = nil)
  if valid_607791 != nil:
    section.add "X-Amz-Algorithm", valid_607791
  var valid_607792 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_607792 = validateParameter(valid_607792, JString, required = false,
                                 default = nil)
  if valid_607792 != nil:
    section.add "X-Amz-SignedHeaders", valid_607792
  result.add "header", section
  ## parameters in `formData` object:
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeDefaultClusterParameters</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   ParameterGroupFamily: JString (required)
  ##                       : The name of the cluster parameter group family.
  section = newJObject()
  var valid_607793 = formData.getOrDefault("MaxRecords")
  valid_607793 = validateParameter(valid_607793, JInt, required = false, default = nil)
  if valid_607793 != nil:
    section.add "MaxRecords", valid_607793
  var valid_607794 = formData.getOrDefault("Marker")
  valid_607794 = validateParameter(valid_607794, JString, required = false,
                                 default = nil)
  if valid_607794 != nil:
    section.add "Marker", valid_607794
  assert formData != nil, "formData argument is necessary due to required `ParameterGroupFamily` field"
  var valid_607795 = formData.getOrDefault("ParameterGroupFamily")
  valid_607795 = validateParameter(valid_607795, JString, required = true,
                                 default = nil)
  if valid_607795 != nil:
    section.add "ParameterGroupFamily", valid_607795
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_607796: Call_PostDescribeDefaultClusterParameters_607781;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Returns a list of parameter settings for the specified parameter group family.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_607796.validator(path, query, header, formData, body)
  let scheme = call_607796.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_607796.url(scheme.get, call_607796.host, call_607796.base,
                         call_607796.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_607796, url, valid)

proc call*(call_607797: Call_PostDescribeDefaultClusterParameters_607781;
          ParameterGroupFamily: string; MaxRecords: int = 0; Marker: string = "";
          Action: string = "DescribeDefaultClusterParameters";
          Version: string = "2012-12-01"): Recallable =
  ## postDescribeDefaultClusterParameters
  ## <p>Returns a list of parameter settings for the specified parameter group family.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeDefaultClusterParameters</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   ParameterGroupFamily: string (required)
  ##                       : The name of the cluster parameter group family.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_607798 = newJObject()
  var formData_607799 = newJObject()
  add(formData_607799, "MaxRecords", newJInt(MaxRecords))
  add(formData_607799, "Marker", newJString(Marker))
  add(formData_607799, "ParameterGroupFamily", newJString(ParameterGroupFamily))
  add(query_607798, "Action", newJString(Action))
  add(query_607798, "Version", newJString(Version))
  result = call_607797.call(nil, query_607798, nil, formData_607799, nil)

var postDescribeDefaultClusterParameters* = Call_PostDescribeDefaultClusterParameters_607781(
    name: "postDescribeDefaultClusterParameters", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeDefaultClusterParameters",
    validator: validate_PostDescribeDefaultClusterParameters_607782, base: "/",
    url: url_PostDescribeDefaultClusterParameters_607783,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeDefaultClusterParameters_607763 = ref object of OpenApiRestCall_605573
proc url_GetDescribeDefaultClusterParameters_607765(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeDefaultClusterParameters_607764(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns a list of parameter settings for the specified parameter group family.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeDefaultClusterParameters</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   ParameterGroupFamily: JString (required)
  ##                       : The name of the cluster parameter group family.
  ##   Action: JString (required)
  ##   Version: JString (required)
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  section = newJObject()
  var valid_607766 = query.getOrDefault("Marker")
  valid_607766 = validateParameter(valid_607766, JString, required = false,
                                 default = nil)
  if valid_607766 != nil:
    section.add "Marker", valid_607766
  assert query != nil, "query argument is necessary due to required `ParameterGroupFamily` field"
  var valid_607767 = query.getOrDefault("ParameterGroupFamily")
  valid_607767 = validateParameter(valid_607767, JString, required = true,
                                 default = nil)
  if valid_607767 != nil:
    section.add "ParameterGroupFamily", valid_607767
  var valid_607768 = query.getOrDefault("Action")
  valid_607768 = validateParameter(valid_607768, JString, required = true, default = newJString(
      "DescribeDefaultClusterParameters"))
  if valid_607768 != nil:
    section.add "Action", valid_607768
  var valid_607769 = query.getOrDefault("Version")
  valid_607769 = validateParameter(valid_607769, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_607769 != nil:
    section.add "Version", valid_607769
  var valid_607770 = query.getOrDefault("MaxRecords")
  valid_607770 = validateParameter(valid_607770, JInt, required = false, default = nil)
  if valid_607770 != nil:
    section.add "MaxRecords", valid_607770
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_607771 = header.getOrDefault("X-Amz-Signature")
  valid_607771 = validateParameter(valid_607771, JString, required = false,
                                 default = nil)
  if valid_607771 != nil:
    section.add "X-Amz-Signature", valid_607771
  var valid_607772 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_607772 = validateParameter(valid_607772, JString, required = false,
                                 default = nil)
  if valid_607772 != nil:
    section.add "X-Amz-Content-Sha256", valid_607772
  var valid_607773 = header.getOrDefault("X-Amz-Date")
  valid_607773 = validateParameter(valid_607773, JString, required = false,
                                 default = nil)
  if valid_607773 != nil:
    section.add "X-Amz-Date", valid_607773
  var valid_607774 = header.getOrDefault("X-Amz-Credential")
  valid_607774 = validateParameter(valid_607774, JString, required = false,
                                 default = nil)
  if valid_607774 != nil:
    section.add "X-Amz-Credential", valid_607774
  var valid_607775 = header.getOrDefault("X-Amz-Security-Token")
  valid_607775 = validateParameter(valid_607775, JString, required = false,
                                 default = nil)
  if valid_607775 != nil:
    section.add "X-Amz-Security-Token", valid_607775
  var valid_607776 = header.getOrDefault("X-Amz-Algorithm")
  valid_607776 = validateParameter(valid_607776, JString, required = false,
                                 default = nil)
  if valid_607776 != nil:
    section.add "X-Amz-Algorithm", valid_607776
  var valid_607777 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_607777 = validateParameter(valid_607777, JString, required = false,
                                 default = nil)
  if valid_607777 != nil:
    section.add "X-Amz-SignedHeaders", valid_607777
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_607778: Call_GetDescribeDefaultClusterParameters_607763;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Returns a list of parameter settings for the specified parameter group family.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_607778.validator(path, query, header, formData, body)
  let scheme = call_607778.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_607778.url(scheme.get, call_607778.host, call_607778.base,
                         call_607778.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_607778, url, valid)

proc call*(call_607779: Call_GetDescribeDefaultClusterParameters_607763;
          ParameterGroupFamily: string; Marker: string = "";
          Action: string = "DescribeDefaultClusterParameters";
          Version: string = "2012-12-01"; MaxRecords: int = 0): Recallable =
  ## getDescribeDefaultClusterParameters
  ## <p>Returns a list of parameter settings for the specified parameter group family.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeDefaultClusterParameters</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   ParameterGroupFamily: string (required)
  ##                       : The name of the cluster parameter group family.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  var query_607780 = newJObject()
  add(query_607780, "Marker", newJString(Marker))
  add(query_607780, "ParameterGroupFamily", newJString(ParameterGroupFamily))
  add(query_607780, "Action", newJString(Action))
  add(query_607780, "Version", newJString(Version))
  add(query_607780, "MaxRecords", newJInt(MaxRecords))
  result = call_607779.call(nil, query_607780, nil, nil, nil)

var getDescribeDefaultClusterParameters* = Call_GetDescribeDefaultClusterParameters_607763(
    name: "getDescribeDefaultClusterParameters", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeDefaultClusterParameters",
    validator: validate_GetDescribeDefaultClusterParameters_607764, base: "/",
    url: url_GetDescribeDefaultClusterParameters_607765,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeEventCategories_607816 = ref object of OpenApiRestCall_605573
proc url_PostDescribeEventCategories_607818(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeEventCategories_607817(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Displays a list of event categories for all event source types, or for a specified source type. For a list of the event categories and source types, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-event-notifications.html">Amazon Redshift Event Notifications</a>.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_607819 = query.getOrDefault("Action")
  valid_607819 = validateParameter(valid_607819, JString, required = true, default = newJString(
      "DescribeEventCategories"))
  if valid_607819 != nil:
    section.add "Action", valid_607819
  var valid_607820 = query.getOrDefault("Version")
  valid_607820 = validateParameter(valid_607820, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_607820 != nil:
    section.add "Version", valid_607820
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_607821 = header.getOrDefault("X-Amz-Signature")
  valid_607821 = validateParameter(valid_607821, JString, required = false,
                                 default = nil)
  if valid_607821 != nil:
    section.add "X-Amz-Signature", valid_607821
  var valid_607822 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_607822 = validateParameter(valid_607822, JString, required = false,
                                 default = nil)
  if valid_607822 != nil:
    section.add "X-Amz-Content-Sha256", valid_607822
  var valid_607823 = header.getOrDefault("X-Amz-Date")
  valid_607823 = validateParameter(valid_607823, JString, required = false,
                                 default = nil)
  if valid_607823 != nil:
    section.add "X-Amz-Date", valid_607823
  var valid_607824 = header.getOrDefault("X-Amz-Credential")
  valid_607824 = validateParameter(valid_607824, JString, required = false,
                                 default = nil)
  if valid_607824 != nil:
    section.add "X-Amz-Credential", valid_607824
  var valid_607825 = header.getOrDefault("X-Amz-Security-Token")
  valid_607825 = validateParameter(valid_607825, JString, required = false,
                                 default = nil)
  if valid_607825 != nil:
    section.add "X-Amz-Security-Token", valid_607825
  var valid_607826 = header.getOrDefault("X-Amz-Algorithm")
  valid_607826 = validateParameter(valid_607826, JString, required = false,
                                 default = nil)
  if valid_607826 != nil:
    section.add "X-Amz-Algorithm", valid_607826
  var valid_607827 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_607827 = validateParameter(valid_607827, JString, required = false,
                                 default = nil)
  if valid_607827 != nil:
    section.add "X-Amz-SignedHeaders", valid_607827
  result.add "header", section
  ## parameters in `formData` object:
  ##   SourceType: JString
  ##             : <p>The source type, such as cluster or parameter group, to which the described event categories apply.</p> <p>Valid values: cluster, cluster-snapshot, cluster-parameter-group, cluster-security-group, and scheduled-action.</p>
  section = newJObject()
  var valid_607828 = formData.getOrDefault("SourceType")
  valid_607828 = validateParameter(valid_607828, JString, required = false,
                                 default = nil)
  if valid_607828 != nil:
    section.add "SourceType", valid_607828
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_607829: Call_PostDescribeEventCategories_607816; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Displays a list of event categories for all event source types, or for a specified source type. For a list of the event categories and source types, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-event-notifications.html">Amazon Redshift Event Notifications</a>.
  ## 
  let valid = call_607829.validator(path, query, header, formData, body)
  let scheme = call_607829.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_607829.url(scheme.get, call_607829.host, call_607829.base,
                         call_607829.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_607829, url, valid)

proc call*(call_607830: Call_PostDescribeEventCategories_607816;
          SourceType: string = ""; Action: string = "DescribeEventCategories";
          Version: string = "2012-12-01"): Recallable =
  ## postDescribeEventCategories
  ## Displays a list of event categories for all event source types, or for a specified source type. For a list of the event categories and source types, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-event-notifications.html">Amazon Redshift Event Notifications</a>.
  ##   SourceType: string
  ##             : <p>The source type, such as cluster or parameter group, to which the described event categories apply.</p> <p>Valid values: cluster, cluster-snapshot, cluster-parameter-group, cluster-security-group, and scheduled-action.</p>
  ##   Action: string (required)
  ##   Version: string (required)
  var query_607831 = newJObject()
  var formData_607832 = newJObject()
  add(formData_607832, "SourceType", newJString(SourceType))
  add(query_607831, "Action", newJString(Action))
  add(query_607831, "Version", newJString(Version))
  result = call_607830.call(nil, query_607831, nil, formData_607832, nil)

var postDescribeEventCategories* = Call_PostDescribeEventCategories_607816(
    name: "postDescribeEventCategories", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeEventCategories",
    validator: validate_PostDescribeEventCategories_607817, base: "/",
    url: url_PostDescribeEventCategories_607818,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeEventCategories_607800 = ref object of OpenApiRestCall_605573
proc url_GetDescribeEventCategories_607802(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeEventCategories_607801(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Displays a list of event categories for all event source types, or for a specified source type. For a list of the event categories and source types, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-event-notifications.html">Amazon Redshift Event Notifications</a>.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   SourceType: JString
  ##             : <p>The source type, such as cluster or parameter group, to which the described event categories apply.</p> <p>Valid values: cluster, cluster-snapshot, cluster-parameter-group, cluster-security-group, and scheduled-action.</p>
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_607803 = query.getOrDefault("SourceType")
  valid_607803 = validateParameter(valid_607803, JString, required = false,
                                 default = nil)
  if valid_607803 != nil:
    section.add "SourceType", valid_607803
  var valid_607804 = query.getOrDefault("Action")
  valid_607804 = validateParameter(valid_607804, JString, required = true, default = newJString(
      "DescribeEventCategories"))
  if valid_607804 != nil:
    section.add "Action", valid_607804
  var valid_607805 = query.getOrDefault("Version")
  valid_607805 = validateParameter(valid_607805, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_607805 != nil:
    section.add "Version", valid_607805
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_607806 = header.getOrDefault("X-Amz-Signature")
  valid_607806 = validateParameter(valid_607806, JString, required = false,
                                 default = nil)
  if valid_607806 != nil:
    section.add "X-Amz-Signature", valid_607806
  var valid_607807 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_607807 = validateParameter(valid_607807, JString, required = false,
                                 default = nil)
  if valid_607807 != nil:
    section.add "X-Amz-Content-Sha256", valid_607807
  var valid_607808 = header.getOrDefault("X-Amz-Date")
  valid_607808 = validateParameter(valid_607808, JString, required = false,
                                 default = nil)
  if valid_607808 != nil:
    section.add "X-Amz-Date", valid_607808
  var valid_607809 = header.getOrDefault("X-Amz-Credential")
  valid_607809 = validateParameter(valid_607809, JString, required = false,
                                 default = nil)
  if valid_607809 != nil:
    section.add "X-Amz-Credential", valid_607809
  var valid_607810 = header.getOrDefault("X-Amz-Security-Token")
  valid_607810 = validateParameter(valid_607810, JString, required = false,
                                 default = nil)
  if valid_607810 != nil:
    section.add "X-Amz-Security-Token", valid_607810
  var valid_607811 = header.getOrDefault("X-Amz-Algorithm")
  valid_607811 = validateParameter(valid_607811, JString, required = false,
                                 default = nil)
  if valid_607811 != nil:
    section.add "X-Amz-Algorithm", valid_607811
  var valid_607812 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_607812 = validateParameter(valid_607812, JString, required = false,
                                 default = nil)
  if valid_607812 != nil:
    section.add "X-Amz-SignedHeaders", valid_607812
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_607813: Call_GetDescribeEventCategories_607800; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Displays a list of event categories for all event source types, or for a specified source type. For a list of the event categories and source types, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-event-notifications.html">Amazon Redshift Event Notifications</a>.
  ## 
  let valid = call_607813.validator(path, query, header, formData, body)
  let scheme = call_607813.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_607813.url(scheme.get, call_607813.host, call_607813.base,
                         call_607813.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_607813, url, valid)

proc call*(call_607814: Call_GetDescribeEventCategories_607800;
          SourceType: string = ""; Action: string = "DescribeEventCategories";
          Version: string = "2012-12-01"): Recallable =
  ## getDescribeEventCategories
  ## Displays a list of event categories for all event source types, or for a specified source type. For a list of the event categories and source types, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-event-notifications.html">Amazon Redshift Event Notifications</a>.
  ##   SourceType: string
  ##             : <p>The source type, such as cluster or parameter group, to which the described event categories apply.</p> <p>Valid values: cluster, cluster-snapshot, cluster-parameter-group, cluster-security-group, and scheduled-action.</p>
  ##   Action: string (required)
  ##   Version: string (required)
  var query_607815 = newJObject()
  add(query_607815, "SourceType", newJString(SourceType))
  add(query_607815, "Action", newJString(Action))
  add(query_607815, "Version", newJString(Version))
  result = call_607814.call(nil, query_607815, nil, nil, nil)

var getDescribeEventCategories* = Call_GetDescribeEventCategories_607800(
    name: "getDescribeEventCategories", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeEventCategories",
    validator: validate_GetDescribeEventCategories_607801, base: "/",
    url: url_GetDescribeEventCategories_607802,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeEventSubscriptions_607853 = ref object of OpenApiRestCall_605573
proc url_PostDescribeEventSubscriptions_607855(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeEventSubscriptions_607854(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Lists descriptions of all the Amazon Redshift event notification subscriptions for a customer account. If you specify a subscription name, lists the description for that subscription.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all event notification subscriptions that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all subscriptions that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, subscriptions are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_607856 = query.getOrDefault("Action")
  valid_607856 = validateParameter(valid_607856, JString, required = true, default = newJString(
      "DescribeEventSubscriptions"))
  if valid_607856 != nil:
    section.add "Action", valid_607856
  var valid_607857 = query.getOrDefault("Version")
  valid_607857 = validateParameter(valid_607857, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_607857 != nil:
    section.add "Version", valid_607857
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_607858 = header.getOrDefault("X-Amz-Signature")
  valid_607858 = validateParameter(valid_607858, JString, required = false,
                                 default = nil)
  if valid_607858 != nil:
    section.add "X-Amz-Signature", valid_607858
  var valid_607859 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_607859 = validateParameter(valid_607859, JString, required = false,
                                 default = nil)
  if valid_607859 != nil:
    section.add "X-Amz-Content-Sha256", valid_607859
  var valid_607860 = header.getOrDefault("X-Amz-Date")
  valid_607860 = validateParameter(valid_607860, JString, required = false,
                                 default = nil)
  if valid_607860 != nil:
    section.add "X-Amz-Date", valid_607860
  var valid_607861 = header.getOrDefault("X-Amz-Credential")
  valid_607861 = validateParameter(valid_607861, JString, required = false,
                                 default = nil)
  if valid_607861 != nil:
    section.add "X-Amz-Credential", valid_607861
  var valid_607862 = header.getOrDefault("X-Amz-Security-Token")
  valid_607862 = validateParameter(valid_607862, JString, required = false,
                                 default = nil)
  if valid_607862 != nil:
    section.add "X-Amz-Security-Token", valid_607862
  var valid_607863 = header.getOrDefault("X-Amz-Algorithm")
  valid_607863 = validateParameter(valid_607863, JString, required = false,
                                 default = nil)
  if valid_607863 != nil:
    section.add "X-Amz-Algorithm", valid_607863
  var valid_607864 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_607864 = validateParameter(valid_607864, JString, required = false,
                                 default = nil)
  if valid_607864 != nil:
    section.add "X-Amz-SignedHeaders", valid_607864
  result.add "header", section
  ## parameters in `formData` object:
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching event notification subscriptions that are associated with the specified key or keys. For example, suppose that you have subscriptions that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the subscriptions that have either or both of these tag keys associated with them.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a DescribeEventSubscriptions request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   SubscriptionName: JString
  ##                   : The name of the Amazon Redshift event notification subscription to be described.
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching event notification subscriptions that are associated with the specified tag value or values. For example, suppose that you have subscriptions that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the subscriptions that have either or both of these tag values associated with them.
  section = newJObject()
  var valid_607865 = formData.getOrDefault("TagKeys")
  valid_607865 = validateParameter(valid_607865, JArray, required = false,
                                 default = nil)
  if valid_607865 != nil:
    section.add "TagKeys", valid_607865
  var valid_607866 = formData.getOrDefault("MaxRecords")
  valid_607866 = validateParameter(valid_607866, JInt, required = false, default = nil)
  if valid_607866 != nil:
    section.add "MaxRecords", valid_607866
  var valid_607867 = formData.getOrDefault("Marker")
  valid_607867 = validateParameter(valid_607867, JString, required = false,
                                 default = nil)
  if valid_607867 != nil:
    section.add "Marker", valid_607867
  var valid_607868 = formData.getOrDefault("SubscriptionName")
  valid_607868 = validateParameter(valid_607868, JString, required = false,
                                 default = nil)
  if valid_607868 != nil:
    section.add "SubscriptionName", valid_607868
  var valid_607869 = formData.getOrDefault("TagValues")
  valid_607869 = validateParameter(valid_607869, JArray, required = false,
                                 default = nil)
  if valid_607869 != nil:
    section.add "TagValues", valid_607869
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_607870: Call_PostDescribeEventSubscriptions_607853; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Lists descriptions of all the Amazon Redshift event notification subscriptions for a customer account. If you specify a subscription name, lists the description for that subscription.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all event notification subscriptions that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all subscriptions that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, subscriptions are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_607870.validator(path, query, header, formData, body)
  let scheme = call_607870.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_607870.url(scheme.get, call_607870.host, call_607870.base,
                         call_607870.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_607870, url, valid)

proc call*(call_607871: Call_PostDescribeEventSubscriptions_607853;
          TagKeys: JsonNode = nil; MaxRecords: int = 0; Marker: string = "";
          SubscriptionName: string = ""; TagValues: JsonNode = nil;
          Action: string = "DescribeEventSubscriptions";
          Version: string = "2012-12-01"): Recallable =
  ## postDescribeEventSubscriptions
  ## <p>Lists descriptions of all the Amazon Redshift event notification subscriptions for a customer account. If you specify a subscription name, lists the description for that subscription.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all event notification subscriptions that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all subscriptions that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, subscriptions are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching event notification subscriptions that are associated with the specified key or keys. For example, suppose that you have subscriptions that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the subscriptions that have either or both of these tag keys associated with them.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a DescribeEventSubscriptions request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   SubscriptionName: string
  ##                   : The name of the Amazon Redshift event notification subscription to be described.
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching event notification subscriptions that are associated with the specified tag value or values. For example, suppose that you have subscriptions that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the subscriptions that have either or both of these tag values associated with them.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_607872 = newJObject()
  var formData_607873 = newJObject()
  if TagKeys != nil:
    formData_607873.add "TagKeys", TagKeys
  add(formData_607873, "MaxRecords", newJInt(MaxRecords))
  add(formData_607873, "Marker", newJString(Marker))
  add(formData_607873, "SubscriptionName", newJString(SubscriptionName))
  if TagValues != nil:
    formData_607873.add "TagValues", TagValues
  add(query_607872, "Action", newJString(Action))
  add(query_607872, "Version", newJString(Version))
  result = call_607871.call(nil, query_607872, nil, formData_607873, nil)

var postDescribeEventSubscriptions* = Call_PostDescribeEventSubscriptions_607853(
    name: "postDescribeEventSubscriptions", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeEventSubscriptions",
    validator: validate_PostDescribeEventSubscriptions_607854, base: "/",
    url: url_PostDescribeEventSubscriptions_607855,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeEventSubscriptions_607833 = ref object of OpenApiRestCall_605573
proc url_GetDescribeEventSubscriptions_607835(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeEventSubscriptions_607834(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Lists descriptions of all the Amazon Redshift event notification subscriptions for a customer account. If you specify a subscription name, lists the description for that subscription.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all event notification subscriptions that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all subscriptions that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, subscriptions are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a DescribeEventSubscriptions request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching event notification subscriptions that are associated with the specified key or keys. For example, suppose that you have subscriptions that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the subscriptions that have either or both of these tag keys associated with them.
  ##   SubscriptionName: JString
  ##                   : The name of the Amazon Redshift event notification subscription to be described.
  ##   Action: JString (required)
  ##   Version: JString (required)
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching event notification subscriptions that are associated with the specified tag value or values. For example, suppose that you have subscriptions that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the subscriptions that have either or both of these tag values associated with them.
  section = newJObject()
  var valid_607836 = query.getOrDefault("Marker")
  valid_607836 = validateParameter(valid_607836, JString, required = false,
                                 default = nil)
  if valid_607836 != nil:
    section.add "Marker", valid_607836
  var valid_607837 = query.getOrDefault("TagKeys")
  valid_607837 = validateParameter(valid_607837, JArray, required = false,
                                 default = nil)
  if valid_607837 != nil:
    section.add "TagKeys", valid_607837
  var valid_607838 = query.getOrDefault("SubscriptionName")
  valid_607838 = validateParameter(valid_607838, JString, required = false,
                                 default = nil)
  if valid_607838 != nil:
    section.add "SubscriptionName", valid_607838
  var valid_607839 = query.getOrDefault("Action")
  valid_607839 = validateParameter(valid_607839, JString, required = true, default = newJString(
      "DescribeEventSubscriptions"))
  if valid_607839 != nil:
    section.add "Action", valid_607839
  var valid_607840 = query.getOrDefault("Version")
  valid_607840 = validateParameter(valid_607840, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_607840 != nil:
    section.add "Version", valid_607840
  var valid_607841 = query.getOrDefault("MaxRecords")
  valid_607841 = validateParameter(valid_607841, JInt, required = false, default = nil)
  if valid_607841 != nil:
    section.add "MaxRecords", valid_607841
  var valid_607842 = query.getOrDefault("TagValues")
  valid_607842 = validateParameter(valid_607842, JArray, required = false,
                                 default = nil)
  if valid_607842 != nil:
    section.add "TagValues", valid_607842
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_607843 = header.getOrDefault("X-Amz-Signature")
  valid_607843 = validateParameter(valid_607843, JString, required = false,
                                 default = nil)
  if valid_607843 != nil:
    section.add "X-Amz-Signature", valid_607843
  var valid_607844 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_607844 = validateParameter(valid_607844, JString, required = false,
                                 default = nil)
  if valid_607844 != nil:
    section.add "X-Amz-Content-Sha256", valid_607844
  var valid_607845 = header.getOrDefault("X-Amz-Date")
  valid_607845 = validateParameter(valid_607845, JString, required = false,
                                 default = nil)
  if valid_607845 != nil:
    section.add "X-Amz-Date", valid_607845
  var valid_607846 = header.getOrDefault("X-Amz-Credential")
  valid_607846 = validateParameter(valid_607846, JString, required = false,
                                 default = nil)
  if valid_607846 != nil:
    section.add "X-Amz-Credential", valid_607846
  var valid_607847 = header.getOrDefault("X-Amz-Security-Token")
  valid_607847 = validateParameter(valid_607847, JString, required = false,
                                 default = nil)
  if valid_607847 != nil:
    section.add "X-Amz-Security-Token", valid_607847
  var valid_607848 = header.getOrDefault("X-Amz-Algorithm")
  valid_607848 = validateParameter(valid_607848, JString, required = false,
                                 default = nil)
  if valid_607848 != nil:
    section.add "X-Amz-Algorithm", valid_607848
  var valid_607849 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_607849 = validateParameter(valid_607849, JString, required = false,
                                 default = nil)
  if valid_607849 != nil:
    section.add "X-Amz-SignedHeaders", valid_607849
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_607850: Call_GetDescribeEventSubscriptions_607833; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Lists descriptions of all the Amazon Redshift event notification subscriptions for a customer account. If you specify a subscription name, lists the description for that subscription.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all event notification subscriptions that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all subscriptions that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, subscriptions are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_607850.validator(path, query, header, formData, body)
  let scheme = call_607850.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_607850.url(scheme.get, call_607850.host, call_607850.base,
                         call_607850.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_607850, url, valid)

proc call*(call_607851: Call_GetDescribeEventSubscriptions_607833;
          Marker: string = ""; TagKeys: JsonNode = nil; SubscriptionName: string = "";
          Action: string = "DescribeEventSubscriptions";
          Version: string = "2012-12-01"; MaxRecords: int = 0; TagValues: JsonNode = nil): Recallable =
  ## getDescribeEventSubscriptions
  ## <p>Lists descriptions of all the Amazon Redshift event notification subscriptions for a customer account. If you specify a subscription name, lists the description for that subscription.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all event notification subscriptions that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all subscriptions that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, subscriptions are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a DescribeEventSubscriptions request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching event notification subscriptions that are associated with the specified key or keys. For example, suppose that you have subscriptions that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the subscriptions that have either or both of these tag keys associated with them.
  ##   SubscriptionName: string
  ##                   : The name of the Amazon Redshift event notification subscription to be described.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching event notification subscriptions that are associated with the specified tag value or values. For example, suppose that you have subscriptions that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the subscriptions that have either or both of these tag values associated with them.
  var query_607852 = newJObject()
  add(query_607852, "Marker", newJString(Marker))
  if TagKeys != nil:
    query_607852.add "TagKeys", TagKeys
  add(query_607852, "SubscriptionName", newJString(SubscriptionName))
  add(query_607852, "Action", newJString(Action))
  add(query_607852, "Version", newJString(Version))
  add(query_607852, "MaxRecords", newJInt(MaxRecords))
  if TagValues != nil:
    query_607852.add "TagValues", TagValues
  result = call_607851.call(nil, query_607852, nil, nil, nil)

var getDescribeEventSubscriptions* = Call_GetDescribeEventSubscriptions_607833(
    name: "getDescribeEventSubscriptions", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeEventSubscriptions",
    validator: validate_GetDescribeEventSubscriptions_607834, base: "/",
    url: url_GetDescribeEventSubscriptions_607835,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeEvents_607896 = ref object of OpenApiRestCall_605573
proc url_PostDescribeEvents_607898(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeEvents_607897(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Returns events related to clusters, security groups, snapshots, and parameter groups for the past 14 days. Events specific to a particular cluster, security group, snapshot or parameter group can be obtained by providing the name as a parameter. By default, the past hour of events are returned.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_607899 = query.getOrDefault("Action")
  valid_607899 = validateParameter(valid_607899, JString, required = true,
                                 default = newJString("DescribeEvents"))
  if valid_607899 != nil:
    section.add "Action", valid_607899
  var valid_607900 = query.getOrDefault("Version")
  valid_607900 = validateParameter(valid_607900, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_607900 != nil:
    section.add "Version", valid_607900
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_607901 = header.getOrDefault("X-Amz-Signature")
  valid_607901 = validateParameter(valid_607901, JString, required = false,
                                 default = nil)
  if valid_607901 != nil:
    section.add "X-Amz-Signature", valid_607901
  var valid_607902 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_607902 = validateParameter(valid_607902, JString, required = false,
                                 default = nil)
  if valid_607902 != nil:
    section.add "X-Amz-Content-Sha256", valid_607902
  var valid_607903 = header.getOrDefault("X-Amz-Date")
  valid_607903 = validateParameter(valid_607903, JString, required = false,
                                 default = nil)
  if valid_607903 != nil:
    section.add "X-Amz-Date", valid_607903
  var valid_607904 = header.getOrDefault("X-Amz-Credential")
  valid_607904 = validateParameter(valid_607904, JString, required = false,
                                 default = nil)
  if valid_607904 != nil:
    section.add "X-Amz-Credential", valid_607904
  var valid_607905 = header.getOrDefault("X-Amz-Security-Token")
  valid_607905 = validateParameter(valid_607905, JString, required = false,
                                 default = nil)
  if valid_607905 != nil:
    section.add "X-Amz-Security-Token", valid_607905
  var valid_607906 = header.getOrDefault("X-Amz-Algorithm")
  valid_607906 = validateParameter(valid_607906, JString, required = false,
                                 default = nil)
  if valid_607906 != nil:
    section.add "X-Amz-Algorithm", valid_607906
  var valid_607907 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_607907 = validateParameter(valid_607907, JString, required = false,
                                 default = nil)
  if valid_607907 != nil:
    section.add "X-Amz-SignedHeaders", valid_607907
  result.add "header", section
  ## parameters in `formData` object:
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeEvents</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   SourceIdentifier: JString
  ##                   : <p>The identifier of the event source for which events will be returned. If this parameter is not specified, then all sources are included in the response.</p> <p>Constraints:</p> <p>If <i>SourceIdentifier</i> is supplied, <i>SourceType</i> must also be provided.</p> <ul> <li> <p>Specify a cluster identifier when <i>SourceType</i> is <code>cluster</code>.</p> </li> <li> <p>Specify a cluster security group name when <i>SourceType</i> is <code>cluster-security-group</code>.</p> </li> <li> <p>Specify a cluster parameter group name when <i>SourceType</i> is <code>cluster-parameter-group</code>.</p> </li> <li> <p>Specify a cluster snapshot identifier when <i>SourceType</i> is <code>cluster-snapshot</code>.</p> </li> </ul>
  ##   SourceType: JString
  ##             : <p>The event source to retrieve events for. If no value is specified, all events are returned.</p> <p>Constraints:</p> <p>If <i>SourceType</i> is supplied, <i>SourceIdentifier</i> must also be provided.</p> <ul> <li> <p>Specify <code>cluster</code> when <i>SourceIdentifier</i> is a cluster identifier.</p> </li> <li> <p>Specify <code>cluster-security-group</code> when <i>SourceIdentifier</i> is a cluster security group name.</p> </li> <li> <p>Specify <code>cluster-parameter-group</code> when <i>SourceIdentifier</i> is a cluster parameter group name.</p> </li> <li> <p>Specify <code>cluster-snapshot</code> when <i>SourceIdentifier</i> is a cluster snapshot identifier.</p> </li> </ul>
  ##   Duration: JInt
  ##           : <p>The number of minutes prior to the time of the request for which to retrieve events. For example, if the request is sent at 18:00 and you specify a duration of 60, then only events which have occurred after 17:00 will be returned.</p> <p>Default: <code>60</code> </p>
  ##   EndTime: JString
  ##          : <p>The end of the time interval for which to retrieve events, specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2009-07-08T18:00Z</code> </p>
  ##   StartTime: JString
  ##            : <p>The beginning of the time interval to retrieve events for, specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2009-07-08T18:00Z</code> </p>
  section = newJObject()
  var valid_607908 = formData.getOrDefault("MaxRecords")
  valid_607908 = validateParameter(valid_607908, JInt, required = false, default = nil)
  if valid_607908 != nil:
    section.add "MaxRecords", valid_607908
  var valid_607909 = formData.getOrDefault("Marker")
  valid_607909 = validateParameter(valid_607909, JString, required = false,
                                 default = nil)
  if valid_607909 != nil:
    section.add "Marker", valid_607909
  var valid_607910 = formData.getOrDefault("SourceIdentifier")
  valid_607910 = validateParameter(valid_607910, JString, required = false,
                                 default = nil)
  if valid_607910 != nil:
    section.add "SourceIdentifier", valid_607910
  var valid_607911 = formData.getOrDefault("SourceType")
  valid_607911 = validateParameter(valid_607911, JString, required = false,
                                 default = newJString("cluster"))
  if valid_607911 != nil:
    section.add "SourceType", valid_607911
  var valid_607912 = formData.getOrDefault("Duration")
  valid_607912 = validateParameter(valid_607912, JInt, required = false, default = nil)
  if valid_607912 != nil:
    section.add "Duration", valid_607912
  var valid_607913 = formData.getOrDefault("EndTime")
  valid_607913 = validateParameter(valid_607913, JString, required = false,
                                 default = nil)
  if valid_607913 != nil:
    section.add "EndTime", valid_607913
  var valid_607914 = formData.getOrDefault("StartTime")
  valid_607914 = validateParameter(valid_607914, JString, required = false,
                                 default = nil)
  if valid_607914 != nil:
    section.add "StartTime", valid_607914
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_607915: Call_PostDescribeEvents_607896; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns events related to clusters, security groups, snapshots, and parameter groups for the past 14 days. Events specific to a particular cluster, security group, snapshot or parameter group can be obtained by providing the name as a parameter. By default, the past hour of events are returned.
  ## 
  let valid = call_607915.validator(path, query, header, formData, body)
  let scheme = call_607915.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_607915.url(scheme.get, call_607915.host, call_607915.base,
                         call_607915.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_607915, url, valid)

proc call*(call_607916: Call_PostDescribeEvents_607896; MaxRecords: int = 0;
          Marker: string = ""; SourceIdentifier: string = "";
          SourceType: string = "cluster"; Duration: int = 0; EndTime: string = "";
          StartTime: string = ""; Action: string = "DescribeEvents";
          Version: string = "2012-12-01"): Recallable =
  ## postDescribeEvents
  ## Returns events related to clusters, security groups, snapshots, and parameter groups for the past 14 days. Events specific to a particular cluster, security group, snapshot or parameter group can be obtained by providing the name as a parameter. By default, the past hour of events are returned.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeEvents</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   SourceIdentifier: string
  ##                   : <p>The identifier of the event source for which events will be returned. If this parameter is not specified, then all sources are included in the response.</p> <p>Constraints:</p> <p>If <i>SourceIdentifier</i> is supplied, <i>SourceType</i> must also be provided.</p> <ul> <li> <p>Specify a cluster identifier when <i>SourceType</i> is <code>cluster</code>.</p> </li> <li> <p>Specify a cluster security group name when <i>SourceType</i> is <code>cluster-security-group</code>.</p> </li> <li> <p>Specify a cluster parameter group name when <i>SourceType</i> is <code>cluster-parameter-group</code>.</p> </li> <li> <p>Specify a cluster snapshot identifier when <i>SourceType</i> is <code>cluster-snapshot</code>.</p> </li> </ul>
  ##   SourceType: string
  ##             : <p>The event source to retrieve events for. If no value is specified, all events are returned.</p> <p>Constraints:</p> <p>If <i>SourceType</i> is supplied, <i>SourceIdentifier</i> must also be provided.</p> <ul> <li> <p>Specify <code>cluster</code> when <i>SourceIdentifier</i> is a cluster identifier.</p> </li> <li> <p>Specify <code>cluster-security-group</code> when <i>SourceIdentifier</i> is a cluster security group name.</p> </li> <li> <p>Specify <code>cluster-parameter-group</code> when <i>SourceIdentifier</i> is a cluster parameter group name.</p> </li> <li> <p>Specify <code>cluster-snapshot</code> when <i>SourceIdentifier</i> is a cluster snapshot identifier.</p> </li> </ul>
  ##   Duration: int
  ##           : <p>The number of minutes prior to the time of the request for which to retrieve events. For example, if the request is sent at 18:00 and you specify a duration of 60, then only events which have occurred after 17:00 will be returned.</p> <p>Default: <code>60</code> </p>
  ##   EndTime: string
  ##          : <p>The end of the time interval for which to retrieve events, specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2009-07-08T18:00Z</code> </p>
  ##   StartTime: string
  ##            : <p>The beginning of the time interval to retrieve events for, specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2009-07-08T18:00Z</code> </p>
  ##   Action: string (required)
  ##   Version: string (required)
  var query_607917 = newJObject()
  var formData_607918 = newJObject()
  add(formData_607918, "MaxRecords", newJInt(MaxRecords))
  add(formData_607918, "Marker", newJString(Marker))
  add(formData_607918, "SourceIdentifier", newJString(SourceIdentifier))
  add(formData_607918, "SourceType", newJString(SourceType))
  add(formData_607918, "Duration", newJInt(Duration))
  add(formData_607918, "EndTime", newJString(EndTime))
  add(formData_607918, "StartTime", newJString(StartTime))
  add(query_607917, "Action", newJString(Action))
  add(query_607917, "Version", newJString(Version))
  result = call_607916.call(nil, query_607917, nil, formData_607918, nil)

var postDescribeEvents* = Call_PostDescribeEvents_607896(
    name: "postDescribeEvents", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeEvents",
    validator: validate_PostDescribeEvents_607897, base: "/",
    url: url_PostDescribeEvents_607898, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeEvents_607874 = ref object of OpenApiRestCall_605573
proc url_GetDescribeEvents_607876(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeEvents_607875(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## Returns events related to clusters, security groups, snapshots, and parameter groups for the past 14 days. Events specific to a particular cluster, security group, snapshot or parameter group can be obtained by providing the name as a parameter. By default, the past hour of events are returned.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeEvents</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   SourceType: JString
  ##             : <p>The event source to retrieve events for. If no value is specified, all events are returned.</p> <p>Constraints:</p> <p>If <i>SourceType</i> is supplied, <i>SourceIdentifier</i> must also be provided.</p> <ul> <li> <p>Specify <code>cluster</code> when <i>SourceIdentifier</i> is a cluster identifier.</p> </li> <li> <p>Specify <code>cluster-security-group</code> when <i>SourceIdentifier</i> is a cluster security group name.</p> </li> <li> <p>Specify <code>cluster-parameter-group</code> when <i>SourceIdentifier</i> is a cluster parameter group name.</p> </li> <li> <p>Specify <code>cluster-snapshot</code> when <i>SourceIdentifier</i> is a cluster snapshot identifier.</p> </li> </ul>
  ##   SourceIdentifier: JString
  ##                   : <p>The identifier of the event source for which events will be returned. If this parameter is not specified, then all sources are included in the response.</p> <p>Constraints:</p> <p>If <i>SourceIdentifier</i> is supplied, <i>SourceType</i> must also be provided.</p> <ul> <li> <p>Specify a cluster identifier when <i>SourceType</i> is <code>cluster</code>.</p> </li> <li> <p>Specify a cluster security group name when <i>SourceType</i> is <code>cluster-security-group</code>.</p> </li> <li> <p>Specify a cluster parameter group name when <i>SourceType</i> is <code>cluster-parameter-group</code>.</p> </li> <li> <p>Specify a cluster snapshot identifier when <i>SourceType</i> is <code>cluster-snapshot</code>.</p> </li> </ul>
  ##   Action: JString (required)
  ##   StartTime: JString
  ##            : <p>The beginning of the time interval to retrieve events for, specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2009-07-08T18:00Z</code> </p>
  ##   Duration: JInt
  ##           : <p>The number of minutes prior to the time of the request for which to retrieve events. For example, if the request is sent at 18:00 and you specify a duration of 60, then only events which have occurred after 17:00 will be returned.</p> <p>Default: <code>60</code> </p>
  ##   EndTime: JString
  ##          : <p>The end of the time interval for which to retrieve events, specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2009-07-08T18:00Z</code> </p>
  ##   Version: JString (required)
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  section = newJObject()
  var valid_607877 = query.getOrDefault("Marker")
  valid_607877 = validateParameter(valid_607877, JString, required = false,
                                 default = nil)
  if valid_607877 != nil:
    section.add "Marker", valid_607877
  var valid_607878 = query.getOrDefault("SourceType")
  valid_607878 = validateParameter(valid_607878, JString, required = false,
                                 default = newJString("cluster"))
  if valid_607878 != nil:
    section.add "SourceType", valid_607878
  var valid_607879 = query.getOrDefault("SourceIdentifier")
  valid_607879 = validateParameter(valid_607879, JString, required = false,
                                 default = nil)
  if valid_607879 != nil:
    section.add "SourceIdentifier", valid_607879
  var valid_607880 = query.getOrDefault("Action")
  valid_607880 = validateParameter(valid_607880, JString, required = true,
                                 default = newJString("DescribeEvents"))
  if valid_607880 != nil:
    section.add "Action", valid_607880
  var valid_607881 = query.getOrDefault("StartTime")
  valid_607881 = validateParameter(valid_607881, JString, required = false,
                                 default = nil)
  if valid_607881 != nil:
    section.add "StartTime", valid_607881
  var valid_607882 = query.getOrDefault("Duration")
  valid_607882 = validateParameter(valid_607882, JInt, required = false, default = nil)
  if valid_607882 != nil:
    section.add "Duration", valid_607882
  var valid_607883 = query.getOrDefault("EndTime")
  valid_607883 = validateParameter(valid_607883, JString, required = false,
                                 default = nil)
  if valid_607883 != nil:
    section.add "EndTime", valid_607883
  var valid_607884 = query.getOrDefault("Version")
  valid_607884 = validateParameter(valid_607884, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_607884 != nil:
    section.add "Version", valid_607884
  var valid_607885 = query.getOrDefault("MaxRecords")
  valid_607885 = validateParameter(valid_607885, JInt, required = false, default = nil)
  if valid_607885 != nil:
    section.add "MaxRecords", valid_607885
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_607886 = header.getOrDefault("X-Amz-Signature")
  valid_607886 = validateParameter(valid_607886, JString, required = false,
                                 default = nil)
  if valid_607886 != nil:
    section.add "X-Amz-Signature", valid_607886
  var valid_607887 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_607887 = validateParameter(valid_607887, JString, required = false,
                                 default = nil)
  if valid_607887 != nil:
    section.add "X-Amz-Content-Sha256", valid_607887
  var valid_607888 = header.getOrDefault("X-Amz-Date")
  valid_607888 = validateParameter(valid_607888, JString, required = false,
                                 default = nil)
  if valid_607888 != nil:
    section.add "X-Amz-Date", valid_607888
  var valid_607889 = header.getOrDefault("X-Amz-Credential")
  valid_607889 = validateParameter(valid_607889, JString, required = false,
                                 default = nil)
  if valid_607889 != nil:
    section.add "X-Amz-Credential", valid_607889
  var valid_607890 = header.getOrDefault("X-Amz-Security-Token")
  valid_607890 = validateParameter(valid_607890, JString, required = false,
                                 default = nil)
  if valid_607890 != nil:
    section.add "X-Amz-Security-Token", valid_607890
  var valid_607891 = header.getOrDefault("X-Amz-Algorithm")
  valid_607891 = validateParameter(valid_607891, JString, required = false,
                                 default = nil)
  if valid_607891 != nil:
    section.add "X-Amz-Algorithm", valid_607891
  var valid_607892 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_607892 = validateParameter(valid_607892, JString, required = false,
                                 default = nil)
  if valid_607892 != nil:
    section.add "X-Amz-SignedHeaders", valid_607892
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_607893: Call_GetDescribeEvents_607874; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns events related to clusters, security groups, snapshots, and parameter groups for the past 14 days. Events specific to a particular cluster, security group, snapshot or parameter group can be obtained by providing the name as a parameter. By default, the past hour of events are returned.
  ## 
  let valid = call_607893.validator(path, query, header, formData, body)
  let scheme = call_607893.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_607893.url(scheme.get, call_607893.host, call_607893.base,
                         call_607893.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_607893, url, valid)

proc call*(call_607894: Call_GetDescribeEvents_607874; Marker: string = "";
          SourceType: string = "cluster"; SourceIdentifier: string = "";
          Action: string = "DescribeEvents"; StartTime: string = ""; Duration: int = 0;
          EndTime: string = ""; Version: string = "2012-12-01"; MaxRecords: int = 0): Recallable =
  ## getDescribeEvents
  ## Returns events related to clusters, security groups, snapshots, and parameter groups for the past 14 days. Events specific to a particular cluster, security group, snapshot or parameter group can be obtained by providing the name as a parameter. By default, the past hour of events are returned.
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeEvents</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   SourceType: string
  ##             : <p>The event source to retrieve events for. If no value is specified, all events are returned.</p> <p>Constraints:</p> <p>If <i>SourceType</i> is supplied, <i>SourceIdentifier</i> must also be provided.</p> <ul> <li> <p>Specify <code>cluster</code> when <i>SourceIdentifier</i> is a cluster identifier.</p> </li> <li> <p>Specify <code>cluster-security-group</code> when <i>SourceIdentifier</i> is a cluster security group name.</p> </li> <li> <p>Specify <code>cluster-parameter-group</code> when <i>SourceIdentifier</i> is a cluster parameter group name.</p> </li> <li> <p>Specify <code>cluster-snapshot</code> when <i>SourceIdentifier</i> is a cluster snapshot identifier.</p> </li> </ul>
  ##   SourceIdentifier: string
  ##                   : <p>The identifier of the event source for which events will be returned. If this parameter is not specified, then all sources are included in the response.</p> <p>Constraints:</p> <p>If <i>SourceIdentifier</i> is supplied, <i>SourceType</i> must also be provided.</p> <ul> <li> <p>Specify a cluster identifier when <i>SourceType</i> is <code>cluster</code>.</p> </li> <li> <p>Specify a cluster security group name when <i>SourceType</i> is <code>cluster-security-group</code>.</p> </li> <li> <p>Specify a cluster parameter group name when <i>SourceType</i> is <code>cluster-parameter-group</code>.</p> </li> <li> <p>Specify a cluster snapshot identifier when <i>SourceType</i> is <code>cluster-snapshot</code>.</p> </li> </ul>
  ##   Action: string (required)
  ##   StartTime: string
  ##            : <p>The beginning of the time interval to retrieve events for, specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2009-07-08T18:00Z</code> </p>
  ##   Duration: int
  ##           : <p>The number of minutes prior to the time of the request for which to retrieve events. For example, if the request is sent at 18:00 and you specify a duration of 60, then only events which have occurred after 17:00 will be returned.</p> <p>Default: <code>60</code> </p>
  ##   EndTime: string
  ##          : <p>The end of the time interval for which to retrieve events, specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2009-07-08T18:00Z</code> </p>
  ##   Version: string (required)
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  var query_607895 = newJObject()
  add(query_607895, "Marker", newJString(Marker))
  add(query_607895, "SourceType", newJString(SourceType))
  add(query_607895, "SourceIdentifier", newJString(SourceIdentifier))
  add(query_607895, "Action", newJString(Action))
  add(query_607895, "StartTime", newJString(StartTime))
  add(query_607895, "Duration", newJInt(Duration))
  add(query_607895, "EndTime", newJString(EndTime))
  add(query_607895, "Version", newJString(Version))
  add(query_607895, "MaxRecords", newJInt(MaxRecords))
  result = call_607894.call(nil, query_607895, nil, nil, nil)

var getDescribeEvents* = Call_GetDescribeEvents_607874(name: "getDescribeEvents",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=DescribeEvents", validator: validate_GetDescribeEvents_607875,
    base: "/", url: url_GetDescribeEvents_607876,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeHsmClientCertificates_607939 = ref object of OpenApiRestCall_605573
proc url_PostDescribeHsmClientCertificates_607941(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeHsmClientCertificates_607940(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns information about the specified HSM client certificate. If no certificate ID is specified, returns information about all the HSM certificates owned by your AWS customer account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM client certificates that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all HSM client certificates that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, HSM client certificates are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_607942 = query.getOrDefault("Action")
  valid_607942 = validateParameter(valid_607942, JString, required = true, default = newJString(
      "DescribeHsmClientCertificates"))
  if valid_607942 != nil:
    section.add "Action", valid_607942
  var valid_607943 = query.getOrDefault("Version")
  valid_607943 = validateParameter(valid_607943, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_607943 != nil:
    section.add "Version", valid_607943
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_607944 = header.getOrDefault("X-Amz-Signature")
  valid_607944 = validateParameter(valid_607944, JString, required = false,
                                 default = nil)
  if valid_607944 != nil:
    section.add "X-Amz-Signature", valid_607944
  var valid_607945 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_607945 = validateParameter(valid_607945, JString, required = false,
                                 default = nil)
  if valid_607945 != nil:
    section.add "X-Amz-Content-Sha256", valid_607945
  var valid_607946 = header.getOrDefault("X-Amz-Date")
  valid_607946 = validateParameter(valid_607946, JString, required = false,
                                 default = nil)
  if valid_607946 != nil:
    section.add "X-Amz-Date", valid_607946
  var valid_607947 = header.getOrDefault("X-Amz-Credential")
  valid_607947 = validateParameter(valid_607947, JString, required = false,
                                 default = nil)
  if valid_607947 != nil:
    section.add "X-Amz-Credential", valid_607947
  var valid_607948 = header.getOrDefault("X-Amz-Security-Token")
  valid_607948 = validateParameter(valid_607948, JString, required = false,
                                 default = nil)
  if valid_607948 != nil:
    section.add "X-Amz-Security-Token", valid_607948
  var valid_607949 = header.getOrDefault("X-Amz-Algorithm")
  valid_607949 = validateParameter(valid_607949, JString, required = false,
                                 default = nil)
  if valid_607949 != nil:
    section.add "X-Amz-Algorithm", valid_607949
  var valid_607950 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_607950 = validateParameter(valid_607950, JString, required = false,
                                 default = nil)
  if valid_607950 != nil:
    section.add "X-Amz-SignedHeaders", valid_607950
  result.add "header", section
  ## parameters in `formData` object:
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching HSM client certificates that are associated with the specified key or keys. For example, suppose that you have HSM client certificates that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the HSM client certificates that have either or both of these tag keys associated with them.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeHsmClientCertificates</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching HSM client certificates that are associated with the specified tag value or values. For example, suppose that you have HSM client certificates that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the HSM client certificates that have either or both of these tag values associated with them.
  ##   HsmClientCertificateIdentifier: JString
  ##                                 : The identifier of a specific HSM client certificate for which you want information. If no identifier is specified, information is returned for all HSM client certificates owned by your AWS customer account.
  section = newJObject()
  var valid_607951 = formData.getOrDefault("TagKeys")
  valid_607951 = validateParameter(valid_607951, JArray, required = false,
                                 default = nil)
  if valid_607951 != nil:
    section.add "TagKeys", valid_607951
  var valid_607952 = formData.getOrDefault("MaxRecords")
  valid_607952 = validateParameter(valid_607952, JInt, required = false, default = nil)
  if valid_607952 != nil:
    section.add "MaxRecords", valid_607952
  var valid_607953 = formData.getOrDefault("Marker")
  valid_607953 = validateParameter(valid_607953, JString, required = false,
                                 default = nil)
  if valid_607953 != nil:
    section.add "Marker", valid_607953
  var valid_607954 = formData.getOrDefault("TagValues")
  valid_607954 = validateParameter(valid_607954, JArray, required = false,
                                 default = nil)
  if valid_607954 != nil:
    section.add "TagValues", valid_607954
  var valid_607955 = formData.getOrDefault("HsmClientCertificateIdentifier")
  valid_607955 = validateParameter(valid_607955, JString, required = false,
                                 default = nil)
  if valid_607955 != nil:
    section.add "HsmClientCertificateIdentifier", valid_607955
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_607956: Call_PostDescribeHsmClientCertificates_607939;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Returns information about the specified HSM client certificate. If no certificate ID is specified, returns information about all the HSM certificates owned by your AWS customer account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM client certificates that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all HSM client certificates that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, HSM client certificates are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_607956.validator(path, query, header, formData, body)
  let scheme = call_607956.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_607956.url(scheme.get, call_607956.host, call_607956.base,
                         call_607956.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_607956, url, valid)

proc call*(call_607957: Call_PostDescribeHsmClientCertificates_607939;
          TagKeys: JsonNode = nil; MaxRecords: int = 0; Marker: string = "";
          TagValues: JsonNode = nil;
          Action: string = "DescribeHsmClientCertificates";
          HsmClientCertificateIdentifier: string = "";
          Version: string = "2012-12-01"): Recallable =
  ## postDescribeHsmClientCertificates
  ## <p>Returns information about the specified HSM client certificate. If no certificate ID is specified, returns information about all the HSM certificates owned by your AWS customer account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM client certificates that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all HSM client certificates that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, HSM client certificates are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching HSM client certificates that are associated with the specified key or keys. For example, suppose that you have HSM client certificates that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the HSM client certificates that have either or both of these tag keys associated with them.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeHsmClientCertificates</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching HSM client certificates that are associated with the specified tag value or values. For example, suppose that you have HSM client certificates that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the HSM client certificates that have either or both of these tag values associated with them.
  ##   Action: string (required)
  ##   HsmClientCertificateIdentifier: string
  ##                                 : The identifier of a specific HSM client certificate for which you want information. If no identifier is specified, information is returned for all HSM client certificates owned by your AWS customer account.
  ##   Version: string (required)
  var query_607958 = newJObject()
  var formData_607959 = newJObject()
  if TagKeys != nil:
    formData_607959.add "TagKeys", TagKeys
  add(formData_607959, "MaxRecords", newJInt(MaxRecords))
  add(formData_607959, "Marker", newJString(Marker))
  if TagValues != nil:
    formData_607959.add "TagValues", TagValues
  add(query_607958, "Action", newJString(Action))
  add(formData_607959, "HsmClientCertificateIdentifier",
      newJString(HsmClientCertificateIdentifier))
  add(query_607958, "Version", newJString(Version))
  result = call_607957.call(nil, query_607958, nil, formData_607959, nil)

var postDescribeHsmClientCertificates* = Call_PostDescribeHsmClientCertificates_607939(
    name: "postDescribeHsmClientCertificates", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeHsmClientCertificates",
    validator: validate_PostDescribeHsmClientCertificates_607940, base: "/",
    url: url_PostDescribeHsmClientCertificates_607941,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeHsmClientCertificates_607919 = ref object of OpenApiRestCall_605573
proc url_GetDescribeHsmClientCertificates_607921(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeHsmClientCertificates_607920(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns information about the specified HSM client certificate. If no certificate ID is specified, returns information about all the HSM certificates owned by your AWS customer account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM client certificates that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all HSM client certificates that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, HSM client certificates are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeHsmClientCertificates</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   HsmClientCertificateIdentifier: JString
  ##                                 : The identifier of a specific HSM client certificate for which you want information. If no identifier is specified, information is returned for all HSM client certificates owned by your AWS customer account.
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching HSM client certificates that are associated with the specified key or keys. For example, suppose that you have HSM client certificates that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the HSM client certificates that have either or both of these tag keys associated with them.
  ##   Action: JString (required)
  ##   Version: JString (required)
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching HSM client certificates that are associated with the specified tag value or values. For example, suppose that you have HSM client certificates that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the HSM client certificates that have either or both of these tag values associated with them.
  section = newJObject()
  var valid_607922 = query.getOrDefault("Marker")
  valid_607922 = validateParameter(valid_607922, JString, required = false,
                                 default = nil)
  if valid_607922 != nil:
    section.add "Marker", valid_607922
  var valid_607923 = query.getOrDefault("HsmClientCertificateIdentifier")
  valid_607923 = validateParameter(valid_607923, JString, required = false,
                                 default = nil)
  if valid_607923 != nil:
    section.add "HsmClientCertificateIdentifier", valid_607923
  var valid_607924 = query.getOrDefault("TagKeys")
  valid_607924 = validateParameter(valid_607924, JArray, required = false,
                                 default = nil)
  if valid_607924 != nil:
    section.add "TagKeys", valid_607924
  var valid_607925 = query.getOrDefault("Action")
  valid_607925 = validateParameter(valid_607925, JString, required = true, default = newJString(
      "DescribeHsmClientCertificates"))
  if valid_607925 != nil:
    section.add "Action", valid_607925
  var valid_607926 = query.getOrDefault("Version")
  valid_607926 = validateParameter(valid_607926, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_607926 != nil:
    section.add "Version", valid_607926
  var valid_607927 = query.getOrDefault("MaxRecords")
  valid_607927 = validateParameter(valid_607927, JInt, required = false, default = nil)
  if valid_607927 != nil:
    section.add "MaxRecords", valid_607927
  var valid_607928 = query.getOrDefault("TagValues")
  valid_607928 = validateParameter(valid_607928, JArray, required = false,
                                 default = nil)
  if valid_607928 != nil:
    section.add "TagValues", valid_607928
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_607929 = header.getOrDefault("X-Amz-Signature")
  valid_607929 = validateParameter(valid_607929, JString, required = false,
                                 default = nil)
  if valid_607929 != nil:
    section.add "X-Amz-Signature", valid_607929
  var valid_607930 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_607930 = validateParameter(valid_607930, JString, required = false,
                                 default = nil)
  if valid_607930 != nil:
    section.add "X-Amz-Content-Sha256", valid_607930
  var valid_607931 = header.getOrDefault("X-Amz-Date")
  valid_607931 = validateParameter(valid_607931, JString, required = false,
                                 default = nil)
  if valid_607931 != nil:
    section.add "X-Amz-Date", valid_607931
  var valid_607932 = header.getOrDefault("X-Amz-Credential")
  valid_607932 = validateParameter(valid_607932, JString, required = false,
                                 default = nil)
  if valid_607932 != nil:
    section.add "X-Amz-Credential", valid_607932
  var valid_607933 = header.getOrDefault("X-Amz-Security-Token")
  valid_607933 = validateParameter(valid_607933, JString, required = false,
                                 default = nil)
  if valid_607933 != nil:
    section.add "X-Amz-Security-Token", valid_607933
  var valid_607934 = header.getOrDefault("X-Amz-Algorithm")
  valid_607934 = validateParameter(valid_607934, JString, required = false,
                                 default = nil)
  if valid_607934 != nil:
    section.add "X-Amz-Algorithm", valid_607934
  var valid_607935 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_607935 = validateParameter(valid_607935, JString, required = false,
                                 default = nil)
  if valid_607935 != nil:
    section.add "X-Amz-SignedHeaders", valid_607935
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_607936: Call_GetDescribeHsmClientCertificates_607919;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Returns information about the specified HSM client certificate. If no certificate ID is specified, returns information about all the HSM certificates owned by your AWS customer account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM client certificates that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all HSM client certificates that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, HSM client certificates are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_607936.validator(path, query, header, formData, body)
  let scheme = call_607936.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_607936.url(scheme.get, call_607936.host, call_607936.base,
                         call_607936.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_607936, url, valid)

proc call*(call_607937: Call_GetDescribeHsmClientCertificates_607919;
          Marker: string = ""; HsmClientCertificateIdentifier: string = "";
          TagKeys: JsonNode = nil; Action: string = "DescribeHsmClientCertificates";
          Version: string = "2012-12-01"; MaxRecords: int = 0; TagValues: JsonNode = nil): Recallable =
  ## getDescribeHsmClientCertificates
  ## <p>Returns information about the specified HSM client certificate. If no certificate ID is specified, returns information about all the HSM certificates owned by your AWS customer account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM client certificates that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all HSM client certificates that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, HSM client certificates are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeHsmClientCertificates</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   HsmClientCertificateIdentifier: string
  ##                                 : The identifier of a specific HSM client certificate for which you want information. If no identifier is specified, information is returned for all HSM client certificates owned by your AWS customer account.
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching HSM client certificates that are associated with the specified key or keys. For example, suppose that you have HSM client certificates that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the HSM client certificates that have either or both of these tag keys associated with them.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching HSM client certificates that are associated with the specified tag value or values. For example, suppose that you have HSM client certificates that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the HSM client certificates that have either or both of these tag values associated with them.
  var query_607938 = newJObject()
  add(query_607938, "Marker", newJString(Marker))
  add(query_607938, "HsmClientCertificateIdentifier",
      newJString(HsmClientCertificateIdentifier))
  if TagKeys != nil:
    query_607938.add "TagKeys", TagKeys
  add(query_607938, "Action", newJString(Action))
  add(query_607938, "Version", newJString(Version))
  add(query_607938, "MaxRecords", newJInt(MaxRecords))
  if TagValues != nil:
    query_607938.add "TagValues", TagValues
  result = call_607937.call(nil, query_607938, nil, nil, nil)

var getDescribeHsmClientCertificates* = Call_GetDescribeHsmClientCertificates_607919(
    name: "getDescribeHsmClientCertificates", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeHsmClientCertificates",
    validator: validate_GetDescribeHsmClientCertificates_607920, base: "/",
    url: url_GetDescribeHsmClientCertificates_607921,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeHsmConfigurations_607980 = ref object of OpenApiRestCall_605573
proc url_PostDescribeHsmConfigurations_607982(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeHsmConfigurations_607981(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns information about the specified Amazon Redshift HSM configuration. If no configuration ID is specified, returns information about all the HSM configurations owned by your AWS customer account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM connections that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all HSM connections that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, HSM connections are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_607983 = query.getOrDefault("Action")
  valid_607983 = validateParameter(valid_607983, JString, required = true, default = newJString(
      "DescribeHsmConfigurations"))
  if valid_607983 != nil:
    section.add "Action", valid_607983
  var valid_607984 = query.getOrDefault("Version")
  valid_607984 = validateParameter(valid_607984, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_607984 != nil:
    section.add "Version", valid_607984
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_607985 = header.getOrDefault("X-Amz-Signature")
  valid_607985 = validateParameter(valid_607985, JString, required = false,
                                 default = nil)
  if valid_607985 != nil:
    section.add "X-Amz-Signature", valid_607985
  var valid_607986 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_607986 = validateParameter(valid_607986, JString, required = false,
                                 default = nil)
  if valid_607986 != nil:
    section.add "X-Amz-Content-Sha256", valid_607986
  var valid_607987 = header.getOrDefault("X-Amz-Date")
  valid_607987 = validateParameter(valid_607987, JString, required = false,
                                 default = nil)
  if valid_607987 != nil:
    section.add "X-Amz-Date", valid_607987
  var valid_607988 = header.getOrDefault("X-Amz-Credential")
  valid_607988 = validateParameter(valid_607988, JString, required = false,
                                 default = nil)
  if valid_607988 != nil:
    section.add "X-Amz-Credential", valid_607988
  var valid_607989 = header.getOrDefault("X-Amz-Security-Token")
  valid_607989 = validateParameter(valid_607989, JString, required = false,
                                 default = nil)
  if valid_607989 != nil:
    section.add "X-Amz-Security-Token", valid_607989
  var valid_607990 = header.getOrDefault("X-Amz-Algorithm")
  valid_607990 = validateParameter(valid_607990, JString, required = false,
                                 default = nil)
  if valid_607990 != nil:
    section.add "X-Amz-Algorithm", valid_607990
  var valid_607991 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_607991 = validateParameter(valid_607991, JString, required = false,
                                 default = nil)
  if valid_607991 != nil:
    section.add "X-Amz-SignedHeaders", valid_607991
  result.add "header", section
  ## parameters in `formData` object:
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching HSM configurations that are associated with the specified key or keys. For example, suppose that you have HSM configurations that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the HSM configurations that have either or both of these tag keys associated with them.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeHsmConfigurations</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching HSM configurations that are associated with the specified tag value or values. For example, suppose that you have HSM configurations that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the HSM configurations that have either or both of these tag values associated with them.
  ##   HsmConfigurationIdentifier: JString
  ##                             : The identifier of a specific Amazon Redshift HSM configuration to be described. If no identifier is specified, information is returned for all HSM configurations owned by your AWS customer account.
  section = newJObject()
  var valid_607992 = formData.getOrDefault("TagKeys")
  valid_607992 = validateParameter(valid_607992, JArray, required = false,
                                 default = nil)
  if valid_607992 != nil:
    section.add "TagKeys", valid_607992
  var valid_607993 = formData.getOrDefault("MaxRecords")
  valid_607993 = validateParameter(valid_607993, JInt, required = false, default = nil)
  if valid_607993 != nil:
    section.add "MaxRecords", valid_607993
  var valid_607994 = formData.getOrDefault("Marker")
  valid_607994 = validateParameter(valid_607994, JString, required = false,
                                 default = nil)
  if valid_607994 != nil:
    section.add "Marker", valid_607994
  var valid_607995 = formData.getOrDefault("TagValues")
  valid_607995 = validateParameter(valid_607995, JArray, required = false,
                                 default = nil)
  if valid_607995 != nil:
    section.add "TagValues", valid_607995
  var valid_607996 = formData.getOrDefault("HsmConfigurationIdentifier")
  valid_607996 = validateParameter(valid_607996, JString, required = false,
                                 default = nil)
  if valid_607996 != nil:
    section.add "HsmConfigurationIdentifier", valid_607996
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_607997: Call_PostDescribeHsmConfigurations_607980; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns information about the specified Amazon Redshift HSM configuration. If no configuration ID is specified, returns information about all the HSM configurations owned by your AWS customer account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM connections that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all HSM connections that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, HSM connections are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_607997.validator(path, query, header, formData, body)
  let scheme = call_607997.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_607997.url(scheme.get, call_607997.host, call_607997.base,
                         call_607997.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_607997, url, valid)

proc call*(call_607998: Call_PostDescribeHsmConfigurations_607980;
          TagKeys: JsonNode = nil; MaxRecords: int = 0; Marker: string = "";
          TagValues: JsonNode = nil; Action: string = "DescribeHsmConfigurations";
          Version: string = "2012-12-01"; HsmConfigurationIdentifier: string = ""): Recallable =
  ## postDescribeHsmConfigurations
  ## <p>Returns information about the specified Amazon Redshift HSM configuration. If no configuration ID is specified, returns information about all the HSM configurations owned by your AWS customer account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM connections that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all HSM connections that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, HSM connections are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching HSM configurations that are associated with the specified key or keys. For example, suppose that you have HSM configurations that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the HSM configurations that have either or both of these tag keys associated with them.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeHsmConfigurations</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching HSM configurations that are associated with the specified tag value or values. For example, suppose that you have HSM configurations that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the HSM configurations that have either or both of these tag values associated with them.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   HsmConfigurationIdentifier: string
  ##                             : The identifier of a specific Amazon Redshift HSM configuration to be described. If no identifier is specified, information is returned for all HSM configurations owned by your AWS customer account.
  var query_607999 = newJObject()
  var formData_608000 = newJObject()
  if TagKeys != nil:
    formData_608000.add "TagKeys", TagKeys
  add(formData_608000, "MaxRecords", newJInt(MaxRecords))
  add(formData_608000, "Marker", newJString(Marker))
  if TagValues != nil:
    formData_608000.add "TagValues", TagValues
  add(query_607999, "Action", newJString(Action))
  add(query_607999, "Version", newJString(Version))
  add(formData_608000, "HsmConfigurationIdentifier",
      newJString(HsmConfigurationIdentifier))
  result = call_607998.call(nil, query_607999, nil, formData_608000, nil)

var postDescribeHsmConfigurations* = Call_PostDescribeHsmConfigurations_607980(
    name: "postDescribeHsmConfigurations", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeHsmConfigurations",
    validator: validate_PostDescribeHsmConfigurations_607981, base: "/",
    url: url_PostDescribeHsmConfigurations_607982,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeHsmConfigurations_607960 = ref object of OpenApiRestCall_605573
proc url_GetDescribeHsmConfigurations_607962(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeHsmConfigurations_607961(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns information about the specified Amazon Redshift HSM configuration. If no configuration ID is specified, returns information about all the HSM configurations owned by your AWS customer account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM connections that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all HSM connections that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, HSM connections are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeHsmConfigurations</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching HSM configurations that are associated with the specified key or keys. For example, suppose that you have HSM configurations that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the HSM configurations that have either or both of these tag keys associated with them.
  ##   Action: JString (required)
  ##   HsmConfigurationIdentifier: JString
  ##                             : The identifier of a specific Amazon Redshift HSM configuration to be described. If no identifier is specified, information is returned for all HSM configurations owned by your AWS customer account.
  ##   Version: JString (required)
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching HSM configurations that are associated with the specified tag value or values. For example, suppose that you have HSM configurations that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the HSM configurations that have either or both of these tag values associated with them.
  section = newJObject()
  var valid_607963 = query.getOrDefault("Marker")
  valid_607963 = validateParameter(valid_607963, JString, required = false,
                                 default = nil)
  if valid_607963 != nil:
    section.add "Marker", valid_607963
  var valid_607964 = query.getOrDefault("TagKeys")
  valid_607964 = validateParameter(valid_607964, JArray, required = false,
                                 default = nil)
  if valid_607964 != nil:
    section.add "TagKeys", valid_607964
  var valid_607965 = query.getOrDefault("Action")
  valid_607965 = validateParameter(valid_607965, JString, required = true, default = newJString(
      "DescribeHsmConfigurations"))
  if valid_607965 != nil:
    section.add "Action", valid_607965
  var valid_607966 = query.getOrDefault("HsmConfigurationIdentifier")
  valid_607966 = validateParameter(valid_607966, JString, required = false,
                                 default = nil)
  if valid_607966 != nil:
    section.add "HsmConfigurationIdentifier", valid_607966
  var valid_607967 = query.getOrDefault("Version")
  valid_607967 = validateParameter(valid_607967, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_607967 != nil:
    section.add "Version", valid_607967
  var valid_607968 = query.getOrDefault("MaxRecords")
  valid_607968 = validateParameter(valid_607968, JInt, required = false, default = nil)
  if valid_607968 != nil:
    section.add "MaxRecords", valid_607968
  var valid_607969 = query.getOrDefault("TagValues")
  valid_607969 = validateParameter(valid_607969, JArray, required = false,
                                 default = nil)
  if valid_607969 != nil:
    section.add "TagValues", valid_607969
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_607970 = header.getOrDefault("X-Amz-Signature")
  valid_607970 = validateParameter(valid_607970, JString, required = false,
                                 default = nil)
  if valid_607970 != nil:
    section.add "X-Amz-Signature", valid_607970
  var valid_607971 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_607971 = validateParameter(valid_607971, JString, required = false,
                                 default = nil)
  if valid_607971 != nil:
    section.add "X-Amz-Content-Sha256", valid_607971
  var valid_607972 = header.getOrDefault("X-Amz-Date")
  valid_607972 = validateParameter(valid_607972, JString, required = false,
                                 default = nil)
  if valid_607972 != nil:
    section.add "X-Amz-Date", valid_607972
  var valid_607973 = header.getOrDefault("X-Amz-Credential")
  valid_607973 = validateParameter(valid_607973, JString, required = false,
                                 default = nil)
  if valid_607973 != nil:
    section.add "X-Amz-Credential", valid_607973
  var valid_607974 = header.getOrDefault("X-Amz-Security-Token")
  valid_607974 = validateParameter(valid_607974, JString, required = false,
                                 default = nil)
  if valid_607974 != nil:
    section.add "X-Amz-Security-Token", valid_607974
  var valid_607975 = header.getOrDefault("X-Amz-Algorithm")
  valid_607975 = validateParameter(valid_607975, JString, required = false,
                                 default = nil)
  if valid_607975 != nil:
    section.add "X-Amz-Algorithm", valid_607975
  var valid_607976 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_607976 = validateParameter(valid_607976, JString, required = false,
                                 default = nil)
  if valid_607976 != nil:
    section.add "X-Amz-SignedHeaders", valid_607976
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_607977: Call_GetDescribeHsmConfigurations_607960; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns information about the specified Amazon Redshift HSM configuration. If no configuration ID is specified, returns information about all the HSM configurations owned by your AWS customer account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM connections that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all HSM connections that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, HSM connections are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_607977.validator(path, query, header, formData, body)
  let scheme = call_607977.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_607977.url(scheme.get, call_607977.host, call_607977.base,
                         call_607977.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_607977, url, valid)

proc call*(call_607978: Call_GetDescribeHsmConfigurations_607960;
          Marker: string = ""; TagKeys: JsonNode = nil;
          Action: string = "DescribeHsmConfigurations";
          HsmConfigurationIdentifier: string = ""; Version: string = "2012-12-01";
          MaxRecords: int = 0; TagValues: JsonNode = nil): Recallable =
  ## getDescribeHsmConfigurations
  ## <p>Returns information about the specified Amazon Redshift HSM configuration. If no configuration ID is specified, returns information about all the HSM configurations owned by your AWS customer account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM connections that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all HSM connections that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, HSM connections are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeHsmConfigurations</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching HSM configurations that are associated with the specified key or keys. For example, suppose that you have HSM configurations that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the HSM configurations that have either or both of these tag keys associated with them.
  ##   Action: string (required)
  ##   HsmConfigurationIdentifier: string
  ##                             : The identifier of a specific Amazon Redshift HSM configuration to be described. If no identifier is specified, information is returned for all HSM configurations owned by your AWS customer account.
  ##   Version: string (required)
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching HSM configurations that are associated with the specified tag value or values. For example, suppose that you have HSM configurations that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the HSM configurations that have either or both of these tag values associated with them.
  var query_607979 = newJObject()
  add(query_607979, "Marker", newJString(Marker))
  if TagKeys != nil:
    query_607979.add "TagKeys", TagKeys
  add(query_607979, "Action", newJString(Action))
  add(query_607979, "HsmConfigurationIdentifier",
      newJString(HsmConfigurationIdentifier))
  add(query_607979, "Version", newJString(Version))
  add(query_607979, "MaxRecords", newJInt(MaxRecords))
  if TagValues != nil:
    query_607979.add "TagValues", TagValues
  result = call_607978.call(nil, query_607979, nil, nil, nil)

var getDescribeHsmConfigurations* = Call_GetDescribeHsmConfigurations_607960(
    name: "getDescribeHsmConfigurations", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeHsmConfigurations",
    validator: validate_GetDescribeHsmConfigurations_607961, base: "/",
    url: url_GetDescribeHsmConfigurations_607962,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeLoggingStatus_608017 = ref object of OpenApiRestCall_605573
proc url_PostDescribeLoggingStatus_608019(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeLoggingStatus_608018(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Describes whether information, such as queries and connection attempts, is being logged for the specified Amazon Redshift cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_608020 = query.getOrDefault("Action")
  valid_608020 = validateParameter(valid_608020, JString, required = true,
                                 default = newJString("DescribeLoggingStatus"))
  if valid_608020 != nil:
    section.add "Action", valid_608020
  var valid_608021 = query.getOrDefault("Version")
  valid_608021 = validateParameter(valid_608021, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_608021 != nil:
    section.add "Version", valid_608021
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_608022 = header.getOrDefault("X-Amz-Signature")
  valid_608022 = validateParameter(valid_608022, JString, required = false,
                                 default = nil)
  if valid_608022 != nil:
    section.add "X-Amz-Signature", valid_608022
  var valid_608023 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_608023 = validateParameter(valid_608023, JString, required = false,
                                 default = nil)
  if valid_608023 != nil:
    section.add "X-Amz-Content-Sha256", valid_608023
  var valid_608024 = header.getOrDefault("X-Amz-Date")
  valid_608024 = validateParameter(valid_608024, JString, required = false,
                                 default = nil)
  if valid_608024 != nil:
    section.add "X-Amz-Date", valid_608024
  var valid_608025 = header.getOrDefault("X-Amz-Credential")
  valid_608025 = validateParameter(valid_608025, JString, required = false,
                                 default = nil)
  if valid_608025 != nil:
    section.add "X-Amz-Credential", valid_608025
  var valid_608026 = header.getOrDefault("X-Amz-Security-Token")
  valid_608026 = validateParameter(valid_608026, JString, required = false,
                                 default = nil)
  if valid_608026 != nil:
    section.add "X-Amz-Security-Token", valid_608026
  var valid_608027 = header.getOrDefault("X-Amz-Algorithm")
  valid_608027 = validateParameter(valid_608027, JString, required = false,
                                 default = nil)
  if valid_608027 != nil:
    section.add "X-Amz-Algorithm", valid_608027
  var valid_608028 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_608028 = validateParameter(valid_608028, JString, required = false,
                                 default = nil)
  if valid_608028 != nil:
    section.add "X-Amz-SignedHeaders", valid_608028
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The identifier of the cluster from which to get the logging status.</p> <p>Example: <code>examplecluster</code> </p>
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_608029 = formData.getOrDefault("ClusterIdentifier")
  valid_608029 = validateParameter(valid_608029, JString, required = true,
                                 default = nil)
  if valid_608029 != nil:
    section.add "ClusterIdentifier", valid_608029
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_608030: Call_PostDescribeLoggingStatus_608017; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Describes whether information, such as queries and connection attempts, is being logged for the specified Amazon Redshift cluster.
  ## 
  let valid = call_608030.validator(path, query, header, formData, body)
  let scheme = call_608030.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_608030.url(scheme.get, call_608030.host, call_608030.base,
                         call_608030.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_608030, url, valid)

proc call*(call_608031: Call_PostDescribeLoggingStatus_608017;
          ClusterIdentifier: string; Action: string = "DescribeLoggingStatus";
          Version: string = "2012-12-01"): Recallable =
  ## postDescribeLoggingStatus
  ## Describes whether information, such as queries and connection attempts, is being logged for the specified Amazon Redshift cluster.
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The identifier of the cluster from which to get the logging status.</p> <p>Example: <code>examplecluster</code> </p>
  ##   Action: string (required)
  ##   Version: string (required)
  var query_608032 = newJObject()
  var formData_608033 = newJObject()
  add(formData_608033, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_608032, "Action", newJString(Action))
  add(query_608032, "Version", newJString(Version))
  result = call_608031.call(nil, query_608032, nil, formData_608033, nil)

var postDescribeLoggingStatus* = Call_PostDescribeLoggingStatus_608017(
    name: "postDescribeLoggingStatus", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeLoggingStatus",
    validator: validate_PostDescribeLoggingStatus_608018, base: "/",
    url: url_PostDescribeLoggingStatus_608019,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeLoggingStatus_608001 = ref object of OpenApiRestCall_605573
proc url_GetDescribeLoggingStatus_608003(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeLoggingStatus_608002(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Describes whether information, such as queries and connection attempts, is being logged for the specified Amazon Redshift cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The identifier of the cluster from which to get the logging status.</p> <p>Example: <code>examplecluster</code> </p>
  ##   Version: JString (required)
  section = newJObject()
  var valid_608004 = query.getOrDefault("Action")
  valid_608004 = validateParameter(valid_608004, JString, required = true,
                                 default = newJString("DescribeLoggingStatus"))
  if valid_608004 != nil:
    section.add "Action", valid_608004
  var valid_608005 = query.getOrDefault("ClusterIdentifier")
  valid_608005 = validateParameter(valid_608005, JString, required = true,
                                 default = nil)
  if valid_608005 != nil:
    section.add "ClusterIdentifier", valid_608005
  var valid_608006 = query.getOrDefault("Version")
  valid_608006 = validateParameter(valid_608006, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_608006 != nil:
    section.add "Version", valid_608006
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_608007 = header.getOrDefault("X-Amz-Signature")
  valid_608007 = validateParameter(valid_608007, JString, required = false,
                                 default = nil)
  if valid_608007 != nil:
    section.add "X-Amz-Signature", valid_608007
  var valid_608008 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_608008 = validateParameter(valid_608008, JString, required = false,
                                 default = nil)
  if valid_608008 != nil:
    section.add "X-Amz-Content-Sha256", valid_608008
  var valid_608009 = header.getOrDefault("X-Amz-Date")
  valid_608009 = validateParameter(valid_608009, JString, required = false,
                                 default = nil)
  if valid_608009 != nil:
    section.add "X-Amz-Date", valid_608009
  var valid_608010 = header.getOrDefault("X-Amz-Credential")
  valid_608010 = validateParameter(valid_608010, JString, required = false,
                                 default = nil)
  if valid_608010 != nil:
    section.add "X-Amz-Credential", valid_608010
  var valid_608011 = header.getOrDefault("X-Amz-Security-Token")
  valid_608011 = validateParameter(valid_608011, JString, required = false,
                                 default = nil)
  if valid_608011 != nil:
    section.add "X-Amz-Security-Token", valid_608011
  var valid_608012 = header.getOrDefault("X-Amz-Algorithm")
  valid_608012 = validateParameter(valid_608012, JString, required = false,
                                 default = nil)
  if valid_608012 != nil:
    section.add "X-Amz-Algorithm", valid_608012
  var valid_608013 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_608013 = validateParameter(valid_608013, JString, required = false,
                                 default = nil)
  if valid_608013 != nil:
    section.add "X-Amz-SignedHeaders", valid_608013
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_608014: Call_GetDescribeLoggingStatus_608001; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Describes whether information, such as queries and connection attempts, is being logged for the specified Amazon Redshift cluster.
  ## 
  let valid = call_608014.validator(path, query, header, formData, body)
  let scheme = call_608014.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_608014.url(scheme.get, call_608014.host, call_608014.base,
                         call_608014.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_608014, url, valid)

proc call*(call_608015: Call_GetDescribeLoggingStatus_608001;
          ClusterIdentifier: string; Action: string = "DescribeLoggingStatus";
          Version: string = "2012-12-01"): Recallable =
  ## getDescribeLoggingStatus
  ## Describes whether information, such as queries and connection attempts, is being logged for the specified Amazon Redshift cluster.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The identifier of the cluster from which to get the logging status.</p> <p>Example: <code>examplecluster</code> </p>
  ##   Version: string (required)
  var query_608016 = newJObject()
  add(query_608016, "Action", newJString(Action))
  add(query_608016, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_608016, "Version", newJString(Version))
  result = call_608015.call(nil, query_608016, nil, nil, nil)

var getDescribeLoggingStatus* = Call_GetDescribeLoggingStatus_608001(
    name: "getDescribeLoggingStatus", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeLoggingStatus",
    validator: validate_GetDescribeLoggingStatus_608002, base: "/",
    url: url_GetDescribeLoggingStatus_608003, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeNodeConfigurationOptions_608056 = ref object of OpenApiRestCall_605573
proc url_PostDescribeNodeConfigurationOptions_608058(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeNodeConfigurationOptions_608057(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns properties of possible node configurations such as node type, number of nodes, and disk usage for the specified action type.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_608059 = query.getOrDefault("Action")
  valid_608059 = validateParameter(valid_608059, JString, required = true, default = newJString(
      "DescribeNodeConfigurationOptions"))
  if valid_608059 != nil:
    section.add "Action", valid_608059
  var valid_608060 = query.getOrDefault("Version")
  valid_608060 = validateParameter(valid_608060, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_608060 != nil:
    section.add "Version", valid_608060
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_608061 = header.getOrDefault("X-Amz-Signature")
  valid_608061 = validateParameter(valid_608061, JString, required = false,
                                 default = nil)
  if valid_608061 != nil:
    section.add "X-Amz-Signature", valid_608061
  var valid_608062 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_608062 = validateParameter(valid_608062, JString, required = false,
                                 default = nil)
  if valid_608062 != nil:
    section.add "X-Amz-Content-Sha256", valid_608062
  var valid_608063 = header.getOrDefault("X-Amz-Date")
  valid_608063 = validateParameter(valid_608063, JString, required = false,
                                 default = nil)
  if valid_608063 != nil:
    section.add "X-Amz-Date", valid_608063
  var valid_608064 = header.getOrDefault("X-Amz-Credential")
  valid_608064 = validateParameter(valid_608064, JString, required = false,
                                 default = nil)
  if valid_608064 != nil:
    section.add "X-Amz-Credential", valid_608064
  var valid_608065 = header.getOrDefault("X-Amz-Security-Token")
  valid_608065 = validateParameter(valid_608065, JString, required = false,
                                 default = nil)
  if valid_608065 != nil:
    section.add "X-Amz-Security-Token", valid_608065
  var valid_608066 = header.getOrDefault("X-Amz-Algorithm")
  valid_608066 = validateParameter(valid_608066, JString, required = false,
                                 default = nil)
  if valid_608066 != nil:
    section.add "X-Amz-Algorithm", valid_608066
  var valid_608067 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_608067 = validateParameter(valid_608067, JString, required = false,
                                 default = nil)
  if valid_608067 != nil:
    section.add "X-Amz-SignedHeaders", valid_608067
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString
  ##                    : The identifier of the cluster to evaluate for possible node configurations.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>500</code> </p> <p>Constraints: minimum 100, maximum 500.</p>
  ##   OwnerAccount: JString
  ##               : The AWS customer account used to create or copy the snapshot. Required if you are restoring a snapshot you do not own, optional if you own the snapshot.
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeNodeConfigurationOptions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   SnapshotIdentifier: JString
  ##                     : The identifier of the snapshot to evaluate for possible node configurations.
  ##   ActionType: JString (required)
  ##             : The action type to evaluate for possible node configurations. Specify "restore-cluster" to get configuration combinations based on an existing snapshot. Specify "recommend-node-config" to get configuration recommendations based on an existing cluster or snapshot. 
  ##   Filter: JArray
  ##         : A set of name, operator, and value items to filter the results.
  section = newJObject()
  var valid_608068 = formData.getOrDefault("ClusterIdentifier")
  valid_608068 = validateParameter(valid_608068, JString, required = false,
                                 default = nil)
  if valid_608068 != nil:
    section.add "ClusterIdentifier", valid_608068
  var valid_608069 = formData.getOrDefault("MaxRecords")
  valid_608069 = validateParameter(valid_608069, JInt, required = false, default = nil)
  if valid_608069 != nil:
    section.add "MaxRecords", valid_608069
  var valid_608070 = formData.getOrDefault("OwnerAccount")
  valid_608070 = validateParameter(valid_608070, JString, required = false,
                                 default = nil)
  if valid_608070 != nil:
    section.add "OwnerAccount", valid_608070
  var valid_608071 = formData.getOrDefault("Marker")
  valid_608071 = validateParameter(valid_608071, JString, required = false,
                                 default = nil)
  if valid_608071 != nil:
    section.add "Marker", valid_608071
  var valid_608072 = formData.getOrDefault("SnapshotIdentifier")
  valid_608072 = validateParameter(valid_608072, JString, required = false,
                                 default = nil)
  if valid_608072 != nil:
    section.add "SnapshotIdentifier", valid_608072
  var valid_608073 = formData.getOrDefault("ActionType")
  valid_608073 = validateParameter(valid_608073, JString, required = true,
                                 default = newJString("restore-cluster"))
  if valid_608073 != nil:
    section.add "ActionType", valid_608073
  var valid_608074 = formData.getOrDefault("Filter")
  valid_608074 = validateParameter(valid_608074, JArray, required = false,
                                 default = nil)
  if valid_608074 != nil:
    section.add "Filter", valid_608074
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_608075: Call_PostDescribeNodeConfigurationOptions_608056;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Returns properties of possible node configurations such as node type, number of nodes, and disk usage for the specified action type.
  ## 
  let valid = call_608075.validator(path, query, header, formData, body)
  let scheme = call_608075.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_608075.url(scheme.get, call_608075.host, call_608075.base,
                         call_608075.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_608075, url, valid)

proc call*(call_608076: Call_PostDescribeNodeConfigurationOptions_608056;
          ClusterIdentifier: string = ""; MaxRecords: int = 0;
          OwnerAccount: string = ""; Marker: string = "";
          SnapshotIdentifier: string = "";
          Action: string = "DescribeNodeConfigurationOptions";
          Version: string = "2012-12-01"; ActionType: string = "restore-cluster";
          Filter: JsonNode = nil): Recallable =
  ## postDescribeNodeConfigurationOptions
  ## Returns properties of possible node configurations such as node type, number of nodes, and disk usage for the specified action type.
  ##   ClusterIdentifier: string
  ##                    : The identifier of the cluster to evaluate for possible node configurations.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>500</code> </p> <p>Constraints: minimum 100, maximum 500.</p>
  ##   OwnerAccount: string
  ##               : The AWS customer account used to create or copy the snapshot. Required if you are restoring a snapshot you do not own, optional if you own the snapshot.
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeNodeConfigurationOptions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   SnapshotIdentifier: string
  ##                     : The identifier of the snapshot to evaluate for possible node configurations.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   ActionType: string (required)
  ##             : The action type to evaluate for possible node configurations. Specify "restore-cluster" to get configuration combinations based on an existing snapshot. Specify "recommend-node-config" to get configuration recommendations based on an existing cluster or snapshot. 
  ##   Filter: JArray
  ##         : A set of name, operator, and value items to filter the results.
  var query_608077 = newJObject()
  var formData_608078 = newJObject()
  add(formData_608078, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_608078, "MaxRecords", newJInt(MaxRecords))
  add(formData_608078, "OwnerAccount", newJString(OwnerAccount))
  add(formData_608078, "Marker", newJString(Marker))
  add(formData_608078, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_608077, "Action", newJString(Action))
  add(query_608077, "Version", newJString(Version))
  add(formData_608078, "ActionType", newJString(ActionType))
  if Filter != nil:
    formData_608078.add "Filter", Filter
  result = call_608076.call(nil, query_608077, nil, formData_608078, nil)

var postDescribeNodeConfigurationOptions* = Call_PostDescribeNodeConfigurationOptions_608056(
    name: "postDescribeNodeConfigurationOptions", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeNodeConfigurationOptions",
    validator: validate_PostDescribeNodeConfigurationOptions_608057, base: "/",
    url: url_PostDescribeNodeConfigurationOptions_608058,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeNodeConfigurationOptions_608034 = ref object of OpenApiRestCall_605573
proc url_GetDescribeNodeConfigurationOptions_608036(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeNodeConfigurationOptions_608035(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns properties of possible node configurations such as node type, number of nodes, and disk usage for the specified action type.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeNodeConfigurationOptions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   SnapshotIdentifier: JString
  ##                     : The identifier of the snapshot to evaluate for possible node configurations.
  ##   ActionType: JString (required)
  ##             : The action type to evaluate for possible node configurations. Specify "restore-cluster" to get configuration combinations based on an existing snapshot. Specify "recommend-node-config" to get configuration recommendations based on an existing cluster or snapshot. 
  ##   Filter: JArray
  ##         : A set of name, operator, and value items to filter the results.
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString
  ##                    : The identifier of the cluster to evaluate for possible node configurations.
  ##   OwnerAccount: JString
  ##               : The AWS customer account used to create or copy the snapshot. Required if you are restoring a snapshot you do not own, optional if you own the snapshot.
  ##   Version: JString (required)
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>500</code> </p> <p>Constraints: minimum 100, maximum 500.</p>
  section = newJObject()
  var valid_608037 = query.getOrDefault("Marker")
  valid_608037 = validateParameter(valid_608037, JString, required = false,
                                 default = nil)
  if valid_608037 != nil:
    section.add "Marker", valid_608037
  var valid_608038 = query.getOrDefault("SnapshotIdentifier")
  valid_608038 = validateParameter(valid_608038, JString, required = false,
                                 default = nil)
  if valid_608038 != nil:
    section.add "SnapshotIdentifier", valid_608038
  var valid_608039 = query.getOrDefault("ActionType")
  valid_608039 = validateParameter(valid_608039, JString, required = true,
                                 default = newJString("restore-cluster"))
  if valid_608039 != nil:
    section.add "ActionType", valid_608039
  var valid_608040 = query.getOrDefault("Filter")
  valid_608040 = validateParameter(valid_608040, JArray, required = false,
                                 default = nil)
  if valid_608040 != nil:
    section.add "Filter", valid_608040
  var valid_608041 = query.getOrDefault("Action")
  valid_608041 = validateParameter(valid_608041, JString, required = true, default = newJString(
      "DescribeNodeConfigurationOptions"))
  if valid_608041 != nil:
    section.add "Action", valid_608041
  var valid_608042 = query.getOrDefault("ClusterIdentifier")
  valid_608042 = validateParameter(valid_608042, JString, required = false,
                                 default = nil)
  if valid_608042 != nil:
    section.add "ClusterIdentifier", valid_608042
  var valid_608043 = query.getOrDefault("OwnerAccount")
  valid_608043 = validateParameter(valid_608043, JString, required = false,
                                 default = nil)
  if valid_608043 != nil:
    section.add "OwnerAccount", valid_608043
  var valid_608044 = query.getOrDefault("Version")
  valid_608044 = validateParameter(valid_608044, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_608044 != nil:
    section.add "Version", valid_608044
  var valid_608045 = query.getOrDefault("MaxRecords")
  valid_608045 = validateParameter(valid_608045, JInt, required = false, default = nil)
  if valid_608045 != nil:
    section.add "MaxRecords", valid_608045
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_608046 = header.getOrDefault("X-Amz-Signature")
  valid_608046 = validateParameter(valid_608046, JString, required = false,
                                 default = nil)
  if valid_608046 != nil:
    section.add "X-Amz-Signature", valid_608046
  var valid_608047 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_608047 = validateParameter(valid_608047, JString, required = false,
                                 default = nil)
  if valid_608047 != nil:
    section.add "X-Amz-Content-Sha256", valid_608047
  var valid_608048 = header.getOrDefault("X-Amz-Date")
  valid_608048 = validateParameter(valid_608048, JString, required = false,
                                 default = nil)
  if valid_608048 != nil:
    section.add "X-Amz-Date", valid_608048
  var valid_608049 = header.getOrDefault("X-Amz-Credential")
  valid_608049 = validateParameter(valid_608049, JString, required = false,
                                 default = nil)
  if valid_608049 != nil:
    section.add "X-Amz-Credential", valid_608049
  var valid_608050 = header.getOrDefault("X-Amz-Security-Token")
  valid_608050 = validateParameter(valid_608050, JString, required = false,
                                 default = nil)
  if valid_608050 != nil:
    section.add "X-Amz-Security-Token", valid_608050
  var valid_608051 = header.getOrDefault("X-Amz-Algorithm")
  valid_608051 = validateParameter(valid_608051, JString, required = false,
                                 default = nil)
  if valid_608051 != nil:
    section.add "X-Amz-Algorithm", valid_608051
  var valid_608052 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_608052 = validateParameter(valid_608052, JString, required = false,
                                 default = nil)
  if valid_608052 != nil:
    section.add "X-Amz-SignedHeaders", valid_608052
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_608053: Call_GetDescribeNodeConfigurationOptions_608034;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Returns properties of possible node configurations such as node type, number of nodes, and disk usage for the specified action type.
  ## 
  let valid = call_608053.validator(path, query, header, formData, body)
  let scheme = call_608053.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_608053.url(scheme.get, call_608053.host, call_608053.base,
                         call_608053.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_608053, url, valid)

proc call*(call_608054: Call_GetDescribeNodeConfigurationOptions_608034;
          Marker: string = ""; SnapshotIdentifier: string = "";
          ActionType: string = "restore-cluster"; Filter: JsonNode = nil;
          Action: string = "DescribeNodeConfigurationOptions";
          ClusterIdentifier: string = ""; OwnerAccount: string = "";
          Version: string = "2012-12-01"; MaxRecords: int = 0): Recallable =
  ## getDescribeNodeConfigurationOptions
  ## Returns properties of possible node configurations such as node type, number of nodes, and disk usage for the specified action type.
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeNodeConfigurationOptions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   SnapshotIdentifier: string
  ##                     : The identifier of the snapshot to evaluate for possible node configurations.
  ##   ActionType: string (required)
  ##             : The action type to evaluate for possible node configurations. Specify "restore-cluster" to get configuration combinations based on an existing snapshot. Specify "recommend-node-config" to get configuration recommendations based on an existing cluster or snapshot. 
  ##   Filter: JArray
  ##         : A set of name, operator, and value items to filter the results.
  ##   Action: string (required)
  ##   ClusterIdentifier: string
  ##                    : The identifier of the cluster to evaluate for possible node configurations.
  ##   OwnerAccount: string
  ##               : The AWS customer account used to create or copy the snapshot. Required if you are restoring a snapshot you do not own, optional if you own the snapshot.
  ##   Version: string (required)
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>500</code> </p> <p>Constraints: minimum 100, maximum 500.</p>
  var query_608055 = newJObject()
  add(query_608055, "Marker", newJString(Marker))
  add(query_608055, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_608055, "ActionType", newJString(ActionType))
  if Filter != nil:
    query_608055.add "Filter", Filter
  add(query_608055, "Action", newJString(Action))
  add(query_608055, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_608055, "OwnerAccount", newJString(OwnerAccount))
  add(query_608055, "Version", newJString(Version))
  add(query_608055, "MaxRecords", newJInt(MaxRecords))
  result = call_608054.call(nil, query_608055, nil, nil, nil)

var getDescribeNodeConfigurationOptions* = Call_GetDescribeNodeConfigurationOptions_608034(
    name: "getDescribeNodeConfigurationOptions", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeNodeConfigurationOptions",
    validator: validate_GetDescribeNodeConfigurationOptions_608035, base: "/",
    url: url_GetDescribeNodeConfigurationOptions_608036,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeOrderableClusterOptions_608098 = ref object of OpenApiRestCall_605573
proc url_PostDescribeOrderableClusterOptions_608100(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeOrderableClusterOptions_608099(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns a list of orderable cluster options. Before you create a new cluster you can use this operation to find what options are available, such as the EC2 Availability Zones (AZ) in the specific AWS Region that you can specify, and the node types you can request. The node types differ by available storage, memory, CPU and price. With the cost involved you might want to obtain a list of cluster options in the specific region and specify values when creating a cluster. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_608101 = query.getOrDefault("Action")
  valid_608101 = validateParameter(valid_608101, JString, required = true, default = newJString(
      "DescribeOrderableClusterOptions"))
  if valid_608101 != nil:
    section.add "Action", valid_608101
  var valid_608102 = query.getOrDefault("Version")
  valid_608102 = validateParameter(valid_608102, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_608102 != nil:
    section.add "Version", valid_608102
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_608103 = header.getOrDefault("X-Amz-Signature")
  valid_608103 = validateParameter(valid_608103, JString, required = false,
                                 default = nil)
  if valid_608103 != nil:
    section.add "X-Amz-Signature", valid_608103
  var valid_608104 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_608104 = validateParameter(valid_608104, JString, required = false,
                                 default = nil)
  if valid_608104 != nil:
    section.add "X-Amz-Content-Sha256", valid_608104
  var valid_608105 = header.getOrDefault("X-Amz-Date")
  valid_608105 = validateParameter(valid_608105, JString, required = false,
                                 default = nil)
  if valid_608105 != nil:
    section.add "X-Amz-Date", valid_608105
  var valid_608106 = header.getOrDefault("X-Amz-Credential")
  valid_608106 = validateParameter(valid_608106, JString, required = false,
                                 default = nil)
  if valid_608106 != nil:
    section.add "X-Amz-Credential", valid_608106
  var valid_608107 = header.getOrDefault("X-Amz-Security-Token")
  valid_608107 = validateParameter(valid_608107, JString, required = false,
                                 default = nil)
  if valid_608107 != nil:
    section.add "X-Amz-Security-Token", valid_608107
  var valid_608108 = header.getOrDefault("X-Amz-Algorithm")
  valid_608108 = validateParameter(valid_608108, JString, required = false,
                                 default = nil)
  if valid_608108 != nil:
    section.add "X-Amz-Algorithm", valid_608108
  var valid_608109 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_608109 = validateParameter(valid_608109, JString, required = false,
                                 default = nil)
  if valid_608109 != nil:
    section.add "X-Amz-SignedHeaders", valid_608109
  result.add "header", section
  ## parameters in `formData` object:
  ##   NodeType: JString
  ##           : The node type filter value. Specify this parameter to show only the available offerings matching the specified node type.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeOrderableClusterOptions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   ClusterVersion: JString
  ##                 : <p>The version filter value. Specify this parameter to show only the available offerings matching the specified version.</p> <p>Default: All versions.</p> <p>Constraints: Must be one of the version returned from <a>DescribeClusterVersions</a>.</p>
  section = newJObject()
  var valid_608110 = formData.getOrDefault("NodeType")
  valid_608110 = validateParameter(valid_608110, JString, required = false,
                                 default = nil)
  if valid_608110 != nil:
    section.add "NodeType", valid_608110
  var valid_608111 = formData.getOrDefault("MaxRecords")
  valid_608111 = validateParameter(valid_608111, JInt, required = false, default = nil)
  if valid_608111 != nil:
    section.add "MaxRecords", valid_608111
  var valid_608112 = formData.getOrDefault("Marker")
  valid_608112 = validateParameter(valid_608112, JString, required = false,
                                 default = nil)
  if valid_608112 != nil:
    section.add "Marker", valid_608112
  var valid_608113 = formData.getOrDefault("ClusterVersion")
  valid_608113 = validateParameter(valid_608113, JString, required = false,
                                 default = nil)
  if valid_608113 != nil:
    section.add "ClusterVersion", valid_608113
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_608114: Call_PostDescribeOrderableClusterOptions_608098;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Returns a list of orderable cluster options. Before you create a new cluster you can use this operation to find what options are available, such as the EC2 Availability Zones (AZ) in the specific AWS Region that you can specify, and the node types you can request. The node types differ by available storage, memory, CPU and price. With the cost involved you might want to obtain a list of cluster options in the specific region and specify values when creating a cluster. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.
  ## 
  let valid = call_608114.validator(path, query, header, formData, body)
  let scheme = call_608114.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_608114.url(scheme.get, call_608114.host, call_608114.base,
                         call_608114.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_608114, url, valid)

proc call*(call_608115: Call_PostDescribeOrderableClusterOptions_608098;
          NodeType: string = ""; MaxRecords: int = 0; Marker: string = "";
          Action: string = "DescribeOrderableClusterOptions";
          ClusterVersion: string = ""; Version: string = "2012-12-01"): Recallable =
  ## postDescribeOrderableClusterOptions
  ## Returns a list of orderable cluster options. Before you create a new cluster you can use this operation to find what options are available, such as the EC2 Availability Zones (AZ) in the specific AWS Region that you can specify, and the node types you can request. The node types differ by available storage, memory, CPU and price. With the cost involved you might want to obtain a list of cluster options in the specific region and specify values when creating a cluster. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.
  ##   NodeType: string
  ##           : The node type filter value. Specify this parameter to show only the available offerings matching the specified node type.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeOrderableClusterOptions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Action: string (required)
  ##   ClusterVersion: string
  ##                 : <p>The version filter value. Specify this parameter to show only the available offerings matching the specified version.</p> <p>Default: All versions.</p> <p>Constraints: Must be one of the version returned from <a>DescribeClusterVersions</a>.</p>
  ##   Version: string (required)
  var query_608116 = newJObject()
  var formData_608117 = newJObject()
  add(formData_608117, "NodeType", newJString(NodeType))
  add(formData_608117, "MaxRecords", newJInt(MaxRecords))
  add(formData_608117, "Marker", newJString(Marker))
  add(query_608116, "Action", newJString(Action))
  add(formData_608117, "ClusterVersion", newJString(ClusterVersion))
  add(query_608116, "Version", newJString(Version))
  result = call_608115.call(nil, query_608116, nil, formData_608117, nil)

var postDescribeOrderableClusterOptions* = Call_PostDescribeOrderableClusterOptions_608098(
    name: "postDescribeOrderableClusterOptions", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeOrderableClusterOptions",
    validator: validate_PostDescribeOrderableClusterOptions_608099, base: "/",
    url: url_PostDescribeOrderableClusterOptions_608100,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeOrderableClusterOptions_608079 = ref object of OpenApiRestCall_605573
proc url_GetDescribeOrderableClusterOptions_608081(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeOrderableClusterOptions_608080(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns a list of orderable cluster options. Before you create a new cluster you can use this operation to find what options are available, such as the EC2 Availability Zones (AZ) in the specific AWS Region that you can specify, and the node types you can request. The node types differ by available storage, memory, CPU and price. With the cost involved you might want to obtain a list of cluster options in the specific region and specify values when creating a cluster. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeOrderableClusterOptions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   ClusterVersion: JString
  ##                 : <p>The version filter value. Specify this parameter to show only the available offerings matching the specified version.</p> <p>Default: All versions.</p> <p>Constraints: Must be one of the version returned from <a>DescribeClusterVersions</a>.</p>
  ##   NodeType: JString
  ##           : The node type filter value. Specify this parameter to show only the available offerings matching the specified node type.
  ##   Action: JString (required)
  ##   Version: JString (required)
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  section = newJObject()
  var valid_608082 = query.getOrDefault("Marker")
  valid_608082 = validateParameter(valid_608082, JString, required = false,
                                 default = nil)
  if valid_608082 != nil:
    section.add "Marker", valid_608082
  var valid_608083 = query.getOrDefault("ClusterVersion")
  valid_608083 = validateParameter(valid_608083, JString, required = false,
                                 default = nil)
  if valid_608083 != nil:
    section.add "ClusterVersion", valid_608083
  var valid_608084 = query.getOrDefault("NodeType")
  valid_608084 = validateParameter(valid_608084, JString, required = false,
                                 default = nil)
  if valid_608084 != nil:
    section.add "NodeType", valid_608084
  var valid_608085 = query.getOrDefault("Action")
  valid_608085 = validateParameter(valid_608085, JString, required = true, default = newJString(
      "DescribeOrderableClusterOptions"))
  if valid_608085 != nil:
    section.add "Action", valid_608085
  var valid_608086 = query.getOrDefault("Version")
  valid_608086 = validateParameter(valid_608086, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_608086 != nil:
    section.add "Version", valid_608086
  var valid_608087 = query.getOrDefault("MaxRecords")
  valid_608087 = validateParameter(valid_608087, JInt, required = false, default = nil)
  if valid_608087 != nil:
    section.add "MaxRecords", valid_608087
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_608088 = header.getOrDefault("X-Amz-Signature")
  valid_608088 = validateParameter(valid_608088, JString, required = false,
                                 default = nil)
  if valid_608088 != nil:
    section.add "X-Amz-Signature", valid_608088
  var valid_608089 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_608089 = validateParameter(valid_608089, JString, required = false,
                                 default = nil)
  if valid_608089 != nil:
    section.add "X-Amz-Content-Sha256", valid_608089
  var valid_608090 = header.getOrDefault("X-Amz-Date")
  valid_608090 = validateParameter(valid_608090, JString, required = false,
                                 default = nil)
  if valid_608090 != nil:
    section.add "X-Amz-Date", valid_608090
  var valid_608091 = header.getOrDefault("X-Amz-Credential")
  valid_608091 = validateParameter(valid_608091, JString, required = false,
                                 default = nil)
  if valid_608091 != nil:
    section.add "X-Amz-Credential", valid_608091
  var valid_608092 = header.getOrDefault("X-Amz-Security-Token")
  valid_608092 = validateParameter(valid_608092, JString, required = false,
                                 default = nil)
  if valid_608092 != nil:
    section.add "X-Amz-Security-Token", valid_608092
  var valid_608093 = header.getOrDefault("X-Amz-Algorithm")
  valid_608093 = validateParameter(valid_608093, JString, required = false,
                                 default = nil)
  if valid_608093 != nil:
    section.add "X-Amz-Algorithm", valid_608093
  var valid_608094 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_608094 = validateParameter(valid_608094, JString, required = false,
                                 default = nil)
  if valid_608094 != nil:
    section.add "X-Amz-SignedHeaders", valid_608094
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_608095: Call_GetDescribeOrderableClusterOptions_608079;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Returns a list of orderable cluster options. Before you create a new cluster you can use this operation to find what options are available, such as the EC2 Availability Zones (AZ) in the specific AWS Region that you can specify, and the node types you can request. The node types differ by available storage, memory, CPU and price. With the cost involved you might want to obtain a list of cluster options in the specific region and specify values when creating a cluster. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.
  ## 
  let valid = call_608095.validator(path, query, header, formData, body)
  let scheme = call_608095.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_608095.url(scheme.get, call_608095.host, call_608095.base,
                         call_608095.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_608095, url, valid)

proc call*(call_608096: Call_GetDescribeOrderableClusterOptions_608079;
          Marker: string = ""; ClusterVersion: string = ""; NodeType: string = "";
          Action: string = "DescribeOrderableClusterOptions";
          Version: string = "2012-12-01"; MaxRecords: int = 0): Recallable =
  ## getDescribeOrderableClusterOptions
  ## Returns a list of orderable cluster options. Before you create a new cluster you can use this operation to find what options are available, such as the EC2 Availability Zones (AZ) in the specific AWS Region that you can specify, and the node types you can request. The node types differ by available storage, memory, CPU and price. With the cost involved you might want to obtain a list of cluster options in the specific region and specify values when creating a cluster. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeOrderableClusterOptions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   ClusterVersion: string
  ##                 : <p>The version filter value. Specify this parameter to show only the available offerings matching the specified version.</p> <p>Default: All versions.</p> <p>Constraints: Must be one of the version returned from <a>DescribeClusterVersions</a>.</p>
  ##   NodeType: string
  ##           : The node type filter value. Specify this parameter to show only the available offerings matching the specified node type.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  var query_608097 = newJObject()
  add(query_608097, "Marker", newJString(Marker))
  add(query_608097, "ClusterVersion", newJString(ClusterVersion))
  add(query_608097, "NodeType", newJString(NodeType))
  add(query_608097, "Action", newJString(Action))
  add(query_608097, "Version", newJString(Version))
  add(query_608097, "MaxRecords", newJInt(MaxRecords))
  result = call_608096.call(nil, query_608097, nil, nil, nil)

var getDescribeOrderableClusterOptions* = Call_GetDescribeOrderableClusterOptions_608079(
    name: "getDescribeOrderableClusterOptions", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeOrderableClusterOptions",
    validator: validate_GetDescribeOrderableClusterOptions_608080, base: "/",
    url: url_GetDescribeOrderableClusterOptions_608081,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeReservedNodeOfferings_608136 = ref object of OpenApiRestCall_605573
proc url_PostDescribeReservedNodeOfferings_608138(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeReservedNodeOfferings_608137(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns a list of the available reserved node offerings by Amazon Redshift with their descriptions including the node type, the fixed and recurring costs of reserving the node and duration the node will be reserved for you. These descriptions help you determine which reserve node offering you want to purchase. You then use the unique offering ID in you call to <a>PurchaseReservedNodeOffering</a> to reserve one or more nodes for your Amazon Redshift cluster. </p> <p> For more information about reserved node offerings, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_608139 = query.getOrDefault("Action")
  valid_608139 = validateParameter(valid_608139, JString, required = true, default = newJString(
      "DescribeReservedNodeOfferings"))
  if valid_608139 != nil:
    section.add "Action", valid_608139
  var valid_608140 = query.getOrDefault("Version")
  valid_608140 = validateParameter(valid_608140, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_608140 != nil:
    section.add "Version", valid_608140
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_608141 = header.getOrDefault("X-Amz-Signature")
  valid_608141 = validateParameter(valid_608141, JString, required = false,
                                 default = nil)
  if valid_608141 != nil:
    section.add "X-Amz-Signature", valid_608141
  var valid_608142 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_608142 = validateParameter(valid_608142, JString, required = false,
                                 default = nil)
  if valid_608142 != nil:
    section.add "X-Amz-Content-Sha256", valid_608142
  var valid_608143 = header.getOrDefault("X-Amz-Date")
  valid_608143 = validateParameter(valid_608143, JString, required = false,
                                 default = nil)
  if valid_608143 != nil:
    section.add "X-Amz-Date", valid_608143
  var valid_608144 = header.getOrDefault("X-Amz-Credential")
  valid_608144 = validateParameter(valid_608144, JString, required = false,
                                 default = nil)
  if valid_608144 != nil:
    section.add "X-Amz-Credential", valid_608144
  var valid_608145 = header.getOrDefault("X-Amz-Security-Token")
  valid_608145 = validateParameter(valid_608145, JString, required = false,
                                 default = nil)
  if valid_608145 != nil:
    section.add "X-Amz-Security-Token", valid_608145
  var valid_608146 = header.getOrDefault("X-Amz-Algorithm")
  valid_608146 = validateParameter(valid_608146, JString, required = false,
                                 default = nil)
  if valid_608146 != nil:
    section.add "X-Amz-Algorithm", valid_608146
  var valid_608147 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_608147 = validateParameter(valid_608147, JString, required = false,
                                 default = nil)
  if valid_608147 != nil:
    section.add "X-Amz-SignedHeaders", valid_608147
  result.add "header", section
  ## parameters in `formData` object:
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   ReservedNodeOfferingId: JString
  ##                         : The unique identifier for the offering.
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeReservedNodeOfferings</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  section = newJObject()
  var valid_608148 = formData.getOrDefault("MaxRecords")
  valid_608148 = validateParameter(valid_608148, JInt, required = false, default = nil)
  if valid_608148 != nil:
    section.add "MaxRecords", valid_608148
  var valid_608149 = formData.getOrDefault("ReservedNodeOfferingId")
  valid_608149 = validateParameter(valid_608149, JString, required = false,
                                 default = nil)
  if valid_608149 != nil:
    section.add "ReservedNodeOfferingId", valid_608149
  var valid_608150 = formData.getOrDefault("Marker")
  valid_608150 = validateParameter(valid_608150, JString, required = false,
                                 default = nil)
  if valid_608150 != nil:
    section.add "Marker", valid_608150
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_608151: Call_PostDescribeReservedNodeOfferings_608136;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Returns a list of the available reserved node offerings by Amazon Redshift with their descriptions including the node type, the fixed and recurring costs of reserving the node and duration the node will be reserved for you. These descriptions help you determine which reserve node offering you want to purchase. You then use the unique offering ID in you call to <a>PurchaseReservedNodeOffering</a> to reserve one or more nodes for your Amazon Redshift cluster. </p> <p> For more information about reserved node offerings, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_608151.validator(path, query, header, formData, body)
  let scheme = call_608151.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_608151.url(scheme.get, call_608151.host, call_608151.base,
                         call_608151.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_608151, url, valid)

proc call*(call_608152: Call_PostDescribeReservedNodeOfferings_608136;
          MaxRecords: int = 0; ReservedNodeOfferingId: string = ""; Marker: string = "";
          Action: string = "DescribeReservedNodeOfferings";
          Version: string = "2012-12-01"): Recallable =
  ## postDescribeReservedNodeOfferings
  ## <p>Returns a list of the available reserved node offerings by Amazon Redshift with their descriptions including the node type, the fixed and recurring costs of reserving the node and duration the node will be reserved for you. These descriptions help you determine which reserve node offering you want to purchase. You then use the unique offering ID in you call to <a>PurchaseReservedNodeOffering</a> to reserve one or more nodes for your Amazon Redshift cluster. </p> <p> For more information about reserved node offerings, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   ReservedNodeOfferingId: string
  ##                         : The unique identifier for the offering.
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeReservedNodeOfferings</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Action: string (required)
  ##   Version: string (required)
  var query_608153 = newJObject()
  var formData_608154 = newJObject()
  add(formData_608154, "MaxRecords", newJInt(MaxRecords))
  add(formData_608154, "ReservedNodeOfferingId",
      newJString(ReservedNodeOfferingId))
  add(formData_608154, "Marker", newJString(Marker))
  add(query_608153, "Action", newJString(Action))
  add(query_608153, "Version", newJString(Version))
  result = call_608152.call(nil, query_608153, nil, formData_608154, nil)

var postDescribeReservedNodeOfferings* = Call_PostDescribeReservedNodeOfferings_608136(
    name: "postDescribeReservedNodeOfferings", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeReservedNodeOfferings",
    validator: validate_PostDescribeReservedNodeOfferings_608137, base: "/",
    url: url_PostDescribeReservedNodeOfferings_608138,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeReservedNodeOfferings_608118 = ref object of OpenApiRestCall_605573
proc url_GetDescribeReservedNodeOfferings_608120(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeReservedNodeOfferings_608119(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns a list of the available reserved node offerings by Amazon Redshift with their descriptions including the node type, the fixed and recurring costs of reserving the node and duration the node will be reserved for you. These descriptions help you determine which reserve node offering you want to purchase. You then use the unique offering ID in you call to <a>PurchaseReservedNodeOffering</a> to reserve one or more nodes for your Amazon Redshift cluster. </p> <p> For more information about reserved node offerings, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeReservedNodeOfferings</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   ReservedNodeOfferingId: JString
  ##                         : The unique identifier for the offering.
  ##   Action: JString (required)
  ##   Version: JString (required)
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  section = newJObject()
  var valid_608121 = query.getOrDefault("Marker")
  valid_608121 = validateParameter(valid_608121, JString, required = false,
                                 default = nil)
  if valid_608121 != nil:
    section.add "Marker", valid_608121
  var valid_608122 = query.getOrDefault("ReservedNodeOfferingId")
  valid_608122 = validateParameter(valid_608122, JString, required = false,
                                 default = nil)
  if valid_608122 != nil:
    section.add "ReservedNodeOfferingId", valid_608122
  var valid_608123 = query.getOrDefault("Action")
  valid_608123 = validateParameter(valid_608123, JString, required = true, default = newJString(
      "DescribeReservedNodeOfferings"))
  if valid_608123 != nil:
    section.add "Action", valid_608123
  var valid_608124 = query.getOrDefault("Version")
  valid_608124 = validateParameter(valid_608124, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_608124 != nil:
    section.add "Version", valid_608124
  var valid_608125 = query.getOrDefault("MaxRecords")
  valid_608125 = validateParameter(valid_608125, JInt, required = false, default = nil)
  if valid_608125 != nil:
    section.add "MaxRecords", valid_608125
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_608126 = header.getOrDefault("X-Amz-Signature")
  valid_608126 = validateParameter(valid_608126, JString, required = false,
                                 default = nil)
  if valid_608126 != nil:
    section.add "X-Amz-Signature", valid_608126
  var valid_608127 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_608127 = validateParameter(valid_608127, JString, required = false,
                                 default = nil)
  if valid_608127 != nil:
    section.add "X-Amz-Content-Sha256", valid_608127
  var valid_608128 = header.getOrDefault("X-Amz-Date")
  valid_608128 = validateParameter(valid_608128, JString, required = false,
                                 default = nil)
  if valid_608128 != nil:
    section.add "X-Amz-Date", valid_608128
  var valid_608129 = header.getOrDefault("X-Amz-Credential")
  valid_608129 = validateParameter(valid_608129, JString, required = false,
                                 default = nil)
  if valid_608129 != nil:
    section.add "X-Amz-Credential", valid_608129
  var valid_608130 = header.getOrDefault("X-Amz-Security-Token")
  valid_608130 = validateParameter(valid_608130, JString, required = false,
                                 default = nil)
  if valid_608130 != nil:
    section.add "X-Amz-Security-Token", valid_608130
  var valid_608131 = header.getOrDefault("X-Amz-Algorithm")
  valid_608131 = validateParameter(valid_608131, JString, required = false,
                                 default = nil)
  if valid_608131 != nil:
    section.add "X-Amz-Algorithm", valid_608131
  var valid_608132 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_608132 = validateParameter(valid_608132, JString, required = false,
                                 default = nil)
  if valid_608132 != nil:
    section.add "X-Amz-SignedHeaders", valid_608132
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_608133: Call_GetDescribeReservedNodeOfferings_608118;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Returns a list of the available reserved node offerings by Amazon Redshift with their descriptions including the node type, the fixed and recurring costs of reserving the node and duration the node will be reserved for you. These descriptions help you determine which reserve node offering you want to purchase. You then use the unique offering ID in you call to <a>PurchaseReservedNodeOffering</a> to reserve one or more nodes for your Amazon Redshift cluster. </p> <p> For more information about reserved node offerings, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_608133.validator(path, query, header, formData, body)
  let scheme = call_608133.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_608133.url(scheme.get, call_608133.host, call_608133.base,
                         call_608133.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_608133, url, valid)

proc call*(call_608134: Call_GetDescribeReservedNodeOfferings_608118;
          Marker: string = ""; ReservedNodeOfferingId: string = "";
          Action: string = "DescribeReservedNodeOfferings";
          Version: string = "2012-12-01"; MaxRecords: int = 0): Recallable =
  ## getDescribeReservedNodeOfferings
  ## <p>Returns a list of the available reserved node offerings by Amazon Redshift with their descriptions including the node type, the fixed and recurring costs of reserving the node and duration the node will be reserved for you. These descriptions help you determine which reserve node offering you want to purchase. You then use the unique offering ID in you call to <a>PurchaseReservedNodeOffering</a> to reserve one or more nodes for your Amazon Redshift cluster. </p> <p> For more information about reserved node offerings, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeReservedNodeOfferings</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   ReservedNodeOfferingId: string
  ##                         : The unique identifier for the offering.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  var query_608135 = newJObject()
  add(query_608135, "Marker", newJString(Marker))
  add(query_608135, "ReservedNodeOfferingId", newJString(ReservedNodeOfferingId))
  add(query_608135, "Action", newJString(Action))
  add(query_608135, "Version", newJString(Version))
  add(query_608135, "MaxRecords", newJInt(MaxRecords))
  result = call_608134.call(nil, query_608135, nil, nil, nil)

var getDescribeReservedNodeOfferings* = Call_GetDescribeReservedNodeOfferings_608118(
    name: "getDescribeReservedNodeOfferings", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeReservedNodeOfferings",
    validator: validate_GetDescribeReservedNodeOfferings_608119, base: "/",
    url: url_GetDescribeReservedNodeOfferings_608120,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeReservedNodes_608173 = ref object of OpenApiRestCall_605573
proc url_PostDescribeReservedNodes_608175(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeReservedNodes_608174(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns the descriptions of the reserved nodes.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_608176 = query.getOrDefault("Action")
  valid_608176 = validateParameter(valid_608176, JString, required = true,
                                 default = newJString("DescribeReservedNodes"))
  if valid_608176 != nil:
    section.add "Action", valid_608176
  var valid_608177 = query.getOrDefault("Version")
  valid_608177 = validateParameter(valid_608177, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_608177 != nil:
    section.add "Version", valid_608177
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_608178 = header.getOrDefault("X-Amz-Signature")
  valid_608178 = validateParameter(valid_608178, JString, required = false,
                                 default = nil)
  if valid_608178 != nil:
    section.add "X-Amz-Signature", valid_608178
  var valid_608179 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_608179 = validateParameter(valid_608179, JString, required = false,
                                 default = nil)
  if valid_608179 != nil:
    section.add "X-Amz-Content-Sha256", valid_608179
  var valid_608180 = header.getOrDefault("X-Amz-Date")
  valid_608180 = validateParameter(valid_608180, JString, required = false,
                                 default = nil)
  if valid_608180 != nil:
    section.add "X-Amz-Date", valid_608180
  var valid_608181 = header.getOrDefault("X-Amz-Credential")
  valid_608181 = validateParameter(valid_608181, JString, required = false,
                                 default = nil)
  if valid_608181 != nil:
    section.add "X-Amz-Credential", valid_608181
  var valid_608182 = header.getOrDefault("X-Amz-Security-Token")
  valid_608182 = validateParameter(valid_608182, JString, required = false,
                                 default = nil)
  if valid_608182 != nil:
    section.add "X-Amz-Security-Token", valid_608182
  var valid_608183 = header.getOrDefault("X-Amz-Algorithm")
  valid_608183 = validateParameter(valid_608183, JString, required = false,
                                 default = nil)
  if valid_608183 != nil:
    section.add "X-Amz-Algorithm", valid_608183
  var valid_608184 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_608184 = validateParameter(valid_608184, JString, required = false,
                                 default = nil)
  if valid_608184 != nil:
    section.add "X-Amz-SignedHeaders", valid_608184
  result.add "header", section
  ## parameters in `formData` object:
  ##   ReservedNodeId: JString
  ##                 : Identifier for the node reservation.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeReservedNodes</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  section = newJObject()
  var valid_608185 = formData.getOrDefault("ReservedNodeId")
  valid_608185 = validateParameter(valid_608185, JString, required = false,
                                 default = nil)
  if valid_608185 != nil:
    section.add "ReservedNodeId", valid_608185
  var valid_608186 = formData.getOrDefault("MaxRecords")
  valid_608186 = validateParameter(valid_608186, JInt, required = false, default = nil)
  if valid_608186 != nil:
    section.add "MaxRecords", valid_608186
  var valid_608187 = formData.getOrDefault("Marker")
  valid_608187 = validateParameter(valid_608187, JString, required = false,
                                 default = nil)
  if valid_608187 != nil:
    section.add "Marker", valid_608187
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_608188: Call_PostDescribeReservedNodes_608173; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns the descriptions of the reserved nodes.
  ## 
  let valid = call_608188.validator(path, query, header, formData, body)
  let scheme = call_608188.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_608188.url(scheme.get, call_608188.host, call_608188.base,
                         call_608188.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_608188, url, valid)

proc call*(call_608189: Call_PostDescribeReservedNodes_608173;
          ReservedNodeId: string = ""; MaxRecords: int = 0; Marker: string = "";
          Action: string = "DescribeReservedNodes"; Version: string = "2012-12-01"): Recallable =
  ## postDescribeReservedNodes
  ## Returns the descriptions of the reserved nodes.
  ##   ReservedNodeId: string
  ##                 : Identifier for the node reservation.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeReservedNodes</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Action: string (required)
  ##   Version: string (required)
  var query_608190 = newJObject()
  var formData_608191 = newJObject()
  add(formData_608191, "ReservedNodeId", newJString(ReservedNodeId))
  add(formData_608191, "MaxRecords", newJInt(MaxRecords))
  add(formData_608191, "Marker", newJString(Marker))
  add(query_608190, "Action", newJString(Action))
  add(query_608190, "Version", newJString(Version))
  result = call_608189.call(nil, query_608190, nil, formData_608191, nil)

var postDescribeReservedNodes* = Call_PostDescribeReservedNodes_608173(
    name: "postDescribeReservedNodes", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeReservedNodes",
    validator: validate_PostDescribeReservedNodes_608174, base: "/",
    url: url_PostDescribeReservedNodes_608175,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeReservedNodes_608155 = ref object of OpenApiRestCall_605573
proc url_GetDescribeReservedNodes_608157(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeReservedNodes_608156(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns the descriptions of the reserved nodes.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeReservedNodes</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Action: JString (required)
  ##   ReservedNodeId: JString
  ##                 : Identifier for the node reservation.
  ##   Version: JString (required)
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  section = newJObject()
  var valid_608158 = query.getOrDefault("Marker")
  valid_608158 = validateParameter(valid_608158, JString, required = false,
                                 default = nil)
  if valid_608158 != nil:
    section.add "Marker", valid_608158
  var valid_608159 = query.getOrDefault("Action")
  valid_608159 = validateParameter(valid_608159, JString, required = true,
                                 default = newJString("DescribeReservedNodes"))
  if valid_608159 != nil:
    section.add "Action", valid_608159
  var valid_608160 = query.getOrDefault("ReservedNodeId")
  valid_608160 = validateParameter(valid_608160, JString, required = false,
                                 default = nil)
  if valid_608160 != nil:
    section.add "ReservedNodeId", valid_608160
  var valid_608161 = query.getOrDefault("Version")
  valid_608161 = validateParameter(valid_608161, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_608161 != nil:
    section.add "Version", valid_608161
  var valid_608162 = query.getOrDefault("MaxRecords")
  valid_608162 = validateParameter(valid_608162, JInt, required = false, default = nil)
  if valid_608162 != nil:
    section.add "MaxRecords", valid_608162
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_608163 = header.getOrDefault("X-Amz-Signature")
  valid_608163 = validateParameter(valid_608163, JString, required = false,
                                 default = nil)
  if valid_608163 != nil:
    section.add "X-Amz-Signature", valid_608163
  var valid_608164 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_608164 = validateParameter(valid_608164, JString, required = false,
                                 default = nil)
  if valid_608164 != nil:
    section.add "X-Amz-Content-Sha256", valid_608164
  var valid_608165 = header.getOrDefault("X-Amz-Date")
  valid_608165 = validateParameter(valid_608165, JString, required = false,
                                 default = nil)
  if valid_608165 != nil:
    section.add "X-Amz-Date", valid_608165
  var valid_608166 = header.getOrDefault("X-Amz-Credential")
  valid_608166 = validateParameter(valid_608166, JString, required = false,
                                 default = nil)
  if valid_608166 != nil:
    section.add "X-Amz-Credential", valid_608166
  var valid_608167 = header.getOrDefault("X-Amz-Security-Token")
  valid_608167 = validateParameter(valid_608167, JString, required = false,
                                 default = nil)
  if valid_608167 != nil:
    section.add "X-Amz-Security-Token", valid_608167
  var valid_608168 = header.getOrDefault("X-Amz-Algorithm")
  valid_608168 = validateParameter(valid_608168, JString, required = false,
                                 default = nil)
  if valid_608168 != nil:
    section.add "X-Amz-Algorithm", valid_608168
  var valid_608169 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_608169 = validateParameter(valid_608169, JString, required = false,
                                 default = nil)
  if valid_608169 != nil:
    section.add "X-Amz-SignedHeaders", valid_608169
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_608170: Call_GetDescribeReservedNodes_608155; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns the descriptions of the reserved nodes.
  ## 
  let valid = call_608170.validator(path, query, header, formData, body)
  let scheme = call_608170.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_608170.url(scheme.get, call_608170.host, call_608170.base,
                         call_608170.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_608170, url, valid)

proc call*(call_608171: Call_GetDescribeReservedNodes_608155; Marker: string = "";
          Action: string = "DescribeReservedNodes"; ReservedNodeId: string = "";
          Version: string = "2012-12-01"; MaxRecords: int = 0): Recallable =
  ## getDescribeReservedNodes
  ## Returns the descriptions of the reserved nodes.
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeReservedNodes</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Action: string (required)
  ##   ReservedNodeId: string
  ##                 : Identifier for the node reservation.
  ##   Version: string (required)
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  var query_608172 = newJObject()
  add(query_608172, "Marker", newJString(Marker))
  add(query_608172, "Action", newJString(Action))
  add(query_608172, "ReservedNodeId", newJString(ReservedNodeId))
  add(query_608172, "Version", newJString(Version))
  add(query_608172, "MaxRecords", newJInt(MaxRecords))
  result = call_608171.call(nil, query_608172, nil, nil, nil)

var getDescribeReservedNodes* = Call_GetDescribeReservedNodes_608155(
    name: "getDescribeReservedNodes", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeReservedNodes",
    validator: validate_GetDescribeReservedNodes_608156, base: "/",
    url: url_GetDescribeReservedNodes_608157, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeResize_608208 = ref object of OpenApiRestCall_605573
proc url_PostDescribeResize_608210(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeResize_608209(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## <p>Returns information about the last resize operation for the specified cluster. If no resize operation has ever been initiated for the specified cluster, a <code>HTTP 404</code> error is returned. If a resize operation was initiated and completed, the status of the resize remains as <code>SUCCEEDED</code> until the next resize. </p> <p>A resize operation can be requested using <a>ModifyCluster</a> and specifying a different number or type of nodes for the cluster. </p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_608211 = query.getOrDefault("Action")
  valid_608211 = validateParameter(valid_608211, JString, required = true,
                                 default = newJString("DescribeResize"))
  if valid_608211 != nil:
    section.add "Action", valid_608211
  var valid_608212 = query.getOrDefault("Version")
  valid_608212 = validateParameter(valid_608212, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_608212 != nil:
    section.add "Version", valid_608212
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_608213 = header.getOrDefault("X-Amz-Signature")
  valid_608213 = validateParameter(valid_608213, JString, required = false,
                                 default = nil)
  if valid_608213 != nil:
    section.add "X-Amz-Signature", valid_608213
  var valid_608214 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_608214 = validateParameter(valid_608214, JString, required = false,
                                 default = nil)
  if valid_608214 != nil:
    section.add "X-Amz-Content-Sha256", valid_608214
  var valid_608215 = header.getOrDefault("X-Amz-Date")
  valid_608215 = validateParameter(valid_608215, JString, required = false,
                                 default = nil)
  if valid_608215 != nil:
    section.add "X-Amz-Date", valid_608215
  var valid_608216 = header.getOrDefault("X-Amz-Credential")
  valid_608216 = validateParameter(valid_608216, JString, required = false,
                                 default = nil)
  if valid_608216 != nil:
    section.add "X-Amz-Credential", valid_608216
  var valid_608217 = header.getOrDefault("X-Amz-Security-Token")
  valid_608217 = validateParameter(valid_608217, JString, required = false,
                                 default = nil)
  if valid_608217 != nil:
    section.add "X-Amz-Security-Token", valid_608217
  var valid_608218 = header.getOrDefault("X-Amz-Algorithm")
  valid_608218 = validateParameter(valid_608218, JString, required = false,
                                 default = nil)
  if valid_608218 != nil:
    section.add "X-Amz-Algorithm", valid_608218
  var valid_608219 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_608219 = validateParameter(valid_608219, JString, required = false,
                                 default = nil)
  if valid_608219 != nil:
    section.add "X-Amz-SignedHeaders", valid_608219
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of a cluster whose resize progress you are requesting. This parameter is case-sensitive.</p> <p>By default, resize operations for all clusters defined for an AWS account are returned.</p>
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_608220 = formData.getOrDefault("ClusterIdentifier")
  valid_608220 = validateParameter(valid_608220, JString, required = true,
                                 default = nil)
  if valid_608220 != nil:
    section.add "ClusterIdentifier", valid_608220
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_608221: Call_PostDescribeResize_608208; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns information about the last resize operation for the specified cluster. If no resize operation has ever been initiated for the specified cluster, a <code>HTTP 404</code> error is returned. If a resize operation was initiated and completed, the status of the resize remains as <code>SUCCEEDED</code> until the next resize. </p> <p>A resize operation can be requested using <a>ModifyCluster</a> and specifying a different number or type of nodes for the cluster. </p>
  ## 
  let valid = call_608221.validator(path, query, header, formData, body)
  let scheme = call_608221.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_608221.url(scheme.get, call_608221.host, call_608221.base,
                         call_608221.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_608221, url, valid)

proc call*(call_608222: Call_PostDescribeResize_608208; ClusterIdentifier: string;
          Action: string = "DescribeResize"; Version: string = "2012-12-01"): Recallable =
  ## postDescribeResize
  ## <p>Returns information about the last resize operation for the specified cluster. If no resize operation has ever been initiated for the specified cluster, a <code>HTTP 404</code> error is returned. If a resize operation was initiated and completed, the status of the resize remains as <code>SUCCEEDED</code> until the next resize. </p> <p>A resize operation can be requested using <a>ModifyCluster</a> and specifying a different number or type of nodes for the cluster. </p>
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of a cluster whose resize progress you are requesting. This parameter is case-sensitive.</p> <p>By default, resize operations for all clusters defined for an AWS account are returned.</p>
  ##   Action: string (required)
  ##   Version: string (required)
  var query_608223 = newJObject()
  var formData_608224 = newJObject()
  add(formData_608224, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_608223, "Action", newJString(Action))
  add(query_608223, "Version", newJString(Version))
  result = call_608222.call(nil, query_608223, nil, formData_608224, nil)

var postDescribeResize* = Call_PostDescribeResize_608208(
    name: "postDescribeResize", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeResize",
    validator: validate_PostDescribeResize_608209, base: "/",
    url: url_PostDescribeResize_608210, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeResize_608192 = ref object of OpenApiRestCall_605573
proc url_GetDescribeResize_608194(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeResize_608193(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## <p>Returns information about the last resize operation for the specified cluster. If no resize operation has ever been initiated for the specified cluster, a <code>HTTP 404</code> error is returned. If a resize operation was initiated and completed, the status of the resize remains as <code>SUCCEEDED</code> until the next resize. </p> <p>A resize operation can be requested using <a>ModifyCluster</a> and specifying a different number or type of nodes for the cluster. </p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of a cluster whose resize progress you are requesting. This parameter is case-sensitive.</p> <p>By default, resize operations for all clusters defined for an AWS account are returned.</p>
  ##   Version: JString (required)
  section = newJObject()
  var valid_608195 = query.getOrDefault("Action")
  valid_608195 = validateParameter(valid_608195, JString, required = true,
                                 default = newJString("DescribeResize"))
  if valid_608195 != nil:
    section.add "Action", valid_608195
  var valid_608196 = query.getOrDefault("ClusterIdentifier")
  valid_608196 = validateParameter(valid_608196, JString, required = true,
                                 default = nil)
  if valid_608196 != nil:
    section.add "ClusterIdentifier", valid_608196
  var valid_608197 = query.getOrDefault("Version")
  valid_608197 = validateParameter(valid_608197, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_608197 != nil:
    section.add "Version", valid_608197
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_608198 = header.getOrDefault("X-Amz-Signature")
  valid_608198 = validateParameter(valid_608198, JString, required = false,
                                 default = nil)
  if valid_608198 != nil:
    section.add "X-Amz-Signature", valid_608198
  var valid_608199 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_608199 = validateParameter(valid_608199, JString, required = false,
                                 default = nil)
  if valid_608199 != nil:
    section.add "X-Amz-Content-Sha256", valid_608199
  var valid_608200 = header.getOrDefault("X-Amz-Date")
  valid_608200 = validateParameter(valid_608200, JString, required = false,
                                 default = nil)
  if valid_608200 != nil:
    section.add "X-Amz-Date", valid_608200
  var valid_608201 = header.getOrDefault("X-Amz-Credential")
  valid_608201 = validateParameter(valid_608201, JString, required = false,
                                 default = nil)
  if valid_608201 != nil:
    section.add "X-Amz-Credential", valid_608201
  var valid_608202 = header.getOrDefault("X-Amz-Security-Token")
  valid_608202 = validateParameter(valid_608202, JString, required = false,
                                 default = nil)
  if valid_608202 != nil:
    section.add "X-Amz-Security-Token", valid_608202
  var valid_608203 = header.getOrDefault("X-Amz-Algorithm")
  valid_608203 = validateParameter(valid_608203, JString, required = false,
                                 default = nil)
  if valid_608203 != nil:
    section.add "X-Amz-Algorithm", valid_608203
  var valid_608204 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_608204 = validateParameter(valid_608204, JString, required = false,
                                 default = nil)
  if valid_608204 != nil:
    section.add "X-Amz-SignedHeaders", valid_608204
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_608205: Call_GetDescribeResize_608192; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns information about the last resize operation for the specified cluster. If no resize operation has ever been initiated for the specified cluster, a <code>HTTP 404</code> error is returned. If a resize operation was initiated and completed, the status of the resize remains as <code>SUCCEEDED</code> until the next resize. </p> <p>A resize operation can be requested using <a>ModifyCluster</a> and specifying a different number or type of nodes for the cluster. </p>
  ## 
  let valid = call_608205.validator(path, query, header, formData, body)
  let scheme = call_608205.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_608205.url(scheme.get, call_608205.host, call_608205.base,
                         call_608205.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_608205, url, valid)

proc call*(call_608206: Call_GetDescribeResize_608192; ClusterIdentifier: string;
          Action: string = "DescribeResize"; Version: string = "2012-12-01"): Recallable =
  ## getDescribeResize
  ## <p>Returns information about the last resize operation for the specified cluster. If no resize operation has ever been initiated for the specified cluster, a <code>HTTP 404</code> error is returned. If a resize operation was initiated and completed, the status of the resize remains as <code>SUCCEEDED</code> until the next resize. </p> <p>A resize operation can be requested using <a>ModifyCluster</a> and specifying a different number or type of nodes for the cluster. </p>
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of a cluster whose resize progress you are requesting. This parameter is case-sensitive.</p> <p>By default, resize operations for all clusters defined for an AWS account are returned.</p>
  ##   Version: string (required)
  var query_608207 = newJObject()
  add(query_608207, "Action", newJString(Action))
  add(query_608207, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_608207, "Version", newJString(Version))
  result = call_608206.call(nil, query_608207, nil, nil, nil)

var getDescribeResize* = Call_GetDescribeResize_608192(name: "getDescribeResize",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=DescribeResize", validator: validate_GetDescribeResize_608193,
    base: "/", url: url_GetDescribeResize_608194,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeScheduledActions_608248 = ref object of OpenApiRestCall_605573
proc url_PostDescribeScheduledActions_608250(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeScheduledActions_608249(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Describes properties of scheduled actions. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_608251 = query.getOrDefault("Action")
  valid_608251 = validateParameter(valid_608251, JString, required = true, default = newJString(
      "DescribeScheduledActions"))
  if valid_608251 != nil:
    section.add "Action", valid_608251
  var valid_608252 = query.getOrDefault("Version")
  valid_608252 = validateParameter(valid_608252, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_608252 != nil:
    section.add "Version", valid_608252
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_608253 = header.getOrDefault("X-Amz-Signature")
  valid_608253 = validateParameter(valid_608253, JString, required = false,
                                 default = nil)
  if valid_608253 != nil:
    section.add "X-Amz-Signature", valid_608253
  var valid_608254 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_608254 = validateParameter(valid_608254, JString, required = false,
                                 default = nil)
  if valid_608254 != nil:
    section.add "X-Amz-Content-Sha256", valid_608254
  var valid_608255 = header.getOrDefault("X-Amz-Date")
  valid_608255 = validateParameter(valid_608255, JString, required = false,
                                 default = nil)
  if valid_608255 != nil:
    section.add "X-Amz-Date", valid_608255
  var valid_608256 = header.getOrDefault("X-Amz-Credential")
  valid_608256 = validateParameter(valid_608256, JString, required = false,
                                 default = nil)
  if valid_608256 != nil:
    section.add "X-Amz-Credential", valid_608256
  var valid_608257 = header.getOrDefault("X-Amz-Security-Token")
  valid_608257 = validateParameter(valid_608257, JString, required = false,
                                 default = nil)
  if valid_608257 != nil:
    section.add "X-Amz-Security-Token", valid_608257
  var valid_608258 = header.getOrDefault("X-Amz-Algorithm")
  valid_608258 = validateParameter(valid_608258, JString, required = false,
                                 default = nil)
  if valid_608258 != nil:
    section.add "X-Amz-Algorithm", valid_608258
  var valid_608259 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_608259 = validateParameter(valid_608259, JString, required = false,
                                 default = nil)
  if valid_608259 != nil:
    section.add "X-Amz-SignedHeaders", valid_608259
  result.add "header", section
  ## parameters in `formData` object:
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   ScheduledActionName: JString
  ##                      : The name of the scheduled action to retrieve. 
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeScheduledActions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   EndTime: JString
  ##          : The end time in UTC of the scheduled action to retrieve. Only active scheduled actions that have invocations before this time are retrieved.
  ##   StartTime: JString
  ##            : The start time in UTC of the scheduled actions to retrieve. Only active scheduled actions that have invocations after this time are retrieved.
  ##   Filters: JArray
  ##          : List of scheduled action filters. 
  ##   TargetActionType: JString
  ##                   : The type of the scheduled actions to retrieve. 
  ##   Active: JBool
  ##         : If true, retrieve only active scheduled actions. If false, retrieve only disabled scheduled actions. 
  section = newJObject()
  var valid_608260 = formData.getOrDefault("MaxRecords")
  valid_608260 = validateParameter(valid_608260, JInt, required = false, default = nil)
  if valid_608260 != nil:
    section.add "MaxRecords", valid_608260
  var valid_608261 = formData.getOrDefault("ScheduledActionName")
  valid_608261 = validateParameter(valid_608261, JString, required = false,
                                 default = nil)
  if valid_608261 != nil:
    section.add "ScheduledActionName", valid_608261
  var valid_608262 = formData.getOrDefault("Marker")
  valid_608262 = validateParameter(valid_608262, JString, required = false,
                                 default = nil)
  if valid_608262 != nil:
    section.add "Marker", valid_608262
  var valid_608263 = formData.getOrDefault("EndTime")
  valid_608263 = validateParameter(valid_608263, JString, required = false,
                                 default = nil)
  if valid_608263 != nil:
    section.add "EndTime", valid_608263
  var valid_608264 = formData.getOrDefault("StartTime")
  valid_608264 = validateParameter(valid_608264, JString, required = false,
                                 default = nil)
  if valid_608264 != nil:
    section.add "StartTime", valid_608264
  var valid_608265 = formData.getOrDefault("Filters")
  valid_608265 = validateParameter(valid_608265, JArray, required = false,
                                 default = nil)
  if valid_608265 != nil:
    section.add "Filters", valid_608265
  var valid_608266 = formData.getOrDefault("TargetActionType")
  valid_608266 = validateParameter(valid_608266, JString, required = false,
                                 default = newJString("ResizeCluster"))
  if valid_608266 != nil:
    section.add "TargetActionType", valid_608266
  var valid_608267 = formData.getOrDefault("Active")
  valid_608267 = validateParameter(valid_608267, JBool, required = false, default = nil)
  if valid_608267 != nil:
    section.add "Active", valid_608267
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_608268: Call_PostDescribeScheduledActions_608248; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Describes properties of scheduled actions. 
  ## 
  let valid = call_608268.validator(path, query, header, formData, body)
  let scheme = call_608268.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_608268.url(scheme.get, call_608268.host, call_608268.base,
                         call_608268.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_608268, url, valid)

proc call*(call_608269: Call_PostDescribeScheduledActions_608248;
          MaxRecords: int = 0; ScheduledActionName: string = ""; Marker: string = "";
          EndTime: string = ""; StartTime: string = "";
          Action: string = "DescribeScheduledActions"; Filters: JsonNode = nil;
          TargetActionType: string = "ResizeCluster";
          Version: string = "2012-12-01"; Active: bool = false): Recallable =
  ## postDescribeScheduledActions
  ## Describes properties of scheduled actions. 
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   ScheduledActionName: string
  ##                      : The name of the scheduled action to retrieve. 
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeScheduledActions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   EndTime: string
  ##          : The end time in UTC of the scheduled action to retrieve. Only active scheduled actions that have invocations before this time are retrieved.
  ##   StartTime: string
  ##            : The start time in UTC of the scheduled actions to retrieve. Only active scheduled actions that have invocations after this time are retrieved.
  ##   Action: string (required)
  ##   Filters: JArray
  ##          : List of scheduled action filters. 
  ##   TargetActionType: string
  ##                   : The type of the scheduled actions to retrieve. 
  ##   Version: string (required)
  ##   Active: bool
  ##         : If true, retrieve only active scheduled actions. If false, retrieve only disabled scheduled actions. 
  var query_608270 = newJObject()
  var formData_608271 = newJObject()
  add(formData_608271, "MaxRecords", newJInt(MaxRecords))
  add(formData_608271, "ScheduledActionName", newJString(ScheduledActionName))
  add(formData_608271, "Marker", newJString(Marker))
  add(formData_608271, "EndTime", newJString(EndTime))
  add(formData_608271, "StartTime", newJString(StartTime))
  add(query_608270, "Action", newJString(Action))
  if Filters != nil:
    formData_608271.add "Filters", Filters
  add(formData_608271, "TargetActionType", newJString(TargetActionType))
  add(query_608270, "Version", newJString(Version))
  add(formData_608271, "Active", newJBool(Active))
  result = call_608269.call(nil, query_608270, nil, formData_608271, nil)

var postDescribeScheduledActions* = Call_PostDescribeScheduledActions_608248(
    name: "postDescribeScheduledActions", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeScheduledActions",
    validator: validate_PostDescribeScheduledActions_608249, base: "/",
    url: url_PostDescribeScheduledActions_608250,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeScheduledActions_608225 = ref object of OpenApiRestCall_605573
proc url_GetDescribeScheduledActions_608227(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeScheduledActions_608226(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Describes properties of scheduled actions. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeScheduledActions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TargetActionType: JString
  ##                   : The type of the scheduled actions to retrieve. 
  ##   ScheduledActionName: JString
  ##                      : The name of the scheduled action to retrieve. 
  ##   Active: JBool
  ##         : If true, retrieve only active scheduled actions. If false, retrieve only disabled scheduled actions. 
  ##   Action: JString (required)
  ##   StartTime: JString
  ##            : The start time in UTC of the scheduled actions to retrieve. Only active scheduled actions that have invocations after this time are retrieved.
  ##   EndTime: JString
  ##          : The end time in UTC of the scheduled action to retrieve. Only active scheduled actions that have invocations before this time are retrieved.
  ##   Version: JString (required)
  ##   Filters: JArray
  ##          : List of scheduled action filters. 
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  section = newJObject()
  var valid_608228 = query.getOrDefault("Marker")
  valid_608228 = validateParameter(valid_608228, JString, required = false,
                                 default = nil)
  if valid_608228 != nil:
    section.add "Marker", valid_608228
  var valid_608229 = query.getOrDefault("TargetActionType")
  valid_608229 = validateParameter(valid_608229, JString, required = false,
                                 default = newJString("ResizeCluster"))
  if valid_608229 != nil:
    section.add "TargetActionType", valid_608229
  var valid_608230 = query.getOrDefault("ScheduledActionName")
  valid_608230 = validateParameter(valid_608230, JString, required = false,
                                 default = nil)
  if valid_608230 != nil:
    section.add "ScheduledActionName", valid_608230
  var valid_608231 = query.getOrDefault("Active")
  valid_608231 = validateParameter(valid_608231, JBool, required = false, default = nil)
  if valid_608231 != nil:
    section.add "Active", valid_608231
  var valid_608232 = query.getOrDefault("Action")
  valid_608232 = validateParameter(valid_608232, JString, required = true, default = newJString(
      "DescribeScheduledActions"))
  if valid_608232 != nil:
    section.add "Action", valid_608232
  var valid_608233 = query.getOrDefault("StartTime")
  valid_608233 = validateParameter(valid_608233, JString, required = false,
                                 default = nil)
  if valid_608233 != nil:
    section.add "StartTime", valid_608233
  var valid_608234 = query.getOrDefault("EndTime")
  valid_608234 = validateParameter(valid_608234, JString, required = false,
                                 default = nil)
  if valid_608234 != nil:
    section.add "EndTime", valid_608234
  var valid_608235 = query.getOrDefault("Version")
  valid_608235 = validateParameter(valid_608235, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_608235 != nil:
    section.add "Version", valid_608235
  var valid_608236 = query.getOrDefault("Filters")
  valid_608236 = validateParameter(valid_608236, JArray, required = false,
                                 default = nil)
  if valid_608236 != nil:
    section.add "Filters", valid_608236
  var valid_608237 = query.getOrDefault("MaxRecords")
  valid_608237 = validateParameter(valid_608237, JInt, required = false, default = nil)
  if valid_608237 != nil:
    section.add "MaxRecords", valid_608237
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_608238 = header.getOrDefault("X-Amz-Signature")
  valid_608238 = validateParameter(valid_608238, JString, required = false,
                                 default = nil)
  if valid_608238 != nil:
    section.add "X-Amz-Signature", valid_608238
  var valid_608239 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_608239 = validateParameter(valid_608239, JString, required = false,
                                 default = nil)
  if valid_608239 != nil:
    section.add "X-Amz-Content-Sha256", valid_608239
  var valid_608240 = header.getOrDefault("X-Amz-Date")
  valid_608240 = validateParameter(valid_608240, JString, required = false,
                                 default = nil)
  if valid_608240 != nil:
    section.add "X-Amz-Date", valid_608240
  var valid_608241 = header.getOrDefault("X-Amz-Credential")
  valid_608241 = validateParameter(valid_608241, JString, required = false,
                                 default = nil)
  if valid_608241 != nil:
    section.add "X-Amz-Credential", valid_608241
  var valid_608242 = header.getOrDefault("X-Amz-Security-Token")
  valid_608242 = validateParameter(valid_608242, JString, required = false,
                                 default = nil)
  if valid_608242 != nil:
    section.add "X-Amz-Security-Token", valid_608242
  var valid_608243 = header.getOrDefault("X-Amz-Algorithm")
  valid_608243 = validateParameter(valid_608243, JString, required = false,
                                 default = nil)
  if valid_608243 != nil:
    section.add "X-Amz-Algorithm", valid_608243
  var valid_608244 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_608244 = validateParameter(valid_608244, JString, required = false,
                                 default = nil)
  if valid_608244 != nil:
    section.add "X-Amz-SignedHeaders", valid_608244
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_608245: Call_GetDescribeScheduledActions_608225; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Describes properties of scheduled actions. 
  ## 
  let valid = call_608245.validator(path, query, header, formData, body)
  let scheme = call_608245.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_608245.url(scheme.get, call_608245.host, call_608245.base,
                         call_608245.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_608245, url, valid)

proc call*(call_608246: Call_GetDescribeScheduledActions_608225;
          Marker: string = ""; TargetActionType: string = "ResizeCluster";
          ScheduledActionName: string = ""; Active: bool = false;
          Action: string = "DescribeScheduledActions"; StartTime: string = "";
          EndTime: string = ""; Version: string = "2012-12-01"; Filters: JsonNode = nil;
          MaxRecords: int = 0): Recallable =
  ## getDescribeScheduledActions
  ## Describes properties of scheduled actions. 
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeScheduledActions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TargetActionType: string
  ##                   : The type of the scheduled actions to retrieve. 
  ##   ScheduledActionName: string
  ##                      : The name of the scheduled action to retrieve. 
  ##   Active: bool
  ##         : If true, retrieve only active scheduled actions. If false, retrieve only disabled scheduled actions. 
  ##   Action: string (required)
  ##   StartTime: string
  ##            : The start time in UTC of the scheduled actions to retrieve. Only active scheduled actions that have invocations after this time are retrieved.
  ##   EndTime: string
  ##          : The end time in UTC of the scheduled action to retrieve. Only active scheduled actions that have invocations before this time are retrieved.
  ##   Version: string (required)
  ##   Filters: JArray
  ##          : List of scheduled action filters. 
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  var query_608247 = newJObject()
  add(query_608247, "Marker", newJString(Marker))
  add(query_608247, "TargetActionType", newJString(TargetActionType))
  add(query_608247, "ScheduledActionName", newJString(ScheduledActionName))
  add(query_608247, "Active", newJBool(Active))
  add(query_608247, "Action", newJString(Action))
  add(query_608247, "StartTime", newJString(StartTime))
  add(query_608247, "EndTime", newJString(EndTime))
  add(query_608247, "Version", newJString(Version))
  if Filters != nil:
    query_608247.add "Filters", Filters
  add(query_608247, "MaxRecords", newJInt(MaxRecords))
  result = call_608246.call(nil, query_608247, nil, nil, nil)

var getDescribeScheduledActions* = Call_GetDescribeScheduledActions_608225(
    name: "getDescribeScheduledActions", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeScheduledActions",
    validator: validate_GetDescribeScheduledActions_608226, base: "/",
    url: url_GetDescribeScheduledActions_608227,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeSnapshotCopyGrants_608292 = ref object of OpenApiRestCall_605573
proc url_PostDescribeSnapshotCopyGrants_608294(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeSnapshotCopyGrants_608293(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns a list of snapshot copy grants owned by the AWS account in the destination region.</p> <p> For more information about managing snapshot copy grants, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_608295 = query.getOrDefault("Action")
  valid_608295 = validateParameter(valid_608295, JString, required = true, default = newJString(
      "DescribeSnapshotCopyGrants"))
  if valid_608295 != nil:
    section.add "Action", valid_608295
  var valid_608296 = query.getOrDefault("Version")
  valid_608296 = validateParameter(valid_608296, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_608296 != nil:
    section.add "Version", valid_608296
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_608297 = header.getOrDefault("X-Amz-Signature")
  valid_608297 = validateParameter(valid_608297, JString, required = false,
                                 default = nil)
  if valid_608297 != nil:
    section.add "X-Amz-Signature", valid_608297
  var valid_608298 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_608298 = validateParameter(valid_608298, JString, required = false,
                                 default = nil)
  if valid_608298 != nil:
    section.add "X-Amz-Content-Sha256", valid_608298
  var valid_608299 = header.getOrDefault("X-Amz-Date")
  valid_608299 = validateParameter(valid_608299, JString, required = false,
                                 default = nil)
  if valid_608299 != nil:
    section.add "X-Amz-Date", valid_608299
  var valid_608300 = header.getOrDefault("X-Amz-Credential")
  valid_608300 = validateParameter(valid_608300, JString, required = false,
                                 default = nil)
  if valid_608300 != nil:
    section.add "X-Amz-Credential", valid_608300
  var valid_608301 = header.getOrDefault("X-Amz-Security-Token")
  valid_608301 = validateParameter(valid_608301, JString, required = false,
                                 default = nil)
  if valid_608301 != nil:
    section.add "X-Amz-Security-Token", valid_608301
  var valid_608302 = header.getOrDefault("X-Amz-Algorithm")
  valid_608302 = validateParameter(valid_608302, JString, required = false,
                                 default = nil)
  if valid_608302 != nil:
    section.add "X-Amz-Algorithm", valid_608302
  var valid_608303 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_608303 = validateParameter(valid_608303, JString, required = false,
                                 default = nil)
  if valid_608303 != nil:
    section.add "X-Amz-SignedHeaders", valid_608303
  result.add "header", section
  ## parameters in `formData` object:
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching resources that are associated with the specified key or keys. For example, suppose that you have resources tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with all resources that have either or both of these tag keys associated with them.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: JString
  ##         : <p>An optional parameter that specifies the starting point to return a set of response records. When the results of a <code>DescribeSnapshotCopyGrant</code> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <b>SnapshotCopyGrantName</b> parameter or the <b>Marker</b> parameter, but not both. </p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching resources that are associated with the specified value or values. For example, suppose that you have resources tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with all resources that have either or both of these tag values associated with them.
  ##   SnapshotCopyGrantName: JString
  ##                        : The name of the snapshot copy grant.
  section = newJObject()
  var valid_608304 = formData.getOrDefault("TagKeys")
  valid_608304 = validateParameter(valid_608304, JArray, required = false,
                                 default = nil)
  if valid_608304 != nil:
    section.add "TagKeys", valid_608304
  var valid_608305 = formData.getOrDefault("MaxRecords")
  valid_608305 = validateParameter(valid_608305, JInt, required = false, default = nil)
  if valid_608305 != nil:
    section.add "MaxRecords", valid_608305
  var valid_608306 = formData.getOrDefault("Marker")
  valid_608306 = validateParameter(valid_608306, JString, required = false,
                                 default = nil)
  if valid_608306 != nil:
    section.add "Marker", valid_608306
  var valid_608307 = formData.getOrDefault("TagValues")
  valid_608307 = validateParameter(valid_608307, JArray, required = false,
                                 default = nil)
  if valid_608307 != nil:
    section.add "TagValues", valid_608307
  var valid_608308 = formData.getOrDefault("SnapshotCopyGrantName")
  valid_608308 = validateParameter(valid_608308, JString, required = false,
                                 default = nil)
  if valid_608308 != nil:
    section.add "SnapshotCopyGrantName", valid_608308
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_608309: Call_PostDescribeSnapshotCopyGrants_608292; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns a list of snapshot copy grants owned by the AWS account in the destination region.</p> <p> For more information about managing snapshot copy grants, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ## 
  let valid = call_608309.validator(path, query, header, formData, body)
  let scheme = call_608309.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_608309.url(scheme.get, call_608309.host, call_608309.base,
                         call_608309.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_608309, url, valid)

proc call*(call_608310: Call_PostDescribeSnapshotCopyGrants_608292;
          TagKeys: JsonNode = nil; MaxRecords: int = 0; Marker: string = "";
          TagValues: JsonNode = nil; Action: string = "DescribeSnapshotCopyGrants";
          SnapshotCopyGrantName: string = ""; Version: string = "2012-12-01"): Recallable =
  ## postDescribeSnapshotCopyGrants
  ## <p>Returns a list of snapshot copy grants owned by the AWS account in the destination region.</p> <p> For more information about managing snapshot copy grants, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching resources that are associated with the specified key or keys. For example, suppose that you have resources tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with all resources that have either or both of these tag keys associated with them.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: string
  ##         : <p>An optional parameter that specifies the starting point to return a set of response records. When the results of a <code>DescribeSnapshotCopyGrant</code> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <b>SnapshotCopyGrantName</b> parameter or the <b>Marker</b> parameter, but not both. </p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching resources that are associated with the specified value or values. For example, suppose that you have resources tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with all resources that have either or both of these tag values associated with them.
  ##   Action: string (required)
  ##   SnapshotCopyGrantName: string
  ##                        : The name of the snapshot copy grant.
  ##   Version: string (required)
  var query_608311 = newJObject()
  var formData_608312 = newJObject()
  if TagKeys != nil:
    formData_608312.add "TagKeys", TagKeys
  add(formData_608312, "MaxRecords", newJInt(MaxRecords))
  add(formData_608312, "Marker", newJString(Marker))
  if TagValues != nil:
    formData_608312.add "TagValues", TagValues
  add(query_608311, "Action", newJString(Action))
  add(formData_608312, "SnapshotCopyGrantName", newJString(SnapshotCopyGrantName))
  add(query_608311, "Version", newJString(Version))
  result = call_608310.call(nil, query_608311, nil, formData_608312, nil)

var postDescribeSnapshotCopyGrants* = Call_PostDescribeSnapshotCopyGrants_608292(
    name: "postDescribeSnapshotCopyGrants", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeSnapshotCopyGrants",
    validator: validate_PostDescribeSnapshotCopyGrants_608293, base: "/",
    url: url_PostDescribeSnapshotCopyGrants_608294,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeSnapshotCopyGrants_608272 = ref object of OpenApiRestCall_605573
proc url_GetDescribeSnapshotCopyGrants_608274(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeSnapshotCopyGrants_608273(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns a list of snapshot copy grants owned by the AWS account in the destination region.</p> <p> For more information about managing snapshot copy grants, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Marker: JString
  ##         : <p>An optional parameter that specifies the starting point to return a set of response records. When the results of a <code>DescribeSnapshotCopyGrant</code> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <b>SnapshotCopyGrantName</b> parameter or the <b>Marker</b> parameter, but not both. </p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching resources that are associated with the specified key or keys. For example, suppose that you have resources tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with all resources that have either or both of these tag keys associated with them.
  ##   Action: JString (required)
  ##   Version: JString (required)
  ##   SnapshotCopyGrantName: JString
  ##                        : The name of the snapshot copy grant.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching resources that are associated with the specified value or values. For example, suppose that you have resources tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with all resources that have either or both of these tag values associated with them.
  section = newJObject()
  var valid_608275 = query.getOrDefault("Marker")
  valid_608275 = validateParameter(valid_608275, JString, required = false,
                                 default = nil)
  if valid_608275 != nil:
    section.add "Marker", valid_608275
  var valid_608276 = query.getOrDefault("TagKeys")
  valid_608276 = validateParameter(valid_608276, JArray, required = false,
                                 default = nil)
  if valid_608276 != nil:
    section.add "TagKeys", valid_608276
  var valid_608277 = query.getOrDefault("Action")
  valid_608277 = validateParameter(valid_608277, JString, required = true, default = newJString(
      "DescribeSnapshotCopyGrants"))
  if valid_608277 != nil:
    section.add "Action", valid_608277
  var valid_608278 = query.getOrDefault("Version")
  valid_608278 = validateParameter(valid_608278, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_608278 != nil:
    section.add "Version", valid_608278
  var valid_608279 = query.getOrDefault("SnapshotCopyGrantName")
  valid_608279 = validateParameter(valid_608279, JString, required = false,
                                 default = nil)
  if valid_608279 != nil:
    section.add "SnapshotCopyGrantName", valid_608279
  var valid_608280 = query.getOrDefault("MaxRecords")
  valid_608280 = validateParameter(valid_608280, JInt, required = false, default = nil)
  if valid_608280 != nil:
    section.add "MaxRecords", valid_608280
  var valid_608281 = query.getOrDefault("TagValues")
  valid_608281 = validateParameter(valid_608281, JArray, required = false,
                                 default = nil)
  if valid_608281 != nil:
    section.add "TagValues", valid_608281
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_608282 = header.getOrDefault("X-Amz-Signature")
  valid_608282 = validateParameter(valid_608282, JString, required = false,
                                 default = nil)
  if valid_608282 != nil:
    section.add "X-Amz-Signature", valid_608282
  var valid_608283 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_608283 = validateParameter(valid_608283, JString, required = false,
                                 default = nil)
  if valid_608283 != nil:
    section.add "X-Amz-Content-Sha256", valid_608283
  var valid_608284 = header.getOrDefault("X-Amz-Date")
  valid_608284 = validateParameter(valid_608284, JString, required = false,
                                 default = nil)
  if valid_608284 != nil:
    section.add "X-Amz-Date", valid_608284
  var valid_608285 = header.getOrDefault("X-Amz-Credential")
  valid_608285 = validateParameter(valid_608285, JString, required = false,
                                 default = nil)
  if valid_608285 != nil:
    section.add "X-Amz-Credential", valid_608285
  var valid_608286 = header.getOrDefault("X-Amz-Security-Token")
  valid_608286 = validateParameter(valid_608286, JString, required = false,
                                 default = nil)
  if valid_608286 != nil:
    section.add "X-Amz-Security-Token", valid_608286
  var valid_608287 = header.getOrDefault("X-Amz-Algorithm")
  valid_608287 = validateParameter(valid_608287, JString, required = false,
                                 default = nil)
  if valid_608287 != nil:
    section.add "X-Amz-Algorithm", valid_608287
  var valid_608288 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_608288 = validateParameter(valid_608288, JString, required = false,
                                 default = nil)
  if valid_608288 != nil:
    section.add "X-Amz-SignedHeaders", valid_608288
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_608289: Call_GetDescribeSnapshotCopyGrants_608272; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns a list of snapshot copy grants owned by the AWS account in the destination region.</p> <p> For more information about managing snapshot copy grants, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ## 
  let valid = call_608289.validator(path, query, header, formData, body)
  let scheme = call_608289.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_608289.url(scheme.get, call_608289.host, call_608289.base,
                         call_608289.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_608289, url, valid)

proc call*(call_608290: Call_GetDescribeSnapshotCopyGrants_608272;
          Marker: string = ""; TagKeys: JsonNode = nil;
          Action: string = "DescribeSnapshotCopyGrants";
          Version: string = "2012-12-01"; SnapshotCopyGrantName: string = "";
          MaxRecords: int = 0; TagValues: JsonNode = nil): Recallable =
  ## getDescribeSnapshotCopyGrants
  ## <p>Returns a list of snapshot copy grants owned by the AWS account in the destination region.</p> <p> For more information about managing snapshot copy grants, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ##   Marker: string
  ##         : <p>An optional parameter that specifies the starting point to return a set of response records. When the results of a <code>DescribeSnapshotCopyGrant</code> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <b>SnapshotCopyGrantName</b> parameter or the <b>Marker</b> parameter, but not both. </p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching resources that are associated with the specified key or keys. For example, suppose that you have resources tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with all resources that have either or both of these tag keys associated with them.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   SnapshotCopyGrantName: string
  ##                        : The name of the snapshot copy grant.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching resources that are associated with the specified value or values. For example, suppose that you have resources tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with all resources that have either or both of these tag values associated with them.
  var query_608291 = newJObject()
  add(query_608291, "Marker", newJString(Marker))
  if TagKeys != nil:
    query_608291.add "TagKeys", TagKeys
  add(query_608291, "Action", newJString(Action))
  add(query_608291, "Version", newJString(Version))
  add(query_608291, "SnapshotCopyGrantName", newJString(SnapshotCopyGrantName))
  add(query_608291, "MaxRecords", newJInt(MaxRecords))
  if TagValues != nil:
    query_608291.add "TagValues", TagValues
  result = call_608290.call(nil, query_608291, nil, nil, nil)

var getDescribeSnapshotCopyGrants* = Call_GetDescribeSnapshotCopyGrants_608272(
    name: "getDescribeSnapshotCopyGrants", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeSnapshotCopyGrants",
    validator: validate_GetDescribeSnapshotCopyGrants_608273, base: "/",
    url: url_GetDescribeSnapshotCopyGrants_608274,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeSnapshotSchedules_608334 = ref object of OpenApiRestCall_605573
proc url_PostDescribeSnapshotSchedules_608336(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeSnapshotSchedules_608335(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns a list of snapshot schedules. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_608337 = query.getOrDefault("Action")
  valid_608337 = validateParameter(valid_608337, JString, required = true, default = newJString(
      "DescribeSnapshotSchedules"))
  if valid_608337 != nil:
    section.add "Action", valid_608337
  var valid_608338 = query.getOrDefault("Version")
  valid_608338 = validateParameter(valid_608338, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_608338 != nil:
    section.add "Version", valid_608338
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_608339 = header.getOrDefault("X-Amz-Signature")
  valid_608339 = validateParameter(valid_608339, JString, required = false,
                                 default = nil)
  if valid_608339 != nil:
    section.add "X-Amz-Signature", valid_608339
  var valid_608340 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_608340 = validateParameter(valid_608340, JString, required = false,
                                 default = nil)
  if valid_608340 != nil:
    section.add "X-Amz-Content-Sha256", valid_608340
  var valid_608341 = header.getOrDefault("X-Amz-Date")
  valid_608341 = validateParameter(valid_608341, JString, required = false,
                                 default = nil)
  if valid_608341 != nil:
    section.add "X-Amz-Date", valid_608341
  var valid_608342 = header.getOrDefault("X-Amz-Credential")
  valid_608342 = validateParameter(valid_608342, JString, required = false,
                                 default = nil)
  if valid_608342 != nil:
    section.add "X-Amz-Credential", valid_608342
  var valid_608343 = header.getOrDefault("X-Amz-Security-Token")
  valid_608343 = validateParameter(valid_608343, JString, required = false,
                                 default = nil)
  if valid_608343 != nil:
    section.add "X-Amz-Security-Token", valid_608343
  var valid_608344 = header.getOrDefault("X-Amz-Algorithm")
  valid_608344 = validateParameter(valid_608344, JString, required = false,
                                 default = nil)
  if valid_608344 != nil:
    section.add "X-Amz-Algorithm", valid_608344
  var valid_608345 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_608345 = validateParameter(valid_608345, JString, required = false,
                                 default = nil)
  if valid_608345 != nil:
    section.add "X-Amz-SignedHeaders", valid_608345
  result.add "header", section
  ## parameters in `formData` object:
  ##   TagKeys: JArray
  ##          : The key value for a snapshot schedule tag.
  ##   ClusterIdentifier: JString
  ##                    : The unique identifier for the cluster whose snapshot schedules you want to view.
  ##   MaxRecords: JInt
  ##             : The maximum number or response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned <code>marker</code> value.
  ##   Marker: JString
  ##         : A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned marker value in the <code>marker</code> parameter and retrying the command. If the <code>marker</code> field is empty, all response records have been retrieved for the request.
  ##   TagValues: JArray
  ##            : The value corresponding to the key of the snapshot schedule tag.
  ##   ScheduleIdentifier: JString
  ##                     : A unique identifier for a snapshot schedule.
  section = newJObject()
  var valid_608346 = formData.getOrDefault("TagKeys")
  valid_608346 = validateParameter(valid_608346, JArray, required = false,
                                 default = nil)
  if valid_608346 != nil:
    section.add "TagKeys", valid_608346
  var valid_608347 = formData.getOrDefault("ClusterIdentifier")
  valid_608347 = validateParameter(valid_608347, JString, required = false,
                                 default = nil)
  if valid_608347 != nil:
    section.add "ClusterIdentifier", valid_608347
  var valid_608348 = formData.getOrDefault("MaxRecords")
  valid_608348 = validateParameter(valid_608348, JInt, required = false, default = nil)
  if valid_608348 != nil:
    section.add "MaxRecords", valid_608348
  var valid_608349 = formData.getOrDefault("Marker")
  valid_608349 = validateParameter(valid_608349, JString, required = false,
                                 default = nil)
  if valid_608349 != nil:
    section.add "Marker", valid_608349
  var valid_608350 = formData.getOrDefault("TagValues")
  valid_608350 = validateParameter(valid_608350, JArray, required = false,
                                 default = nil)
  if valid_608350 != nil:
    section.add "TagValues", valid_608350
  var valid_608351 = formData.getOrDefault("ScheduleIdentifier")
  valid_608351 = validateParameter(valid_608351, JString, required = false,
                                 default = nil)
  if valid_608351 != nil:
    section.add "ScheduleIdentifier", valid_608351
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_608352: Call_PostDescribeSnapshotSchedules_608334; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns a list of snapshot schedules. 
  ## 
  let valid = call_608352.validator(path, query, header, formData, body)
  let scheme = call_608352.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_608352.url(scheme.get, call_608352.host, call_608352.base,
                         call_608352.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_608352, url, valid)

proc call*(call_608353: Call_PostDescribeSnapshotSchedules_608334;
          TagKeys: JsonNode = nil; ClusterIdentifier: string = ""; MaxRecords: int = 0;
          Marker: string = ""; TagValues: JsonNode = nil;
          Action: string = "DescribeSnapshotSchedules";
          ScheduleIdentifier: string = ""; Version: string = "2012-12-01"): Recallable =
  ## postDescribeSnapshotSchedules
  ## Returns a list of snapshot schedules. 
  ##   TagKeys: JArray
  ##          : The key value for a snapshot schedule tag.
  ##   ClusterIdentifier: string
  ##                    : The unique identifier for the cluster whose snapshot schedules you want to view.
  ##   MaxRecords: int
  ##             : The maximum number or response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned <code>marker</code> value.
  ##   Marker: string
  ##         : A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned marker value in the <code>marker</code> parameter and retrying the command. If the <code>marker</code> field is empty, all response records have been retrieved for the request.
  ##   TagValues: JArray
  ##            : The value corresponding to the key of the snapshot schedule tag.
  ##   Action: string (required)
  ##   ScheduleIdentifier: string
  ##                     : A unique identifier for a snapshot schedule.
  ##   Version: string (required)
  var query_608354 = newJObject()
  var formData_608355 = newJObject()
  if TagKeys != nil:
    formData_608355.add "TagKeys", TagKeys
  add(formData_608355, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_608355, "MaxRecords", newJInt(MaxRecords))
  add(formData_608355, "Marker", newJString(Marker))
  if TagValues != nil:
    formData_608355.add "TagValues", TagValues
  add(query_608354, "Action", newJString(Action))
  add(formData_608355, "ScheduleIdentifier", newJString(ScheduleIdentifier))
  add(query_608354, "Version", newJString(Version))
  result = call_608353.call(nil, query_608354, nil, formData_608355, nil)

var postDescribeSnapshotSchedules* = Call_PostDescribeSnapshotSchedules_608334(
    name: "postDescribeSnapshotSchedules", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeSnapshotSchedules",
    validator: validate_PostDescribeSnapshotSchedules_608335, base: "/",
    url: url_PostDescribeSnapshotSchedules_608336,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeSnapshotSchedules_608313 = ref object of OpenApiRestCall_605573
proc url_GetDescribeSnapshotSchedules_608315(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeSnapshotSchedules_608314(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns a list of snapshot schedules. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Marker: JString
  ##         : A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned marker value in the <code>marker</code> parameter and retrying the command. If the <code>marker</code> field is empty, all response records have been retrieved for the request.
  ##   ScheduleIdentifier: JString
  ##                     : A unique identifier for a snapshot schedule.
  ##   TagKeys: JArray
  ##          : The key value for a snapshot schedule tag.
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString
  ##                    : The unique identifier for the cluster whose snapshot schedules you want to view.
  ##   Version: JString (required)
  ##   MaxRecords: JInt
  ##             : The maximum number or response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned <code>marker</code> value.
  ##   TagValues: JArray
  ##            : The value corresponding to the key of the snapshot schedule tag.
  section = newJObject()
  var valid_608316 = query.getOrDefault("Marker")
  valid_608316 = validateParameter(valid_608316, JString, required = false,
                                 default = nil)
  if valid_608316 != nil:
    section.add "Marker", valid_608316
  var valid_608317 = query.getOrDefault("ScheduleIdentifier")
  valid_608317 = validateParameter(valid_608317, JString, required = false,
                                 default = nil)
  if valid_608317 != nil:
    section.add "ScheduleIdentifier", valid_608317
  var valid_608318 = query.getOrDefault("TagKeys")
  valid_608318 = validateParameter(valid_608318, JArray, required = false,
                                 default = nil)
  if valid_608318 != nil:
    section.add "TagKeys", valid_608318
  var valid_608319 = query.getOrDefault("Action")
  valid_608319 = validateParameter(valid_608319, JString, required = true, default = newJString(
      "DescribeSnapshotSchedules"))
  if valid_608319 != nil:
    section.add "Action", valid_608319
  var valid_608320 = query.getOrDefault("ClusterIdentifier")
  valid_608320 = validateParameter(valid_608320, JString, required = false,
                                 default = nil)
  if valid_608320 != nil:
    section.add "ClusterIdentifier", valid_608320
  var valid_608321 = query.getOrDefault("Version")
  valid_608321 = validateParameter(valid_608321, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_608321 != nil:
    section.add "Version", valid_608321
  var valid_608322 = query.getOrDefault("MaxRecords")
  valid_608322 = validateParameter(valid_608322, JInt, required = false, default = nil)
  if valid_608322 != nil:
    section.add "MaxRecords", valid_608322
  var valid_608323 = query.getOrDefault("TagValues")
  valid_608323 = validateParameter(valid_608323, JArray, required = false,
                                 default = nil)
  if valid_608323 != nil:
    section.add "TagValues", valid_608323
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_608324 = header.getOrDefault("X-Amz-Signature")
  valid_608324 = validateParameter(valid_608324, JString, required = false,
                                 default = nil)
  if valid_608324 != nil:
    section.add "X-Amz-Signature", valid_608324
  var valid_608325 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_608325 = validateParameter(valid_608325, JString, required = false,
                                 default = nil)
  if valid_608325 != nil:
    section.add "X-Amz-Content-Sha256", valid_608325
  var valid_608326 = header.getOrDefault("X-Amz-Date")
  valid_608326 = validateParameter(valid_608326, JString, required = false,
                                 default = nil)
  if valid_608326 != nil:
    section.add "X-Amz-Date", valid_608326
  var valid_608327 = header.getOrDefault("X-Amz-Credential")
  valid_608327 = validateParameter(valid_608327, JString, required = false,
                                 default = nil)
  if valid_608327 != nil:
    section.add "X-Amz-Credential", valid_608327
  var valid_608328 = header.getOrDefault("X-Amz-Security-Token")
  valid_608328 = validateParameter(valid_608328, JString, required = false,
                                 default = nil)
  if valid_608328 != nil:
    section.add "X-Amz-Security-Token", valid_608328
  var valid_608329 = header.getOrDefault("X-Amz-Algorithm")
  valid_608329 = validateParameter(valid_608329, JString, required = false,
                                 default = nil)
  if valid_608329 != nil:
    section.add "X-Amz-Algorithm", valid_608329
  var valid_608330 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_608330 = validateParameter(valid_608330, JString, required = false,
                                 default = nil)
  if valid_608330 != nil:
    section.add "X-Amz-SignedHeaders", valid_608330
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_608331: Call_GetDescribeSnapshotSchedules_608313; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns a list of snapshot schedules. 
  ## 
  let valid = call_608331.validator(path, query, header, formData, body)
  let scheme = call_608331.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_608331.url(scheme.get, call_608331.host, call_608331.base,
                         call_608331.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_608331, url, valid)

proc call*(call_608332: Call_GetDescribeSnapshotSchedules_608313;
          Marker: string = ""; ScheduleIdentifier: string = ""; TagKeys: JsonNode = nil;
          Action: string = "DescribeSnapshotSchedules";
          ClusterIdentifier: string = ""; Version: string = "2012-12-01";
          MaxRecords: int = 0; TagValues: JsonNode = nil): Recallable =
  ## getDescribeSnapshotSchedules
  ## Returns a list of snapshot schedules. 
  ##   Marker: string
  ##         : A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned marker value in the <code>marker</code> parameter and retrying the command. If the <code>marker</code> field is empty, all response records have been retrieved for the request.
  ##   ScheduleIdentifier: string
  ##                     : A unique identifier for a snapshot schedule.
  ##   TagKeys: JArray
  ##          : The key value for a snapshot schedule tag.
  ##   Action: string (required)
  ##   ClusterIdentifier: string
  ##                    : The unique identifier for the cluster whose snapshot schedules you want to view.
  ##   Version: string (required)
  ##   MaxRecords: int
  ##             : The maximum number or response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned <code>marker</code> value.
  ##   TagValues: JArray
  ##            : The value corresponding to the key of the snapshot schedule tag.
  var query_608333 = newJObject()
  add(query_608333, "Marker", newJString(Marker))
  add(query_608333, "ScheduleIdentifier", newJString(ScheduleIdentifier))
  if TagKeys != nil:
    query_608333.add "TagKeys", TagKeys
  add(query_608333, "Action", newJString(Action))
  add(query_608333, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_608333, "Version", newJString(Version))
  add(query_608333, "MaxRecords", newJInt(MaxRecords))
  if TagValues != nil:
    query_608333.add "TagValues", TagValues
  result = call_608332.call(nil, query_608333, nil, nil, nil)

var getDescribeSnapshotSchedules* = Call_GetDescribeSnapshotSchedules_608313(
    name: "getDescribeSnapshotSchedules", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeSnapshotSchedules",
    validator: validate_GetDescribeSnapshotSchedules_608314, base: "/",
    url: url_GetDescribeSnapshotSchedules_608315,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeStorage_608371 = ref object of OpenApiRestCall_605573
proc url_PostDescribeStorage_608373(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeStorage_608372(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Returns account level backups storage size and provisional storage.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_608374 = query.getOrDefault("Action")
  valid_608374 = validateParameter(valid_608374, JString, required = true,
                                 default = newJString("DescribeStorage"))
  if valid_608374 != nil:
    section.add "Action", valid_608374
  var valid_608375 = query.getOrDefault("Version")
  valid_608375 = validateParameter(valid_608375, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_608375 != nil:
    section.add "Version", valid_608375
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_608376 = header.getOrDefault("X-Amz-Signature")
  valid_608376 = validateParameter(valid_608376, JString, required = false,
                                 default = nil)
  if valid_608376 != nil:
    section.add "X-Amz-Signature", valid_608376
  var valid_608377 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_608377 = validateParameter(valid_608377, JString, required = false,
                                 default = nil)
  if valid_608377 != nil:
    section.add "X-Amz-Content-Sha256", valid_608377
  var valid_608378 = header.getOrDefault("X-Amz-Date")
  valid_608378 = validateParameter(valid_608378, JString, required = false,
                                 default = nil)
  if valid_608378 != nil:
    section.add "X-Amz-Date", valid_608378
  var valid_608379 = header.getOrDefault("X-Amz-Credential")
  valid_608379 = validateParameter(valid_608379, JString, required = false,
                                 default = nil)
  if valid_608379 != nil:
    section.add "X-Amz-Credential", valid_608379
  var valid_608380 = header.getOrDefault("X-Amz-Security-Token")
  valid_608380 = validateParameter(valid_608380, JString, required = false,
                                 default = nil)
  if valid_608380 != nil:
    section.add "X-Amz-Security-Token", valid_608380
  var valid_608381 = header.getOrDefault("X-Amz-Algorithm")
  valid_608381 = validateParameter(valid_608381, JString, required = false,
                                 default = nil)
  if valid_608381 != nil:
    section.add "X-Amz-Algorithm", valid_608381
  var valid_608382 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_608382 = validateParameter(valid_608382, JString, required = false,
                                 default = nil)
  if valid_608382 != nil:
    section.add "X-Amz-SignedHeaders", valid_608382
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_608383: Call_PostDescribeStorage_608371; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns account level backups storage size and provisional storage.
  ## 
  let valid = call_608383.validator(path, query, header, formData, body)
  let scheme = call_608383.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_608383.url(scheme.get, call_608383.host, call_608383.base,
                         call_608383.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_608383, url, valid)

proc call*(call_608384: Call_PostDescribeStorage_608371;
          Action: string = "DescribeStorage"; Version: string = "2012-12-01"): Recallable =
  ## postDescribeStorage
  ## Returns account level backups storage size and provisional storage.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_608385 = newJObject()
  add(query_608385, "Action", newJString(Action))
  add(query_608385, "Version", newJString(Version))
  result = call_608384.call(nil, query_608385, nil, nil, nil)

var postDescribeStorage* = Call_PostDescribeStorage_608371(
    name: "postDescribeStorage", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeStorage",
    validator: validate_PostDescribeStorage_608372, base: "/",
    url: url_PostDescribeStorage_608373, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeStorage_608356 = ref object of OpenApiRestCall_605573
proc url_GetDescribeStorage_608358(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeStorage_608357(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Returns account level backups storage size and provisional storage.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_608359 = query.getOrDefault("Action")
  valid_608359 = validateParameter(valid_608359, JString, required = true,
                                 default = newJString("DescribeStorage"))
  if valid_608359 != nil:
    section.add "Action", valid_608359
  var valid_608360 = query.getOrDefault("Version")
  valid_608360 = validateParameter(valid_608360, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_608360 != nil:
    section.add "Version", valid_608360
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_608361 = header.getOrDefault("X-Amz-Signature")
  valid_608361 = validateParameter(valid_608361, JString, required = false,
                                 default = nil)
  if valid_608361 != nil:
    section.add "X-Amz-Signature", valid_608361
  var valid_608362 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_608362 = validateParameter(valid_608362, JString, required = false,
                                 default = nil)
  if valid_608362 != nil:
    section.add "X-Amz-Content-Sha256", valid_608362
  var valid_608363 = header.getOrDefault("X-Amz-Date")
  valid_608363 = validateParameter(valid_608363, JString, required = false,
                                 default = nil)
  if valid_608363 != nil:
    section.add "X-Amz-Date", valid_608363
  var valid_608364 = header.getOrDefault("X-Amz-Credential")
  valid_608364 = validateParameter(valid_608364, JString, required = false,
                                 default = nil)
  if valid_608364 != nil:
    section.add "X-Amz-Credential", valid_608364
  var valid_608365 = header.getOrDefault("X-Amz-Security-Token")
  valid_608365 = validateParameter(valid_608365, JString, required = false,
                                 default = nil)
  if valid_608365 != nil:
    section.add "X-Amz-Security-Token", valid_608365
  var valid_608366 = header.getOrDefault("X-Amz-Algorithm")
  valid_608366 = validateParameter(valid_608366, JString, required = false,
                                 default = nil)
  if valid_608366 != nil:
    section.add "X-Amz-Algorithm", valid_608366
  var valid_608367 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_608367 = validateParameter(valid_608367, JString, required = false,
                                 default = nil)
  if valid_608367 != nil:
    section.add "X-Amz-SignedHeaders", valid_608367
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_608368: Call_GetDescribeStorage_608356; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns account level backups storage size and provisional storage.
  ## 
  let valid = call_608368.validator(path, query, header, formData, body)
  let scheme = call_608368.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_608368.url(scheme.get, call_608368.host, call_608368.base,
                         call_608368.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_608368, url, valid)

proc call*(call_608369: Call_GetDescribeStorage_608356;
          Action: string = "DescribeStorage"; Version: string = "2012-12-01"): Recallable =
  ## getDescribeStorage
  ## Returns account level backups storage size and provisional storage.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_608370 = newJObject()
  add(query_608370, "Action", newJString(Action))
  add(query_608370, "Version", newJString(Version))
  result = call_608369.call(nil, query_608370, nil, nil, nil)

var getDescribeStorage* = Call_GetDescribeStorage_608356(
    name: "getDescribeStorage", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeStorage",
    validator: validate_GetDescribeStorage_608357, base: "/",
    url: url_GetDescribeStorage_608358, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeTableRestoreStatus_608405 = ref object of OpenApiRestCall_605573
proc url_PostDescribeTableRestoreStatus_608407(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeTableRestoreStatus_608406(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists the status of one or more table restore requests made using the <a>RestoreTableFromClusterSnapshot</a> API action. If you don't specify a value for the <code>TableRestoreRequestId</code> parameter, then <code>DescribeTableRestoreStatus</code> returns the status of all table restore requests ordered by the date and time of the request in ascending order. Otherwise <code>DescribeTableRestoreStatus</code> returns the status of the table specified by <code>TableRestoreRequestId</code>.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_608408 = query.getOrDefault("Action")
  valid_608408 = validateParameter(valid_608408, JString, required = true, default = newJString(
      "DescribeTableRestoreStatus"))
  if valid_608408 != nil:
    section.add "Action", valid_608408
  var valid_608409 = query.getOrDefault("Version")
  valid_608409 = validateParameter(valid_608409, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_608409 != nil:
    section.add "Version", valid_608409
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_608410 = header.getOrDefault("X-Amz-Signature")
  valid_608410 = validateParameter(valid_608410, JString, required = false,
                                 default = nil)
  if valid_608410 != nil:
    section.add "X-Amz-Signature", valid_608410
  var valid_608411 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_608411 = validateParameter(valid_608411, JString, required = false,
                                 default = nil)
  if valid_608411 != nil:
    section.add "X-Amz-Content-Sha256", valid_608411
  var valid_608412 = header.getOrDefault("X-Amz-Date")
  valid_608412 = validateParameter(valid_608412, JString, required = false,
                                 default = nil)
  if valid_608412 != nil:
    section.add "X-Amz-Date", valid_608412
  var valid_608413 = header.getOrDefault("X-Amz-Credential")
  valid_608413 = validateParameter(valid_608413, JString, required = false,
                                 default = nil)
  if valid_608413 != nil:
    section.add "X-Amz-Credential", valid_608413
  var valid_608414 = header.getOrDefault("X-Amz-Security-Token")
  valid_608414 = validateParameter(valid_608414, JString, required = false,
                                 default = nil)
  if valid_608414 != nil:
    section.add "X-Amz-Security-Token", valid_608414
  var valid_608415 = header.getOrDefault("X-Amz-Algorithm")
  valid_608415 = validateParameter(valid_608415, JString, required = false,
                                 default = nil)
  if valid_608415 != nil:
    section.add "X-Amz-Algorithm", valid_608415
  var valid_608416 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_608416 = validateParameter(valid_608416, JString, required = false,
                                 default = nil)
  if valid_608416 != nil:
    section.add "X-Amz-SignedHeaders", valid_608416
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString
  ##                    : The Amazon Redshift cluster that the table is being restored to.
  ##   TableRestoreRequestId: JString
  ##                        : The identifier of the table restore request to return status for. If you don't specify a <code>TableRestoreRequestId</code> value, then <code>DescribeTableRestoreStatus</code> returns the status of all in-progress table restore requests.
  ##   MaxRecords: JInt
  ##             : The maximum number of records to include in the response. If more records exist than the specified <code>MaxRecords</code> value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.
  ##   Marker: JString
  ##         : An optional pagination token provided by a previous <code>DescribeTableRestoreStatus</code> request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by the <code>MaxRecords</code> parameter.
  section = newJObject()
  var valid_608417 = formData.getOrDefault("ClusterIdentifier")
  valid_608417 = validateParameter(valid_608417, JString, required = false,
                                 default = nil)
  if valid_608417 != nil:
    section.add "ClusterIdentifier", valid_608417
  var valid_608418 = formData.getOrDefault("TableRestoreRequestId")
  valid_608418 = validateParameter(valid_608418, JString, required = false,
                                 default = nil)
  if valid_608418 != nil:
    section.add "TableRestoreRequestId", valid_608418
  var valid_608419 = formData.getOrDefault("MaxRecords")
  valid_608419 = validateParameter(valid_608419, JInt, required = false, default = nil)
  if valid_608419 != nil:
    section.add "MaxRecords", valid_608419
  var valid_608420 = formData.getOrDefault("Marker")
  valid_608420 = validateParameter(valid_608420, JString, required = false,
                                 default = nil)
  if valid_608420 != nil:
    section.add "Marker", valid_608420
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_608421: Call_PostDescribeTableRestoreStatus_608405; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the status of one or more table restore requests made using the <a>RestoreTableFromClusterSnapshot</a> API action. If you don't specify a value for the <code>TableRestoreRequestId</code> parameter, then <code>DescribeTableRestoreStatus</code> returns the status of all table restore requests ordered by the date and time of the request in ascending order. Otherwise <code>DescribeTableRestoreStatus</code> returns the status of the table specified by <code>TableRestoreRequestId</code>.
  ## 
  let valid = call_608421.validator(path, query, header, formData, body)
  let scheme = call_608421.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_608421.url(scheme.get, call_608421.host, call_608421.base,
                         call_608421.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_608421, url, valid)

proc call*(call_608422: Call_PostDescribeTableRestoreStatus_608405;
          ClusterIdentifier: string = ""; TableRestoreRequestId: string = "";
          MaxRecords: int = 0; Marker: string = "";
          Action: string = "DescribeTableRestoreStatus";
          Version: string = "2012-12-01"): Recallable =
  ## postDescribeTableRestoreStatus
  ## Lists the status of one or more table restore requests made using the <a>RestoreTableFromClusterSnapshot</a> API action. If you don't specify a value for the <code>TableRestoreRequestId</code> parameter, then <code>DescribeTableRestoreStatus</code> returns the status of all table restore requests ordered by the date and time of the request in ascending order. Otherwise <code>DescribeTableRestoreStatus</code> returns the status of the table specified by <code>TableRestoreRequestId</code>.
  ##   ClusterIdentifier: string
  ##                    : The Amazon Redshift cluster that the table is being restored to.
  ##   TableRestoreRequestId: string
  ##                        : The identifier of the table restore request to return status for. If you don't specify a <code>TableRestoreRequestId</code> value, then <code>DescribeTableRestoreStatus</code> returns the status of all in-progress table restore requests.
  ##   MaxRecords: int
  ##             : The maximum number of records to include in the response. If more records exist than the specified <code>MaxRecords</code> value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.
  ##   Marker: string
  ##         : An optional pagination token provided by a previous <code>DescribeTableRestoreStatus</code> request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by the <code>MaxRecords</code> parameter.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_608423 = newJObject()
  var formData_608424 = newJObject()
  add(formData_608424, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_608424, "TableRestoreRequestId", newJString(TableRestoreRequestId))
  add(formData_608424, "MaxRecords", newJInt(MaxRecords))
  add(formData_608424, "Marker", newJString(Marker))
  add(query_608423, "Action", newJString(Action))
  add(query_608423, "Version", newJString(Version))
  result = call_608422.call(nil, query_608423, nil, formData_608424, nil)

var postDescribeTableRestoreStatus* = Call_PostDescribeTableRestoreStatus_608405(
    name: "postDescribeTableRestoreStatus", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeTableRestoreStatus",
    validator: validate_PostDescribeTableRestoreStatus_608406, base: "/",
    url: url_PostDescribeTableRestoreStatus_608407,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeTableRestoreStatus_608386 = ref object of OpenApiRestCall_605573
proc url_GetDescribeTableRestoreStatus_608388(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeTableRestoreStatus_608387(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists the status of one or more table restore requests made using the <a>RestoreTableFromClusterSnapshot</a> API action. If you don't specify a value for the <code>TableRestoreRequestId</code> parameter, then <code>DescribeTableRestoreStatus</code> returns the status of all table restore requests ordered by the date and time of the request in ascending order. Otherwise <code>DescribeTableRestoreStatus</code> returns the status of the table specified by <code>TableRestoreRequestId</code>.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Marker: JString
  ##         : An optional pagination token provided by a previous <code>DescribeTableRestoreStatus</code> request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by the <code>MaxRecords</code> parameter.
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString
  ##                    : The Amazon Redshift cluster that the table is being restored to.
  ##   Version: JString (required)
  ##   TableRestoreRequestId: JString
  ##                        : The identifier of the table restore request to return status for. If you don't specify a <code>TableRestoreRequestId</code> value, then <code>DescribeTableRestoreStatus</code> returns the status of all in-progress table restore requests.
  ##   MaxRecords: JInt
  ##             : The maximum number of records to include in the response. If more records exist than the specified <code>MaxRecords</code> value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.
  section = newJObject()
  var valid_608389 = query.getOrDefault("Marker")
  valid_608389 = validateParameter(valid_608389, JString, required = false,
                                 default = nil)
  if valid_608389 != nil:
    section.add "Marker", valid_608389
  var valid_608390 = query.getOrDefault("Action")
  valid_608390 = validateParameter(valid_608390, JString, required = true, default = newJString(
      "DescribeTableRestoreStatus"))
  if valid_608390 != nil:
    section.add "Action", valid_608390
  var valid_608391 = query.getOrDefault("ClusterIdentifier")
  valid_608391 = validateParameter(valid_608391, JString, required = false,
                                 default = nil)
  if valid_608391 != nil:
    section.add "ClusterIdentifier", valid_608391
  var valid_608392 = query.getOrDefault("Version")
  valid_608392 = validateParameter(valid_608392, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_608392 != nil:
    section.add "Version", valid_608392
  var valid_608393 = query.getOrDefault("TableRestoreRequestId")
  valid_608393 = validateParameter(valid_608393, JString, required = false,
                                 default = nil)
  if valid_608393 != nil:
    section.add "TableRestoreRequestId", valid_608393
  var valid_608394 = query.getOrDefault("MaxRecords")
  valid_608394 = validateParameter(valid_608394, JInt, required = false, default = nil)
  if valid_608394 != nil:
    section.add "MaxRecords", valid_608394
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_608395 = header.getOrDefault("X-Amz-Signature")
  valid_608395 = validateParameter(valid_608395, JString, required = false,
                                 default = nil)
  if valid_608395 != nil:
    section.add "X-Amz-Signature", valid_608395
  var valid_608396 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_608396 = validateParameter(valid_608396, JString, required = false,
                                 default = nil)
  if valid_608396 != nil:
    section.add "X-Amz-Content-Sha256", valid_608396
  var valid_608397 = header.getOrDefault("X-Amz-Date")
  valid_608397 = validateParameter(valid_608397, JString, required = false,
                                 default = nil)
  if valid_608397 != nil:
    section.add "X-Amz-Date", valid_608397
  var valid_608398 = header.getOrDefault("X-Amz-Credential")
  valid_608398 = validateParameter(valid_608398, JString, required = false,
                                 default = nil)
  if valid_608398 != nil:
    section.add "X-Amz-Credential", valid_608398
  var valid_608399 = header.getOrDefault("X-Amz-Security-Token")
  valid_608399 = validateParameter(valid_608399, JString, required = false,
                                 default = nil)
  if valid_608399 != nil:
    section.add "X-Amz-Security-Token", valid_608399
  var valid_608400 = header.getOrDefault("X-Amz-Algorithm")
  valid_608400 = validateParameter(valid_608400, JString, required = false,
                                 default = nil)
  if valid_608400 != nil:
    section.add "X-Amz-Algorithm", valid_608400
  var valid_608401 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_608401 = validateParameter(valid_608401, JString, required = false,
                                 default = nil)
  if valid_608401 != nil:
    section.add "X-Amz-SignedHeaders", valid_608401
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_608402: Call_GetDescribeTableRestoreStatus_608386; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the status of one or more table restore requests made using the <a>RestoreTableFromClusterSnapshot</a> API action. If you don't specify a value for the <code>TableRestoreRequestId</code> parameter, then <code>DescribeTableRestoreStatus</code> returns the status of all table restore requests ordered by the date and time of the request in ascending order. Otherwise <code>DescribeTableRestoreStatus</code> returns the status of the table specified by <code>TableRestoreRequestId</code>.
  ## 
  let valid = call_608402.validator(path, query, header, formData, body)
  let scheme = call_608402.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_608402.url(scheme.get, call_608402.host, call_608402.base,
                         call_608402.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_608402, url, valid)

proc call*(call_608403: Call_GetDescribeTableRestoreStatus_608386;
          Marker: string = ""; Action: string = "DescribeTableRestoreStatus";
          ClusterIdentifier: string = ""; Version: string = "2012-12-01";
          TableRestoreRequestId: string = ""; MaxRecords: int = 0): Recallable =
  ## getDescribeTableRestoreStatus
  ## Lists the status of one or more table restore requests made using the <a>RestoreTableFromClusterSnapshot</a> API action. If you don't specify a value for the <code>TableRestoreRequestId</code> parameter, then <code>DescribeTableRestoreStatus</code> returns the status of all table restore requests ordered by the date and time of the request in ascending order. Otherwise <code>DescribeTableRestoreStatus</code> returns the status of the table specified by <code>TableRestoreRequestId</code>.
  ##   Marker: string
  ##         : An optional pagination token provided by a previous <code>DescribeTableRestoreStatus</code> request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by the <code>MaxRecords</code> parameter.
  ##   Action: string (required)
  ##   ClusterIdentifier: string
  ##                    : The Amazon Redshift cluster that the table is being restored to.
  ##   Version: string (required)
  ##   TableRestoreRequestId: string
  ##                        : The identifier of the table restore request to return status for. If you don't specify a <code>TableRestoreRequestId</code> value, then <code>DescribeTableRestoreStatus</code> returns the status of all in-progress table restore requests.
  ##   MaxRecords: int
  ##             : The maximum number of records to include in the response. If more records exist than the specified <code>MaxRecords</code> value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.
  var query_608404 = newJObject()
  add(query_608404, "Marker", newJString(Marker))
  add(query_608404, "Action", newJString(Action))
  add(query_608404, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_608404, "Version", newJString(Version))
  add(query_608404, "TableRestoreRequestId", newJString(TableRestoreRequestId))
  add(query_608404, "MaxRecords", newJInt(MaxRecords))
  result = call_608403.call(nil, query_608404, nil, nil, nil)

var getDescribeTableRestoreStatus* = Call_GetDescribeTableRestoreStatus_608386(
    name: "getDescribeTableRestoreStatus", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeTableRestoreStatus",
    validator: validate_GetDescribeTableRestoreStatus_608387, base: "/",
    url: url_GetDescribeTableRestoreStatus_608388,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeTags_608446 = ref object of OpenApiRestCall_605573
proc url_PostDescribeTags_608448(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeTags_608447(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## <p>Returns a list of tags. You can return tags from a specific resource by specifying an ARN, or you can return all tags for a given type of resource, such as clusters, snapshots, and so on.</p> <p>The following are limitations for <code>DescribeTags</code>: </p> <ul> <li> <p>You cannot specify an ARN and a resource-type value together in the same request.</p> </li> <li> <p>You cannot use the <code>MaxRecords</code> and <code>Marker</code> parameters together with the ARN parameter.</p> </li> <li> <p>The <code>MaxRecords</code> parameter can be a range from 10 to 50 results to return in a request.</p> </li> </ul> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all resources that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all resources that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, resources are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_608449 = query.getOrDefault("Action")
  valid_608449 = validateParameter(valid_608449, JString, required = true,
                                 default = newJString("DescribeTags"))
  if valid_608449 != nil:
    section.add "Action", valid_608449
  var valid_608450 = query.getOrDefault("Version")
  valid_608450 = validateParameter(valid_608450, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_608450 != nil:
    section.add "Version", valid_608450
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_608451 = header.getOrDefault("X-Amz-Signature")
  valid_608451 = validateParameter(valid_608451, JString, required = false,
                                 default = nil)
  if valid_608451 != nil:
    section.add "X-Amz-Signature", valid_608451
  var valid_608452 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_608452 = validateParameter(valid_608452, JString, required = false,
                                 default = nil)
  if valid_608452 != nil:
    section.add "X-Amz-Content-Sha256", valid_608452
  var valid_608453 = header.getOrDefault("X-Amz-Date")
  valid_608453 = validateParameter(valid_608453, JString, required = false,
                                 default = nil)
  if valid_608453 != nil:
    section.add "X-Amz-Date", valid_608453
  var valid_608454 = header.getOrDefault("X-Amz-Credential")
  valid_608454 = validateParameter(valid_608454, JString, required = false,
                                 default = nil)
  if valid_608454 != nil:
    section.add "X-Amz-Credential", valid_608454
  var valid_608455 = header.getOrDefault("X-Amz-Security-Token")
  valid_608455 = validateParameter(valid_608455, JString, required = false,
                                 default = nil)
  if valid_608455 != nil:
    section.add "X-Amz-Security-Token", valid_608455
  var valid_608456 = header.getOrDefault("X-Amz-Algorithm")
  valid_608456 = validateParameter(valid_608456, JString, required = false,
                                 default = nil)
  if valid_608456 != nil:
    section.add "X-Amz-Algorithm", valid_608456
  var valid_608457 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_608457 = validateParameter(valid_608457, JString, required = false,
                                 default = nil)
  if valid_608457 != nil:
    section.add "X-Amz-SignedHeaders", valid_608457
  result.add "header", section
  ## parameters in `formData` object:
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching resources that are associated with the specified key or keys. For example, suppose that you have resources tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with all resources that have either or both of these tag keys associated with them.
  ##   MaxRecords: JInt
  ##             : The maximum number or response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned <code>marker</code> value. 
  ##   ResourceType: JString
  ##               : <p>The type of resource with which you want to view tags. Valid resource types are: </p> <ul> <li> <p>Cluster</p> </li> <li> <p>CIDR/IP</p> </li> <li> <p>EC2 security group</p> </li> <li> <p>Snapshot</p> </li> <li> <p>Cluster security group</p> </li> <li> <p>Subnet group</p> </li> <li> <p>HSM connection</p> </li> <li> <p>HSM certificate</p> </li> <li> <p>Parameter group</p> </li> <li> <p>Snapshot copy grant</p> </li> </ul> <p>For more information about Amazon Redshift resource types and constructing ARNs, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-overview.html#redshift-iam-access-control-specify-actions">Specifying Policy Elements: Actions, Effects, Resources, and Principals</a> in the Amazon Redshift Cluster Management Guide. </p>
  ##   Marker: JString
  ##         : A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned marker value in the <code>marker</code> parameter and retrying the command. If the <code>marker</code> field is empty, all response records have been retrieved for the request. 
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching resources that are associated with the specified value or values. For example, suppose that you have resources tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with all resources that have either or both of these tag values associated with them.
  ##   ResourceName: JString
  ##               : The Amazon Resource Name (ARN) for which you want to describe the tag or tags. For example, <code>arn:aws:redshift:us-east-2:123456789:cluster:t1</code>. 
  section = newJObject()
  var valid_608458 = formData.getOrDefault("TagKeys")
  valid_608458 = validateParameter(valid_608458, JArray, required = false,
                                 default = nil)
  if valid_608458 != nil:
    section.add "TagKeys", valid_608458
  var valid_608459 = formData.getOrDefault("MaxRecords")
  valid_608459 = validateParameter(valid_608459, JInt, required = false, default = nil)
  if valid_608459 != nil:
    section.add "MaxRecords", valid_608459
  var valid_608460 = formData.getOrDefault("ResourceType")
  valid_608460 = validateParameter(valid_608460, JString, required = false,
                                 default = nil)
  if valid_608460 != nil:
    section.add "ResourceType", valid_608460
  var valid_608461 = formData.getOrDefault("Marker")
  valid_608461 = validateParameter(valid_608461, JString, required = false,
                                 default = nil)
  if valid_608461 != nil:
    section.add "Marker", valid_608461
  var valid_608462 = formData.getOrDefault("TagValues")
  valid_608462 = validateParameter(valid_608462, JArray, required = false,
                                 default = nil)
  if valid_608462 != nil:
    section.add "TagValues", valid_608462
  var valid_608463 = formData.getOrDefault("ResourceName")
  valid_608463 = validateParameter(valid_608463, JString, required = false,
                                 default = nil)
  if valid_608463 != nil:
    section.add "ResourceName", valid_608463
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_608464: Call_PostDescribeTags_608446; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns a list of tags. You can return tags from a specific resource by specifying an ARN, or you can return all tags for a given type of resource, such as clusters, snapshots, and so on.</p> <p>The following are limitations for <code>DescribeTags</code>: </p> <ul> <li> <p>You cannot specify an ARN and a resource-type value together in the same request.</p> </li> <li> <p>You cannot use the <code>MaxRecords</code> and <code>Marker</code> parameters together with the ARN parameter.</p> </li> <li> <p>The <code>MaxRecords</code> parameter can be a range from 10 to 50 results to return in a request.</p> </li> </ul> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all resources that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all resources that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, resources are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_608464.validator(path, query, header, formData, body)
  let scheme = call_608464.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_608464.url(scheme.get, call_608464.host, call_608464.base,
                         call_608464.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_608464, url, valid)

proc call*(call_608465: Call_PostDescribeTags_608446; TagKeys: JsonNode = nil;
          MaxRecords: int = 0; ResourceType: string = ""; Marker: string = "";
          TagValues: JsonNode = nil; Action: string = "DescribeTags";
          Version: string = "2012-12-01"; ResourceName: string = ""): Recallable =
  ## postDescribeTags
  ## <p>Returns a list of tags. You can return tags from a specific resource by specifying an ARN, or you can return all tags for a given type of resource, such as clusters, snapshots, and so on.</p> <p>The following are limitations for <code>DescribeTags</code>: </p> <ul> <li> <p>You cannot specify an ARN and a resource-type value together in the same request.</p> </li> <li> <p>You cannot use the <code>MaxRecords</code> and <code>Marker</code> parameters together with the ARN parameter.</p> </li> <li> <p>The <code>MaxRecords</code> parameter can be a range from 10 to 50 results to return in a request.</p> </li> </ul> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all resources that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all resources that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, resources are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching resources that are associated with the specified key or keys. For example, suppose that you have resources tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with all resources that have either or both of these tag keys associated with them.
  ##   MaxRecords: int
  ##             : The maximum number or response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned <code>marker</code> value. 
  ##   ResourceType: string
  ##               : <p>The type of resource with which you want to view tags. Valid resource types are: </p> <ul> <li> <p>Cluster</p> </li> <li> <p>CIDR/IP</p> </li> <li> <p>EC2 security group</p> </li> <li> <p>Snapshot</p> </li> <li> <p>Cluster security group</p> </li> <li> <p>Subnet group</p> </li> <li> <p>HSM connection</p> </li> <li> <p>HSM certificate</p> </li> <li> <p>Parameter group</p> </li> <li> <p>Snapshot copy grant</p> </li> </ul> <p>For more information about Amazon Redshift resource types and constructing ARNs, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-overview.html#redshift-iam-access-control-specify-actions">Specifying Policy Elements: Actions, Effects, Resources, and Principals</a> in the Amazon Redshift Cluster Management Guide. </p>
  ##   Marker: string
  ##         : A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned marker value in the <code>marker</code> parameter and retrying the command. If the <code>marker</code> field is empty, all response records have been retrieved for the request. 
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching resources that are associated with the specified value or values. For example, suppose that you have resources tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with all resources that have either or both of these tag values associated with them.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   ResourceName: string
  ##               : The Amazon Resource Name (ARN) for which you want to describe the tag or tags. For example, <code>arn:aws:redshift:us-east-2:123456789:cluster:t1</code>. 
  var query_608466 = newJObject()
  var formData_608467 = newJObject()
  if TagKeys != nil:
    formData_608467.add "TagKeys", TagKeys
  add(formData_608467, "MaxRecords", newJInt(MaxRecords))
  add(formData_608467, "ResourceType", newJString(ResourceType))
  add(formData_608467, "Marker", newJString(Marker))
  if TagValues != nil:
    formData_608467.add "TagValues", TagValues
  add(query_608466, "Action", newJString(Action))
  add(query_608466, "Version", newJString(Version))
  add(formData_608467, "ResourceName", newJString(ResourceName))
  result = call_608465.call(nil, query_608466, nil, formData_608467, nil)

var postDescribeTags* = Call_PostDescribeTags_608446(name: "postDescribeTags",
    meth: HttpMethod.HttpPost, host: "redshift.amazonaws.com",
    route: "/#Action=DescribeTags", validator: validate_PostDescribeTags_608447,
    base: "/", url: url_PostDescribeTags_608448,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeTags_608425 = ref object of OpenApiRestCall_605573
proc url_GetDescribeTags_608427(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeTags_608426(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## <p>Returns a list of tags. You can return tags from a specific resource by specifying an ARN, or you can return all tags for a given type of resource, such as clusters, snapshots, and so on.</p> <p>The following are limitations for <code>DescribeTags</code>: </p> <ul> <li> <p>You cannot specify an ARN and a resource-type value together in the same request.</p> </li> <li> <p>You cannot use the <code>MaxRecords</code> and <code>Marker</code> parameters together with the ARN parameter.</p> </li> <li> <p>The <code>MaxRecords</code> parameter can be a range from 10 to 50 results to return in a request.</p> </li> </ul> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all resources that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all resources that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, resources are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Marker: JString
  ##         : A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned marker value in the <code>marker</code> parameter and retrying the command. If the <code>marker</code> field is empty, all response records have been retrieved for the request. 
  ##   ResourceName: JString
  ##               : The Amazon Resource Name (ARN) for which you want to describe the tag or tags. For example, <code>arn:aws:redshift:us-east-2:123456789:cluster:t1</code>. 
  ##   ResourceType: JString
  ##               : <p>The type of resource with which you want to view tags. Valid resource types are: </p> <ul> <li> <p>Cluster</p> </li> <li> <p>CIDR/IP</p> </li> <li> <p>EC2 security group</p> </li> <li> <p>Snapshot</p> </li> <li> <p>Cluster security group</p> </li> <li> <p>Subnet group</p> </li> <li> <p>HSM connection</p> </li> <li> <p>HSM certificate</p> </li> <li> <p>Parameter group</p> </li> <li> <p>Snapshot copy grant</p> </li> </ul> <p>For more information about Amazon Redshift resource types and constructing ARNs, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-overview.html#redshift-iam-access-control-specify-actions">Specifying Policy Elements: Actions, Effects, Resources, and Principals</a> in the Amazon Redshift Cluster Management Guide. </p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching resources that are associated with the specified key or keys. For example, suppose that you have resources tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with all resources that have either or both of these tag keys associated with them.
  ##   Action: JString (required)
  ##   Version: JString (required)
  ##   MaxRecords: JInt
  ##             : The maximum number or response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned <code>marker</code> value. 
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching resources that are associated with the specified value or values. For example, suppose that you have resources tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with all resources that have either or both of these tag values associated with them.
  section = newJObject()
  var valid_608428 = query.getOrDefault("Marker")
  valid_608428 = validateParameter(valid_608428, JString, required = false,
                                 default = nil)
  if valid_608428 != nil:
    section.add "Marker", valid_608428
  var valid_608429 = query.getOrDefault("ResourceName")
  valid_608429 = validateParameter(valid_608429, JString, required = false,
                                 default = nil)
  if valid_608429 != nil:
    section.add "ResourceName", valid_608429
  var valid_608430 = query.getOrDefault("ResourceType")
  valid_608430 = validateParameter(valid_608430, JString, required = false,
                                 default = nil)
  if valid_608430 != nil:
    section.add "ResourceType", valid_608430
  var valid_608431 = query.getOrDefault("TagKeys")
  valid_608431 = validateParameter(valid_608431, JArray, required = false,
                                 default = nil)
  if valid_608431 != nil:
    section.add "TagKeys", valid_608431
  var valid_608432 = query.getOrDefault("Action")
  valid_608432 = validateParameter(valid_608432, JString, required = true,
                                 default = newJString("DescribeTags"))
  if valid_608432 != nil:
    section.add "Action", valid_608432
  var valid_608433 = query.getOrDefault("Version")
  valid_608433 = validateParameter(valid_608433, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_608433 != nil:
    section.add "Version", valid_608433
  var valid_608434 = query.getOrDefault("MaxRecords")
  valid_608434 = validateParameter(valid_608434, JInt, required = false, default = nil)
  if valid_608434 != nil:
    section.add "MaxRecords", valid_608434
  var valid_608435 = query.getOrDefault("TagValues")
  valid_608435 = validateParameter(valid_608435, JArray, required = false,
                                 default = nil)
  if valid_608435 != nil:
    section.add "TagValues", valid_608435
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_608436 = header.getOrDefault("X-Amz-Signature")
  valid_608436 = validateParameter(valid_608436, JString, required = false,
                                 default = nil)
  if valid_608436 != nil:
    section.add "X-Amz-Signature", valid_608436
  var valid_608437 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_608437 = validateParameter(valid_608437, JString, required = false,
                                 default = nil)
  if valid_608437 != nil:
    section.add "X-Amz-Content-Sha256", valid_608437
  var valid_608438 = header.getOrDefault("X-Amz-Date")
  valid_608438 = validateParameter(valid_608438, JString, required = false,
                                 default = nil)
  if valid_608438 != nil:
    section.add "X-Amz-Date", valid_608438
  var valid_608439 = header.getOrDefault("X-Amz-Credential")
  valid_608439 = validateParameter(valid_608439, JString, required = false,
                                 default = nil)
  if valid_608439 != nil:
    section.add "X-Amz-Credential", valid_608439
  var valid_608440 = header.getOrDefault("X-Amz-Security-Token")
  valid_608440 = validateParameter(valid_608440, JString, required = false,
                                 default = nil)
  if valid_608440 != nil:
    section.add "X-Amz-Security-Token", valid_608440
  var valid_608441 = header.getOrDefault("X-Amz-Algorithm")
  valid_608441 = validateParameter(valid_608441, JString, required = false,
                                 default = nil)
  if valid_608441 != nil:
    section.add "X-Amz-Algorithm", valid_608441
  var valid_608442 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_608442 = validateParameter(valid_608442, JString, required = false,
                                 default = nil)
  if valid_608442 != nil:
    section.add "X-Amz-SignedHeaders", valid_608442
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_608443: Call_GetDescribeTags_608425; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns a list of tags. You can return tags from a specific resource by specifying an ARN, or you can return all tags for a given type of resource, such as clusters, snapshots, and so on.</p> <p>The following are limitations for <code>DescribeTags</code>: </p> <ul> <li> <p>You cannot specify an ARN and a resource-type value together in the same request.</p> </li> <li> <p>You cannot use the <code>MaxRecords</code> and <code>Marker</code> parameters together with the ARN parameter.</p> </li> <li> <p>The <code>MaxRecords</code> parameter can be a range from 10 to 50 results to return in a request.</p> </li> </ul> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all resources that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all resources that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, resources are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_608443.validator(path, query, header, formData, body)
  let scheme = call_608443.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_608443.url(scheme.get, call_608443.host, call_608443.base,
                         call_608443.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_608443, url, valid)

proc call*(call_608444: Call_GetDescribeTags_608425; Marker: string = "";
          ResourceName: string = ""; ResourceType: string = ""; TagKeys: JsonNode = nil;
          Action: string = "DescribeTags"; Version: string = "2012-12-01";
          MaxRecords: int = 0; TagValues: JsonNode = nil): Recallable =
  ## getDescribeTags
  ## <p>Returns a list of tags. You can return tags from a specific resource by specifying an ARN, or you can return all tags for a given type of resource, such as clusters, snapshots, and so on.</p> <p>The following are limitations for <code>DescribeTags</code>: </p> <ul> <li> <p>You cannot specify an ARN and a resource-type value together in the same request.</p> </li> <li> <p>You cannot use the <code>MaxRecords</code> and <code>Marker</code> parameters together with the ARN parameter.</p> </li> <li> <p>The <code>MaxRecords</code> parameter can be a range from 10 to 50 results to return in a request.</p> </li> </ul> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all resources that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all resources that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, resources are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   Marker: string
  ##         : A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned marker value in the <code>marker</code> parameter and retrying the command. If the <code>marker</code> field is empty, all response records have been retrieved for the request. 
  ##   ResourceName: string
  ##               : The Amazon Resource Name (ARN) for which you want to describe the tag or tags. For example, <code>arn:aws:redshift:us-east-2:123456789:cluster:t1</code>. 
  ##   ResourceType: string
  ##               : <p>The type of resource with which you want to view tags. Valid resource types are: </p> <ul> <li> <p>Cluster</p> </li> <li> <p>CIDR/IP</p> </li> <li> <p>EC2 security group</p> </li> <li> <p>Snapshot</p> </li> <li> <p>Cluster security group</p> </li> <li> <p>Subnet group</p> </li> <li> <p>HSM connection</p> </li> <li> <p>HSM certificate</p> </li> <li> <p>Parameter group</p> </li> <li> <p>Snapshot copy grant</p> </li> </ul> <p>For more information about Amazon Redshift resource types and constructing ARNs, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-overview.html#redshift-iam-access-control-specify-actions">Specifying Policy Elements: Actions, Effects, Resources, and Principals</a> in the Amazon Redshift Cluster Management Guide. </p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching resources that are associated with the specified key or keys. For example, suppose that you have resources tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with all resources that have either or both of these tag keys associated with them.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   MaxRecords: int
  ##             : The maximum number or response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned <code>marker</code> value. 
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching resources that are associated with the specified value or values. For example, suppose that you have resources tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with all resources that have either or both of these tag values associated with them.
  var query_608445 = newJObject()
  add(query_608445, "Marker", newJString(Marker))
  add(query_608445, "ResourceName", newJString(ResourceName))
  add(query_608445, "ResourceType", newJString(ResourceType))
  if TagKeys != nil:
    query_608445.add "TagKeys", TagKeys
  add(query_608445, "Action", newJString(Action))
  add(query_608445, "Version", newJString(Version))
  add(query_608445, "MaxRecords", newJInt(MaxRecords))
  if TagValues != nil:
    query_608445.add "TagValues", TagValues
  result = call_608444.call(nil, query_608445, nil, nil, nil)

var getDescribeTags* = Call_GetDescribeTags_608425(name: "getDescribeTags",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=DescribeTags", validator: validate_GetDescribeTags_608426,
    base: "/", url: url_GetDescribeTags_608427, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDisableLogging_608484 = ref object of OpenApiRestCall_605573
proc url_PostDisableLogging_608486(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDisableLogging_608485(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Stops logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_608487 = query.getOrDefault("Action")
  valid_608487 = validateParameter(valid_608487, JString, required = true,
                                 default = newJString("DisableLogging"))
  if valid_608487 != nil:
    section.add "Action", valid_608487
  var valid_608488 = query.getOrDefault("Version")
  valid_608488 = validateParameter(valid_608488, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_608488 != nil:
    section.add "Version", valid_608488
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_608489 = header.getOrDefault("X-Amz-Signature")
  valid_608489 = validateParameter(valid_608489, JString, required = false,
                                 default = nil)
  if valid_608489 != nil:
    section.add "X-Amz-Signature", valid_608489
  var valid_608490 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_608490 = validateParameter(valid_608490, JString, required = false,
                                 default = nil)
  if valid_608490 != nil:
    section.add "X-Amz-Content-Sha256", valid_608490
  var valid_608491 = header.getOrDefault("X-Amz-Date")
  valid_608491 = validateParameter(valid_608491, JString, required = false,
                                 default = nil)
  if valid_608491 != nil:
    section.add "X-Amz-Date", valid_608491
  var valid_608492 = header.getOrDefault("X-Amz-Credential")
  valid_608492 = validateParameter(valid_608492, JString, required = false,
                                 default = nil)
  if valid_608492 != nil:
    section.add "X-Amz-Credential", valid_608492
  var valid_608493 = header.getOrDefault("X-Amz-Security-Token")
  valid_608493 = validateParameter(valid_608493, JString, required = false,
                                 default = nil)
  if valid_608493 != nil:
    section.add "X-Amz-Security-Token", valid_608493
  var valid_608494 = header.getOrDefault("X-Amz-Algorithm")
  valid_608494 = validateParameter(valid_608494, JString, required = false,
                                 default = nil)
  if valid_608494 != nil:
    section.add "X-Amz-Algorithm", valid_608494
  var valid_608495 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_608495 = validateParameter(valid_608495, JString, required = false,
                                 default = nil)
  if valid_608495 != nil:
    section.add "X-Amz-SignedHeaders", valid_608495
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The identifier of the cluster on which logging is to be stopped.</p> <p>Example: <code>examplecluster</code> </p>
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_608496 = formData.getOrDefault("ClusterIdentifier")
  valid_608496 = validateParameter(valid_608496, JString, required = true,
                                 default = nil)
  if valid_608496 != nil:
    section.add "ClusterIdentifier", valid_608496
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_608497: Call_PostDisableLogging_608484; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Stops logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
  ## 
  let valid = call_608497.validator(path, query, header, formData, body)
  let scheme = call_608497.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_608497.url(scheme.get, call_608497.host, call_608497.base,
                         call_608497.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_608497, url, valid)

proc call*(call_608498: Call_PostDisableLogging_608484; ClusterIdentifier: string;
          Action: string = "DisableLogging"; Version: string = "2012-12-01"): Recallable =
  ## postDisableLogging
  ## Stops logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The identifier of the cluster on which logging is to be stopped.</p> <p>Example: <code>examplecluster</code> </p>
  ##   Action: string (required)
  ##   Version: string (required)
  var query_608499 = newJObject()
  var formData_608500 = newJObject()
  add(formData_608500, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_608499, "Action", newJString(Action))
  add(query_608499, "Version", newJString(Version))
  result = call_608498.call(nil, query_608499, nil, formData_608500, nil)

var postDisableLogging* = Call_PostDisableLogging_608484(
    name: "postDisableLogging", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DisableLogging",
    validator: validate_PostDisableLogging_608485, base: "/",
    url: url_PostDisableLogging_608486, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDisableLogging_608468 = ref object of OpenApiRestCall_605573
proc url_GetDisableLogging_608470(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDisableLogging_608469(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## Stops logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The identifier of the cluster on which logging is to be stopped.</p> <p>Example: <code>examplecluster</code> </p>
  ##   Version: JString (required)
  section = newJObject()
  var valid_608471 = query.getOrDefault("Action")
  valid_608471 = validateParameter(valid_608471, JString, required = true,
                                 default = newJString("DisableLogging"))
  if valid_608471 != nil:
    section.add "Action", valid_608471
  var valid_608472 = query.getOrDefault("ClusterIdentifier")
  valid_608472 = validateParameter(valid_608472, JString, required = true,
                                 default = nil)
  if valid_608472 != nil:
    section.add "ClusterIdentifier", valid_608472
  var valid_608473 = query.getOrDefault("Version")
  valid_608473 = validateParameter(valid_608473, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_608473 != nil:
    section.add "Version", valid_608473
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_608474 = header.getOrDefault("X-Amz-Signature")
  valid_608474 = validateParameter(valid_608474, JString, required = false,
                                 default = nil)
  if valid_608474 != nil:
    section.add "X-Amz-Signature", valid_608474
  var valid_608475 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_608475 = validateParameter(valid_608475, JString, required = false,
                                 default = nil)
  if valid_608475 != nil:
    section.add "X-Amz-Content-Sha256", valid_608475
  var valid_608476 = header.getOrDefault("X-Amz-Date")
  valid_608476 = validateParameter(valid_608476, JString, required = false,
                                 default = nil)
  if valid_608476 != nil:
    section.add "X-Amz-Date", valid_608476
  var valid_608477 = header.getOrDefault("X-Amz-Credential")
  valid_608477 = validateParameter(valid_608477, JString, required = false,
                                 default = nil)
  if valid_608477 != nil:
    section.add "X-Amz-Credential", valid_608477
  var valid_608478 = header.getOrDefault("X-Amz-Security-Token")
  valid_608478 = validateParameter(valid_608478, JString, required = false,
                                 default = nil)
  if valid_608478 != nil:
    section.add "X-Amz-Security-Token", valid_608478
  var valid_608479 = header.getOrDefault("X-Amz-Algorithm")
  valid_608479 = validateParameter(valid_608479, JString, required = false,
                                 default = nil)
  if valid_608479 != nil:
    section.add "X-Amz-Algorithm", valid_608479
  var valid_608480 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_608480 = validateParameter(valid_608480, JString, required = false,
                                 default = nil)
  if valid_608480 != nil:
    section.add "X-Amz-SignedHeaders", valid_608480
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_608481: Call_GetDisableLogging_608468; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Stops logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
  ## 
  let valid = call_608481.validator(path, query, header, formData, body)
  let scheme = call_608481.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_608481.url(scheme.get, call_608481.host, call_608481.base,
                         call_608481.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_608481, url, valid)

proc call*(call_608482: Call_GetDisableLogging_608468; ClusterIdentifier: string;
          Action: string = "DisableLogging"; Version: string = "2012-12-01"): Recallable =
  ## getDisableLogging
  ## Stops logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The identifier of the cluster on which logging is to be stopped.</p> <p>Example: <code>examplecluster</code> </p>
  ##   Version: string (required)
  var query_608483 = newJObject()
  add(query_608483, "Action", newJString(Action))
  add(query_608483, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_608483, "Version", newJString(Version))
  result = call_608482.call(nil, query_608483, nil, nil, nil)

var getDisableLogging* = Call_GetDisableLogging_608468(name: "getDisableLogging",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=DisableLogging", validator: validate_GetDisableLogging_608469,
    base: "/", url: url_GetDisableLogging_608470,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDisableSnapshotCopy_608517 = ref object of OpenApiRestCall_605573
proc url_PostDisableSnapshotCopy_608519(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDisableSnapshotCopy_608518(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Disables the automatic copying of snapshots from one region to another region for a specified cluster.</p> <p>If your cluster and its snapshots are encrypted using a customer master key (CMK) from AWS KMS, use <a>DeleteSnapshotCopyGrant</a> to delete the grant that grants Amazon Redshift permission to the CMK in the destination region. </p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_608520 = query.getOrDefault("Action")
  valid_608520 = validateParameter(valid_608520, JString, required = true,
                                 default = newJString("DisableSnapshotCopy"))
  if valid_608520 != nil:
    section.add "Action", valid_608520
  var valid_608521 = query.getOrDefault("Version")
  valid_608521 = validateParameter(valid_608521, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_608521 != nil:
    section.add "Version", valid_608521
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_608522 = header.getOrDefault("X-Amz-Signature")
  valid_608522 = validateParameter(valid_608522, JString, required = false,
                                 default = nil)
  if valid_608522 != nil:
    section.add "X-Amz-Signature", valid_608522
  var valid_608523 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_608523 = validateParameter(valid_608523, JString, required = false,
                                 default = nil)
  if valid_608523 != nil:
    section.add "X-Amz-Content-Sha256", valid_608523
  var valid_608524 = header.getOrDefault("X-Amz-Date")
  valid_608524 = validateParameter(valid_608524, JString, required = false,
                                 default = nil)
  if valid_608524 != nil:
    section.add "X-Amz-Date", valid_608524
  var valid_608525 = header.getOrDefault("X-Amz-Credential")
  valid_608525 = validateParameter(valid_608525, JString, required = false,
                                 default = nil)
  if valid_608525 != nil:
    section.add "X-Amz-Credential", valid_608525
  var valid_608526 = header.getOrDefault("X-Amz-Security-Token")
  valid_608526 = validateParameter(valid_608526, JString, required = false,
                                 default = nil)
  if valid_608526 != nil:
    section.add "X-Amz-Security-Token", valid_608526
  var valid_608527 = header.getOrDefault("X-Amz-Algorithm")
  valid_608527 = validateParameter(valid_608527, JString, required = false,
                                 default = nil)
  if valid_608527 != nil:
    section.add "X-Amz-Algorithm", valid_608527
  var valid_608528 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_608528 = validateParameter(valid_608528, JString, required = false,
                                 default = nil)
  if valid_608528 != nil:
    section.add "X-Amz-SignedHeaders", valid_608528
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of the source cluster that you want to disable copying of snapshots to a destination region.</p> <p>Constraints: Must be the valid name of an existing cluster that has cross-region snapshot copy enabled.</p>
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_608529 = formData.getOrDefault("ClusterIdentifier")
  valid_608529 = validateParameter(valid_608529, JString, required = true,
                                 default = nil)
  if valid_608529 != nil:
    section.add "ClusterIdentifier", valid_608529
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_608530: Call_PostDisableSnapshotCopy_608517; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Disables the automatic copying of snapshots from one region to another region for a specified cluster.</p> <p>If your cluster and its snapshots are encrypted using a customer master key (CMK) from AWS KMS, use <a>DeleteSnapshotCopyGrant</a> to delete the grant that grants Amazon Redshift permission to the CMK in the destination region. </p>
  ## 
  let valid = call_608530.validator(path, query, header, formData, body)
  let scheme = call_608530.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_608530.url(scheme.get, call_608530.host, call_608530.base,
                         call_608530.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_608530, url, valid)

proc call*(call_608531: Call_PostDisableSnapshotCopy_608517;
          ClusterIdentifier: string; Action: string = "DisableSnapshotCopy";
          Version: string = "2012-12-01"): Recallable =
  ## postDisableSnapshotCopy
  ## <p>Disables the automatic copying of snapshots from one region to another region for a specified cluster.</p> <p>If your cluster and its snapshots are encrypted using a customer master key (CMK) from AWS KMS, use <a>DeleteSnapshotCopyGrant</a> to delete the grant that grants Amazon Redshift permission to the CMK in the destination region. </p>
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of the source cluster that you want to disable copying of snapshots to a destination region.</p> <p>Constraints: Must be the valid name of an existing cluster that has cross-region snapshot copy enabled.</p>
  ##   Action: string (required)
  ##   Version: string (required)
  var query_608532 = newJObject()
  var formData_608533 = newJObject()
  add(formData_608533, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_608532, "Action", newJString(Action))
  add(query_608532, "Version", newJString(Version))
  result = call_608531.call(nil, query_608532, nil, formData_608533, nil)

var postDisableSnapshotCopy* = Call_PostDisableSnapshotCopy_608517(
    name: "postDisableSnapshotCopy", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DisableSnapshotCopy",
    validator: validate_PostDisableSnapshotCopy_608518, base: "/",
    url: url_PostDisableSnapshotCopy_608519, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDisableSnapshotCopy_608501 = ref object of OpenApiRestCall_605573
proc url_GetDisableSnapshotCopy_608503(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDisableSnapshotCopy_608502(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Disables the automatic copying of snapshots from one region to another region for a specified cluster.</p> <p>If your cluster and its snapshots are encrypted using a customer master key (CMK) from AWS KMS, use <a>DeleteSnapshotCopyGrant</a> to delete the grant that grants Amazon Redshift permission to the CMK in the destination region. </p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of the source cluster that you want to disable copying of snapshots to a destination region.</p> <p>Constraints: Must be the valid name of an existing cluster that has cross-region snapshot copy enabled.</p>
  ##   Version: JString (required)
  section = newJObject()
  var valid_608504 = query.getOrDefault("Action")
  valid_608504 = validateParameter(valid_608504, JString, required = true,
                                 default = newJString("DisableSnapshotCopy"))
  if valid_608504 != nil:
    section.add "Action", valid_608504
  var valid_608505 = query.getOrDefault("ClusterIdentifier")
  valid_608505 = validateParameter(valid_608505, JString, required = true,
                                 default = nil)
  if valid_608505 != nil:
    section.add "ClusterIdentifier", valid_608505
  var valid_608506 = query.getOrDefault("Version")
  valid_608506 = validateParameter(valid_608506, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_608506 != nil:
    section.add "Version", valid_608506
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_608507 = header.getOrDefault("X-Amz-Signature")
  valid_608507 = validateParameter(valid_608507, JString, required = false,
                                 default = nil)
  if valid_608507 != nil:
    section.add "X-Amz-Signature", valid_608507
  var valid_608508 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_608508 = validateParameter(valid_608508, JString, required = false,
                                 default = nil)
  if valid_608508 != nil:
    section.add "X-Amz-Content-Sha256", valid_608508
  var valid_608509 = header.getOrDefault("X-Amz-Date")
  valid_608509 = validateParameter(valid_608509, JString, required = false,
                                 default = nil)
  if valid_608509 != nil:
    section.add "X-Amz-Date", valid_608509
  var valid_608510 = header.getOrDefault("X-Amz-Credential")
  valid_608510 = validateParameter(valid_608510, JString, required = false,
                                 default = nil)
  if valid_608510 != nil:
    section.add "X-Amz-Credential", valid_608510
  var valid_608511 = header.getOrDefault("X-Amz-Security-Token")
  valid_608511 = validateParameter(valid_608511, JString, required = false,
                                 default = nil)
  if valid_608511 != nil:
    section.add "X-Amz-Security-Token", valid_608511
  var valid_608512 = header.getOrDefault("X-Amz-Algorithm")
  valid_608512 = validateParameter(valid_608512, JString, required = false,
                                 default = nil)
  if valid_608512 != nil:
    section.add "X-Amz-Algorithm", valid_608512
  var valid_608513 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_608513 = validateParameter(valid_608513, JString, required = false,
                                 default = nil)
  if valid_608513 != nil:
    section.add "X-Amz-SignedHeaders", valid_608513
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_608514: Call_GetDisableSnapshotCopy_608501; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Disables the automatic copying of snapshots from one region to another region for a specified cluster.</p> <p>If your cluster and its snapshots are encrypted using a customer master key (CMK) from AWS KMS, use <a>DeleteSnapshotCopyGrant</a> to delete the grant that grants Amazon Redshift permission to the CMK in the destination region. </p>
  ## 
  let valid = call_608514.validator(path, query, header, formData, body)
  let scheme = call_608514.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_608514.url(scheme.get, call_608514.host, call_608514.base,
                         call_608514.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_608514, url, valid)

proc call*(call_608515: Call_GetDisableSnapshotCopy_608501;
          ClusterIdentifier: string; Action: string = "DisableSnapshotCopy";
          Version: string = "2012-12-01"): Recallable =
  ## getDisableSnapshotCopy
  ## <p>Disables the automatic copying of snapshots from one region to another region for a specified cluster.</p> <p>If your cluster and its snapshots are encrypted using a customer master key (CMK) from AWS KMS, use <a>DeleteSnapshotCopyGrant</a> to delete the grant that grants Amazon Redshift permission to the CMK in the destination region. </p>
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of the source cluster that you want to disable copying of snapshots to a destination region.</p> <p>Constraints: Must be the valid name of an existing cluster that has cross-region snapshot copy enabled.</p>
  ##   Version: string (required)
  var query_608516 = newJObject()
  add(query_608516, "Action", newJString(Action))
  add(query_608516, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_608516, "Version", newJString(Version))
  result = call_608515.call(nil, query_608516, nil, nil, nil)

var getDisableSnapshotCopy* = Call_GetDisableSnapshotCopy_608501(
    name: "getDisableSnapshotCopy", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DisableSnapshotCopy",
    validator: validate_GetDisableSnapshotCopy_608502, base: "/",
    url: url_GetDisableSnapshotCopy_608503, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostEnableLogging_608552 = ref object of OpenApiRestCall_605573
proc url_PostEnableLogging_608554(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostEnableLogging_608553(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## Starts logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_608555 = query.getOrDefault("Action")
  valid_608555 = validateParameter(valid_608555, JString, required = true,
                                 default = newJString("EnableLogging"))
  if valid_608555 != nil:
    section.add "Action", valid_608555
  var valid_608556 = query.getOrDefault("Version")
  valid_608556 = validateParameter(valid_608556, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_608556 != nil:
    section.add "Version", valid_608556
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_608557 = header.getOrDefault("X-Amz-Signature")
  valid_608557 = validateParameter(valid_608557, JString, required = false,
                                 default = nil)
  if valid_608557 != nil:
    section.add "X-Amz-Signature", valid_608557
  var valid_608558 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_608558 = validateParameter(valid_608558, JString, required = false,
                                 default = nil)
  if valid_608558 != nil:
    section.add "X-Amz-Content-Sha256", valid_608558
  var valid_608559 = header.getOrDefault("X-Amz-Date")
  valid_608559 = validateParameter(valid_608559, JString, required = false,
                                 default = nil)
  if valid_608559 != nil:
    section.add "X-Amz-Date", valid_608559
  var valid_608560 = header.getOrDefault("X-Amz-Credential")
  valid_608560 = validateParameter(valid_608560, JString, required = false,
                                 default = nil)
  if valid_608560 != nil:
    section.add "X-Amz-Credential", valid_608560
  var valid_608561 = header.getOrDefault("X-Amz-Security-Token")
  valid_608561 = validateParameter(valid_608561, JString, required = false,
                                 default = nil)
  if valid_608561 != nil:
    section.add "X-Amz-Security-Token", valid_608561
  var valid_608562 = header.getOrDefault("X-Amz-Algorithm")
  valid_608562 = validateParameter(valid_608562, JString, required = false,
                                 default = nil)
  if valid_608562 != nil:
    section.add "X-Amz-Algorithm", valid_608562
  var valid_608563 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_608563 = validateParameter(valid_608563, JString, required = false,
                                 default = nil)
  if valid_608563 != nil:
    section.add "X-Amz-SignedHeaders", valid_608563
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The identifier of the cluster on which logging is to be started.</p> <p>Example: <code>examplecluster</code> </p>
  ##   BucketName: JString (required)
  ##             : <p>The name of an existing S3 bucket where the log files are to be stored.</p> <p>Constraints:</p> <ul> <li> <p>Must be in the same region as the cluster</p> </li> <li> <p>The cluster must have read bucket and put object permissions</p> </li> </ul>
  ##   S3KeyPrefix: JString
  ##              : <p>The prefix applied to the log file names.</p> <p>Constraints:</p> <ul> <li> <p>Cannot exceed 512 characters</p> </li> <li> <p>Cannot contain spaces( ), double quotes ("), single quotes ('), a backslash (\), or control characters. The hexadecimal codes for invalid characters are: </p> <ul> <li> <p>x00 to x20</p> </li> <li> <p>x22</p> </li> <li> <p>x27</p> </li> <li> <p>x5c</p> </li> <li> <p>x7f or larger</p> </li> </ul> </li> </ul>
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_608564 = formData.getOrDefault("ClusterIdentifier")
  valid_608564 = validateParameter(valid_608564, JString, required = true,
                                 default = nil)
  if valid_608564 != nil:
    section.add "ClusterIdentifier", valid_608564
  var valid_608565 = formData.getOrDefault("BucketName")
  valid_608565 = validateParameter(valid_608565, JString, required = true,
                                 default = nil)
  if valid_608565 != nil:
    section.add "BucketName", valid_608565
  var valid_608566 = formData.getOrDefault("S3KeyPrefix")
  valid_608566 = validateParameter(valid_608566, JString, required = false,
                                 default = nil)
  if valid_608566 != nil:
    section.add "S3KeyPrefix", valid_608566
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_608567: Call_PostEnableLogging_608552; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Starts logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
  ## 
  let valid = call_608567.validator(path, query, header, formData, body)
  let scheme = call_608567.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_608567.url(scheme.get, call_608567.host, call_608567.base,
                         call_608567.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_608567, url, valid)

proc call*(call_608568: Call_PostEnableLogging_608552; ClusterIdentifier: string;
          BucketName: string; Action: string = "EnableLogging";
          Version: string = "2012-12-01"; S3KeyPrefix: string = ""): Recallable =
  ## postEnableLogging
  ## Starts logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The identifier of the cluster on which logging is to be started.</p> <p>Example: <code>examplecluster</code> </p>
  ##   Action: string (required)
  ##   BucketName: string (required)
  ##             : <p>The name of an existing S3 bucket where the log files are to be stored.</p> <p>Constraints:</p> <ul> <li> <p>Must be in the same region as the cluster</p> </li> <li> <p>The cluster must have read bucket and put object permissions</p> </li> </ul>
  ##   Version: string (required)
  ##   S3KeyPrefix: string
  ##              : <p>The prefix applied to the log file names.</p> <p>Constraints:</p> <ul> <li> <p>Cannot exceed 512 characters</p> </li> <li> <p>Cannot contain spaces( ), double quotes ("), single quotes ('), a backslash (\), or control characters. The hexadecimal codes for invalid characters are: </p> <ul> <li> <p>x00 to x20</p> </li> <li> <p>x22</p> </li> <li> <p>x27</p> </li> <li> <p>x5c</p> </li> <li> <p>x7f or larger</p> </li> </ul> </li> </ul>
  var query_608569 = newJObject()
  var formData_608570 = newJObject()
  add(formData_608570, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_608569, "Action", newJString(Action))
  add(formData_608570, "BucketName", newJString(BucketName))
  add(query_608569, "Version", newJString(Version))
  add(formData_608570, "S3KeyPrefix", newJString(S3KeyPrefix))
  result = call_608568.call(nil, query_608569, nil, formData_608570, nil)

var postEnableLogging* = Call_PostEnableLogging_608552(name: "postEnableLogging",
    meth: HttpMethod.HttpPost, host: "redshift.amazonaws.com",
    route: "/#Action=EnableLogging", validator: validate_PostEnableLogging_608553,
    base: "/", url: url_PostEnableLogging_608554,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetEnableLogging_608534 = ref object of OpenApiRestCall_605573
proc url_GetEnableLogging_608536(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetEnableLogging_608535(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Starts logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   BucketName: JString (required)
  ##             : <p>The name of an existing S3 bucket where the log files are to be stored.</p> <p>Constraints:</p> <ul> <li> <p>Must be in the same region as the cluster</p> </li> <li> <p>The cluster must have read bucket and put object permissions</p> </li> </ul>
  ##   S3KeyPrefix: JString
  ##              : <p>The prefix applied to the log file names.</p> <p>Constraints:</p> <ul> <li> <p>Cannot exceed 512 characters</p> </li> <li> <p>Cannot contain spaces( ), double quotes ("), single quotes ('), a backslash (\), or control characters. The hexadecimal codes for invalid characters are: </p> <ul> <li> <p>x00 to x20</p> </li> <li> <p>x22</p> </li> <li> <p>x27</p> </li> <li> <p>x5c</p> </li> <li> <p>x7f or larger</p> </li> </ul> </li> </ul>
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The identifier of the cluster on which logging is to be started.</p> <p>Example: <code>examplecluster</code> </p>
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `BucketName` field"
  var valid_608537 = query.getOrDefault("BucketName")
  valid_608537 = validateParameter(valid_608537, JString, required = true,
                                 default = nil)
  if valid_608537 != nil:
    section.add "BucketName", valid_608537
  var valid_608538 = query.getOrDefault("S3KeyPrefix")
  valid_608538 = validateParameter(valid_608538, JString, required = false,
                                 default = nil)
  if valid_608538 != nil:
    section.add "S3KeyPrefix", valid_608538
  var valid_608539 = query.getOrDefault("Action")
  valid_608539 = validateParameter(valid_608539, JString, required = true,
                                 default = newJString("EnableLogging"))
  if valid_608539 != nil:
    section.add "Action", valid_608539
  var valid_608540 = query.getOrDefault("ClusterIdentifier")
  valid_608540 = validateParameter(valid_608540, JString, required = true,
                                 default = nil)
  if valid_608540 != nil:
    section.add "ClusterIdentifier", valid_608540
  var valid_608541 = query.getOrDefault("Version")
  valid_608541 = validateParameter(valid_608541, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_608541 != nil:
    section.add "Version", valid_608541
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_608542 = header.getOrDefault("X-Amz-Signature")
  valid_608542 = validateParameter(valid_608542, JString, required = false,
                                 default = nil)
  if valid_608542 != nil:
    section.add "X-Amz-Signature", valid_608542
  var valid_608543 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_608543 = validateParameter(valid_608543, JString, required = false,
                                 default = nil)
  if valid_608543 != nil:
    section.add "X-Amz-Content-Sha256", valid_608543
  var valid_608544 = header.getOrDefault("X-Amz-Date")
  valid_608544 = validateParameter(valid_608544, JString, required = false,
                                 default = nil)
  if valid_608544 != nil:
    section.add "X-Amz-Date", valid_608544
  var valid_608545 = header.getOrDefault("X-Amz-Credential")
  valid_608545 = validateParameter(valid_608545, JString, required = false,
                                 default = nil)
  if valid_608545 != nil:
    section.add "X-Amz-Credential", valid_608545
  var valid_608546 = header.getOrDefault("X-Amz-Security-Token")
  valid_608546 = validateParameter(valid_608546, JString, required = false,
                                 default = nil)
  if valid_608546 != nil:
    section.add "X-Amz-Security-Token", valid_608546
  var valid_608547 = header.getOrDefault("X-Amz-Algorithm")
  valid_608547 = validateParameter(valid_608547, JString, required = false,
                                 default = nil)
  if valid_608547 != nil:
    section.add "X-Amz-Algorithm", valid_608547
  var valid_608548 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_608548 = validateParameter(valid_608548, JString, required = false,
                                 default = nil)
  if valid_608548 != nil:
    section.add "X-Amz-SignedHeaders", valid_608548
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_608549: Call_GetEnableLogging_608534; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Starts logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
  ## 
  let valid = call_608549.validator(path, query, header, formData, body)
  let scheme = call_608549.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_608549.url(scheme.get, call_608549.host, call_608549.base,
                         call_608549.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_608549, url, valid)

proc call*(call_608550: Call_GetEnableLogging_608534; BucketName: string;
          ClusterIdentifier: string; S3KeyPrefix: string = "";
          Action: string = "EnableLogging"; Version: string = "2012-12-01"): Recallable =
  ## getEnableLogging
  ## Starts logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
  ##   BucketName: string (required)
  ##             : <p>The name of an existing S3 bucket where the log files are to be stored.</p> <p>Constraints:</p> <ul> <li> <p>Must be in the same region as the cluster</p> </li> <li> <p>The cluster must have read bucket and put object permissions</p> </li> </ul>
  ##   S3KeyPrefix: string
  ##              : <p>The prefix applied to the log file names.</p> <p>Constraints:</p> <ul> <li> <p>Cannot exceed 512 characters</p> </li> <li> <p>Cannot contain spaces( ), double quotes ("), single quotes ('), a backslash (\), or control characters. The hexadecimal codes for invalid characters are: </p> <ul> <li> <p>x00 to x20</p> </li> <li> <p>x22</p> </li> <li> <p>x27</p> </li> <li> <p>x5c</p> </li> <li> <p>x7f or larger</p> </li> </ul> </li> </ul>
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The identifier of the cluster on which logging is to be started.</p> <p>Example: <code>examplecluster</code> </p>
  ##   Version: string (required)
  var query_608551 = newJObject()
  add(query_608551, "BucketName", newJString(BucketName))
  add(query_608551, "S3KeyPrefix", newJString(S3KeyPrefix))
  add(query_608551, "Action", newJString(Action))
  add(query_608551, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_608551, "Version", newJString(Version))
  result = call_608550.call(nil, query_608551, nil, nil, nil)

var getEnableLogging* = Call_GetEnableLogging_608534(name: "getEnableLogging",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=EnableLogging", validator: validate_GetEnableLogging_608535,
    base: "/", url: url_GetEnableLogging_608536,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostEnableSnapshotCopy_608591 = ref object of OpenApiRestCall_605573
proc url_PostEnableSnapshotCopy_608593(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostEnableSnapshotCopy_608592(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Enables the automatic copy of snapshots from one region to another region for a specified cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_608594 = query.getOrDefault("Action")
  valid_608594 = validateParameter(valid_608594, JString, required = true,
                                 default = newJString("EnableSnapshotCopy"))
  if valid_608594 != nil:
    section.add "Action", valid_608594
  var valid_608595 = query.getOrDefault("Version")
  valid_608595 = validateParameter(valid_608595, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_608595 != nil:
    section.add "Version", valid_608595
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_608596 = header.getOrDefault("X-Amz-Signature")
  valid_608596 = validateParameter(valid_608596, JString, required = false,
                                 default = nil)
  if valid_608596 != nil:
    section.add "X-Amz-Signature", valid_608596
  var valid_608597 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_608597 = validateParameter(valid_608597, JString, required = false,
                                 default = nil)
  if valid_608597 != nil:
    section.add "X-Amz-Content-Sha256", valid_608597
  var valid_608598 = header.getOrDefault("X-Amz-Date")
  valid_608598 = validateParameter(valid_608598, JString, required = false,
                                 default = nil)
  if valid_608598 != nil:
    section.add "X-Amz-Date", valid_608598
  var valid_608599 = header.getOrDefault("X-Amz-Credential")
  valid_608599 = validateParameter(valid_608599, JString, required = false,
                                 default = nil)
  if valid_608599 != nil:
    section.add "X-Amz-Credential", valid_608599
  var valid_608600 = header.getOrDefault("X-Amz-Security-Token")
  valid_608600 = validateParameter(valid_608600, JString, required = false,
                                 default = nil)
  if valid_608600 != nil:
    section.add "X-Amz-Security-Token", valid_608600
  var valid_608601 = header.getOrDefault("X-Amz-Algorithm")
  valid_608601 = validateParameter(valid_608601, JString, required = false,
                                 default = nil)
  if valid_608601 != nil:
    section.add "X-Amz-Algorithm", valid_608601
  var valid_608602 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_608602 = validateParameter(valid_608602, JString, required = false,
                                 default = nil)
  if valid_608602 != nil:
    section.add "X-Amz-SignedHeaders", valid_608602
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of the source cluster to copy snapshots from.</p> <p>Constraints: Must be the valid name of an existing cluster that does not already have cross-region snapshot copy enabled.</p>
  ##   RetentionPeriod: JInt
  ##                  : <p>The number of days to retain automated snapshots in the destination region after they are copied from the source region.</p> <p>Default: 7.</p> <p>Constraints: Must be at least 1 and no more than 35.</p>
  ##   DestinationRegion: JString (required)
  ##                    : <p>The destination AWS Region that you want to copy snapshots to.</p> <p>Constraints: Must be the name of a valid AWS Region. For more information, see <a 
  ## href="https://docs.aws.amazon.com/general/latest/gr/rande.html#redshift_region">Regions and Endpoints</a> in the Amazon Web Services General Reference. </p>
  ##   SnapshotCopyGrantName: JString
  ##                        : The name of the snapshot copy grant to use when snapshots of an AWS KMS-encrypted cluster are copied to the destination region.
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The number of days to retain newly copied snapshots in the destination AWS Region after they are copied from the source AWS Region. If the value is -1, the manual snapshot is retained indefinitely. </p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_608603 = formData.getOrDefault("ClusterIdentifier")
  valid_608603 = validateParameter(valid_608603, JString, required = true,
                                 default = nil)
  if valid_608603 != nil:
    section.add "ClusterIdentifier", valid_608603
  var valid_608604 = formData.getOrDefault("RetentionPeriod")
  valid_608604 = validateParameter(valid_608604, JInt, required = false, default = nil)
  if valid_608604 != nil:
    section.add "RetentionPeriod", valid_608604
  var valid_608605 = formData.getOrDefault("DestinationRegion")
  valid_608605 = validateParameter(valid_608605, JString, required = true,
                                 default = nil)
  if valid_608605 != nil:
    section.add "DestinationRegion", valid_608605
  var valid_608606 = formData.getOrDefault("SnapshotCopyGrantName")
  valid_608606 = validateParameter(valid_608606, JString, required = false,
                                 default = nil)
  if valid_608606 != nil:
    section.add "SnapshotCopyGrantName", valid_608606
  var valid_608607 = formData.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_608607 = validateParameter(valid_608607, JInt, required = false, default = nil)
  if valid_608607 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_608607
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_608608: Call_PostEnableSnapshotCopy_608591; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Enables the automatic copy of snapshots from one region to another region for a specified cluster.
  ## 
  let valid = call_608608.validator(path, query, header, formData, body)
  let scheme = call_608608.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_608608.url(scheme.get, call_608608.host, call_608608.base,
                         call_608608.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_608608, url, valid)

proc call*(call_608609: Call_PostEnableSnapshotCopy_608591;
          ClusterIdentifier: string; DestinationRegion: string;
          RetentionPeriod: int = 0; Action: string = "EnableSnapshotCopy";
          SnapshotCopyGrantName: string = ""; Version: string = "2012-12-01";
          ManualSnapshotRetentionPeriod: int = 0): Recallable =
  ## postEnableSnapshotCopy
  ## Enables the automatic copy of snapshots from one region to another region for a specified cluster.
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of the source cluster to copy snapshots from.</p> <p>Constraints: Must be the valid name of an existing cluster that does not already have cross-region snapshot copy enabled.</p>
  ##   RetentionPeriod: int
  ##                  : <p>The number of days to retain automated snapshots in the destination region after they are copied from the source region.</p> <p>Default: 7.</p> <p>Constraints: Must be at least 1 and no more than 35.</p>
  ##   DestinationRegion: string (required)
  ##                    : <p>The destination AWS Region that you want to copy snapshots to.</p> <p>Constraints: Must be the name of a valid AWS Region. For more information, see <a 
  ## href="https://docs.aws.amazon.com/general/latest/gr/rande.html#redshift_region">Regions and Endpoints</a> in the Amazon Web Services General Reference. </p>
  ##   Action: string (required)
  ##   SnapshotCopyGrantName: string
  ##                        : The name of the snapshot copy grant to use when snapshots of an AWS KMS-encrypted cluster are copied to the destination region.
  ##   Version: string (required)
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The number of days to retain newly copied snapshots in the destination AWS Region after they are copied from the source AWS Region. If the value is -1, the manual snapshot is retained indefinitely. </p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  var query_608610 = newJObject()
  var formData_608611 = newJObject()
  add(formData_608611, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_608611, "RetentionPeriod", newJInt(RetentionPeriod))
  add(formData_608611, "DestinationRegion", newJString(DestinationRegion))
  add(query_608610, "Action", newJString(Action))
  add(formData_608611, "SnapshotCopyGrantName", newJString(SnapshotCopyGrantName))
  add(query_608610, "Version", newJString(Version))
  add(formData_608611, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  result = call_608609.call(nil, query_608610, nil, formData_608611, nil)

var postEnableSnapshotCopy* = Call_PostEnableSnapshotCopy_608591(
    name: "postEnableSnapshotCopy", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=EnableSnapshotCopy",
    validator: validate_PostEnableSnapshotCopy_608592, base: "/",
    url: url_PostEnableSnapshotCopy_608593, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetEnableSnapshotCopy_608571 = ref object of OpenApiRestCall_605573
proc url_GetEnableSnapshotCopy_608573(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetEnableSnapshotCopy_608572(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Enables the automatic copy of snapshots from one region to another region for a specified cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The number of days to retain newly copied snapshots in the destination AWS Region after they are copied from the source AWS Region. If the value is -1, the manual snapshot is retained indefinitely. </p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  ##   DestinationRegion: JString (required)
  ##                    : <p>The destination AWS Region that you want to copy snapshots to.</p> <p>Constraints: Must be the name of a valid AWS Region. For more information, see <a 
  ## href="https://docs.aws.amazon.com/general/latest/gr/rande.html#redshift_region">Regions and Endpoints</a> in the Amazon Web Services General Reference. </p>
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of the source cluster to copy snapshots from.</p> <p>Constraints: Must be the valid name of an existing cluster that does not already have cross-region snapshot copy enabled.</p>
  ##   Version: JString (required)
  ##   RetentionPeriod: JInt
  ##                  : <p>The number of days to retain automated snapshots in the destination region after they are copied from the source region.</p> <p>Default: 7.</p> <p>Constraints: Must be at least 1 and no more than 35.</p>
  ##   SnapshotCopyGrantName: JString
  ##                        : The name of the snapshot copy grant to use when snapshots of an AWS KMS-encrypted cluster are copied to the destination region.
  section = newJObject()
  var valid_608574 = query.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_608574 = validateParameter(valid_608574, JInt, required = false, default = nil)
  if valid_608574 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_608574
  assert query != nil,
        "query argument is necessary due to required `DestinationRegion` field"
  var valid_608575 = query.getOrDefault("DestinationRegion")
  valid_608575 = validateParameter(valid_608575, JString, required = true,
                                 default = nil)
  if valid_608575 != nil:
    section.add "DestinationRegion", valid_608575
  var valid_608576 = query.getOrDefault("Action")
  valid_608576 = validateParameter(valid_608576, JString, required = true,
                                 default = newJString("EnableSnapshotCopy"))
  if valid_608576 != nil:
    section.add "Action", valid_608576
  var valid_608577 = query.getOrDefault("ClusterIdentifier")
  valid_608577 = validateParameter(valid_608577, JString, required = true,
                                 default = nil)
  if valid_608577 != nil:
    section.add "ClusterIdentifier", valid_608577
  var valid_608578 = query.getOrDefault("Version")
  valid_608578 = validateParameter(valid_608578, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_608578 != nil:
    section.add "Version", valid_608578
  var valid_608579 = query.getOrDefault("RetentionPeriod")
  valid_608579 = validateParameter(valid_608579, JInt, required = false, default = nil)
  if valid_608579 != nil:
    section.add "RetentionPeriod", valid_608579
  var valid_608580 = query.getOrDefault("SnapshotCopyGrantName")
  valid_608580 = validateParameter(valid_608580, JString, required = false,
                                 default = nil)
  if valid_608580 != nil:
    section.add "SnapshotCopyGrantName", valid_608580
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_608581 = header.getOrDefault("X-Amz-Signature")
  valid_608581 = validateParameter(valid_608581, JString, required = false,
                                 default = nil)
  if valid_608581 != nil:
    section.add "X-Amz-Signature", valid_608581
  var valid_608582 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_608582 = validateParameter(valid_608582, JString, required = false,
                                 default = nil)
  if valid_608582 != nil:
    section.add "X-Amz-Content-Sha256", valid_608582
  var valid_608583 = header.getOrDefault("X-Amz-Date")
  valid_608583 = validateParameter(valid_608583, JString, required = false,
                                 default = nil)
  if valid_608583 != nil:
    section.add "X-Amz-Date", valid_608583
  var valid_608584 = header.getOrDefault("X-Amz-Credential")
  valid_608584 = validateParameter(valid_608584, JString, required = false,
                                 default = nil)
  if valid_608584 != nil:
    section.add "X-Amz-Credential", valid_608584
  var valid_608585 = header.getOrDefault("X-Amz-Security-Token")
  valid_608585 = validateParameter(valid_608585, JString, required = false,
                                 default = nil)
  if valid_608585 != nil:
    section.add "X-Amz-Security-Token", valid_608585
  var valid_608586 = header.getOrDefault("X-Amz-Algorithm")
  valid_608586 = validateParameter(valid_608586, JString, required = false,
                                 default = nil)
  if valid_608586 != nil:
    section.add "X-Amz-Algorithm", valid_608586
  var valid_608587 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_608587 = validateParameter(valid_608587, JString, required = false,
                                 default = nil)
  if valid_608587 != nil:
    section.add "X-Amz-SignedHeaders", valid_608587
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_608588: Call_GetEnableSnapshotCopy_608571; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Enables the automatic copy of snapshots from one region to another region for a specified cluster.
  ## 
  let valid = call_608588.validator(path, query, header, formData, body)
  let scheme = call_608588.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_608588.url(scheme.get, call_608588.host, call_608588.base,
                         call_608588.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_608588, url, valid)

proc call*(call_608589: Call_GetEnableSnapshotCopy_608571;
          DestinationRegion: string; ClusterIdentifier: string;
          ManualSnapshotRetentionPeriod: int = 0;
          Action: string = "EnableSnapshotCopy"; Version: string = "2012-12-01";
          RetentionPeriod: int = 0; SnapshotCopyGrantName: string = ""): Recallable =
  ## getEnableSnapshotCopy
  ## Enables the automatic copy of snapshots from one region to another region for a specified cluster.
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The number of days to retain newly copied snapshots in the destination AWS Region after they are copied from the source AWS Region. If the value is -1, the manual snapshot is retained indefinitely. </p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  ##   DestinationRegion: string (required)
  ##                    : <p>The destination AWS Region that you want to copy snapshots to.</p> <p>Constraints: Must be the name of a valid AWS Region. For more information, see <a 
  ## href="https://docs.aws.amazon.com/general/latest/gr/rande.html#redshift_region">Regions and Endpoints</a> in the Amazon Web Services General Reference. </p>
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of the source cluster to copy snapshots from.</p> <p>Constraints: Must be the valid name of an existing cluster that does not already have cross-region snapshot copy enabled.</p>
  ##   Version: string (required)
  ##   RetentionPeriod: int
  ##                  : <p>The number of days to retain automated snapshots in the destination region after they are copied from the source region.</p> <p>Default: 7.</p> <p>Constraints: Must be at least 1 and no more than 35.</p>
  ##   SnapshotCopyGrantName: string
  ##                        : The name of the snapshot copy grant to use when snapshots of an AWS KMS-encrypted cluster are copied to the destination region.
  var query_608590 = newJObject()
  add(query_608590, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  add(query_608590, "DestinationRegion", newJString(DestinationRegion))
  add(query_608590, "Action", newJString(Action))
  add(query_608590, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_608590, "Version", newJString(Version))
  add(query_608590, "RetentionPeriod", newJInt(RetentionPeriod))
  add(query_608590, "SnapshotCopyGrantName", newJString(SnapshotCopyGrantName))
  result = call_608589.call(nil, query_608590, nil, nil, nil)

var getEnableSnapshotCopy* = Call_GetEnableSnapshotCopy_608571(
    name: "getEnableSnapshotCopy", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=EnableSnapshotCopy",
    validator: validate_GetEnableSnapshotCopy_608572, base: "/",
    url: url_GetEnableSnapshotCopy_608573, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostGetClusterCredentials_608633 = ref object of OpenApiRestCall_605573
proc url_PostGetClusterCredentials_608635(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostGetClusterCredentials_608634(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns a database user name and temporary password with temporary authorization to log on to an Amazon Redshift database. The action returns the database user name prefixed with <code>IAM:</code> if <code>AutoCreate</code> is <code>False</code> or <code>IAMA:</code> if <code>AutoCreate</code> is <code>True</code>. You can optionally specify one or more database user groups that the user will join at log on. By default, the temporary credentials expire in 900 seconds. You can optionally specify a duration between 900 seconds (15 minutes) and 3600 seconds (60 minutes). For more information, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/generating-user-credentials.html">Using IAM Authentication to Generate Database User Credentials</a> in the Amazon Redshift Cluster Management Guide.</p> <p>The AWS Identity and Access Management (IAM)user or role that executes GetClusterCredentials must have an IAM policy attached that allows access to all necessary actions and resources. For more information about permissions, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-identity-based.html#redshift-policy-resources.getclustercredentials-resources">Resource Policies for GetClusterCredentials</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If the <code>DbGroups</code> parameter is specified, the IAM policy must allow the <code>redshift:JoinGroup</code> action with access to the listed <code>dbgroups</code>. </p> <p>In addition, if the <code>AutoCreate</code> parameter is set to <code>True</code>, then the policy must include the <code>redshift:CreateClusterUser</code> privilege.</p> <p>If the <code>DbName</code> parameter is specified, the IAM policy must allow access to the resource <code>dbname</code> for the specified database name. </p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_608636 = query.getOrDefault("Action")
  valid_608636 = validateParameter(valid_608636, JString, required = true,
                                 default = newJString("GetClusterCredentials"))
  if valid_608636 != nil:
    section.add "Action", valid_608636
  var valid_608637 = query.getOrDefault("Version")
  valid_608637 = validateParameter(valid_608637, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_608637 != nil:
    section.add "Version", valid_608637
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_608638 = header.getOrDefault("X-Amz-Signature")
  valid_608638 = validateParameter(valid_608638, JString, required = false,
                                 default = nil)
  if valid_608638 != nil:
    section.add "X-Amz-Signature", valid_608638
  var valid_608639 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_608639 = validateParameter(valid_608639, JString, required = false,
                                 default = nil)
  if valid_608639 != nil:
    section.add "X-Amz-Content-Sha256", valid_608639
  var valid_608640 = header.getOrDefault("X-Amz-Date")
  valid_608640 = validateParameter(valid_608640, JString, required = false,
                                 default = nil)
  if valid_608640 != nil:
    section.add "X-Amz-Date", valid_608640
  var valid_608641 = header.getOrDefault("X-Amz-Credential")
  valid_608641 = validateParameter(valid_608641, JString, required = false,
                                 default = nil)
  if valid_608641 != nil:
    section.add "X-Amz-Credential", valid_608641
  var valid_608642 = header.getOrDefault("X-Amz-Security-Token")
  valid_608642 = validateParameter(valid_608642, JString, required = false,
                                 default = nil)
  if valid_608642 != nil:
    section.add "X-Amz-Security-Token", valid_608642
  var valid_608643 = header.getOrDefault("X-Amz-Algorithm")
  valid_608643 = validateParameter(valid_608643, JString, required = false,
                                 default = nil)
  if valid_608643 != nil:
    section.add "X-Amz-Algorithm", valid_608643
  var valid_608644 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_608644 = validateParameter(valid_608644, JString, required = false,
                                 default = nil)
  if valid_608644 != nil:
    section.add "X-Amz-SignedHeaders", valid_608644
  result.add "header", section
  ## parameters in `formData` object:
  ##   DbUser: JString (required)
  ##         : <p>The name of a database user. If a user name matching <code>DbUser</code> exists in the database, the temporary user credentials have the same permissions as the existing user. If <code>DbUser</code> doesn't exist in the database and <code>Autocreate</code> is <code>True</code>, a new user is created using the value for <code>DbUser</code> with PUBLIC permissions. If a database user matching the value for <code>DbUser</code> doesn't exist and <code>Autocreate</code> is <code>False</code>, then the command succeeds but the connection attempt will fail because the user doesn't exist in the database.</p> <p>For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/r_CREATE_USER.html">CREATE USER</a> in the Amazon Redshift Database Developer Guide. </p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 64 alphanumeric characters or hyphens. The user name can't be <code>PUBLIC</code>.</p> </li> <li> <p>Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Must not contain a colon ( : ) or slash ( / ). </p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p> </li> </ul>
  ##   ClusterIdentifier: JString (required)
  ##                    : The unique identifier of the cluster that contains the database for which your are requesting credentials. This parameter is case sensitive.
  ##   DurationSeconds: JInt
  ##                  : <p>The number of seconds until the returned temporary password expires.</p> <p>Constraint: minimum 900, maximum 3600.</p> <p>Default: 900</p>
  ##   DbGroups: JArray
  ##           : <p>A list of the names of existing database groups that the user named in <code>DbUser</code> will join for the current session, in addition to any group memberships for an existing user. If not specified, a new user is added only to PUBLIC.</p> <p>Database group name constraints</p> <ul> <li> <p>Must be 1 to 64 alphanumeric characters or hyphens</p> </li> <li> <p>Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Must not contain a colon ( : ) or slash ( / ). </p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p> </li> </ul>
  ##   DbName: JString
  ##         : <p>The name of a database that <code>DbUser</code> is authorized to log on to. If <code>DbName</code> is not specified, <code>DbUser</code> can log on to any existing database.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 64 alphanumeric characters or hyphens</p> </li> <li> <p>Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Must not contain a colon ( : ) or slash ( / ). </p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p> </li> </ul>
  ##   AutoCreate: JBool
  ##             : Create a database user with the name specified for the user named in <code>DbUser</code> if one does not exist.
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `DbUser` field"
  var valid_608645 = formData.getOrDefault("DbUser")
  valid_608645 = validateParameter(valid_608645, JString, required = true,
                                 default = nil)
  if valid_608645 != nil:
    section.add "DbUser", valid_608645
  var valid_608646 = formData.getOrDefault("ClusterIdentifier")
  valid_608646 = validateParameter(valid_608646, JString, required = true,
                                 default = nil)
  if valid_608646 != nil:
    section.add "ClusterIdentifier", valid_608646
  var valid_608647 = formData.getOrDefault("DurationSeconds")
  valid_608647 = validateParameter(valid_608647, JInt, required = false, default = nil)
  if valid_608647 != nil:
    section.add "DurationSeconds", valid_608647
  var valid_608648 = formData.getOrDefault("DbGroups")
  valid_608648 = validateParameter(valid_608648, JArray, required = false,
                                 default = nil)
  if valid_608648 != nil:
    section.add "DbGroups", valid_608648
  var valid_608649 = formData.getOrDefault("DbName")
  valid_608649 = validateParameter(valid_608649, JString, required = false,
                                 default = nil)
  if valid_608649 != nil:
    section.add "DbName", valid_608649
  var valid_608650 = formData.getOrDefault("AutoCreate")
  valid_608650 = validateParameter(valid_608650, JBool, required = false, default = nil)
  if valid_608650 != nil:
    section.add "AutoCreate", valid_608650
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_608651: Call_PostGetClusterCredentials_608633; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns a database user name and temporary password with temporary authorization to log on to an Amazon Redshift database. The action returns the database user name prefixed with <code>IAM:</code> if <code>AutoCreate</code> is <code>False</code> or <code>IAMA:</code> if <code>AutoCreate</code> is <code>True</code>. You can optionally specify one or more database user groups that the user will join at log on. By default, the temporary credentials expire in 900 seconds. You can optionally specify a duration between 900 seconds (15 minutes) and 3600 seconds (60 minutes). For more information, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/generating-user-credentials.html">Using IAM Authentication to Generate Database User Credentials</a> in the Amazon Redshift Cluster Management Guide.</p> <p>The AWS Identity and Access Management (IAM)user or role that executes GetClusterCredentials must have an IAM policy attached that allows access to all necessary actions and resources. For more information about permissions, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-identity-based.html#redshift-policy-resources.getclustercredentials-resources">Resource Policies for GetClusterCredentials</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If the <code>DbGroups</code> parameter is specified, the IAM policy must allow the <code>redshift:JoinGroup</code> action with access to the listed <code>dbgroups</code>. </p> <p>In addition, if the <code>AutoCreate</code> parameter is set to <code>True</code>, then the policy must include the <code>redshift:CreateClusterUser</code> privilege.</p> <p>If the <code>DbName</code> parameter is specified, the IAM policy must allow access to the resource <code>dbname</code> for the specified database name. </p>
  ## 
  let valid = call_608651.validator(path, query, header, formData, body)
  let scheme = call_608651.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_608651.url(scheme.get, call_608651.host, call_608651.base,
                         call_608651.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_608651, url, valid)

proc call*(call_608652: Call_PostGetClusterCredentials_608633; DbUser: string;
          ClusterIdentifier: string; DurationSeconds: int = 0;
          DbGroups: JsonNode = nil; Action: string = "GetClusterCredentials";
          DbName: string = ""; AutoCreate: bool = false; Version: string = "2012-12-01"): Recallable =
  ## postGetClusterCredentials
  ## <p>Returns a database user name and temporary password with temporary authorization to log on to an Amazon Redshift database. The action returns the database user name prefixed with <code>IAM:</code> if <code>AutoCreate</code> is <code>False</code> or <code>IAMA:</code> if <code>AutoCreate</code> is <code>True</code>. You can optionally specify one or more database user groups that the user will join at log on. By default, the temporary credentials expire in 900 seconds. You can optionally specify a duration between 900 seconds (15 minutes) and 3600 seconds (60 minutes). For more information, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/generating-user-credentials.html">Using IAM Authentication to Generate Database User Credentials</a> in the Amazon Redshift Cluster Management Guide.</p> <p>The AWS Identity and Access Management (IAM)user or role that executes GetClusterCredentials must have an IAM policy attached that allows access to all necessary actions and resources. For more information about permissions, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-identity-based.html#redshift-policy-resources.getclustercredentials-resources">Resource Policies for GetClusterCredentials</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If the <code>DbGroups</code> parameter is specified, the IAM policy must allow the <code>redshift:JoinGroup</code> action with access to the listed <code>dbgroups</code>. </p> <p>In addition, if the <code>AutoCreate</code> parameter is set to <code>True</code>, then the policy must include the <code>redshift:CreateClusterUser</code> privilege.</p> <p>If the <code>DbName</code> parameter is specified, the IAM policy must allow access to the resource <code>dbname</code> for the specified database name. </p>
  ##   DbUser: string (required)
  ##         : <p>The name of a database user. If a user name matching <code>DbUser</code> exists in the database, the temporary user credentials have the same permissions as the existing user. If <code>DbUser</code> doesn't exist in the database and <code>Autocreate</code> is <code>True</code>, a new user is created using the value for <code>DbUser</code> with PUBLIC permissions. If a database user matching the value for <code>DbUser</code> doesn't exist and <code>Autocreate</code> is <code>False</code>, then the command succeeds but the connection attempt will fail because the user doesn't exist in the database.</p> <p>For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/r_CREATE_USER.html">CREATE USER</a> in the Amazon Redshift Database Developer Guide. </p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 64 alphanumeric characters or hyphens. The user name can't be <code>PUBLIC</code>.</p> </li> <li> <p>Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Must not contain a colon ( : ) or slash ( / ). </p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p> </li> </ul>
  ##   ClusterIdentifier: string (required)
  ##                    : The unique identifier of the cluster that contains the database for which your are requesting credentials. This parameter is case sensitive.
  ##   DurationSeconds: int
  ##                  : <p>The number of seconds until the returned temporary password expires.</p> <p>Constraint: minimum 900, maximum 3600.</p> <p>Default: 900</p>
  ##   DbGroups: JArray
  ##           : <p>A list of the names of existing database groups that the user named in <code>DbUser</code> will join for the current session, in addition to any group memberships for an existing user. If not specified, a new user is added only to PUBLIC.</p> <p>Database group name constraints</p> <ul> <li> <p>Must be 1 to 64 alphanumeric characters or hyphens</p> </li> <li> <p>Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Must not contain a colon ( : ) or slash ( / ). </p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p> </li> </ul>
  ##   Action: string (required)
  ##   DbName: string
  ##         : <p>The name of a database that <code>DbUser</code> is authorized to log on to. If <code>DbName</code> is not specified, <code>DbUser</code> can log on to any existing database.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 64 alphanumeric characters or hyphens</p> </li> <li> <p>Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Must not contain a colon ( : ) or slash ( / ). </p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p> </li> </ul>
  ##   AutoCreate: bool
  ##             : Create a database user with the name specified for the user named in <code>DbUser</code> if one does not exist.
  ##   Version: string (required)
  var query_608653 = newJObject()
  var formData_608654 = newJObject()
  add(formData_608654, "DbUser", newJString(DbUser))
  add(formData_608654, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_608654, "DurationSeconds", newJInt(DurationSeconds))
  if DbGroups != nil:
    formData_608654.add "DbGroups", DbGroups
  add(query_608653, "Action", newJString(Action))
  add(formData_608654, "DbName", newJString(DbName))
  add(formData_608654, "AutoCreate", newJBool(AutoCreate))
  add(query_608653, "Version", newJString(Version))
  result = call_608652.call(nil, query_608653, nil, formData_608654, nil)

var postGetClusterCredentials* = Call_PostGetClusterCredentials_608633(
    name: "postGetClusterCredentials", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=GetClusterCredentials",
    validator: validate_PostGetClusterCredentials_608634, base: "/",
    url: url_PostGetClusterCredentials_608635,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetGetClusterCredentials_608612 = ref object of OpenApiRestCall_605573
proc url_GetGetClusterCredentials_608614(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetGetClusterCredentials_608613(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns a database user name and temporary password with temporary authorization to log on to an Amazon Redshift database. The action returns the database user name prefixed with <code>IAM:</code> if <code>AutoCreate</code> is <code>False</code> or <code>IAMA:</code> if <code>AutoCreate</code> is <code>True</code>. You can optionally specify one or more database user groups that the user will join at log on. By default, the temporary credentials expire in 900 seconds. You can optionally specify a duration between 900 seconds (15 minutes) and 3600 seconds (60 minutes). For more information, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/generating-user-credentials.html">Using IAM Authentication to Generate Database User Credentials</a> in the Amazon Redshift Cluster Management Guide.</p> <p>The AWS Identity and Access Management (IAM)user or role that executes GetClusterCredentials must have an IAM policy attached that allows access to all necessary actions and resources. For more information about permissions, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-identity-based.html#redshift-policy-resources.getclustercredentials-resources">Resource Policies for GetClusterCredentials</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If the <code>DbGroups</code> parameter is specified, the IAM policy must allow the <code>redshift:JoinGroup</code> action with access to the listed <code>dbgroups</code>. </p> <p>In addition, if the <code>AutoCreate</code> parameter is set to <code>True</code>, then the policy must include the <code>redshift:CreateClusterUser</code> privilege.</p> <p>If the <code>DbName</code> parameter is specified, the IAM policy must allow access to the resource <code>dbname</code> for the specified database name. </p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   DbName: JString
  ##         : <p>The name of a database that <code>DbUser</code> is authorized to log on to. If <code>DbName</code> is not specified, <code>DbUser</code> can log on to any existing database.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 64 alphanumeric characters or hyphens</p> </li> <li> <p>Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Must not contain a colon ( : ) or slash ( / ). </p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p> </li> </ul>
  ##   DbUser: JString (required)
  ##         : <p>The name of a database user. If a user name matching <code>DbUser</code> exists in the database, the temporary user credentials have the same permissions as the existing user. If <code>DbUser</code> doesn't exist in the database and <code>Autocreate</code> is <code>True</code>, a new user is created using the value for <code>DbUser</code> with PUBLIC permissions. If a database user matching the value for <code>DbUser</code> doesn't exist and <code>Autocreate</code> is <code>False</code>, then the command succeeds but the connection attempt will fail because the user doesn't exist in the database.</p> <p>For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/r_CREATE_USER.html">CREATE USER</a> in the Amazon Redshift Database Developer Guide. </p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 64 alphanumeric characters or hyphens. The user name can't be <code>PUBLIC</code>.</p> </li> <li> <p>Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Must not contain a colon ( : ) or slash ( / ). </p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p> </li> </ul>
  ##   AutoCreate: JBool
  ##             : Create a database user with the name specified for the user named in <code>DbUser</code> if one does not exist.
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : The unique identifier of the cluster that contains the database for which your are requesting credentials. This parameter is case sensitive.
  ##   Version: JString (required)
  ##   DbGroups: JArray
  ##           : <p>A list of the names of existing database groups that the user named in <code>DbUser</code> will join for the current session, in addition to any group memberships for an existing user. If not specified, a new user is added only to PUBLIC.</p> <p>Database group name constraints</p> <ul> <li> <p>Must be 1 to 64 alphanumeric characters or hyphens</p> </li> <li> <p>Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Must not contain a colon ( : ) or slash ( / ). </p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p> </li> </ul>
  ##   DurationSeconds: JInt
  ##                  : <p>The number of seconds until the returned temporary password expires.</p> <p>Constraint: minimum 900, maximum 3600.</p> <p>Default: 900</p>
  section = newJObject()
  var valid_608615 = query.getOrDefault("DbName")
  valid_608615 = validateParameter(valid_608615, JString, required = false,
                                 default = nil)
  if valid_608615 != nil:
    section.add "DbName", valid_608615
  assert query != nil, "query argument is necessary due to required `DbUser` field"
  var valid_608616 = query.getOrDefault("DbUser")
  valid_608616 = validateParameter(valid_608616, JString, required = true,
                                 default = nil)
  if valid_608616 != nil:
    section.add "DbUser", valid_608616
  var valid_608617 = query.getOrDefault("AutoCreate")
  valid_608617 = validateParameter(valid_608617, JBool, required = false, default = nil)
  if valid_608617 != nil:
    section.add "AutoCreate", valid_608617
  var valid_608618 = query.getOrDefault("Action")
  valid_608618 = validateParameter(valid_608618, JString, required = true,
                                 default = newJString("GetClusterCredentials"))
  if valid_608618 != nil:
    section.add "Action", valid_608618
  var valid_608619 = query.getOrDefault("ClusterIdentifier")
  valid_608619 = validateParameter(valid_608619, JString, required = true,
                                 default = nil)
  if valid_608619 != nil:
    section.add "ClusterIdentifier", valid_608619
  var valid_608620 = query.getOrDefault("Version")
  valid_608620 = validateParameter(valid_608620, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_608620 != nil:
    section.add "Version", valid_608620
  var valid_608621 = query.getOrDefault("DbGroups")
  valid_608621 = validateParameter(valid_608621, JArray, required = false,
                                 default = nil)
  if valid_608621 != nil:
    section.add "DbGroups", valid_608621
  var valid_608622 = query.getOrDefault("DurationSeconds")
  valid_608622 = validateParameter(valid_608622, JInt, required = false, default = nil)
  if valid_608622 != nil:
    section.add "DurationSeconds", valid_608622
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_608623 = header.getOrDefault("X-Amz-Signature")
  valid_608623 = validateParameter(valid_608623, JString, required = false,
                                 default = nil)
  if valid_608623 != nil:
    section.add "X-Amz-Signature", valid_608623
  var valid_608624 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_608624 = validateParameter(valid_608624, JString, required = false,
                                 default = nil)
  if valid_608624 != nil:
    section.add "X-Amz-Content-Sha256", valid_608624
  var valid_608625 = header.getOrDefault("X-Amz-Date")
  valid_608625 = validateParameter(valid_608625, JString, required = false,
                                 default = nil)
  if valid_608625 != nil:
    section.add "X-Amz-Date", valid_608625
  var valid_608626 = header.getOrDefault("X-Amz-Credential")
  valid_608626 = validateParameter(valid_608626, JString, required = false,
                                 default = nil)
  if valid_608626 != nil:
    section.add "X-Amz-Credential", valid_608626
  var valid_608627 = header.getOrDefault("X-Amz-Security-Token")
  valid_608627 = validateParameter(valid_608627, JString, required = false,
                                 default = nil)
  if valid_608627 != nil:
    section.add "X-Amz-Security-Token", valid_608627
  var valid_608628 = header.getOrDefault("X-Amz-Algorithm")
  valid_608628 = validateParameter(valid_608628, JString, required = false,
                                 default = nil)
  if valid_608628 != nil:
    section.add "X-Amz-Algorithm", valid_608628
  var valid_608629 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_608629 = validateParameter(valid_608629, JString, required = false,
                                 default = nil)
  if valid_608629 != nil:
    section.add "X-Amz-SignedHeaders", valid_608629
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_608630: Call_GetGetClusterCredentials_608612; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns a database user name and temporary password with temporary authorization to log on to an Amazon Redshift database. The action returns the database user name prefixed with <code>IAM:</code> if <code>AutoCreate</code> is <code>False</code> or <code>IAMA:</code> if <code>AutoCreate</code> is <code>True</code>. You can optionally specify one or more database user groups that the user will join at log on. By default, the temporary credentials expire in 900 seconds. You can optionally specify a duration between 900 seconds (15 minutes) and 3600 seconds (60 minutes). For more information, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/generating-user-credentials.html">Using IAM Authentication to Generate Database User Credentials</a> in the Amazon Redshift Cluster Management Guide.</p> <p>The AWS Identity and Access Management (IAM)user or role that executes GetClusterCredentials must have an IAM policy attached that allows access to all necessary actions and resources. For more information about permissions, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-identity-based.html#redshift-policy-resources.getclustercredentials-resources">Resource Policies for GetClusterCredentials</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If the <code>DbGroups</code> parameter is specified, the IAM policy must allow the <code>redshift:JoinGroup</code> action with access to the listed <code>dbgroups</code>. </p> <p>In addition, if the <code>AutoCreate</code> parameter is set to <code>True</code>, then the policy must include the <code>redshift:CreateClusterUser</code> privilege.</p> <p>If the <code>DbName</code> parameter is specified, the IAM policy must allow access to the resource <code>dbname</code> for the specified database name. </p>
  ## 
  let valid = call_608630.validator(path, query, header, formData, body)
  let scheme = call_608630.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_608630.url(scheme.get, call_608630.host, call_608630.base,
                         call_608630.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_608630, url, valid)

proc call*(call_608631: Call_GetGetClusterCredentials_608612; DbUser: string;
          ClusterIdentifier: string; DbName: string = ""; AutoCreate: bool = false;
          Action: string = "GetClusterCredentials"; Version: string = "2012-12-01";
          DbGroups: JsonNode = nil; DurationSeconds: int = 0): Recallable =
  ## getGetClusterCredentials
  ## <p>Returns a database user name and temporary password with temporary authorization to log on to an Amazon Redshift database. The action returns the database user name prefixed with <code>IAM:</code> if <code>AutoCreate</code> is <code>False</code> or <code>IAMA:</code> if <code>AutoCreate</code> is <code>True</code>. You can optionally specify one or more database user groups that the user will join at log on. By default, the temporary credentials expire in 900 seconds. You can optionally specify a duration between 900 seconds (15 minutes) and 3600 seconds (60 minutes). For more information, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/generating-user-credentials.html">Using IAM Authentication to Generate Database User Credentials</a> in the Amazon Redshift Cluster Management Guide.</p> <p>The AWS Identity and Access Management (IAM)user or role that executes GetClusterCredentials must have an IAM policy attached that allows access to all necessary actions and resources. For more information about permissions, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-identity-based.html#redshift-policy-resources.getclustercredentials-resources">Resource Policies for GetClusterCredentials</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If the <code>DbGroups</code> parameter is specified, the IAM policy must allow the <code>redshift:JoinGroup</code> action with access to the listed <code>dbgroups</code>. </p> <p>In addition, if the <code>AutoCreate</code> parameter is set to <code>True</code>, then the policy must include the <code>redshift:CreateClusterUser</code> privilege.</p> <p>If the <code>DbName</code> parameter is specified, the IAM policy must allow access to the resource <code>dbname</code> for the specified database name. </p>
  ##   DbName: string
  ##         : <p>The name of a database that <code>DbUser</code> is authorized to log on to. If <code>DbName</code> is not specified, <code>DbUser</code> can log on to any existing database.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 64 alphanumeric characters or hyphens</p> </li> <li> <p>Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Must not contain a colon ( : ) or slash ( / ). </p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p> </li> </ul>
  ##   DbUser: string (required)
  ##         : <p>The name of a database user. If a user name matching <code>DbUser</code> exists in the database, the temporary user credentials have the same permissions as the existing user. If <code>DbUser</code> doesn't exist in the database and <code>Autocreate</code> is <code>True</code>, a new user is created using the value for <code>DbUser</code> with PUBLIC permissions. If a database user matching the value for <code>DbUser</code> doesn't exist and <code>Autocreate</code> is <code>False</code>, then the command succeeds but the connection attempt will fail because the user doesn't exist in the database.</p> <p>For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/r_CREATE_USER.html">CREATE USER</a> in the Amazon Redshift Database Developer Guide. </p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 64 alphanumeric characters or hyphens. The user name can't be <code>PUBLIC</code>.</p> </li> <li> <p>Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Must not contain a colon ( : ) or slash ( / ). </p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p> </li> </ul>
  ##   AutoCreate: bool
  ##             : Create a database user with the name specified for the user named in <code>DbUser</code> if one does not exist.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : The unique identifier of the cluster that contains the database for which your are requesting credentials. This parameter is case sensitive.
  ##   Version: string (required)
  ##   DbGroups: JArray
  ##           : <p>A list of the names of existing database groups that the user named in <code>DbUser</code> will join for the current session, in addition to any group memberships for an existing user. If not specified, a new user is added only to PUBLIC.</p> <p>Database group name constraints</p> <ul> <li> <p>Must be 1 to 64 alphanumeric characters or hyphens</p> </li> <li> <p>Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Must not contain a colon ( : ) or slash ( / ). </p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p> </li> </ul>
  ##   DurationSeconds: int
  ##                  : <p>The number of seconds until the returned temporary password expires.</p> <p>Constraint: minimum 900, maximum 3600.</p> <p>Default: 900</p>
  var query_608632 = newJObject()
  add(query_608632, "DbName", newJString(DbName))
  add(query_608632, "DbUser", newJString(DbUser))
  add(query_608632, "AutoCreate", newJBool(AutoCreate))
  add(query_608632, "Action", newJString(Action))
  add(query_608632, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_608632, "Version", newJString(Version))
  if DbGroups != nil:
    query_608632.add "DbGroups", DbGroups
  add(query_608632, "DurationSeconds", newJInt(DurationSeconds))
  result = call_608631.call(nil, query_608632, nil, nil, nil)

var getGetClusterCredentials* = Call_GetGetClusterCredentials_608612(
    name: "getGetClusterCredentials", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=GetClusterCredentials",
    validator: validate_GetGetClusterCredentials_608613, base: "/",
    url: url_GetGetClusterCredentials_608614, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostGetReservedNodeExchangeOfferings_608673 = ref object of OpenApiRestCall_605573
proc url_PostGetReservedNodeExchangeOfferings_608675(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostGetReservedNodeExchangeOfferings_608674(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns an array of DC2 ReservedNodeOfferings that matches the payment type, term, and usage price of the given DC1 reserved node.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_608676 = query.getOrDefault("Action")
  valid_608676 = validateParameter(valid_608676, JString, required = true, default = newJString(
      "GetReservedNodeExchangeOfferings"))
  if valid_608676 != nil:
    section.add "Action", valid_608676
  var valid_608677 = query.getOrDefault("Version")
  valid_608677 = validateParameter(valid_608677, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_608677 != nil:
    section.add "Version", valid_608677
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_608678 = header.getOrDefault("X-Amz-Signature")
  valid_608678 = validateParameter(valid_608678, JString, required = false,
                                 default = nil)
  if valid_608678 != nil:
    section.add "X-Amz-Signature", valid_608678
  var valid_608679 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_608679 = validateParameter(valid_608679, JString, required = false,
                                 default = nil)
  if valid_608679 != nil:
    section.add "X-Amz-Content-Sha256", valid_608679
  var valid_608680 = header.getOrDefault("X-Amz-Date")
  valid_608680 = validateParameter(valid_608680, JString, required = false,
                                 default = nil)
  if valid_608680 != nil:
    section.add "X-Amz-Date", valid_608680
  var valid_608681 = header.getOrDefault("X-Amz-Credential")
  valid_608681 = validateParameter(valid_608681, JString, required = false,
                                 default = nil)
  if valid_608681 != nil:
    section.add "X-Amz-Credential", valid_608681
  var valid_608682 = header.getOrDefault("X-Amz-Security-Token")
  valid_608682 = validateParameter(valid_608682, JString, required = false,
                                 default = nil)
  if valid_608682 != nil:
    section.add "X-Amz-Security-Token", valid_608682
  var valid_608683 = header.getOrDefault("X-Amz-Algorithm")
  valid_608683 = validateParameter(valid_608683, JString, required = false,
                                 default = nil)
  if valid_608683 != nil:
    section.add "X-Amz-Algorithm", valid_608683
  var valid_608684 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_608684 = validateParameter(valid_608684, JString, required = false,
                                 default = nil)
  if valid_608684 != nil:
    section.add "X-Amz-SignedHeaders", valid_608684
  result.add "header", section
  ## parameters in `formData` object:
  ##   ReservedNodeId: JString (required)
  ##                 : A string representing the node identifier for the DC1 Reserved Node to be exchanged.
  ##   MaxRecords: JInt
  ##             : An integer setting the maximum number of ReservedNodeOfferings to retrieve.
  ##   Marker: JString
  ##         : A value that indicates the starting point for the next set of ReservedNodeOfferings.
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `ReservedNodeId` field"
  var valid_608685 = formData.getOrDefault("ReservedNodeId")
  valid_608685 = validateParameter(valid_608685, JString, required = true,
                                 default = nil)
  if valid_608685 != nil:
    section.add "ReservedNodeId", valid_608685
  var valid_608686 = formData.getOrDefault("MaxRecords")
  valid_608686 = validateParameter(valid_608686, JInt, required = false, default = nil)
  if valid_608686 != nil:
    section.add "MaxRecords", valid_608686
  var valid_608687 = formData.getOrDefault("Marker")
  valid_608687 = validateParameter(valid_608687, JString, required = false,
                                 default = nil)
  if valid_608687 != nil:
    section.add "Marker", valid_608687
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_608688: Call_PostGetReservedNodeExchangeOfferings_608673;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Returns an array of DC2 ReservedNodeOfferings that matches the payment type, term, and usage price of the given DC1 reserved node.
  ## 
  let valid = call_608688.validator(path, query, header, formData, body)
  let scheme = call_608688.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_608688.url(scheme.get, call_608688.host, call_608688.base,
                         call_608688.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_608688, url, valid)

proc call*(call_608689: Call_PostGetReservedNodeExchangeOfferings_608673;
          ReservedNodeId: string; MaxRecords: int = 0; Marker: string = "";
          Action: string = "GetReservedNodeExchangeOfferings";
          Version: string = "2012-12-01"): Recallable =
  ## postGetReservedNodeExchangeOfferings
  ## Returns an array of DC2 ReservedNodeOfferings that matches the payment type, term, and usage price of the given DC1 reserved node.
  ##   ReservedNodeId: string (required)
  ##                 : A string representing the node identifier for the DC1 Reserved Node to be exchanged.
  ##   MaxRecords: int
  ##             : An integer setting the maximum number of ReservedNodeOfferings to retrieve.
  ##   Marker: string
  ##         : A value that indicates the starting point for the next set of ReservedNodeOfferings.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_608690 = newJObject()
  var formData_608691 = newJObject()
  add(formData_608691, "ReservedNodeId", newJString(ReservedNodeId))
  add(formData_608691, "MaxRecords", newJInt(MaxRecords))
  add(formData_608691, "Marker", newJString(Marker))
  add(query_608690, "Action", newJString(Action))
  add(query_608690, "Version", newJString(Version))
  result = call_608689.call(nil, query_608690, nil, formData_608691, nil)

var postGetReservedNodeExchangeOfferings* = Call_PostGetReservedNodeExchangeOfferings_608673(
    name: "postGetReservedNodeExchangeOfferings", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=GetReservedNodeExchangeOfferings",
    validator: validate_PostGetReservedNodeExchangeOfferings_608674, base: "/",
    url: url_PostGetReservedNodeExchangeOfferings_608675,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetGetReservedNodeExchangeOfferings_608655 = ref object of OpenApiRestCall_605573
proc url_GetGetReservedNodeExchangeOfferings_608657(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetGetReservedNodeExchangeOfferings_608656(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns an array of DC2 ReservedNodeOfferings that matches the payment type, term, and usage price of the given DC1 reserved node.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Marker: JString
  ##         : A value that indicates the starting point for the next set of ReservedNodeOfferings.
  ##   Action: JString (required)
  ##   ReservedNodeId: JString (required)
  ##                 : A string representing the node identifier for the DC1 Reserved Node to be exchanged.
  ##   Version: JString (required)
  ##   MaxRecords: JInt
  ##             : An integer setting the maximum number of ReservedNodeOfferings to retrieve.
  section = newJObject()
  var valid_608658 = query.getOrDefault("Marker")
  valid_608658 = validateParameter(valid_608658, JString, required = false,
                                 default = nil)
  if valid_608658 != nil:
    section.add "Marker", valid_608658
  var valid_608659 = query.getOrDefault("Action")
  valid_608659 = validateParameter(valid_608659, JString, required = true, default = newJString(
      "GetReservedNodeExchangeOfferings"))
  if valid_608659 != nil:
    section.add "Action", valid_608659
  var valid_608660 = query.getOrDefault("ReservedNodeId")
  valid_608660 = validateParameter(valid_608660, JString, required = true,
                                 default = nil)
  if valid_608660 != nil:
    section.add "ReservedNodeId", valid_608660
  var valid_608661 = query.getOrDefault("Version")
  valid_608661 = validateParameter(valid_608661, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_608661 != nil:
    section.add "Version", valid_608661
  var valid_608662 = query.getOrDefault("MaxRecords")
  valid_608662 = validateParameter(valid_608662, JInt, required = false, default = nil)
  if valid_608662 != nil:
    section.add "MaxRecords", valid_608662
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_608663 = header.getOrDefault("X-Amz-Signature")
  valid_608663 = validateParameter(valid_608663, JString, required = false,
                                 default = nil)
  if valid_608663 != nil:
    section.add "X-Amz-Signature", valid_608663
  var valid_608664 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_608664 = validateParameter(valid_608664, JString, required = false,
                                 default = nil)
  if valid_608664 != nil:
    section.add "X-Amz-Content-Sha256", valid_608664
  var valid_608665 = header.getOrDefault("X-Amz-Date")
  valid_608665 = validateParameter(valid_608665, JString, required = false,
                                 default = nil)
  if valid_608665 != nil:
    section.add "X-Amz-Date", valid_608665
  var valid_608666 = header.getOrDefault("X-Amz-Credential")
  valid_608666 = validateParameter(valid_608666, JString, required = false,
                                 default = nil)
  if valid_608666 != nil:
    section.add "X-Amz-Credential", valid_608666
  var valid_608667 = header.getOrDefault("X-Amz-Security-Token")
  valid_608667 = validateParameter(valid_608667, JString, required = false,
                                 default = nil)
  if valid_608667 != nil:
    section.add "X-Amz-Security-Token", valid_608667
  var valid_608668 = header.getOrDefault("X-Amz-Algorithm")
  valid_608668 = validateParameter(valid_608668, JString, required = false,
                                 default = nil)
  if valid_608668 != nil:
    section.add "X-Amz-Algorithm", valid_608668
  var valid_608669 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_608669 = validateParameter(valid_608669, JString, required = false,
                                 default = nil)
  if valid_608669 != nil:
    section.add "X-Amz-SignedHeaders", valid_608669
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_608670: Call_GetGetReservedNodeExchangeOfferings_608655;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Returns an array of DC2 ReservedNodeOfferings that matches the payment type, term, and usage price of the given DC1 reserved node.
  ## 
  let valid = call_608670.validator(path, query, header, formData, body)
  let scheme = call_608670.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_608670.url(scheme.get, call_608670.host, call_608670.base,
                         call_608670.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_608670, url, valid)

proc call*(call_608671: Call_GetGetReservedNodeExchangeOfferings_608655;
          ReservedNodeId: string; Marker: string = "";
          Action: string = "GetReservedNodeExchangeOfferings";
          Version: string = "2012-12-01"; MaxRecords: int = 0): Recallable =
  ## getGetReservedNodeExchangeOfferings
  ## Returns an array of DC2 ReservedNodeOfferings that matches the payment type, term, and usage price of the given DC1 reserved node.
  ##   Marker: string
  ##         : A value that indicates the starting point for the next set of ReservedNodeOfferings.
  ##   Action: string (required)
  ##   ReservedNodeId: string (required)
  ##                 : A string representing the node identifier for the DC1 Reserved Node to be exchanged.
  ##   Version: string (required)
  ##   MaxRecords: int
  ##             : An integer setting the maximum number of ReservedNodeOfferings to retrieve.
  var query_608672 = newJObject()
  add(query_608672, "Marker", newJString(Marker))
  add(query_608672, "Action", newJString(Action))
  add(query_608672, "ReservedNodeId", newJString(ReservedNodeId))
  add(query_608672, "Version", newJString(Version))
  add(query_608672, "MaxRecords", newJInt(MaxRecords))
  result = call_608671.call(nil, query_608672, nil, nil, nil)

var getGetReservedNodeExchangeOfferings* = Call_GetGetReservedNodeExchangeOfferings_608655(
    name: "getGetReservedNodeExchangeOfferings", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=GetReservedNodeExchangeOfferings",
    validator: validate_GetGetReservedNodeExchangeOfferings_608656, base: "/",
    url: url_GetGetReservedNodeExchangeOfferings_608657,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostModifyCluster_608729 = ref object of OpenApiRestCall_605573
proc url_PostModifyCluster_608731(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostModifyCluster_608730(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## <p>Modifies the settings for a cluster.</p> <p>You can also change node type and the number of nodes to scale up or down the cluster. When resizing a cluster, you must specify both the number of nodes and the node type even if one of the parameters does not change.</p> <p>You can add another security or parameter group, or change the master user password. Resetting a cluster password or modifying the security groups associated with a cluster do not need a reboot. However, modifying a parameter group requires a reboot for parameters to take effect. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_608732 = query.getOrDefault("Action")
  valid_608732 = validateParameter(valid_608732, JString, required = true,
                                 default = newJString("ModifyCluster"))
  if valid_608732 != nil:
    section.add "Action", valid_608732
  var valid_608733 = query.getOrDefault("Version")
  valid_608733 = validateParameter(valid_608733, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_608733 != nil:
    section.add "Version", valid_608733
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_608734 = header.getOrDefault("X-Amz-Signature")
  valid_608734 = validateParameter(valid_608734, JString, required = false,
                                 default = nil)
  if valid_608734 != nil:
    section.add "X-Amz-Signature", valid_608734
  var valid_608735 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_608735 = validateParameter(valid_608735, JString, required = false,
                                 default = nil)
  if valid_608735 != nil:
    section.add "X-Amz-Content-Sha256", valid_608735
  var valid_608736 = header.getOrDefault("X-Amz-Date")
  valid_608736 = validateParameter(valid_608736, JString, required = false,
                                 default = nil)
  if valid_608736 != nil:
    section.add "X-Amz-Date", valid_608736
  var valid_608737 = header.getOrDefault("X-Amz-Credential")
  valid_608737 = validateParameter(valid_608737, JString, required = false,
                                 default = nil)
  if valid_608737 != nil:
    section.add "X-Amz-Credential", valid_608737
  var valid_608738 = header.getOrDefault("X-Amz-Security-Token")
  valid_608738 = validateParameter(valid_608738, JString, required = false,
                                 default = nil)
  if valid_608738 != nil:
    section.add "X-Amz-Security-Token", valid_608738
  var valid_608739 = header.getOrDefault("X-Amz-Algorithm")
  valid_608739 = validateParameter(valid_608739, JString, required = false,
                                 default = nil)
  if valid_608739 != nil:
    section.add "X-Amz-Algorithm", valid_608739
  var valid_608740 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_608740 = validateParameter(valid_608740, JString, required = false,
                                 default = nil)
  if valid_608740 != nil:
    section.add "X-Amz-SignedHeaders", valid_608740
  result.add "header", section
  ## parameters in `formData` object:
  ##   PreferredMaintenanceWindow: JString
  ##                             : <p>The weekly time range (in UTC) during which system maintenance can occur, if necessary. If system maintenance is necessary during the window, it may result in an outage.</p> <p>This maintenance window change is made immediately. If the new maintenance window indicates the current time, there must be at least 120 minutes between the current time and end of the window in order to ensure that pending changes are applied.</p> <p>Default: Uses existing setting.</p> <p>Format: ddd:hh24:mi-ddd:hh24:mi, for example <code>wed:07:30-wed:08:00</code>.</p> <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p> <p>Constraints: Must be at least 30 minutes.</p>
  ##   NodeType: JString
  ##           : <p>The new node type of the cluster. If you specify a new node type, you must also specify the number of nodes parameter.</p> <p> For more information about resizing clusters, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/rs-resize-tutorial.html">Resizing Clusters in Amazon Redshift</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>Valid Values: <code>ds2.xlarge</code> | <code>ds2.8xlarge</code> | <code>dc1.large</code> | <code>dc1.8xlarge</code> | <code>dc2.large</code> | <code>dc2.8xlarge</code> | <code>ra3.16xlarge</code> </p>
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of the cluster to be modified.</p> <p>Example: <code>examplecluster</code> </p>
  ##   MasterUserPassword: JString
  ##                     : <p>The new password for the cluster master user. This change is asynchronously applied as soon as possible. Between the time of the request and the completion of the request, the <code>MasterUserPassword</code> element exists in the <code>PendingModifiedValues</code> element of the operation response. </p> <note> <p>Operations never return the password, so this operation provides a way to regain access to the master user account for a cluster if the password is lost.</p> </note> <p>Default: Uses existing setting.</p> <p>Constraints:</p> <ul> <li> <p>Must be between 8 and 64 characters in length.</p> </li> <li> <p>Must contain at least one uppercase letter.</p> </li> <li> <p>Must contain at least one lowercase letter.</p> </li> <li> <p>Must contain one number.</p> </li> <li> <p>Can be any printable ASCII character (ASCII code 33 to 126) except ' (single quote), " (double quote), \, /, @, or space.</p> </li> </ul>
  ##   MaintenanceTrackName: JString
  ##                       : The name for the maintenance track that you want to assign for the cluster. This name change is asynchronous. The new track name stays in the <code>PendingModifiedValues</code> for the cluster until the next maintenance window. When the maintenance track changes, the cluster is switched to the latest cluster release available for the maintenance track. At this point, the maintenance track name is applied.
  ##   ClusterSecurityGroups: JArray
  ##                        : <p>A list of cluster security groups to be authorized on this cluster. This change is asynchronously applied as soon as possible.</p> <p>Security groups currently associated with the cluster, and not in the list of groups to apply, will be revoked from the cluster.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens</p> </li> <li> <p>First character must be a letter</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens</p> </li> </ul>
  ##   NumberOfNodes: JInt
  ##                : <p>The new number of nodes of the cluster. If you specify a new number of nodes, you must also specify the node type parameter.</p> <p> For more information about resizing clusters, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/rs-resize-tutorial.html">Resizing Clusters in Amazon Redshift</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>Valid Values: Integer greater than <code>0</code>.</p>
  ##   VpcSecurityGroupIds: JArray
  ##                      : A list of virtual private cloud (VPC) security groups to be associated with the cluster. This change is asynchronously applied as soon as possible.
  ##   AutomatedSnapshotRetentionPeriod: JInt
  ##                                   : <p>The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p> <p>If you decrease the automated snapshot retention period from its current value, existing automated snapshots that fall outside of the new retention period will be immediately deleted.</p> <p>Default: Uses existing setting.</p> <p>Constraints: Must be a value from 0 to 35.</p>
  ##   NewClusterIdentifier: JString
  ##                       : <p>The new identifier for the cluster.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul> <p>Example: <code>examplecluster</code> </p>
  ##   EnhancedVpcRouting: JBool
  ##                     : <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p> <p>Default: false</p>
  ##   KmsKeyId: JString
  ##           : The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster.
  ##   AllowVersionUpgrade: JBool
  ##                      : <p>If <code>true</code>, major version upgrades will be applied automatically to the cluster during the maintenance window. </p> <p>Default: <code>false</code> </p>
  ##   PubliclyAccessible: JBool
  ##                     : If <code>true</code>, the cluster can be accessed from a public network. Only clusters in VPCs can be set to be publicly available.
  ##   ClusterParameterGroupName: JString
  ##                            : <p>The name of the cluster parameter group to apply to this cluster. This change is applied only after the cluster is rebooted. To reboot a cluster use <a>RebootCluster</a>. </p> <p>Default: Uses existing setting.</p> <p>Constraints: The cluster parameter group must be in the same parameter group family that matches the cluster version.</p>
  ##   ClusterVersion: JString
  ##                 : <p>The new version number of the Amazon Redshift engine to upgrade to.</p> <p>For major version upgrades, if a non-default cluster parameter group is currently in use, a new cluster parameter group in the cluster parameter group family for the new version must be specified. The new cluster parameter group can be the default for that cluster parameter group family. For more information about parameters and parameter groups, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>Example: <code>1.0</code> </p>
  ##   ClusterType: JString
  ##              : <p>The new cluster type.</p> <p>When you submit your cluster resize request, your existing cluster goes into a read-only mode. After Amazon Redshift provisions a new cluster based on your resize requirements, there will be outage for a period while the old cluster is deleted and your connection is switched to the new cluster. You can use <a>DescribeResize</a> to track the progress of the resize request. </p> <p>Valid Values: <code> multi-node | single-node </code> </p>
  ##   HsmClientCertificateIdentifier: JString
  ##                                 : Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM.
  ##   Encrypted: JBool
  ##            : <p>Indicates whether the cluster is encrypted. If the value is encrypted (true) and you provide a value for the <code>KmsKeyId</code> parameter, we encrypt the cluster with the provided <code>KmsKeyId</code>. If you don't provide a <code>KmsKeyId</code>, we encrypt with the default key. In the China region we use legacy encryption if you specify that the cluster is encrypted.</p> <p>If the value is not encrypted (false), then the cluster is decrypted. </p>
  ##   ElasticIp: JString
  ##            : <p>The Elastic IP (EIP) address for the cluster.</p> <p>Constraints: The cluster must be provisioned in EC2-VPC and publicly-accessible through an Internet gateway. For more information about provisioning clusters in EC2-VPC, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#cluster-platforms">Supported Platforms to Launch Your Cluster</a> in the Amazon Redshift Cluster Management Guide.</p>
  ##   HsmConfigurationIdentifier: JString
  ##                             : Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The default for number of days that a newly created manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. This value doesn't retroactively change the retention periods of existing manual snapshots.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  section = newJObject()
  var valid_608741 = formData.getOrDefault("PreferredMaintenanceWindow")
  valid_608741 = validateParameter(valid_608741, JString, required = false,
                                 default = nil)
  if valid_608741 != nil:
    section.add "PreferredMaintenanceWindow", valid_608741
  var valid_608742 = formData.getOrDefault("NodeType")
  valid_608742 = validateParameter(valid_608742, JString, required = false,
                                 default = nil)
  if valid_608742 != nil:
    section.add "NodeType", valid_608742
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_608743 = formData.getOrDefault("ClusterIdentifier")
  valid_608743 = validateParameter(valid_608743, JString, required = true,
                                 default = nil)
  if valid_608743 != nil:
    section.add "ClusterIdentifier", valid_608743
  var valid_608744 = formData.getOrDefault("MasterUserPassword")
  valid_608744 = validateParameter(valid_608744, JString, required = false,
                                 default = nil)
  if valid_608744 != nil:
    section.add "MasterUserPassword", valid_608744
  var valid_608745 = formData.getOrDefault("MaintenanceTrackName")
  valid_608745 = validateParameter(valid_608745, JString, required = false,
                                 default = nil)
  if valid_608745 != nil:
    section.add "MaintenanceTrackName", valid_608745
  var valid_608746 = formData.getOrDefault("ClusterSecurityGroups")
  valid_608746 = validateParameter(valid_608746, JArray, required = false,
                                 default = nil)
  if valid_608746 != nil:
    section.add "ClusterSecurityGroups", valid_608746
  var valid_608747 = formData.getOrDefault("NumberOfNodes")
  valid_608747 = validateParameter(valid_608747, JInt, required = false, default = nil)
  if valid_608747 != nil:
    section.add "NumberOfNodes", valid_608747
  var valid_608748 = formData.getOrDefault("VpcSecurityGroupIds")
  valid_608748 = validateParameter(valid_608748, JArray, required = false,
                                 default = nil)
  if valid_608748 != nil:
    section.add "VpcSecurityGroupIds", valid_608748
  var valid_608749 = formData.getOrDefault("AutomatedSnapshotRetentionPeriod")
  valid_608749 = validateParameter(valid_608749, JInt, required = false, default = nil)
  if valid_608749 != nil:
    section.add "AutomatedSnapshotRetentionPeriod", valid_608749
  var valid_608750 = formData.getOrDefault("NewClusterIdentifier")
  valid_608750 = validateParameter(valid_608750, JString, required = false,
                                 default = nil)
  if valid_608750 != nil:
    section.add "NewClusterIdentifier", valid_608750
  var valid_608751 = formData.getOrDefault("EnhancedVpcRouting")
  valid_608751 = validateParameter(valid_608751, JBool, required = false, default = nil)
  if valid_608751 != nil:
    section.add "EnhancedVpcRouting", valid_608751
  var valid_608752 = formData.getOrDefault("KmsKeyId")
  valid_608752 = validateParameter(valid_608752, JString, required = false,
                                 default = nil)
  if valid_608752 != nil:
    section.add "KmsKeyId", valid_608752
  var valid_608753 = formData.getOrDefault("AllowVersionUpgrade")
  valid_608753 = validateParameter(valid_608753, JBool, required = false, default = nil)
  if valid_608753 != nil:
    section.add "AllowVersionUpgrade", valid_608753
  var valid_608754 = formData.getOrDefault("PubliclyAccessible")
  valid_608754 = validateParameter(valid_608754, JBool, required = false, default = nil)
  if valid_608754 != nil:
    section.add "PubliclyAccessible", valid_608754
  var valid_608755 = formData.getOrDefault("ClusterParameterGroupName")
  valid_608755 = validateParameter(valid_608755, JString, required = false,
                                 default = nil)
  if valid_608755 != nil:
    section.add "ClusterParameterGroupName", valid_608755
  var valid_608756 = formData.getOrDefault("ClusterVersion")
  valid_608756 = validateParameter(valid_608756, JString, required = false,
                                 default = nil)
  if valid_608756 != nil:
    section.add "ClusterVersion", valid_608756
  var valid_608757 = formData.getOrDefault("ClusterType")
  valid_608757 = validateParameter(valid_608757, JString, required = false,
                                 default = nil)
  if valid_608757 != nil:
    section.add "ClusterType", valid_608757
  var valid_608758 = formData.getOrDefault("HsmClientCertificateIdentifier")
  valid_608758 = validateParameter(valid_608758, JString, required = false,
                                 default = nil)
  if valid_608758 != nil:
    section.add "HsmClientCertificateIdentifier", valid_608758
  var valid_608759 = formData.getOrDefault("Encrypted")
  valid_608759 = validateParameter(valid_608759, JBool, required = false, default = nil)
  if valid_608759 != nil:
    section.add "Encrypted", valid_608759
  var valid_608760 = formData.getOrDefault("ElasticIp")
  valid_608760 = validateParameter(valid_608760, JString, required = false,
                                 default = nil)
  if valid_608760 != nil:
    section.add "ElasticIp", valid_608760
  var valid_608761 = formData.getOrDefault("HsmConfigurationIdentifier")
  valid_608761 = validateParameter(valid_608761, JString, required = false,
                                 default = nil)
  if valid_608761 != nil:
    section.add "HsmConfigurationIdentifier", valid_608761
  var valid_608762 = formData.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_608762 = validateParameter(valid_608762, JInt, required = false, default = nil)
  if valid_608762 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_608762
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_608763: Call_PostModifyCluster_608729; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Modifies the settings for a cluster.</p> <p>You can also change node type and the number of nodes to scale up or down the cluster. When resizing a cluster, you must specify both the number of nodes and the node type even if one of the parameters does not change.</p> <p>You can add another security or parameter group, or change the master user password. Resetting a cluster password or modifying the security groups associated with a cluster do not need a reboot. However, modifying a parameter group requires a reboot for parameters to take effect. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_608763.validator(path, query, header, formData, body)
  let scheme = call_608763.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_608763.url(scheme.get, call_608763.host, call_608763.base,
                         call_608763.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_608763, url, valid)

proc call*(call_608764: Call_PostModifyCluster_608729; ClusterIdentifier: string;
          PreferredMaintenanceWindow: string = ""; NodeType: string = "";
          MasterUserPassword: string = ""; MaintenanceTrackName: string = "";
          ClusterSecurityGroups: JsonNode = nil; NumberOfNodes: int = 0;
          VpcSecurityGroupIds: JsonNode = nil;
          AutomatedSnapshotRetentionPeriod: int = 0;
          NewClusterIdentifier: string = ""; EnhancedVpcRouting: bool = false;
          KmsKeyId: string = ""; AllowVersionUpgrade: bool = false;
          PubliclyAccessible: bool = false; Action: string = "ModifyCluster";
          ClusterParameterGroupName: string = ""; ClusterVersion: string = "";
          ClusterType: string = ""; HsmClientCertificateIdentifier: string = "";
          Encrypted: bool = false; Version: string = "2012-12-01";
          ElasticIp: string = ""; HsmConfigurationIdentifier: string = "";
          ManualSnapshotRetentionPeriod: int = 0): Recallable =
  ## postModifyCluster
  ## <p>Modifies the settings for a cluster.</p> <p>You can also change node type and the number of nodes to scale up or down the cluster. When resizing a cluster, you must specify both the number of nodes and the node type even if one of the parameters does not change.</p> <p>You can add another security or parameter group, or change the master user password. Resetting a cluster password or modifying the security groups associated with a cluster do not need a reboot. However, modifying a parameter group requires a reboot for parameters to take effect. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   PreferredMaintenanceWindow: string
  ##                             : <p>The weekly time range (in UTC) during which system maintenance can occur, if necessary. If system maintenance is necessary during the window, it may result in an outage.</p> <p>This maintenance window change is made immediately. If the new maintenance window indicates the current time, there must be at least 120 minutes between the current time and end of the window in order to ensure that pending changes are applied.</p> <p>Default: Uses existing setting.</p> <p>Format: ddd:hh24:mi-ddd:hh24:mi, for example <code>wed:07:30-wed:08:00</code>.</p> <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p> <p>Constraints: Must be at least 30 minutes.</p>
  ##   NodeType: string
  ##           : <p>The new node type of the cluster. If you specify a new node type, you must also specify the number of nodes parameter.</p> <p> For more information about resizing clusters, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/rs-resize-tutorial.html">Resizing Clusters in Amazon Redshift</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>Valid Values: <code>ds2.xlarge</code> | <code>ds2.8xlarge</code> | <code>dc1.large</code> | <code>dc1.8xlarge</code> | <code>dc2.large</code> | <code>dc2.8xlarge</code> | <code>ra3.16xlarge</code> </p>
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of the cluster to be modified.</p> <p>Example: <code>examplecluster</code> </p>
  ##   MasterUserPassword: string
  ##                     : <p>The new password for the cluster master user. This change is asynchronously applied as soon as possible. Between the time of the request and the completion of the request, the <code>MasterUserPassword</code> element exists in the <code>PendingModifiedValues</code> element of the operation response. </p> <note> <p>Operations never return the password, so this operation provides a way to regain access to the master user account for a cluster if the password is lost.</p> </note> <p>Default: Uses existing setting.</p> <p>Constraints:</p> <ul> <li> <p>Must be between 8 and 64 characters in length.</p> </li> <li> <p>Must contain at least one uppercase letter.</p> </li> <li> <p>Must contain at least one lowercase letter.</p> </li> <li> <p>Must contain one number.</p> </li> <li> <p>Can be any printable ASCII character (ASCII code 33 to 126) except ' (single quote), " (double quote), \, /, @, or space.</p> </li> </ul>
  ##   MaintenanceTrackName: string
  ##                       : The name for the maintenance track that you want to assign for the cluster. This name change is asynchronous. The new track name stays in the <code>PendingModifiedValues</code> for the cluster until the next maintenance window. When the maintenance track changes, the cluster is switched to the latest cluster release available for the maintenance track. At this point, the maintenance track name is applied.
  ##   ClusterSecurityGroups: JArray
  ##                        : <p>A list of cluster security groups to be authorized on this cluster. This change is asynchronously applied as soon as possible.</p> <p>Security groups currently associated with the cluster, and not in the list of groups to apply, will be revoked from the cluster.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens</p> </li> <li> <p>First character must be a letter</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens</p> </li> </ul>
  ##   NumberOfNodes: int
  ##                : <p>The new number of nodes of the cluster. If you specify a new number of nodes, you must also specify the node type parameter.</p> <p> For more information about resizing clusters, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/rs-resize-tutorial.html">Resizing Clusters in Amazon Redshift</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>Valid Values: Integer greater than <code>0</code>.</p>
  ##   VpcSecurityGroupIds: JArray
  ##                      : A list of virtual private cloud (VPC) security groups to be associated with the cluster. This change is asynchronously applied as soon as possible.
  ##   AutomatedSnapshotRetentionPeriod: int
  ##                                   : <p>The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p> <p>If you decrease the automated snapshot retention period from its current value, existing automated snapshots that fall outside of the new retention period will be immediately deleted.</p> <p>Default: Uses existing setting.</p> <p>Constraints: Must be a value from 0 to 35.</p>
  ##   NewClusterIdentifier: string
  ##                       : <p>The new identifier for the cluster.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul> <p>Example: <code>examplecluster</code> </p>
  ##   EnhancedVpcRouting: bool
  ##                     : <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p> <p>Default: false</p>
  ##   KmsKeyId: string
  ##           : The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster.
  ##   AllowVersionUpgrade: bool
  ##                      : <p>If <code>true</code>, major version upgrades will be applied automatically to the cluster during the maintenance window. </p> <p>Default: <code>false</code> </p>
  ##   PubliclyAccessible: bool
  ##                     : If <code>true</code>, the cluster can be accessed from a public network. Only clusters in VPCs can be set to be publicly available.
  ##   Action: string (required)
  ##   ClusterParameterGroupName: string
  ##                            : <p>The name of the cluster parameter group to apply to this cluster. This change is applied only after the cluster is rebooted. To reboot a cluster use <a>RebootCluster</a>. </p> <p>Default: Uses existing setting.</p> <p>Constraints: The cluster parameter group must be in the same parameter group family that matches the cluster version.</p>
  ##   ClusterVersion: string
  ##                 : <p>The new version number of the Amazon Redshift engine to upgrade to.</p> <p>For major version upgrades, if a non-default cluster parameter group is currently in use, a new cluster parameter group in the cluster parameter group family for the new version must be specified. The new cluster parameter group can be the default for that cluster parameter group family. For more information about parameters and parameter groups, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>Example: <code>1.0</code> </p>
  ##   ClusterType: string
  ##              : <p>The new cluster type.</p> <p>When you submit your cluster resize request, your existing cluster goes into a read-only mode. After Amazon Redshift provisions a new cluster based on your resize requirements, there will be outage for a period while the old cluster is deleted and your connection is switched to the new cluster. You can use <a>DescribeResize</a> to track the progress of the resize request. </p> <p>Valid Values: <code> multi-node | single-node </code> </p>
  ##   HsmClientCertificateIdentifier: string
  ##                                 : Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM.
  ##   Encrypted: bool
  ##            : <p>Indicates whether the cluster is encrypted. If the value is encrypted (true) and you provide a value for the <code>KmsKeyId</code> parameter, we encrypt the cluster with the provided <code>KmsKeyId</code>. If you don't provide a <code>KmsKeyId</code>, we encrypt with the default key. In the China region we use legacy encryption if you specify that the cluster is encrypted.</p> <p>If the value is not encrypted (false), then the cluster is decrypted. </p>
  ##   Version: string (required)
  ##   ElasticIp: string
  ##            : <p>The Elastic IP (EIP) address for the cluster.</p> <p>Constraints: The cluster must be provisioned in EC2-VPC and publicly-accessible through an Internet gateway. For more information about provisioning clusters in EC2-VPC, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#cluster-platforms">Supported Platforms to Launch Your Cluster</a> in the Amazon Redshift Cluster Management Guide.</p>
  ##   HsmConfigurationIdentifier: string
  ##                             : Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The default for number of days that a newly created manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. This value doesn't retroactively change the retention periods of existing manual snapshots.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  var query_608765 = newJObject()
  var formData_608766 = newJObject()
  add(formData_608766, "PreferredMaintenanceWindow",
      newJString(PreferredMaintenanceWindow))
  add(formData_608766, "NodeType", newJString(NodeType))
  add(formData_608766, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_608766, "MasterUserPassword", newJString(MasterUserPassword))
  add(formData_608766, "MaintenanceTrackName", newJString(MaintenanceTrackName))
  if ClusterSecurityGroups != nil:
    formData_608766.add "ClusterSecurityGroups", ClusterSecurityGroups
  add(formData_608766, "NumberOfNodes", newJInt(NumberOfNodes))
  if VpcSecurityGroupIds != nil:
    formData_608766.add "VpcSecurityGroupIds", VpcSecurityGroupIds
  add(formData_608766, "AutomatedSnapshotRetentionPeriod",
      newJInt(AutomatedSnapshotRetentionPeriod))
  add(formData_608766, "NewClusterIdentifier", newJString(NewClusterIdentifier))
  add(formData_608766, "EnhancedVpcRouting", newJBool(EnhancedVpcRouting))
  add(formData_608766, "KmsKeyId", newJString(KmsKeyId))
  add(formData_608766, "AllowVersionUpgrade", newJBool(AllowVersionUpgrade))
  add(formData_608766, "PubliclyAccessible", newJBool(PubliclyAccessible))
  add(query_608765, "Action", newJString(Action))
  add(formData_608766, "ClusterParameterGroupName",
      newJString(ClusterParameterGroupName))
  add(formData_608766, "ClusterVersion", newJString(ClusterVersion))
  add(formData_608766, "ClusterType", newJString(ClusterType))
  add(formData_608766, "HsmClientCertificateIdentifier",
      newJString(HsmClientCertificateIdentifier))
  add(formData_608766, "Encrypted", newJBool(Encrypted))
  add(query_608765, "Version", newJString(Version))
  add(formData_608766, "ElasticIp", newJString(ElasticIp))
  add(formData_608766, "HsmConfigurationIdentifier",
      newJString(HsmConfigurationIdentifier))
  add(formData_608766, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  result = call_608764.call(nil, query_608765, nil, formData_608766, nil)

var postModifyCluster* = Call_PostModifyCluster_608729(name: "postModifyCluster",
    meth: HttpMethod.HttpPost, host: "redshift.amazonaws.com",
    route: "/#Action=ModifyCluster", validator: validate_PostModifyCluster_608730,
    base: "/", url: url_PostModifyCluster_608731,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetModifyCluster_608692 = ref object of OpenApiRestCall_605573
proc url_GetModifyCluster_608694(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetModifyCluster_608693(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## <p>Modifies the settings for a cluster.</p> <p>You can also change node type and the number of nodes to scale up or down the cluster. When resizing a cluster, you must specify both the number of nodes and the node type even if one of the parameters does not change.</p> <p>You can add another security or parameter group, or change the master user password. Resetting a cluster password or modifying the security groups associated with a cluster do not need a reboot. However, modifying a parameter group requires a reboot for parameters to take effect. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   MaintenanceTrackName: JString
  ##                       : The name for the maintenance track that you want to assign for the cluster. This name change is asynchronous. The new track name stays in the <code>PendingModifiedValues</code> for the cluster until the next maintenance window. When the maintenance track changes, the cluster is switched to the latest cluster release available for the maintenance track. At this point, the maintenance track name is applied.
  ##   Encrypted: JBool
  ##            : <p>Indicates whether the cluster is encrypted. If the value is encrypted (true) and you provide a value for the <code>KmsKeyId</code> parameter, we encrypt the cluster with the provided <code>KmsKeyId</code>. If you don't provide a <code>KmsKeyId</code>, we encrypt with the default key. In the China region we use legacy encryption if you specify that the cluster is encrypted.</p> <p>If the value is not encrypted (false), then the cluster is decrypted. </p>
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The default for number of days that a newly created manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. This value doesn't retroactively change the retention periods of existing manual snapshots.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  ##   HsmClientCertificateIdentifier: JString
  ##                                 : Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM.
  ##   ClusterSecurityGroups: JArray
  ##                        : <p>A list of cluster security groups to be authorized on this cluster. This change is asynchronously applied as soon as possible.</p> <p>Security groups currently associated with the cluster, and not in the list of groups to apply, will be revoked from the cluster.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens</p> </li> <li> <p>First character must be a letter</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens</p> </li> </ul>
  ##   KmsKeyId: JString
  ##           : The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster.
  ##   ClusterParameterGroupName: JString
  ##                            : <p>The name of the cluster parameter group to apply to this cluster. This change is applied only after the cluster is rebooted. To reboot a cluster use <a>RebootCluster</a>. </p> <p>Default: Uses existing setting.</p> <p>Constraints: The cluster parameter group must be in the same parameter group family that matches the cluster version.</p>
  ##   NodeType: JString
  ##           : <p>The new node type of the cluster. If you specify a new node type, you must also specify the number of nodes parameter.</p> <p> For more information about resizing clusters, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/rs-resize-tutorial.html">Resizing Clusters in Amazon Redshift</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>Valid Values: <code>ds2.xlarge</code> | <code>ds2.8xlarge</code> | <code>dc1.large</code> | <code>dc1.8xlarge</code> | <code>dc2.large</code> | <code>dc2.8xlarge</code> | <code>ra3.16xlarge</code> </p>
  ##   ClusterVersion: JString
  ##                 : <p>The new version number of the Amazon Redshift engine to upgrade to.</p> <p>For major version upgrades, if a non-default cluster parameter group is currently in use, a new cluster parameter group in the cluster parameter group family for the new version must be specified. The new cluster parameter group can be the default for that cluster parameter group family. For more information about parameters and parameter groups, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>Example: <code>1.0</code> </p>
  ##   ClusterType: JString
  ##              : <p>The new cluster type.</p> <p>When you submit your cluster resize request, your existing cluster goes into a read-only mode. After Amazon Redshift provisions a new cluster based on your resize requirements, there will be outage for a period while the old cluster is deleted and your connection is switched to the new cluster. You can use <a>DescribeResize</a> to track the progress of the resize request. </p> <p>Valid Values: <code> multi-node | single-node </code> </p>
  ##   NumberOfNodes: JInt
  ##                : <p>The new number of nodes of the cluster. If you specify a new number of nodes, you must also specify the node type parameter.</p> <p> For more information about resizing clusters, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/rs-resize-tutorial.html">Resizing Clusters in Amazon Redshift</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>Valid Values: Integer greater than <code>0</code>.</p>
  ##   AllowVersionUpgrade: JBool
  ##                      : <p>If <code>true</code>, major version upgrades will be applied automatically to the cluster during the maintenance window. </p> <p>Default: <code>false</code> </p>
  ##   ElasticIp: JString
  ##            : <p>The Elastic IP (EIP) address for the cluster.</p> <p>Constraints: The cluster must be provisioned in EC2-VPC and publicly-accessible through an Internet gateway. For more information about provisioning clusters in EC2-VPC, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#cluster-platforms">Supported Platforms to Launch Your Cluster</a> in the Amazon Redshift Cluster Management Guide.</p>
  ##   AutomatedSnapshotRetentionPeriod: JInt
  ##                                   : <p>The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p> <p>If you decrease the automated snapshot retention period from its current value, existing automated snapshots that fall outside of the new retention period will be immediately deleted.</p> <p>Default: Uses existing setting.</p> <p>Constraints: Must be a value from 0 to 35.</p>
  ##   EnhancedVpcRouting: JBool
  ##                     : <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p> <p>Default: false</p>
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of the cluster to be modified.</p> <p>Example: <code>examplecluster</code> </p>
  ##   VpcSecurityGroupIds: JArray
  ##                      : A list of virtual private cloud (VPC) security groups to be associated with the cluster. This change is asynchronously applied as soon as possible.
  ##   NewClusterIdentifier: JString
  ##                       : <p>The new identifier for the cluster.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul> <p>Example: <code>examplecluster</code> </p>
  ##   MasterUserPassword: JString
  ##                     : <p>The new password for the cluster master user. This change is asynchronously applied as soon as possible. Between the time of the request and the completion of the request, the <code>MasterUserPassword</code> element exists in the <code>PendingModifiedValues</code> element of the operation response. </p> <note> <p>Operations never return the password, so this operation provides a way to regain access to the master user account for a cluster if the password is lost.</p> </note> <p>Default: Uses existing setting.</p> <p>Constraints:</p> <ul> <li> <p>Must be between 8 and 64 characters in length.</p> </li> <li> <p>Must contain at least one uppercase letter.</p> </li> <li> <p>Must contain at least one lowercase letter.</p> </li> <li> <p>Must contain one number.</p> </li> <li> <p>Can be any printable ASCII character (ASCII code 33 to 126) except ' (single quote), " (double quote), \, /, @, or space.</p> </li> </ul>
  ##   HsmConfigurationIdentifier: JString
  ##                             : Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
  ##   Version: JString (required)
  ##   PreferredMaintenanceWindow: JString
  ##                             : <p>The weekly time range (in UTC) during which system maintenance can occur, if necessary. If system maintenance is necessary during the window, it may result in an outage.</p> <p>This maintenance window change is made immediately. If the new maintenance window indicates the current time, there must be at least 120 minutes between the current time and end of the window in order to ensure that pending changes are applied.</p> <p>Default: Uses existing setting.</p> <p>Format: ddd:hh24:mi-ddd:hh24:mi, for example <code>wed:07:30-wed:08:00</code>.</p> <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p> <p>Constraints: Must be at least 30 minutes.</p>
  ##   PubliclyAccessible: JBool
  ##                     : If <code>true</code>, the cluster can be accessed from a public network. Only clusters in VPCs can be set to be publicly available.
  section = newJObject()
  var valid_608695 = query.getOrDefault("MaintenanceTrackName")
  valid_608695 = validateParameter(valid_608695, JString, required = false,
                                 default = nil)
  if valid_608695 != nil:
    section.add "MaintenanceTrackName", valid_608695
  var valid_608696 = query.getOrDefault("Encrypted")
  valid_608696 = validateParameter(valid_608696, JBool, required = false, default = nil)
  if valid_608696 != nil:
    section.add "Encrypted", valid_608696
  var valid_608697 = query.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_608697 = validateParameter(valid_608697, JInt, required = false, default = nil)
  if valid_608697 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_608697
  var valid_608698 = query.getOrDefault("HsmClientCertificateIdentifier")
  valid_608698 = validateParameter(valid_608698, JString, required = false,
                                 default = nil)
  if valid_608698 != nil:
    section.add "HsmClientCertificateIdentifier", valid_608698
  var valid_608699 = query.getOrDefault("ClusterSecurityGroups")
  valid_608699 = validateParameter(valid_608699, JArray, required = false,
                                 default = nil)
  if valid_608699 != nil:
    section.add "ClusterSecurityGroups", valid_608699
  var valid_608700 = query.getOrDefault("KmsKeyId")
  valid_608700 = validateParameter(valid_608700, JString, required = false,
                                 default = nil)
  if valid_608700 != nil:
    section.add "KmsKeyId", valid_608700
  var valid_608701 = query.getOrDefault("ClusterParameterGroupName")
  valid_608701 = validateParameter(valid_608701, JString, required = false,
                                 default = nil)
  if valid_608701 != nil:
    section.add "ClusterParameterGroupName", valid_608701
  var valid_608702 = query.getOrDefault("NodeType")
  valid_608702 = validateParameter(valid_608702, JString, required = false,
                                 default = nil)
  if valid_608702 != nil:
    section.add "NodeType", valid_608702
  var valid_608703 = query.getOrDefault("ClusterVersion")
  valid_608703 = validateParameter(valid_608703, JString, required = false,
                                 default = nil)
  if valid_608703 != nil:
    section.add "ClusterVersion", valid_608703
  var valid_608704 = query.getOrDefault("ClusterType")
  valid_608704 = validateParameter(valid_608704, JString, required = false,
                                 default = nil)
  if valid_608704 != nil:
    section.add "ClusterType", valid_608704
  var valid_608705 = query.getOrDefault("NumberOfNodes")
  valid_608705 = validateParameter(valid_608705, JInt, required = false, default = nil)
  if valid_608705 != nil:
    section.add "NumberOfNodes", valid_608705
  var valid_608706 = query.getOrDefault("AllowVersionUpgrade")
  valid_608706 = validateParameter(valid_608706, JBool, required = false, default = nil)
  if valid_608706 != nil:
    section.add "AllowVersionUpgrade", valid_608706
  var valid_608707 = query.getOrDefault("ElasticIp")
  valid_608707 = validateParameter(valid_608707, JString, required = false,
                                 default = nil)
  if valid_608707 != nil:
    section.add "ElasticIp", valid_608707
  var valid_608708 = query.getOrDefault("AutomatedSnapshotRetentionPeriod")
  valid_608708 = validateParameter(valid_608708, JInt, required = false, default = nil)
  if valid_608708 != nil:
    section.add "AutomatedSnapshotRetentionPeriod", valid_608708
  var valid_608709 = query.getOrDefault("EnhancedVpcRouting")
  valid_608709 = validateParameter(valid_608709, JBool, required = false, default = nil)
  if valid_608709 != nil:
    section.add "EnhancedVpcRouting", valid_608709
  var valid_608710 = query.getOrDefault("Action")
  valid_608710 = validateParameter(valid_608710, JString, required = true,
                                 default = newJString("ModifyCluster"))
  if valid_608710 != nil:
    section.add "Action", valid_608710
  var valid_608711 = query.getOrDefault("ClusterIdentifier")
  valid_608711 = validateParameter(valid_608711, JString, required = true,
                                 default = nil)
  if valid_608711 != nil:
    section.add "ClusterIdentifier", valid_608711
  var valid_608712 = query.getOrDefault("VpcSecurityGroupIds")
  valid_608712 = validateParameter(valid_608712, JArray, required = false,
                                 default = nil)
  if valid_608712 != nil:
    section.add "VpcSecurityGroupIds", valid_608712
  var valid_608713 = query.getOrDefault("NewClusterIdentifier")
  valid_608713 = validateParameter(valid_608713, JString, required = false,
                                 default = nil)
  if valid_608713 != nil:
    section.add "NewClusterIdentifier", valid_608713
  var valid_608714 = query.getOrDefault("MasterUserPassword")
  valid_608714 = validateParameter(valid_608714, JString, required = false,
                                 default = nil)
  if valid_608714 != nil:
    section.add "MasterUserPassword", valid_608714
  var valid_608715 = query.getOrDefault("HsmConfigurationIdentifier")
  valid_608715 = validateParameter(valid_608715, JString, required = false,
                                 default = nil)
  if valid_608715 != nil:
    section.add "HsmConfigurationIdentifier", valid_608715
  var valid_608716 = query.getOrDefault("Version")
  valid_608716 = validateParameter(valid_608716, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_608716 != nil:
    section.add "Version", valid_608716
  var valid_608717 = query.getOrDefault("PreferredMaintenanceWindow")
  valid_608717 = validateParameter(valid_608717, JString, required = false,
                                 default = nil)
  if valid_608717 != nil:
    section.add "PreferredMaintenanceWindow", valid_608717
  var valid_608718 = query.getOrDefault("PubliclyAccessible")
  valid_608718 = validateParameter(valid_608718, JBool, required = false, default = nil)
  if valid_608718 != nil:
    section.add "PubliclyAccessible", valid_608718
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_608719 = header.getOrDefault("X-Amz-Signature")
  valid_608719 = validateParameter(valid_608719, JString, required = false,
                                 default = nil)
  if valid_608719 != nil:
    section.add "X-Amz-Signature", valid_608719
  var valid_608720 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_608720 = validateParameter(valid_608720, JString, required = false,
                                 default = nil)
  if valid_608720 != nil:
    section.add "X-Amz-Content-Sha256", valid_608720
  var valid_608721 = header.getOrDefault("X-Amz-Date")
  valid_608721 = validateParameter(valid_608721, JString, required = false,
                                 default = nil)
  if valid_608721 != nil:
    section.add "X-Amz-Date", valid_608721
  var valid_608722 = header.getOrDefault("X-Amz-Credential")
  valid_608722 = validateParameter(valid_608722, JString, required = false,
                                 default = nil)
  if valid_608722 != nil:
    section.add "X-Amz-Credential", valid_608722
  var valid_608723 = header.getOrDefault("X-Amz-Security-Token")
  valid_608723 = validateParameter(valid_608723, JString, required = false,
                                 default = nil)
  if valid_608723 != nil:
    section.add "X-Amz-Security-Token", valid_608723
  var valid_608724 = header.getOrDefault("X-Amz-Algorithm")
  valid_608724 = validateParameter(valid_608724, JString, required = false,
                                 default = nil)
  if valid_608724 != nil:
    section.add "X-Amz-Algorithm", valid_608724
  var valid_608725 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_608725 = validateParameter(valid_608725, JString, required = false,
                                 default = nil)
  if valid_608725 != nil:
    section.add "X-Amz-SignedHeaders", valid_608725
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_608726: Call_GetModifyCluster_608692; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Modifies the settings for a cluster.</p> <p>You can also change node type and the number of nodes to scale up or down the cluster. When resizing a cluster, you must specify both the number of nodes and the node type even if one of the parameters does not change.</p> <p>You can add another security or parameter group, or change the master user password. Resetting a cluster password or modifying the security groups associated with a cluster do not need a reboot. However, modifying a parameter group requires a reboot for parameters to take effect. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_608726.validator(path, query, header, formData, body)
  let scheme = call_608726.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_608726.url(scheme.get, call_608726.host, call_608726.base,
                         call_608726.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_608726, url, valid)

proc call*(call_608727: Call_GetModifyCluster_608692; ClusterIdentifier: string;
          MaintenanceTrackName: string = ""; Encrypted: bool = false;
          ManualSnapshotRetentionPeriod: int = 0;
          HsmClientCertificateIdentifier: string = "";
          ClusterSecurityGroups: JsonNode = nil; KmsKeyId: string = "";
          ClusterParameterGroupName: string = ""; NodeType: string = "";
          ClusterVersion: string = ""; ClusterType: string = ""; NumberOfNodes: int = 0;
          AllowVersionUpgrade: bool = false; ElasticIp: string = "";
          AutomatedSnapshotRetentionPeriod: int = 0;
          EnhancedVpcRouting: bool = false; Action: string = "ModifyCluster";
          VpcSecurityGroupIds: JsonNode = nil; NewClusterIdentifier: string = "";
          MasterUserPassword: string = ""; HsmConfigurationIdentifier: string = "";
          Version: string = "2012-12-01"; PreferredMaintenanceWindow: string = "";
          PubliclyAccessible: bool = false): Recallable =
  ## getModifyCluster
  ## <p>Modifies the settings for a cluster.</p> <p>You can also change node type and the number of nodes to scale up or down the cluster. When resizing a cluster, you must specify both the number of nodes and the node type even if one of the parameters does not change.</p> <p>You can add another security or parameter group, or change the master user password. Resetting a cluster password or modifying the security groups associated with a cluster do not need a reboot. However, modifying a parameter group requires a reboot for parameters to take effect. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   MaintenanceTrackName: string
  ##                       : The name for the maintenance track that you want to assign for the cluster. This name change is asynchronous. The new track name stays in the <code>PendingModifiedValues</code> for the cluster until the next maintenance window. When the maintenance track changes, the cluster is switched to the latest cluster release available for the maintenance track. At this point, the maintenance track name is applied.
  ##   Encrypted: bool
  ##            : <p>Indicates whether the cluster is encrypted. If the value is encrypted (true) and you provide a value for the <code>KmsKeyId</code> parameter, we encrypt the cluster with the provided <code>KmsKeyId</code>. If you don't provide a <code>KmsKeyId</code>, we encrypt with the default key. In the China region we use legacy encryption if you specify that the cluster is encrypted.</p> <p>If the value is not encrypted (false), then the cluster is decrypted. </p>
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The default for number of days that a newly created manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. This value doesn't retroactively change the retention periods of existing manual snapshots.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  ##   HsmClientCertificateIdentifier: string
  ##                                 : Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM.
  ##   ClusterSecurityGroups: JArray
  ##                        : <p>A list of cluster security groups to be authorized on this cluster. This change is asynchronously applied as soon as possible.</p> <p>Security groups currently associated with the cluster, and not in the list of groups to apply, will be revoked from the cluster.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens</p> </li> <li> <p>First character must be a letter</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens</p> </li> </ul>
  ##   KmsKeyId: string
  ##           : The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster.
  ##   ClusterParameterGroupName: string
  ##                            : <p>The name of the cluster parameter group to apply to this cluster. This change is applied only after the cluster is rebooted. To reboot a cluster use <a>RebootCluster</a>. </p> <p>Default: Uses existing setting.</p> <p>Constraints: The cluster parameter group must be in the same parameter group family that matches the cluster version.</p>
  ##   NodeType: string
  ##           : <p>The new node type of the cluster. If you specify a new node type, you must also specify the number of nodes parameter.</p> <p> For more information about resizing clusters, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/rs-resize-tutorial.html">Resizing Clusters in Amazon Redshift</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>Valid Values: <code>ds2.xlarge</code> | <code>ds2.8xlarge</code> | <code>dc1.large</code> | <code>dc1.8xlarge</code> | <code>dc2.large</code> | <code>dc2.8xlarge</code> | <code>ra3.16xlarge</code> </p>
  ##   ClusterVersion: string
  ##                 : <p>The new version number of the Amazon Redshift engine to upgrade to.</p> <p>For major version upgrades, if a non-default cluster parameter group is currently in use, a new cluster parameter group in the cluster parameter group family for the new version must be specified. The new cluster parameter group can be the default for that cluster parameter group family. For more information about parameters and parameter groups, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>Example: <code>1.0</code> </p>
  ##   ClusterType: string
  ##              : <p>The new cluster type.</p> <p>When you submit your cluster resize request, your existing cluster goes into a read-only mode. After Amazon Redshift provisions a new cluster based on your resize requirements, there will be outage for a period while the old cluster is deleted and your connection is switched to the new cluster. You can use <a>DescribeResize</a> to track the progress of the resize request. </p> <p>Valid Values: <code> multi-node | single-node </code> </p>
  ##   NumberOfNodes: int
  ##                : <p>The new number of nodes of the cluster. If you specify a new number of nodes, you must also specify the node type parameter.</p> <p> For more information about resizing clusters, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/rs-resize-tutorial.html">Resizing Clusters in Amazon Redshift</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>Valid Values: Integer greater than <code>0</code>.</p>
  ##   AllowVersionUpgrade: bool
  ##                      : <p>If <code>true</code>, major version upgrades will be applied automatically to the cluster during the maintenance window. </p> <p>Default: <code>false</code> </p>
  ##   ElasticIp: string
  ##            : <p>The Elastic IP (EIP) address for the cluster.</p> <p>Constraints: The cluster must be provisioned in EC2-VPC and publicly-accessible through an Internet gateway. For more information about provisioning clusters in EC2-VPC, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#cluster-platforms">Supported Platforms to Launch Your Cluster</a> in the Amazon Redshift Cluster Management Guide.</p>
  ##   AutomatedSnapshotRetentionPeriod: int
  ##                                   : <p>The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p> <p>If you decrease the automated snapshot retention period from its current value, existing automated snapshots that fall outside of the new retention period will be immediately deleted.</p> <p>Default: Uses existing setting.</p> <p>Constraints: Must be a value from 0 to 35.</p>
  ##   EnhancedVpcRouting: bool
  ##                     : <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p> <p>Default: false</p>
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of the cluster to be modified.</p> <p>Example: <code>examplecluster</code> </p>
  ##   VpcSecurityGroupIds: JArray
  ##                      : A list of virtual private cloud (VPC) security groups to be associated with the cluster. This change is asynchronously applied as soon as possible.
  ##   NewClusterIdentifier: string
  ##                       : <p>The new identifier for the cluster.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul> <p>Example: <code>examplecluster</code> </p>
  ##   MasterUserPassword: string
  ##                     : <p>The new password for the cluster master user. This change is asynchronously applied as soon as possible. Between the time of the request and the completion of the request, the <code>MasterUserPassword</code> element exists in the <code>PendingModifiedValues</code> element of the operation response. </p> <note> <p>Operations never return the password, so this operation provides a way to regain access to the master user account for a cluster if the password is lost.</p> </note> <p>Default: Uses existing setting.</p> <p>Constraints:</p> <ul> <li> <p>Must be between 8 and 64 characters in length.</p> </li> <li> <p>Must contain at least one uppercase letter.</p> </li> <li> <p>Must contain at least one lowercase letter.</p> </li> <li> <p>Must contain one number.</p> </li> <li> <p>Can be any printable ASCII character (ASCII code 33 to 126) except ' (single quote), " (double quote), \, /, @, or space.</p> </li> </ul>
  ##   HsmConfigurationIdentifier: string
  ##                             : Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
  ##   Version: string (required)
  ##   PreferredMaintenanceWindow: string
  ##                             : <p>The weekly time range (in UTC) during which system maintenance can occur, if necessary. If system maintenance is necessary during the window, it may result in an outage.</p> <p>This maintenance window change is made immediately. If the new maintenance window indicates the current time, there must be at least 120 minutes between the current time and end of the window in order to ensure that pending changes are applied.</p> <p>Default: Uses existing setting.</p> <p>Format: ddd:hh24:mi-ddd:hh24:mi, for example <code>wed:07:30-wed:08:00</code>.</p> <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p> <p>Constraints: Must be at least 30 minutes.</p>
  ##   PubliclyAccessible: bool
  ##                     : If <code>true</code>, the cluster can be accessed from a public network. Only clusters in VPCs can be set to be publicly available.
  var query_608728 = newJObject()
  add(query_608728, "MaintenanceTrackName", newJString(MaintenanceTrackName))
  add(query_608728, "Encrypted", newJBool(Encrypted))
  add(query_608728, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  add(query_608728, "HsmClientCertificateIdentifier",
      newJString(HsmClientCertificateIdentifier))
  if ClusterSecurityGroups != nil:
    query_608728.add "ClusterSecurityGroups", ClusterSecurityGroups
  add(query_608728, "KmsKeyId", newJString(KmsKeyId))
  add(query_608728, "ClusterParameterGroupName",
      newJString(ClusterParameterGroupName))
  add(query_608728, "NodeType", newJString(NodeType))
  add(query_608728, "ClusterVersion", newJString(ClusterVersion))
  add(query_608728, "ClusterType", newJString(ClusterType))
  add(query_608728, "NumberOfNodes", newJInt(NumberOfNodes))
  add(query_608728, "AllowVersionUpgrade", newJBool(AllowVersionUpgrade))
  add(query_608728, "ElasticIp", newJString(ElasticIp))
  add(query_608728, "AutomatedSnapshotRetentionPeriod",
      newJInt(AutomatedSnapshotRetentionPeriod))
  add(query_608728, "EnhancedVpcRouting", newJBool(EnhancedVpcRouting))
  add(query_608728, "Action", newJString(Action))
  add(query_608728, "ClusterIdentifier", newJString(ClusterIdentifier))
  if VpcSecurityGroupIds != nil:
    query_608728.add "VpcSecurityGroupIds", VpcSecurityGroupIds
  add(query_608728, "NewClusterIdentifier", newJString(NewClusterIdentifier))
  add(query_608728, "MasterUserPassword", newJString(MasterUserPassword))
  add(query_608728, "HsmConfigurationIdentifier",
      newJString(HsmConfigurationIdentifier))
  add(query_608728, "Version", newJString(Version))
  add(query_608728, "PreferredMaintenanceWindow",
      newJString(PreferredMaintenanceWindow))
  add(query_608728, "PubliclyAccessible", newJBool(PubliclyAccessible))
  result = call_608727.call(nil, query_608728, nil, nil, nil)

var getModifyCluster* = Call_GetModifyCluster_608692(name: "getModifyCluster",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=ModifyCluster", validator: validate_GetModifyCluster_608693,
    base: "/", url: url_GetModifyCluster_608694,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostModifyClusterDbRevision_608784 = ref object of OpenApiRestCall_605573
proc url_PostModifyClusterDbRevision_608786(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostModifyClusterDbRevision_608785(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies the database revision of a cluster. The database revision is a unique revision of the database running in a cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_608787 = query.getOrDefault("Action")
  valid_608787 = validateParameter(valid_608787, JString, required = true, default = newJString(
      "ModifyClusterDbRevision"))
  if valid_608787 != nil:
    section.add "Action", valid_608787
  var valid_608788 = query.getOrDefault("Version")
  valid_608788 = validateParameter(valid_608788, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_608788 != nil:
    section.add "Version", valid_608788
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_608789 = header.getOrDefault("X-Amz-Signature")
  valid_608789 = validateParameter(valid_608789, JString, required = false,
                                 default = nil)
  if valid_608789 != nil:
    section.add "X-Amz-Signature", valid_608789
  var valid_608790 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_608790 = validateParameter(valid_608790, JString, required = false,
                                 default = nil)
  if valid_608790 != nil:
    section.add "X-Amz-Content-Sha256", valid_608790
  var valid_608791 = header.getOrDefault("X-Amz-Date")
  valid_608791 = validateParameter(valid_608791, JString, required = false,
                                 default = nil)
  if valid_608791 != nil:
    section.add "X-Amz-Date", valid_608791
  var valid_608792 = header.getOrDefault("X-Amz-Credential")
  valid_608792 = validateParameter(valid_608792, JString, required = false,
                                 default = nil)
  if valid_608792 != nil:
    section.add "X-Amz-Credential", valid_608792
  var valid_608793 = header.getOrDefault("X-Amz-Security-Token")
  valid_608793 = validateParameter(valid_608793, JString, required = false,
                                 default = nil)
  if valid_608793 != nil:
    section.add "X-Amz-Security-Token", valid_608793
  var valid_608794 = header.getOrDefault("X-Amz-Algorithm")
  valid_608794 = validateParameter(valid_608794, JString, required = false,
                                 default = nil)
  if valid_608794 != nil:
    section.add "X-Amz-Algorithm", valid_608794
  var valid_608795 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_608795 = validateParameter(valid_608795, JString, required = false,
                                 default = nil)
  if valid_608795 != nil:
    section.add "X-Amz-SignedHeaders", valid_608795
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of a cluster whose database revision you want to modify. </p> <p>Example: <code>examplecluster</code> </p>
  ##   RevisionTarget: JString (required)
  ##                 : The identifier of the database revision. You can retrieve this value from the response to the <a>DescribeClusterDbRevisions</a> request.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_608796 = formData.getOrDefault("ClusterIdentifier")
  valid_608796 = validateParameter(valid_608796, JString, required = true,
                                 default = nil)
  if valid_608796 != nil:
    section.add "ClusterIdentifier", valid_608796
  var valid_608797 = formData.getOrDefault("RevisionTarget")
  valid_608797 = validateParameter(valid_608797, JString, required = true,
                                 default = nil)
  if valid_608797 != nil:
    section.add "RevisionTarget", valid_608797
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_608798: Call_PostModifyClusterDbRevision_608784; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Modifies the database revision of a cluster. The database revision is a unique revision of the database running in a cluster.
  ## 
  let valid = call_608798.validator(path, query, header, formData, body)
  let scheme = call_608798.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_608798.url(scheme.get, call_608798.host, call_608798.base,
                         call_608798.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_608798, url, valid)

proc call*(call_608799: Call_PostModifyClusterDbRevision_608784;
          ClusterIdentifier: string; RevisionTarget: string;
          Action: string = "ModifyClusterDbRevision"; Version: string = "2012-12-01"): Recallable =
  ## postModifyClusterDbRevision
  ## Modifies the database revision of a cluster. The database revision is a unique revision of the database running in a cluster.
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of a cluster whose database revision you want to modify. </p> <p>Example: <code>examplecluster</code> </p>
  ##   Action: string (required)
  ##   RevisionTarget: string (required)
  ##                 : The identifier of the database revision. You can retrieve this value from the response to the <a>DescribeClusterDbRevisions</a> request.
  ##   Version: string (required)
  var query_608800 = newJObject()
  var formData_608801 = newJObject()
  add(formData_608801, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_608800, "Action", newJString(Action))
  add(formData_608801, "RevisionTarget", newJString(RevisionTarget))
  add(query_608800, "Version", newJString(Version))
  result = call_608799.call(nil, query_608800, nil, formData_608801, nil)

var postModifyClusterDbRevision* = Call_PostModifyClusterDbRevision_608784(
    name: "postModifyClusterDbRevision", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyClusterDbRevision",
    validator: validate_PostModifyClusterDbRevision_608785, base: "/",
    url: url_PostModifyClusterDbRevision_608786,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetModifyClusterDbRevision_608767 = ref object of OpenApiRestCall_605573
proc url_GetModifyClusterDbRevision_608769(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetModifyClusterDbRevision_608768(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies the database revision of a cluster. The database revision is a unique revision of the database running in a cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   RevisionTarget: JString (required)
  ##                 : The identifier of the database revision. You can retrieve this value from the response to the <a>DescribeClusterDbRevisions</a> request.
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of a cluster whose database revision you want to modify. </p> <p>Example: <code>examplecluster</code> </p>
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `RevisionTarget` field"
  var valid_608770 = query.getOrDefault("RevisionTarget")
  valid_608770 = validateParameter(valid_608770, JString, required = true,
                                 default = nil)
  if valid_608770 != nil:
    section.add "RevisionTarget", valid_608770
  var valid_608771 = query.getOrDefault("Action")
  valid_608771 = validateParameter(valid_608771, JString, required = true, default = newJString(
      "ModifyClusterDbRevision"))
  if valid_608771 != nil:
    section.add "Action", valid_608771
  var valid_608772 = query.getOrDefault("ClusterIdentifier")
  valid_608772 = validateParameter(valid_608772, JString, required = true,
                                 default = nil)
  if valid_608772 != nil:
    section.add "ClusterIdentifier", valid_608772
  var valid_608773 = query.getOrDefault("Version")
  valid_608773 = validateParameter(valid_608773, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_608773 != nil:
    section.add "Version", valid_608773
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_608774 = header.getOrDefault("X-Amz-Signature")
  valid_608774 = validateParameter(valid_608774, JString, required = false,
                                 default = nil)
  if valid_608774 != nil:
    section.add "X-Amz-Signature", valid_608774
  var valid_608775 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_608775 = validateParameter(valid_608775, JString, required = false,
                                 default = nil)
  if valid_608775 != nil:
    section.add "X-Amz-Content-Sha256", valid_608775
  var valid_608776 = header.getOrDefault("X-Amz-Date")
  valid_608776 = validateParameter(valid_608776, JString, required = false,
                                 default = nil)
  if valid_608776 != nil:
    section.add "X-Amz-Date", valid_608776
  var valid_608777 = header.getOrDefault("X-Amz-Credential")
  valid_608777 = validateParameter(valid_608777, JString, required = false,
                                 default = nil)
  if valid_608777 != nil:
    section.add "X-Amz-Credential", valid_608777
  var valid_608778 = header.getOrDefault("X-Amz-Security-Token")
  valid_608778 = validateParameter(valid_608778, JString, required = false,
                                 default = nil)
  if valid_608778 != nil:
    section.add "X-Amz-Security-Token", valid_608778
  var valid_608779 = header.getOrDefault("X-Amz-Algorithm")
  valid_608779 = validateParameter(valid_608779, JString, required = false,
                                 default = nil)
  if valid_608779 != nil:
    section.add "X-Amz-Algorithm", valid_608779
  var valid_608780 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_608780 = validateParameter(valid_608780, JString, required = false,
                                 default = nil)
  if valid_608780 != nil:
    section.add "X-Amz-SignedHeaders", valid_608780
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_608781: Call_GetModifyClusterDbRevision_608767; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Modifies the database revision of a cluster. The database revision is a unique revision of the database running in a cluster.
  ## 
  let valid = call_608781.validator(path, query, header, formData, body)
  let scheme = call_608781.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_608781.url(scheme.get, call_608781.host, call_608781.base,
                         call_608781.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_608781, url, valid)

proc call*(call_608782: Call_GetModifyClusterDbRevision_608767;
          RevisionTarget: string; ClusterIdentifier: string;
          Action: string = "ModifyClusterDbRevision"; Version: string = "2012-12-01"): Recallable =
  ## getModifyClusterDbRevision
  ## Modifies the database revision of a cluster. The database revision is a unique revision of the database running in a cluster.
  ##   RevisionTarget: string (required)
  ##                 : The identifier of the database revision. You can retrieve this value from the response to the <a>DescribeClusterDbRevisions</a> request.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of a cluster whose database revision you want to modify. </p> <p>Example: <code>examplecluster</code> </p>
  ##   Version: string (required)
  var query_608783 = newJObject()
  add(query_608783, "RevisionTarget", newJString(RevisionTarget))
  add(query_608783, "Action", newJString(Action))
  add(query_608783, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_608783, "Version", newJString(Version))
  result = call_608782.call(nil, query_608783, nil, nil, nil)

var getModifyClusterDbRevision* = Call_GetModifyClusterDbRevision_608767(
    name: "getModifyClusterDbRevision", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyClusterDbRevision",
    validator: validate_GetModifyClusterDbRevision_608768, base: "/",
    url: url_GetModifyClusterDbRevision_608769,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostModifyClusterIamRoles_608820 = ref object of OpenApiRestCall_605573
proc url_PostModifyClusterIamRoles_608822(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostModifyClusterIamRoles_608821(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Modifies the list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services.</p> <p>A cluster can have up to 10 IAM roles associated at any time.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_608823 = query.getOrDefault("Action")
  valid_608823 = validateParameter(valid_608823, JString, required = true,
                                 default = newJString("ModifyClusterIamRoles"))
  if valid_608823 != nil:
    section.add "Action", valid_608823
  var valid_608824 = query.getOrDefault("Version")
  valid_608824 = validateParameter(valid_608824, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_608824 != nil:
    section.add "Version", valid_608824
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_608825 = header.getOrDefault("X-Amz-Signature")
  valid_608825 = validateParameter(valid_608825, JString, required = false,
                                 default = nil)
  if valid_608825 != nil:
    section.add "X-Amz-Signature", valid_608825
  var valid_608826 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_608826 = validateParameter(valid_608826, JString, required = false,
                                 default = nil)
  if valid_608826 != nil:
    section.add "X-Amz-Content-Sha256", valid_608826
  var valid_608827 = header.getOrDefault("X-Amz-Date")
  valid_608827 = validateParameter(valid_608827, JString, required = false,
                                 default = nil)
  if valid_608827 != nil:
    section.add "X-Amz-Date", valid_608827
  var valid_608828 = header.getOrDefault("X-Amz-Credential")
  valid_608828 = validateParameter(valid_608828, JString, required = false,
                                 default = nil)
  if valid_608828 != nil:
    section.add "X-Amz-Credential", valid_608828
  var valid_608829 = header.getOrDefault("X-Amz-Security-Token")
  valid_608829 = validateParameter(valid_608829, JString, required = false,
                                 default = nil)
  if valid_608829 != nil:
    section.add "X-Amz-Security-Token", valid_608829
  var valid_608830 = header.getOrDefault("X-Amz-Algorithm")
  valid_608830 = validateParameter(valid_608830, JString, required = false,
                                 default = nil)
  if valid_608830 != nil:
    section.add "X-Amz-Algorithm", valid_608830
  var valid_608831 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_608831 = validateParameter(valid_608831, JString, required = false,
                                 default = nil)
  if valid_608831 != nil:
    section.add "X-Amz-SignedHeaders", valid_608831
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : The unique identifier of the cluster for which you want to associate or disassociate IAM roles.
  ##   RemoveIamRoles: JArray
  ##                 : Zero or more IAM roles in ARN format to disassociate from the cluster. You can disassociate up to 10 IAM roles from a single cluster in a single request.
  ##   AddIamRoles: JArray
  ##              : Zero or more IAM roles to associate with the cluster. The roles must be in their Amazon Resource Name (ARN) format. You can associate up to 10 IAM roles with a single cluster in a single request.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_608832 = formData.getOrDefault("ClusterIdentifier")
  valid_608832 = validateParameter(valid_608832, JString, required = true,
                                 default = nil)
  if valid_608832 != nil:
    section.add "ClusterIdentifier", valid_608832
  var valid_608833 = formData.getOrDefault("RemoveIamRoles")
  valid_608833 = validateParameter(valid_608833, JArray, required = false,
                                 default = nil)
  if valid_608833 != nil:
    section.add "RemoveIamRoles", valid_608833
  var valid_608834 = formData.getOrDefault("AddIamRoles")
  valid_608834 = validateParameter(valid_608834, JArray, required = false,
                                 default = nil)
  if valid_608834 != nil:
    section.add "AddIamRoles", valid_608834
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_608835: Call_PostModifyClusterIamRoles_608820; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Modifies the list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services.</p> <p>A cluster can have up to 10 IAM roles associated at any time.</p>
  ## 
  let valid = call_608835.validator(path, query, header, formData, body)
  let scheme = call_608835.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_608835.url(scheme.get, call_608835.host, call_608835.base,
                         call_608835.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_608835, url, valid)

proc call*(call_608836: Call_PostModifyClusterIamRoles_608820;
          ClusterIdentifier: string; RemoveIamRoles: JsonNode = nil;
          Action: string = "ModifyClusterIamRoles"; AddIamRoles: JsonNode = nil;
          Version: string = "2012-12-01"): Recallable =
  ## postModifyClusterIamRoles
  ## <p>Modifies the list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services.</p> <p>A cluster can have up to 10 IAM roles associated at any time.</p>
  ##   ClusterIdentifier: string (required)
  ##                    : The unique identifier of the cluster for which you want to associate or disassociate IAM roles.
  ##   RemoveIamRoles: JArray
  ##                 : Zero or more IAM roles in ARN format to disassociate from the cluster. You can disassociate up to 10 IAM roles from a single cluster in a single request.
  ##   Action: string (required)
  ##   AddIamRoles: JArray
  ##              : Zero or more IAM roles to associate with the cluster. The roles must be in their Amazon Resource Name (ARN) format. You can associate up to 10 IAM roles with a single cluster in a single request.
  ##   Version: string (required)
  var query_608837 = newJObject()
  var formData_608838 = newJObject()
  add(formData_608838, "ClusterIdentifier", newJString(ClusterIdentifier))
  if RemoveIamRoles != nil:
    formData_608838.add "RemoveIamRoles", RemoveIamRoles
  add(query_608837, "Action", newJString(Action))
  if AddIamRoles != nil:
    formData_608838.add "AddIamRoles", AddIamRoles
  add(query_608837, "Version", newJString(Version))
  result = call_608836.call(nil, query_608837, nil, formData_608838, nil)

var postModifyClusterIamRoles* = Call_PostModifyClusterIamRoles_608820(
    name: "postModifyClusterIamRoles", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyClusterIamRoles",
    validator: validate_PostModifyClusterIamRoles_608821, base: "/",
    url: url_PostModifyClusterIamRoles_608822,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetModifyClusterIamRoles_608802 = ref object of OpenApiRestCall_605573
proc url_GetModifyClusterIamRoles_608804(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetModifyClusterIamRoles_608803(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Modifies the list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services.</p> <p>A cluster can have up to 10 IAM roles associated at any time.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   AddIamRoles: JArray
  ##              : Zero or more IAM roles to associate with the cluster. The roles must be in their Amazon Resource Name (ARN) format. You can associate up to 10 IAM roles with a single cluster in a single request.
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : The unique identifier of the cluster for which you want to associate or disassociate IAM roles.
  ##   RemoveIamRoles: JArray
  ##                 : Zero or more IAM roles in ARN format to disassociate from the cluster. You can disassociate up to 10 IAM roles from a single cluster in a single request.
  ##   Version: JString (required)
  section = newJObject()
  var valid_608805 = query.getOrDefault("AddIamRoles")
  valid_608805 = validateParameter(valid_608805, JArray, required = false,
                                 default = nil)
  if valid_608805 != nil:
    section.add "AddIamRoles", valid_608805
  var valid_608806 = query.getOrDefault("Action")
  valid_608806 = validateParameter(valid_608806, JString, required = true,
                                 default = newJString("ModifyClusterIamRoles"))
  if valid_608806 != nil:
    section.add "Action", valid_608806
  var valid_608807 = query.getOrDefault("ClusterIdentifier")
  valid_608807 = validateParameter(valid_608807, JString, required = true,
                                 default = nil)
  if valid_608807 != nil:
    section.add "ClusterIdentifier", valid_608807
  var valid_608808 = query.getOrDefault("RemoveIamRoles")
  valid_608808 = validateParameter(valid_608808, JArray, required = false,
                                 default = nil)
  if valid_608808 != nil:
    section.add "RemoveIamRoles", valid_608808
  var valid_608809 = query.getOrDefault("Version")
  valid_608809 = validateParameter(valid_608809, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_608809 != nil:
    section.add "Version", valid_608809
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_608810 = header.getOrDefault("X-Amz-Signature")
  valid_608810 = validateParameter(valid_608810, JString, required = false,
                                 default = nil)
  if valid_608810 != nil:
    section.add "X-Amz-Signature", valid_608810
  var valid_608811 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_608811 = validateParameter(valid_608811, JString, required = false,
                                 default = nil)
  if valid_608811 != nil:
    section.add "X-Amz-Content-Sha256", valid_608811
  var valid_608812 = header.getOrDefault("X-Amz-Date")
  valid_608812 = validateParameter(valid_608812, JString, required = false,
                                 default = nil)
  if valid_608812 != nil:
    section.add "X-Amz-Date", valid_608812
  var valid_608813 = header.getOrDefault("X-Amz-Credential")
  valid_608813 = validateParameter(valid_608813, JString, required = false,
                                 default = nil)
  if valid_608813 != nil:
    section.add "X-Amz-Credential", valid_608813
  var valid_608814 = header.getOrDefault("X-Amz-Security-Token")
  valid_608814 = validateParameter(valid_608814, JString, required = false,
                                 default = nil)
  if valid_608814 != nil:
    section.add "X-Amz-Security-Token", valid_608814
  var valid_608815 = header.getOrDefault("X-Amz-Algorithm")
  valid_608815 = validateParameter(valid_608815, JString, required = false,
                                 default = nil)
  if valid_608815 != nil:
    section.add "X-Amz-Algorithm", valid_608815
  var valid_608816 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_608816 = validateParameter(valid_608816, JString, required = false,
                                 default = nil)
  if valid_608816 != nil:
    section.add "X-Amz-SignedHeaders", valid_608816
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_608817: Call_GetModifyClusterIamRoles_608802; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Modifies the list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services.</p> <p>A cluster can have up to 10 IAM roles associated at any time.</p>
  ## 
  let valid = call_608817.validator(path, query, header, formData, body)
  let scheme = call_608817.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_608817.url(scheme.get, call_608817.host, call_608817.base,
                         call_608817.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_608817, url, valid)

proc call*(call_608818: Call_GetModifyClusterIamRoles_608802;
          ClusterIdentifier: string; AddIamRoles: JsonNode = nil;
          Action: string = "ModifyClusterIamRoles"; RemoveIamRoles: JsonNode = nil;
          Version: string = "2012-12-01"): Recallable =
  ## getModifyClusterIamRoles
  ## <p>Modifies the list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services.</p> <p>A cluster can have up to 10 IAM roles associated at any time.</p>
  ##   AddIamRoles: JArray
  ##              : Zero or more IAM roles to associate with the cluster. The roles must be in their Amazon Resource Name (ARN) format. You can associate up to 10 IAM roles with a single cluster in a single request.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : The unique identifier of the cluster for which you want to associate or disassociate IAM roles.
  ##   RemoveIamRoles: JArray
  ##                 : Zero or more IAM roles in ARN format to disassociate from the cluster. You can disassociate up to 10 IAM roles from a single cluster in a single request.
  ##   Version: string (required)
  var query_608819 = newJObject()
  if AddIamRoles != nil:
    query_608819.add "AddIamRoles", AddIamRoles
  add(query_608819, "Action", newJString(Action))
  add(query_608819, "ClusterIdentifier", newJString(ClusterIdentifier))
  if RemoveIamRoles != nil:
    query_608819.add "RemoveIamRoles", RemoveIamRoles
  add(query_608819, "Version", newJString(Version))
  result = call_608818.call(nil, query_608819, nil, nil, nil)

var getModifyClusterIamRoles* = Call_GetModifyClusterIamRoles_608802(
    name: "getModifyClusterIamRoles", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyClusterIamRoles",
    validator: validate_GetModifyClusterIamRoles_608803, base: "/",
    url: url_GetModifyClusterIamRoles_608804, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostModifyClusterMaintenance_608860 = ref object of OpenApiRestCall_605573
proc url_PostModifyClusterMaintenance_608862(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostModifyClusterMaintenance_608861(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies the maintenance settings of a cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_608863 = query.getOrDefault("Action")
  valid_608863 = validateParameter(valid_608863, JString, required = true, default = newJString(
      "ModifyClusterMaintenance"))
  if valid_608863 != nil:
    section.add "Action", valid_608863
  var valid_608864 = query.getOrDefault("Version")
  valid_608864 = validateParameter(valid_608864, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_608864 != nil:
    section.add "Version", valid_608864
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_608865 = header.getOrDefault("X-Amz-Signature")
  valid_608865 = validateParameter(valid_608865, JString, required = false,
                                 default = nil)
  if valid_608865 != nil:
    section.add "X-Amz-Signature", valid_608865
  var valid_608866 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_608866 = validateParameter(valid_608866, JString, required = false,
                                 default = nil)
  if valid_608866 != nil:
    section.add "X-Amz-Content-Sha256", valid_608866
  var valid_608867 = header.getOrDefault("X-Amz-Date")
  valid_608867 = validateParameter(valid_608867, JString, required = false,
                                 default = nil)
  if valid_608867 != nil:
    section.add "X-Amz-Date", valid_608867
  var valid_608868 = header.getOrDefault("X-Amz-Credential")
  valid_608868 = validateParameter(valid_608868, JString, required = false,
                                 default = nil)
  if valid_608868 != nil:
    section.add "X-Amz-Credential", valid_608868
  var valid_608869 = header.getOrDefault("X-Amz-Security-Token")
  valid_608869 = validateParameter(valid_608869, JString, required = false,
                                 default = nil)
  if valid_608869 != nil:
    section.add "X-Amz-Security-Token", valid_608869
  var valid_608870 = header.getOrDefault("X-Amz-Algorithm")
  valid_608870 = validateParameter(valid_608870, JString, required = false,
                                 default = nil)
  if valid_608870 != nil:
    section.add "X-Amz-Algorithm", valid_608870
  var valid_608871 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_608871 = validateParameter(valid_608871, JString, required = false,
                                 default = nil)
  if valid_608871 != nil:
    section.add "X-Amz-SignedHeaders", valid_608871
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : A unique identifier for the cluster.
  ##   DeferMaintenanceStartTime: JString
  ##                            : A timestamp indicating the start time for the deferred maintenance window.
  ##   DeferMaintenance: JBool
  ##                   : A boolean indicating whether to enable the deferred maintenance window. 
  ##   DeferMaintenanceDuration: JInt
  ##                           : An integer indicating the duration of the maintenance window in days. If you specify a duration, you can't specify an end time. The duration must be 45 days or less.
  ##   DeferMaintenanceEndTime: JString
  ##                          : A timestamp indicating end time for the deferred maintenance window. If you specify an end time, you can't specify a duration.
  ##   DeferMaintenanceIdentifier: JString
  ##                             : A unique identifier for the deferred maintenance window.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_608872 = formData.getOrDefault("ClusterIdentifier")
  valid_608872 = validateParameter(valid_608872, JString, required = true,
                                 default = nil)
  if valid_608872 != nil:
    section.add "ClusterIdentifier", valid_608872
  var valid_608873 = formData.getOrDefault("DeferMaintenanceStartTime")
  valid_608873 = validateParameter(valid_608873, JString, required = false,
                                 default = nil)
  if valid_608873 != nil:
    section.add "DeferMaintenanceStartTime", valid_608873
  var valid_608874 = formData.getOrDefault("DeferMaintenance")
  valid_608874 = validateParameter(valid_608874, JBool, required = false, default = nil)
  if valid_608874 != nil:
    section.add "DeferMaintenance", valid_608874
  var valid_608875 = formData.getOrDefault("DeferMaintenanceDuration")
  valid_608875 = validateParameter(valid_608875, JInt, required = false, default = nil)
  if valid_608875 != nil:
    section.add "DeferMaintenanceDuration", valid_608875
  var valid_608876 = formData.getOrDefault("DeferMaintenanceEndTime")
  valid_608876 = validateParameter(valid_608876, JString, required = false,
                                 default = nil)
  if valid_608876 != nil:
    section.add "DeferMaintenanceEndTime", valid_608876
  var valid_608877 = formData.getOrDefault("DeferMaintenanceIdentifier")
  valid_608877 = validateParameter(valid_608877, JString, required = false,
                                 default = nil)
  if valid_608877 != nil:
    section.add "DeferMaintenanceIdentifier", valid_608877
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_608878: Call_PostModifyClusterMaintenance_608860; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Modifies the maintenance settings of a cluster.
  ## 
  let valid = call_608878.validator(path, query, header, formData, body)
  let scheme = call_608878.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_608878.url(scheme.get, call_608878.host, call_608878.base,
                         call_608878.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_608878, url, valid)

proc call*(call_608879: Call_PostModifyClusterMaintenance_608860;
          ClusterIdentifier: string; DeferMaintenanceStartTime: string = "";
          DeferMaintenance: bool = false; DeferMaintenanceDuration: int = 0;
          DeferMaintenanceEndTime: string = "";
          Action: string = "ModifyClusterMaintenance";
          DeferMaintenanceIdentifier: string = ""; Version: string = "2012-12-01"): Recallable =
  ## postModifyClusterMaintenance
  ## Modifies the maintenance settings of a cluster.
  ##   ClusterIdentifier: string (required)
  ##                    : A unique identifier for the cluster.
  ##   DeferMaintenanceStartTime: string
  ##                            : A timestamp indicating the start time for the deferred maintenance window.
  ##   DeferMaintenance: bool
  ##                   : A boolean indicating whether to enable the deferred maintenance window. 
  ##   DeferMaintenanceDuration: int
  ##                           : An integer indicating the duration of the maintenance window in days. If you specify a duration, you can't specify an end time. The duration must be 45 days or less.
  ##   DeferMaintenanceEndTime: string
  ##                          : A timestamp indicating end time for the deferred maintenance window. If you specify an end time, you can't specify a duration.
  ##   Action: string (required)
  ##   DeferMaintenanceIdentifier: string
  ##                             : A unique identifier for the deferred maintenance window.
  ##   Version: string (required)
  var query_608880 = newJObject()
  var formData_608881 = newJObject()
  add(formData_608881, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_608881, "DeferMaintenanceStartTime",
      newJString(DeferMaintenanceStartTime))
  add(formData_608881, "DeferMaintenance", newJBool(DeferMaintenance))
  add(formData_608881, "DeferMaintenanceDuration",
      newJInt(DeferMaintenanceDuration))
  add(formData_608881, "DeferMaintenanceEndTime",
      newJString(DeferMaintenanceEndTime))
  add(query_608880, "Action", newJString(Action))
  add(formData_608881, "DeferMaintenanceIdentifier",
      newJString(DeferMaintenanceIdentifier))
  add(query_608880, "Version", newJString(Version))
  result = call_608879.call(nil, query_608880, nil, formData_608881, nil)

var postModifyClusterMaintenance* = Call_PostModifyClusterMaintenance_608860(
    name: "postModifyClusterMaintenance", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyClusterMaintenance",
    validator: validate_PostModifyClusterMaintenance_608861, base: "/",
    url: url_PostModifyClusterMaintenance_608862,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetModifyClusterMaintenance_608839 = ref object of OpenApiRestCall_605573
proc url_GetModifyClusterMaintenance_608841(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetModifyClusterMaintenance_608840(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies the maintenance settings of a cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   DeferMaintenanceDuration: JInt
  ##                           : An integer indicating the duration of the maintenance window in days. If you specify a duration, you can't specify an end time. The duration must be 45 days or less.
  ##   DeferMaintenanceIdentifier: JString
  ##                             : A unique identifier for the deferred maintenance window.
  ##   DeferMaintenanceEndTime: JString
  ##                          : A timestamp indicating end time for the deferred maintenance window. If you specify an end time, you can't specify a duration.
  ##   Action: JString (required)
  ##   DeferMaintenance: JBool
  ##                   : A boolean indicating whether to enable the deferred maintenance window. 
  ##   ClusterIdentifier: JString (required)
  ##                    : A unique identifier for the cluster.
  ##   Version: JString (required)
  ##   DeferMaintenanceStartTime: JString
  ##                            : A timestamp indicating the start time for the deferred maintenance window.
  section = newJObject()
  var valid_608842 = query.getOrDefault("DeferMaintenanceDuration")
  valid_608842 = validateParameter(valid_608842, JInt, required = false, default = nil)
  if valid_608842 != nil:
    section.add "DeferMaintenanceDuration", valid_608842
  var valid_608843 = query.getOrDefault("DeferMaintenanceIdentifier")
  valid_608843 = validateParameter(valid_608843, JString, required = false,
                                 default = nil)
  if valid_608843 != nil:
    section.add "DeferMaintenanceIdentifier", valid_608843
  var valid_608844 = query.getOrDefault("DeferMaintenanceEndTime")
  valid_608844 = validateParameter(valid_608844, JString, required = false,
                                 default = nil)
  if valid_608844 != nil:
    section.add "DeferMaintenanceEndTime", valid_608844
  var valid_608845 = query.getOrDefault("Action")
  valid_608845 = validateParameter(valid_608845, JString, required = true, default = newJString(
      "ModifyClusterMaintenance"))
  if valid_608845 != nil:
    section.add "Action", valid_608845
  var valid_608846 = query.getOrDefault("DeferMaintenance")
  valid_608846 = validateParameter(valid_608846, JBool, required = false, default = nil)
  if valid_608846 != nil:
    section.add "DeferMaintenance", valid_608846
  var valid_608847 = query.getOrDefault("ClusterIdentifier")
  valid_608847 = validateParameter(valid_608847, JString, required = true,
                                 default = nil)
  if valid_608847 != nil:
    section.add "ClusterIdentifier", valid_608847
  var valid_608848 = query.getOrDefault("Version")
  valid_608848 = validateParameter(valid_608848, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_608848 != nil:
    section.add "Version", valid_608848
  var valid_608849 = query.getOrDefault("DeferMaintenanceStartTime")
  valid_608849 = validateParameter(valid_608849, JString, required = false,
                                 default = nil)
  if valid_608849 != nil:
    section.add "DeferMaintenanceStartTime", valid_608849
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_608850 = header.getOrDefault("X-Amz-Signature")
  valid_608850 = validateParameter(valid_608850, JString, required = false,
                                 default = nil)
  if valid_608850 != nil:
    section.add "X-Amz-Signature", valid_608850
  var valid_608851 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_608851 = validateParameter(valid_608851, JString, required = false,
                                 default = nil)
  if valid_608851 != nil:
    section.add "X-Amz-Content-Sha256", valid_608851
  var valid_608852 = header.getOrDefault("X-Amz-Date")
  valid_608852 = validateParameter(valid_608852, JString, required = false,
                                 default = nil)
  if valid_608852 != nil:
    section.add "X-Amz-Date", valid_608852
  var valid_608853 = header.getOrDefault("X-Amz-Credential")
  valid_608853 = validateParameter(valid_608853, JString, required = false,
                                 default = nil)
  if valid_608853 != nil:
    section.add "X-Amz-Credential", valid_608853
  var valid_608854 = header.getOrDefault("X-Amz-Security-Token")
  valid_608854 = validateParameter(valid_608854, JString, required = false,
                                 default = nil)
  if valid_608854 != nil:
    section.add "X-Amz-Security-Token", valid_608854
  var valid_608855 = header.getOrDefault("X-Amz-Algorithm")
  valid_608855 = validateParameter(valid_608855, JString, required = false,
                                 default = nil)
  if valid_608855 != nil:
    section.add "X-Amz-Algorithm", valid_608855
  var valid_608856 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_608856 = validateParameter(valid_608856, JString, required = false,
                                 default = nil)
  if valid_608856 != nil:
    section.add "X-Amz-SignedHeaders", valid_608856
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_608857: Call_GetModifyClusterMaintenance_608839; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Modifies the maintenance settings of a cluster.
  ## 
  let valid = call_608857.validator(path, query, header, formData, body)
  let scheme = call_608857.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_608857.url(scheme.get, call_608857.host, call_608857.base,
                         call_608857.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_608857, url, valid)

proc call*(call_608858: Call_GetModifyClusterMaintenance_608839;
          ClusterIdentifier: string; DeferMaintenanceDuration: int = 0;
          DeferMaintenanceIdentifier: string = "";
          DeferMaintenanceEndTime: string = "";
          Action: string = "ModifyClusterMaintenance";
          DeferMaintenance: bool = false; Version: string = "2012-12-01";
          DeferMaintenanceStartTime: string = ""): Recallable =
  ## getModifyClusterMaintenance
  ## Modifies the maintenance settings of a cluster.
  ##   DeferMaintenanceDuration: int
  ##                           : An integer indicating the duration of the maintenance window in days. If you specify a duration, you can't specify an end time. The duration must be 45 days or less.
  ##   DeferMaintenanceIdentifier: string
  ##                             : A unique identifier for the deferred maintenance window.
  ##   DeferMaintenanceEndTime: string
  ##                          : A timestamp indicating end time for the deferred maintenance window. If you specify an end time, you can't specify a duration.
  ##   Action: string (required)
  ##   DeferMaintenance: bool
  ##                   : A boolean indicating whether to enable the deferred maintenance window. 
  ##   ClusterIdentifier: string (required)
  ##                    : A unique identifier for the cluster.
  ##   Version: string (required)
  ##   DeferMaintenanceStartTime: string
  ##                            : A timestamp indicating the start time for the deferred maintenance window.
  var query_608859 = newJObject()
  add(query_608859, "DeferMaintenanceDuration", newJInt(DeferMaintenanceDuration))
  add(query_608859, "DeferMaintenanceIdentifier",
      newJString(DeferMaintenanceIdentifier))
  add(query_608859, "DeferMaintenanceEndTime", newJString(DeferMaintenanceEndTime))
  add(query_608859, "Action", newJString(Action))
  add(query_608859, "DeferMaintenance", newJBool(DeferMaintenance))
  add(query_608859, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_608859, "Version", newJString(Version))
  add(query_608859, "DeferMaintenanceStartTime",
      newJString(DeferMaintenanceStartTime))
  result = call_608858.call(nil, query_608859, nil, nil, nil)

var getModifyClusterMaintenance* = Call_GetModifyClusterMaintenance_608839(
    name: "getModifyClusterMaintenance", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyClusterMaintenance",
    validator: validate_GetModifyClusterMaintenance_608840, base: "/",
    url: url_GetModifyClusterMaintenance_608841,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostModifyClusterParameterGroup_608899 = ref object of OpenApiRestCall_605573
proc url_PostModifyClusterParameterGroup_608901(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostModifyClusterParameterGroup_608900(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Modifies the parameters of a parameter group.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_608902 = query.getOrDefault("Action")
  valid_608902 = validateParameter(valid_608902, JString, required = true, default = newJString(
      "ModifyClusterParameterGroup"))
  if valid_608902 != nil:
    section.add "Action", valid_608902
  var valid_608903 = query.getOrDefault("Version")
  valid_608903 = validateParameter(valid_608903, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_608903 != nil:
    section.add "Version", valid_608903
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_608904 = header.getOrDefault("X-Amz-Signature")
  valid_608904 = validateParameter(valid_608904, JString, required = false,
                                 default = nil)
  if valid_608904 != nil:
    section.add "X-Amz-Signature", valid_608904
  var valid_608905 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_608905 = validateParameter(valid_608905, JString, required = false,
                                 default = nil)
  if valid_608905 != nil:
    section.add "X-Amz-Content-Sha256", valid_608905
  var valid_608906 = header.getOrDefault("X-Amz-Date")
  valid_608906 = validateParameter(valid_608906, JString, required = false,
                                 default = nil)
  if valid_608906 != nil:
    section.add "X-Amz-Date", valid_608906
  var valid_608907 = header.getOrDefault("X-Amz-Credential")
  valid_608907 = validateParameter(valid_608907, JString, required = false,
                                 default = nil)
  if valid_608907 != nil:
    section.add "X-Amz-Credential", valid_608907
  var valid_608908 = header.getOrDefault("X-Amz-Security-Token")
  valid_608908 = validateParameter(valid_608908, JString, required = false,
                                 default = nil)
  if valid_608908 != nil:
    section.add "X-Amz-Security-Token", valid_608908
  var valid_608909 = header.getOrDefault("X-Amz-Algorithm")
  valid_608909 = validateParameter(valid_608909, JString, required = false,
                                 default = nil)
  if valid_608909 != nil:
    section.add "X-Amz-Algorithm", valid_608909
  var valid_608910 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_608910 = validateParameter(valid_608910, JString, required = false,
                                 default = nil)
  if valid_608910 != nil:
    section.add "X-Amz-SignedHeaders", valid_608910
  result.add "header", section
  ## parameters in `formData` object:
  ##   Parameters: JArray (required)
  ##             : <p>An array of parameters to be modified. A maximum of 20 parameters can be modified in a single request.</p> <p>For each parameter to be modified, you must supply at least the parameter name and parameter value; other name-value pairs of the parameter are optional.</p> <p>For the workload management (WLM) configuration, you must supply all the name-value pairs in the wlm_json_configuration parameter.</p>
  ##   ParameterGroupName: JString (required)
  ##                     : The name of the parameter group to be modified.
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `Parameters` field"
  var valid_608911 = formData.getOrDefault("Parameters")
  valid_608911 = validateParameter(valid_608911, JArray, required = true, default = nil)
  if valid_608911 != nil:
    section.add "Parameters", valid_608911
  var valid_608912 = formData.getOrDefault("ParameterGroupName")
  valid_608912 = validateParameter(valid_608912, JString, required = true,
                                 default = nil)
  if valid_608912 != nil:
    section.add "ParameterGroupName", valid_608912
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_608913: Call_PostModifyClusterParameterGroup_608899;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Modifies the parameters of a parameter group.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_608913.validator(path, query, header, formData, body)
  let scheme = call_608913.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_608913.url(scheme.get, call_608913.host, call_608913.base,
                         call_608913.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_608913, url, valid)

proc call*(call_608914: Call_PostModifyClusterParameterGroup_608899;
          Parameters: JsonNode; ParameterGroupName: string;
          Action: string = "ModifyClusterParameterGroup";
          Version: string = "2012-12-01"): Recallable =
  ## postModifyClusterParameterGroup
  ## <p>Modifies the parameters of a parameter group.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   Action: string (required)
  ##   Parameters: JArray (required)
  ##             : <p>An array of parameters to be modified. A maximum of 20 parameters can be modified in a single request.</p> <p>For each parameter to be modified, you must supply at least the parameter name and parameter value; other name-value pairs of the parameter are optional.</p> <p>For the workload management (WLM) configuration, you must supply all the name-value pairs in the wlm_json_configuration parameter.</p>
  ##   ParameterGroupName: string (required)
  ##                     : The name of the parameter group to be modified.
  ##   Version: string (required)
  var query_608915 = newJObject()
  var formData_608916 = newJObject()
  add(query_608915, "Action", newJString(Action))
  if Parameters != nil:
    formData_608916.add "Parameters", Parameters
  add(formData_608916, "ParameterGroupName", newJString(ParameterGroupName))
  add(query_608915, "Version", newJString(Version))
  result = call_608914.call(nil, query_608915, nil, formData_608916, nil)

var postModifyClusterParameterGroup* = Call_PostModifyClusterParameterGroup_608899(
    name: "postModifyClusterParameterGroup", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyClusterParameterGroup",
    validator: validate_PostModifyClusterParameterGroup_608900, base: "/",
    url: url_PostModifyClusterParameterGroup_608901,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetModifyClusterParameterGroup_608882 = ref object of OpenApiRestCall_605573
proc url_GetModifyClusterParameterGroup_608884(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetModifyClusterParameterGroup_608883(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Modifies the parameters of a parameter group.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Parameters: JArray (required)
  ##             : <p>An array of parameters to be modified. A maximum of 20 parameters can be modified in a single request.</p> <p>For each parameter to be modified, you must supply at least the parameter name and parameter value; other name-value pairs of the parameter are optional.</p> <p>For the workload management (WLM) configuration, you must supply all the name-value pairs in the wlm_json_configuration parameter.</p>
  ##   Action: JString (required)
  ##   ParameterGroupName: JString (required)
  ##                     : The name of the parameter group to be modified.
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `Parameters` field"
  var valid_608885 = query.getOrDefault("Parameters")
  valid_608885 = validateParameter(valid_608885, JArray, required = true, default = nil)
  if valid_608885 != nil:
    section.add "Parameters", valid_608885
  var valid_608886 = query.getOrDefault("Action")
  valid_608886 = validateParameter(valid_608886, JString, required = true, default = newJString(
      "ModifyClusterParameterGroup"))
  if valid_608886 != nil:
    section.add "Action", valid_608886
  var valid_608887 = query.getOrDefault("ParameterGroupName")
  valid_608887 = validateParameter(valid_608887, JString, required = true,
                                 default = nil)
  if valid_608887 != nil:
    section.add "ParameterGroupName", valid_608887
  var valid_608888 = query.getOrDefault("Version")
  valid_608888 = validateParameter(valid_608888, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_608888 != nil:
    section.add "Version", valid_608888
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_608889 = header.getOrDefault("X-Amz-Signature")
  valid_608889 = validateParameter(valid_608889, JString, required = false,
                                 default = nil)
  if valid_608889 != nil:
    section.add "X-Amz-Signature", valid_608889
  var valid_608890 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_608890 = validateParameter(valid_608890, JString, required = false,
                                 default = nil)
  if valid_608890 != nil:
    section.add "X-Amz-Content-Sha256", valid_608890
  var valid_608891 = header.getOrDefault("X-Amz-Date")
  valid_608891 = validateParameter(valid_608891, JString, required = false,
                                 default = nil)
  if valid_608891 != nil:
    section.add "X-Amz-Date", valid_608891
  var valid_608892 = header.getOrDefault("X-Amz-Credential")
  valid_608892 = validateParameter(valid_608892, JString, required = false,
                                 default = nil)
  if valid_608892 != nil:
    section.add "X-Amz-Credential", valid_608892
  var valid_608893 = header.getOrDefault("X-Amz-Security-Token")
  valid_608893 = validateParameter(valid_608893, JString, required = false,
                                 default = nil)
  if valid_608893 != nil:
    section.add "X-Amz-Security-Token", valid_608893
  var valid_608894 = header.getOrDefault("X-Amz-Algorithm")
  valid_608894 = validateParameter(valid_608894, JString, required = false,
                                 default = nil)
  if valid_608894 != nil:
    section.add "X-Amz-Algorithm", valid_608894
  var valid_608895 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_608895 = validateParameter(valid_608895, JString, required = false,
                                 default = nil)
  if valid_608895 != nil:
    section.add "X-Amz-SignedHeaders", valid_608895
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_608896: Call_GetModifyClusterParameterGroup_608882; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Modifies the parameters of a parameter group.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_608896.validator(path, query, header, formData, body)
  let scheme = call_608896.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_608896.url(scheme.get, call_608896.host, call_608896.base,
                         call_608896.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_608896, url, valid)

proc call*(call_608897: Call_GetModifyClusterParameterGroup_608882;
          Parameters: JsonNode; ParameterGroupName: string;
          Action: string = "ModifyClusterParameterGroup";
          Version: string = "2012-12-01"): Recallable =
  ## getModifyClusterParameterGroup
  ## <p>Modifies the parameters of a parameter group.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   Parameters: JArray (required)
  ##             : <p>An array of parameters to be modified. A maximum of 20 parameters can be modified in a single request.</p> <p>For each parameter to be modified, you must supply at least the parameter name and parameter value; other name-value pairs of the parameter are optional.</p> <p>For the workload management (WLM) configuration, you must supply all the name-value pairs in the wlm_json_configuration parameter.</p>
  ##   Action: string (required)
  ##   ParameterGroupName: string (required)
  ##                     : The name of the parameter group to be modified.
  ##   Version: string (required)
  var query_608898 = newJObject()
  if Parameters != nil:
    query_608898.add "Parameters", Parameters
  add(query_608898, "Action", newJString(Action))
  add(query_608898, "ParameterGroupName", newJString(ParameterGroupName))
  add(query_608898, "Version", newJString(Version))
  result = call_608897.call(nil, query_608898, nil, nil, nil)

var getModifyClusterParameterGroup* = Call_GetModifyClusterParameterGroup_608882(
    name: "getModifyClusterParameterGroup", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyClusterParameterGroup",
    validator: validate_GetModifyClusterParameterGroup_608883, base: "/",
    url: url_GetModifyClusterParameterGroup_608884,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostModifyClusterSnapshot_608935 = ref object of OpenApiRestCall_605573
proc url_PostModifyClusterSnapshot_608937(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostModifyClusterSnapshot_608936(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Modifies the settings for a snapshot.</p> <p>This exanmple modifies the manual retention period setting for a cluster snapshot.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_608938 = query.getOrDefault("Action")
  valid_608938 = validateParameter(valid_608938, JString, required = true,
                                 default = newJString("ModifyClusterSnapshot"))
  if valid_608938 != nil:
    section.add "Action", valid_608938
  var valid_608939 = query.getOrDefault("Version")
  valid_608939 = validateParameter(valid_608939, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_608939 != nil:
    section.add "Version", valid_608939
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_608940 = header.getOrDefault("X-Amz-Signature")
  valid_608940 = validateParameter(valid_608940, JString, required = false,
                                 default = nil)
  if valid_608940 != nil:
    section.add "X-Amz-Signature", valid_608940
  var valid_608941 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_608941 = validateParameter(valid_608941, JString, required = false,
                                 default = nil)
  if valid_608941 != nil:
    section.add "X-Amz-Content-Sha256", valid_608941
  var valid_608942 = header.getOrDefault("X-Amz-Date")
  valid_608942 = validateParameter(valid_608942, JString, required = false,
                                 default = nil)
  if valid_608942 != nil:
    section.add "X-Amz-Date", valid_608942
  var valid_608943 = header.getOrDefault("X-Amz-Credential")
  valid_608943 = validateParameter(valid_608943, JString, required = false,
                                 default = nil)
  if valid_608943 != nil:
    section.add "X-Amz-Credential", valid_608943
  var valid_608944 = header.getOrDefault("X-Amz-Security-Token")
  valid_608944 = validateParameter(valid_608944, JString, required = false,
                                 default = nil)
  if valid_608944 != nil:
    section.add "X-Amz-Security-Token", valid_608944
  var valid_608945 = header.getOrDefault("X-Amz-Algorithm")
  valid_608945 = validateParameter(valid_608945, JString, required = false,
                                 default = nil)
  if valid_608945 != nil:
    section.add "X-Amz-Algorithm", valid_608945
  var valid_608946 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_608946 = validateParameter(valid_608946, JString, required = false,
                                 default = nil)
  if valid_608946 != nil:
    section.add "X-Amz-SignedHeaders", valid_608946
  result.add "header", section
  ## parameters in `formData` object:
  ##   Force: JBool
  ##        : A Boolean option to override an exception if the retention period has already passed.
  ##   SnapshotIdentifier: JString (required)
  ##                     : The identifier of the snapshot whose setting you want to modify.
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely.</p> <p>If the manual snapshot falls outside of the new retention period, you can specify the force option to immediately delete the snapshot.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  section = newJObject()
  var valid_608947 = formData.getOrDefault("Force")
  valid_608947 = validateParameter(valid_608947, JBool, required = false, default = nil)
  if valid_608947 != nil:
    section.add "Force", valid_608947
  assert formData != nil, "formData argument is necessary due to required `SnapshotIdentifier` field"
  var valid_608948 = formData.getOrDefault("SnapshotIdentifier")
  valid_608948 = validateParameter(valid_608948, JString, required = true,
                                 default = nil)
  if valid_608948 != nil:
    section.add "SnapshotIdentifier", valid_608948
  var valid_608949 = formData.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_608949 = validateParameter(valid_608949, JInt, required = false, default = nil)
  if valid_608949 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_608949
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_608950: Call_PostModifyClusterSnapshot_608935; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Modifies the settings for a snapshot.</p> <p>This exanmple modifies the manual retention period setting for a cluster snapshot.</p>
  ## 
  let valid = call_608950.validator(path, query, header, formData, body)
  let scheme = call_608950.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_608950.url(scheme.get, call_608950.host, call_608950.base,
                         call_608950.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_608950, url, valid)

proc call*(call_608951: Call_PostModifyClusterSnapshot_608935;
          SnapshotIdentifier: string; Force: bool = false;
          Action: string = "ModifyClusterSnapshot"; Version: string = "2012-12-01";
          ManualSnapshotRetentionPeriod: int = 0): Recallable =
  ## postModifyClusterSnapshot
  ## <p>Modifies the settings for a snapshot.</p> <p>This exanmple modifies the manual retention period setting for a cluster snapshot.</p>
  ##   Force: bool
  ##        : A Boolean option to override an exception if the retention period has already passed.
  ##   SnapshotIdentifier: string (required)
  ##                     : The identifier of the snapshot whose setting you want to modify.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely.</p> <p>If the manual snapshot falls outside of the new retention period, you can specify the force option to immediately delete the snapshot.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  var query_608952 = newJObject()
  var formData_608953 = newJObject()
  add(formData_608953, "Force", newJBool(Force))
  add(formData_608953, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_608952, "Action", newJString(Action))
  add(query_608952, "Version", newJString(Version))
  add(formData_608953, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  result = call_608951.call(nil, query_608952, nil, formData_608953, nil)

var postModifyClusterSnapshot* = Call_PostModifyClusterSnapshot_608935(
    name: "postModifyClusterSnapshot", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyClusterSnapshot",
    validator: validate_PostModifyClusterSnapshot_608936, base: "/",
    url: url_PostModifyClusterSnapshot_608937,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetModifyClusterSnapshot_608917 = ref object of OpenApiRestCall_605573
proc url_GetModifyClusterSnapshot_608919(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetModifyClusterSnapshot_608918(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Modifies the settings for a snapshot.</p> <p>This exanmple modifies the manual retention period setting for a cluster snapshot.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   SnapshotIdentifier: JString (required)
  ##                     : The identifier of the snapshot whose setting you want to modify.
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely.</p> <p>If the manual snapshot falls outside of the new retention period, you can specify the force option to immediately delete the snapshot.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  ##   Force: JBool
  ##        : A Boolean option to override an exception if the retention period has already passed.
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `SnapshotIdentifier` field"
  var valid_608920 = query.getOrDefault("SnapshotIdentifier")
  valid_608920 = validateParameter(valid_608920, JString, required = true,
                                 default = nil)
  if valid_608920 != nil:
    section.add "SnapshotIdentifier", valid_608920
  var valid_608921 = query.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_608921 = validateParameter(valid_608921, JInt, required = false, default = nil)
  if valid_608921 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_608921
  var valid_608922 = query.getOrDefault("Force")
  valid_608922 = validateParameter(valid_608922, JBool, required = false, default = nil)
  if valid_608922 != nil:
    section.add "Force", valid_608922
  var valid_608923 = query.getOrDefault("Action")
  valid_608923 = validateParameter(valid_608923, JString, required = true,
                                 default = newJString("ModifyClusterSnapshot"))
  if valid_608923 != nil:
    section.add "Action", valid_608923
  var valid_608924 = query.getOrDefault("Version")
  valid_608924 = validateParameter(valid_608924, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_608924 != nil:
    section.add "Version", valid_608924
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_608925 = header.getOrDefault("X-Amz-Signature")
  valid_608925 = validateParameter(valid_608925, JString, required = false,
                                 default = nil)
  if valid_608925 != nil:
    section.add "X-Amz-Signature", valid_608925
  var valid_608926 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_608926 = validateParameter(valid_608926, JString, required = false,
                                 default = nil)
  if valid_608926 != nil:
    section.add "X-Amz-Content-Sha256", valid_608926
  var valid_608927 = header.getOrDefault("X-Amz-Date")
  valid_608927 = validateParameter(valid_608927, JString, required = false,
                                 default = nil)
  if valid_608927 != nil:
    section.add "X-Amz-Date", valid_608927
  var valid_608928 = header.getOrDefault("X-Amz-Credential")
  valid_608928 = validateParameter(valid_608928, JString, required = false,
                                 default = nil)
  if valid_608928 != nil:
    section.add "X-Amz-Credential", valid_608928
  var valid_608929 = header.getOrDefault("X-Amz-Security-Token")
  valid_608929 = validateParameter(valid_608929, JString, required = false,
                                 default = nil)
  if valid_608929 != nil:
    section.add "X-Amz-Security-Token", valid_608929
  var valid_608930 = header.getOrDefault("X-Amz-Algorithm")
  valid_608930 = validateParameter(valid_608930, JString, required = false,
                                 default = nil)
  if valid_608930 != nil:
    section.add "X-Amz-Algorithm", valid_608930
  var valid_608931 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_608931 = validateParameter(valid_608931, JString, required = false,
                                 default = nil)
  if valid_608931 != nil:
    section.add "X-Amz-SignedHeaders", valid_608931
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_608932: Call_GetModifyClusterSnapshot_608917; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Modifies the settings for a snapshot.</p> <p>This exanmple modifies the manual retention period setting for a cluster snapshot.</p>
  ## 
  let valid = call_608932.validator(path, query, header, formData, body)
  let scheme = call_608932.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_608932.url(scheme.get, call_608932.host, call_608932.base,
                         call_608932.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_608932, url, valid)

proc call*(call_608933: Call_GetModifyClusterSnapshot_608917;
          SnapshotIdentifier: string; ManualSnapshotRetentionPeriod: int = 0;
          Force: bool = false; Action: string = "ModifyClusterSnapshot";
          Version: string = "2012-12-01"): Recallable =
  ## getModifyClusterSnapshot
  ## <p>Modifies the settings for a snapshot.</p> <p>This exanmple modifies the manual retention period setting for a cluster snapshot.</p>
  ##   SnapshotIdentifier: string (required)
  ##                     : The identifier of the snapshot whose setting you want to modify.
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely.</p> <p>If the manual snapshot falls outside of the new retention period, you can specify the force option to immediately delete the snapshot.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  ##   Force: bool
  ##        : A Boolean option to override an exception if the retention period has already passed.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_608934 = newJObject()
  add(query_608934, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_608934, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  add(query_608934, "Force", newJBool(Force))
  add(query_608934, "Action", newJString(Action))
  add(query_608934, "Version", newJString(Version))
  result = call_608933.call(nil, query_608934, nil, nil, nil)

var getModifyClusterSnapshot* = Call_GetModifyClusterSnapshot_608917(
    name: "getModifyClusterSnapshot", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyClusterSnapshot",
    validator: validate_GetModifyClusterSnapshot_608918, base: "/",
    url: url_GetModifyClusterSnapshot_608919, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostModifyClusterSnapshotSchedule_608972 = ref object of OpenApiRestCall_605573
proc url_PostModifyClusterSnapshotSchedule_608974(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostModifyClusterSnapshotSchedule_608973(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies a snapshot schedule for a cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_608975 = query.getOrDefault("Action")
  valid_608975 = validateParameter(valid_608975, JString, required = true, default = newJString(
      "ModifyClusterSnapshotSchedule"))
  if valid_608975 != nil:
    section.add "Action", valid_608975
  var valid_608976 = query.getOrDefault("Version")
  valid_608976 = validateParameter(valid_608976, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_608976 != nil:
    section.add "Version", valid_608976
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_608977 = header.getOrDefault("X-Amz-Signature")
  valid_608977 = validateParameter(valid_608977, JString, required = false,
                                 default = nil)
  if valid_608977 != nil:
    section.add "X-Amz-Signature", valid_608977
  var valid_608978 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_608978 = validateParameter(valid_608978, JString, required = false,
                                 default = nil)
  if valid_608978 != nil:
    section.add "X-Amz-Content-Sha256", valid_608978
  var valid_608979 = header.getOrDefault("X-Amz-Date")
  valid_608979 = validateParameter(valid_608979, JString, required = false,
                                 default = nil)
  if valid_608979 != nil:
    section.add "X-Amz-Date", valid_608979
  var valid_608980 = header.getOrDefault("X-Amz-Credential")
  valid_608980 = validateParameter(valid_608980, JString, required = false,
                                 default = nil)
  if valid_608980 != nil:
    section.add "X-Amz-Credential", valid_608980
  var valid_608981 = header.getOrDefault("X-Amz-Security-Token")
  valid_608981 = validateParameter(valid_608981, JString, required = false,
                                 default = nil)
  if valid_608981 != nil:
    section.add "X-Amz-Security-Token", valid_608981
  var valid_608982 = header.getOrDefault("X-Amz-Algorithm")
  valid_608982 = validateParameter(valid_608982, JString, required = false,
                                 default = nil)
  if valid_608982 != nil:
    section.add "X-Amz-Algorithm", valid_608982
  var valid_608983 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_608983 = validateParameter(valid_608983, JString, required = false,
                                 default = nil)
  if valid_608983 != nil:
    section.add "X-Amz-SignedHeaders", valid_608983
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : A unique identifier for the cluster whose snapshot schedule you want to modify. 
  ##   ScheduleIdentifier: JString
  ##                     : A unique alphanumeric identifier for the schedule that you want to associate with the cluster.
  ##   DisassociateSchedule: JBool
  ##                       : A boolean to indicate whether to remove the assoiciation between the cluster and the schedule.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_608984 = formData.getOrDefault("ClusterIdentifier")
  valid_608984 = validateParameter(valid_608984, JString, required = true,
                                 default = nil)
  if valid_608984 != nil:
    section.add "ClusterIdentifier", valid_608984
  var valid_608985 = formData.getOrDefault("ScheduleIdentifier")
  valid_608985 = validateParameter(valid_608985, JString, required = false,
                                 default = nil)
  if valid_608985 != nil:
    section.add "ScheduleIdentifier", valid_608985
  var valid_608986 = formData.getOrDefault("DisassociateSchedule")
  valid_608986 = validateParameter(valid_608986, JBool, required = false, default = nil)
  if valid_608986 != nil:
    section.add "DisassociateSchedule", valid_608986
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_608987: Call_PostModifyClusterSnapshotSchedule_608972;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Modifies a snapshot schedule for a cluster.
  ## 
  let valid = call_608987.validator(path, query, header, formData, body)
  let scheme = call_608987.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_608987.url(scheme.get, call_608987.host, call_608987.base,
                         call_608987.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_608987, url, valid)

proc call*(call_608988: Call_PostModifyClusterSnapshotSchedule_608972;
          ClusterIdentifier: string;
          Action: string = "ModifyClusterSnapshotSchedule";
          ScheduleIdentifier: string = ""; DisassociateSchedule: bool = false;
          Version: string = "2012-12-01"): Recallable =
  ## postModifyClusterSnapshotSchedule
  ## Modifies a snapshot schedule for a cluster.
  ##   ClusterIdentifier: string (required)
  ##                    : A unique identifier for the cluster whose snapshot schedule you want to modify. 
  ##   Action: string (required)
  ##   ScheduleIdentifier: string
  ##                     : A unique alphanumeric identifier for the schedule that you want to associate with the cluster.
  ##   DisassociateSchedule: bool
  ##                       : A boolean to indicate whether to remove the assoiciation between the cluster and the schedule.
  ##   Version: string (required)
  var query_608989 = newJObject()
  var formData_608990 = newJObject()
  add(formData_608990, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_608989, "Action", newJString(Action))
  add(formData_608990, "ScheduleIdentifier", newJString(ScheduleIdentifier))
  add(formData_608990, "DisassociateSchedule", newJBool(DisassociateSchedule))
  add(query_608989, "Version", newJString(Version))
  result = call_608988.call(nil, query_608989, nil, formData_608990, nil)

var postModifyClusterSnapshotSchedule* = Call_PostModifyClusterSnapshotSchedule_608972(
    name: "postModifyClusterSnapshotSchedule", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=ModifyClusterSnapshotSchedule",
    validator: validate_PostModifyClusterSnapshotSchedule_608973, base: "/",
    url: url_PostModifyClusterSnapshotSchedule_608974,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetModifyClusterSnapshotSchedule_608954 = ref object of OpenApiRestCall_605573
proc url_GetModifyClusterSnapshotSchedule_608956(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetModifyClusterSnapshotSchedule_608955(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies a snapshot schedule for a cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ScheduleIdentifier: JString
  ##                     : A unique alphanumeric identifier for the schedule that you want to associate with the cluster.
  ##   Action: JString (required)
  ##   DisassociateSchedule: JBool
  ##                       : A boolean to indicate whether to remove the assoiciation between the cluster and the schedule.
  ##   ClusterIdentifier: JString (required)
  ##                    : A unique identifier for the cluster whose snapshot schedule you want to modify. 
  ##   Version: JString (required)
  section = newJObject()
  var valid_608957 = query.getOrDefault("ScheduleIdentifier")
  valid_608957 = validateParameter(valid_608957, JString, required = false,
                                 default = nil)
  if valid_608957 != nil:
    section.add "ScheduleIdentifier", valid_608957
  var valid_608958 = query.getOrDefault("Action")
  valid_608958 = validateParameter(valid_608958, JString, required = true, default = newJString(
      "ModifyClusterSnapshotSchedule"))
  if valid_608958 != nil:
    section.add "Action", valid_608958
  var valid_608959 = query.getOrDefault("DisassociateSchedule")
  valid_608959 = validateParameter(valid_608959, JBool, required = false, default = nil)
  if valid_608959 != nil:
    section.add "DisassociateSchedule", valid_608959
  var valid_608960 = query.getOrDefault("ClusterIdentifier")
  valid_608960 = validateParameter(valid_608960, JString, required = true,
                                 default = nil)
  if valid_608960 != nil:
    section.add "ClusterIdentifier", valid_608960
  var valid_608961 = query.getOrDefault("Version")
  valid_608961 = validateParameter(valid_608961, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_608961 != nil:
    section.add "Version", valid_608961
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_608962 = header.getOrDefault("X-Amz-Signature")
  valid_608962 = validateParameter(valid_608962, JString, required = false,
                                 default = nil)
  if valid_608962 != nil:
    section.add "X-Amz-Signature", valid_608962
  var valid_608963 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_608963 = validateParameter(valid_608963, JString, required = false,
                                 default = nil)
  if valid_608963 != nil:
    section.add "X-Amz-Content-Sha256", valid_608963
  var valid_608964 = header.getOrDefault("X-Amz-Date")
  valid_608964 = validateParameter(valid_608964, JString, required = false,
                                 default = nil)
  if valid_608964 != nil:
    section.add "X-Amz-Date", valid_608964
  var valid_608965 = header.getOrDefault("X-Amz-Credential")
  valid_608965 = validateParameter(valid_608965, JString, required = false,
                                 default = nil)
  if valid_608965 != nil:
    section.add "X-Amz-Credential", valid_608965
  var valid_608966 = header.getOrDefault("X-Amz-Security-Token")
  valid_608966 = validateParameter(valid_608966, JString, required = false,
                                 default = nil)
  if valid_608966 != nil:
    section.add "X-Amz-Security-Token", valid_608966
  var valid_608967 = header.getOrDefault("X-Amz-Algorithm")
  valid_608967 = validateParameter(valid_608967, JString, required = false,
                                 default = nil)
  if valid_608967 != nil:
    section.add "X-Amz-Algorithm", valid_608967
  var valid_608968 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_608968 = validateParameter(valid_608968, JString, required = false,
                                 default = nil)
  if valid_608968 != nil:
    section.add "X-Amz-SignedHeaders", valid_608968
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_608969: Call_GetModifyClusterSnapshotSchedule_608954;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Modifies a snapshot schedule for a cluster.
  ## 
  let valid = call_608969.validator(path, query, header, formData, body)
  let scheme = call_608969.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_608969.url(scheme.get, call_608969.host, call_608969.base,
                         call_608969.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_608969, url, valid)

proc call*(call_608970: Call_GetModifyClusterSnapshotSchedule_608954;
          ClusterIdentifier: string; ScheduleIdentifier: string = "";
          Action: string = "ModifyClusterSnapshotSchedule";
          DisassociateSchedule: bool = false; Version: string = "2012-12-01"): Recallable =
  ## getModifyClusterSnapshotSchedule
  ## Modifies a snapshot schedule for a cluster.
  ##   ScheduleIdentifier: string
  ##                     : A unique alphanumeric identifier for the schedule that you want to associate with the cluster.
  ##   Action: string (required)
  ##   DisassociateSchedule: bool
  ##                       : A boolean to indicate whether to remove the assoiciation between the cluster and the schedule.
  ##   ClusterIdentifier: string (required)
  ##                    : A unique identifier for the cluster whose snapshot schedule you want to modify. 
  ##   Version: string (required)
  var query_608971 = newJObject()
  add(query_608971, "ScheduleIdentifier", newJString(ScheduleIdentifier))
  add(query_608971, "Action", newJString(Action))
  add(query_608971, "DisassociateSchedule", newJBool(DisassociateSchedule))
  add(query_608971, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_608971, "Version", newJString(Version))
  result = call_608970.call(nil, query_608971, nil, nil, nil)

var getModifyClusterSnapshotSchedule* = Call_GetModifyClusterSnapshotSchedule_608954(
    name: "getModifyClusterSnapshotSchedule", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=ModifyClusterSnapshotSchedule",
    validator: validate_GetModifyClusterSnapshotSchedule_608955, base: "/",
    url: url_GetModifyClusterSnapshotSchedule_608956,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostModifyClusterSubnetGroup_609009 = ref object of OpenApiRestCall_605573
proc url_PostModifyClusterSubnetGroup_609011(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostModifyClusterSubnetGroup_609010(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies a cluster subnet group to include the specified list of VPC subnets. The operation replaces the existing list of subnets with the new list of subnets.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_609012 = query.getOrDefault("Action")
  valid_609012 = validateParameter(valid_609012, JString, required = true, default = newJString(
      "ModifyClusterSubnetGroup"))
  if valid_609012 != nil:
    section.add "Action", valid_609012
  var valid_609013 = query.getOrDefault("Version")
  valid_609013 = validateParameter(valid_609013, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_609013 != nil:
    section.add "Version", valid_609013
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_609014 = header.getOrDefault("X-Amz-Signature")
  valid_609014 = validateParameter(valid_609014, JString, required = false,
                                 default = nil)
  if valid_609014 != nil:
    section.add "X-Amz-Signature", valid_609014
  var valid_609015 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_609015 = validateParameter(valid_609015, JString, required = false,
                                 default = nil)
  if valid_609015 != nil:
    section.add "X-Amz-Content-Sha256", valid_609015
  var valid_609016 = header.getOrDefault("X-Amz-Date")
  valid_609016 = validateParameter(valid_609016, JString, required = false,
                                 default = nil)
  if valid_609016 != nil:
    section.add "X-Amz-Date", valid_609016
  var valid_609017 = header.getOrDefault("X-Amz-Credential")
  valid_609017 = validateParameter(valid_609017, JString, required = false,
                                 default = nil)
  if valid_609017 != nil:
    section.add "X-Amz-Credential", valid_609017
  var valid_609018 = header.getOrDefault("X-Amz-Security-Token")
  valid_609018 = validateParameter(valid_609018, JString, required = false,
                                 default = nil)
  if valid_609018 != nil:
    section.add "X-Amz-Security-Token", valid_609018
  var valid_609019 = header.getOrDefault("X-Amz-Algorithm")
  valid_609019 = validateParameter(valid_609019, JString, required = false,
                                 default = nil)
  if valid_609019 != nil:
    section.add "X-Amz-Algorithm", valid_609019
  var valid_609020 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_609020 = validateParameter(valid_609020, JString, required = false,
                                 default = nil)
  if valid_609020 != nil:
    section.add "X-Amz-SignedHeaders", valid_609020
  result.add "header", section
  ## parameters in `formData` object:
  ##   Description: JString
  ##              : A text description of the subnet group to be modified.
  ##   ClusterSubnetGroupName: JString (required)
  ##                         : The name of the subnet group to be modified.
  ##   SubnetIds: JArray (required)
  ##            : An array of VPC subnet IDs. A maximum of 20 subnets can be modified in a single request.
  section = newJObject()
  var valid_609021 = formData.getOrDefault("Description")
  valid_609021 = validateParameter(valid_609021, JString, required = false,
                                 default = nil)
  if valid_609021 != nil:
    section.add "Description", valid_609021
  assert formData != nil, "formData argument is necessary due to required `ClusterSubnetGroupName` field"
  var valid_609022 = formData.getOrDefault("ClusterSubnetGroupName")
  valid_609022 = validateParameter(valid_609022, JString, required = true,
                                 default = nil)
  if valid_609022 != nil:
    section.add "ClusterSubnetGroupName", valid_609022
  var valid_609023 = formData.getOrDefault("SubnetIds")
  valid_609023 = validateParameter(valid_609023, JArray, required = true, default = nil)
  if valid_609023 != nil:
    section.add "SubnetIds", valid_609023
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_609024: Call_PostModifyClusterSubnetGroup_609009; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Modifies a cluster subnet group to include the specified list of VPC subnets. The operation replaces the existing list of subnets with the new list of subnets.
  ## 
  let valid = call_609024.validator(path, query, header, formData, body)
  let scheme = call_609024.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_609024.url(scheme.get, call_609024.host, call_609024.base,
                         call_609024.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_609024, url, valid)

proc call*(call_609025: Call_PostModifyClusterSubnetGroup_609009;
          ClusterSubnetGroupName: string; SubnetIds: JsonNode;
          Description: string = ""; Action: string = "ModifyClusterSubnetGroup";
          Version: string = "2012-12-01"): Recallable =
  ## postModifyClusterSubnetGroup
  ## Modifies a cluster subnet group to include the specified list of VPC subnets. The operation replaces the existing list of subnets with the new list of subnets.
  ##   Description: string
  ##              : A text description of the subnet group to be modified.
  ##   ClusterSubnetGroupName: string (required)
  ##                         : The name of the subnet group to be modified.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   SubnetIds: JArray (required)
  ##            : An array of VPC subnet IDs. A maximum of 20 subnets can be modified in a single request.
  var query_609026 = newJObject()
  var formData_609027 = newJObject()
  add(formData_609027, "Description", newJString(Description))
  add(formData_609027, "ClusterSubnetGroupName",
      newJString(ClusterSubnetGroupName))
  add(query_609026, "Action", newJString(Action))
  add(query_609026, "Version", newJString(Version))
  if SubnetIds != nil:
    formData_609027.add "SubnetIds", SubnetIds
  result = call_609025.call(nil, query_609026, nil, formData_609027, nil)

var postModifyClusterSubnetGroup* = Call_PostModifyClusterSubnetGroup_609009(
    name: "postModifyClusterSubnetGroup", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyClusterSubnetGroup",
    validator: validate_PostModifyClusterSubnetGroup_609010, base: "/",
    url: url_PostModifyClusterSubnetGroup_609011,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetModifyClusterSubnetGroup_608991 = ref object of OpenApiRestCall_605573
proc url_GetModifyClusterSubnetGroup_608993(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetModifyClusterSubnetGroup_608992(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies a cluster subnet group to include the specified list of VPC subnets. The operation replaces the existing list of subnets with the new list of subnets.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ClusterSubnetGroupName: JString (required)
  ##                         : The name of the subnet group to be modified.
  ##   SubnetIds: JArray (required)
  ##            : An array of VPC subnet IDs. A maximum of 20 subnets can be modified in a single request.
  ##   Action: JString (required)
  ##   Description: JString
  ##              : A text description of the subnet group to be modified.
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `ClusterSubnetGroupName` field"
  var valid_608994 = query.getOrDefault("ClusterSubnetGroupName")
  valid_608994 = validateParameter(valid_608994, JString, required = true,
                                 default = nil)
  if valid_608994 != nil:
    section.add "ClusterSubnetGroupName", valid_608994
  var valid_608995 = query.getOrDefault("SubnetIds")
  valid_608995 = validateParameter(valid_608995, JArray, required = true, default = nil)
  if valid_608995 != nil:
    section.add "SubnetIds", valid_608995
  var valid_608996 = query.getOrDefault("Action")
  valid_608996 = validateParameter(valid_608996, JString, required = true, default = newJString(
      "ModifyClusterSubnetGroup"))
  if valid_608996 != nil:
    section.add "Action", valid_608996
  var valid_608997 = query.getOrDefault("Description")
  valid_608997 = validateParameter(valid_608997, JString, required = false,
                                 default = nil)
  if valid_608997 != nil:
    section.add "Description", valid_608997
  var valid_608998 = query.getOrDefault("Version")
  valid_608998 = validateParameter(valid_608998, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_608998 != nil:
    section.add "Version", valid_608998
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_608999 = header.getOrDefault("X-Amz-Signature")
  valid_608999 = validateParameter(valid_608999, JString, required = false,
                                 default = nil)
  if valid_608999 != nil:
    section.add "X-Amz-Signature", valid_608999
  var valid_609000 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_609000 = validateParameter(valid_609000, JString, required = false,
                                 default = nil)
  if valid_609000 != nil:
    section.add "X-Amz-Content-Sha256", valid_609000
  var valid_609001 = header.getOrDefault("X-Amz-Date")
  valid_609001 = validateParameter(valid_609001, JString, required = false,
                                 default = nil)
  if valid_609001 != nil:
    section.add "X-Amz-Date", valid_609001
  var valid_609002 = header.getOrDefault("X-Amz-Credential")
  valid_609002 = validateParameter(valid_609002, JString, required = false,
                                 default = nil)
  if valid_609002 != nil:
    section.add "X-Amz-Credential", valid_609002
  var valid_609003 = header.getOrDefault("X-Amz-Security-Token")
  valid_609003 = validateParameter(valid_609003, JString, required = false,
                                 default = nil)
  if valid_609003 != nil:
    section.add "X-Amz-Security-Token", valid_609003
  var valid_609004 = header.getOrDefault("X-Amz-Algorithm")
  valid_609004 = validateParameter(valid_609004, JString, required = false,
                                 default = nil)
  if valid_609004 != nil:
    section.add "X-Amz-Algorithm", valid_609004
  var valid_609005 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_609005 = validateParameter(valid_609005, JString, required = false,
                                 default = nil)
  if valid_609005 != nil:
    section.add "X-Amz-SignedHeaders", valid_609005
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_609006: Call_GetModifyClusterSubnetGroup_608991; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Modifies a cluster subnet group to include the specified list of VPC subnets. The operation replaces the existing list of subnets with the new list of subnets.
  ## 
  let valid = call_609006.validator(path, query, header, formData, body)
  let scheme = call_609006.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_609006.url(scheme.get, call_609006.host, call_609006.base,
                         call_609006.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_609006, url, valid)

proc call*(call_609007: Call_GetModifyClusterSubnetGroup_608991;
          ClusterSubnetGroupName: string; SubnetIds: JsonNode;
          Action: string = "ModifyClusterSubnetGroup"; Description: string = "";
          Version: string = "2012-12-01"): Recallable =
  ## getModifyClusterSubnetGroup
  ## Modifies a cluster subnet group to include the specified list of VPC subnets. The operation replaces the existing list of subnets with the new list of subnets.
  ##   ClusterSubnetGroupName: string (required)
  ##                         : The name of the subnet group to be modified.
  ##   SubnetIds: JArray (required)
  ##            : An array of VPC subnet IDs. A maximum of 20 subnets can be modified in a single request.
  ##   Action: string (required)
  ##   Description: string
  ##              : A text description of the subnet group to be modified.
  ##   Version: string (required)
  var query_609008 = newJObject()
  add(query_609008, "ClusterSubnetGroupName", newJString(ClusterSubnetGroupName))
  if SubnetIds != nil:
    query_609008.add "SubnetIds", SubnetIds
  add(query_609008, "Action", newJString(Action))
  add(query_609008, "Description", newJString(Description))
  add(query_609008, "Version", newJString(Version))
  result = call_609007.call(nil, query_609008, nil, nil, nil)

var getModifyClusterSubnetGroup* = Call_GetModifyClusterSubnetGroup_608991(
    name: "getModifyClusterSubnetGroup", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyClusterSubnetGroup",
    validator: validate_GetModifyClusterSubnetGroup_608992, base: "/",
    url: url_GetModifyClusterSubnetGroup_608993,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostModifyEventSubscription_609050 = ref object of OpenApiRestCall_605573
proc url_PostModifyEventSubscription_609052(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostModifyEventSubscription_609051(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies an existing Amazon Redshift event notification subscription.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_609053 = query.getOrDefault("Action")
  valid_609053 = validateParameter(valid_609053, JString, required = true, default = newJString(
      "ModifyEventSubscription"))
  if valid_609053 != nil:
    section.add "Action", valid_609053
  var valid_609054 = query.getOrDefault("Version")
  valid_609054 = validateParameter(valid_609054, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_609054 != nil:
    section.add "Version", valid_609054
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_609055 = header.getOrDefault("X-Amz-Signature")
  valid_609055 = validateParameter(valid_609055, JString, required = false,
                                 default = nil)
  if valid_609055 != nil:
    section.add "X-Amz-Signature", valid_609055
  var valid_609056 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_609056 = validateParameter(valid_609056, JString, required = false,
                                 default = nil)
  if valid_609056 != nil:
    section.add "X-Amz-Content-Sha256", valid_609056
  var valid_609057 = header.getOrDefault("X-Amz-Date")
  valid_609057 = validateParameter(valid_609057, JString, required = false,
                                 default = nil)
  if valid_609057 != nil:
    section.add "X-Amz-Date", valid_609057
  var valid_609058 = header.getOrDefault("X-Amz-Credential")
  valid_609058 = validateParameter(valid_609058, JString, required = false,
                                 default = nil)
  if valid_609058 != nil:
    section.add "X-Amz-Credential", valid_609058
  var valid_609059 = header.getOrDefault("X-Amz-Security-Token")
  valid_609059 = validateParameter(valid_609059, JString, required = false,
                                 default = nil)
  if valid_609059 != nil:
    section.add "X-Amz-Security-Token", valid_609059
  var valid_609060 = header.getOrDefault("X-Amz-Algorithm")
  valid_609060 = validateParameter(valid_609060, JString, required = false,
                                 default = nil)
  if valid_609060 != nil:
    section.add "X-Amz-Algorithm", valid_609060
  var valid_609061 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_609061 = validateParameter(valid_609061, JString, required = false,
                                 default = nil)
  if valid_609061 != nil:
    section.add "X-Amz-SignedHeaders", valid_609061
  result.add "header", section
  ## parameters in `formData` object:
  ##   SourceIds: JArray
  ##            : <p>A list of one or more identifiers of Amazon Redshift source objects. All of the objects must be of the same type as was specified in the source type parameter. The event subscription will return only events generated by the specified objects. If not specified, then events are returned for all objects within the source type specified.</p> <p>Example: my-cluster-1, my-cluster-2</p> <p>Example: my-snapshot-20131010</p>
  ##   SnsTopicArn: JString
  ##              : The Amazon Resource Name (ARN) of the SNS topic to be used by the event notification subscription.
  ##   Enabled: JBool
  ##          : A Boolean value indicating if the subscription is enabled. <code>true</code> indicates the subscription is enabled 
  ##   SubscriptionName: JString (required)
  ##                   : The name of the modified Amazon Redshift event notification subscription.
  ##   SourceType: JString
  ##             : <p>The type of source that will be generating the events. For example, if you want to be notified of events generated by a cluster, you would set this parameter to cluster. If this value is not specified, events are returned for all Amazon Redshift objects in your AWS account. You must specify a source type in order to specify source IDs.</p> <p>Valid values: cluster, cluster-parameter-group, cluster-security-group, cluster-snapshot, and scheduled-action.</p>
  ##   Severity: JString
  ##           : <p>Specifies the Amazon Redshift event severity to be published by the event notification subscription.</p> <p>Values: ERROR, INFO</p>
  ##   EventCategories: JArray
  ##                  : <p>Specifies the Amazon Redshift event categories to be published by the event notification subscription.</p> <p>Values: configuration, management, monitoring, security</p>
  section = newJObject()
  var valid_609062 = formData.getOrDefault("SourceIds")
  valid_609062 = validateParameter(valid_609062, JArray, required = false,
                                 default = nil)
  if valid_609062 != nil:
    section.add "SourceIds", valid_609062
  var valid_609063 = formData.getOrDefault("SnsTopicArn")
  valid_609063 = validateParameter(valid_609063, JString, required = false,
                                 default = nil)
  if valid_609063 != nil:
    section.add "SnsTopicArn", valid_609063
  var valid_609064 = formData.getOrDefault("Enabled")
  valid_609064 = validateParameter(valid_609064, JBool, required = false, default = nil)
  if valid_609064 != nil:
    section.add "Enabled", valid_609064
  assert formData != nil, "formData argument is necessary due to required `SubscriptionName` field"
  var valid_609065 = formData.getOrDefault("SubscriptionName")
  valid_609065 = validateParameter(valid_609065, JString, required = true,
                                 default = nil)
  if valid_609065 != nil:
    section.add "SubscriptionName", valid_609065
  var valid_609066 = formData.getOrDefault("SourceType")
  valid_609066 = validateParameter(valid_609066, JString, required = false,
                                 default = nil)
  if valid_609066 != nil:
    section.add "SourceType", valid_609066
  var valid_609067 = formData.getOrDefault("Severity")
  valid_609067 = validateParameter(valid_609067, JString, required = false,
                                 default = nil)
  if valid_609067 != nil:
    section.add "Severity", valid_609067
  var valid_609068 = formData.getOrDefault("EventCategories")
  valid_609068 = validateParameter(valid_609068, JArray, required = false,
                                 default = nil)
  if valid_609068 != nil:
    section.add "EventCategories", valid_609068
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_609069: Call_PostModifyEventSubscription_609050; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Modifies an existing Amazon Redshift event notification subscription.
  ## 
  let valid = call_609069.validator(path, query, header, formData, body)
  let scheme = call_609069.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_609069.url(scheme.get, call_609069.host, call_609069.base,
                         call_609069.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_609069, url, valid)

proc call*(call_609070: Call_PostModifyEventSubscription_609050;
          SubscriptionName: string; SourceIds: JsonNode = nil;
          SnsTopicArn: string = ""; Enabled: bool = false; SourceType: string = "";
          Severity: string = ""; EventCategories: JsonNode = nil;
          Action: string = "ModifyEventSubscription"; Version: string = "2012-12-01"): Recallable =
  ## postModifyEventSubscription
  ## Modifies an existing Amazon Redshift event notification subscription.
  ##   SourceIds: JArray
  ##            : <p>A list of one or more identifiers of Amazon Redshift source objects. All of the objects must be of the same type as was specified in the source type parameter. The event subscription will return only events generated by the specified objects. If not specified, then events are returned for all objects within the source type specified.</p> <p>Example: my-cluster-1, my-cluster-2</p> <p>Example: my-snapshot-20131010</p>
  ##   SnsTopicArn: string
  ##              : The Amazon Resource Name (ARN) of the SNS topic to be used by the event notification subscription.
  ##   Enabled: bool
  ##          : A Boolean value indicating if the subscription is enabled. <code>true</code> indicates the subscription is enabled 
  ##   SubscriptionName: string (required)
  ##                   : The name of the modified Amazon Redshift event notification subscription.
  ##   SourceType: string
  ##             : <p>The type of source that will be generating the events. For example, if you want to be notified of events generated by a cluster, you would set this parameter to cluster. If this value is not specified, events are returned for all Amazon Redshift objects in your AWS account. You must specify a source type in order to specify source IDs.</p> <p>Valid values: cluster, cluster-parameter-group, cluster-security-group, cluster-snapshot, and scheduled-action.</p>
  ##   Severity: string
  ##           : <p>Specifies the Amazon Redshift event severity to be published by the event notification subscription.</p> <p>Values: ERROR, INFO</p>
  ##   EventCategories: JArray
  ##                  : <p>Specifies the Amazon Redshift event categories to be published by the event notification subscription.</p> <p>Values: configuration, management, monitoring, security</p>
  ##   Action: string (required)
  ##   Version: string (required)
  var query_609071 = newJObject()
  var formData_609072 = newJObject()
  if SourceIds != nil:
    formData_609072.add "SourceIds", SourceIds
  add(formData_609072, "SnsTopicArn", newJString(SnsTopicArn))
  add(formData_609072, "Enabled", newJBool(Enabled))
  add(formData_609072, "SubscriptionName", newJString(SubscriptionName))
  add(formData_609072, "SourceType", newJString(SourceType))
  add(formData_609072, "Severity", newJString(Severity))
  if EventCategories != nil:
    formData_609072.add "EventCategories", EventCategories
  add(query_609071, "Action", newJString(Action))
  add(query_609071, "Version", newJString(Version))
  result = call_609070.call(nil, query_609071, nil, formData_609072, nil)

var postModifyEventSubscription* = Call_PostModifyEventSubscription_609050(
    name: "postModifyEventSubscription", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyEventSubscription",
    validator: validate_PostModifyEventSubscription_609051, base: "/",
    url: url_PostModifyEventSubscription_609052,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetModifyEventSubscription_609028 = ref object of OpenApiRestCall_605573
proc url_GetModifyEventSubscription_609030(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetModifyEventSubscription_609029(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies an existing Amazon Redshift event notification subscription.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   SourceType: JString
  ##             : <p>The type of source that will be generating the events. For example, if you want to be notified of events generated by a cluster, you would set this parameter to cluster. If this value is not specified, events are returned for all Amazon Redshift objects in your AWS account. You must specify a source type in order to specify source IDs.</p> <p>Valid values: cluster, cluster-parameter-group, cluster-security-group, cluster-snapshot, and scheduled-action.</p>
  ##   Enabled: JBool
  ##          : A Boolean value indicating if the subscription is enabled. <code>true</code> indicates the subscription is enabled 
  ##   Severity: JString
  ##           : <p>Specifies the Amazon Redshift event severity to be published by the event notification subscription.</p> <p>Values: ERROR, INFO</p>
  ##   SubscriptionName: JString (required)
  ##                   : The name of the modified Amazon Redshift event notification subscription.
  ##   EventCategories: JArray
  ##                  : <p>Specifies the Amazon Redshift event categories to be published by the event notification subscription.</p> <p>Values: configuration, management, monitoring, security</p>
  ##   SourceIds: JArray
  ##            : <p>A list of one or more identifiers of Amazon Redshift source objects. All of the objects must be of the same type as was specified in the source type parameter. The event subscription will return only events generated by the specified objects. If not specified, then events are returned for all objects within the source type specified.</p> <p>Example: my-cluster-1, my-cluster-2</p> <p>Example: my-snapshot-20131010</p>
  ##   Action: JString (required)
  ##   SnsTopicArn: JString
  ##              : The Amazon Resource Name (ARN) of the SNS topic to be used by the event notification subscription.
  ##   Version: JString (required)
  section = newJObject()
  var valid_609031 = query.getOrDefault("SourceType")
  valid_609031 = validateParameter(valid_609031, JString, required = false,
                                 default = nil)
  if valid_609031 != nil:
    section.add "SourceType", valid_609031
  var valid_609032 = query.getOrDefault("Enabled")
  valid_609032 = validateParameter(valid_609032, JBool, required = false, default = nil)
  if valid_609032 != nil:
    section.add "Enabled", valid_609032
  var valid_609033 = query.getOrDefault("Severity")
  valid_609033 = validateParameter(valid_609033, JString, required = false,
                                 default = nil)
  if valid_609033 != nil:
    section.add "Severity", valid_609033
  assert query != nil,
        "query argument is necessary due to required `SubscriptionName` field"
  var valid_609034 = query.getOrDefault("SubscriptionName")
  valid_609034 = validateParameter(valid_609034, JString, required = true,
                                 default = nil)
  if valid_609034 != nil:
    section.add "SubscriptionName", valid_609034
  var valid_609035 = query.getOrDefault("EventCategories")
  valid_609035 = validateParameter(valid_609035, JArray, required = false,
                                 default = nil)
  if valid_609035 != nil:
    section.add "EventCategories", valid_609035
  var valid_609036 = query.getOrDefault("SourceIds")
  valid_609036 = validateParameter(valid_609036, JArray, required = false,
                                 default = nil)
  if valid_609036 != nil:
    section.add "SourceIds", valid_609036
  var valid_609037 = query.getOrDefault("Action")
  valid_609037 = validateParameter(valid_609037, JString, required = true, default = newJString(
      "ModifyEventSubscription"))
  if valid_609037 != nil:
    section.add "Action", valid_609037
  var valid_609038 = query.getOrDefault("SnsTopicArn")
  valid_609038 = validateParameter(valid_609038, JString, required = false,
                                 default = nil)
  if valid_609038 != nil:
    section.add "SnsTopicArn", valid_609038
  var valid_609039 = query.getOrDefault("Version")
  valid_609039 = validateParameter(valid_609039, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_609039 != nil:
    section.add "Version", valid_609039
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_609040 = header.getOrDefault("X-Amz-Signature")
  valid_609040 = validateParameter(valid_609040, JString, required = false,
                                 default = nil)
  if valid_609040 != nil:
    section.add "X-Amz-Signature", valid_609040
  var valid_609041 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_609041 = validateParameter(valid_609041, JString, required = false,
                                 default = nil)
  if valid_609041 != nil:
    section.add "X-Amz-Content-Sha256", valid_609041
  var valid_609042 = header.getOrDefault("X-Amz-Date")
  valid_609042 = validateParameter(valid_609042, JString, required = false,
                                 default = nil)
  if valid_609042 != nil:
    section.add "X-Amz-Date", valid_609042
  var valid_609043 = header.getOrDefault("X-Amz-Credential")
  valid_609043 = validateParameter(valid_609043, JString, required = false,
                                 default = nil)
  if valid_609043 != nil:
    section.add "X-Amz-Credential", valid_609043
  var valid_609044 = header.getOrDefault("X-Amz-Security-Token")
  valid_609044 = validateParameter(valid_609044, JString, required = false,
                                 default = nil)
  if valid_609044 != nil:
    section.add "X-Amz-Security-Token", valid_609044
  var valid_609045 = header.getOrDefault("X-Amz-Algorithm")
  valid_609045 = validateParameter(valid_609045, JString, required = false,
                                 default = nil)
  if valid_609045 != nil:
    section.add "X-Amz-Algorithm", valid_609045
  var valid_609046 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_609046 = validateParameter(valid_609046, JString, required = false,
                                 default = nil)
  if valid_609046 != nil:
    section.add "X-Amz-SignedHeaders", valid_609046
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_609047: Call_GetModifyEventSubscription_609028; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Modifies an existing Amazon Redshift event notification subscription.
  ## 
  let valid = call_609047.validator(path, query, header, formData, body)
  let scheme = call_609047.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_609047.url(scheme.get, call_609047.host, call_609047.base,
                         call_609047.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_609047, url, valid)

proc call*(call_609048: Call_GetModifyEventSubscription_609028;
          SubscriptionName: string; SourceType: string = ""; Enabled: bool = false;
          Severity: string = ""; EventCategories: JsonNode = nil;
          SourceIds: JsonNode = nil; Action: string = "ModifyEventSubscription";
          SnsTopicArn: string = ""; Version: string = "2012-12-01"): Recallable =
  ## getModifyEventSubscription
  ## Modifies an existing Amazon Redshift event notification subscription.
  ##   SourceType: string
  ##             : <p>The type of source that will be generating the events. For example, if you want to be notified of events generated by a cluster, you would set this parameter to cluster. If this value is not specified, events are returned for all Amazon Redshift objects in your AWS account. You must specify a source type in order to specify source IDs.</p> <p>Valid values: cluster, cluster-parameter-group, cluster-security-group, cluster-snapshot, and scheduled-action.</p>
  ##   Enabled: bool
  ##          : A Boolean value indicating if the subscription is enabled. <code>true</code> indicates the subscription is enabled 
  ##   Severity: string
  ##           : <p>Specifies the Amazon Redshift event severity to be published by the event notification subscription.</p> <p>Values: ERROR, INFO</p>
  ##   SubscriptionName: string (required)
  ##                   : The name of the modified Amazon Redshift event notification subscription.
  ##   EventCategories: JArray
  ##                  : <p>Specifies the Amazon Redshift event categories to be published by the event notification subscription.</p> <p>Values: configuration, management, monitoring, security</p>
  ##   SourceIds: JArray
  ##            : <p>A list of one or more identifiers of Amazon Redshift source objects. All of the objects must be of the same type as was specified in the source type parameter. The event subscription will return only events generated by the specified objects. If not specified, then events are returned for all objects within the source type specified.</p> <p>Example: my-cluster-1, my-cluster-2</p> <p>Example: my-snapshot-20131010</p>
  ##   Action: string (required)
  ##   SnsTopicArn: string
  ##              : The Amazon Resource Name (ARN) of the SNS topic to be used by the event notification subscription.
  ##   Version: string (required)
  var query_609049 = newJObject()
  add(query_609049, "SourceType", newJString(SourceType))
  add(query_609049, "Enabled", newJBool(Enabled))
  add(query_609049, "Severity", newJString(Severity))
  add(query_609049, "SubscriptionName", newJString(SubscriptionName))
  if EventCategories != nil:
    query_609049.add "EventCategories", EventCategories
  if SourceIds != nil:
    query_609049.add "SourceIds", SourceIds
  add(query_609049, "Action", newJString(Action))
  add(query_609049, "SnsTopicArn", newJString(SnsTopicArn))
  add(query_609049, "Version", newJString(Version))
  result = call_609048.call(nil, query_609049, nil, nil, nil)

var getModifyEventSubscription* = Call_GetModifyEventSubscription_609028(
    name: "getModifyEventSubscription", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyEventSubscription",
    validator: validate_GetModifyEventSubscription_609029, base: "/",
    url: url_GetModifyEventSubscription_609030,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostModifyScheduledAction_609096 = ref object of OpenApiRestCall_605573
proc url_PostModifyScheduledAction_609098(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostModifyScheduledAction_609097(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies a scheduled action. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_609099 = query.getOrDefault("Action")
  valid_609099 = validateParameter(valid_609099, JString, required = true,
                                 default = newJString("ModifyScheduledAction"))
  if valid_609099 != nil:
    section.add "Action", valid_609099
  var valid_609100 = query.getOrDefault("Version")
  valid_609100 = validateParameter(valid_609100, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_609100 != nil:
    section.add "Version", valid_609100
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_609101 = header.getOrDefault("X-Amz-Signature")
  valid_609101 = validateParameter(valid_609101, JString, required = false,
                                 default = nil)
  if valid_609101 != nil:
    section.add "X-Amz-Signature", valid_609101
  var valid_609102 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_609102 = validateParameter(valid_609102, JString, required = false,
                                 default = nil)
  if valid_609102 != nil:
    section.add "X-Amz-Content-Sha256", valid_609102
  var valid_609103 = header.getOrDefault("X-Amz-Date")
  valid_609103 = validateParameter(valid_609103, JString, required = false,
                                 default = nil)
  if valid_609103 != nil:
    section.add "X-Amz-Date", valid_609103
  var valid_609104 = header.getOrDefault("X-Amz-Credential")
  valid_609104 = validateParameter(valid_609104, JString, required = false,
                                 default = nil)
  if valid_609104 != nil:
    section.add "X-Amz-Credential", valid_609104
  var valid_609105 = header.getOrDefault("X-Amz-Security-Token")
  valid_609105 = validateParameter(valid_609105, JString, required = false,
                                 default = nil)
  if valid_609105 != nil:
    section.add "X-Amz-Security-Token", valid_609105
  var valid_609106 = header.getOrDefault("X-Amz-Algorithm")
  valid_609106 = validateParameter(valid_609106, JString, required = false,
                                 default = nil)
  if valid_609106 != nil:
    section.add "X-Amz-Algorithm", valid_609106
  var valid_609107 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_609107 = validateParameter(valid_609107, JString, required = false,
                                 default = nil)
  if valid_609107 != nil:
    section.add "X-Amz-SignedHeaders", valid_609107
  result.add "header", section
  ## parameters in `formData` object:
  ##   Enable: JBool
  ##         : A modified enable flag of the scheduled action. If true, the scheduled action is active. If false, the scheduled action is disabled. 
  ##   TargetAction.ResizeCluster: JString
  ##                             : The action type that specifies an Amazon Redshift API operation that is supported by the Amazon Redshift scheduler. 
  ## An action that runs a <code>ResizeCluster</code> API operation. 
  ##   ScheduledActionName: JString (required)
  ##                      : The name of the scheduled action to modify. 
  ##   ScheduledActionDescription: JString
  ##                             : A modified description of the scheduled action. 
  ##   Schedule: JString
  ##           : A modified schedule in either <code>at( )</code> or <code>cron( )</code> format. For more information about this parameter, see <a>ScheduledAction</a>.
  ##   EndTime: JString
  ##          : A modified end time of the scheduled action. For more information about this parameter, see <a>ScheduledAction</a>. 
  ##   StartTime: JString
  ##            : A modified start time of the scheduled action. For more information about this parameter, see <a>ScheduledAction</a>. 
  ##   IamRole: JString
  ##          : A different IAM role to assume to run the target action. For more information about this parameter, see <a>ScheduledAction</a>.
  section = newJObject()
  var valid_609108 = formData.getOrDefault("Enable")
  valid_609108 = validateParameter(valid_609108, JBool, required = false, default = nil)
  if valid_609108 != nil:
    section.add "Enable", valid_609108
  var valid_609109 = formData.getOrDefault("TargetAction.ResizeCluster")
  valid_609109 = validateParameter(valid_609109, JString, required = false,
                                 default = nil)
  if valid_609109 != nil:
    section.add "TargetAction.ResizeCluster", valid_609109
  assert formData != nil, "formData argument is necessary due to required `ScheduledActionName` field"
  var valid_609110 = formData.getOrDefault("ScheduledActionName")
  valid_609110 = validateParameter(valid_609110, JString, required = true,
                                 default = nil)
  if valid_609110 != nil:
    section.add "ScheduledActionName", valid_609110
  var valid_609111 = formData.getOrDefault("ScheduledActionDescription")
  valid_609111 = validateParameter(valid_609111, JString, required = false,
                                 default = nil)
  if valid_609111 != nil:
    section.add "ScheduledActionDescription", valid_609111
  var valid_609112 = formData.getOrDefault("Schedule")
  valid_609112 = validateParameter(valid_609112, JString, required = false,
                                 default = nil)
  if valid_609112 != nil:
    section.add "Schedule", valid_609112
  var valid_609113 = formData.getOrDefault("EndTime")
  valid_609113 = validateParameter(valid_609113, JString, required = false,
                                 default = nil)
  if valid_609113 != nil:
    section.add "EndTime", valid_609113
  var valid_609114 = formData.getOrDefault("StartTime")
  valid_609114 = validateParameter(valid_609114, JString, required = false,
                                 default = nil)
  if valid_609114 != nil:
    section.add "StartTime", valid_609114
  var valid_609115 = formData.getOrDefault("IamRole")
  valid_609115 = validateParameter(valid_609115, JString, required = false,
                                 default = nil)
  if valid_609115 != nil:
    section.add "IamRole", valid_609115
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_609116: Call_PostModifyScheduledAction_609096; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Modifies a scheduled action. 
  ## 
  let valid = call_609116.validator(path, query, header, formData, body)
  let scheme = call_609116.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_609116.url(scheme.get, call_609116.host, call_609116.base,
                         call_609116.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_609116, url, valid)

proc call*(call_609117: Call_PostModifyScheduledAction_609096;
          ScheduledActionName: string; Enable: bool = false;
          TargetActionResizeCluster: string = "";
          ScheduledActionDescription: string = ""; Schedule: string = "";
          EndTime: string = ""; StartTime: string = "";
          Action: string = "ModifyScheduledAction"; Version: string = "2012-12-01";
          IamRole: string = ""): Recallable =
  ## postModifyScheduledAction
  ## Modifies a scheduled action. 
  ##   Enable: bool
  ##         : A modified enable flag of the scheduled action. If true, the scheduled action is active. If false, the scheduled action is disabled. 
  ##   TargetActionResizeCluster: string
  ##                            : The action type that specifies an Amazon Redshift API operation that is supported by the Amazon Redshift scheduler. 
  ## An action that runs a <code>ResizeCluster</code> API operation. 
  ##   ScheduledActionName: string (required)
  ##                      : The name of the scheduled action to modify. 
  ##   ScheduledActionDescription: string
  ##                             : A modified description of the scheduled action. 
  ##   Schedule: string
  ##           : A modified schedule in either <code>at( )</code> or <code>cron( )</code> format. For more information about this parameter, see <a>ScheduledAction</a>.
  ##   EndTime: string
  ##          : A modified end time of the scheduled action. For more information about this parameter, see <a>ScheduledAction</a>. 
  ##   StartTime: string
  ##            : A modified start time of the scheduled action. For more information about this parameter, see <a>ScheduledAction</a>. 
  ##   Action: string (required)
  ##   Version: string (required)
  ##   IamRole: string
  ##          : A different IAM role to assume to run the target action. For more information about this parameter, see <a>ScheduledAction</a>.
  var query_609118 = newJObject()
  var formData_609119 = newJObject()
  add(formData_609119, "Enable", newJBool(Enable))
  add(formData_609119, "TargetAction.ResizeCluster",
      newJString(TargetActionResizeCluster))
  add(formData_609119, "ScheduledActionName", newJString(ScheduledActionName))
  add(formData_609119, "ScheduledActionDescription",
      newJString(ScheduledActionDescription))
  add(formData_609119, "Schedule", newJString(Schedule))
  add(formData_609119, "EndTime", newJString(EndTime))
  add(formData_609119, "StartTime", newJString(StartTime))
  add(query_609118, "Action", newJString(Action))
  add(query_609118, "Version", newJString(Version))
  add(formData_609119, "IamRole", newJString(IamRole))
  result = call_609117.call(nil, query_609118, nil, formData_609119, nil)

var postModifyScheduledAction* = Call_PostModifyScheduledAction_609096(
    name: "postModifyScheduledAction", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyScheduledAction",
    validator: validate_PostModifyScheduledAction_609097, base: "/",
    url: url_PostModifyScheduledAction_609098,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetModifyScheduledAction_609073 = ref object of OpenApiRestCall_605573
proc url_GetModifyScheduledAction_609075(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetModifyScheduledAction_609074(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies a scheduled action. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Schedule: JString
  ##           : A modified schedule in either <code>at( )</code> or <code>cron( )</code> format. For more information about this parameter, see <a>ScheduledAction</a>.
  ##   Enable: JBool
  ##         : A modified enable flag of the scheduled action. If true, the scheduled action is active. If false, the scheduled action is disabled. 
  ##   ScheduledActionName: JString (required)
  ##                      : The name of the scheduled action to modify. 
  ##   IamRole: JString
  ##          : A different IAM role to assume to run the target action. For more information about this parameter, see <a>ScheduledAction</a>.
  ##   TargetAction.ResizeCluster: JString
  ##                             : The action type that specifies an Amazon Redshift API operation that is supported by the Amazon Redshift scheduler. 
  ## An action that runs a <code>ResizeCluster</code> API operation. 
  ##   ScheduledActionDescription: JString
  ##                             : A modified description of the scheduled action. 
  ##   Action: JString (required)
  ##   StartTime: JString
  ##            : A modified start time of the scheduled action. For more information about this parameter, see <a>ScheduledAction</a>. 
  ##   EndTime: JString
  ##          : A modified end time of the scheduled action. For more information about this parameter, see <a>ScheduledAction</a>. 
  ##   Version: JString (required)
  section = newJObject()
  var valid_609076 = query.getOrDefault("Schedule")
  valid_609076 = validateParameter(valid_609076, JString, required = false,
                                 default = nil)
  if valid_609076 != nil:
    section.add "Schedule", valid_609076
  var valid_609077 = query.getOrDefault("Enable")
  valid_609077 = validateParameter(valid_609077, JBool, required = false, default = nil)
  if valid_609077 != nil:
    section.add "Enable", valid_609077
  assert query != nil, "query argument is necessary due to required `ScheduledActionName` field"
  var valid_609078 = query.getOrDefault("ScheduledActionName")
  valid_609078 = validateParameter(valid_609078, JString, required = true,
                                 default = nil)
  if valid_609078 != nil:
    section.add "ScheduledActionName", valid_609078
  var valid_609079 = query.getOrDefault("IamRole")
  valid_609079 = validateParameter(valid_609079, JString, required = false,
                                 default = nil)
  if valid_609079 != nil:
    section.add "IamRole", valid_609079
  var valid_609080 = query.getOrDefault("TargetAction.ResizeCluster")
  valid_609080 = validateParameter(valid_609080, JString, required = false,
                                 default = nil)
  if valid_609080 != nil:
    section.add "TargetAction.ResizeCluster", valid_609080
  var valid_609081 = query.getOrDefault("ScheduledActionDescription")
  valid_609081 = validateParameter(valid_609081, JString, required = false,
                                 default = nil)
  if valid_609081 != nil:
    section.add "ScheduledActionDescription", valid_609081
  var valid_609082 = query.getOrDefault("Action")
  valid_609082 = validateParameter(valid_609082, JString, required = true,
                                 default = newJString("ModifyScheduledAction"))
  if valid_609082 != nil:
    section.add "Action", valid_609082
  var valid_609083 = query.getOrDefault("StartTime")
  valid_609083 = validateParameter(valid_609083, JString, required = false,
                                 default = nil)
  if valid_609083 != nil:
    section.add "StartTime", valid_609083
  var valid_609084 = query.getOrDefault("EndTime")
  valid_609084 = validateParameter(valid_609084, JString, required = false,
                                 default = nil)
  if valid_609084 != nil:
    section.add "EndTime", valid_609084
  var valid_609085 = query.getOrDefault("Version")
  valid_609085 = validateParameter(valid_609085, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_609085 != nil:
    section.add "Version", valid_609085
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_609086 = header.getOrDefault("X-Amz-Signature")
  valid_609086 = validateParameter(valid_609086, JString, required = false,
                                 default = nil)
  if valid_609086 != nil:
    section.add "X-Amz-Signature", valid_609086
  var valid_609087 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_609087 = validateParameter(valid_609087, JString, required = false,
                                 default = nil)
  if valid_609087 != nil:
    section.add "X-Amz-Content-Sha256", valid_609087
  var valid_609088 = header.getOrDefault("X-Amz-Date")
  valid_609088 = validateParameter(valid_609088, JString, required = false,
                                 default = nil)
  if valid_609088 != nil:
    section.add "X-Amz-Date", valid_609088
  var valid_609089 = header.getOrDefault("X-Amz-Credential")
  valid_609089 = validateParameter(valid_609089, JString, required = false,
                                 default = nil)
  if valid_609089 != nil:
    section.add "X-Amz-Credential", valid_609089
  var valid_609090 = header.getOrDefault("X-Amz-Security-Token")
  valid_609090 = validateParameter(valid_609090, JString, required = false,
                                 default = nil)
  if valid_609090 != nil:
    section.add "X-Amz-Security-Token", valid_609090
  var valid_609091 = header.getOrDefault("X-Amz-Algorithm")
  valid_609091 = validateParameter(valid_609091, JString, required = false,
                                 default = nil)
  if valid_609091 != nil:
    section.add "X-Amz-Algorithm", valid_609091
  var valid_609092 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_609092 = validateParameter(valid_609092, JString, required = false,
                                 default = nil)
  if valid_609092 != nil:
    section.add "X-Amz-SignedHeaders", valid_609092
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_609093: Call_GetModifyScheduledAction_609073; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Modifies a scheduled action. 
  ## 
  let valid = call_609093.validator(path, query, header, formData, body)
  let scheme = call_609093.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_609093.url(scheme.get, call_609093.host, call_609093.base,
                         call_609093.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_609093, url, valid)

proc call*(call_609094: Call_GetModifyScheduledAction_609073;
          ScheduledActionName: string; Schedule: string = ""; Enable: bool = false;
          IamRole: string = ""; TargetActionResizeCluster: string = "";
          ScheduledActionDescription: string = "";
          Action: string = "ModifyScheduledAction"; StartTime: string = "";
          EndTime: string = ""; Version: string = "2012-12-01"): Recallable =
  ## getModifyScheduledAction
  ## Modifies a scheduled action. 
  ##   Schedule: string
  ##           : A modified schedule in either <code>at( )</code> or <code>cron( )</code> format. For more information about this parameter, see <a>ScheduledAction</a>.
  ##   Enable: bool
  ##         : A modified enable flag of the scheduled action. If true, the scheduled action is active. If false, the scheduled action is disabled. 
  ##   ScheduledActionName: string (required)
  ##                      : The name of the scheduled action to modify. 
  ##   IamRole: string
  ##          : A different IAM role to assume to run the target action. For more information about this parameter, see <a>ScheduledAction</a>.
  ##   TargetActionResizeCluster: string
  ##                            : The action type that specifies an Amazon Redshift API operation that is supported by the Amazon Redshift scheduler. 
  ## An action that runs a <code>ResizeCluster</code> API operation. 
  ##   ScheduledActionDescription: string
  ##                             : A modified description of the scheduled action. 
  ##   Action: string (required)
  ##   StartTime: string
  ##            : A modified start time of the scheduled action. For more information about this parameter, see <a>ScheduledAction</a>. 
  ##   EndTime: string
  ##          : A modified end time of the scheduled action. For more information about this parameter, see <a>ScheduledAction</a>. 
  ##   Version: string (required)
  var query_609095 = newJObject()
  add(query_609095, "Schedule", newJString(Schedule))
  add(query_609095, "Enable", newJBool(Enable))
  add(query_609095, "ScheduledActionName", newJString(ScheduledActionName))
  add(query_609095, "IamRole", newJString(IamRole))
  add(query_609095, "TargetAction.ResizeCluster",
      newJString(TargetActionResizeCluster))
  add(query_609095, "ScheduledActionDescription",
      newJString(ScheduledActionDescription))
  add(query_609095, "Action", newJString(Action))
  add(query_609095, "StartTime", newJString(StartTime))
  add(query_609095, "EndTime", newJString(EndTime))
  add(query_609095, "Version", newJString(Version))
  result = call_609094.call(nil, query_609095, nil, nil, nil)

var getModifyScheduledAction* = Call_GetModifyScheduledAction_609073(
    name: "getModifyScheduledAction", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyScheduledAction",
    validator: validate_GetModifyScheduledAction_609074, base: "/",
    url: url_GetModifyScheduledAction_609075, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostModifySnapshotCopyRetentionPeriod_609138 = ref object of OpenApiRestCall_605573
proc url_PostModifySnapshotCopyRetentionPeriod_609140(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostModifySnapshotCopyRetentionPeriod_609139(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies the number of days to retain snapshots in the destination AWS Region after they are copied from the source AWS Region. By default, this operation only changes the retention period of copied automated snapshots. The retention periods for both new and existing copied automated snapshots are updated with the new retention period. You can set the manual option to change only the retention periods of copied manual snapshots. If you set this option, only newly copied manual snapshots have the new retention period. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_609141 = query.getOrDefault("Action")
  valid_609141 = validateParameter(valid_609141, JString, required = true, default = newJString(
      "ModifySnapshotCopyRetentionPeriod"))
  if valid_609141 != nil:
    section.add "Action", valid_609141
  var valid_609142 = query.getOrDefault("Version")
  valid_609142 = validateParameter(valid_609142, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_609142 != nil:
    section.add "Version", valid_609142
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_609143 = header.getOrDefault("X-Amz-Signature")
  valid_609143 = validateParameter(valid_609143, JString, required = false,
                                 default = nil)
  if valid_609143 != nil:
    section.add "X-Amz-Signature", valid_609143
  var valid_609144 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_609144 = validateParameter(valid_609144, JString, required = false,
                                 default = nil)
  if valid_609144 != nil:
    section.add "X-Amz-Content-Sha256", valid_609144
  var valid_609145 = header.getOrDefault("X-Amz-Date")
  valid_609145 = validateParameter(valid_609145, JString, required = false,
                                 default = nil)
  if valid_609145 != nil:
    section.add "X-Amz-Date", valid_609145
  var valid_609146 = header.getOrDefault("X-Amz-Credential")
  valid_609146 = validateParameter(valid_609146, JString, required = false,
                                 default = nil)
  if valid_609146 != nil:
    section.add "X-Amz-Credential", valid_609146
  var valid_609147 = header.getOrDefault("X-Amz-Security-Token")
  valid_609147 = validateParameter(valid_609147, JString, required = false,
                                 default = nil)
  if valid_609147 != nil:
    section.add "X-Amz-Security-Token", valid_609147
  var valid_609148 = header.getOrDefault("X-Amz-Algorithm")
  valid_609148 = validateParameter(valid_609148, JString, required = false,
                                 default = nil)
  if valid_609148 != nil:
    section.add "X-Amz-Algorithm", valid_609148
  var valid_609149 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_609149 = validateParameter(valid_609149, JString, required = false,
                                 default = nil)
  if valid_609149 != nil:
    section.add "X-Amz-SignedHeaders", valid_609149
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of the cluster for which you want to change the retention period for either automated or manual snapshots that are copied to a destination AWS Region.</p> <p>Constraints: Must be the valid name of an existing cluster that has cross-region snapshot copy enabled.</p>
  ##   RetentionPeriod: JInt (required)
  ##                  : <p>The number of days to retain automated snapshots in the destination AWS Region after they are copied from the source AWS Region.</p> <p>By default, this only changes the retention period of copied automated snapshots. </p> <p>If you decrease the retention period for automated snapshots that are copied to a destination AWS Region, Amazon Redshift deletes any existing automated snapshots that were copied to the destination AWS Region and that fall outside of the new retention period.</p> <p>Constraints: Must be at least 1 and no more than 35 for automated snapshots. </p> <p>If you specify the <code>manual</code> option, only newly copied manual snapshots will have the new retention period. </p> <p>If you specify the value of -1 newly copied manual snapshots are retained indefinitely.</p> <p>Constraints: The number of days must be either -1 or an integer between 1 and 3,653 for manual snapshots.</p>
  ##   Manual: JBool
  ##         : Indicates whether to apply the snapshot retention period to newly copied manual snapshots instead of automated snapshots.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_609150 = formData.getOrDefault("ClusterIdentifier")
  valid_609150 = validateParameter(valid_609150, JString, required = true,
                                 default = nil)
  if valid_609150 != nil:
    section.add "ClusterIdentifier", valid_609150
  var valid_609151 = formData.getOrDefault("RetentionPeriod")
  valid_609151 = validateParameter(valid_609151, JInt, required = true, default = nil)
  if valid_609151 != nil:
    section.add "RetentionPeriod", valid_609151
  var valid_609152 = formData.getOrDefault("Manual")
  valid_609152 = validateParameter(valid_609152, JBool, required = false, default = nil)
  if valid_609152 != nil:
    section.add "Manual", valid_609152
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_609153: Call_PostModifySnapshotCopyRetentionPeriod_609138;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Modifies the number of days to retain snapshots in the destination AWS Region after they are copied from the source AWS Region. By default, this operation only changes the retention period of copied automated snapshots. The retention periods for both new and existing copied automated snapshots are updated with the new retention period. You can set the manual option to change only the retention periods of copied manual snapshots. If you set this option, only newly copied manual snapshots have the new retention period. 
  ## 
  let valid = call_609153.validator(path, query, header, formData, body)
  let scheme = call_609153.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_609153.url(scheme.get, call_609153.host, call_609153.base,
                         call_609153.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_609153, url, valid)

proc call*(call_609154: Call_PostModifySnapshotCopyRetentionPeriod_609138;
          ClusterIdentifier: string; RetentionPeriod: int;
          Action: string = "ModifySnapshotCopyRetentionPeriod";
          Manual: bool = false; Version: string = "2012-12-01"): Recallable =
  ## postModifySnapshotCopyRetentionPeriod
  ## Modifies the number of days to retain snapshots in the destination AWS Region after they are copied from the source AWS Region. By default, this operation only changes the retention period of copied automated snapshots. The retention periods for both new and existing copied automated snapshots are updated with the new retention period. You can set the manual option to change only the retention periods of copied manual snapshots. If you set this option, only newly copied manual snapshots have the new retention period. 
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of the cluster for which you want to change the retention period for either automated or manual snapshots that are copied to a destination AWS Region.</p> <p>Constraints: Must be the valid name of an existing cluster that has cross-region snapshot copy enabled.</p>
  ##   RetentionPeriod: int (required)
  ##                  : <p>The number of days to retain automated snapshots in the destination AWS Region after they are copied from the source AWS Region.</p> <p>By default, this only changes the retention period of copied automated snapshots. </p> <p>If you decrease the retention period for automated snapshots that are copied to a destination AWS Region, Amazon Redshift deletes any existing automated snapshots that were copied to the destination AWS Region and that fall outside of the new retention period.</p> <p>Constraints: Must be at least 1 and no more than 35 for automated snapshots. </p> <p>If you specify the <code>manual</code> option, only newly copied manual snapshots will have the new retention period. </p> <p>If you specify the value of -1 newly copied manual snapshots are retained indefinitely.</p> <p>Constraints: The number of days must be either -1 or an integer between 1 and 3,653 for manual snapshots.</p>
  ##   Action: string (required)
  ##   Manual: bool
  ##         : Indicates whether to apply the snapshot retention period to newly copied manual snapshots instead of automated snapshots.
  ##   Version: string (required)
  var query_609155 = newJObject()
  var formData_609156 = newJObject()
  add(formData_609156, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_609156, "RetentionPeriod", newJInt(RetentionPeriod))
  add(query_609155, "Action", newJString(Action))
  add(formData_609156, "Manual", newJBool(Manual))
  add(query_609155, "Version", newJString(Version))
  result = call_609154.call(nil, query_609155, nil, formData_609156, nil)

var postModifySnapshotCopyRetentionPeriod* = Call_PostModifySnapshotCopyRetentionPeriod_609138(
    name: "postModifySnapshotCopyRetentionPeriod", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=ModifySnapshotCopyRetentionPeriod",
    validator: validate_PostModifySnapshotCopyRetentionPeriod_609139, base: "/",
    url: url_PostModifySnapshotCopyRetentionPeriod_609140,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetModifySnapshotCopyRetentionPeriod_609120 = ref object of OpenApiRestCall_605573
proc url_GetModifySnapshotCopyRetentionPeriod_609122(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetModifySnapshotCopyRetentionPeriod_609121(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies the number of days to retain snapshots in the destination AWS Region after they are copied from the source AWS Region. By default, this operation only changes the retention period of copied automated snapshots. The retention periods for both new and existing copied automated snapshots are updated with the new retention period. You can set the manual option to change only the retention periods of copied manual snapshots. If you set this option, only newly copied manual snapshots have the new retention period. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Manual: JBool
  ##         : Indicates whether to apply the snapshot retention period to newly copied manual snapshots instead of automated snapshots.
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of the cluster for which you want to change the retention period for either automated or manual snapshots that are copied to a destination AWS Region.</p> <p>Constraints: Must be the valid name of an existing cluster that has cross-region snapshot copy enabled.</p>
  ##   Version: JString (required)
  ##   RetentionPeriod: JInt (required)
  ##                  : <p>The number of days to retain automated snapshots in the destination AWS Region after they are copied from the source AWS Region.</p> <p>By default, this only changes the retention period of copied automated snapshots. </p> <p>If you decrease the retention period for automated snapshots that are copied to a destination AWS Region, Amazon Redshift deletes any existing automated snapshots that were copied to the destination AWS Region and that fall outside of the new retention period.</p> <p>Constraints: Must be at least 1 and no more than 35 for automated snapshots. </p> <p>If you specify the <code>manual</code> option, only newly copied manual snapshots will have the new retention period. </p> <p>If you specify the value of -1 newly copied manual snapshots are retained indefinitely.</p> <p>Constraints: The number of days must be either -1 or an integer between 1 and 3,653 for manual snapshots.</p>
  section = newJObject()
  var valid_609123 = query.getOrDefault("Manual")
  valid_609123 = validateParameter(valid_609123, JBool, required = false, default = nil)
  if valid_609123 != nil:
    section.add "Manual", valid_609123
  var valid_609124 = query.getOrDefault("Action")
  valid_609124 = validateParameter(valid_609124, JString, required = true, default = newJString(
      "ModifySnapshotCopyRetentionPeriod"))
  if valid_609124 != nil:
    section.add "Action", valid_609124
  var valid_609125 = query.getOrDefault("ClusterIdentifier")
  valid_609125 = validateParameter(valid_609125, JString, required = true,
                                 default = nil)
  if valid_609125 != nil:
    section.add "ClusterIdentifier", valid_609125
  var valid_609126 = query.getOrDefault("Version")
  valid_609126 = validateParameter(valid_609126, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_609126 != nil:
    section.add "Version", valid_609126
  var valid_609127 = query.getOrDefault("RetentionPeriod")
  valid_609127 = validateParameter(valid_609127, JInt, required = true, default = nil)
  if valid_609127 != nil:
    section.add "RetentionPeriod", valid_609127
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_609128 = header.getOrDefault("X-Amz-Signature")
  valid_609128 = validateParameter(valid_609128, JString, required = false,
                                 default = nil)
  if valid_609128 != nil:
    section.add "X-Amz-Signature", valid_609128
  var valid_609129 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_609129 = validateParameter(valid_609129, JString, required = false,
                                 default = nil)
  if valid_609129 != nil:
    section.add "X-Amz-Content-Sha256", valid_609129
  var valid_609130 = header.getOrDefault("X-Amz-Date")
  valid_609130 = validateParameter(valid_609130, JString, required = false,
                                 default = nil)
  if valid_609130 != nil:
    section.add "X-Amz-Date", valid_609130
  var valid_609131 = header.getOrDefault("X-Amz-Credential")
  valid_609131 = validateParameter(valid_609131, JString, required = false,
                                 default = nil)
  if valid_609131 != nil:
    section.add "X-Amz-Credential", valid_609131
  var valid_609132 = header.getOrDefault("X-Amz-Security-Token")
  valid_609132 = validateParameter(valid_609132, JString, required = false,
                                 default = nil)
  if valid_609132 != nil:
    section.add "X-Amz-Security-Token", valid_609132
  var valid_609133 = header.getOrDefault("X-Amz-Algorithm")
  valid_609133 = validateParameter(valid_609133, JString, required = false,
                                 default = nil)
  if valid_609133 != nil:
    section.add "X-Amz-Algorithm", valid_609133
  var valid_609134 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_609134 = validateParameter(valid_609134, JString, required = false,
                                 default = nil)
  if valid_609134 != nil:
    section.add "X-Amz-SignedHeaders", valid_609134
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_609135: Call_GetModifySnapshotCopyRetentionPeriod_609120;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Modifies the number of days to retain snapshots in the destination AWS Region after they are copied from the source AWS Region. By default, this operation only changes the retention period of copied automated snapshots. The retention periods for both new and existing copied automated snapshots are updated with the new retention period. You can set the manual option to change only the retention periods of copied manual snapshots. If you set this option, only newly copied manual snapshots have the new retention period. 
  ## 
  let valid = call_609135.validator(path, query, header, formData, body)
  let scheme = call_609135.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_609135.url(scheme.get, call_609135.host, call_609135.base,
                         call_609135.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_609135, url, valid)

proc call*(call_609136: Call_GetModifySnapshotCopyRetentionPeriod_609120;
          ClusterIdentifier: string; RetentionPeriod: int; Manual: bool = false;
          Action: string = "ModifySnapshotCopyRetentionPeriod";
          Version: string = "2012-12-01"): Recallable =
  ## getModifySnapshotCopyRetentionPeriod
  ## Modifies the number of days to retain snapshots in the destination AWS Region after they are copied from the source AWS Region. By default, this operation only changes the retention period of copied automated snapshots. The retention periods for both new and existing copied automated snapshots are updated with the new retention period. You can set the manual option to change only the retention periods of copied manual snapshots. If you set this option, only newly copied manual snapshots have the new retention period. 
  ##   Manual: bool
  ##         : Indicates whether to apply the snapshot retention period to newly copied manual snapshots instead of automated snapshots.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of the cluster for which you want to change the retention period for either automated or manual snapshots that are copied to a destination AWS Region.</p> <p>Constraints: Must be the valid name of an existing cluster that has cross-region snapshot copy enabled.</p>
  ##   Version: string (required)
  ##   RetentionPeriod: int (required)
  ##                  : <p>The number of days to retain automated snapshots in the destination AWS Region after they are copied from the source AWS Region.</p> <p>By default, this only changes the retention period of copied automated snapshots. </p> <p>If you decrease the retention period for automated snapshots that are copied to a destination AWS Region, Amazon Redshift deletes any existing automated snapshots that were copied to the destination AWS Region and that fall outside of the new retention period.</p> <p>Constraints: Must be at least 1 and no more than 35 for automated snapshots. </p> <p>If you specify the <code>manual</code> option, only newly copied manual snapshots will have the new retention period. </p> <p>If you specify the value of -1 newly copied manual snapshots are retained indefinitely.</p> <p>Constraints: The number of days must be either -1 or an integer between 1 and 3,653 for manual snapshots.</p>
  var query_609137 = newJObject()
  add(query_609137, "Manual", newJBool(Manual))
  add(query_609137, "Action", newJString(Action))
  add(query_609137, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_609137, "Version", newJString(Version))
  add(query_609137, "RetentionPeriod", newJInt(RetentionPeriod))
  result = call_609136.call(nil, query_609137, nil, nil, nil)

var getModifySnapshotCopyRetentionPeriod* = Call_GetModifySnapshotCopyRetentionPeriod_609120(
    name: "getModifySnapshotCopyRetentionPeriod", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=ModifySnapshotCopyRetentionPeriod",
    validator: validate_GetModifySnapshotCopyRetentionPeriod_609121, base: "/",
    url: url_GetModifySnapshotCopyRetentionPeriod_609122,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostModifySnapshotSchedule_609174 = ref object of OpenApiRestCall_605573
proc url_PostModifySnapshotSchedule_609176(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostModifySnapshotSchedule_609175(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies a snapshot schedule. Any schedule associated with a cluster is modified asynchronously.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_609177 = query.getOrDefault("Action")
  valid_609177 = validateParameter(valid_609177, JString, required = true,
                                 default = newJString("ModifySnapshotSchedule"))
  if valid_609177 != nil:
    section.add "Action", valid_609177
  var valid_609178 = query.getOrDefault("Version")
  valid_609178 = validateParameter(valid_609178, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_609178 != nil:
    section.add "Version", valid_609178
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_609179 = header.getOrDefault("X-Amz-Signature")
  valid_609179 = validateParameter(valid_609179, JString, required = false,
                                 default = nil)
  if valid_609179 != nil:
    section.add "X-Amz-Signature", valid_609179
  var valid_609180 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_609180 = validateParameter(valid_609180, JString, required = false,
                                 default = nil)
  if valid_609180 != nil:
    section.add "X-Amz-Content-Sha256", valid_609180
  var valid_609181 = header.getOrDefault("X-Amz-Date")
  valid_609181 = validateParameter(valid_609181, JString, required = false,
                                 default = nil)
  if valid_609181 != nil:
    section.add "X-Amz-Date", valid_609181
  var valid_609182 = header.getOrDefault("X-Amz-Credential")
  valid_609182 = validateParameter(valid_609182, JString, required = false,
                                 default = nil)
  if valid_609182 != nil:
    section.add "X-Amz-Credential", valid_609182
  var valid_609183 = header.getOrDefault("X-Amz-Security-Token")
  valid_609183 = validateParameter(valid_609183, JString, required = false,
                                 default = nil)
  if valid_609183 != nil:
    section.add "X-Amz-Security-Token", valid_609183
  var valid_609184 = header.getOrDefault("X-Amz-Algorithm")
  valid_609184 = validateParameter(valid_609184, JString, required = false,
                                 default = nil)
  if valid_609184 != nil:
    section.add "X-Amz-Algorithm", valid_609184
  var valid_609185 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_609185 = validateParameter(valid_609185, JString, required = false,
                                 default = nil)
  if valid_609185 != nil:
    section.add "X-Amz-SignedHeaders", valid_609185
  result.add "header", section
  ## parameters in `formData` object:
  ##   ScheduleDefinitions: JArray (required)
  ##                      : An updated list of schedule definitions. A schedule definition is made up of schedule expressions, for example, "cron(30 12 *)" or "rate(12 hours)".
  ##   ScheduleIdentifier: JString (required)
  ##                     : A unique alphanumeric identifier of the schedule to modify.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ScheduleDefinitions` field"
  var valid_609186 = formData.getOrDefault("ScheduleDefinitions")
  valid_609186 = validateParameter(valid_609186, JArray, required = true, default = nil)
  if valid_609186 != nil:
    section.add "ScheduleDefinitions", valid_609186
  var valid_609187 = formData.getOrDefault("ScheduleIdentifier")
  valid_609187 = validateParameter(valid_609187, JString, required = true,
                                 default = nil)
  if valid_609187 != nil:
    section.add "ScheduleIdentifier", valid_609187
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_609188: Call_PostModifySnapshotSchedule_609174; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Modifies a snapshot schedule. Any schedule associated with a cluster is modified asynchronously.
  ## 
  let valid = call_609188.validator(path, query, header, formData, body)
  let scheme = call_609188.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_609188.url(scheme.get, call_609188.host, call_609188.base,
                         call_609188.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_609188, url, valid)

proc call*(call_609189: Call_PostModifySnapshotSchedule_609174;
          ScheduleDefinitions: JsonNode; ScheduleIdentifier: string;
          Action: string = "ModifySnapshotSchedule"; Version: string = "2012-12-01"): Recallable =
  ## postModifySnapshotSchedule
  ## Modifies a snapshot schedule. Any schedule associated with a cluster is modified asynchronously.
  ##   ScheduleDefinitions: JArray (required)
  ##                      : An updated list of schedule definitions. A schedule definition is made up of schedule expressions, for example, "cron(30 12 *)" or "rate(12 hours)".
  ##   Action: string (required)
  ##   ScheduleIdentifier: string (required)
  ##                     : A unique alphanumeric identifier of the schedule to modify.
  ##   Version: string (required)
  var query_609190 = newJObject()
  var formData_609191 = newJObject()
  if ScheduleDefinitions != nil:
    formData_609191.add "ScheduleDefinitions", ScheduleDefinitions
  add(query_609190, "Action", newJString(Action))
  add(formData_609191, "ScheduleIdentifier", newJString(ScheduleIdentifier))
  add(query_609190, "Version", newJString(Version))
  result = call_609189.call(nil, query_609190, nil, formData_609191, nil)

var postModifySnapshotSchedule* = Call_PostModifySnapshotSchedule_609174(
    name: "postModifySnapshotSchedule", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=ModifySnapshotSchedule",
    validator: validate_PostModifySnapshotSchedule_609175, base: "/",
    url: url_PostModifySnapshotSchedule_609176,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetModifySnapshotSchedule_609157 = ref object of OpenApiRestCall_605573
proc url_GetModifySnapshotSchedule_609159(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetModifySnapshotSchedule_609158(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies a snapshot schedule. Any schedule associated with a cluster is modified asynchronously.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ScheduleIdentifier: JString (required)
  ##                     : A unique alphanumeric identifier of the schedule to modify.
  ##   ScheduleDefinitions: JArray (required)
  ##                      : An updated list of schedule definitions. A schedule definition is made up of schedule expressions, for example, "cron(30 12 *)" or "rate(12 hours)".
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `ScheduleIdentifier` field"
  var valid_609160 = query.getOrDefault("ScheduleIdentifier")
  valid_609160 = validateParameter(valid_609160, JString, required = true,
                                 default = nil)
  if valid_609160 != nil:
    section.add "ScheduleIdentifier", valid_609160
  var valid_609161 = query.getOrDefault("ScheduleDefinitions")
  valid_609161 = validateParameter(valid_609161, JArray, required = true, default = nil)
  if valid_609161 != nil:
    section.add "ScheduleDefinitions", valid_609161
  var valid_609162 = query.getOrDefault("Action")
  valid_609162 = validateParameter(valid_609162, JString, required = true,
                                 default = newJString("ModifySnapshotSchedule"))
  if valid_609162 != nil:
    section.add "Action", valid_609162
  var valid_609163 = query.getOrDefault("Version")
  valid_609163 = validateParameter(valid_609163, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_609163 != nil:
    section.add "Version", valid_609163
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_609164 = header.getOrDefault("X-Amz-Signature")
  valid_609164 = validateParameter(valid_609164, JString, required = false,
                                 default = nil)
  if valid_609164 != nil:
    section.add "X-Amz-Signature", valid_609164
  var valid_609165 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_609165 = validateParameter(valid_609165, JString, required = false,
                                 default = nil)
  if valid_609165 != nil:
    section.add "X-Amz-Content-Sha256", valid_609165
  var valid_609166 = header.getOrDefault("X-Amz-Date")
  valid_609166 = validateParameter(valid_609166, JString, required = false,
                                 default = nil)
  if valid_609166 != nil:
    section.add "X-Amz-Date", valid_609166
  var valid_609167 = header.getOrDefault("X-Amz-Credential")
  valid_609167 = validateParameter(valid_609167, JString, required = false,
                                 default = nil)
  if valid_609167 != nil:
    section.add "X-Amz-Credential", valid_609167
  var valid_609168 = header.getOrDefault("X-Amz-Security-Token")
  valid_609168 = validateParameter(valid_609168, JString, required = false,
                                 default = nil)
  if valid_609168 != nil:
    section.add "X-Amz-Security-Token", valid_609168
  var valid_609169 = header.getOrDefault("X-Amz-Algorithm")
  valid_609169 = validateParameter(valid_609169, JString, required = false,
                                 default = nil)
  if valid_609169 != nil:
    section.add "X-Amz-Algorithm", valid_609169
  var valid_609170 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_609170 = validateParameter(valid_609170, JString, required = false,
                                 default = nil)
  if valid_609170 != nil:
    section.add "X-Amz-SignedHeaders", valid_609170
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_609171: Call_GetModifySnapshotSchedule_609157; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Modifies a snapshot schedule. Any schedule associated with a cluster is modified asynchronously.
  ## 
  let valid = call_609171.validator(path, query, header, formData, body)
  let scheme = call_609171.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_609171.url(scheme.get, call_609171.host, call_609171.base,
                         call_609171.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_609171, url, valid)

proc call*(call_609172: Call_GetModifySnapshotSchedule_609157;
          ScheduleIdentifier: string; ScheduleDefinitions: JsonNode;
          Action: string = "ModifySnapshotSchedule"; Version: string = "2012-12-01"): Recallable =
  ## getModifySnapshotSchedule
  ## Modifies a snapshot schedule. Any schedule associated with a cluster is modified asynchronously.
  ##   ScheduleIdentifier: string (required)
  ##                     : A unique alphanumeric identifier of the schedule to modify.
  ##   ScheduleDefinitions: JArray (required)
  ##                      : An updated list of schedule definitions. A schedule definition is made up of schedule expressions, for example, "cron(30 12 *)" or "rate(12 hours)".
  ##   Action: string (required)
  ##   Version: string (required)
  var query_609173 = newJObject()
  add(query_609173, "ScheduleIdentifier", newJString(ScheduleIdentifier))
  if ScheduleDefinitions != nil:
    query_609173.add "ScheduleDefinitions", ScheduleDefinitions
  add(query_609173, "Action", newJString(Action))
  add(query_609173, "Version", newJString(Version))
  result = call_609172.call(nil, query_609173, nil, nil, nil)

var getModifySnapshotSchedule* = Call_GetModifySnapshotSchedule_609157(
    name: "getModifySnapshotSchedule", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=ModifySnapshotSchedule",
    validator: validate_GetModifySnapshotSchedule_609158, base: "/",
    url: url_GetModifySnapshotSchedule_609159,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostPurchaseReservedNodeOffering_609209 = ref object of OpenApiRestCall_605573
proc url_PostPurchaseReservedNodeOffering_609211(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostPurchaseReservedNodeOffering_609210(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Allows you to purchase reserved nodes. Amazon Redshift offers a predefined set of reserved node offerings. You can purchase one or more of the offerings. You can call the <a>DescribeReservedNodeOfferings</a> API to obtain the available reserved node offerings. You can call this API by providing a specific reserved node offering and the number of nodes you want to reserve. </p> <p> For more information about reserved node offerings, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_609212 = query.getOrDefault("Action")
  valid_609212 = validateParameter(valid_609212, JString, required = true, default = newJString(
      "PurchaseReservedNodeOffering"))
  if valid_609212 != nil:
    section.add "Action", valid_609212
  var valid_609213 = query.getOrDefault("Version")
  valid_609213 = validateParameter(valid_609213, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_609213 != nil:
    section.add "Version", valid_609213
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_609214 = header.getOrDefault("X-Amz-Signature")
  valid_609214 = validateParameter(valid_609214, JString, required = false,
                                 default = nil)
  if valid_609214 != nil:
    section.add "X-Amz-Signature", valid_609214
  var valid_609215 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_609215 = validateParameter(valid_609215, JString, required = false,
                                 default = nil)
  if valid_609215 != nil:
    section.add "X-Amz-Content-Sha256", valid_609215
  var valid_609216 = header.getOrDefault("X-Amz-Date")
  valid_609216 = validateParameter(valid_609216, JString, required = false,
                                 default = nil)
  if valid_609216 != nil:
    section.add "X-Amz-Date", valid_609216
  var valid_609217 = header.getOrDefault("X-Amz-Credential")
  valid_609217 = validateParameter(valid_609217, JString, required = false,
                                 default = nil)
  if valid_609217 != nil:
    section.add "X-Amz-Credential", valid_609217
  var valid_609218 = header.getOrDefault("X-Amz-Security-Token")
  valid_609218 = validateParameter(valid_609218, JString, required = false,
                                 default = nil)
  if valid_609218 != nil:
    section.add "X-Amz-Security-Token", valid_609218
  var valid_609219 = header.getOrDefault("X-Amz-Algorithm")
  valid_609219 = validateParameter(valid_609219, JString, required = false,
                                 default = nil)
  if valid_609219 != nil:
    section.add "X-Amz-Algorithm", valid_609219
  var valid_609220 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_609220 = validateParameter(valid_609220, JString, required = false,
                                 default = nil)
  if valid_609220 != nil:
    section.add "X-Amz-SignedHeaders", valid_609220
  result.add "header", section
  ## parameters in `formData` object:
  ##   NodeCount: JInt
  ##            : <p>The number of reserved nodes that you want to purchase.</p> <p>Default: <code>1</code> </p>
  ##   ReservedNodeOfferingId: JString (required)
  ##                         : The unique identifier of the reserved node offering you want to purchase.
  section = newJObject()
  var valid_609221 = formData.getOrDefault("NodeCount")
  valid_609221 = validateParameter(valid_609221, JInt, required = false, default = nil)
  if valid_609221 != nil:
    section.add "NodeCount", valid_609221
  assert formData != nil, "formData argument is necessary due to required `ReservedNodeOfferingId` field"
  var valid_609222 = formData.getOrDefault("ReservedNodeOfferingId")
  valid_609222 = validateParameter(valid_609222, JString, required = true,
                                 default = nil)
  if valid_609222 != nil:
    section.add "ReservedNodeOfferingId", valid_609222
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_609223: Call_PostPurchaseReservedNodeOffering_609209;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Allows you to purchase reserved nodes. Amazon Redshift offers a predefined set of reserved node offerings. You can purchase one or more of the offerings. You can call the <a>DescribeReservedNodeOfferings</a> API to obtain the available reserved node offerings. You can call this API by providing a specific reserved node offering and the number of nodes you want to reserve. </p> <p> For more information about reserved node offerings, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_609223.validator(path, query, header, formData, body)
  let scheme = call_609223.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_609223.url(scheme.get, call_609223.host, call_609223.base,
                         call_609223.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_609223, url, valid)

proc call*(call_609224: Call_PostPurchaseReservedNodeOffering_609209;
          ReservedNodeOfferingId: string; NodeCount: int = 0;
          Action: string = "PurchaseReservedNodeOffering";
          Version: string = "2012-12-01"): Recallable =
  ## postPurchaseReservedNodeOffering
  ## <p>Allows you to purchase reserved nodes. Amazon Redshift offers a predefined set of reserved node offerings. You can purchase one or more of the offerings. You can call the <a>DescribeReservedNodeOfferings</a> API to obtain the available reserved node offerings. You can call this API by providing a specific reserved node offering and the number of nodes you want to reserve. </p> <p> For more information about reserved node offerings, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   NodeCount: int
  ##            : <p>The number of reserved nodes that you want to purchase.</p> <p>Default: <code>1</code> </p>
  ##   ReservedNodeOfferingId: string (required)
  ##                         : The unique identifier of the reserved node offering you want to purchase.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_609225 = newJObject()
  var formData_609226 = newJObject()
  add(formData_609226, "NodeCount", newJInt(NodeCount))
  add(formData_609226, "ReservedNodeOfferingId",
      newJString(ReservedNodeOfferingId))
  add(query_609225, "Action", newJString(Action))
  add(query_609225, "Version", newJString(Version))
  result = call_609224.call(nil, query_609225, nil, formData_609226, nil)

var postPurchaseReservedNodeOffering* = Call_PostPurchaseReservedNodeOffering_609209(
    name: "postPurchaseReservedNodeOffering", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=PurchaseReservedNodeOffering",
    validator: validate_PostPurchaseReservedNodeOffering_609210, base: "/",
    url: url_PostPurchaseReservedNodeOffering_609211,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetPurchaseReservedNodeOffering_609192 = ref object of OpenApiRestCall_605573
proc url_GetPurchaseReservedNodeOffering_609194(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetPurchaseReservedNodeOffering_609193(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Allows you to purchase reserved nodes. Amazon Redshift offers a predefined set of reserved node offerings. You can purchase one or more of the offerings. You can call the <a>DescribeReservedNodeOfferings</a> API to obtain the available reserved node offerings. You can call this API by providing a specific reserved node offering and the number of nodes you want to reserve. </p> <p> For more information about reserved node offerings, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ReservedNodeOfferingId: JString (required)
  ##                         : The unique identifier of the reserved node offering you want to purchase.
  ##   Action: JString (required)
  ##   Version: JString (required)
  ##   NodeCount: JInt
  ##            : <p>The number of reserved nodes that you want to purchase.</p> <p>Default: <code>1</code> </p>
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `ReservedNodeOfferingId` field"
  var valid_609195 = query.getOrDefault("ReservedNodeOfferingId")
  valid_609195 = validateParameter(valid_609195, JString, required = true,
                                 default = nil)
  if valid_609195 != nil:
    section.add "ReservedNodeOfferingId", valid_609195
  var valid_609196 = query.getOrDefault("Action")
  valid_609196 = validateParameter(valid_609196, JString, required = true, default = newJString(
      "PurchaseReservedNodeOffering"))
  if valid_609196 != nil:
    section.add "Action", valid_609196
  var valid_609197 = query.getOrDefault("Version")
  valid_609197 = validateParameter(valid_609197, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_609197 != nil:
    section.add "Version", valid_609197
  var valid_609198 = query.getOrDefault("NodeCount")
  valid_609198 = validateParameter(valid_609198, JInt, required = false, default = nil)
  if valid_609198 != nil:
    section.add "NodeCount", valid_609198
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_609199 = header.getOrDefault("X-Amz-Signature")
  valid_609199 = validateParameter(valid_609199, JString, required = false,
                                 default = nil)
  if valid_609199 != nil:
    section.add "X-Amz-Signature", valid_609199
  var valid_609200 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_609200 = validateParameter(valid_609200, JString, required = false,
                                 default = nil)
  if valid_609200 != nil:
    section.add "X-Amz-Content-Sha256", valid_609200
  var valid_609201 = header.getOrDefault("X-Amz-Date")
  valid_609201 = validateParameter(valid_609201, JString, required = false,
                                 default = nil)
  if valid_609201 != nil:
    section.add "X-Amz-Date", valid_609201
  var valid_609202 = header.getOrDefault("X-Amz-Credential")
  valid_609202 = validateParameter(valid_609202, JString, required = false,
                                 default = nil)
  if valid_609202 != nil:
    section.add "X-Amz-Credential", valid_609202
  var valid_609203 = header.getOrDefault("X-Amz-Security-Token")
  valid_609203 = validateParameter(valid_609203, JString, required = false,
                                 default = nil)
  if valid_609203 != nil:
    section.add "X-Amz-Security-Token", valid_609203
  var valid_609204 = header.getOrDefault("X-Amz-Algorithm")
  valid_609204 = validateParameter(valid_609204, JString, required = false,
                                 default = nil)
  if valid_609204 != nil:
    section.add "X-Amz-Algorithm", valid_609204
  var valid_609205 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_609205 = validateParameter(valid_609205, JString, required = false,
                                 default = nil)
  if valid_609205 != nil:
    section.add "X-Amz-SignedHeaders", valid_609205
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_609206: Call_GetPurchaseReservedNodeOffering_609192;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Allows you to purchase reserved nodes. Amazon Redshift offers a predefined set of reserved node offerings. You can purchase one or more of the offerings. You can call the <a>DescribeReservedNodeOfferings</a> API to obtain the available reserved node offerings. You can call this API by providing a specific reserved node offering and the number of nodes you want to reserve. </p> <p> For more information about reserved node offerings, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_609206.validator(path, query, header, formData, body)
  let scheme = call_609206.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_609206.url(scheme.get, call_609206.host, call_609206.base,
                         call_609206.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_609206, url, valid)

proc call*(call_609207: Call_GetPurchaseReservedNodeOffering_609192;
          ReservedNodeOfferingId: string;
          Action: string = "PurchaseReservedNodeOffering";
          Version: string = "2012-12-01"; NodeCount: int = 0): Recallable =
  ## getPurchaseReservedNodeOffering
  ## <p>Allows you to purchase reserved nodes. Amazon Redshift offers a predefined set of reserved node offerings. You can purchase one or more of the offerings. You can call the <a>DescribeReservedNodeOfferings</a> API to obtain the available reserved node offerings. You can call this API by providing a specific reserved node offering and the number of nodes you want to reserve. </p> <p> For more information about reserved node offerings, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   ReservedNodeOfferingId: string (required)
  ##                         : The unique identifier of the reserved node offering you want to purchase.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   NodeCount: int
  ##            : <p>The number of reserved nodes that you want to purchase.</p> <p>Default: <code>1</code> </p>
  var query_609208 = newJObject()
  add(query_609208, "ReservedNodeOfferingId", newJString(ReservedNodeOfferingId))
  add(query_609208, "Action", newJString(Action))
  add(query_609208, "Version", newJString(Version))
  add(query_609208, "NodeCount", newJInt(NodeCount))
  result = call_609207.call(nil, query_609208, nil, nil, nil)

var getPurchaseReservedNodeOffering* = Call_GetPurchaseReservedNodeOffering_609192(
    name: "getPurchaseReservedNodeOffering", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=PurchaseReservedNodeOffering",
    validator: validate_GetPurchaseReservedNodeOffering_609193, base: "/",
    url: url_GetPurchaseReservedNodeOffering_609194,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostRebootCluster_609243 = ref object of OpenApiRestCall_605573
proc url_PostRebootCluster_609245(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostRebootCluster_609244(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## Reboots a cluster. This action is taken as soon as possible. It results in a momentary outage to the cluster, during which the cluster status is set to <code>rebooting</code>. A cluster event is created when the reboot is completed. Any pending cluster modifications (see <a>ModifyCluster</a>) are applied at this reboot. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_609246 = query.getOrDefault("Action")
  valid_609246 = validateParameter(valid_609246, JString, required = true,
                                 default = newJString("RebootCluster"))
  if valid_609246 != nil:
    section.add "Action", valid_609246
  var valid_609247 = query.getOrDefault("Version")
  valid_609247 = validateParameter(valid_609247, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_609247 != nil:
    section.add "Version", valid_609247
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_609248 = header.getOrDefault("X-Amz-Signature")
  valid_609248 = validateParameter(valid_609248, JString, required = false,
                                 default = nil)
  if valid_609248 != nil:
    section.add "X-Amz-Signature", valid_609248
  var valid_609249 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_609249 = validateParameter(valid_609249, JString, required = false,
                                 default = nil)
  if valid_609249 != nil:
    section.add "X-Amz-Content-Sha256", valid_609249
  var valid_609250 = header.getOrDefault("X-Amz-Date")
  valid_609250 = validateParameter(valid_609250, JString, required = false,
                                 default = nil)
  if valid_609250 != nil:
    section.add "X-Amz-Date", valid_609250
  var valid_609251 = header.getOrDefault("X-Amz-Credential")
  valid_609251 = validateParameter(valid_609251, JString, required = false,
                                 default = nil)
  if valid_609251 != nil:
    section.add "X-Amz-Credential", valid_609251
  var valid_609252 = header.getOrDefault("X-Amz-Security-Token")
  valid_609252 = validateParameter(valid_609252, JString, required = false,
                                 default = nil)
  if valid_609252 != nil:
    section.add "X-Amz-Security-Token", valid_609252
  var valid_609253 = header.getOrDefault("X-Amz-Algorithm")
  valid_609253 = validateParameter(valid_609253, JString, required = false,
                                 default = nil)
  if valid_609253 != nil:
    section.add "X-Amz-Algorithm", valid_609253
  var valid_609254 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_609254 = validateParameter(valid_609254, JString, required = false,
                                 default = nil)
  if valid_609254 != nil:
    section.add "X-Amz-SignedHeaders", valid_609254
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : The cluster identifier.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_609255 = formData.getOrDefault("ClusterIdentifier")
  valid_609255 = validateParameter(valid_609255, JString, required = true,
                                 default = nil)
  if valid_609255 != nil:
    section.add "ClusterIdentifier", valid_609255
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_609256: Call_PostRebootCluster_609243; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Reboots a cluster. This action is taken as soon as possible. It results in a momentary outage to the cluster, during which the cluster status is set to <code>rebooting</code>. A cluster event is created when the reboot is completed. Any pending cluster modifications (see <a>ModifyCluster</a>) are applied at this reboot. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. 
  ## 
  let valid = call_609256.validator(path, query, header, formData, body)
  let scheme = call_609256.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_609256.url(scheme.get, call_609256.host, call_609256.base,
                         call_609256.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_609256, url, valid)

proc call*(call_609257: Call_PostRebootCluster_609243; ClusterIdentifier: string;
          Action: string = "RebootCluster"; Version: string = "2012-12-01"): Recallable =
  ## postRebootCluster
  ## Reboots a cluster. This action is taken as soon as possible. It results in a momentary outage to the cluster, during which the cluster status is set to <code>rebooting</code>. A cluster event is created when the reboot is completed. Any pending cluster modifications (see <a>ModifyCluster</a>) are applied at this reboot. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. 
  ##   ClusterIdentifier: string (required)
  ##                    : The cluster identifier.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_609258 = newJObject()
  var formData_609259 = newJObject()
  add(formData_609259, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_609258, "Action", newJString(Action))
  add(query_609258, "Version", newJString(Version))
  result = call_609257.call(nil, query_609258, nil, formData_609259, nil)

var postRebootCluster* = Call_PostRebootCluster_609243(name: "postRebootCluster",
    meth: HttpMethod.HttpPost, host: "redshift.amazonaws.com",
    route: "/#Action=RebootCluster", validator: validate_PostRebootCluster_609244,
    base: "/", url: url_PostRebootCluster_609245,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetRebootCluster_609227 = ref object of OpenApiRestCall_605573
proc url_GetRebootCluster_609229(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetRebootCluster_609228(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Reboots a cluster. This action is taken as soon as possible. It results in a momentary outage to the cluster, during which the cluster status is set to <code>rebooting</code>. A cluster event is created when the reboot is completed. Any pending cluster modifications (see <a>ModifyCluster</a>) are applied at this reboot. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : The cluster identifier.
  ##   Version: JString (required)
  section = newJObject()
  var valid_609230 = query.getOrDefault("Action")
  valid_609230 = validateParameter(valid_609230, JString, required = true,
                                 default = newJString("RebootCluster"))
  if valid_609230 != nil:
    section.add "Action", valid_609230
  var valid_609231 = query.getOrDefault("ClusterIdentifier")
  valid_609231 = validateParameter(valid_609231, JString, required = true,
                                 default = nil)
  if valid_609231 != nil:
    section.add "ClusterIdentifier", valid_609231
  var valid_609232 = query.getOrDefault("Version")
  valid_609232 = validateParameter(valid_609232, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_609232 != nil:
    section.add "Version", valid_609232
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_609233 = header.getOrDefault("X-Amz-Signature")
  valid_609233 = validateParameter(valid_609233, JString, required = false,
                                 default = nil)
  if valid_609233 != nil:
    section.add "X-Amz-Signature", valid_609233
  var valid_609234 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_609234 = validateParameter(valid_609234, JString, required = false,
                                 default = nil)
  if valid_609234 != nil:
    section.add "X-Amz-Content-Sha256", valid_609234
  var valid_609235 = header.getOrDefault("X-Amz-Date")
  valid_609235 = validateParameter(valid_609235, JString, required = false,
                                 default = nil)
  if valid_609235 != nil:
    section.add "X-Amz-Date", valid_609235
  var valid_609236 = header.getOrDefault("X-Amz-Credential")
  valid_609236 = validateParameter(valid_609236, JString, required = false,
                                 default = nil)
  if valid_609236 != nil:
    section.add "X-Amz-Credential", valid_609236
  var valid_609237 = header.getOrDefault("X-Amz-Security-Token")
  valid_609237 = validateParameter(valid_609237, JString, required = false,
                                 default = nil)
  if valid_609237 != nil:
    section.add "X-Amz-Security-Token", valid_609237
  var valid_609238 = header.getOrDefault("X-Amz-Algorithm")
  valid_609238 = validateParameter(valid_609238, JString, required = false,
                                 default = nil)
  if valid_609238 != nil:
    section.add "X-Amz-Algorithm", valid_609238
  var valid_609239 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_609239 = validateParameter(valid_609239, JString, required = false,
                                 default = nil)
  if valid_609239 != nil:
    section.add "X-Amz-SignedHeaders", valid_609239
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_609240: Call_GetRebootCluster_609227; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Reboots a cluster. This action is taken as soon as possible. It results in a momentary outage to the cluster, during which the cluster status is set to <code>rebooting</code>. A cluster event is created when the reboot is completed. Any pending cluster modifications (see <a>ModifyCluster</a>) are applied at this reboot. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. 
  ## 
  let valid = call_609240.validator(path, query, header, formData, body)
  let scheme = call_609240.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_609240.url(scheme.get, call_609240.host, call_609240.base,
                         call_609240.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_609240, url, valid)

proc call*(call_609241: Call_GetRebootCluster_609227; ClusterIdentifier: string;
          Action: string = "RebootCluster"; Version: string = "2012-12-01"): Recallable =
  ## getRebootCluster
  ## Reboots a cluster. This action is taken as soon as possible. It results in a momentary outage to the cluster, during which the cluster status is set to <code>rebooting</code>. A cluster event is created when the reboot is completed. Any pending cluster modifications (see <a>ModifyCluster</a>) are applied at this reboot. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. 
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : The cluster identifier.
  ##   Version: string (required)
  var query_609242 = newJObject()
  add(query_609242, "Action", newJString(Action))
  add(query_609242, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_609242, "Version", newJString(Version))
  result = call_609241.call(nil, query_609242, nil, nil, nil)

var getRebootCluster* = Call_GetRebootCluster_609227(name: "getRebootCluster",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=RebootCluster", validator: validate_GetRebootCluster_609228,
    base: "/", url: url_GetRebootCluster_609229,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostResetClusterParameterGroup_609278 = ref object of OpenApiRestCall_605573
proc url_PostResetClusterParameterGroup_609280(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostResetClusterParameterGroup_609279(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Sets one or more parameters of the specified parameter group to their default values and sets the source values of the parameters to "engine-default". To reset the entire parameter group specify the <i>ResetAllParameters</i> parameter. For parameter changes to take effect you must reboot any associated clusters. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_609281 = query.getOrDefault("Action")
  valid_609281 = validateParameter(valid_609281, JString, required = true, default = newJString(
      "ResetClusterParameterGroup"))
  if valid_609281 != nil:
    section.add "Action", valid_609281
  var valid_609282 = query.getOrDefault("Version")
  valid_609282 = validateParameter(valid_609282, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_609282 != nil:
    section.add "Version", valid_609282
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_609283 = header.getOrDefault("X-Amz-Signature")
  valid_609283 = validateParameter(valid_609283, JString, required = false,
                                 default = nil)
  if valid_609283 != nil:
    section.add "X-Amz-Signature", valid_609283
  var valid_609284 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_609284 = validateParameter(valid_609284, JString, required = false,
                                 default = nil)
  if valid_609284 != nil:
    section.add "X-Amz-Content-Sha256", valid_609284
  var valid_609285 = header.getOrDefault("X-Amz-Date")
  valid_609285 = validateParameter(valid_609285, JString, required = false,
                                 default = nil)
  if valid_609285 != nil:
    section.add "X-Amz-Date", valid_609285
  var valid_609286 = header.getOrDefault("X-Amz-Credential")
  valid_609286 = validateParameter(valid_609286, JString, required = false,
                                 default = nil)
  if valid_609286 != nil:
    section.add "X-Amz-Credential", valid_609286
  var valid_609287 = header.getOrDefault("X-Amz-Security-Token")
  valid_609287 = validateParameter(valid_609287, JString, required = false,
                                 default = nil)
  if valid_609287 != nil:
    section.add "X-Amz-Security-Token", valid_609287
  var valid_609288 = header.getOrDefault("X-Amz-Algorithm")
  valid_609288 = validateParameter(valid_609288, JString, required = false,
                                 default = nil)
  if valid_609288 != nil:
    section.add "X-Amz-Algorithm", valid_609288
  var valid_609289 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_609289 = validateParameter(valid_609289, JString, required = false,
                                 default = nil)
  if valid_609289 != nil:
    section.add "X-Amz-SignedHeaders", valid_609289
  result.add "header", section
  ## parameters in `formData` object:
  ##   ResetAllParameters: JBool
  ##                     : <p>If <code>true</code>, all parameters in the specified parameter group will be reset to their default values. </p> <p>Default: <code>true</code> </p>
  ##   Parameters: JArray
  ##             : <p>An array of names of parameters to be reset. If <i>ResetAllParameters</i> option is not used, then at least one parameter name must be supplied. </p> <p>Constraints: A maximum of 20 parameters can be reset in a single request.</p>
  ##   ParameterGroupName: JString (required)
  ##                     : The name of the cluster parameter group to be reset.
  section = newJObject()
  var valid_609290 = formData.getOrDefault("ResetAllParameters")
  valid_609290 = validateParameter(valid_609290, JBool, required = false, default = nil)
  if valid_609290 != nil:
    section.add "ResetAllParameters", valid_609290
  var valid_609291 = formData.getOrDefault("Parameters")
  valid_609291 = validateParameter(valid_609291, JArray, required = false,
                                 default = nil)
  if valid_609291 != nil:
    section.add "Parameters", valid_609291
  assert formData != nil, "formData argument is necessary due to required `ParameterGroupName` field"
  var valid_609292 = formData.getOrDefault("ParameterGroupName")
  valid_609292 = validateParameter(valid_609292, JString, required = true,
                                 default = nil)
  if valid_609292 != nil:
    section.add "ParameterGroupName", valid_609292
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_609293: Call_PostResetClusterParameterGroup_609278; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Sets one or more parameters of the specified parameter group to their default values and sets the source values of the parameters to "engine-default". To reset the entire parameter group specify the <i>ResetAllParameters</i> parameter. For parameter changes to take effect you must reboot any associated clusters. 
  ## 
  let valid = call_609293.validator(path, query, header, formData, body)
  let scheme = call_609293.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_609293.url(scheme.get, call_609293.host, call_609293.base,
                         call_609293.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_609293, url, valid)

proc call*(call_609294: Call_PostResetClusterParameterGroup_609278;
          ParameterGroupName: string; ResetAllParameters: bool = false;
          Action: string = "ResetClusterParameterGroup"; Parameters: JsonNode = nil;
          Version: string = "2012-12-01"): Recallable =
  ## postResetClusterParameterGroup
  ## Sets one or more parameters of the specified parameter group to their default values and sets the source values of the parameters to "engine-default". To reset the entire parameter group specify the <i>ResetAllParameters</i> parameter. For parameter changes to take effect you must reboot any associated clusters. 
  ##   ResetAllParameters: bool
  ##                     : <p>If <code>true</code>, all parameters in the specified parameter group will be reset to their default values. </p> <p>Default: <code>true</code> </p>
  ##   Action: string (required)
  ##   Parameters: JArray
  ##             : <p>An array of names of parameters to be reset. If <i>ResetAllParameters</i> option is not used, then at least one parameter name must be supplied. </p> <p>Constraints: A maximum of 20 parameters can be reset in a single request.</p>
  ##   ParameterGroupName: string (required)
  ##                     : The name of the cluster parameter group to be reset.
  ##   Version: string (required)
  var query_609295 = newJObject()
  var formData_609296 = newJObject()
  add(formData_609296, "ResetAllParameters", newJBool(ResetAllParameters))
  add(query_609295, "Action", newJString(Action))
  if Parameters != nil:
    formData_609296.add "Parameters", Parameters
  add(formData_609296, "ParameterGroupName", newJString(ParameterGroupName))
  add(query_609295, "Version", newJString(Version))
  result = call_609294.call(nil, query_609295, nil, formData_609296, nil)

var postResetClusterParameterGroup* = Call_PostResetClusterParameterGroup_609278(
    name: "postResetClusterParameterGroup", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=ResetClusterParameterGroup",
    validator: validate_PostResetClusterParameterGroup_609279, base: "/",
    url: url_PostResetClusterParameterGroup_609280,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetResetClusterParameterGroup_609260 = ref object of OpenApiRestCall_605573
proc url_GetResetClusterParameterGroup_609262(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetResetClusterParameterGroup_609261(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Sets one or more parameters of the specified parameter group to their default values and sets the source values of the parameters to "engine-default". To reset the entire parameter group specify the <i>ResetAllParameters</i> parameter. For parameter changes to take effect you must reboot any associated clusters. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Parameters: JArray
  ##             : <p>An array of names of parameters to be reset. If <i>ResetAllParameters</i> option is not used, then at least one parameter name must be supplied. </p> <p>Constraints: A maximum of 20 parameters can be reset in a single request.</p>
  ##   ResetAllParameters: JBool
  ##                     : <p>If <code>true</code>, all parameters in the specified parameter group will be reset to their default values. </p> <p>Default: <code>true</code> </p>
  ##   Action: JString (required)
  ##   ParameterGroupName: JString (required)
  ##                     : The name of the cluster parameter group to be reset.
  ##   Version: JString (required)
  section = newJObject()
  var valid_609263 = query.getOrDefault("Parameters")
  valid_609263 = validateParameter(valid_609263, JArray, required = false,
                                 default = nil)
  if valid_609263 != nil:
    section.add "Parameters", valid_609263
  var valid_609264 = query.getOrDefault("ResetAllParameters")
  valid_609264 = validateParameter(valid_609264, JBool, required = false, default = nil)
  if valid_609264 != nil:
    section.add "ResetAllParameters", valid_609264
  var valid_609265 = query.getOrDefault("Action")
  valid_609265 = validateParameter(valid_609265, JString, required = true, default = newJString(
      "ResetClusterParameterGroup"))
  if valid_609265 != nil:
    section.add "Action", valid_609265
  var valid_609266 = query.getOrDefault("ParameterGroupName")
  valid_609266 = validateParameter(valid_609266, JString, required = true,
                                 default = nil)
  if valid_609266 != nil:
    section.add "ParameterGroupName", valid_609266
  var valid_609267 = query.getOrDefault("Version")
  valid_609267 = validateParameter(valid_609267, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_609267 != nil:
    section.add "Version", valid_609267
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_609268 = header.getOrDefault("X-Amz-Signature")
  valid_609268 = validateParameter(valid_609268, JString, required = false,
                                 default = nil)
  if valid_609268 != nil:
    section.add "X-Amz-Signature", valid_609268
  var valid_609269 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_609269 = validateParameter(valid_609269, JString, required = false,
                                 default = nil)
  if valid_609269 != nil:
    section.add "X-Amz-Content-Sha256", valid_609269
  var valid_609270 = header.getOrDefault("X-Amz-Date")
  valid_609270 = validateParameter(valid_609270, JString, required = false,
                                 default = nil)
  if valid_609270 != nil:
    section.add "X-Amz-Date", valid_609270
  var valid_609271 = header.getOrDefault("X-Amz-Credential")
  valid_609271 = validateParameter(valid_609271, JString, required = false,
                                 default = nil)
  if valid_609271 != nil:
    section.add "X-Amz-Credential", valid_609271
  var valid_609272 = header.getOrDefault("X-Amz-Security-Token")
  valid_609272 = validateParameter(valid_609272, JString, required = false,
                                 default = nil)
  if valid_609272 != nil:
    section.add "X-Amz-Security-Token", valid_609272
  var valid_609273 = header.getOrDefault("X-Amz-Algorithm")
  valid_609273 = validateParameter(valid_609273, JString, required = false,
                                 default = nil)
  if valid_609273 != nil:
    section.add "X-Amz-Algorithm", valid_609273
  var valid_609274 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_609274 = validateParameter(valid_609274, JString, required = false,
                                 default = nil)
  if valid_609274 != nil:
    section.add "X-Amz-SignedHeaders", valid_609274
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_609275: Call_GetResetClusterParameterGroup_609260; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Sets one or more parameters of the specified parameter group to their default values and sets the source values of the parameters to "engine-default". To reset the entire parameter group specify the <i>ResetAllParameters</i> parameter. For parameter changes to take effect you must reboot any associated clusters. 
  ## 
  let valid = call_609275.validator(path, query, header, formData, body)
  let scheme = call_609275.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_609275.url(scheme.get, call_609275.host, call_609275.base,
                         call_609275.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_609275, url, valid)

proc call*(call_609276: Call_GetResetClusterParameterGroup_609260;
          ParameterGroupName: string; Parameters: JsonNode = nil;
          ResetAllParameters: bool = false;
          Action: string = "ResetClusterParameterGroup";
          Version: string = "2012-12-01"): Recallable =
  ## getResetClusterParameterGroup
  ## Sets one or more parameters of the specified parameter group to their default values and sets the source values of the parameters to "engine-default". To reset the entire parameter group specify the <i>ResetAllParameters</i> parameter. For parameter changes to take effect you must reboot any associated clusters. 
  ##   Parameters: JArray
  ##             : <p>An array of names of parameters to be reset. If <i>ResetAllParameters</i> option is not used, then at least one parameter name must be supplied. </p> <p>Constraints: A maximum of 20 parameters can be reset in a single request.</p>
  ##   ResetAllParameters: bool
  ##                     : <p>If <code>true</code>, all parameters in the specified parameter group will be reset to their default values. </p> <p>Default: <code>true</code> </p>
  ##   Action: string (required)
  ##   ParameterGroupName: string (required)
  ##                     : The name of the cluster parameter group to be reset.
  ##   Version: string (required)
  var query_609277 = newJObject()
  if Parameters != nil:
    query_609277.add "Parameters", Parameters
  add(query_609277, "ResetAllParameters", newJBool(ResetAllParameters))
  add(query_609277, "Action", newJString(Action))
  add(query_609277, "ParameterGroupName", newJString(ParameterGroupName))
  add(query_609277, "Version", newJString(Version))
  result = call_609276.call(nil, query_609277, nil, nil, nil)

var getResetClusterParameterGroup* = Call_GetResetClusterParameterGroup_609260(
    name: "getResetClusterParameterGroup", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=ResetClusterParameterGroup",
    validator: validate_GetResetClusterParameterGroup_609261, base: "/",
    url: url_GetResetClusterParameterGroup_609262,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostResizeCluster_609317 = ref object of OpenApiRestCall_605573
proc url_PostResizeCluster_609319(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostResizeCluster_609318(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## <p>Changes the size of the cluster. You can change the cluster's type, or change the number or type of nodes. The default behavior is to use the elastic resize method. With an elastic resize, your cluster is available for read and write operations more quickly than with the classic resize method. </p> <p>Elastic resize operations have the following restrictions:</p> <ul> <li> <p>You can only resize clusters of the following types:</p> <ul> <li> <p>dc2.large</p> </li> <li> <p>dc2.8xlarge</p> </li> <li> <p>ds2.xlarge</p> </li> <li> <p>ds2.8xlarge</p> </li> <li> <p>ra3.16xlarge</p> </li> </ul> </li> <li> <p>The type of nodes that you add must match the node type for the cluster.</p> </li> </ul>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_609320 = query.getOrDefault("Action")
  valid_609320 = validateParameter(valid_609320, JString, required = true,
                                 default = newJString("ResizeCluster"))
  if valid_609320 != nil:
    section.add "Action", valid_609320
  var valid_609321 = query.getOrDefault("Version")
  valid_609321 = validateParameter(valid_609321, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_609321 != nil:
    section.add "Version", valid_609321
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_609322 = header.getOrDefault("X-Amz-Signature")
  valid_609322 = validateParameter(valid_609322, JString, required = false,
                                 default = nil)
  if valid_609322 != nil:
    section.add "X-Amz-Signature", valid_609322
  var valid_609323 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_609323 = validateParameter(valid_609323, JString, required = false,
                                 default = nil)
  if valid_609323 != nil:
    section.add "X-Amz-Content-Sha256", valid_609323
  var valid_609324 = header.getOrDefault("X-Amz-Date")
  valid_609324 = validateParameter(valid_609324, JString, required = false,
                                 default = nil)
  if valid_609324 != nil:
    section.add "X-Amz-Date", valid_609324
  var valid_609325 = header.getOrDefault("X-Amz-Credential")
  valid_609325 = validateParameter(valid_609325, JString, required = false,
                                 default = nil)
  if valid_609325 != nil:
    section.add "X-Amz-Credential", valid_609325
  var valid_609326 = header.getOrDefault("X-Amz-Security-Token")
  valid_609326 = validateParameter(valid_609326, JString, required = false,
                                 default = nil)
  if valid_609326 != nil:
    section.add "X-Amz-Security-Token", valid_609326
  var valid_609327 = header.getOrDefault("X-Amz-Algorithm")
  valid_609327 = validateParameter(valid_609327, JString, required = false,
                                 default = nil)
  if valid_609327 != nil:
    section.add "X-Amz-Algorithm", valid_609327
  var valid_609328 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_609328 = validateParameter(valid_609328, JString, required = false,
                                 default = nil)
  if valid_609328 != nil:
    section.add "X-Amz-SignedHeaders", valid_609328
  result.add "header", section
  ## parameters in `formData` object:
  ##   NodeType: JString
  ##           : The new node type for the nodes you are adding. If not specified, the cluster's current node type is used.
  ##   ClusterIdentifier: JString (required)
  ##                    : The unique identifier for the cluster to resize.
  ##   NumberOfNodes: JInt (required)
  ##                : The new number of nodes for the cluster.
  ##   ClusterType: JString
  ##              : The new cluster type for the specified cluster.
  ##   Classic: JBool
  ##          : A boolean value indicating whether the resize operation is using the classic resize process. If you don't provide this parameter or set the value to <code>false</code>, the resize type is elastic. 
  section = newJObject()
  var valid_609329 = formData.getOrDefault("NodeType")
  valid_609329 = validateParameter(valid_609329, JString, required = false,
                                 default = nil)
  if valid_609329 != nil:
    section.add "NodeType", valid_609329
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_609330 = formData.getOrDefault("ClusterIdentifier")
  valid_609330 = validateParameter(valid_609330, JString, required = true,
                                 default = nil)
  if valid_609330 != nil:
    section.add "ClusterIdentifier", valid_609330
  var valid_609331 = formData.getOrDefault("NumberOfNodes")
  valid_609331 = validateParameter(valid_609331, JInt, required = true, default = nil)
  if valid_609331 != nil:
    section.add "NumberOfNodes", valid_609331
  var valid_609332 = formData.getOrDefault("ClusterType")
  valid_609332 = validateParameter(valid_609332, JString, required = false,
                                 default = nil)
  if valid_609332 != nil:
    section.add "ClusterType", valid_609332
  var valid_609333 = formData.getOrDefault("Classic")
  valid_609333 = validateParameter(valid_609333, JBool, required = false, default = nil)
  if valid_609333 != nil:
    section.add "Classic", valid_609333
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_609334: Call_PostResizeCluster_609317; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Changes the size of the cluster. You can change the cluster's type, or change the number or type of nodes. The default behavior is to use the elastic resize method. With an elastic resize, your cluster is available for read and write operations more quickly than with the classic resize method. </p> <p>Elastic resize operations have the following restrictions:</p> <ul> <li> <p>You can only resize clusters of the following types:</p> <ul> <li> <p>dc2.large</p> </li> <li> <p>dc2.8xlarge</p> </li> <li> <p>ds2.xlarge</p> </li> <li> <p>ds2.8xlarge</p> </li> <li> <p>ra3.16xlarge</p> </li> </ul> </li> <li> <p>The type of nodes that you add must match the node type for the cluster.</p> </li> </ul>
  ## 
  let valid = call_609334.validator(path, query, header, formData, body)
  let scheme = call_609334.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_609334.url(scheme.get, call_609334.host, call_609334.base,
                         call_609334.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_609334, url, valid)

proc call*(call_609335: Call_PostResizeCluster_609317; ClusterIdentifier: string;
          NumberOfNodes: int; NodeType: string = ""; Action: string = "ResizeCluster";
          ClusterType: string = ""; Version: string = "2012-12-01";
          Classic: bool = false): Recallable =
  ## postResizeCluster
  ## <p>Changes the size of the cluster. You can change the cluster's type, or change the number or type of nodes. The default behavior is to use the elastic resize method. With an elastic resize, your cluster is available for read and write operations more quickly than with the classic resize method. </p> <p>Elastic resize operations have the following restrictions:</p> <ul> <li> <p>You can only resize clusters of the following types:</p> <ul> <li> <p>dc2.large</p> </li> <li> <p>dc2.8xlarge</p> </li> <li> <p>ds2.xlarge</p> </li> <li> <p>ds2.8xlarge</p> </li> <li> <p>ra3.16xlarge</p> </li> </ul> </li> <li> <p>The type of nodes that you add must match the node type for the cluster.</p> </li> </ul>
  ##   NodeType: string
  ##           : The new node type for the nodes you are adding. If not specified, the cluster's current node type is used.
  ##   ClusterIdentifier: string (required)
  ##                    : The unique identifier for the cluster to resize.
  ##   NumberOfNodes: int (required)
  ##                : The new number of nodes for the cluster.
  ##   Action: string (required)
  ##   ClusterType: string
  ##              : The new cluster type for the specified cluster.
  ##   Version: string (required)
  ##   Classic: bool
  ##          : A boolean value indicating whether the resize operation is using the classic resize process. If you don't provide this parameter or set the value to <code>false</code>, the resize type is elastic. 
  var query_609336 = newJObject()
  var formData_609337 = newJObject()
  add(formData_609337, "NodeType", newJString(NodeType))
  add(formData_609337, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_609337, "NumberOfNodes", newJInt(NumberOfNodes))
  add(query_609336, "Action", newJString(Action))
  add(formData_609337, "ClusterType", newJString(ClusterType))
  add(query_609336, "Version", newJString(Version))
  add(formData_609337, "Classic", newJBool(Classic))
  result = call_609335.call(nil, query_609336, nil, formData_609337, nil)

var postResizeCluster* = Call_PostResizeCluster_609317(name: "postResizeCluster",
    meth: HttpMethod.HttpPost, host: "redshift.amazonaws.com",
    route: "/#Action=ResizeCluster", validator: validate_PostResizeCluster_609318,
    base: "/", url: url_PostResizeCluster_609319,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetResizeCluster_609297 = ref object of OpenApiRestCall_605573
proc url_GetResizeCluster_609299(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetResizeCluster_609298(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## <p>Changes the size of the cluster. You can change the cluster's type, or change the number or type of nodes. The default behavior is to use the elastic resize method. With an elastic resize, your cluster is available for read and write operations more quickly than with the classic resize method. </p> <p>Elastic resize operations have the following restrictions:</p> <ul> <li> <p>You can only resize clusters of the following types:</p> <ul> <li> <p>dc2.large</p> </li> <li> <p>dc2.8xlarge</p> </li> <li> <p>ds2.xlarge</p> </li> <li> <p>ds2.8xlarge</p> </li> <li> <p>ra3.16xlarge</p> </li> </ul> </li> <li> <p>The type of nodes that you add must match the node type for the cluster.</p> </li> </ul>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   NodeType: JString
  ##           : The new node type for the nodes you are adding. If not specified, the cluster's current node type is used.
  ##   ClusterType: JString
  ##              : The new cluster type for the specified cluster.
  ##   NumberOfNodes: JInt (required)
  ##                : The new number of nodes for the cluster.
  ##   Classic: JBool
  ##          : A boolean value indicating whether the resize operation is using the classic resize process. If you don't provide this parameter or set the value to <code>false</code>, the resize type is elastic. 
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : The unique identifier for the cluster to resize.
  ##   Version: JString (required)
  section = newJObject()
  var valid_609300 = query.getOrDefault("NodeType")
  valid_609300 = validateParameter(valid_609300, JString, required = false,
                                 default = nil)
  if valid_609300 != nil:
    section.add "NodeType", valid_609300
  var valid_609301 = query.getOrDefault("ClusterType")
  valid_609301 = validateParameter(valid_609301, JString, required = false,
                                 default = nil)
  if valid_609301 != nil:
    section.add "ClusterType", valid_609301
  assert query != nil,
        "query argument is necessary due to required `NumberOfNodes` field"
  var valid_609302 = query.getOrDefault("NumberOfNodes")
  valid_609302 = validateParameter(valid_609302, JInt, required = true, default = nil)
  if valid_609302 != nil:
    section.add "NumberOfNodes", valid_609302
  var valid_609303 = query.getOrDefault("Classic")
  valid_609303 = validateParameter(valid_609303, JBool, required = false, default = nil)
  if valid_609303 != nil:
    section.add "Classic", valid_609303
  var valid_609304 = query.getOrDefault("Action")
  valid_609304 = validateParameter(valid_609304, JString, required = true,
                                 default = newJString("ResizeCluster"))
  if valid_609304 != nil:
    section.add "Action", valid_609304
  var valid_609305 = query.getOrDefault("ClusterIdentifier")
  valid_609305 = validateParameter(valid_609305, JString, required = true,
                                 default = nil)
  if valid_609305 != nil:
    section.add "ClusterIdentifier", valid_609305
  var valid_609306 = query.getOrDefault("Version")
  valid_609306 = validateParameter(valid_609306, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_609306 != nil:
    section.add "Version", valid_609306
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_609307 = header.getOrDefault("X-Amz-Signature")
  valid_609307 = validateParameter(valid_609307, JString, required = false,
                                 default = nil)
  if valid_609307 != nil:
    section.add "X-Amz-Signature", valid_609307
  var valid_609308 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_609308 = validateParameter(valid_609308, JString, required = false,
                                 default = nil)
  if valid_609308 != nil:
    section.add "X-Amz-Content-Sha256", valid_609308
  var valid_609309 = header.getOrDefault("X-Amz-Date")
  valid_609309 = validateParameter(valid_609309, JString, required = false,
                                 default = nil)
  if valid_609309 != nil:
    section.add "X-Amz-Date", valid_609309
  var valid_609310 = header.getOrDefault("X-Amz-Credential")
  valid_609310 = validateParameter(valid_609310, JString, required = false,
                                 default = nil)
  if valid_609310 != nil:
    section.add "X-Amz-Credential", valid_609310
  var valid_609311 = header.getOrDefault("X-Amz-Security-Token")
  valid_609311 = validateParameter(valid_609311, JString, required = false,
                                 default = nil)
  if valid_609311 != nil:
    section.add "X-Amz-Security-Token", valid_609311
  var valid_609312 = header.getOrDefault("X-Amz-Algorithm")
  valid_609312 = validateParameter(valid_609312, JString, required = false,
                                 default = nil)
  if valid_609312 != nil:
    section.add "X-Amz-Algorithm", valid_609312
  var valid_609313 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_609313 = validateParameter(valid_609313, JString, required = false,
                                 default = nil)
  if valid_609313 != nil:
    section.add "X-Amz-SignedHeaders", valid_609313
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_609314: Call_GetResizeCluster_609297; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Changes the size of the cluster. You can change the cluster's type, or change the number or type of nodes. The default behavior is to use the elastic resize method. With an elastic resize, your cluster is available for read and write operations more quickly than with the classic resize method. </p> <p>Elastic resize operations have the following restrictions:</p> <ul> <li> <p>You can only resize clusters of the following types:</p> <ul> <li> <p>dc2.large</p> </li> <li> <p>dc2.8xlarge</p> </li> <li> <p>ds2.xlarge</p> </li> <li> <p>ds2.8xlarge</p> </li> <li> <p>ra3.16xlarge</p> </li> </ul> </li> <li> <p>The type of nodes that you add must match the node type for the cluster.</p> </li> </ul>
  ## 
  let valid = call_609314.validator(path, query, header, formData, body)
  let scheme = call_609314.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_609314.url(scheme.get, call_609314.host, call_609314.base,
                         call_609314.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_609314, url, valid)

proc call*(call_609315: Call_GetResizeCluster_609297; NumberOfNodes: int;
          ClusterIdentifier: string; NodeType: string = ""; ClusterType: string = "";
          Classic: bool = false; Action: string = "ResizeCluster";
          Version: string = "2012-12-01"): Recallable =
  ## getResizeCluster
  ## <p>Changes the size of the cluster. You can change the cluster's type, or change the number or type of nodes. The default behavior is to use the elastic resize method. With an elastic resize, your cluster is available for read and write operations more quickly than with the classic resize method. </p> <p>Elastic resize operations have the following restrictions:</p> <ul> <li> <p>You can only resize clusters of the following types:</p> <ul> <li> <p>dc2.large</p> </li> <li> <p>dc2.8xlarge</p> </li> <li> <p>ds2.xlarge</p> </li> <li> <p>ds2.8xlarge</p> </li> <li> <p>ra3.16xlarge</p> </li> </ul> </li> <li> <p>The type of nodes that you add must match the node type for the cluster.</p> </li> </ul>
  ##   NodeType: string
  ##           : The new node type for the nodes you are adding. If not specified, the cluster's current node type is used.
  ##   ClusterType: string
  ##              : The new cluster type for the specified cluster.
  ##   NumberOfNodes: int (required)
  ##                : The new number of nodes for the cluster.
  ##   Classic: bool
  ##          : A boolean value indicating whether the resize operation is using the classic resize process. If you don't provide this parameter or set the value to <code>false</code>, the resize type is elastic. 
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : The unique identifier for the cluster to resize.
  ##   Version: string (required)
  var query_609316 = newJObject()
  add(query_609316, "NodeType", newJString(NodeType))
  add(query_609316, "ClusterType", newJString(ClusterType))
  add(query_609316, "NumberOfNodes", newJInt(NumberOfNodes))
  add(query_609316, "Classic", newJBool(Classic))
  add(query_609316, "Action", newJString(Action))
  add(query_609316, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_609316, "Version", newJString(Version))
  result = call_609315.call(nil, query_609316, nil, nil, nil)

var getResizeCluster* = Call_GetResizeCluster_609297(name: "getResizeCluster",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=ResizeCluster", validator: validate_GetResizeCluster_609298,
    base: "/", url: url_GetResizeCluster_609299,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostRestoreFromClusterSnapshot_609379 = ref object of OpenApiRestCall_605573
proc url_PostRestoreFromClusterSnapshot_609381(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostRestoreFromClusterSnapshot_609380(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a new cluster from a snapshot. By default, Amazon Redshift creates the resulting cluster with the same configuration as the original cluster from which the snapshot was created, except that the new cluster is created with the default cluster security and parameter groups. After Amazon Redshift creates the cluster, you can use the <a>ModifyCluster</a> API to associate a different security group and different parameter group with the restored cluster. If you are using a DS node type, you can also choose to change to another DS node type of the same size during restore.</p> <p>If you restore a cluster into a VPC, you must provide a cluster subnet group where you want the cluster restored.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_609382 = query.getOrDefault("Action")
  valid_609382 = validateParameter(valid_609382, JString, required = true, default = newJString(
      "RestoreFromClusterSnapshot"))
  if valid_609382 != nil:
    section.add "Action", valid_609382
  var valid_609383 = query.getOrDefault("Version")
  valid_609383 = validateParameter(valid_609383, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_609383 != nil:
    section.add "Version", valid_609383
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_609384 = header.getOrDefault("X-Amz-Signature")
  valid_609384 = validateParameter(valid_609384, JString, required = false,
                                 default = nil)
  if valid_609384 != nil:
    section.add "X-Amz-Signature", valid_609384
  var valid_609385 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_609385 = validateParameter(valid_609385, JString, required = false,
                                 default = nil)
  if valid_609385 != nil:
    section.add "X-Amz-Content-Sha256", valid_609385
  var valid_609386 = header.getOrDefault("X-Amz-Date")
  valid_609386 = validateParameter(valid_609386, JString, required = false,
                                 default = nil)
  if valid_609386 != nil:
    section.add "X-Amz-Date", valid_609386
  var valid_609387 = header.getOrDefault("X-Amz-Credential")
  valid_609387 = validateParameter(valid_609387, JString, required = false,
                                 default = nil)
  if valid_609387 != nil:
    section.add "X-Amz-Credential", valid_609387
  var valid_609388 = header.getOrDefault("X-Amz-Security-Token")
  valid_609388 = validateParameter(valid_609388, JString, required = false,
                                 default = nil)
  if valid_609388 != nil:
    section.add "X-Amz-Security-Token", valid_609388
  var valid_609389 = header.getOrDefault("X-Amz-Algorithm")
  valid_609389 = validateParameter(valid_609389, JString, required = false,
                                 default = nil)
  if valid_609389 != nil:
    section.add "X-Amz-Algorithm", valid_609389
  var valid_609390 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_609390 = validateParameter(valid_609390, JString, required = false,
                                 default = nil)
  if valid_609390 != nil:
    section.add "X-Amz-SignedHeaders", valid_609390
  result.add "header", section
  ## parameters in `formData` object:
  ##   Port: JInt
  ##       : <p>The port number on which the cluster accepts connections.</p> <p>Default: The same port as the original cluster.</p> <p>Constraints: Must be between <code>1115</code> and <code>65535</code>.</p>
  ##   PreferredMaintenanceWindow: JString
  ##                             : <p>The weekly time range (in UTC) during which automated cluster maintenance can occur.</p> <p> Format: <code>ddd:hh24:mi-ddd:hh24:mi</code> </p> <p> Default: The value selected for the cluster from which the snapshot was taken. For more information about the time blocks for each region, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-maintenance-windows">Maintenance Windows</a> in Amazon Redshift Cluster Management Guide. </p> <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p> <p>Constraints: Minimum 30-minute window.</p>
  ##   NodeType: JString
  ##           : <p>The node type that the restored cluster will be provisioned with.</p> <p>Default: The node type of the cluster from which the snapshot was taken. You can modify this if you are using any DS node type. In that case, you can choose to restore into another DS node type of the same size. For example, you can restore ds1.8xlarge into ds2.8xlarge, or ds1.xlarge into ds2.xlarge. If you have a DC instance type, you must restore into that same instance type and size. In other words, you can only restore a dc1.large instance type into another dc1.large instance type or dc2.large instance type. You can't restore dc1.8xlarge to dc2.8xlarge. First restore to a dc1.8xlareg cluster, then resize to a dc2.8large cluster. For more information about node types, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-about-clusters-and-nodes"> About Clusters and Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The identifier of the cluster that will be created from restoring the snapshot.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul>
  ##   MaintenanceTrackName: JString
  ##                       : The name of the maintenance track for the restored cluster. When you take a snapshot, the snapshot inherits the <code>MaintenanceTrack</code> value from the cluster. The snapshot might be on a different track than the cluster that was the source for the snapshot. For example, suppose that you take a snapshot of a cluster that is on the current track and then change the cluster to be on the trailing track. In this case, the snapshot and the source cluster are on different tracks.
  ##   ClusterSecurityGroups: JArray
  ##                        : <p>A list of security groups to be associated with this cluster.</p> <p>Default: The default cluster security group for Amazon Redshift.</p> <p>Cluster security groups only apply to clusters outside of VPCs.</p>
  ##   IamRoles: JArray
  ##           : <p>A list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services. You must supply the IAM roles in their Amazon Resource Name (ARN) format. You can supply up to 10 IAM roles in a single request.</p> <p>A cluster can have up to 10 IAM roles associated at any time.</p>
  ##   OwnerAccount: JString
  ##               : The AWS customer account used to create or copy the snapshot. Required if you are restoring a snapshot you do not own, optional if you own the snapshot.
  ##   VpcSecurityGroupIds: JArray
  ##                      : <p>A list of Virtual Private Cloud (VPC) security groups to be associated with the cluster.</p> <p>Default: The default VPC security group is associated with the cluster.</p> <p>VPC security groups only apply to clusters in VPCs.</p>
  ##   AutomatedSnapshotRetentionPeriod: JInt
  ##                                   : <p>The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p> <p>Default: The value selected for the cluster from which the snapshot was taken.</p> <p>Constraints: Must be a value from 0 to 35.</p>
  ##   AvailabilityZone: JString
  ##                   : <p>The Amazon EC2 Availability Zone in which to restore the cluster.</p> <p>Default: A random, system-chosen Availability Zone.</p> <p>Example: <code>us-east-2a</code> </p>
  ##   EnhancedVpcRouting: JBool
  ##                     : <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p> <p>Default: false</p>
  ##   KmsKeyId: JString
  ##           : The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster that you restore from a shared snapshot.
  ##   NumberOfNodes: JInt
  ##                : The number of nodes specified when provisioning the restored cluster.
  ##   ClusterSubnetGroupName: JString
  ##                         : <p>The name of the subnet group where you want to cluster restored.</p> <p>A snapshot of cluster in VPC can be restored only in VPC. Therefore, you must provide subnet group name where you want the cluster restored.</p>
  ##   AllowVersionUpgrade: JBool
  ##                      : <p>If <code>true</code>, major version upgrades can be applied during the maintenance window to the Amazon Redshift engine that is running on the cluster. </p> <p>Default: <code>true</code> </p>
  ##   SnapshotIdentifier: JString (required)
  ##                     : <p>The name of the snapshot from which to create the new cluster. This parameter isn't case sensitive.</p> <p>Example: <code>my-snapshot-id</code> </p>
  ##   PubliclyAccessible: JBool
  ##                     : If <code>true</code>, the cluster can be accessed from a public network. 
  ##   ClusterParameterGroupName: JString
  ##                            : <p>The name of the parameter group to be associated with this cluster.</p> <p>Default: The default Amazon Redshift cluster parameter group. For information about the default parameter group, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Working with Amazon Redshift Parameter Groups</a>.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   HsmClientCertificateIdentifier: JString
  ##                                 : Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM.
  ##   SnapshotClusterIdentifier: JString
  ##                            : The name of the cluster the source snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.
  ##   AdditionalInfo: JString
  ##                 : Reserved.
  ##   SnapshotScheduleIdentifier: JString
  ##                             : A unique identifier for the snapshot schedule.
  ##   ElasticIp: JString
  ##            : The elastic IP (EIP) address for the cluster.
  ##   HsmConfigurationIdentifier: JString
  ##                             : Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The default number of days to retain a manual snapshot. If the value is -1, the snapshot is retained indefinitely. This setting doesn't change the retention period of existing snapshots.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  section = newJObject()
  var valid_609391 = formData.getOrDefault("Port")
  valid_609391 = validateParameter(valid_609391, JInt, required = false, default = nil)
  if valid_609391 != nil:
    section.add "Port", valid_609391
  var valid_609392 = formData.getOrDefault("PreferredMaintenanceWindow")
  valid_609392 = validateParameter(valid_609392, JString, required = false,
                                 default = nil)
  if valid_609392 != nil:
    section.add "PreferredMaintenanceWindow", valid_609392
  var valid_609393 = formData.getOrDefault("NodeType")
  valid_609393 = validateParameter(valid_609393, JString, required = false,
                                 default = nil)
  if valid_609393 != nil:
    section.add "NodeType", valid_609393
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_609394 = formData.getOrDefault("ClusterIdentifier")
  valid_609394 = validateParameter(valid_609394, JString, required = true,
                                 default = nil)
  if valid_609394 != nil:
    section.add "ClusterIdentifier", valid_609394
  var valid_609395 = formData.getOrDefault("MaintenanceTrackName")
  valid_609395 = validateParameter(valid_609395, JString, required = false,
                                 default = nil)
  if valid_609395 != nil:
    section.add "MaintenanceTrackName", valid_609395
  var valid_609396 = formData.getOrDefault("ClusterSecurityGroups")
  valid_609396 = validateParameter(valid_609396, JArray, required = false,
                                 default = nil)
  if valid_609396 != nil:
    section.add "ClusterSecurityGroups", valid_609396
  var valid_609397 = formData.getOrDefault("IamRoles")
  valid_609397 = validateParameter(valid_609397, JArray, required = false,
                                 default = nil)
  if valid_609397 != nil:
    section.add "IamRoles", valid_609397
  var valid_609398 = formData.getOrDefault("OwnerAccount")
  valid_609398 = validateParameter(valid_609398, JString, required = false,
                                 default = nil)
  if valid_609398 != nil:
    section.add "OwnerAccount", valid_609398
  var valid_609399 = formData.getOrDefault("VpcSecurityGroupIds")
  valid_609399 = validateParameter(valid_609399, JArray, required = false,
                                 default = nil)
  if valid_609399 != nil:
    section.add "VpcSecurityGroupIds", valid_609399
  var valid_609400 = formData.getOrDefault("AutomatedSnapshotRetentionPeriod")
  valid_609400 = validateParameter(valid_609400, JInt, required = false, default = nil)
  if valid_609400 != nil:
    section.add "AutomatedSnapshotRetentionPeriod", valid_609400
  var valid_609401 = formData.getOrDefault("AvailabilityZone")
  valid_609401 = validateParameter(valid_609401, JString, required = false,
                                 default = nil)
  if valid_609401 != nil:
    section.add "AvailabilityZone", valid_609401
  var valid_609402 = formData.getOrDefault("EnhancedVpcRouting")
  valid_609402 = validateParameter(valid_609402, JBool, required = false, default = nil)
  if valid_609402 != nil:
    section.add "EnhancedVpcRouting", valid_609402
  var valid_609403 = formData.getOrDefault("KmsKeyId")
  valid_609403 = validateParameter(valid_609403, JString, required = false,
                                 default = nil)
  if valid_609403 != nil:
    section.add "KmsKeyId", valid_609403
  var valid_609404 = formData.getOrDefault("NumberOfNodes")
  valid_609404 = validateParameter(valid_609404, JInt, required = false, default = nil)
  if valid_609404 != nil:
    section.add "NumberOfNodes", valid_609404
  var valid_609405 = formData.getOrDefault("ClusterSubnetGroupName")
  valid_609405 = validateParameter(valid_609405, JString, required = false,
                                 default = nil)
  if valid_609405 != nil:
    section.add "ClusterSubnetGroupName", valid_609405
  var valid_609406 = formData.getOrDefault("AllowVersionUpgrade")
  valid_609406 = validateParameter(valid_609406, JBool, required = false, default = nil)
  if valid_609406 != nil:
    section.add "AllowVersionUpgrade", valid_609406
  var valid_609407 = formData.getOrDefault("SnapshotIdentifier")
  valid_609407 = validateParameter(valid_609407, JString, required = true,
                                 default = nil)
  if valid_609407 != nil:
    section.add "SnapshotIdentifier", valid_609407
  var valid_609408 = formData.getOrDefault("PubliclyAccessible")
  valid_609408 = validateParameter(valid_609408, JBool, required = false, default = nil)
  if valid_609408 != nil:
    section.add "PubliclyAccessible", valid_609408
  var valid_609409 = formData.getOrDefault("ClusterParameterGroupName")
  valid_609409 = validateParameter(valid_609409, JString, required = false,
                                 default = nil)
  if valid_609409 != nil:
    section.add "ClusterParameterGroupName", valid_609409
  var valid_609410 = formData.getOrDefault("HsmClientCertificateIdentifier")
  valid_609410 = validateParameter(valid_609410, JString, required = false,
                                 default = nil)
  if valid_609410 != nil:
    section.add "HsmClientCertificateIdentifier", valid_609410
  var valid_609411 = formData.getOrDefault("SnapshotClusterIdentifier")
  valid_609411 = validateParameter(valid_609411, JString, required = false,
                                 default = nil)
  if valid_609411 != nil:
    section.add "SnapshotClusterIdentifier", valid_609411
  var valid_609412 = formData.getOrDefault("AdditionalInfo")
  valid_609412 = validateParameter(valid_609412, JString, required = false,
                                 default = nil)
  if valid_609412 != nil:
    section.add "AdditionalInfo", valid_609412
  var valid_609413 = formData.getOrDefault("SnapshotScheduleIdentifier")
  valid_609413 = validateParameter(valid_609413, JString, required = false,
                                 default = nil)
  if valid_609413 != nil:
    section.add "SnapshotScheduleIdentifier", valid_609413
  var valid_609414 = formData.getOrDefault("ElasticIp")
  valid_609414 = validateParameter(valid_609414, JString, required = false,
                                 default = nil)
  if valid_609414 != nil:
    section.add "ElasticIp", valid_609414
  var valid_609415 = formData.getOrDefault("HsmConfigurationIdentifier")
  valid_609415 = validateParameter(valid_609415, JString, required = false,
                                 default = nil)
  if valid_609415 != nil:
    section.add "HsmConfigurationIdentifier", valid_609415
  var valid_609416 = formData.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_609416 = validateParameter(valid_609416, JInt, required = false, default = nil)
  if valid_609416 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_609416
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_609417: Call_PostRestoreFromClusterSnapshot_609379; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a new cluster from a snapshot. By default, Amazon Redshift creates the resulting cluster with the same configuration as the original cluster from which the snapshot was created, except that the new cluster is created with the default cluster security and parameter groups. After Amazon Redshift creates the cluster, you can use the <a>ModifyCluster</a> API to associate a different security group and different parameter group with the restored cluster. If you are using a DS node type, you can also choose to change to another DS node type of the same size during restore.</p> <p>If you restore a cluster into a VPC, you must provide a cluster subnet group where you want the cluster restored.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_609417.validator(path, query, header, formData, body)
  let scheme = call_609417.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_609417.url(scheme.get, call_609417.host, call_609417.base,
                         call_609417.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_609417, url, valid)

proc call*(call_609418: Call_PostRestoreFromClusterSnapshot_609379;
          ClusterIdentifier: string; SnapshotIdentifier: string; Port: int = 0;
          PreferredMaintenanceWindow: string = ""; NodeType: string = "";
          MaintenanceTrackName: string = ""; ClusterSecurityGroups: JsonNode = nil;
          IamRoles: JsonNode = nil; OwnerAccount: string = "";
          VpcSecurityGroupIds: JsonNode = nil;
          AutomatedSnapshotRetentionPeriod: int = 0; AvailabilityZone: string = "";
          EnhancedVpcRouting: bool = false; KmsKeyId: string = "";
          NumberOfNodes: int = 0; ClusterSubnetGroupName: string = "";
          AllowVersionUpgrade: bool = false; PubliclyAccessible: bool = false;
          Action: string = "RestoreFromClusterSnapshot";
          ClusterParameterGroupName: string = "";
          HsmClientCertificateIdentifier: string = "";
          SnapshotClusterIdentifier: string = ""; AdditionalInfo: string = "";
          SnapshotScheduleIdentifier: string = ""; Version: string = "2012-12-01";
          ElasticIp: string = ""; HsmConfigurationIdentifier: string = "";
          ManualSnapshotRetentionPeriod: int = 0): Recallable =
  ## postRestoreFromClusterSnapshot
  ## <p>Creates a new cluster from a snapshot. By default, Amazon Redshift creates the resulting cluster with the same configuration as the original cluster from which the snapshot was created, except that the new cluster is created with the default cluster security and parameter groups. After Amazon Redshift creates the cluster, you can use the <a>ModifyCluster</a> API to associate a different security group and different parameter group with the restored cluster. If you are using a DS node type, you can also choose to change to another DS node type of the same size during restore.</p> <p>If you restore a cluster into a VPC, you must provide a cluster subnet group where you want the cluster restored.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   Port: int
  ##       : <p>The port number on which the cluster accepts connections.</p> <p>Default: The same port as the original cluster.</p> <p>Constraints: Must be between <code>1115</code> and <code>65535</code>.</p>
  ##   PreferredMaintenanceWindow: string
  ##                             : <p>The weekly time range (in UTC) during which automated cluster maintenance can occur.</p> <p> Format: <code>ddd:hh24:mi-ddd:hh24:mi</code> </p> <p> Default: The value selected for the cluster from which the snapshot was taken. For more information about the time blocks for each region, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-maintenance-windows">Maintenance Windows</a> in Amazon Redshift Cluster Management Guide. </p> <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p> <p>Constraints: Minimum 30-minute window.</p>
  ##   NodeType: string
  ##           : <p>The node type that the restored cluster will be provisioned with.</p> <p>Default: The node type of the cluster from which the snapshot was taken. You can modify this if you are using any DS node type. In that case, you can choose to restore into another DS node type of the same size. For example, you can restore ds1.8xlarge into ds2.8xlarge, or ds1.xlarge into ds2.xlarge. If you have a DC instance type, you must restore into that same instance type and size. In other words, you can only restore a dc1.large instance type into another dc1.large instance type or dc2.large instance type. You can't restore dc1.8xlarge to dc2.8xlarge. First restore to a dc1.8xlareg cluster, then resize to a dc2.8large cluster. For more information about node types, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-about-clusters-and-nodes"> About Clusters and Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The identifier of the cluster that will be created from restoring the snapshot.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul>
  ##   MaintenanceTrackName: string
  ##                       : The name of the maintenance track for the restored cluster. When you take a snapshot, the snapshot inherits the <code>MaintenanceTrack</code> value from the cluster. The snapshot might be on a different track than the cluster that was the source for the snapshot. For example, suppose that you take a snapshot of a cluster that is on the current track and then change the cluster to be on the trailing track. In this case, the snapshot and the source cluster are on different tracks.
  ##   ClusterSecurityGroups: JArray
  ##                        : <p>A list of security groups to be associated with this cluster.</p> <p>Default: The default cluster security group for Amazon Redshift.</p> <p>Cluster security groups only apply to clusters outside of VPCs.</p>
  ##   IamRoles: JArray
  ##           : <p>A list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services. You must supply the IAM roles in their Amazon Resource Name (ARN) format. You can supply up to 10 IAM roles in a single request.</p> <p>A cluster can have up to 10 IAM roles associated at any time.</p>
  ##   OwnerAccount: string
  ##               : The AWS customer account used to create or copy the snapshot. Required if you are restoring a snapshot you do not own, optional if you own the snapshot.
  ##   VpcSecurityGroupIds: JArray
  ##                      : <p>A list of Virtual Private Cloud (VPC) security groups to be associated with the cluster.</p> <p>Default: The default VPC security group is associated with the cluster.</p> <p>VPC security groups only apply to clusters in VPCs.</p>
  ##   AutomatedSnapshotRetentionPeriod: int
  ##                                   : <p>The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p> <p>Default: The value selected for the cluster from which the snapshot was taken.</p> <p>Constraints: Must be a value from 0 to 35.</p>
  ##   AvailabilityZone: string
  ##                   : <p>The Amazon EC2 Availability Zone in which to restore the cluster.</p> <p>Default: A random, system-chosen Availability Zone.</p> <p>Example: <code>us-east-2a</code> </p>
  ##   EnhancedVpcRouting: bool
  ##                     : <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p> <p>Default: false</p>
  ##   KmsKeyId: string
  ##           : The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster that you restore from a shared snapshot.
  ##   NumberOfNodes: int
  ##                : The number of nodes specified when provisioning the restored cluster.
  ##   ClusterSubnetGroupName: string
  ##                         : <p>The name of the subnet group where you want to cluster restored.</p> <p>A snapshot of cluster in VPC can be restored only in VPC. Therefore, you must provide subnet group name where you want the cluster restored.</p>
  ##   AllowVersionUpgrade: bool
  ##                      : <p>If <code>true</code>, major version upgrades can be applied during the maintenance window to the Amazon Redshift engine that is running on the cluster. </p> <p>Default: <code>true</code> </p>
  ##   SnapshotIdentifier: string (required)
  ##                     : <p>The name of the snapshot from which to create the new cluster. This parameter isn't case sensitive.</p> <p>Example: <code>my-snapshot-id</code> </p>
  ##   PubliclyAccessible: bool
  ##                     : If <code>true</code>, the cluster can be accessed from a public network. 
  ##   Action: string (required)
  ##   ClusterParameterGroupName: string
  ##                            : <p>The name of the parameter group to be associated with this cluster.</p> <p>Default: The default Amazon Redshift cluster parameter group. For information about the default parameter group, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Working with Amazon Redshift Parameter Groups</a>.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   HsmClientCertificateIdentifier: string
  ##                                 : Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM.
  ##   SnapshotClusterIdentifier: string
  ##                            : The name of the cluster the source snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.
  ##   AdditionalInfo: string
  ##                 : Reserved.
  ##   SnapshotScheduleIdentifier: string
  ##                             : A unique identifier for the snapshot schedule.
  ##   Version: string (required)
  ##   ElasticIp: string
  ##            : The elastic IP (EIP) address for the cluster.
  ##   HsmConfigurationIdentifier: string
  ##                             : Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The default number of days to retain a manual snapshot. If the value is -1, the snapshot is retained indefinitely. This setting doesn't change the retention period of existing snapshots.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  var query_609419 = newJObject()
  var formData_609420 = newJObject()
  add(formData_609420, "Port", newJInt(Port))
  add(formData_609420, "PreferredMaintenanceWindow",
      newJString(PreferredMaintenanceWindow))
  add(formData_609420, "NodeType", newJString(NodeType))
  add(formData_609420, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_609420, "MaintenanceTrackName", newJString(MaintenanceTrackName))
  if ClusterSecurityGroups != nil:
    formData_609420.add "ClusterSecurityGroups", ClusterSecurityGroups
  if IamRoles != nil:
    formData_609420.add "IamRoles", IamRoles
  add(formData_609420, "OwnerAccount", newJString(OwnerAccount))
  if VpcSecurityGroupIds != nil:
    formData_609420.add "VpcSecurityGroupIds", VpcSecurityGroupIds
  add(formData_609420, "AutomatedSnapshotRetentionPeriod",
      newJInt(AutomatedSnapshotRetentionPeriod))
  add(formData_609420, "AvailabilityZone", newJString(AvailabilityZone))
  add(formData_609420, "EnhancedVpcRouting", newJBool(EnhancedVpcRouting))
  add(formData_609420, "KmsKeyId", newJString(KmsKeyId))
  add(formData_609420, "NumberOfNodes", newJInt(NumberOfNodes))
  add(formData_609420, "ClusterSubnetGroupName",
      newJString(ClusterSubnetGroupName))
  add(formData_609420, "AllowVersionUpgrade", newJBool(AllowVersionUpgrade))
  add(formData_609420, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(formData_609420, "PubliclyAccessible", newJBool(PubliclyAccessible))
  add(query_609419, "Action", newJString(Action))
  add(formData_609420, "ClusterParameterGroupName",
      newJString(ClusterParameterGroupName))
  add(formData_609420, "HsmClientCertificateIdentifier",
      newJString(HsmClientCertificateIdentifier))
  add(formData_609420, "SnapshotClusterIdentifier",
      newJString(SnapshotClusterIdentifier))
  add(formData_609420, "AdditionalInfo", newJString(AdditionalInfo))
  add(formData_609420, "SnapshotScheduleIdentifier",
      newJString(SnapshotScheduleIdentifier))
  add(query_609419, "Version", newJString(Version))
  add(formData_609420, "ElasticIp", newJString(ElasticIp))
  add(formData_609420, "HsmConfigurationIdentifier",
      newJString(HsmConfigurationIdentifier))
  add(formData_609420, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  result = call_609418.call(nil, query_609419, nil, formData_609420, nil)

var postRestoreFromClusterSnapshot* = Call_PostRestoreFromClusterSnapshot_609379(
    name: "postRestoreFromClusterSnapshot", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=RestoreFromClusterSnapshot",
    validator: validate_PostRestoreFromClusterSnapshot_609380, base: "/",
    url: url_PostRestoreFromClusterSnapshot_609381,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetRestoreFromClusterSnapshot_609338 = ref object of OpenApiRestCall_605573
proc url_GetRestoreFromClusterSnapshot_609340(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetRestoreFromClusterSnapshot_609339(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a new cluster from a snapshot. By default, Amazon Redshift creates the resulting cluster with the same configuration as the original cluster from which the snapshot was created, except that the new cluster is created with the default cluster security and parameter groups. After Amazon Redshift creates the cluster, you can use the <a>ModifyCluster</a> API to associate a different security group and different parameter group with the restored cluster. If you are using a DS node type, you can also choose to change to another DS node type of the same size during restore.</p> <p>If you restore a cluster into a VPC, you must provide a cluster subnet group where you want the cluster restored.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ClusterSubnetGroupName: JString
  ##                         : <p>The name of the subnet group where you want to cluster restored.</p> <p>A snapshot of cluster in VPC can be restored only in VPC. Therefore, you must provide subnet group name where you want the cluster restored.</p>
  ##   MaintenanceTrackName: JString
  ##                       : The name of the maintenance track for the restored cluster. When you take a snapshot, the snapshot inherits the <code>MaintenanceTrack</code> value from the cluster. The snapshot might be on a different track than the cluster that was the source for the snapshot. For example, suppose that you take a snapshot of a cluster that is on the current track and then change the cluster to be on the trailing track. In this case, the snapshot and the source cluster are on different tracks.
  ##   SnapshotIdentifier: JString (required)
  ##                     : <p>The name of the snapshot from which to create the new cluster. This parameter isn't case sensitive.</p> <p>Example: <code>my-snapshot-id</code> </p>
  ##   HsmClientCertificateIdentifier: JString
  ##                                 : Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM.
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The default number of days to retain a manual snapshot. If the value is -1, the snapshot is retained indefinitely. This setting doesn't change the retention period of existing snapshots.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  ##   ClusterSecurityGroups: JArray
  ##                        : <p>A list of security groups to be associated with this cluster.</p> <p>Default: The default cluster security group for Amazon Redshift.</p> <p>Cluster security groups only apply to clusters outside of VPCs.</p>
  ##   KmsKeyId: JString
  ##           : The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster that you restore from a shared snapshot.
  ##   ClusterParameterGroupName: JString
  ##                            : <p>The name of the parameter group to be associated with this cluster.</p> <p>Default: The default Amazon Redshift cluster parameter group. For information about the default parameter group, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Working with Amazon Redshift Parameter Groups</a>.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   NodeType: JString
  ##           : <p>The node type that the restored cluster will be provisioned with.</p> <p>Default: The node type of the cluster from which the snapshot was taken. You can modify this if you are using any DS node type. In that case, you can choose to restore into another DS node type of the same size. For example, you can restore ds1.8xlarge into ds2.8xlarge, or ds1.xlarge into ds2.xlarge. If you have a DC instance type, you must restore into that same instance type and size. In other words, you can only restore a dc1.large instance type into another dc1.large instance type or dc2.large instance type. You can't restore dc1.8xlarge to dc2.8xlarge. First restore to a dc1.8xlareg cluster, then resize to a dc2.8large cluster. For more information about node types, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-about-clusters-and-nodes"> About Clusters and Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ##   SnapshotScheduleIdentifier: JString
  ##                             : A unique identifier for the snapshot schedule.
  ##   IamRoles: JArray
  ##           : <p>A list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services. You must supply the IAM roles in their Amazon Resource Name (ARN) format. You can supply up to 10 IAM roles in a single request.</p> <p>A cluster can have up to 10 IAM roles associated at any time.</p>
  ##   NumberOfNodes: JInt
  ##                : The number of nodes specified when provisioning the restored cluster.
  ##   AdditionalInfo: JString
  ##                 : Reserved.
  ##   SnapshotClusterIdentifier: JString
  ##                            : The name of the cluster the source snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.
  ##   AllowVersionUpgrade: JBool
  ##                      : <p>If <code>true</code>, major version upgrades can be applied during the maintenance window to the Amazon Redshift engine that is running on the cluster. </p> <p>Default: <code>true</code> </p>
  ##   ElasticIp: JString
  ##            : The elastic IP (EIP) address for the cluster.
  ##   AutomatedSnapshotRetentionPeriod: JInt
  ##                                   : <p>The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p> <p>Default: The value selected for the cluster from which the snapshot was taken.</p> <p>Constraints: Must be a value from 0 to 35.</p>
  ##   EnhancedVpcRouting: JBool
  ##                     : <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p> <p>Default: false</p>
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The identifier of the cluster that will be created from restoring the snapshot.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul>
  ##   Port: JInt
  ##       : <p>The port number on which the cluster accepts connections.</p> <p>Default: The same port as the original cluster.</p> <p>Constraints: Must be between <code>1115</code> and <code>65535</code>.</p>
  ##   VpcSecurityGroupIds: JArray
  ##                      : <p>A list of Virtual Private Cloud (VPC) security groups to be associated with the cluster.</p> <p>Default: The default VPC security group is associated with the cluster.</p> <p>VPC security groups only apply to clusters in VPCs.</p>
  ##   AvailabilityZone: JString
  ##                   : <p>The Amazon EC2 Availability Zone in which to restore the cluster.</p> <p>Default: A random, system-chosen Availability Zone.</p> <p>Example: <code>us-east-2a</code> </p>
  ##   HsmConfigurationIdentifier: JString
  ##                             : Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
  ##   OwnerAccount: JString
  ##               : The AWS customer account used to create or copy the snapshot. Required if you are restoring a snapshot you do not own, optional if you own the snapshot.
  ##   Version: JString (required)
  ##   PreferredMaintenanceWindow: JString
  ##                             : <p>The weekly time range (in UTC) during which automated cluster maintenance can occur.</p> <p> Format: <code>ddd:hh24:mi-ddd:hh24:mi</code> </p> <p> Default: The value selected for the cluster from which the snapshot was taken. For more information about the time blocks for each region, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-maintenance-windows">Maintenance Windows</a> in Amazon Redshift Cluster Management Guide. </p> <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p> <p>Constraints: Minimum 30-minute window.</p>
  ##   PubliclyAccessible: JBool
  ##                     : If <code>true</code>, the cluster can be accessed from a public network. 
  section = newJObject()
  var valid_609341 = query.getOrDefault("ClusterSubnetGroupName")
  valid_609341 = validateParameter(valid_609341, JString, required = false,
                                 default = nil)
  if valid_609341 != nil:
    section.add "ClusterSubnetGroupName", valid_609341
  var valid_609342 = query.getOrDefault("MaintenanceTrackName")
  valid_609342 = validateParameter(valid_609342, JString, required = false,
                                 default = nil)
  if valid_609342 != nil:
    section.add "MaintenanceTrackName", valid_609342
  assert query != nil, "query argument is necessary due to required `SnapshotIdentifier` field"
  var valid_609343 = query.getOrDefault("SnapshotIdentifier")
  valid_609343 = validateParameter(valid_609343, JString, required = true,
                                 default = nil)
  if valid_609343 != nil:
    section.add "SnapshotIdentifier", valid_609343
  var valid_609344 = query.getOrDefault("HsmClientCertificateIdentifier")
  valid_609344 = validateParameter(valid_609344, JString, required = false,
                                 default = nil)
  if valid_609344 != nil:
    section.add "HsmClientCertificateIdentifier", valid_609344
  var valid_609345 = query.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_609345 = validateParameter(valid_609345, JInt, required = false, default = nil)
  if valid_609345 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_609345
  var valid_609346 = query.getOrDefault("ClusterSecurityGroups")
  valid_609346 = validateParameter(valid_609346, JArray, required = false,
                                 default = nil)
  if valid_609346 != nil:
    section.add "ClusterSecurityGroups", valid_609346
  var valid_609347 = query.getOrDefault("KmsKeyId")
  valid_609347 = validateParameter(valid_609347, JString, required = false,
                                 default = nil)
  if valid_609347 != nil:
    section.add "KmsKeyId", valid_609347
  var valid_609348 = query.getOrDefault("ClusterParameterGroupName")
  valid_609348 = validateParameter(valid_609348, JString, required = false,
                                 default = nil)
  if valid_609348 != nil:
    section.add "ClusterParameterGroupName", valid_609348
  var valid_609349 = query.getOrDefault("NodeType")
  valid_609349 = validateParameter(valid_609349, JString, required = false,
                                 default = nil)
  if valid_609349 != nil:
    section.add "NodeType", valid_609349
  var valid_609350 = query.getOrDefault("SnapshotScheduleIdentifier")
  valid_609350 = validateParameter(valid_609350, JString, required = false,
                                 default = nil)
  if valid_609350 != nil:
    section.add "SnapshotScheduleIdentifier", valid_609350
  var valid_609351 = query.getOrDefault("IamRoles")
  valid_609351 = validateParameter(valid_609351, JArray, required = false,
                                 default = nil)
  if valid_609351 != nil:
    section.add "IamRoles", valid_609351
  var valid_609352 = query.getOrDefault("NumberOfNodes")
  valid_609352 = validateParameter(valid_609352, JInt, required = false, default = nil)
  if valid_609352 != nil:
    section.add "NumberOfNodes", valid_609352
  var valid_609353 = query.getOrDefault("AdditionalInfo")
  valid_609353 = validateParameter(valid_609353, JString, required = false,
                                 default = nil)
  if valid_609353 != nil:
    section.add "AdditionalInfo", valid_609353
  var valid_609354 = query.getOrDefault("SnapshotClusterIdentifier")
  valid_609354 = validateParameter(valid_609354, JString, required = false,
                                 default = nil)
  if valid_609354 != nil:
    section.add "SnapshotClusterIdentifier", valid_609354
  var valid_609355 = query.getOrDefault("AllowVersionUpgrade")
  valid_609355 = validateParameter(valid_609355, JBool, required = false, default = nil)
  if valid_609355 != nil:
    section.add "AllowVersionUpgrade", valid_609355
  var valid_609356 = query.getOrDefault("ElasticIp")
  valid_609356 = validateParameter(valid_609356, JString, required = false,
                                 default = nil)
  if valid_609356 != nil:
    section.add "ElasticIp", valid_609356
  var valid_609357 = query.getOrDefault("AutomatedSnapshotRetentionPeriod")
  valid_609357 = validateParameter(valid_609357, JInt, required = false, default = nil)
  if valid_609357 != nil:
    section.add "AutomatedSnapshotRetentionPeriod", valid_609357
  var valid_609358 = query.getOrDefault("EnhancedVpcRouting")
  valid_609358 = validateParameter(valid_609358, JBool, required = false, default = nil)
  if valid_609358 != nil:
    section.add "EnhancedVpcRouting", valid_609358
  var valid_609359 = query.getOrDefault("Action")
  valid_609359 = validateParameter(valid_609359, JString, required = true, default = newJString(
      "RestoreFromClusterSnapshot"))
  if valid_609359 != nil:
    section.add "Action", valid_609359
  var valid_609360 = query.getOrDefault("ClusterIdentifier")
  valid_609360 = validateParameter(valid_609360, JString, required = true,
                                 default = nil)
  if valid_609360 != nil:
    section.add "ClusterIdentifier", valid_609360
  var valid_609361 = query.getOrDefault("Port")
  valid_609361 = validateParameter(valid_609361, JInt, required = false, default = nil)
  if valid_609361 != nil:
    section.add "Port", valid_609361
  var valid_609362 = query.getOrDefault("VpcSecurityGroupIds")
  valid_609362 = validateParameter(valid_609362, JArray, required = false,
                                 default = nil)
  if valid_609362 != nil:
    section.add "VpcSecurityGroupIds", valid_609362
  var valid_609363 = query.getOrDefault("AvailabilityZone")
  valid_609363 = validateParameter(valid_609363, JString, required = false,
                                 default = nil)
  if valid_609363 != nil:
    section.add "AvailabilityZone", valid_609363
  var valid_609364 = query.getOrDefault("HsmConfigurationIdentifier")
  valid_609364 = validateParameter(valid_609364, JString, required = false,
                                 default = nil)
  if valid_609364 != nil:
    section.add "HsmConfigurationIdentifier", valid_609364
  var valid_609365 = query.getOrDefault("OwnerAccount")
  valid_609365 = validateParameter(valid_609365, JString, required = false,
                                 default = nil)
  if valid_609365 != nil:
    section.add "OwnerAccount", valid_609365
  var valid_609366 = query.getOrDefault("Version")
  valid_609366 = validateParameter(valid_609366, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_609366 != nil:
    section.add "Version", valid_609366
  var valid_609367 = query.getOrDefault("PreferredMaintenanceWindow")
  valid_609367 = validateParameter(valid_609367, JString, required = false,
                                 default = nil)
  if valid_609367 != nil:
    section.add "PreferredMaintenanceWindow", valid_609367
  var valid_609368 = query.getOrDefault("PubliclyAccessible")
  valid_609368 = validateParameter(valid_609368, JBool, required = false, default = nil)
  if valid_609368 != nil:
    section.add "PubliclyAccessible", valid_609368
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_609369 = header.getOrDefault("X-Amz-Signature")
  valid_609369 = validateParameter(valid_609369, JString, required = false,
                                 default = nil)
  if valid_609369 != nil:
    section.add "X-Amz-Signature", valid_609369
  var valid_609370 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_609370 = validateParameter(valid_609370, JString, required = false,
                                 default = nil)
  if valid_609370 != nil:
    section.add "X-Amz-Content-Sha256", valid_609370
  var valid_609371 = header.getOrDefault("X-Amz-Date")
  valid_609371 = validateParameter(valid_609371, JString, required = false,
                                 default = nil)
  if valid_609371 != nil:
    section.add "X-Amz-Date", valid_609371
  var valid_609372 = header.getOrDefault("X-Amz-Credential")
  valid_609372 = validateParameter(valid_609372, JString, required = false,
                                 default = nil)
  if valid_609372 != nil:
    section.add "X-Amz-Credential", valid_609372
  var valid_609373 = header.getOrDefault("X-Amz-Security-Token")
  valid_609373 = validateParameter(valid_609373, JString, required = false,
                                 default = nil)
  if valid_609373 != nil:
    section.add "X-Amz-Security-Token", valid_609373
  var valid_609374 = header.getOrDefault("X-Amz-Algorithm")
  valid_609374 = validateParameter(valid_609374, JString, required = false,
                                 default = nil)
  if valid_609374 != nil:
    section.add "X-Amz-Algorithm", valid_609374
  var valid_609375 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_609375 = validateParameter(valid_609375, JString, required = false,
                                 default = nil)
  if valid_609375 != nil:
    section.add "X-Amz-SignedHeaders", valid_609375
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_609376: Call_GetRestoreFromClusterSnapshot_609338; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a new cluster from a snapshot. By default, Amazon Redshift creates the resulting cluster with the same configuration as the original cluster from which the snapshot was created, except that the new cluster is created with the default cluster security and parameter groups. After Amazon Redshift creates the cluster, you can use the <a>ModifyCluster</a> API to associate a different security group and different parameter group with the restored cluster. If you are using a DS node type, you can also choose to change to another DS node type of the same size during restore.</p> <p>If you restore a cluster into a VPC, you must provide a cluster subnet group where you want the cluster restored.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_609376.validator(path, query, header, formData, body)
  let scheme = call_609376.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_609376.url(scheme.get, call_609376.host, call_609376.base,
                         call_609376.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_609376, url, valid)

proc call*(call_609377: Call_GetRestoreFromClusterSnapshot_609338;
          SnapshotIdentifier: string; ClusterIdentifier: string;
          ClusterSubnetGroupName: string = ""; MaintenanceTrackName: string = "";
          HsmClientCertificateIdentifier: string = "";
          ManualSnapshotRetentionPeriod: int = 0;
          ClusterSecurityGroups: JsonNode = nil; KmsKeyId: string = "";
          ClusterParameterGroupName: string = ""; NodeType: string = "";
          SnapshotScheduleIdentifier: string = ""; IamRoles: JsonNode = nil;
          NumberOfNodes: int = 0; AdditionalInfo: string = "";
          SnapshotClusterIdentifier: string = ""; AllowVersionUpgrade: bool = false;
          ElasticIp: string = ""; AutomatedSnapshotRetentionPeriod: int = 0;
          EnhancedVpcRouting: bool = false;
          Action: string = "RestoreFromClusterSnapshot"; Port: int = 0;
          VpcSecurityGroupIds: JsonNode = nil; AvailabilityZone: string = "";
          HsmConfigurationIdentifier: string = ""; OwnerAccount: string = "";
          Version: string = "2012-12-01"; PreferredMaintenanceWindow: string = "";
          PubliclyAccessible: bool = false): Recallable =
  ## getRestoreFromClusterSnapshot
  ## <p>Creates a new cluster from a snapshot. By default, Amazon Redshift creates the resulting cluster with the same configuration as the original cluster from which the snapshot was created, except that the new cluster is created with the default cluster security and parameter groups. After Amazon Redshift creates the cluster, you can use the <a>ModifyCluster</a> API to associate a different security group and different parameter group with the restored cluster. If you are using a DS node type, you can also choose to change to another DS node type of the same size during restore.</p> <p>If you restore a cluster into a VPC, you must provide a cluster subnet group where you want the cluster restored.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   ClusterSubnetGroupName: string
  ##                         : <p>The name of the subnet group where you want to cluster restored.</p> <p>A snapshot of cluster in VPC can be restored only in VPC. Therefore, you must provide subnet group name where you want the cluster restored.</p>
  ##   MaintenanceTrackName: string
  ##                       : The name of the maintenance track for the restored cluster. When you take a snapshot, the snapshot inherits the <code>MaintenanceTrack</code> value from the cluster. The snapshot might be on a different track than the cluster that was the source for the snapshot. For example, suppose that you take a snapshot of a cluster that is on the current track and then change the cluster to be on the trailing track. In this case, the snapshot and the source cluster are on different tracks.
  ##   SnapshotIdentifier: string (required)
  ##                     : <p>The name of the snapshot from which to create the new cluster. This parameter isn't case sensitive.</p> <p>Example: <code>my-snapshot-id</code> </p>
  ##   HsmClientCertificateIdentifier: string
  ##                                 : Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM.
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The default number of days to retain a manual snapshot. If the value is -1, the snapshot is retained indefinitely. This setting doesn't change the retention period of existing snapshots.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  ##   ClusterSecurityGroups: JArray
  ##                        : <p>A list of security groups to be associated with this cluster.</p> <p>Default: The default cluster security group for Amazon Redshift.</p> <p>Cluster security groups only apply to clusters outside of VPCs.</p>
  ##   KmsKeyId: string
  ##           : The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster that you restore from a shared snapshot.
  ##   ClusterParameterGroupName: string
  ##                            : <p>The name of the parameter group to be associated with this cluster.</p> <p>Default: The default Amazon Redshift cluster parameter group. For information about the default parameter group, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Working with Amazon Redshift Parameter Groups</a>.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   NodeType: string
  ##           : <p>The node type that the restored cluster will be provisioned with.</p> <p>Default: The node type of the cluster from which the snapshot was taken. You can modify this if you are using any DS node type. In that case, you can choose to restore into another DS node type of the same size. For example, you can restore ds1.8xlarge into ds2.8xlarge, or ds1.xlarge into ds2.xlarge. If you have a DC instance type, you must restore into that same instance type and size. In other words, you can only restore a dc1.large instance type into another dc1.large instance type or dc2.large instance type. You can't restore dc1.8xlarge to dc2.8xlarge. First restore to a dc1.8xlareg cluster, then resize to a dc2.8large cluster. For more information about node types, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-about-clusters-and-nodes"> About Clusters and Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ##   SnapshotScheduleIdentifier: string
  ##                             : A unique identifier for the snapshot schedule.
  ##   IamRoles: JArray
  ##           : <p>A list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services. You must supply the IAM roles in their Amazon Resource Name (ARN) format. You can supply up to 10 IAM roles in a single request.</p> <p>A cluster can have up to 10 IAM roles associated at any time.</p>
  ##   NumberOfNodes: int
  ##                : The number of nodes specified when provisioning the restored cluster.
  ##   AdditionalInfo: string
  ##                 : Reserved.
  ##   SnapshotClusterIdentifier: string
  ##                            : The name of the cluster the source snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.
  ##   AllowVersionUpgrade: bool
  ##                      : <p>If <code>true</code>, major version upgrades can be applied during the maintenance window to the Amazon Redshift engine that is running on the cluster. </p> <p>Default: <code>true</code> </p>
  ##   ElasticIp: string
  ##            : The elastic IP (EIP) address for the cluster.
  ##   AutomatedSnapshotRetentionPeriod: int
  ##                                   : <p>The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p> <p>Default: The value selected for the cluster from which the snapshot was taken.</p> <p>Constraints: Must be a value from 0 to 35.</p>
  ##   EnhancedVpcRouting: bool
  ##                     : <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p> <p>Default: false</p>
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The identifier of the cluster that will be created from restoring the snapshot.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul>
  ##   Port: int
  ##       : <p>The port number on which the cluster accepts connections.</p> <p>Default: The same port as the original cluster.</p> <p>Constraints: Must be between <code>1115</code> and <code>65535</code>.</p>
  ##   VpcSecurityGroupIds: JArray
  ##                      : <p>A list of Virtual Private Cloud (VPC) security groups to be associated with the cluster.</p> <p>Default: The default VPC security group is associated with the cluster.</p> <p>VPC security groups only apply to clusters in VPCs.</p>
  ##   AvailabilityZone: string
  ##                   : <p>The Amazon EC2 Availability Zone in which to restore the cluster.</p> <p>Default: A random, system-chosen Availability Zone.</p> <p>Example: <code>us-east-2a</code> </p>
  ##   HsmConfigurationIdentifier: string
  ##                             : Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
  ##   OwnerAccount: string
  ##               : The AWS customer account used to create or copy the snapshot. Required if you are restoring a snapshot you do not own, optional if you own the snapshot.
  ##   Version: string (required)
  ##   PreferredMaintenanceWindow: string
  ##                             : <p>The weekly time range (in UTC) during which automated cluster maintenance can occur.</p> <p> Format: <code>ddd:hh24:mi-ddd:hh24:mi</code> </p> <p> Default: The value selected for the cluster from which the snapshot was taken. For more information about the time blocks for each region, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-maintenance-windows">Maintenance Windows</a> in Amazon Redshift Cluster Management Guide. </p> <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p> <p>Constraints: Minimum 30-minute window.</p>
  ##   PubliclyAccessible: bool
  ##                     : If <code>true</code>, the cluster can be accessed from a public network. 
  var query_609378 = newJObject()
  add(query_609378, "ClusterSubnetGroupName", newJString(ClusterSubnetGroupName))
  add(query_609378, "MaintenanceTrackName", newJString(MaintenanceTrackName))
  add(query_609378, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_609378, "HsmClientCertificateIdentifier",
      newJString(HsmClientCertificateIdentifier))
  add(query_609378, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  if ClusterSecurityGroups != nil:
    query_609378.add "ClusterSecurityGroups", ClusterSecurityGroups
  add(query_609378, "KmsKeyId", newJString(KmsKeyId))
  add(query_609378, "ClusterParameterGroupName",
      newJString(ClusterParameterGroupName))
  add(query_609378, "NodeType", newJString(NodeType))
  add(query_609378, "SnapshotScheduleIdentifier",
      newJString(SnapshotScheduleIdentifier))
  if IamRoles != nil:
    query_609378.add "IamRoles", IamRoles
  add(query_609378, "NumberOfNodes", newJInt(NumberOfNodes))
  add(query_609378, "AdditionalInfo", newJString(AdditionalInfo))
  add(query_609378, "SnapshotClusterIdentifier",
      newJString(SnapshotClusterIdentifier))
  add(query_609378, "AllowVersionUpgrade", newJBool(AllowVersionUpgrade))
  add(query_609378, "ElasticIp", newJString(ElasticIp))
  add(query_609378, "AutomatedSnapshotRetentionPeriod",
      newJInt(AutomatedSnapshotRetentionPeriod))
  add(query_609378, "EnhancedVpcRouting", newJBool(EnhancedVpcRouting))
  add(query_609378, "Action", newJString(Action))
  add(query_609378, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_609378, "Port", newJInt(Port))
  if VpcSecurityGroupIds != nil:
    query_609378.add "VpcSecurityGroupIds", VpcSecurityGroupIds
  add(query_609378, "AvailabilityZone", newJString(AvailabilityZone))
  add(query_609378, "HsmConfigurationIdentifier",
      newJString(HsmConfigurationIdentifier))
  add(query_609378, "OwnerAccount", newJString(OwnerAccount))
  add(query_609378, "Version", newJString(Version))
  add(query_609378, "PreferredMaintenanceWindow",
      newJString(PreferredMaintenanceWindow))
  add(query_609378, "PubliclyAccessible", newJBool(PubliclyAccessible))
  result = call_609377.call(nil, query_609378, nil, nil, nil)

var getRestoreFromClusterSnapshot* = Call_GetRestoreFromClusterSnapshot_609338(
    name: "getRestoreFromClusterSnapshot", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=RestoreFromClusterSnapshot",
    validator: validate_GetRestoreFromClusterSnapshot_609339, base: "/",
    url: url_GetRestoreFromClusterSnapshot_609340,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostRestoreTableFromClusterSnapshot_609444 = ref object of OpenApiRestCall_605573
proc url_PostRestoreTableFromClusterSnapshot_609446(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostRestoreTableFromClusterSnapshot_609445(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a new table from a table in an Amazon Redshift cluster snapshot. You must create the new table within the Amazon Redshift cluster that the snapshot was taken from.</p> <p>You cannot use <code>RestoreTableFromClusterSnapshot</code> to restore a table with the same name as an existing table in an Amazon Redshift cluster. That is, you cannot overwrite an existing table in a cluster with a restored table. If you want to replace your original table with a new, restored table, then rename or drop your original table before you call <code>RestoreTableFromClusterSnapshot</code>. When you have renamed your original table, then you can pass the original name of the table as the <code>NewTableName</code> parameter value in the call to <code>RestoreTableFromClusterSnapshot</code>. This way, you can replace the original table with the table created from the snapshot.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_609447 = query.getOrDefault("Action")
  valid_609447 = validateParameter(valid_609447, JString, required = true, default = newJString(
      "RestoreTableFromClusterSnapshot"))
  if valid_609447 != nil:
    section.add "Action", valid_609447
  var valid_609448 = query.getOrDefault("Version")
  valid_609448 = validateParameter(valid_609448, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_609448 != nil:
    section.add "Version", valid_609448
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_609449 = header.getOrDefault("X-Amz-Signature")
  valid_609449 = validateParameter(valid_609449, JString, required = false,
                                 default = nil)
  if valid_609449 != nil:
    section.add "X-Amz-Signature", valid_609449
  var valid_609450 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_609450 = validateParameter(valid_609450, JString, required = false,
                                 default = nil)
  if valid_609450 != nil:
    section.add "X-Amz-Content-Sha256", valid_609450
  var valid_609451 = header.getOrDefault("X-Amz-Date")
  valid_609451 = validateParameter(valid_609451, JString, required = false,
                                 default = nil)
  if valid_609451 != nil:
    section.add "X-Amz-Date", valid_609451
  var valid_609452 = header.getOrDefault("X-Amz-Credential")
  valid_609452 = validateParameter(valid_609452, JString, required = false,
                                 default = nil)
  if valid_609452 != nil:
    section.add "X-Amz-Credential", valid_609452
  var valid_609453 = header.getOrDefault("X-Amz-Security-Token")
  valid_609453 = validateParameter(valid_609453, JString, required = false,
                                 default = nil)
  if valid_609453 != nil:
    section.add "X-Amz-Security-Token", valid_609453
  var valid_609454 = header.getOrDefault("X-Amz-Algorithm")
  valid_609454 = validateParameter(valid_609454, JString, required = false,
                                 default = nil)
  if valid_609454 != nil:
    section.add "X-Amz-Algorithm", valid_609454
  var valid_609455 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_609455 = validateParameter(valid_609455, JString, required = false,
                                 default = nil)
  if valid_609455 != nil:
    section.add "X-Amz-SignedHeaders", valid_609455
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : The identifier of the Amazon Redshift cluster to restore the table to.
  ##   NewTableName: JString (required)
  ##               : The name of the table to create as a result of the current request.
  ##   TargetSchemaName: JString
  ##                   : The name of the schema to restore the table to.
  ##   TargetDatabaseName: JString
  ##                     : The name of the database to restore the table to.
  ##   SnapshotIdentifier: JString (required)
  ##                     : The identifier of the snapshot to restore the table from. This snapshot must have been created from the Amazon Redshift cluster specified by the <code>ClusterIdentifier</code> parameter.
  ##   SourceDatabaseName: JString (required)
  ##                     : The name of the source database that contains the table to restore from.
  ##   SourceSchemaName: JString
  ##                   : The name of the source schema that contains the table to restore from. If you do not specify a <code>SourceSchemaName</code> value, the default is <code>public</code>.
  ##   SourceTableName: JString (required)
  ##                  : The name of the source table to restore from.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_609456 = formData.getOrDefault("ClusterIdentifier")
  valid_609456 = validateParameter(valid_609456, JString, required = true,
                                 default = nil)
  if valid_609456 != nil:
    section.add "ClusterIdentifier", valid_609456
  var valid_609457 = formData.getOrDefault("NewTableName")
  valid_609457 = validateParameter(valid_609457, JString, required = true,
                                 default = nil)
  if valid_609457 != nil:
    section.add "NewTableName", valid_609457
  var valid_609458 = formData.getOrDefault("TargetSchemaName")
  valid_609458 = validateParameter(valid_609458, JString, required = false,
                                 default = nil)
  if valid_609458 != nil:
    section.add "TargetSchemaName", valid_609458
  var valid_609459 = formData.getOrDefault("TargetDatabaseName")
  valid_609459 = validateParameter(valid_609459, JString, required = false,
                                 default = nil)
  if valid_609459 != nil:
    section.add "TargetDatabaseName", valid_609459
  var valid_609460 = formData.getOrDefault("SnapshotIdentifier")
  valid_609460 = validateParameter(valid_609460, JString, required = true,
                                 default = nil)
  if valid_609460 != nil:
    section.add "SnapshotIdentifier", valid_609460
  var valid_609461 = formData.getOrDefault("SourceDatabaseName")
  valid_609461 = validateParameter(valid_609461, JString, required = true,
                                 default = nil)
  if valid_609461 != nil:
    section.add "SourceDatabaseName", valid_609461
  var valid_609462 = formData.getOrDefault("SourceSchemaName")
  valid_609462 = validateParameter(valid_609462, JString, required = false,
                                 default = nil)
  if valid_609462 != nil:
    section.add "SourceSchemaName", valid_609462
  var valid_609463 = formData.getOrDefault("SourceTableName")
  valid_609463 = validateParameter(valid_609463, JString, required = true,
                                 default = nil)
  if valid_609463 != nil:
    section.add "SourceTableName", valid_609463
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_609464: Call_PostRestoreTableFromClusterSnapshot_609444;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Creates a new table from a table in an Amazon Redshift cluster snapshot. You must create the new table within the Amazon Redshift cluster that the snapshot was taken from.</p> <p>You cannot use <code>RestoreTableFromClusterSnapshot</code> to restore a table with the same name as an existing table in an Amazon Redshift cluster. That is, you cannot overwrite an existing table in a cluster with a restored table. If you want to replace your original table with a new, restored table, then rename or drop your original table before you call <code>RestoreTableFromClusterSnapshot</code>. When you have renamed your original table, then you can pass the original name of the table as the <code>NewTableName</code> parameter value in the call to <code>RestoreTableFromClusterSnapshot</code>. This way, you can replace the original table with the table created from the snapshot.</p>
  ## 
  let valid = call_609464.validator(path, query, header, formData, body)
  let scheme = call_609464.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_609464.url(scheme.get, call_609464.host, call_609464.base,
                         call_609464.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_609464, url, valid)

proc call*(call_609465: Call_PostRestoreTableFromClusterSnapshot_609444;
          ClusterIdentifier: string; NewTableName: string;
          SnapshotIdentifier: string; SourceDatabaseName: string;
          SourceTableName: string; TargetSchemaName: string = "";
          TargetDatabaseName: string = "";
          Action: string = "RestoreTableFromClusterSnapshot";
          Version: string = "2012-12-01"; SourceSchemaName: string = ""): Recallable =
  ## postRestoreTableFromClusterSnapshot
  ## <p>Creates a new table from a table in an Amazon Redshift cluster snapshot. You must create the new table within the Amazon Redshift cluster that the snapshot was taken from.</p> <p>You cannot use <code>RestoreTableFromClusterSnapshot</code> to restore a table with the same name as an existing table in an Amazon Redshift cluster. That is, you cannot overwrite an existing table in a cluster with a restored table. If you want to replace your original table with a new, restored table, then rename or drop your original table before you call <code>RestoreTableFromClusterSnapshot</code>. When you have renamed your original table, then you can pass the original name of the table as the <code>NewTableName</code> parameter value in the call to <code>RestoreTableFromClusterSnapshot</code>. This way, you can replace the original table with the table created from the snapshot.</p>
  ##   ClusterIdentifier: string (required)
  ##                    : The identifier of the Amazon Redshift cluster to restore the table to.
  ##   NewTableName: string (required)
  ##               : The name of the table to create as a result of the current request.
  ##   TargetSchemaName: string
  ##                   : The name of the schema to restore the table to.
  ##   TargetDatabaseName: string
  ##                     : The name of the database to restore the table to.
  ##   SnapshotIdentifier: string (required)
  ##                     : The identifier of the snapshot to restore the table from. This snapshot must have been created from the Amazon Redshift cluster specified by the <code>ClusterIdentifier</code> parameter.
  ##   SourceDatabaseName: string (required)
  ##                     : The name of the source database that contains the table to restore from.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   SourceSchemaName: string
  ##                   : The name of the source schema that contains the table to restore from. If you do not specify a <code>SourceSchemaName</code> value, the default is <code>public</code>.
  ##   SourceTableName: string (required)
  ##                  : The name of the source table to restore from.
  var query_609466 = newJObject()
  var formData_609467 = newJObject()
  add(formData_609467, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_609467, "NewTableName", newJString(NewTableName))
  add(formData_609467, "TargetSchemaName", newJString(TargetSchemaName))
  add(formData_609467, "TargetDatabaseName", newJString(TargetDatabaseName))
  add(formData_609467, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(formData_609467, "SourceDatabaseName", newJString(SourceDatabaseName))
  add(query_609466, "Action", newJString(Action))
  add(query_609466, "Version", newJString(Version))
  add(formData_609467, "SourceSchemaName", newJString(SourceSchemaName))
  add(formData_609467, "SourceTableName", newJString(SourceTableName))
  result = call_609465.call(nil, query_609466, nil, formData_609467, nil)

var postRestoreTableFromClusterSnapshot* = Call_PostRestoreTableFromClusterSnapshot_609444(
    name: "postRestoreTableFromClusterSnapshot", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=RestoreTableFromClusterSnapshot",
    validator: validate_PostRestoreTableFromClusterSnapshot_609445, base: "/",
    url: url_PostRestoreTableFromClusterSnapshot_609446,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetRestoreTableFromClusterSnapshot_609421 = ref object of OpenApiRestCall_605573
proc url_GetRestoreTableFromClusterSnapshot_609423(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetRestoreTableFromClusterSnapshot_609422(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a new table from a table in an Amazon Redshift cluster snapshot. You must create the new table within the Amazon Redshift cluster that the snapshot was taken from.</p> <p>You cannot use <code>RestoreTableFromClusterSnapshot</code> to restore a table with the same name as an existing table in an Amazon Redshift cluster. That is, you cannot overwrite an existing table in a cluster with a restored table. If you want to replace your original table with a new, restored table, then rename or drop your original table before you call <code>RestoreTableFromClusterSnapshot</code>. When you have renamed your original table, then you can pass the original name of the table as the <code>NewTableName</code> parameter value in the call to <code>RestoreTableFromClusterSnapshot</code>. This way, you can replace the original table with the table created from the snapshot.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   SnapshotIdentifier: JString (required)
  ##                     : The identifier of the snapshot to restore the table from. This snapshot must have been created from the Amazon Redshift cluster specified by the <code>ClusterIdentifier</code> parameter.
  ##   SourceTableName: JString (required)
  ##                  : The name of the source table to restore from.
  ##   SourceDatabaseName: JString (required)
  ##                     : The name of the source database that contains the table to restore from.
  ##   TargetSchemaName: JString
  ##                   : The name of the schema to restore the table to.
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : The identifier of the Amazon Redshift cluster to restore the table to.
  ##   SourceSchemaName: JString
  ##                   : The name of the source schema that contains the table to restore from. If you do not specify a <code>SourceSchemaName</code> value, the default is <code>public</code>.
  ##   Version: JString (required)
  ##   TargetDatabaseName: JString
  ##                     : The name of the database to restore the table to.
  ##   NewTableName: JString (required)
  ##               : The name of the table to create as a result of the current request.
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `SnapshotIdentifier` field"
  var valid_609424 = query.getOrDefault("SnapshotIdentifier")
  valid_609424 = validateParameter(valid_609424, JString, required = true,
                                 default = nil)
  if valid_609424 != nil:
    section.add "SnapshotIdentifier", valid_609424
  var valid_609425 = query.getOrDefault("SourceTableName")
  valid_609425 = validateParameter(valid_609425, JString, required = true,
                                 default = nil)
  if valid_609425 != nil:
    section.add "SourceTableName", valid_609425
  var valid_609426 = query.getOrDefault("SourceDatabaseName")
  valid_609426 = validateParameter(valid_609426, JString, required = true,
                                 default = nil)
  if valid_609426 != nil:
    section.add "SourceDatabaseName", valid_609426
  var valid_609427 = query.getOrDefault("TargetSchemaName")
  valid_609427 = validateParameter(valid_609427, JString, required = false,
                                 default = nil)
  if valid_609427 != nil:
    section.add "TargetSchemaName", valid_609427
  var valid_609428 = query.getOrDefault("Action")
  valid_609428 = validateParameter(valid_609428, JString, required = true, default = newJString(
      "RestoreTableFromClusterSnapshot"))
  if valid_609428 != nil:
    section.add "Action", valid_609428
  var valid_609429 = query.getOrDefault("ClusterIdentifier")
  valid_609429 = validateParameter(valid_609429, JString, required = true,
                                 default = nil)
  if valid_609429 != nil:
    section.add "ClusterIdentifier", valid_609429
  var valid_609430 = query.getOrDefault("SourceSchemaName")
  valid_609430 = validateParameter(valid_609430, JString, required = false,
                                 default = nil)
  if valid_609430 != nil:
    section.add "SourceSchemaName", valid_609430
  var valid_609431 = query.getOrDefault("Version")
  valid_609431 = validateParameter(valid_609431, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_609431 != nil:
    section.add "Version", valid_609431
  var valid_609432 = query.getOrDefault("TargetDatabaseName")
  valid_609432 = validateParameter(valid_609432, JString, required = false,
                                 default = nil)
  if valid_609432 != nil:
    section.add "TargetDatabaseName", valid_609432
  var valid_609433 = query.getOrDefault("NewTableName")
  valid_609433 = validateParameter(valid_609433, JString, required = true,
                                 default = nil)
  if valid_609433 != nil:
    section.add "NewTableName", valid_609433
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_609434 = header.getOrDefault("X-Amz-Signature")
  valid_609434 = validateParameter(valid_609434, JString, required = false,
                                 default = nil)
  if valid_609434 != nil:
    section.add "X-Amz-Signature", valid_609434
  var valid_609435 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_609435 = validateParameter(valid_609435, JString, required = false,
                                 default = nil)
  if valid_609435 != nil:
    section.add "X-Amz-Content-Sha256", valid_609435
  var valid_609436 = header.getOrDefault("X-Amz-Date")
  valid_609436 = validateParameter(valid_609436, JString, required = false,
                                 default = nil)
  if valid_609436 != nil:
    section.add "X-Amz-Date", valid_609436
  var valid_609437 = header.getOrDefault("X-Amz-Credential")
  valid_609437 = validateParameter(valid_609437, JString, required = false,
                                 default = nil)
  if valid_609437 != nil:
    section.add "X-Amz-Credential", valid_609437
  var valid_609438 = header.getOrDefault("X-Amz-Security-Token")
  valid_609438 = validateParameter(valid_609438, JString, required = false,
                                 default = nil)
  if valid_609438 != nil:
    section.add "X-Amz-Security-Token", valid_609438
  var valid_609439 = header.getOrDefault("X-Amz-Algorithm")
  valid_609439 = validateParameter(valid_609439, JString, required = false,
                                 default = nil)
  if valid_609439 != nil:
    section.add "X-Amz-Algorithm", valid_609439
  var valid_609440 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_609440 = validateParameter(valid_609440, JString, required = false,
                                 default = nil)
  if valid_609440 != nil:
    section.add "X-Amz-SignedHeaders", valid_609440
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_609441: Call_GetRestoreTableFromClusterSnapshot_609421;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Creates a new table from a table in an Amazon Redshift cluster snapshot. You must create the new table within the Amazon Redshift cluster that the snapshot was taken from.</p> <p>You cannot use <code>RestoreTableFromClusterSnapshot</code> to restore a table with the same name as an existing table in an Amazon Redshift cluster. That is, you cannot overwrite an existing table in a cluster with a restored table. If you want to replace your original table with a new, restored table, then rename or drop your original table before you call <code>RestoreTableFromClusterSnapshot</code>. When you have renamed your original table, then you can pass the original name of the table as the <code>NewTableName</code> parameter value in the call to <code>RestoreTableFromClusterSnapshot</code>. This way, you can replace the original table with the table created from the snapshot.</p>
  ## 
  let valid = call_609441.validator(path, query, header, formData, body)
  let scheme = call_609441.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_609441.url(scheme.get, call_609441.host, call_609441.base,
                         call_609441.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_609441, url, valid)

proc call*(call_609442: Call_GetRestoreTableFromClusterSnapshot_609421;
          SnapshotIdentifier: string; SourceTableName: string;
          SourceDatabaseName: string; ClusterIdentifier: string;
          NewTableName: string; TargetSchemaName: string = "";
          Action: string = "RestoreTableFromClusterSnapshot";
          SourceSchemaName: string = ""; Version: string = "2012-12-01";
          TargetDatabaseName: string = ""): Recallable =
  ## getRestoreTableFromClusterSnapshot
  ## <p>Creates a new table from a table in an Amazon Redshift cluster snapshot. You must create the new table within the Amazon Redshift cluster that the snapshot was taken from.</p> <p>You cannot use <code>RestoreTableFromClusterSnapshot</code> to restore a table with the same name as an existing table in an Amazon Redshift cluster. That is, you cannot overwrite an existing table in a cluster with a restored table. If you want to replace your original table with a new, restored table, then rename or drop your original table before you call <code>RestoreTableFromClusterSnapshot</code>. When you have renamed your original table, then you can pass the original name of the table as the <code>NewTableName</code> parameter value in the call to <code>RestoreTableFromClusterSnapshot</code>. This way, you can replace the original table with the table created from the snapshot.</p>
  ##   SnapshotIdentifier: string (required)
  ##                     : The identifier of the snapshot to restore the table from. This snapshot must have been created from the Amazon Redshift cluster specified by the <code>ClusterIdentifier</code> parameter.
  ##   SourceTableName: string (required)
  ##                  : The name of the source table to restore from.
  ##   SourceDatabaseName: string (required)
  ##                     : The name of the source database that contains the table to restore from.
  ##   TargetSchemaName: string
  ##                   : The name of the schema to restore the table to.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : The identifier of the Amazon Redshift cluster to restore the table to.
  ##   SourceSchemaName: string
  ##                   : The name of the source schema that contains the table to restore from. If you do not specify a <code>SourceSchemaName</code> value, the default is <code>public</code>.
  ##   Version: string (required)
  ##   TargetDatabaseName: string
  ##                     : The name of the database to restore the table to.
  ##   NewTableName: string (required)
  ##               : The name of the table to create as a result of the current request.
  var query_609443 = newJObject()
  add(query_609443, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_609443, "SourceTableName", newJString(SourceTableName))
  add(query_609443, "SourceDatabaseName", newJString(SourceDatabaseName))
  add(query_609443, "TargetSchemaName", newJString(TargetSchemaName))
  add(query_609443, "Action", newJString(Action))
  add(query_609443, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_609443, "SourceSchemaName", newJString(SourceSchemaName))
  add(query_609443, "Version", newJString(Version))
  add(query_609443, "TargetDatabaseName", newJString(TargetDatabaseName))
  add(query_609443, "NewTableName", newJString(NewTableName))
  result = call_609442.call(nil, query_609443, nil, nil, nil)

var getRestoreTableFromClusterSnapshot* = Call_GetRestoreTableFromClusterSnapshot_609421(
    name: "getRestoreTableFromClusterSnapshot", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=RestoreTableFromClusterSnapshot",
    validator: validate_GetRestoreTableFromClusterSnapshot_609422, base: "/",
    url: url_GetRestoreTableFromClusterSnapshot_609423,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostRevokeClusterSecurityGroupIngress_609487 = ref object of OpenApiRestCall_605573
proc url_PostRevokeClusterSecurityGroupIngress_609489(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostRevokeClusterSecurityGroupIngress_609488(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Revokes an ingress rule in an Amazon Redshift security group for a previously authorized IP range or Amazon EC2 security group. To add an ingress rule, see <a>AuthorizeClusterSecurityGroupIngress</a>. For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_609490 = query.getOrDefault("Action")
  valid_609490 = validateParameter(valid_609490, JString, required = true, default = newJString(
      "RevokeClusterSecurityGroupIngress"))
  if valid_609490 != nil:
    section.add "Action", valid_609490
  var valid_609491 = query.getOrDefault("Version")
  valid_609491 = validateParameter(valid_609491, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_609491 != nil:
    section.add "Version", valid_609491
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_609492 = header.getOrDefault("X-Amz-Signature")
  valid_609492 = validateParameter(valid_609492, JString, required = false,
                                 default = nil)
  if valid_609492 != nil:
    section.add "X-Amz-Signature", valid_609492
  var valid_609493 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_609493 = validateParameter(valid_609493, JString, required = false,
                                 default = nil)
  if valid_609493 != nil:
    section.add "X-Amz-Content-Sha256", valid_609493
  var valid_609494 = header.getOrDefault("X-Amz-Date")
  valid_609494 = validateParameter(valid_609494, JString, required = false,
                                 default = nil)
  if valid_609494 != nil:
    section.add "X-Amz-Date", valid_609494
  var valid_609495 = header.getOrDefault("X-Amz-Credential")
  valid_609495 = validateParameter(valid_609495, JString, required = false,
                                 default = nil)
  if valid_609495 != nil:
    section.add "X-Amz-Credential", valid_609495
  var valid_609496 = header.getOrDefault("X-Amz-Security-Token")
  valid_609496 = validateParameter(valid_609496, JString, required = false,
                                 default = nil)
  if valid_609496 != nil:
    section.add "X-Amz-Security-Token", valid_609496
  var valid_609497 = header.getOrDefault("X-Amz-Algorithm")
  valid_609497 = validateParameter(valid_609497, JString, required = false,
                                 default = nil)
  if valid_609497 != nil:
    section.add "X-Amz-Algorithm", valid_609497
  var valid_609498 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_609498 = validateParameter(valid_609498, JString, required = false,
                                 default = nil)
  if valid_609498 != nil:
    section.add "X-Amz-SignedHeaders", valid_609498
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterSecurityGroupName: JString (required)
  ##                           : The name of the security Group from which to revoke the ingress rule.
  ##   EC2SecurityGroupName: JString
  ##                       : The name of the EC2 Security Group whose access is to be revoked. If <code>EC2SecurityGroupName</code> is specified, <code>EC2SecurityGroupOwnerId</code> must also be provided and <code>CIDRIP</code> cannot be provided. 
  ##   EC2SecurityGroupOwnerId: JString
  ##                          : <p>The AWS account number of the owner of the security group specified in the <code>EC2SecurityGroupName</code> parameter. The AWS access key ID is not an acceptable value. If <code>EC2SecurityGroupOwnerId</code> is specified, <code>EC2SecurityGroupName</code> must also be provided. and <code>CIDRIP</code> cannot be provided. </p> <p>Example: <code>111122223333</code> </p>
  ##   CIDRIP: JString
  ##         : The IP range for which to revoke access. This range must be a valid Classless Inter-Domain Routing (CIDR) block of IP addresses. If <code>CIDRIP</code> is specified, <code>EC2SecurityGroupName</code> and <code>EC2SecurityGroupOwnerId</code> cannot be provided. 
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterSecurityGroupName` field"
  var valid_609499 = formData.getOrDefault("ClusterSecurityGroupName")
  valid_609499 = validateParameter(valid_609499, JString, required = true,
                                 default = nil)
  if valid_609499 != nil:
    section.add "ClusterSecurityGroupName", valid_609499
  var valid_609500 = formData.getOrDefault("EC2SecurityGroupName")
  valid_609500 = validateParameter(valid_609500, JString, required = false,
                                 default = nil)
  if valid_609500 != nil:
    section.add "EC2SecurityGroupName", valid_609500
  var valid_609501 = formData.getOrDefault("EC2SecurityGroupOwnerId")
  valid_609501 = validateParameter(valid_609501, JString, required = false,
                                 default = nil)
  if valid_609501 != nil:
    section.add "EC2SecurityGroupOwnerId", valid_609501
  var valid_609502 = formData.getOrDefault("CIDRIP")
  valid_609502 = validateParameter(valid_609502, JString, required = false,
                                 default = nil)
  if valid_609502 != nil:
    section.add "CIDRIP", valid_609502
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_609503: Call_PostRevokeClusterSecurityGroupIngress_609487;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Revokes an ingress rule in an Amazon Redshift security group for a previously authorized IP range or Amazon EC2 security group. To add an ingress rule, see <a>AuthorizeClusterSecurityGroupIngress</a>. For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>. 
  ## 
  let valid = call_609503.validator(path, query, header, formData, body)
  let scheme = call_609503.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_609503.url(scheme.get, call_609503.host, call_609503.base,
                         call_609503.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_609503, url, valid)

proc call*(call_609504: Call_PostRevokeClusterSecurityGroupIngress_609487;
          ClusterSecurityGroupName: string; EC2SecurityGroupName: string = "";
          EC2SecurityGroupOwnerId: string = ""; CIDRIP: string = "";
          Action: string = "RevokeClusterSecurityGroupIngress";
          Version: string = "2012-12-01"): Recallable =
  ## postRevokeClusterSecurityGroupIngress
  ## Revokes an ingress rule in an Amazon Redshift security group for a previously authorized IP range or Amazon EC2 security group. To add an ingress rule, see <a>AuthorizeClusterSecurityGroupIngress</a>. For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>. 
  ##   ClusterSecurityGroupName: string (required)
  ##                           : The name of the security Group from which to revoke the ingress rule.
  ##   EC2SecurityGroupName: string
  ##                       : The name of the EC2 Security Group whose access is to be revoked. If <code>EC2SecurityGroupName</code> is specified, <code>EC2SecurityGroupOwnerId</code> must also be provided and <code>CIDRIP</code> cannot be provided. 
  ##   EC2SecurityGroupOwnerId: string
  ##                          : <p>The AWS account number of the owner of the security group specified in the <code>EC2SecurityGroupName</code> parameter. The AWS access key ID is not an acceptable value. If <code>EC2SecurityGroupOwnerId</code> is specified, <code>EC2SecurityGroupName</code> must also be provided. and <code>CIDRIP</code> cannot be provided. </p> <p>Example: <code>111122223333</code> </p>
  ##   CIDRIP: string
  ##         : The IP range for which to revoke access. This range must be a valid Classless Inter-Domain Routing (CIDR) block of IP addresses. If <code>CIDRIP</code> is specified, <code>EC2SecurityGroupName</code> and <code>EC2SecurityGroupOwnerId</code> cannot be provided. 
  ##   Action: string (required)
  ##   Version: string (required)
  var query_609505 = newJObject()
  var formData_609506 = newJObject()
  add(formData_609506, "ClusterSecurityGroupName",
      newJString(ClusterSecurityGroupName))
  add(formData_609506, "EC2SecurityGroupName", newJString(EC2SecurityGroupName))
  add(formData_609506, "EC2SecurityGroupOwnerId",
      newJString(EC2SecurityGroupOwnerId))
  add(formData_609506, "CIDRIP", newJString(CIDRIP))
  add(query_609505, "Action", newJString(Action))
  add(query_609505, "Version", newJString(Version))
  result = call_609504.call(nil, query_609505, nil, formData_609506, nil)

var postRevokeClusterSecurityGroupIngress* = Call_PostRevokeClusterSecurityGroupIngress_609487(
    name: "postRevokeClusterSecurityGroupIngress", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=RevokeClusterSecurityGroupIngress",
    validator: validate_PostRevokeClusterSecurityGroupIngress_609488, base: "/",
    url: url_PostRevokeClusterSecurityGroupIngress_609489,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetRevokeClusterSecurityGroupIngress_609468 = ref object of OpenApiRestCall_605573
proc url_GetRevokeClusterSecurityGroupIngress_609470(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetRevokeClusterSecurityGroupIngress_609469(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Revokes an ingress rule in an Amazon Redshift security group for a previously authorized IP range or Amazon EC2 security group. To add an ingress rule, see <a>AuthorizeClusterSecurityGroupIngress</a>. For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   EC2SecurityGroupName: JString
  ##                       : The name of the EC2 Security Group whose access is to be revoked. If <code>EC2SecurityGroupName</code> is specified, <code>EC2SecurityGroupOwnerId</code> must also be provided and <code>CIDRIP</code> cannot be provided. 
  ##   EC2SecurityGroupOwnerId: JString
  ##                          : <p>The AWS account number of the owner of the security group specified in the <code>EC2SecurityGroupName</code> parameter. The AWS access key ID is not an acceptable value. If <code>EC2SecurityGroupOwnerId</code> is specified, <code>EC2SecurityGroupName</code> must also be provided. and <code>CIDRIP</code> cannot be provided. </p> <p>Example: <code>111122223333</code> </p>
  ##   ClusterSecurityGroupName: JString (required)
  ##                           : The name of the security Group from which to revoke the ingress rule.
  ##   Action: JString (required)
  ##   Version: JString (required)
  ##   CIDRIP: JString
  ##         : The IP range for which to revoke access. This range must be a valid Classless Inter-Domain Routing (CIDR) block of IP addresses. If <code>CIDRIP</code> is specified, <code>EC2SecurityGroupName</code> and <code>EC2SecurityGroupOwnerId</code> cannot be provided. 
  section = newJObject()
  var valid_609471 = query.getOrDefault("EC2SecurityGroupName")
  valid_609471 = validateParameter(valid_609471, JString, required = false,
                                 default = nil)
  if valid_609471 != nil:
    section.add "EC2SecurityGroupName", valid_609471
  var valid_609472 = query.getOrDefault("EC2SecurityGroupOwnerId")
  valid_609472 = validateParameter(valid_609472, JString, required = false,
                                 default = nil)
  if valid_609472 != nil:
    section.add "EC2SecurityGroupOwnerId", valid_609472
  assert query != nil, "query argument is necessary due to required `ClusterSecurityGroupName` field"
  var valid_609473 = query.getOrDefault("ClusterSecurityGroupName")
  valid_609473 = validateParameter(valid_609473, JString, required = true,
                                 default = nil)
  if valid_609473 != nil:
    section.add "ClusterSecurityGroupName", valid_609473
  var valid_609474 = query.getOrDefault("Action")
  valid_609474 = validateParameter(valid_609474, JString, required = true, default = newJString(
      "RevokeClusterSecurityGroupIngress"))
  if valid_609474 != nil:
    section.add "Action", valid_609474
  var valid_609475 = query.getOrDefault("Version")
  valid_609475 = validateParameter(valid_609475, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_609475 != nil:
    section.add "Version", valid_609475
  var valid_609476 = query.getOrDefault("CIDRIP")
  valid_609476 = validateParameter(valid_609476, JString, required = false,
                                 default = nil)
  if valid_609476 != nil:
    section.add "CIDRIP", valid_609476
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_609477 = header.getOrDefault("X-Amz-Signature")
  valid_609477 = validateParameter(valid_609477, JString, required = false,
                                 default = nil)
  if valid_609477 != nil:
    section.add "X-Amz-Signature", valid_609477
  var valid_609478 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_609478 = validateParameter(valid_609478, JString, required = false,
                                 default = nil)
  if valid_609478 != nil:
    section.add "X-Amz-Content-Sha256", valid_609478
  var valid_609479 = header.getOrDefault("X-Amz-Date")
  valid_609479 = validateParameter(valid_609479, JString, required = false,
                                 default = nil)
  if valid_609479 != nil:
    section.add "X-Amz-Date", valid_609479
  var valid_609480 = header.getOrDefault("X-Amz-Credential")
  valid_609480 = validateParameter(valid_609480, JString, required = false,
                                 default = nil)
  if valid_609480 != nil:
    section.add "X-Amz-Credential", valid_609480
  var valid_609481 = header.getOrDefault("X-Amz-Security-Token")
  valid_609481 = validateParameter(valid_609481, JString, required = false,
                                 default = nil)
  if valid_609481 != nil:
    section.add "X-Amz-Security-Token", valid_609481
  var valid_609482 = header.getOrDefault("X-Amz-Algorithm")
  valid_609482 = validateParameter(valid_609482, JString, required = false,
                                 default = nil)
  if valid_609482 != nil:
    section.add "X-Amz-Algorithm", valid_609482
  var valid_609483 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_609483 = validateParameter(valid_609483, JString, required = false,
                                 default = nil)
  if valid_609483 != nil:
    section.add "X-Amz-SignedHeaders", valid_609483
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_609484: Call_GetRevokeClusterSecurityGroupIngress_609468;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Revokes an ingress rule in an Amazon Redshift security group for a previously authorized IP range or Amazon EC2 security group. To add an ingress rule, see <a>AuthorizeClusterSecurityGroupIngress</a>. For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>. 
  ## 
  let valid = call_609484.validator(path, query, header, formData, body)
  let scheme = call_609484.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_609484.url(scheme.get, call_609484.host, call_609484.base,
                         call_609484.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_609484, url, valid)

proc call*(call_609485: Call_GetRevokeClusterSecurityGroupIngress_609468;
          ClusterSecurityGroupName: string; EC2SecurityGroupName: string = "";
          EC2SecurityGroupOwnerId: string = "";
          Action: string = "RevokeClusterSecurityGroupIngress";
          Version: string = "2012-12-01"; CIDRIP: string = ""): Recallable =
  ## getRevokeClusterSecurityGroupIngress
  ## Revokes an ingress rule in an Amazon Redshift security group for a previously authorized IP range or Amazon EC2 security group. To add an ingress rule, see <a>AuthorizeClusterSecurityGroupIngress</a>. For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>. 
  ##   EC2SecurityGroupName: string
  ##                       : The name of the EC2 Security Group whose access is to be revoked. If <code>EC2SecurityGroupName</code> is specified, <code>EC2SecurityGroupOwnerId</code> must also be provided and <code>CIDRIP</code> cannot be provided. 
  ##   EC2SecurityGroupOwnerId: string
  ##                          : <p>The AWS account number of the owner of the security group specified in the <code>EC2SecurityGroupName</code> parameter. The AWS access key ID is not an acceptable value. If <code>EC2SecurityGroupOwnerId</code> is specified, <code>EC2SecurityGroupName</code> must also be provided. and <code>CIDRIP</code> cannot be provided. </p> <p>Example: <code>111122223333</code> </p>
  ##   ClusterSecurityGroupName: string (required)
  ##                           : The name of the security Group from which to revoke the ingress rule.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   CIDRIP: string
  ##         : The IP range for which to revoke access. This range must be a valid Classless Inter-Domain Routing (CIDR) block of IP addresses. If <code>CIDRIP</code> is specified, <code>EC2SecurityGroupName</code> and <code>EC2SecurityGroupOwnerId</code> cannot be provided. 
  var query_609486 = newJObject()
  add(query_609486, "EC2SecurityGroupName", newJString(EC2SecurityGroupName))
  add(query_609486, "EC2SecurityGroupOwnerId", newJString(EC2SecurityGroupOwnerId))
  add(query_609486, "ClusterSecurityGroupName",
      newJString(ClusterSecurityGroupName))
  add(query_609486, "Action", newJString(Action))
  add(query_609486, "Version", newJString(Version))
  add(query_609486, "CIDRIP", newJString(CIDRIP))
  result = call_609485.call(nil, query_609486, nil, nil, nil)

var getRevokeClusterSecurityGroupIngress* = Call_GetRevokeClusterSecurityGroupIngress_609468(
    name: "getRevokeClusterSecurityGroupIngress", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=RevokeClusterSecurityGroupIngress",
    validator: validate_GetRevokeClusterSecurityGroupIngress_609469, base: "/",
    url: url_GetRevokeClusterSecurityGroupIngress_609470,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostRevokeSnapshotAccess_609525 = ref object of OpenApiRestCall_605573
proc url_PostRevokeSnapshotAccess_609527(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostRevokeSnapshotAccess_609526(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Removes the ability of the specified AWS customer account to restore the specified snapshot. If the account is currently restoring the snapshot, the restore will run to completion.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_609528 = query.getOrDefault("Action")
  valid_609528 = validateParameter(valid_609528, JString, required = true,
                                 default = newJString("RevokeSnapshotAccess"))
  if valid_609528 != nil:
    section.add "Action", valid_609528
  var valid_609529 = query.getOrDefault("Version")
  valid_609529 = validateParameter(valid_609529, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_609529 != nil:
    section.add "Version", valid_609529
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_609530 = header.getOrDefault("X-Amz-Signature")
  valid_609530 = validateParameter(valid_609530, JString, required = false,
                                 default = nil)
  if valid_609530 != nil:
    section.add "X-Amz-Signature", valid_609530
  var valid_609531 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_609531 = validateParameter(valid_609531, JString, required = false,
                                 default = nil)
  if valid_609531 != nil:
    section.add "X-Amz-Content-Sha256", valid_609531
  var valid_609532 = header.getOrDefault("X-Amz-Date")
  valid_609532 = validateParameter(valid_609532, JString, required = false,
                                 default = nil)
  if valid_609532 != nil:
    section.add "X-Amz-Date", valid_609532
  var valid_609533 = header.getOrDefault("X-Amz-Credential")
  valid_609533 = validateParameter(valid_609533, JString, required = false,
                                 default = nil)
  if valid_609533 != nil:
    section.add "X-Amz-Credential", valid_609533
  var valid_609534 = header.getOrDefault("X-Amz-Security-Token")
  valid_609534 = validateParameter(valid_609534, JString, required = false,
                                 default = nil)
  if valid_609534 != nil:
    section.add "X-Amz-Security-Token", valid_609534
  var valid_609535 = header.getOrDefault("X-Amz-Algorithm")
  valid_609535 = validateParameter(valid_609535, JString, required = false,
                                 default = nil)
  if valid_609535 != nil:
    section.add "X-Amz-Algorithm", valid_609535
  var valid_609536 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_609536 = validateParameter(valid_609536, JString, required = false,
                                 default = nil)
  if valid_609536 != nil:
    section.add "X-Amz-SignedHeaders", valid_609536
  result.add "header", section
  ## parameters in `formData` object:
  ##   SnapshotIdentifier: JString (required)
  ##                     : The identifier of the snapshot that the account can no longer access.
  ##   AccountWithRestoreAccess: JString (required)
  ##                           : The identifier of the AWS customer account that can no longer restore the specified snapshot.
  ##   SnapshotClusterIdentifier: JString
  ##                            : The identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `SnapshotIdentifier` field"
  var valid_609537 = formData.getOrDefault("SnapshotIdentifier")
  valid_609537 = validateParameter(valid_609537, JString, required = true,
                                 default = nil)
  if valid_609537 != nil:
    section.add "SnapshotIdentifier", valid_609537
  var valid_609538 = formData.getOrDefault("AccountWithRestoreAccess")
  valid_609538 = validateParameter(valid_609538, JString, required = true,
                                 default = nil)
  if valid_609538 != nil:
    section.add "AccountWithRestoreAccess", valid_609538
  var valid_609539 = formData.getOrDefault("SnapshotClusterIdentifier")
  valid_609539 = validateParameter(valid_609539, JString, required = false,
                                 default = nil)
  if valid_609539 != nil:
    section.add "SnapshotClusterIdentifier", valid_609539
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_609540: Call_PostRevokeSnapshotAccess_609525; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Removes the ability of the specified AWS customer account to restore the specified snapshot. If the account is currently restoring the snapshot, the restore will run to completion.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_609540.validator(path, query, header, formData, body)
  let scheme = call_609540.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_609540.url(scheme.get, call_609540.host, call_609540.base,
                         call_609540.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_609540, url, valid)

proc call*(call_609541: Call_PostRevokeSnapshotAccess_609525;
          SnapshotIdentifier: string; AccountWithRestoreAccess: string;
          Action: string = "RevokeSnapshotAccess";
          SnapshotClusterIdentifier: string = ""; Version: string = "2012-12-01"): Recallable =
  ## postRevokeSnapshotAccess
  ## <p>Removes the ability of the specified AWS customer account to restore the specified snapshot. If the account is currently restoring the snapshot, the restore will run to completion.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   SnapshotIdentifier: string (required)
  ##                     : The identifier of the snapshot that the account can no longer access.
  ##   Action: string (required)
  ##   AccountWithRestoreAccess: string (required)
  ##                           : The identifier of the AWS customer account that can no longer restore the specified snapshot.
  ##   SnapshotClusterIdentifier: string
  ##                            : The identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.
  ##   Version: string (required)
  var query_609542 = newJObject()
  var formData_609543 = newJObject()
  add(formData_609543, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_609542, "Action", newJString(Action))
  add(formData_609543, "AccountWithRestoreAccess",
      newJString(AccountWithRestoreAccess))
  add(formData_609543, "SnapshotClusterIdentifier",
      newJString(SnapshotClusterIdentifier))
  add(query_609542, "Version", newJString(Version))
  result = call_609541.call(nil, query_609542, nil, formData_609543, nil)

var postRevokeSnapshotAccess* = Call_PostRevokeSnapshotAccess_609525(
    name: "postRevokeSnapshotAccess", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=RevokeSnapshotAccess",
    validator: validate_PostRevokeSnapshotAccess_609526, base: "/",
    url: url_PostRevokeSnapshotAccess_609527, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetRevokeSnapshotAccess_609507 = ref object of OpenApiRestCall_605573
proc url_GetRevokeSnapshotAccess_609509(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetRevokeSnapshotAccess_609508(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Removes the ability of the specified AWS customer account to restore the specified snapshot. If the account is currently restoring the snapshot, the restore will run to completion.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   SnapshotIdentifier: JString (required)
  ##                     : The identifier of the snapshot that the account can no longer access.
  ##   SnapshotClusterIdentifier: JString
  ##                            : The identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.
  ##   Action: JString (required)
  ##   Version: JString (required)
  ##   AccountWithRestoreAccess: JString (required)
  ##                           : The identifier of the AWS customer account that can no longer restore the specified snapshot.
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `SnapshotIdentifier` field"
  var valid_609510 = query.getOrDefault("SnapshotIdentifier")
  valid_609510 = validateParameter(valid_609510, JString, required = true,
                                 default = nil)
  if valid_609510 != nil:
    section.add "SnapshotIdentifier", valid_609510
  var valid_609511 = query.getOrDefault("SnapshotClusterIdentifier")
  valid_609511 = validateParameter(valid_609511, JString, required = false,
                                 default = nil)
  if valid_609511 != nil:
    section.add "SnapshotClusterIdentifier", valid_609511
  var valid_609512 = query.getOrDefault("Action")
  valid_609512 = validateParameter(valid_609512, JString, required = true,
                                 default = newJString("RevokeSnapshotAccess"))
  if valid_609512 != nil:
    section.add "Action", valid_609512
  var valid_609513 = query.getOrDefault("Version")
  valid_609513 = validateParameter(valid_609513, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_609513 != nil:
    section.add "Version", valid_609513
  var valid_609514 = query.getOrDefault("AccountWithRestoreAccess")
  valid_609514 = validateParameter(valid_609514, JString, required = true,
                                 default = nil)
  if valid_609514 != nil:
    section.add "AccountWithRestoreAccess", valid_609514
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_609515 = header.getOrDefault("X-Amz-Signature")
  valid_609515 = validateParameter(valid_609515, JString, required = false,
                                 default = nil)
  if valid_609515 != nil:
    section.add "X-Amz-Signature", valid_609515
  var valid_609516 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_609516 = validateParameter(valid_609516, JString, required = false,
                                 default = nil)
  if valid_609516 != nil:
    section.add "X-Amz-Content-Sha256", valid_609516
  var valid_609517 = header.getOrDefault("X-Amz-Date")
  valid_609517 = validateParameter(valid_609517, JString, required = false,
                                 default = nil)
  if valid_609517 != nil:
    section.add "X-Amz-Date", valid_609517
  var valid_609518 = header.getOrDefault("X-Amz-Credential")
  valid_609518 = validateParameter(valid_609518, JString, required = false,
                                 default = nil)
  if valid_609518 != nil:
    section.add "X-Amz-Credential", valid_609518
  var valid_609519 = header.getOrDefault("X-Amz-Security-Token")
  valid_609519 = validateParameter(valid_609519, JString, required = false,
                                 default = nil)
  if valid_609519 != nil:
    section.add "X-Amz-Security-Token", valid_609519
  var valid_609520 = header.getOrDefault("X-Amz-Algorithm")
  valid_609520 = validateParameter(valid_609520, JString, required = false,
                                 default = nil)
  if valid_609520 != nil:
    section.add "X-Amz-Algorithm", valid_609520
  var valid_609521 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_609521 = validateParameter(valid_609521, JString, required = false,
                                 default = nil)
  if valid_609521 != nil:
    section.add "X-Amz-SignedHeaders", valid_609521
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_609522: Call_GetRevokeSnapshotAccess_609507; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Removes the ability of the specified AWS customer account to restore the specified snapshot. If the account is currently restoring the snapshot, the restore will run to completion.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_609522.validator(path, query, header, formData, body)
  let scheme = call_609522.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_609522.url(scheme.get, call_609522.host, call_609522.base,
                         call_609522.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_609522, url, valid)

proc call*(call_609523: Call_GetRevokeSnapshotAccess_609507;
          SnapshotIdentifier: string; AccountWithRestoreAccess: string;
          SnapshotClusterIdentifier: string = "";
          Action: string = "RevokeSnapshotAccess"; Version: string = "2012-12-01"): Recallable =
  ## getRevokeSnapshotAccess
  ## <p>Removes the ability of the specified AWS customer account to restore the specified snapshot. If the account is currently restoring the snapshot, the restore will run to completion.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   SnapshotIdentifier: string (required)
  ##                     : The identifier of the snapshot that the account can no longer access.
  ##   SnapshotClusterIdentifier: string
  ##                            : The identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   AccountWithRestoreAccess: string (required)
  ##                           : The identifier of the AWS customer account that can no longer restore the specified snapshot.
  var query_609524 = newJObject()
  add(query_609524, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_609524, "SnapshotClusterIdentifier",
      newJString(SnapshotClusterIdentifier))
  add(query_609524, "Action", newJString(Action))
  add(query_609524, "Version", newJString(Version))
  add(query_609524, "AccountWithRestoreAccess",
      newJString(AccountWithRestoreAccess))
  result = call_609523.call(nil, query_609524, nil, nil, nil)

var getRevokeSnapshotAccess* = Call_GetRevokeSnapshotAccess_609507(
    name: "getRevokeSnapshotAccess", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=RevokeSnapshotAccess",
    validator: validate_GetRevokeSnapshotAccess_609508, base: "/",
    url: url_GetRevokeSnapshotAccess_609509, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostRotateEncryptionKey_609560 = ref object of OpenApiRestCall_605573
proc url_PostRotateEncryptionKey_609562(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostRotateEncryptionKey_609561(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Rotates the encryption keys for a cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_609563 = query.getOrDefault("Action")
  valid_609563 = validateParameter(valid_609563, JString, required = true,
                                 default = newJString("RotateEncryptionKey"))
  if valid_609563 != nil:
    section.add "Action", valid_609563
  var valid_609564 = query.getOrDefault("Version")
  valid_609564 = validateParameter(valid_609564, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_609564 != nil:
    section.add "Version", valid_609564
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_609565 = header.getOrDefault("X-Amz-Signature")
  valid_609565 = validateParameter(valid_609565, JString, required = false,
                                 default = nil)
  if valid_609565 != nil:
    section.add "X-Amz-Signature", valid_609565
  var valid_609566 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_609566 = validateParameter(valid_609566, JString, required = false,
                                 default = nil)
  if valid_609566 != nil:
    section.add "X-Amz-Content-Sha256", valid_609566
  var valid_609567 = header.getOrDefault("X-Amz-Date")
  valid_609567 = validateParameter(valid_609567, JString, required = false,
                                 default = nil)
  if valid_609567 != nil:
    section.add "X-Amz-Date", valid_609567
  var valid_609568 = header.getOrDefault("X-Amz-Credential")
  valid_609568 = validateParameter(valid_609568, JString, required = false,
                                 default = nil)
  if valid_609568 != nil:
    section.add "X-Amz-Credential", valid_609568
  var valid_609569 = header.getOrDefault("X-Amz-Security-Token")
  valid_609569 = validateParameter(valid_609569, JString, required = false,
                                 default = nil)
  if valid_609569 != nil:
    section.add "X-Amz-Security-Token", valid_609569
  var valid_609570 = header.getOrDefault("X-Amz-Algorithm")
  valid_609570 = validateParameter(valid_609570, JString, required = false,
                                 default = nil)
  if valid_609570 != nil:
    section.add "X-Amz-Algorithm", valid_609570
  var valid_609571 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_609571 = validateParameter(valid_609571, JString, required = false,
                                 default = nil)
  if valid_609571 != nil:
    section.add "X-Amz-SignedHeaders", valid_609571
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of the cluster that you want to rotate the encryption keys for.</p> <p>Constraints: Must be the name of valid cluster that has encryption enabled.</p>
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_609572 = formData.getOrDefault("ClusterIdentifier")
  valid_609572 = validateParameter(valid_609572, JString, required = true,
                                 default = nil)
  if valid_609572 != nil:
    section.add "ClusterIdentifier", valid_609572
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_609573: Call_PostRotateEncryptionKey_609560; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Rotates the encryption keys for a cluster.
  ## 
  let valid = call_609573.validator(path, query, header, formData, body)
  let scheme = call_609573.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_609573.url(scheme.get, call_609573.host, call_609573.base,
                         call_609573.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_609573, url, valid)

proc call*(call_609574: Call_PostRotateEncryptionKey_609560;
          ClusterIdentifier: string; Action: string = "RotateEncryptionKey";
          Version: string = "2012-12-01"): Recallable =
  ## postRotateEncryptionKey
  ## Rotates the encryption keys for a cluster.
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of the cluster that you want to rotate the encryption keys for.</p> <p>Constraints: Must be the name of valid cluster that has encryption enabled.</p>
  ##   Action: string (required)
  ##   Version: string (required)
  var query_609575 = newJObject()
  var formData_609576 = newJObject()
  add(formData_609576, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_609575, "Action", newJString(Action))
  add(query_609575, "Version", newJString(Version))
  result = call_609574.call(nil, query_609575, nil, formData_609576, nil)

var postRotateEncryptionKey* = Call_PostRotateEncryptionKey_609560(
    name: "postRotateEncryptionKey", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=RotateEncryptionKey",
    validator: validate_PostRotateEncryptionKey_609561, base: "/",
    url: url_PostRotateEncryptionKey_609562, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetRotateEncryptionKey_609544 = ref object of OpenApiRestCall_605573
proc url_GetRotateEncryptionKey_609546(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetRotateEncryptionKey_609545(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Rotates the encryption keys for a cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of the cluster that you want to rotate the encryption keys for.</p> <p>Constraints: Must be the name of valid cluster that has encryption enabled.</p>
  ##   Version: JString (required)
  section = newJObject()
  var valid_609547 = query.getOrDefault("Action")
  valid_609547 = validateParameter(valid_609547, JString, required = true,
                                 default = newJString("RotateEncryptionKey"))
  if valid_609547 != nil:
    section.add "Action", valid_609547
  var valid_609548 = query.getOrDefault("ClusterIdentifier")
  valid_609548 = validateParameter(valid_609548, JString, required = true,
                                 default = nil)
  if valid_609548 != nil:
    section.add "ClusterIdentifier", valid_609548
  var valid_609549 = query.getOrDefault("Version")
  valid_609549 = validateParameter(valid_609549, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_609549 != nil:
    section.add "Version", valid_609549
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_609550 = header.getOrDefault("X-Amz-Signature")
  valid_609550 = validateParameter(valid_609550, JString, required = false,
                                 default = nil)
  if valid_609550 != nil:
    section.add "X-Amz-Signature", valid_609550
  var valid_609551 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_609551 = validateParameter(valid_609551, JString, required = false,
                                 default = nil)
  if valid_609551 != nil:
    section.add "X-Amz-Content-Sha256", valid_609551
  var valid_609552 = header.getOrDefault("X-Amz-Date")
  valid_609552 = validateParameter(valid_609552, JString, required = false,
                                 default = nil)
  if valid_609552 != nil:
    section.add "X-Amz-Date", valid_609552
  var valid_609553 = header.getOrDefault("X-Amz-Credential")
  valid_609553 = validateParameter(valid_609553, JString, required = false,
                                 default = nil)
  if valid_609553 != nil:
    section.add "X-Amz-Credential", valid_609553
  var valid_609554 = header.getOrDefault("X-Amz-Security-Token")
  valid_609554 = validateParameter(valid_609554, JString, required = false,
                                 default = nil)
  if valid_609554 != nil:
    section.add "X-Amz-Security-Token", valid_609554
  var valid_609555 = header.getOrDefault("X-Amz-Algorithm")
  valid_609555 = validateParameter(valid_609555, JString, required = false,
                                 default = nil)
  if valid_609555 != nil:
    section.add "X-Amz-Algorithm", valid_609555
  var valid_609556 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_609556 = validateParameter(valid_609556, JString, required = false,
                                 default = nil)
  if valid_609556 != nil:
    section.add "X-Amz-SignedHeaders", valid_609556
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_609557: Call_GetRotateEncryptionKey_609544; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Rotates the encryption keys for a cluster.
  ## 
  let valid = call_609557.validator(path, query, header, formData, body)
  let scheme = call_609557.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_609557.url(scheme.get, call_609557.host, call_609557.base,
                         call_609557.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_609557, url, valid)

proc call*(call_609558: Call_GetRotateEncryptionKey_609544;
          ClusterIdentifier: string; Action: string = "RotateEncryptionKey";
          Version: string = "2012-12-01"): Recallable =
  ## getRotateEncryptionKey
  ## Rotates the encryption keys for a cluster.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of the cluster that you want to rotate the encryption keys for.</p> <p>Constraints: Must be the name of valid cluster that has encryption enabled.</p>
  ##   Version: string (required)
  var query_609559 = newJObject()
  add(query_609559, "Action", newJString(Action))
  add(query_609559, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_609559, "Version", newJString(Version))
  result = call_609558.call(nil, query_609559, nil, nil, nil)

var getRotateEncryptionKey* = Call_GetRotateEncryptionKey_609544(
    name: "getRotateEncryptionKey", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=RotateEncryptionKey",
    validator: validate_GetRotateEncryptionKey_609545, base: "/",
    url: url_GetRotateEncryptionKey_609546, schemes: {Scheme.Https, Scheme.Http})
export
  rest

type
  EnvKind = enum
    BakeIntoBinary = "Baking $1 into the binary",
    FetchFromEnv = "Fetch $1 from the environment"
template sloppyConst(via: EnvKind; name: untyped): untyped =
  import
    macros

  const
    name {.strdefine.}: string = case via
    of BakeIntoBinary:
      getEnv(astToStr(name), "")
    of FetchFromEnv:
      ""
  static :
    let msg = block:
      if name == "":
        "Missing $1 in the environment"
      else:
        $via
    warning msg % [astToStr(name)]

sloppyConst FetchFromEnv, AWS_ACCESS_KEY_ID
sloppyConst FetchFromEnv, AWS_SECRET_ACCESS_KEY
sloppyConst BakeIntoBinary, AWS_REGION
sloppyConst FetchFromEnv, AWS_ACCOUNT_ID
proc atozSign(recall: var Recallable; query: JsonNode; algo: SigningAlgo = SHA256) =
  let
    date = makeDateTime()
    access = os.getEnv("AWS_ACCESS_KEY_ID", AWS_ACCESS_KEY_ID)
    secret = os.getEnv("AWS_SECRET_ACCESS_KEY", AWS_SECRET_ACCESS_KEY)
    region = os.getEnv("AWS_REGION", AWS_REGION)
  assert secret != "", "need $AWS_SECRET_ACCESS_KEY in environment"
  assert access != "", "need $AWS_ACCESS_KEY_ID in environment"
  assert region != "", "need $AWS_REGION in environment"
  var
    normal: PathNormal
    url = normalizeUrl(recall.url, query, normalize = normal)
    scheme = parseEnum[Scheme](url.scheme)
  assert scheme in awsServers, "unknown scheme `" & $scheme & "`"
  assert region in awsServers[scheme], "unknown region `" & region & "`"
  url.hostname = awsServers[scheme][region]
  case awsServiceName.toLowerAscii
  of "s3":
    normal = PathNormal.S3
  else:
    normal = PathNormal.Default
  recall.headers["Host"] = url.hostname
  recall.headers["X-Amz-Date"] = date
  let
    algo = SHA256
    scope = credentialScope(region = region, service = awsServiceName, date = date)
    request = canonicalRequest(recall.meth, $url, query, recall.headers, recall.body,
                             normalize = normal, digest = algo)
    sts = stringToSign(request.hash(algo), scope, date = date, digest = algo)
    signature = calculateSignature(secret = secret, date = date, region = region,
                                 service = awsServiceName, sts, digest = algo)
  var auth = $algo & " "
  auth &= "Credential=" & access / scope & ", "
  auth &= "SignedHeaders=" & recall.headers.signedHeaders & ", "
  auth &= "Signature=" & signature
  recall.headers["Authorization"] = auth
  recall.headers.del "Host"
  recall.url = $url

method atozHook(call: OpenApiRestCall; url: Uri; input: JsonNode): Recallable {.base.} =
  ## the hook is a terrible earworm
  var headers = newHttpHeaders(massageHeaders(input.getOrDefault("header")))
  let
    body = input.getOrDefault("body")
    text = if body == nil:
      "" elif body.kind == JString:
      body.getStr else:
      $body
  if body != nil and body.kind != JString:
    if not headers.hasKey("content-type"):
      headers["content-type"] = "application/x-amz-json-1.0"
  const
    XAmzSecurityToken = "X-Amz-Security-Token"
  if not headers.hasKey(XAmzSecurityToken):
    let session = getEnv("AWS_SESSION_TOKEN", "")
    if session != "":
      headers[XAmzSecurityToken] = session
  result = newRecallable(call, url, headers, text)
  result.atozSign(input.getOrDefault("query"), SHA256)
