
import
  json, options, hashes, uri, tables, rest, os, uri, strutils, httpcore, sigv4

## auto-generated via openapi macro
## title: Amazon Redshift
## version: 2012-12-01
## termsOfService: https://aws.amazon.com/service-terms/
## license:
##     name: Apache 2.0 License
##     url: http://www.apache.org/licenses/
## 
## <fullname>Amazon Redshift</fullname> <p> <b>Overview</b> </p> <p>This is an interface reference for Amazon Redshift. It contains documentation for one of the programming or command line interfaces you can use to manage Amazon Redshift clusters. Note that Amazon Redshift is asynchronous, which means that some interfaces may require techniques, such as polling or asynchronous callback handlers, to determine when a command has been applied. In this reference, the parameter descriptions indicate whether a change is applied immediately, on the next instance reboot, or during the next maintenance window. For a summary of the Amazon Redshift cluster management interfaces, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/using-aws-sdk.html">Using the Amazon Redshift Management Interfaces</a>.</p> <p>Amazon Redshift manages all the work of setting up, operating, and scaling a data warehouse: provisioning capacity, monitoring and backing up the cluster, and applying patches and upgrades to the Amazon Redshift engine. You can focus on using your data to acquire new insights for your business and customers.</p> <p>If you are a first-time user of Amazon Redshift, we recommend that you begin by reading the <a href="https://docs.aws.amazon.com/redshift/latest/gsg/getting-started.html">Amazon Redshift Getting Started Guide</a>.</p> <p>If you are a database developer, the <a href="https://docs.aws.amazon.com/redshift/latest/dg/welcome.html">Amazon Redshift Database Developer Guide</a> explains how to design, build, query, and maintain the databases that make up your data warehouse. </p>
## 
## Amazon Web Services documentation
## https://docs.aws.amazon.com/redshift/
type
  Scheme {.pure.} = enum
    Https = "https", Http = "http", Wss = "wss", Ws = "ws"
  ValidatorSignature = proc (query: JsonNode = nil; body: JsonNode = nil;
                          header: JsonNode = nil; path: JsonNode = nil;
                          formData: JsonNode = nil): JsonNode
  OpenApiRestCall = ref object of RestCall
    validator*: ValidatorSignature
    route*: string
    base*: string
    host*: string
    schemes*: set[Scheme]
    url*: proc (protocol: Scheme; host: string; base: string; route: string;
              path: JsonNode; query: JsonNode): Uri

  OpenApiRestCall_602450 = ref object of OpenApiRestCall
proc hash(scheme: Scheme): Hash {.used.} =
  result = hash(ord(scheme))

proc clone[T: OpenApiRestCall_602450](t: T): T {.used.} =
  result = T(name: t.name, meth: t.meth, host: t.host, base: t.base, route: t.route,
           schemes: t.schemes, validator: t.validator, url: t.url)

proc pickScheme(t: OpenApiRestCall_602450): Option[Scheme] {.used.} =
  ## select a supported scheme from a set of candidates
  for scheme in Scheme.low ..
      Scheme.high:
    if scheme notin t.schemes:
      continue
    if scheme in [Scheme.Https, Scheme.Wss]:
      when defined(ssl):
        return some(scheme)
      else:
        continue
    return some(scheme)

proc validateParameter(js: JsonNode; kind: JsonNodeKind; required: bool;
                      default: JsonNode = nil): JsonNode =
  ## ensure an input is of the correct json type and yield
  ## a suitable default value when appropriate
  if js ==
      nil:
    if default != nil:
      return validateParameter(default, kind, required = required)
  result = js
  if result ==
      nil:
    assert not required, $kind & " expected; received nil"
    if required:
      result = newJNull()
  else:
    assert js.kind ==
        kind, $kind & " expected; received " &
        $js.kind

type
  KeyVal {.used.} = tuple[key: string, val: string]
  PathTokenKind = enum
    ConstantSegment, VariableSegment
  PathToken = tuple[kind: PathTokenKind, value: string]
proc queryString(query: JsonNode): string {.used.} =
  var qs: seq[KeyVal]
  if query == nil:
    return ""
  for k, v in query.pairs:
    qs.add (key: k, val: v.getStr)
  result = encodeQuery(qs)

proc hydratePath(input: JsonNode; segments: seq[PathToken]): Option[string] {.used.} =
  ## reconstitute a path with constants and variable values taken from json
  var head: string
  if segments.len == 0:
    return some("")
  head = segments[0].value
  case segments[0].kind
  of ConstantSegment:
    discard
  of VariableSegment:
    if head notin input:
      return
    let js = input[head]
    if js.kind notin {JString, JInt, JFloat, JNull, JBool}:
      return
    head = $js
  var remainder = input.hydratePath(segments[1 ..^ 1])
  if remainder.isNone:
    return
  result = some(head & remainder.get)

const
  awsServers = {Scheme.Http: {"ap-northeast-1": "redshift.ap-northeast-1.amazonaws.com", "ap-southeast-1": "redshift.ap-southeast-1.amazonaws.com",
                           "us-west-2": "redshift.us-west-2.amazonaws.com",
                           "eu-west-2": "redshift.eu-west-2.amazonaws.com", "ap-northeast-3": "redshift.ap-northeast-3.amazonaws.com", "eu-central-1": "redshift.eu-central-1.amazonaws.com",
                           "us-east-2": "redshift.us-east-2.amazonaws.com",
                           "us-east-1": "redshift.us-east-1.amazonaws.com", "cn-northwest-1": "redshift.cn-northwest-1.amazonaws.com.cn",
                           "ap-south-1": "redshift.ap-south-1.amazonaws.com",
                           "eu-north-1": "redshift.eu-north-1.amazonaws.com", "ap-northeast-2": "redshift.ap-northeast-2.amazonaws.com",
                           "us-west-1": "redshift.us-west-1.amazonaws.com", "us-gov-east-1": "redshift.us-gov-east-1.amazonaws.com",
                           "eu-west-3": "redshift.eu-west-3.amazonaws.com", "cn-north-1": "redshift.cn-north-1.amazonaws.com.cn",
                           "sa-east-1": "redshift.sa-east-1.amazonaws.com",
                           "eu-west-1": "redshift.eu-west-1.amazonaws.com", "us-gov-west-1": "redshift.us-gov-west-1.amazonaws.com", "ap-southeast-2": "redshift.ap-southeast-2.amazonaws.com", "ca-central-1": "redshift.ca-central-1.amazonaws.com"}.toTable, Scheme.Https: {
      "ap-northeast-1": "redshift.ap-northeast-1.amazonaws.com",
      "ap-southeast-1": "redshift.ap-southeast-1.amazonaws.com",
      "us-west-2": "redshift.us-west-2.amazonaws.com",
      "eu-west-2": "redshift.eu-west-2.amazonaws.com",
      "ap-northeast-3": "redshift.ap-northeast-3.amazonaws.com",
      "eu-central-1": "redshift.eu-central-1.amazonaws.com",
      "us-east-2": "redshift.us-east-2.amazonaws.com",
      "us-east-1": "redshift.us-east-1.amazonaws.com",
      "cn-northwest-1": "redshift.cn-northwest-1.amazonaws.com.cn",
      "ap-south-1": "redshift.ap-south-1.amazonaws.com",
      "eu-north-1": "redshift.eu-north-1.amazonaws.com",
      "ap-northeast-2": "redshift.ap-northeast-2.amazonaws.com",
      "us-west-1": "redshift.us-west-1.amazonaws.com",
      "us-gov-east-1": "redshift.us-gov-east-1.amazonaws.com",
      "eu-west-3": "redshift.eu-west-3.amazonaws.com",
      "cn-north-1": "redshift.cn-north-1.amazonaws.com.cn",
      "sa-east-1": "redshift.sa-east-1.amazonaws.com",
      "eu-west-1": "redshift.eu-west-1.amazonaws.com",
      "us-gov-west-1": "redshift.us-gov-west-1.amazonaws.com",
      "ap-southeast-2": "redshift.ap-southeast-2.amazonaws.com",
      "ca-central-1": "redshift.ca-central-1.amazonaws.com"}.toTable}.toTable
const
  awsServiceName = "redshift"
method hook(call: OpenApiRestCall; url: Uri; input: JsonNode): Recallable {.base.}
type
  Call_PostAcceptReservedNodeExchange_603059 = ref object of OpenApiRestCall_602450
proc url_PostAcceptReservedNodeExchange_603061(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostAcceptReservedNodeExchange_603060(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Exchanges a DC1 Reserved Node for a DC2 Reserved Node with no changes to the configuration (term, payment type, or number of nodes) and no additional costs. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_603062 = query.getOrDefault("Action")
  valid_603062 = validateParameter(valid_603062, JString, required = true, default = newJString(
      "AcceptReservedNodeExchange"))
  if valid_603062 != nil:
    section.add "Action", valid_603062
  var valid_603063 = query.getOrDefault("Version")
  valid_603063 = validateParameter(valid_603063, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_603063 != nil:
    section.add "Version", valid_603063
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603064 = header.getOrDefault("X-Amz-Date")
  valid_603064 = validateParameter(valid_603064, JString, required = false,
                                 default = nil)
  if valid_603064 != nil:
    section.add "X-Amz-Date", valid_603064
  var valid_603065 = header.getOrDefault("X-Amz-Security-Token")
  valid_603065 = validateParameter(valid_603065, JString, required = false,
                                 default = nil)
  if valid_603065 != nil:
    section.add "X-Amz-Security-Token", valid_603065
  var valid_603066 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603066 = validateParameter(valid_603066, JString, required = false,
                                 default = nil)
  if valid_603066 != nil:
    section.add "X-Amz-Content-Sha256", valid_603066
  var valid_603067 = header.getOrDefault("X-Amz-Algorithm")
  valid_603067 = validateParameter(valid_603067, JString, required = false,
                                 default = nil)
  if valid_603067 != nil:
    section.add "X-Amz-Algorithm", valid_603067
  var valid_603068 = header.getOrDefault("X-Amz-Signature")
  valid_603068 = validateParameter(valid_603068, JString, required = false,
                                 default = nil)
  if valid_603068 != nil:
    section.add "X-Amz-Signature", valid_603068
  var valid_603069 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603069 = validateParameter(valid_603069, JString, required = false,
                                 default = nil)
  if valid_603069 != nil:
    section.add "X-Amz-SignedHeaders", valid_603069
  var valid_603070 = header.getOrDefault("X-Amz-Credential")
  valid_603070 = validateParameter(valid_603070, JString, required = false,
                                 default = nil)
  if valid_603070 != nil:
    section.add "X-Amz-Credential", valid_603070
  result.add "header", section
  ## parameters in `formData` object:
  ##   ReservedNodeId: JString (required)
  ##                 : A string representing the node identifier of the DC1 Reserved Node to be exchanged.
  ##   TargetReservedNodeOfferingId: JString (required)
  ##                               : The unique identifier of the DC2 Reserved Node offering to be used for the exchange. You can obtain the value for the parameter by calling <a>GetReservedNodeExchangeOfferings</a> 
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `ReservedNodeId` field"
  var valid_603071 = formData.getOrDefault("ReservedNodeId")
  valid_603071 = validateParameter(valid_603071, JString, required = true,
                                 default = nil)
  if valid_603071 != nil:
    section.add "ReservedNodeId", valid_603071
  var valid_603072 = formData.getOrDefault("TargetReservedNodeOfferingId")
  valid_603072 = validateParameter(valid_603072, JString, required = true,
                                 default = nil)
  if valid_603072 != nil:
    section.add "TargetReservedNodeOfferingId", valid_603072
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603073: Call_PostAcceptReservedNodeExchange_603059; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Exchanges a DC1 Reserved Node for a DC2 Reserved Node with no changes to the configuration (term, payment type, or number of nodes) and no additional costs. 
  ## 
  let valid = call_603073.validator(path, query, header, formData, body)
  let scheme = call_603073.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603073.url(scheme.get, call_603073.host, call_603073.base,
                         call_603073.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_603073, url, valid)

proc call*(call_603074: Call_PostAcceptReservedNodeExchange_603059;
          ReservedNodeId: string; TargetReservedNodeOfferingId: string;
          Action: string = "AcceptReservedNodeExchange";
          Version: string = "2012-12-01"): Recallable =
  ## postAcceptReservedNodeExchange
  ## Exchanges a DC1 Reserved Node for a DC2 Reserved Node with no changes to the configuration (term, payment type, or number of nodes) and no additional costs. 
  ##   ReservedNodeId: string (required)
  ##                 : A string representing the node identifier of the DC1 Reserved Node to be exchanged.
  ##   TargetReservedNodeOfferingId: string (required)
  ##                               : The unique identifier of the DC2 Reserved Node offering to be used for the exchange. You can obtain the value for the parameter by calling <a>GetReservedNodeExchangeOfferings</a> 
  ##   Action: string (required)
  ##   Version: string (required)
  var query_603075 = newJObject()
  var formData_603076 = newJObject()
  add(formData_603076, "ReservedNodeId", newJString(ReservedNodeId))
  add(formData_603076, "TargetReservedNodeOfferingId",
      newJString(TargetReservedNodeOfferingId))
  add(query_603075, "Action", newJString(Action))
  add(query_603075, "Version", newJString(Version))
  result = call_603074.call(nil, query_603075, nil, formData_603076, nil)

var postAcceptReservedNodeExchange* = Call_PostAcceptReservedNodeExchange_603059(
    name: "postAcceptReservedNodeExchange", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=AcceptReservedNodeExchange",
    validator: validate_PostAcceptReservedNodeExchange_603060, base: "/",
    url: url_PostAcceptReservedNodeExchange_603061,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetAcceptReservedNodeExchange_602787 = ref object of OpenApiRestCall_602450
proc url_GetAcceptReservedNodeExchange_602789(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetAcceptReservedNodeExchange_602788(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Exchanges a DC1 Reserved Node for a DC2 Reserved Node with no changes to the configuration (term, payment type, or number of nodes) and no additional costs. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   TargetReservedNodeOfferingId: JString (required)
  ##                               : The unique identifier of the DC2 Reserved Node offering to be used for the exchange. You can obtain the value for the parameter by calling <a>GetReservedNodeExchangeOfferings</a> 
  ##   Version: JString (required)
  ##   ReservedNodeId: JString (required)
  ##                 : A string representing the node identifier of the DC1 Reserved Node to be exchanged.
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_602914 = query.getOrDefault("Action")
  valid_602914 = validateParameter(valid_602914, JString, required = true, default = newJString(
      "AcceptReservedNodeExchange"))
  if valid_602914 != nil:
    section.add "Action", valid_602914
  var valid_602915 = query.getOrDefault("TargetReservedNodeOfferingId")
  valid_602915 = validateParameter(valid_602915, JString, required = true,
                                 default = nil)
  if valid_602915 != nil:
    section.add "TargetReservedNodeOfferingId", valid_602915
  var valid_602916 = query.getOrDefault("Version")
  valid_602916 = validateParameter(valid_602916, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_602916 != nil:
    section.add "Version", valid_602916
  var valid_602917 = query.getOrDefault("ReservedNodeId")
  valid_602917 = validateParameter(valid_602917, JString, required = true,
                                 default = nil)
  if valid_602917 != nil:
    section.add "ReservedNodeId", valid_602917
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_602918 = header.getOrDefault("X-Amz-Date")
  valid_602918 = validateParameter(valid_602918, JString, required = false,
                                 default = nil)
  if valid_602918 != nil:
    section.add "X-Amz-Date", valid_602918
  var valid_602919 = header.getOrDefault("X-Amz-Security-Token")
  valid_602919 = validateParameter(valid_602919, JString, required = false,
                                 default = nil)
  if valid_602919 != nil:
    section.add "X-Amz-Security-Token", valid_602919
  var valid_602920 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602920 = validateParameter(valid_602920, JString, required = false,
                                 default = nil)
  if valid_602920 != nil:
    section.add "X-Amz-Content-Sha256", valid_602920
  var valid_602921 = header.getOrDefault("X-Amz-Algorithm")
  valid_602921 = validateParameter(valid_602921, JString, required = false,
                                 default = nil)
  if valid_602921 != nil:
    section.add "X-Amz-Algorithm", valid_602921
  var valid_602922 = header.getOrDefault("X-Amz-Signature")
  valid_602922 = validateParameter(valid_602922, JString, required = false,
                                 default = nil)
  if valid_602922 != nil:
    section.add "X-Amz-Signature", valid_602922
  var valid_602923 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602923 = validateParameter(valid_602923, JString, required = false,
                                 default = nil)
  if valid_602923 != nil:
    section.add "X-Amz-SignedHeaders", valid_602923
  var valid_602924 = header.getOrDefault("X-Amz-Credential")
  valid_602924 = validateParameter(valid_602924, JString, required = false,
                                 default = nil)
  if valid_602924 != nil:
    section.add "X-Amz-Credential", valid_602924
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602947: Call_GetAcceptReservedNodeExchange_602787; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Exchanges a DC1 Reserved Node for a DC2 Reserved Node with no changes to the configuration (term, payment type, or number of nodes) and no additional costs. 
  ## 
  let valid = call_602947.validator(path, query, header, formData, body)
  let scheme = call_602947.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602947.url(scheme.get, call_602947.host, call_602947.base,
                         call_602947.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_602947, url, valid)

proc call*(call_603018: Call_GetAcceptReservedNodeExchange_602787;
          TargetReservedNodeOfferingId: string; ReservedNodeId: string;
          Action: string = "AcceptReservedNodeExchange";
          Version: string = "2012-12-01"): Recallable =
  ## getAcceptReservedNodeExchange
  ## Exchanges a DC1 Reserved Node for a DC2 Reserved Node with no changes to the configuration (term, payment type, or number of nodes) and no additional costs. 
  ##   Action: string (required)
  ##   TargetReservedNodeOfferingId: string (required)
  ##                               : The unique identifier of the DC2 Reserved Node offering to be used for the exchange. You can obtain the value for the parameter by calling <a>GetReservedNodeExchangeOfferings</a> 
  ##   Version: string (required)
  ##   ReservedNodeId: string (required)
  ##                 : A string representing the node identifier of the DC1 Reserved Node to be exchanged.
  var query_603019 = newJObject()
  add(query_603019, "Action", newJString(Action))
  add(query_603019, "TargetReservedNodeOfferingId",
      newJString(TargetReservedNodeOfferingId))
  add(query_603019, "Version", newJString(Version))
  add(query_603019, "ReservedNodeId", newJString(ReservedNodeId))
  result = call_603018.call(nil, query_603019, nil, nil, nil)

var getAcceptReservedNodeExchange* = Call_GetAcceptReservedNodeExchange_602787(
    name: "getAcceptReservedNodeExchange", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=AcceptReservedNodeExchange",
    validator: validate_GetAcceptReservedNodeExchange_602788, base: "/",
    url: url_GetAcceptReservedNodeExchange_602789,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostAuthorizeClusterSecurityGroupIngress_603096 = ref object of OpenApiRestCall_602450
proc url_PostAuthorizeClusterSecurityGroupIngress_603098(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostAuthorizeClusterSecurityGroupIngress_603097(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Adds an inbound (ingress) rule to an Amazon Redshift security group. Depending on whether the application accessing your cluster is running on the Internet or an Amazon EC2 instance, you can authorize inbound access to either a Classless Interdomain Routing (CIDR)/Internet Protocol (IP) range or to an Amazon EC2 security group. You can add as many as 20 ingress rules to an Amazon Redshift security group.</p> <p>If you authorize access to an Amazon EC2 security group, specify <i>EC2SecurityGroupName</i> and <i>EC2SecurityGroupOwnerId</i>. The Amazon EC2 security group and Amazon Redshift cluster must be in the same AWS Region. </p> <p>If you authorize access to a CIDR/IP address range, specify <i>CIDRIP</i>. For an overview of CIDR blocks, see the Wikipedia article on <a href="http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing">Classless Inter-Domain Routing</a>. </p> <p>You must also associate the security group with a cluster so that clients running on these IP addresses or the EC2 instance are authorized to connect to the cluster. For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Working with Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_603099 = query.getOrDefault("Action")
  valid_603099 = validateParameter(valid_603099, JString, required = true, default = newJString(
      "AuthorizeClusterSecurityGroupIngress"))
  if valid_603099 != nil:
    section.add "Action", valid_603099
  var valid_603100 = query.getOrDefault("Version")
  valid_603100 = validateParameter(valid_603100, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_603100 != nil:
    section.add "Version", valid_603100
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603101 = header.getOrDefault("X-Amz-Date")
  valid_603101 = validateParameter(valid_603101, JString, required = false,
                                 default = nil)
  if valid_603101 != nil:
    section.add "X-Amz-Date", valid_603101
  var valid_603102 = header.getOrDefault("X-Amz-Security-Token")
  valid_603102 = validateParameter(valid_603102, JString, required = false,
                                 default = nil)
  if valid_603102 != nil:
    section.add "X-Amz-Security-Token", valid_603102
  var valid_603103 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603103 = validateParameter(valid_603103, JString, required = false,
                                 default = nil)
  if valid_603103 != nil:
    section.add "X-Amz-Content-Sha256", valid_603103
  var valid_603104 = header.getOrDefault("X-Amz-Algorithm")
  valid_603104 = validateParameter(valid_603104, JString, required = false,
                                 default = nil)
  if valid_603104 != nil:
    section.add "X-Amz-Algorithm", valid_603104
  var valid_603105 = header.getOrDefault("X-Amz-Signature")
  valid_603105 = validateParameter(valid_603105, JString, required = false,
                                 default = nil)
  if valid_603105 != nil:
    section.add "X-Amz-Signature", valid_603105
  var valid_603106 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603106 = validateParameter(valid_603106, JString, required = false,
                                 default = nil)
  if valid_603106 != nil:
    section.add "X-Amz-SignedHeaders", valid_603106
  var valid_603107 = header.getOrDefault("X-Amz-Credential")
  valid_603107 = validateParameter(valid_603107, JString, required = false,
                                 default = nil)
  if valid_603107 != nil:
    section.add "X-Amz-Credential", valid_603107
  result.add "header", section
  ## parameters in `formData` object:
  ##   EC2SecurityGroupName: JString
  ##                       : The EC2 security group to be added the Amazon Redshift security group.
  ##   CIDRIP: JString
  ##         : The IP range to be added the Amazon Redshift security group.
  ##   EC2SecurityGroupOwnerId: JString
  ##                          : <p>The AWS account number of the owner of the security group specified by the <i>EC2SecurityGroupName</i> parameter. The AWS Access Key ID is not an acceptable value. </p> <p>Example: <code>111122223333</code> </p>
  ##   ClusterSecurityGroupName: JString (required)
  ##                           : The name of the security group to which the ingress rule is added.
  section = newJObject()
  var valid_603108 = formData.getOrDefault("EC2SecurityGroupName")
  valid_603108 = validateParameter(valid_603108, JString, required = false,
                                 default = nil)
  if valid_603108 != nil:
    section.add "EC2SecurityGroupName", valid_603108
  var valid_603109 = formData.getOrDefault("CIDRIP")
  valid_603109 = validateParameter(valid_603109, JString, required = false,
                                 default = nil)
  if valid_603109 != nil:
    section.add "CIDRIP", valid_603109
  var valid_603110 = formData.getOrDefault("EC2SecurityGroupOwnerId")
  valid_603110 = validateParameter(valid_603110, JString, required = false,
                                 default = nil)
  if valid_603110 != nil:
    section.add "EC2SecurityGroupOwnerId", valid_603110
  assert formData != nil, "formData argument is necessary due to required `ClusterSecurityGroupName` field"
  var valid_603111 = formData.getOrDefault("ClusterSecurityGroupName")
  valid_603111 = validateParameter(valid_603111, JString, required = true,
                                 default = nil)
  if valid_603111 != nil:
    section.add "ClusterSecurityGroupName", valid_603111
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603112: Call_PostAuthorizeClusterSecurityGroupIngress_603096;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Adds an inbound (ingress) rule to an Amazon Redshift security group. Depending on whether the application accessing your cluster is running on the Internet or an Amazon EC2 instance, you can authorize inbound access to either a Classless Interdomain Routing (CIDR)/Internet Protocol (IP) range or to an Amazon EC2 security group. You can add as many as 20 ingress rules to an Amazon Redshift security group.</p> <p>If you authorize access to an Amazon EC2 security group, specify <i>EC2SecurityGroupName</i> and <i>EC2SecurityGroupOwnerId</i>. The Amazon EC2 security group and Amazon Redshift cluster must be in the same AWS Region. </p> <p>If you authorize access to a CIDR/IP address range, specify <i>CIDRIP</i>. For an overview of CIDR blocks, see the Wikipedia article on <a href="http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing">Classless Inter-Domain Routing</a>. </p> <p>You must also associate the security group with a cluster so that clients running on these IP addresses or the EC2 instance are authorized to connect to the cluster. For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Working with Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_603112.validator(path, query, header, formData, body)
  let scheme = call_603112.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603112.url(scheme.get, call_603112.host, call_603112.base,
                         call_603112.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_603112, url, valid)

proc call*(call_603113: Call_PostAuthorizeClusterSecurityGroupIngress_603096;
          ClusterSecurityGroupName: string;
          Action: string = "AuthorizeClusterSecurityGroupIngress";
          EC2SecurityGroupName: string = ""; CIDRIP: string = "";
          Version: string = "2012-12-01"; EC2SecurityGroupOwnerId: string = ""): Recallable =
  ## postAuthorizeClusterSecurityGroupIngress
  ## <p>Adds an inbound (ingress) rule to an Amazon Redshift security group. Depending on whether the application accessing your cluster is running on the Internet or an Amazon EC2 instance, you can authorize inbound access to either a Classless Interdomain Routing (CIDR)/Internet Protocol (IP) range or to an Amazon EC2 security group. You can add as many as 20 ingress rules to an Amazon Redshift security group.</p> <p>If you authorize access to an Amazon EC2 security group, specify <i>EC2SecurityGroupName</i> and <i>EC2SecurityGroupOwnerId</i>. The Amazon EC2 security group and Amazon Redshift cluster must be in the same AWS Region. </p> <p>If you authorize access to a CIDR/IP address range, specify <i>CIDRIP</i>. For an overview of CIDR blocks, see the Wikipedia article on <a href="http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing">Classless Inter-Domain Routing</a>. </p> <p>You must also associate the security group with a cluster so that clients running on these IP addresses or the EC2 instance are authorized to connect to the cluster. For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Working with Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   Action: string (required)
  ##   EC2SecurityGroupName: string
  ##                       : The EC2 security group to be added the Amazon Redshift security group.
  ##   CIDRIP: string
  ##         : The IP range to be added the Amazon Redshift security group.
  ##   Version: string (required)
  ##   EC2SecurityGroupOwnerId: string
  ##                          : <p>The AWS account number of the owner of the security group specified by the <i>EC2SecurityGroupName</i> parameter. The AWS Access Key ID is not an acceptable value. </p> <p>Example: <code>111122223333</code> </p>
  ##   ClusterSecurityGroupName: string (required)
  ##                           : The name of the security group to which the ingress rule is added.
  var query_603114 = newJObject()
  var formData_603115 = newJObject()
  add(query_603114, "Action", newJString(Action))
  add(formData_603115, "EC2SecurityGroupName", newJString(EC2SecurityGroupName))
  add(formData_603115, "CIDRIP", newJString(CIDRIP))
  add(query_603114, "Version", newJString(Version))
  add(formData_603115, "EC2SecurityGroupOwnerId",
      newJString(EC2SecurityGroupOwnerId))
  add(formData_603115, "ClusterSecurityGroupName",
      newJString(ClusterSecurityGroupName))
  result = call_603113.call(nil, query_603114, nil, formData_603115, nil)

var postAuthorizeClusterSecurityGroupIngress* = Call_PostAuthorizeClusterSecurityGroupIngress_603096(
    name: "postAuthorizeClusterSecurityGroupIngress", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=AuthorizeClusterSecurityGroupIngress",
    validator: validate_PostAuthorizeClusterSecurityGroupIngress_603097,
    base: "/", url: url_PostAuthorizeClusterSecurityGroupIngress_603098,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetAuthorizeClusterSecurityGroupIngress_603077 = ref object of OpenApiRestCall_602450
proc url_GetAuthorizeClusterSecurityGroupIngress_603079(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetAuthorizeClusterSecurityGroupIngress_603078(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Adds an inbound (ingress) rule to an Amazon Redshift security group. Depending on whether the application accessing your cluster is running on the Internet or an Amazon EC2 instance, you can authorize inbound access to either a Classless Interdomain Routing (CIDR)/Internet Protocol (IP) range or to an Amazon EC2 security group. You can add as many as 20 ingress rules to an Amazon Redshift security group.</p> <p>If you authorize access to an Amazon EC2 security group, specify <i>EC2SecurityGroupName</i> and <i>EC2SecurityGroupOwnerId</i>. The Amazon EC2 security group and Amazon Redshift cluster must be in the same AWS Region. </p> <p>If you authorize access to a CIDR/IP address range, specify <i>CIDRIP</i>. For an overview of CIDR blocks, see the Wikipedia article on <a href="http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing">Classless Inter-Domain Routing</a>. </p> <p>You must also associate the security group with a cluster so that clients running on these IP addresses or the EC2 instance are authorized to connect to the cluster. For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Working with Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ClusterSecurityGroupName: JString (required)
  ##                           : The name of the security group to which the ingress rule is added.
  ##   EC2SecurityGroupOwnerId: JString
  ##                          : <p>The AWS account number of the owner of the security group specified by the <i>EC2SecurityGroupName</i> parameter. The AWS Access Key ID is not an acceptable value. </p> <p>Example: <code>111122223333</code> </p>
  ##   Action: JString (required)
  ##   CIDRIP: JString
  ##         : The IP range to be added the Amazon Redshift security group.
  ##   EC2SecurityGroupName: JString
  ##                       : The EC2 security group to be added the Amazon Redshift security group.
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `ClusterSecurityGroupName` field"
  var valid_603080 = query.getOrDefault("ClusterSecurityGroupName")
  valid_603080 = validateParameter(valid_603080, JString, required = true,
                                 default = nil)
  if valid_603080 != nil:
    section.add "ClusterSecurityGroupName", valid_603080
  var valid_603081 = query.getOrDefault("EC2SecurityGroupOwnerId")
  valid_603081 = validateParameter(valid_603081, JString, required = false,
                                 default = nil)
  if valid_603081 != nil:
    section.add "EC2SecurityGroupOwnerId", valid_603081
  var valid_603082 = query.getOrDefault("Action")
  valid_603082 = validateParameter(valid_603082, JString, required = true, default = newJString(
      "AuthorizeClusterSecurityGroupIngress"))
  if valid_603082 != nil:
    section.add "Action", valid_603082
  var valid_603083 = query.getOrDefault("CIDRIP")
  valid_603083 = validateParameter(valid_603083, JString, required = false,
                                 default = nil)
  if valid_603083 != nil:
    section.add "CIDRIP", valid_603083
  var valid_603084 = query.getOrDefault("EC2SecurityGroupName")
  valid_603084 = validateParameter(valid_603084, JString, required = false,
                                 default = nil)
  if valid_603084 != nil:
    section.add "EC2SecurityGroupName", valid_603084
  var valid_603085 = query.getOrDefault("Version")
  valid_603085 = validateParameter(valid_603085, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_603085 != nil:
    section.add "Version", valid_603085
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603086 = header.getOrDefault("X-Amz-Date")
  valid_603086 = validateParameter(valid_603086, JString, required = false,
                                 default = nil)
  if valid_603086 != nil:
    section.add "X-Amz-Date", valid_603086
  var valid_603087 = header.getOrDefault("X-Amz-Security-Token")
  valid_603087 = validateParameter(valid_603087, JString, required = false,
                                 default = nil)
  if valid_603087 != nil:
    section.add "X-Amz-Security-Token", valid_603087
  var valid_603088 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603088 = validateParameter(valid_603088, JString, required = false,
                                 default = nil)
  if valid_603088 != nil:
    section.add "X-Amz-Content-Sha256", valid_603088
  var valid_603089 = header.getOrDefault("X-Amz-Algorithm")
  valid_603089 = validateParameter(valid_603089, JString, required = false,
                                 default = nil)
  if valid_603089 != nil:
    section.add "X-Amz-Algorithm", valid_603089
  var valid_603090 = header.getOrDefault("X-Amz-Signature")
  valid_603090 = validateParameter(valid_603090, JString, required = false,
                                 default = nil)
  if valid_603090 != nil:
    section.add "X-Amz-Signature", valid_603090
  var valid_603091 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603091 = validateParameter(valid_603091, JString, required = false,
                                 default = nil)
  if valid_603091 != nil:
    section.add "X-Amz-SignedHeaders", valid_603091
  var valid_603092 = header.getOrDefault("X-Amz-Credential")
  valid_603092 = validateParameter(valid_603092, JString, required = false,
                                 default = nil)
  if valid_603092 != nil:
    section.add "X-Amz-Credential", valid_603092
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603093: Call_GetAuthorizeClusterSecurityGroupIngress_603077;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Adds an inbound (ingress) rule to an Amazon Redshift security group. Depending on whether the application accessing your cluster is running on the Internet or an Amazon EC2 instance, you can authorize inbound access to either a Classless Interdomain Routing (CIDR)/Internet Protocol (IP) range or to an Amazon EC2 security group. You can add as many as 20 ingress rules to an Amazon Redshift security group.</p> <p>If you authorize access to an Amazon EC2 security group, specify <i>EC2SecurityGroupName</i> and <i>EC2SecurityGroupOwnerId</i>. The Amazon EC2 security group and Amazon Redshift cluster must be in the same AWS Region. </p> <p>If you authorize access to a CIDR/IP address range, specify <i>CIDRIP</i>. For an overview of CIDR blocks, see the Wikipedia article on <a href="http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing">Classless Inter-Domain Routing</a>. </p> <p>You must also associate the security group with a cluster so that clients running on these IP addresses or the EC2 instance are authorized to connect to the cluster. For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Working with Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_603093.validator(path, query, header, formData, body)
  let scheme = call_603093.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603093.url(scheme.get, call_603093.host, call_603093.base,
                         call_603093.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_603093, url, valid)

proc call*(call_603094: Call_GetAuthorizeClusterSecurityGroupIngress_603077;
          ClusterSecurityGroupName: string; EC2SecurityGroupOwnerId: string = "";
          Action: string = "AuthorizeClusterSecurityGroupIngress";
          CIDRIP: string = ""; EC2SecurityGroupName: string = "";
          Version: string = "2012-12-01"): Recallable =
  ## getAuthorizeClusterSecurityGroupIngress
  ## <p>Adds an inbound (ingress) rule to an Amazon Redshift security group. Depending on whether the application accessing your cluster is running on the Internet or an Amazon EC2 instance, you can authorize inbound access to either a Classless Interdomain Routing (CIDR)/Internet Protocol (IP) range or to an Amazon EC2 security group. You can add as many as 20 ingress rules to an Amazon Redshift security group.</p> <p>If you authorize access to an Amazon EC2 security group, specify <i>EC2SecurityGroupName</i> and <i>EC2SecurityGroupOwnerId</i>. The Amazon EC2 security group and Amazon Redshift cluster must be in the same AWS Region. </p> <p>If you authorize access to a CIDR/IP address range, specify <i>CIDRIP</i>. For an overview of CIDR blocks, see the Wikipedia article on <a href="http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing">Classless Inter-Domain Routing</a>. </p> <p>You must also associate the security group with a cluster so that clients running on these IP addresses or the EC2 instance are authorized to connect to the cluster. For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Working with Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   ClusterSecurityGroupName: string (required)
  ##                           : The name of the security group to which the ingress rule is added.
  ##   EC2SecurityGroupOwnerId: string
  ##                          : <p>The AWS account number of the owner of the security group specified by the <i>EC2SecurityGroupName</i> parameter. The AWS Access Key ID is not an acceptable value. </p> <p>Example: <code>111122223333</code> </p>
  ##   Action: string (required)
  ##   CIDRIP: string
  ##         : The IP range to be added the Amazon Redshift security group.
  ##   EC2SecurityGroupName: string
  ##                       : The EC2 security group to be added the Amazon Redshift security group.
  ##   Version: string (required)
  var query_603095 = newJObject()
  add(query_603095, "ClusterSecurityGroupName",
      newJString(ClusterSecurityGroupName))
  add(query_603095, "EC2SecurityGroupOwnerId", newJString(EC2SecurityGroupOwnerId))
  add(query_603095, "Action", newJString(Action))
  add(query_603095, "CIDRIP", newJString(CIDRIP))
  add(query_603095, "EC2SecurityGroupName", newJString(EC2SecurityGroupName))
  add(query_603095, "Version", newJString(Version))
  result = call_603094.call(nil, query_603095, nil, nil, nil)

var getAuthorizeClusterSecurityGroupIngress* = Call_GetAuthorizeClusterSecurityGroupIngress_603077(
    name: "getAuthorizeClusterSecurityGroupIngress", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=AuthorizeClusterSecurityGroupIngress",
    validator: validate_GetAuthorizeClusterSecurityGroupIngress_603078, base: "/",
    url: url_GetAuthorizeClusterSecurityGroupIngress_603079,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostAuthorizeSnapshotAccess_603134 = ref object of OpenApiRestCall_602450
proc url_PostAuthorizeSnapshotAccess_603136(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostAuthorizeSnapshotAccess_603135(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Authorizes the specified AWS customer account to restore the specified snapshot.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_603137 = query.getOrDefault("Action")
  valid_603137 = validateParameter(valid_603137, JString, required = true, default = newJString(
      "AuthorizeSnapshotAccess"))
  if valid_603137 != nil:
    section.add "Action", valid_603137
  var valid_603138 = query.getOrDefault("Version")
  valid_603138 = validateParameter(valid_603138, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_603138 != nil:
    section.add "Version", valid_603138
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603139 = header.getOrDefault("X-Amz-Date")
  valid_603139 = validateParameter(valid_603139, JString, required = false,
                                 default = nil)
  if valid_603139 != nil:
    section.add "X-Amz-Date", valid_603139
  var valid_603140 = header.getOrDefault("X-Amz-Security-Token")
  valid_603140 = validateParameter(valid_603140, JString, required = false,
                                 default = nil)
  if valid_603140 != nil:
    section.add "X-Amz-Security-Token", valid_603140
  var valid_603141 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603141 = validateParameter(valid_603141, JString, required = false,
                                 default = nil)
  if valid_603141 != nil:
    section.add "X-Amz-Content-Sha256", valid_603141
  var valid_603142 = header.getOrDefault("X-Amz-Algorithm")
  valid_603142 = validateParameter(valid_603142, JString, required = false,
                                 default = nil)
  if valid_603142 != nil:
    section.add "X-Amz-Algorithm", valid_603142
  var valid_603143 = header.getOrDefault("X-Amz-Signature")
  valid_603143 = validateParameter(valid_603143, JString, required = false,
                                 default = nil)
  if valid_603143 != nil:
    section.add "X-Amz-Signature", valid_603143
  var valid_603144 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603144 = validateParameter(valid_603144, JString, required = false,
                                 default = nil)
  if valid_603144 != nil:
    section.add "X-Amz-SignedHeaders", valid_603144
  var valid_603145 = header.getOrDefault("X-Amz-Credential")
  valid_603145 = validateParameter(valid_603145, JString, required = false,
                                 default = nil)
  if valid_603145 != nil:
    section.add "X-Amz-Credential", valid_603145
  result.add "header", section
  ## parameters in `formData` object:
  ##   AccountWithRestoreAccess: JString (required)
  ##                           : <p>The identifier of the AWS customer account authorized to restore the specified snapshot.</p> <p>To share a snapshot with AWS support, specify amazon-redshift-support.</p>
  ##   SnapshotClusterIdentifier: JString
  ##                            : The identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.
  ##   SnapshotIdentifier: JString (required)
  ##                     : The identifier of the snapshot the account is authorized to restore.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `AccountWithRestoreAccess` field"
  var valid_603146 = formData.getOrDefault("AccountWithRestoreAccess")
  valid_603146 = validateParameter(valid_603146, JString, required = true,
                                 default = nil)
  if valid_603146 != nil:
    section.add "AccountWithRestoreAccess", valid_603146
  var valid_603147 = formData.getOrDefault("SnapshotClusterIdentifier")
  valid_603147 = validateParameter(valid_603147, JString, required = false,
                                 default = nil)
  if valid_603147 != nil:
    section.add "SnapshotClusterIdentifier", valid_603147
  var valid_603148 = formData.getOrDefault("SnapshotIdentifier")
  valid_603148 = validateParameter(valid_603148, JString, required = true,
                                 default = nil)
  if valid_603148 != nil:
    section.add "SnapshotIdentifier", valid_603148
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603149: Call_PostAuthorizeSnapshotAccess_603134; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Authorizes the specified AWS customer account to restore the specified snapshot.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_603149.validator(path, query, header, formData, body)
  let scheme = call_603149.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603149.url(scheme.get, call_603149.host, call_603149.base,
                         call_603149.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_603149, url, valid)

proc call*(call_603150: Call_PostAuthorizeSnapshotAccess_603134;
          AccountWithRestoreAccess: string; SnapshotIdentifier: string;
          SnapshotClusterIdentifier: string = "";
          Action: string = "AuthorizeSnapshotAccess"; Version: string = "2012-12-01"): Recallable =
  ## postAuthorizeSnapshotAccess
  ## <p>Authorizes the specified AWS customer account to restore the specified snapshot.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   AccountWithRestoreAccess: string (required)
  ##                           : <p>The identifier of the AWS customer account authorized to restore the specified snapshot.</p> <p>To share a snapshot with AWS support, specify amazon-redshift-support.</p>
  ##   SnapshotClusterIdentifier: string
  ##                            : The identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.
  ##   Action: string (required)
  ##   SnapshotIdentifier: string (required)
  ##                     : The identifier of the snapshot the account is authorized to restore.
  ##   Version: string (required)
  var query_603151 = newJObject()
  var formData_603152 = newJObject()
  add(formData_603152, "AccountWithRestoreAccess",
      newJString(AccountWithRestoreAccess))
  add(formData_603152, "SnapshotClusterIdentifier",
      newJString(SnapshotClusterIdentifier))
  add(query_603151, "Action", newJString(Action))
  add(formData_603152, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_603151, "Version", newJString(Version))
  result = call_603150.call(nil, query_603151, nil, formData_603152, nil)

var postAuthorizeSnapshotAccess* = Call_PostAuthorizeSnapshotAccess_603134(
    name: "postAuthorizeSnapshotAccess", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=AuthorizeSnapshotAccess",
    validator: validate_PostAuthorizeSnapshotAccess_603135, base: "/",
    url: url_PostAuthorizeSnapshotAccess_603136,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetAuthorizeSnapshotAccess_603116 = ref object of OpenApiRestCall_602450
proc url_GetAuthorizeSnapshotAccess_603118(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetAuthorizeSnapshotAccess_603117(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Authorizes the specified AWS customer account to restore the specified snapshot.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   AccountWithRestoreAccess: JString (required)
  ##                           : <p>The identifier of the AWS customer account authorized to restore the specified snapshot.</p> <p>To share a snapshot with AWS support, specify amazon-redshift-support.</p>
  ##   Action: JString (required)
  ##   SnapshotClusterIdentifier: JString
  ##                            : The identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.
  ##   SnapshotIdentifier: JString (required)
  ##                     : The identifier of the snapshot the account is authorized to restore.
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `AccountWithRestoreAccess` field"
  var valid_603119 = query.getOrDefault("AccountWithRestoreAccess")
  valid_603119 = validateParameter(valid_603119, JString, required = true,
                                 default = nil)
  if valid_603119 != nil:
    section.add "AccountWithRestoreAccess", valid_603119
  var valid_603120 = query.getOrDefault("Action")
  valid_603120 = validateParameter(valid_603120, JString, required = true, default = newJString(
      "AuthorizeSnapshotAccess"))
  if valid_603120 != nil:
    section.add "Action", valid_603120
  var valid_603121 = query.getOrDefault("SnapshotClusterIdentifier")
  valid_603121 = validateParameter(valid_603121, JString, required = false,
                                 default = nil)
  if valid_603121 != nil:
    section.add "SnapshotClusterIdentifier", valid_603121
  var valid_603122 = query.getOrDefault("SnapshotIdentifier")
  valid_603122 = validateParameter(valid_603122, JString, required = true,
                                 default = nil)
  if valid_603122 != nil:
    section.add "SnapshotIdentifier", valid_603122
  var valid_603123 = query.getOrDefault("Version")
  valid_603123 = validateParameter(valid_603123, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_603123 != nil:
    section.add "Version", valid_603123
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603124 = header.getOrDefault("X-Amz-Date")
  valid_603124 = validateParameter(valid_603124, JString, required = false,
                                 default = nil)
  if valid_603124 != nil:
    section.add "X-Amz-Date", valid_603124
  var valid_603125 = header.getOrDefault("X-Amz-Security-Token")
  valid_603125 = validateParameter(valid_603125, JString, required = false,
                                 default = nil)
  if valid_603125 != nil:
    section.add "X-Amz-Security-Token", valid_603125
  var valid_603126 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603126 = validateParameter(valid_603126, JString, required = false,
                                 default = nil)
  if valid_603126 != nil:
    section.add "X-Amz-Content-Sha256", valid_603126
  var valid_603127 = header.getOrDefault("X-Amz-Algorithm")
  valid_603127 = validateParameter(valid_603127, JString, required = false,
                                 default = nil)
  if valid_603127 != nil:
    section.add "X-Amz-Algorithm", valid_603127
  var valid_603128 = header.getOrDefault("X-Amz-Signature")
  valid_603128 = validateParameter(valid_603128, JString, required = false,
                                 default = nil)
  if valid_603128 != nil:
    section.add "X-Amz-Signature", valid_603128
  var valid_603129 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603129 = validateParameter(valid_603129, JString, required = false,
                                 default = nil)
  if valid_603129 != nil:
    section.add "X-Amz-SignedHeaders", valid_603129
  var valid_603130 = header.getOrDefault("X-Amz-Credential")
  valid_603130 = validateParameter(valid_603130, JString, required = false,
                                 default = nil)
  if valid_603130 != nil:
    section.add "X-Amz-Credential", valid_603130
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603131: Call_GetAuthorizeSnapshotAccess_603116; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Authorizes the specified AWS customer account to restore the specified snapshot.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_603131.validator(path, query, header, formData, body)
  let scheme = call_603131.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603131.url(scheme.get, call_603131.host, call_603131.base,
                         call_603131.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_603131, url, valid)

proc call*(call_603132: Call_GetAuthorizeSnapshotAccess_603116;
          AccountWithRestoreAccess: string; SnapshotIdentifier: string;
          Action: string = "AuthorizeSnapshotAccess";
          SnapshotClusterIdentifier: string = ""; Version: string = "2012-12-01"): Recallable =
  ## getAuthorizeSnapshotAccess
  ## <p>Authorizes the specified AWS customer account to restore the specified snapshot.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   AccountWithRestoreAccess: string (required)
  ##                           : <p>The identifier of the AWS customer account authorized to restore the specified snapshot.</p> <p>To share a snapshot with AWS support, specify amazon-redshift-support.</p>
  ##   Action: string (required)
  ##   SnapshotClusterIdentifier: string
  ##                            : The identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.
  ##   SnapshotIdentifier: string (required)
  ##                     : The identifier of the snapshot the account is authorized to restore.
  ##   Version: string (required)
  var query_603133 = newJObject()
  add(query_603133, "AccountWithRestoreAccess",
      newJString(AccountWithRestoreAccess))
  add(query_603133, "Action", newJString(Action))
  add(query_603133, "SnapshotClusterIdentifier",
      newJString(SnapshotClusterIdentifier))
  add(query_603133, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_603133, "Version", newJString(Version))
  result = call_603132.call(nil, query_603133, nil, nil, nil)

var getAuthorizeSnapshotAccess* = Call_GetAuthorizeSnapshotAccess_603116(
    name: "getAuthorizeSnapshotAccess", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=AuthorizeSnapshotAccess",
    validator: validate_GetAuthorizeSnapshotAccess_603117, base: "/",
    url: url_GetAuthorizeSnapshotAccess_603118,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostBatchDeleteClusterSnapshots_603169 = ref object of OpenApiRestCall_602450
proc url_PostBatchDeleteClusterSnapshots_603171(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostBatchDeleteClusterSnapshots_603170(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a set of cluster snapshots.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_603172 = query.getOrDefault("Action")
  valid_603172 = validateParameter(valid_603172, JString, required = true, default = newJString(
      "BatchDeleteClusterSnapshots"))
  if valid_603172 != nil:
    section.add "Action", valid_603172
  var valid_603173 = query.getOrDefault("Version")
  valid_603173 = validateParameter(valid_603173, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_603173 != nil:
    section.add "Version", valid_603173
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603174 = header.getOrDefault("X-Amz-Date")
  valid_603174 = validateParameter(valid_603174, JString, required = false,
                                 default = nil)
  if valid_603174 != nil:
    section.add "X-Amz-Date", valid_603174
  var valid_603175 = header.getOrDefault("X-Amz-Security-Token")
  valid_603175 = validateParameter(valid_603175, JString, required = false,
                                 default = nil)
  if valid_603175 != nil:
    section.add "X-Amz-Security-Token", valid_603175
  var valid_603176 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603176 = validateParameter(valid_603176, JString, required = false,
                                 default = nil)
  if valid_603176 != nil:
    section.add "X-Amz-Content-Sha256", valid_603176
  var valid_603177 = header.getOrDefault("X-Amz-Algorithm")
  valid_603177 = validateParameter(valid_603177, JString, required = false,
                                 default = nil)
  if valid_603177 != nil:
    section.add "X-Amz-Algorithm", valid_603177
  var valid_603178 = header.getOrDefault("X-Amz-Signature")
  valid_603178 = validateParameter(valid_603178, JString, required = false,
                                 default = nil)
  if valid_603178 != nil:
    section.add "X-Amz-Signature", valid_603178
  var valid_603179 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603179 = validateParameter(valid_603179, JString, required = false,
                                 default = nil)
  if valid_603179 != nil:
    section.add "X-Amz-SignedHeaders", valid_603179
  var valid_603180 = header.getOrDefault("X-Amz-Credential")
  valid_603180 = validateParameter(valid_603180, JString, required = false,
                                 default = nil)
  if valid_603180 != nil:
    section.add "X-Amz-Credential", valid_603180
  result.add "header", section
  ## parameters in `formData` object:
  ##   Identifiers: JArray (required)
  ##              : A list of identifiers for the snapshots that you want to delete.
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `Identifiers` field"
  var valid_603181 = formData.getOrDefault("Identifiers")
  valid_603181 = validateParameter(valid_603181, JArray, required = true, default = nil)
  if valid_603181 != nil:
    section.add "Identifiers", valid_603181
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603182: Call_PostBatchDeleteClusterSnapshots_603169;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Deletes a set of cluster snapshots.
  ## 
  let valid = call_603182.validator(path, query, header, formData, body)
  let scheme = call_603182.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603182.url(scheme.get, call_603182.host, call_603182.base,
                         call_603182.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_603182, url, valid)

proc call*(call_603183: Call_PostBatchDeleteClusterSnapshots_603169;
          Identifiers: JsonNode; Action: string = "BatchDeleteClusterSnapshots";
          Version: string = "2012-12-01"): Recallable =
  ## postBatchDeleteClusterSnapshots
  ## Deletes a set of cluster snapshots.
  ##   Identifiers: JArray (required)
  ##              : A list of identifiers for the snapshots that you want to delete.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_603184 = newJObject()
  var formData_603185 = newJObject()
  if Identifiers != nil:
    formData_603185.add "Identifiers", Identifiers
  add(query_603184, "Action", newJString(Action))
  add(query_603184, "Version", newJString(Version))
  result = call_603183.call(nil, query_603184, nil, formData_603185, nil)

var postBatchDeleteClusterSnapshots* = Call_PostBatchDeleteClusterSnapshots_603169(
    name: "postBatchDeleteClusterSnapshots", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=BatchDeleteClusterSnapshots",
    validator: validate_PostBatchDeleteClusterSnapshots_603170, base: "/",
    url: url_PostBatchDeleteClusterSnapshots_603171,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetBatchDeleteClusterSnapshots_603153 = ref object of OpenApiRestCall_602450
proc url_GetBatchDeleteClusterSnapshots_603155(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetBatchDeleteClusterSnapshots_603154(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a set of cluster snapshots.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Identifiers: JArray (required)
  ##              : A list of identifiers for the snapshots that you want to delete.
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_603156 = query.getOrDefault("Action")
  valid_603156 = validateParameter(valid_603156, JString, required = true, default = newJString(
      "BatchDeleteClusterSnapshots"))
  if valid_603156 != nil:
    section.add "Action", valid_603156
  var valid_603157 = query.getOrDefault("Identifiers")
  valid_603157 = validateParameter(valid_603157, JArray, required = true, default = nil)
  if valid_603157 != nil:
    section.add "Identifiers", valid_603157
  var valid_603158 = query.getOrDefault("Version")
  valid_603158 = validateParameter(valid_603158, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_603158 != nil:
    section.add "Version", valid_603158
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603159 = header.getOrDefault("X-Amz-Date")
  valid_603159 = validateParameter(valid_603159, JString, required = false,
                                 default = nil)
  if valid_603159 != nil:
    section.add "X-Amz-Date", valid_603159
  var valid_603160 = header.getOrDefault("X-Amz-Security-Token")
  valid_603160 = validateParameter(valid_603160, JString, required = false,
                                 default = nil)
  if valid_603160 != nil:
    section.add "X-Amz-Security-Token", valid_603160
  var valid_603161 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603161 = validateParameter(valid_603161, JString, required = false,
                                 default = nil)
  if valid_603161 != nil:
    section.add "X-Amz-Content-Sha256", valid_603161
  var valid_603162 = header.getOrDefault("X-Amz-Algorithm")
  valid_603162 = validateParameter(valid_603162, JString, required = false,
                                 default = nil)
  if valid_603162 != nil:
    section.add "X-Amz-Algorithm", valid_603162
  var valid_603163 = header.getOrDefault("X-Amz-Signature")
  valid_603163 = validateParameter(valid_603163, JString, required = false,
                                 default = nil)
  if valid_603163 != nil:
    section.add "X-Amz-Signature", valid_603163
  var valid_603164 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603164 = validateParameter(valid_603164, JString, required = false,
                                 default = nil)
  if valid_603164 != nil:
    section.add "X-Amz-SignedHeaders", valid_603164
  var valid_603165 = header.getOrDefault("X-Amz-Credential")
  valid_603165 = validateParameter(valid_603165, JString, required = false,
                                 default = nil)
  if valid_603165 != nil:
    section.add "X-Amz-Credential", valid_603165
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603166: Call_GetBatchDeleteClusterSnapshots_603153; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a set of cluster snapshots.
  ## 
  let valid = call_603166.validator(path, query, header, formData, body)
  let scheme = call_603166.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603166.url(scheme.get, call_603166.host, call_603166.base,
                         call_603166.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_603166, url, valid)

proc call*(call_603167: Call_GetBatchDeleteClusterSnapshots_603153;
          Identifiers: JsonNode; Action: string = "BatchDeleteClusterSnapshots";
          Version: string = "2012-12-01"): Recallable =
  ## getBatchDeleteClusterSnapshots
  ## Deletes a set of cluster snapshots.
  ##   Action: string (required)
  ##   Identifiers: JArray (required)
  ##              : A list of identifiers for the snapshots that you want to delete.
  ##   Version: string (required)
  var query_603168 = newJObject()
  add(query_603168, "Action", newJString(Action))
  if Identifiers != nil:
    query_603168.add "Identifiers", Identifiers
  add(query_603168, "Version", newJString(Version))
  result = call_603167.call(nil, query_603168, nil, nil, nil)

var getBatchDeleteClusterSnapshots* = Call_GetBatchDeleteClusterSnapshots_603153(
    name: "getBatchDeleteClusterSnapshots", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=BatchDeleteClusterSnapshots",
    validator: validate_GetBatchDeleteClusterSnapshots_603154, base: "/",
    url: url_GetBatchDeleteClusterSnapshots_603155,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostBatchModifyClusterSnapshots_603204 = ref object of OpenApiRestCall_602450
proc url_PostBatchModifyClusterSnapshots_603206(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostBatchModifyClusterSnapshots_603205(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies the settings for a list of snapshots.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_603207 = query.getOrDefault("Action")
  valid_603207 = validateParameter(valid_603207, JString, required = true, default = newJString(
      "BatchModifyClusterSnapshots"))
  if valid_603207 != nil:
    section.add "Action", valid_603207
  var valid_603208 = query.getOrDefault("Version")
  valid_603208 = validateParameter(valid_603208, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_603208 != nil:
    section.add "Version", valid_603208
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603209 = header.getOrDefault("X-Amz-Date")
  valid_603209 = validateParameter(valid_603209, JString, required = false,
                                 default = nil)
  if valid_603209 != nil:
    section.add "X-Amz-Date", valid_603209
  var valid_603210 = header.getOrDefault("X-Amz-Security-Token")
  valid_603210 = validateParameter(valid_603210, JString, required = false,
                                 default = nil)
  if valid_603210 != nil:
    section.add "X-Amz-Security-Token", valid_603210
  var valid_603211 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603211 = validateParameter(valid_603211, JString, required = false,
                                 default = nil)
  if valid_603211 != nil:
    section.add "X-Amz-Content-Sha256", valid_603211
  var valid_603212 = header.getOrDefault("X-Amz-Algorithm")
  valid_603212 = validateParameter(valid_603212, JString, required = false,
                                 default = nil)
  if valid_603212 != nil:
    section.add "X-Amz-Algorithm", valid_603212
  var valid_603213 = header.getOrDefault("X-Amz-Signature")
  valid_603213 = validateParameter(valid_603213, JString, required = false,
                                 default = nil)
  if valid_603213 != nil:
    section.add "X-Amz-Signature", valid_603213
  var valid_603214 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603214 = validateParameter(valid_603214, JString, required = false,
                                 default = nil)
  if valid_603214 != nil:
    section.add "X-Amz-SignedHeaders", valid_603214
  var valid_603215 = header.getOrDefault("X-Amz-Credential")
  valid_603215 = validateParameter(valid_603215, JString, required = false,
                                 default = nil)
  if valid_603215 != nil:
    section.add "X-Amz-Credential", valid_603215
  result.add "header", section
  ## parameters in `formData` object:
  ##   Force: JBool
  ##        : A boolean value indicating whether to override an exception if the retention period has passed. 
  ##   SnapshotIdentifierList: JArray (required)
  ##                         : A list of snapshot identifiers you want to modify.
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The number of days that a manual snapshot is retained. If you specify the value -1, the manual snapshot is retained indefinitely.</p> <p>The number must be either -1 or an integer between 1 and 3,653.</p> <p>If you decrease the manual snapshot retention period from its current value, existing manual snapshots that fall outside of the new retention period will return an error. If you want to suppress the errors and delete the snapshots, use the force option. </p>
  section = newJObject()
  var valid_603216 = formData.getOrDefault("Force")
  valid_603216 = validateParameter(valid_603216, JBool, required = false, default = nil)
  if valid_603216 != nil:
    section.add "Force", valid_603216
  assert formData != nil, "formData argument is necessary due to required `SnapshotIdentifierList` field"
  var valid_603217 = formData.getOrDefault("SnapshotIdentifierList")
  valid_603217 = validateParameter(valid_603217, JArray, required = true, default = nil)
  if valid_603217 != nil:
    section.add "SnapshotIdentifierList", valid_603217
  var valid_603218 = formData.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_603218 = validateParameter(valid_603218, JInt, required = false, default = nil)
  if valid_603218 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_603218
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603219: Call_PostBatchModifyClusterSnapshots_603204;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Modifies the settings for a list of snapshots.
  ## 
  let valid = call_603219.validator(path, query, header, formData, body)
  let scheme = call_603219.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603219.url(scheme.get, call_603219.host, call_603219.base,
                         call_603219.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_603219, url, valid)

proc call*(call_603220: Call_PostBatchModifyClusterSnapshots_603204;
          SnapshotIdentifierList: JsonNode; Force: bool = false;
          Action: string = "BatchModifyClusterSnapshots";
          ManualSnapshotRetentionPeriod: int = 0; Version: string = "2012-12-01"): Recallable =
  ## postBatchModifyClusterSnapshots
  ## Modifies the settings for a list of snapshots.
  ##   Force: bool
  ##        : A boolean value indicating whether to override an exception if the retention period has passed. 
  ##   SnapshotIdentifierList: JArray (required)
  ##                         : A list of snapshot identifiers you want to modify.
  ##   Action: string (required)
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The number of days that a manual snapshot is retained. If you specify the value -1, the manual snapshot is retained indefinitely.</p> <p>The number must be either -1 or an integer between 1 and 3,653.</p> <p>If you decrease the manual snapshot retention period from its current value, existing manual snapshots that fall outside of the new retention period will return an error. If you want to suppress the errors and delete the snapshots, use the force option. </p>
  ##   Version: string (required)
  var query_603221 = newJObject()
  var formData_603222 = newJObject()
  add(formData_603222, "Force", newJBool(Force))
  if SnapshotIdentifierList != nil:
    formData_603222.add "SnapshotIdentifierList", SnapshotIdentifierList
  add(query_603221, "Action", newJString(Action))
  add(formData_603222, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  add(query_603221, "Version", newJString(Version))
  result = call_603220.call(nil, query_603221, nil, formData_603222, nil)

var postBatchModifyClusterSnapshots* = Call_PostBatchModifyClusterSnapshots_603204(
    name: "postBatchModifyClusterSnapshots", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=BatchModifyClusterSnapshots",
    validator: validate_PostBatchModifyClusterSnapshots_603205, base: "/",
    url: url_PostBatchModifyClusterSnapshots_603206,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetBatchModifyClusterSnapshots_603186 = ref object of OpenApiRestCall_602450
proc url_GetBatchModifyClusterSnapshots_603188(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetBatchModifyClusterSnapshots_603187(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies the settings for a list of snapshots.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   SnapshotIdentifierList: JArray (required)
  ##                         : A list of snapshot identifiers you want to modify.
  ##   Action: JString (required)
  ##   Version: JString (required)
  ##   Force: JBool
  ##        : A boolean value indicating whether to override an exception if the retention period has passed. 
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The number of days that a manual snapshot is retained. If you specify the value -1, the manual snapshot is retained indefinitely.</p> <p>The number must be either -1 or an integer between 1 and 3,653.</p> <p>If you decrease the manual snapshot retention period from its current value, existing manual snapshots that fall outside of the new retention period will return an error. If you want to suppress the errors and delete the snapshots, use the force option. </p>
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `SnapshotIdentifierList` field"
  var valid_603189 = query.getOrDefault("SnapshotIdentifierList")
  valid_603189 = validateParameter(valid_603189, JArray, required = true, default = nil)
  if valid_603189 != nil:
    section.add "SnapshotIdentifierList", valid_603189
  var valid_603190 = query.getOrDefault("Action")
  valid_603190 = validateParameter(valid_603190, JString, required = true, default = newJString(
      "BatchModifyClusterSnapshots"))
  if valid_603190 != nil:
    section.add "Action", valid_603190
  var valid_603191 = query.getOrDefault("Version")
  valid_603191 = validateParameter(valid_603191, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_603191 != nil:
    section.add "Version", valid_603191
  var valid_603192 = query.getOrDefault("Force")
  valid_603192 = validateParameter(valid_603192, JBool, required = false, default = nil)
  if valid_603192 != nil:
    section.add "Force", valid_603192
  var valid_603193 = query.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_603193 = validateParameter(valid_603193, JInt, required = false, default = nil)
  if valid_603193 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_603193
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603194 = header.getOrDefault("X-Amz-Date")
  valid_603194 = validateParameter(valid_603194, JString, required = false,
                                 default = nil)
  if valid_603194 != nil:
    section.add "X-Amz-Date", valid_603194
  var valid_603195 = header.getOrDefault("X-Amz-Security-Token")
  valid_603195 = validateParameter(valid_603195, JString, required = false,
                                 default = nil)
  if valid_603195 != nil:
    section.add "X-Amz-Security-Token", valid_603195
  var valid_603196 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603196 = validateParameter(valid_603196, JString, required = false,
                                 default = nil)
  if valid_603196 != nil:
    section.add "X-Amz-Content-Sha256", valid_603196
  var valid_603197 = header.getOrDefault("X-Amz-Algorithm")
  valid_603197 = validateParameter(valid_603197, JString, required = false,
                                 default = nil)
  if valid_603197 != nil:
    section.add "X-Amz-Algorithm", valid_603197
  var valid_603198 = header.getOrDefault("X-Amz-Signature")
  valid_603198 = validateParameter(valid_603198, JString, required = false,
                                 default = nil)
  if valid_603198 != nil:
    section.add "X-Amz-Signature", valid_603198
  var valid_603199 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603199 = validateParameter(valid_603199, JString, required = false,
                                 default = nil)
  if valid_603199 != nil:
    section.add "X-Amz-SignedHeaders", valid_603199
  var valid_603200 = header.getOrDefault("X-Amz-Credential")
  valid_603200 = validateParameter(valid_603200, JString, required = false,
                                 default = nil)
  if valid_603200 != nil:
    section.add "X-Amz-Credential", valid_603200
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603201: Call_GetBatchModifyClusterSnapshots_603186; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Modifies the settings for a list of snapshots.
  ## 
  let valid = call_603201.validator(path, query, header, formData, body)
  let scheme = call_603201.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603201.url(scheme.get, call_603201.host, call_603201.base,
                         call_603201.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_603201, url, valid)

proc call*(call_603202: Call_GetBatchModifyClusterSnapshots_603186;
          SnapshotIdentifierList: JsonNode;
          Action: string = "BatchModifyClusterSnapshots";
          Version: string = "2012-12-01"; Force: bool = false;
          ManualSnapshotRetentionPeriod: int = 0): Recallable =
  ## getBatchModifyClusterSnapshots
  ## Modifies the settings for a list of snapshots.
  ##   SnapshotIdentifierList: JArray (required)
  ##                         : A list of snapshot identifiers you want to modify.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   Force: bool
  ##        : A boolean value indicating whether to override an exception if the retention period has passed. 
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The number of days that a manual snapshot is retained. If you specify the value -1, the manual snapshot is retained indefinitely.</p> <p>The number must be either -1 or an integer between 1 and 3,653.</p> <p>If you decrease the manual snapshot retention period from its current value, existing manual snapshots that fall outside of the new retention period will return an error. If you want to suppress the errors and delete the snapshots, use the force option. </p>
  var query_603203 = newJObject()
  if SnapshotIdentifierList != nil:
    query_603203.add "SnapshotIdentifierList", SnapshotIdentifierList
  add(query_603203, "Action", newJString(Action))
  add(query_603203, "Version", newJString(Version))
  add(query_603203, "Force", newJBool(Force))
  add(query_603203, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  result = call_603202.call(nil, query_603203, nil, nil, nil)

var getBatchModifyClusterSnapshots* = Call_GetBatchModifyClusterSnapshots_603186(
    name: "getBatchModifyClusterSnapshots", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=BatchModifyClusterSnapshots",
    validator: validate_GetBatchModifyClusterSnapshots_603187, base: "/",
    url: url_GetBatchModifyClusterSnapshots_603188,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCancelResize_603239 = ref object of OpenApiRestCall_602450
proc url_PostCancelResize_603241(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostCancelResize_603240(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Cancels a resize operation.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_603242 = query.getOrDefault("Action")
  valid_603242 = validateParameter(valid_603242, JString, required = true,
                                 default = newJString("CancelResize"))
  if valid_603242 != nil:
    section.add "Action", valid_603242
  var valid_603243 = query.getOrDefault("Version")
  valid_603243 = validateParameter(valid_603243, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_603243 != nil:
    section.add "Version", valid_603243
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603244 = header.getOrDefault("X-Amz-Date")
  valid_603244 = validateParameter(valid_603244, JString, required = false,
                                 default = nil)
  if valid_603244 != nil:
    section.add "X-Amz-Date", valid_603244
  var valid_603245 = header.getOrDefault("X-Amz-Security-Token")
  valid_603245 = validateParameter(valid_603245, JString, required = false,
                                 default = nil)
  if valid_603245 != nil:
    section.add "X-Amz-Security-Token", valid_603245
  var valid_603246 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603246 = validateParameter(valid_603246, JString, required = false,
                                 default = nil)
  if valid_603246 != nil:
    section.add "X-Amz-Content-Sha256", valid_603246
  var valid_603247 = header.getOrDefault("X-Amz-Algorithm")
  valid_603247 = validateParameter(valid_603247, JString, required = false,
                                 default = nil)
  if valid_603247 != nil:
    section.add "X-Amz-Algorithm", valid_603247
  var valid_603248 = header.getOrDefault("X-Amz-Signature")
  valid_603248 = validateParameter(valid_603248, JString, required = false,
                                 default = nil)
  if valid_603248 != nil:
    section.add "X-Amz-Signature", valid_603248
  var valid_603249 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603249 = validateParameter(valid_603249, JString, required = false,
                                 default = nil)
  if valid_603249 != nil:
    section.add "X-Amz-SignedHeaders", valid_603249
  var valid_603250 = header.getOrDefault("X-Amz-Credential")
  valid_603250 = validateParameter(valid_603250, JString, required = false,
                                 default = nil)
  if valid_603250 != nil:
    section.add "X-Amz-Credential", valid_603250
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : The unique identifier for the cluster that you want to cancel a resize operation for.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_603251 = formData.getOrDefault("ClusterIdentifier")
  valid_603251 = validateParameter(valid_603251, JString, required = true,
                                 default = nil)
  if valid_603251 != nil:
    section.add "ClusterIdentifier", valid_603251
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603252: Call_PostCancelResize_603239; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Cancels a resize operation.
  ## 
  let valid = call_603252.validator(path, query, header, formData, body)
  let scheme = call_603252.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603252.url(scheme.get, call_603252.host, call_603252.base,
                         call_603252.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_603252, url, valid)

proc call*(call_603253: Call_PostCancelResize_603239; ClusterIdentifier: string;
          Action: string = "CancelResize"; Version: string = "2012-12-01"): Recallable =
  ## postCancelResize
  ## Cancels a resize operation.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : The unique identifier for the cluster that you want to cancel a resize operation for.
  ##   Version: string (required)
  var query_603254 = newJObject()
  var formData_603255 = newJObject()
  add(query_603254, "Action", newJString(Action))
  add(formData_603255, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_603254, "Version", newJString(Version))
  result = call_603253.call(nil, query_603254, nil, formData_603255, nil)

var postCancelResize* = Call_PostCancelResize_603239(name: "postCancelResize",
    meth: HttpMethod.HttpPost, host: "redshift.amazonaws.com",
    route: "/#Action=CancelResize", validator: validate_PostCancelResize_603240,
    base: "/", url: url_PostCancelResize_603241,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCancelResize_603223 = ref object of OpenApiRestCall_602450
proc url_GetCancelResize_603225(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetCancelResize_603224(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Cancels a resize operation.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : The unique identifier for the cluster that you want to cancel a resize operation for.
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_603226 = query.getOrDefault("Action")
  valid_603226 = validateParameter(valid_603226, JString, required = true,
                                 default = newJString("CancelResize"))
  if valid_603226 != nil:
    section.add "Action", valid_603226
  var valid_603227 = query.getOrDefault("ClusterIdentifier")
  valid_603227 = validateParameter(valid_603227, JString, required = true,
                                 default = nil)
  if valid_603227 != nil:
    section.add "ClusterIdentifier", valid_603227
  var valid_603228 = query.getOrDefault("Version")
  valid_603228 = validateParameter(valid_603228, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_603228 != nil:
    section.add "Version", valid_603228
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603229 = header.getOrDefault("X-Amz-Date")
  valid_603229 = validateParameter(valid_603229, JString, required = false,
                                 default = nil)
  if valid_603229 != nil:
    section.add "X-Amz-Date", valid_603229
  var valid_603230 = header.getOrDefault("X-Amz-Security-Token")
  valid_603230 = validateParameter(valid_603230, JString, required = false,
                                 default = nil)
  if valid_603230 != nil:
    section.add "X-Amz-Security-Token", valid_603230
  var valid_603231 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603231 = validateParameter(valid_603231, JString, required = false,
                                 default = nil)
  if valid_603231 != nil:
    section.add "X-Amz-Content-Sha256", valid_603231
  var valid_603232 = header.getOrDefault("X-Amz-Algorithm")
  valid_603232 = validateParameter(valid_603232, JString, required = false,
                                 default = nil)
  if valid_603232 != nil:
    section.add "X-Amz-Algorithm", valid_603232
  var valid_603233 = header.getOrDefault("X-Amz-Signature")
  valid_603233 = validateParameter(valid_603233, JString, required = false,
                                 default = nil)
  if valid_603233 != nil:
    section.add "X-Amz-Signature", valid_603233
  var valid_603234 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603234 = validateParameter(valid_603234, JString, required = false,
                                 default = nil)
  if valid_603234 != nil:
    section.add "X-Amz-SignedHeaders", valid_603234
  var valid_603235 = header.getOrDefault("X-Amz-Credential")
  valid_603235 = validateParameter(valid_603235, JString, required = false,
                                 default = nil)
  if valid_603235 != nil:
    section.add "X-Amz-Credential", valid_603235
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603236: Call_GetCancelResize_603223; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Cancels a resize operation.
  ## 
  let valid = call_603236.validator(path, query, header, formData, body)
  let scheme = call_603236.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603236.url(scheme.get, call_603236.host, call_603236.base,
                         call_603236.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_603236, url, valid)

proc call*(call_603237: Call_GetCancelResize_603223; ClusterIdentifier: string;
          Action: string = "CancelResize"; Version: string = "2012-12-01"): Recallable =
  ## getCancelResize
  ## Cancels a resize operation.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : The unique identifier for the cluster that you want to cancel a resize operation for.
  ##   Version: string (required)
  var query_603238 = newJObject()
  add(query_603238, "Action", newJString(Action))
  add(query_603238, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_603238, "Version", newJString(Version))
  result = call_603237.call(nil, query_603238, nil, nil, nil)

var getCancelResize* = Call_GetCancelResize_603223(name: "getCancelResize",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=CancelResize", validator: validate_GetCancelResize_603224,
    base: "/", url: url_GetCancelResize_603225, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCopyClusterSnapshot_603275 = ref object of OpenApiRestCall_602450
proc url_PostCopyClusterSnapshot_603277(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostCopyClusterSnapshot_603276(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Copies the specified automated cluster snapshot to a new manual cluster snapshot. The source must be an automated snapshot and it must be in the available state.</p> <p>When you delete a cluster, Amazon Redshift deletes any automated snapshots of the cluster. Also, when the retention period of the snapshot expires, Amazon Redshift automatically deletes it. If you want to keep an automated snapshot for a longer period, you can make a manual copy of the snapshot. Manual snapshots are retained until you delete them.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_603278 = query.getOrDefault("Action")
  valid_603278 = validateParameter(valid_603278, JString, required = true,
                                 default = newJString("CopyClusterSnapshot"))
  if valid_603278 != nil:
    section.add "Action", valid_603278
  var valid_603279 = query.getOrDefault("Version")
  valid_603279 = validateParameter(valid_603279, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_603279 != nil:
    section.add "Version", valid_603279
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603280 = header.getOrDefault("X-Amz-Date")
  valid_603280 = validateParameter(valid_603280, JString, required = false,
                                 default = nil)
  if valid_603280 != nil:
    section.add "X-Amz-Date", valid_603280
  var valid_603281 = header.getOrDefault("X-Amz-Security-Token")
  valid_603281 = validateParameter(valid_603281, JString, required = false,
                                 default = nil)
  if valid_603281 != nil:
    section.add "X-Amz-Security-Token", valid_603281
  var valid_603282 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603282 = validateParameter(valid_603282, JString, required = false,
                                 default = nil)
  if valid_603282 != nil:
    section.add "X-Amz-Content-Sha256", valid_603282
  var valid_603283 = header.getOrDefault("X-Amz-Algorithm")
  valid_603283 = validateParameter(valid_603283, JString, required = false,
                                 default = nil)
  if valid_603283 != nil:
    section.add "X-Amz-Algorithm", valid_603283
  var valid_603284 = header.getOrDefault("X-Amz-Signature")
  valid_603284 = validateParameter(valid_603284, JString, required = false,
                                 default = nil)
  if valid_603284 != nil:
    section.add "X-Amz-Signature", valid_603284
  var valid_603285 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603285 = validateParameter(valid_603285, JString, required = false,
                                 default = nil)
  if valid_603285 != nil:
    section.add "X-Amz-SignedHeaders", valid_603285
  var valid_603286 = header.getOrDefault("X-Amz-Credential")
  valid_603286 = validateParameter(valid_603286, JString, required = false,
                                 default = nil)
  if valid_603286 != nil:
    section.add "X-Amz-Credential", valid_603286
  result.add "header", section
  ## parameters in `formData` object:
  ##   SourceSnapshotIdentifier: JString (required)
  ##                           : <p>The identifier for the source snapshot.</p> <p>Constraints:</p> <ul> <li> <p>Must be the identifier for a valid automated snapshot whose state is <code>available</code>.</p> </li> </ul>
  ##   TargetSnapshotIdentifier: JString (required)
  ##                           : <p>The identifier given to the new manual snapshot.</p> <p>Constraints:</p> <ul> <li> <p>Cannot be null, empty, or blank.</p> </li> <li> <p>Must contain from 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for the AWS account that is making the request.</p> </li> </ul>
  ##   SourceSnapshotClusterIdentifier: JString
  ##                                  : <p>The identifier of the cluster the source snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.</p> <p>Constraints:</p> <ul> <li> <p>Must be the identifier for a valid cluster.</p> </li> </ul>
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. </p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `SourceSnapshotIdentifier` field"
  var valid_603287 = formData.getOrDefault("SourceSnapshotIdentifier")
  valid_603287 = validateParameter(valid_603287, JString, required = true,
                                 default = nil)
  if valid_603287 != nil:
    section.add "SourceSnapshotIdentifier", valid_603287
  var valid_603288 = formData.getOrDefault("TargetSnapshotIdentifier")
  valid_603288 = validateParameter(valid_603288, JString, required = true,
                                 default = nil)
  if valid_603288 != nil:
    section.add "TargetSnapshotIdentifier", valid_603288
  var valid_603289 = formData.getOrDefault("SourceSnapshotClusterIdentifier")
  valid_603289 = validateParameter(valid_603289, JString, required = false,
                                 default = nil)
  if valid_603289 != nil:
    section.add "SourceSnapshotClusterIdentifier", valid_603289
  var valid_603290 = formData.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_603290 = validateParameter(valid_603290, JInt, required = false, default = nil)
  if valid_603290 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_603290
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603291: Call_PostCopyClusterSnapshot_603275; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Copies the specified automated cluster snapshot to a new manual cluster snapshot. The source must be an automated snapshot and it must be in the available state.</p> <p>When you delete a cluster, Amazon Redshift deletes any automated snapshots of the cluster. Also, when the retention period of the snapshot expires, Amazon Redshift automatically deletes it. If you want to keep an automated snapshot for a longer period, you can make a manual copy of the snapshot. Manual snapshots are retained until you delete them.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_603291.validator(path, query, header, formData, body)
  let scheme = call_603291.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603291.url(scheme.get, call_603291.host, call_603291.base,
                         call_603291.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_603291, url, valid)

proc call*(call_603292: Call_PostCopyClusterSnapshot_603275;
          SourceSnapshotIdentifier: string; TargetSnapshotIdentifier: string;
          Action: string = "CopyClusterSnapshot";
          SourceSnapshotClusterIdentifier: string = "";
          ManualSnapshotRetentionPeriod: int = 0; Version: string = "2012-12-01"): Recallable =
  ## postCopyClusterSnapshot
  ## <p>Copies the specified automated cluster snapshot to a new manual cluster snapshot. The source must be an automated snapshot and it must be in the available state.</p> <p>When you delete a cluster, Amazon Redshift deletes any automated snapshots of the cluster. Also, when the retention period of the snapshot expires, Amazon Redshift automatically deletes it. If you want to keep an automated snapshot for a longer period, you can make a manual copy of the snapshot. Manual snapshots are retained until you delete them.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   SourceSnapshotIdentifier: string (required)
  ##                           : <p>The identifier for the source snapshot.</p> <p>Constraints:</p> <ul> <li> <p>Must be the identifier for a valid automated snapshot whose state is <code>available</code>.</p> </li> </ul>
  ##   TargetSnapshotIdentifier: string (required)
  ##                           : <p>The identifier given to the new manual snapshot.</p> <p>Constraints:</p> <ul> <li> <p>Cannot be null, empty, or blank.</p> </li> <li> <p>Must contain from 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for the AWS account that is making the request.</p> </li> </ul>
  ##   Action: string (required)
  ##   SourceSnapshotClusterIdentifier: string
  ##                                  : <p>The identifier of the cluster the source snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.</p> <p>Constraints:</p> <ul> <li> <p>Must be the identifier for a valid cluster.</p> </li> </ul>
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. </p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  ##   Version: string (required)
  var query_603293 = newJObject()
  var formData_603294 = newJObject()
  add(formData_603294, "SourceSnapshotIdentifier",
      newJString(SourceSnapshotIdentifier))
  add(formData_603294, "TargetSnapshotIdentifier",
      newJString(TargetSnapshotIdentifier))
  add(query_603293, "Action", newJString(Action))
  add(formData_603294, "SourceSnapshotClusterIdentifier",
      newJString(SourceSnapshotClusterIdentifier))
  add(formData_603294, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  add(query_603293, "Version", newJString(Version))
  result = call_603292.call(nil, query_603293, nil, formData_603294, nil)

var postCopyClusterSnapshot* = Call_PostCopyClusterSnapshot_603275(
    name: "postCopyClusterSnapshot", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=CopyClusterSnapshot",
    validator: validate_PostCopyClusterSnapshot_603276, base: "/",
    url: url_PostCopyClusterSnapshot_603277, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCopyClusterSnapshot_603256 = ref object of OpenApiRestCall_602450
proc url_GetCopyClusterSnapshot_603258(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetCopyClusterSnapshot_603257(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Copies the specified automated cluster snapshot to a new manual cluster snapshot. The source must be an automated snapshot and it must be in the available state.</p> <p>When you delete a cluster, Amazon Redshift deletes any automated snapshots of the cluster. Also, when the retention period of the snapshot expires, Amazon Redshift automatically deletes it. If you want to keep an automated snapshot for a longer period, you can make a manual copy of the snapshot. Manual snapshots are retained until you delete them.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   SourceSnapshotIdentifier: JString (required)
  ##                           : <p>The identifier for the source snapshot.</p> <p>Constraints:</p> <ul> <li> <p>Must be the identifier for a valid automated snapshot whose state is <code>available</code>.</p> </li> </ul>
  ##   Action: JString (required)
  ##   TargetSnapshotIdentifier: JString (required)
  ##                           : <p>The identifier given to the new manual snapshot.</p> <p>Constraints:</p> <ul> <li> <p>Cannot be null, empty, or blank.</p> </li> <li> <p>Must contain from 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for the AWS account that is making the request.</p> </li> </ul>
  ##   Version: JString (required)
  ##   SourceSnapshotClusterIdentifier: JString
  ##                                  : <p>The identifier of the cluster the source snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.</p> <p>Constraints:</p> <ul> <li> <p>Must be the identifier for a valid cluster.</p> </li> </ul>
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. </p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `SourceSnapshotIdentifier` field"
  var valid_603259 = query.getOrDefault("SourceSnapshotIdentifier")
  valid_603259 = validateParameter(valid_603259, JString, required = true,
                                 default = nil)
  if valid_603259 != nil:
    section.add "SourceSnapshotIdentifier", valid_603259
  var valid_603260 = query.getOrDefault("Action")
  valid_603260 = validateParameter(valid_603260, JString, required = true,
                                 default = newJString("CopyClusterSnapshot"))
  if valid_603260 != nil:
    section.add "Action", valid_603260
  var valid_603261 = query.getOrDefault("TargetSnapshotIdentifier")
  valid_603261 = validateParameter(valid_603261, JString, required = true,
                                 default = nil)
  if valid_603261 != nil:
    section.add "TargetSnapshotIdentifier", valid_603261
  var valid_603262 = query.getOrDefault("Version")
  valid_603262 = validateParameter(valid_603262, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_603262 != nil:
    section.add "Version", valid_603262
  var valid_603263 = query.getOrDefault("SourceSnapshotClusterIdentifier")
  valid_603263 = validateParameter(valid_603263, JString, required = false,
                                 default = nil)
  if valid_603263 != nil:
    section.add "SourceSnapshotClusterIdentifier", valid_603263
  var valid_603264 = query.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_603264 = validateParameter(valid_603264, JInt, required = false, default = nil)
  if valid_603264 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_603264
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603265 = header.getOrDefault("X-Amz-Date")
  valid_603265 = validateParameter(valid_603265, JString, required = false,
                                 default = nil)
  if valid_603265 != nil:
    section.add "X-Amz-Date", valid_603265
  var valid_603266 = header.getOrDefault("X-Amz-Security-Token")
  valid_603266 = validateParameter(valid_603266, JString, required = false,
                                 default = nil)
  if valid_603266 != nil:
    section.add "X-Amz-Security-Token", valid_603266
  var valid_603267 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603267 = validateParameter(valid_603267, JString, required = false,
                                 default = nil)
  if valid_603267 != nil:
    section.add "X-Amz-Content-Sha256", valid_603267
  var valid_603268 = header.getOrDefault("X-Amz-Algorithm")
  valid_603268 = validateParameter(valid_603268, JString, required = false,
                                 default = nil)
  if valid_603268 != nil:
    section.add "X-Amz-Algorithm", valid_603268
  var valid_603269 = header.getOrDefault("X-Amz-Signature")
  valid_603269 = validateParameter(valid_603269, JString, required = false,
                                 default = nil)
  if valid_603269 != nil:
    section.add "X-Amz-Signature", valid_603269
  var valid_603270 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603270 = validateParameter(valid_603270, JString, required = false,
                                 default = nil)
  if valid_603270 != nil:
    section.add "X-Amz-SignedHeaders", valid_603270
  var valid_603271 = header.getOrDefault("X-Amz-Credential")
  valid_603271 = validateParameter(valid_603271, JString, required = false,
                                 default = nil)
  if valid_603271 != nil:
    section.add "X-Amz-Credential", valid_603271
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603272: Call_GetCopyClusterSnapshot_603256; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Copies the specified automated cluster snapshot to a new manual cluster snapshot. The source must be an automated snapshot and it must be in the available state.</p> <p>When you delete a cluster, Amazon Redshift deletes any automated snapshots of the cluster. Also, when the retention period of the snapshot expires, Amazon Redshift automatically deletes it. If you want to keep an automated snapshot for a longer period, you can make a manual copy of the snapshot. Manual snapshots are retained until you delete them.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_603272.validator(path, query, header, formData, body)
  let scheme = call_603272.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603272.url(scheme.get, call_603272.host, call_603272.base,
                         call_603272.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_603272, url, valid)

proc call*(call_603273: Call_GetCopyClusterSnapshot_603256;
          SourceSnapshotIdentifier: string; TargetSnapshotIdentifier: string;
          Action: string = "CopyClusterSnapshot"; Version: string = "2012-12-01";
          SourceSnapshotClusterIdentifier: string = "";
          ManualSnapshotRetentionPeriod: int = 0): Recallable =
  ## getCopyClusterSnapshot
  ## <p>Copies the specified automated cluster snapshot to a new manual cluster snapshot. The source must be an automated snapshot and it must be in the available state.</p> <p>When you delete a cluster, Amazon Redshift deletes any automated snapshots of the cluster. Also, when the retention period of the snapshot expires, Amazon Redshift automatically deletes it. If you want to keep an automated snapshot for a longer period, you can make a manual copy of the snapshot. Manual snapshots are retained until you delete them.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   SourceSnapshotIdentifier: string (required)
  ##                           : <p>The identifier for the source snapshot.</p> <p>Constraints:</p> <ul> <li> <p>Must be the identifier for a valid automated snapshot whose state is <code>available</code>.</p> </li> </ul>
  ##   Action: string (required)
  ##   TargetSnapshotIdentifier: string (required)
  ##                           : <p>The identifier given to the new manual snapshot.</p> <p>Constraints:</p> <ul> <li> <p>Cannot be null, empty, or blank.</p> </li> <li> <p>Must contain from 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for the AWS account that is making the request.</p> </li> </ul>
  ##   Version: string (required)
  ##   SourceSnapshotClusterIdentifier: string
  ##                                  : <p>The identifier of the cluster the source snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.</p> <p>Constraints:</p> <ul> <li> <p>Must be the identifier for a valid cluster.</p> </li> </ul>
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. </p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  var query_603274 = newJObject()
  add(query_603274, "SourceSnapshotIdentifier",
      newJString(SourceSnapshotIdentifier))
  add(query_603274, "Action", newJString(Action))
  add(query_603274, "TargetSnapshotIdentifier",
      newJString(TargetSnapshotIdentifier))
  add(query_603274, "Version", newJString(Version))
  add(query_603274, "SourceSnapshotClusterIdentifier",
      newJString(SourceSnapshotClusterIdentifier))
  add(query_603274, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  result = call_603273.call(nil, query_603274, nil, nil, nil)

var getCopyClusterSnapshot* = Call_GetCopyClusterSnapshot_603256(
    name: "getCopyClusterSnapshot", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=CopyClusterSnapshot",
    validator: validate_GetCopyClusterSnapshot_603257, base: "/",
    url: url_GetCopyClusterSnapshot_603258, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCreateCluster_603340 = ref object of OpenApiRestCall_602450
proc url_PostCreateCluster_603342(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostCreateCluster_603341(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## <p>Creates a new cluster.</p> <p>To create a cluster in Virtual Private Cloud (VPC), you must provide a cluster subnet group name. The cluster subnet group identifies the subnets of your VPC that Amazon Redshift uses when creating the cluster. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_603343 = query.getOrDefault("Action")
  valid_603343 = validateParameter(valid_603343, JString, required = true,
                                 default = newJString("CreateCluster"))
  if valid_603343 != nil:
    section.add "Action", valid_603343
  var valid_603344 = query.getOrDefault("Version")
  valid_603344 = validateParameter(valid_603344, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_603344 != nil:
    section.add "Version", valid_603344
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603345 = header.getOrDefault("X-Amz-Date")
  valid_603345 = validateParameter(valid_603345, JString, required = false,
                                 default = nil)
  if valid_603345 != nil:
    section.add "X-Amz-Date", valid_603345
  var valid_603346 = header.getOrDefault("X-Amz-Security-Token")
  valid_603346 = validateParameter(valid_603346, JString, required = false,
                                 default = nil)
  if valid_603346 != nil:
    section.add "X-Amz-Security-Token", valid_603346
  var valid_603347 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603347 = validateParameter(valid_603347, JString, required = false,
                                 default = nil)
  if valid_603347 != nil:
    section.add "X-Amz-Content-Sha256", valid_603347
  var valid_603348 = header.getOrDefault("X-Amz-Algorithm")
  valid_603348 = validateParameter(valid_603348, JString, required = false,
                                 default = nil)
  if valid_603348 != nil:
    section.add "X-Amz-Algorithm", valid_603348
  var valid_603349 = header.getOrDefault("X-Amz-Signature")
  valid_603349 = validateParameter(valid_603349, JString, required = false,
                                 default = nil)
  if valid_603349 != nil:
    section.add "X-Amz-Signature", valid_603349
  var valid_603350 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603350 = validateParameter(valid_603350, JString, required = false,
                                 default = nil)
  if valid_603350 != nil:
    section.add "X-Amz-SignedHeaders", valid_603350
  var valid_603351 = header.getOrDefault("X-Amz-Credential")
  valid_603351 = validateParameter(valid_603351, JString, required = false,
                                 default = nil)
  if valid_603351 != nil:
    section.add "X-Amz-Credential", valid_603351
  result.add "header", section
  ## parameters in `formData` object:
  ##   PreferredMaintenanceWindow: JString
  ##                             : <p>The weekly time range (in UTC) during which automated cluster maintenance can occur.</p> <p> Format: <code>ddd:hh24:mi-ddd:hh24:mi</code> </p> <p> Default: A 30-minute window selected at random from an 8-hour block of time per region, occurring on a random day of the week. For more information about the time blocks for each region, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-maintenance-windows">Maintenance Windows</a> in Amazon Redshift Cluster Management Guide.</p> <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p> <p>Constraints: Minimum 30-minute window.</p>
  ##   EnhancedVpcRouting: JBool
  ##                     : <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p> <p>Default: false</p>
  ##   Port: JInt
  ##       : <p>The port number on which the cluster accepts incoming connections.</p> <p>The cluster is accessible only via the JDBC and ODBC connection strings. Part of the connection string requires the port on which the cluster will listen for incoming connections.</p> <p>Default: <code>5439</code> </p> <p>Valid Values: <code>1150-65535</code> </p>
  ##   VpcSecurityGroupIds: JArray
  ##                      : <p>A list of Virtual Private Cloud (VPC) security groups to be associated with the cluster.</p> <p>Default: The default VPC security group is associated with the cluster.</p>
  ##   DBName: JString
  ##         : <p>The name of the first database to be created when the cluster is created.</p> <p>To create additional databases after the cluster is created, connect to the cluster with a SQL client and use SQL commands to create a database. For more information, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/t_creating_database.html">Create a Database</a> in the Amazon Redshift Database Developer Guide. </p> <p>Default: <code>dev</code> </p> <p>Constraints:</p> <ul> <li> <p>Must contain 1 to 64 alphanumeric characters.</p> </li> <li> <p>Must contain only lowercase letters.</p> </li> <li> <p>Cannot be a word that is reserved by the service. A list of reserved words can be found in <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide. </p> </li> </ul>
  ##   ClusterVersion: JString
  ##                 : <p>The version of the Amazon Redshift engine software that you want to deploy on the cluster.</p> <p>The version selected runs on all the nodes in the cluster.</p> <p>Constraints: Only version 1.0 is currently available.</p> <p>Example: <code>1.0</code> </p>
  ##   ClusterType: JString
  ##              : <p>The type of the cluster. When cluster type is specified as</p> <ul> <li> <p> <code>single-node</code>, the <b>NumberOfNodes</b> parameter is not required.</p> </li> <li> <p> <code>multi-node</code>, the <b>NumberOfNodes</b> parameter is required.</p> </li> </ul> <p>Valid Values: <code>multi-node</code> | <code>single-node</code> </p> <p>Default: <code>multi-node</code> </p>
  ##   MasterUserPassword: JString (required)
  ##                     : <p>The password associated with the master user account for the cluster that is being created.</p> <p>Constraints:</p> <ul> <li> <p>Must be between 8 and 64 characters in length.</p> </li> <li> <p>Must contain at least one uppercase letter.</p> </li> <li> <p>Must contain at least one lowercase letter.</p> </li> <li> <p>Must contain one number.</p> </li> <li> <p>Can be any printable ASCII character (ASCII code 33 to 126) except ' (single quote), " (double quote), \, /, @, or space.</p> </li> </ul>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   AdditionalInfo: JString
  ##                 : Reserved.
  ##   ClusterSecurityGroups: JArray
  ##                        : <p>A list of security groups to be associated with this cluster.</p> <p>Default: The default cluster security group for Amazon Redshift.</p>
  ##   AvailabilityZone: JString
  ##                   : <p>The EC2 Availability Zone (AZ) in which you want Amazon Redshift to provision the cluster. For example, if you have several EC2 instances running in a specific Availability Zone, then you might want the cluster to be provisioned in the same zone in order to decrease network latency.</p> <p>Default: A random, system-chosen Availability Zone in the region that is specified by the endpoint.</p> <p>Example: <code>us-east-1d</code> </p> <p>Constraint: The specified Availability Zone must be in the same region as the current endpoint.</p>
  ##   Encrypted: JBool
  ##            : <p>If <code>true</code>, the data in the cluster is encrypted at rest. </p> <p>Default: false</p>
  ##   HsmConfigurationIdentifier: JString
  ##                             : Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
  ##   HsmClientCertificateIdentifier: JString
  ##                                 : Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM.
  ##   PubliclyAccessible: JBool
  ##                     : If <code>true</code>, the cluster can be accessed from a public network. 
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>A unique identifier for the cluster. You use this identifier to refer to the cluster for any subsequent cluster operations such as deleting or modifying. The identifier also appears in the Amazon Redshift console.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul> <p>Example: <code>myexamplecluster</code> </p>
  ##   MasterUsername: JString (required)
  ##                 : <p>The user name associated with the master user account for the cluster that is being created.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 - 128 alphanumeric characters. The user name can't be <code>PUBLIC</code>.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide. </p> </li> </ul>
  ##   NumberOfNodes: JInt
  ##                : <p>The number of compute nodes in the cluster. This parameter is required when the <b>ClusterType</b> parameter is specified as <code>multi-node</code>. </p> <p>For information about determining how many nodes you need, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#how-many-nodes"> Working with Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p> <p>If you don't specify this parameter, you get a single-node cluster. When requesting a multi-node cluster, you must specify the number of nodes that you want in the cluster.</p> <p>Default: <code>1</code> </p> <p>Constraints: Value must be at least 1 and no more than 100.</p>
  ##   IamRoles: JArray
  ##           : <p>A list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services. You must supply the IAM roles in their Amazon Resource Name (ARN) format. You can supply up to 10 IAM roles in a single request.</p> <p>A cluster can have up to 10 IAM roles associated with it at any time.</p>
  ##   ClusterParameterGroupName: JString
  ##                            : <p>The name of the parameter group to be associated with this cluster.</p> <p>Default: The default Amazon Redshift cluster parameter group. For information about the default parameter group, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Working with Amazon Redshift Parameter Groups</a> </p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   SnapshotScheduleIdentifier: JString
  ##                             : A unique identifier for the snapshot schedule.
  ##   KmsKeyId: JString
  ##           : The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster.
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The default number of days to retain a manual snapshot. If the value is -1, the snapshot is retained indefinitely. This setting doesn't change the retention period of existing snapshots.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  ##   ElasticIp: JString
  ##            : <p>The Elastic IP (EIP) address for the cluster.</p> <p>Constraints: The cluster must be provisioned in EC2-VPC and publicly-accessible through an Internet gateway. For more information about provisioning clusters in EC2-VPC, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#cluster-platforms">Supported Platforms to Launch Your Cluster</a> in the Amazon Redshift Cluster Management Guide.</p>
  ##   AllowVersionUpgrade: JBool
  ##                      : <p>If <code>true</code>, major version upgrades can be applied during the maintenance window to the Amazon Redshift engine that is running on the cluster.</p> <p>When a new major version of the Amazon Redshift engine is released, you can request that the service automatically apply upgrades during the maintenance window to the Amazon Redshift engine that is running on your cluster.</p> <p>Default: <code>true</code> </p>
  ##   AutomatedSnapshotRetentionPeriod: JInt
  ##                                   : <p>The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p> <p>Default: <code>1</code> </p> <p>Constraints: Must be a value from 0 to 35.</p>
  ##   NodeType: JString (required)
  ##           : <p>The node type to be provisioned for the cluster. For information about node types, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#how-many-nodes"> Working with Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p> <p>Valid Values: <code>ds2.xlarge</code> | <code>ds2.8xlarge</code> | <code>ds2.xlarge</code> | <code>ds2.8xlarge</code> | <code>dc1.large</code> | <code>dc1.8xlarge</code> | <code>dc2.large</code> | <code>dc2.8xlarge</code> </p>
  ##   MaintenanceTrackName: JString
  ##                       : An optional parameter for the name of the maintenance track for the cluster. If you don't provide a maintenance track name, the cluster is assigned to the <code>current</code> track.
  ##   ClusterSubnetGroupName: JString
  ##                         : <p>The name of a cluster subnet group to be associated with this cluster.</p> <p>If this parameter is not provided the resulting cluster will be deployed outside virtual private cloud (VPC).</p>
  section = newJObject()
  var valid_603352 = formData.getOrDefault("PreferredMaintenanceWindow")
  valid_603352 = validateParameter(valid_603352, JString, required = false,
                                 default = nil)
  if valid_603352 != nil:
    section.add "PreferredMaintenanceWindow", valid_603352
  var valid_603353 = formData.getOrDefault("EnhancedVpcRouting")
  valid_603353 = validateParameter(valid_603353, JBool, required = false, default = nil)
  if valid_603353 != nil:
    section.add "EnhancedVpcRouting", valid_603353
  var valid_603354 = formData.getOrDefault("Port")
  valid_603354 = validateParameter(valid_603354, JInt, required = false, default = nil)
  if valid_603354 != nil:
    section.add "Port", valid_603354
  var valid_603355 = formData.getOrDefault("VpcSecurityGroupIds")
  valid_603355 = validateParameter(valid_603355, JArray, required = false,
                                 default = nil)
  if valid_603355 != nil:
    section.add "VpcSecurityGroupIds", valid_603355
  var valid_603356 = formData.getOrDefault("DBName")
  valid_603356 = validateParameter(valid_603356, JString, required = false,
                                 default = nil)
  if valid_603356 != nil:
    section.add "DBName", valid_603356
  var valid_603357 = formData.getOrDefault("ClusterVersion")
  valid_603357 = validateParameter(valid_603357, JString, required = false,
                                 default = nil)
  if valid_603357 != nil:
    section.add "ClusterVersion", valid_603357
  var valid_603358 = formData.getOrDefault("ClusterType")
  valid_603358 = validateParameter(valid_603358, JString, required = false,
                                 default = nil)
  if valid_603358 != nil:
    section.add "ClusterType", valid_603358
  assert formData != nil, "formData argument is necessary due to required `MasterUserPassword` field"
  var valid_603359 = formData.getOrDefault("MasterUserPassword")
  valid_603359 = validateParameter(valid_603359, JString, required = true,
                                 default = nil)
  if valid_603359 != nil:
    section.add "MasterUserPassword", valid_603359
  var valid_603360 = formData.getOrDefault("Tags")
  valid_603360 = validateParameter(valid_603360, JArray, required = false,
                                 default = nil)
  if valid_603360 != nil:
    section.add "Tags", valid_603360
  var valid_603361 = formData.getOrDefault("AdditionalInfo")
  valid_603361 = validateParameter(valid_603361, JString, required = false,
                                 default = nil)
  if valid_603361 != nil:
    section.add "AdditionalInfo", valid_603361
  var valid_603362 = formData.getOrDefault("ClusterSecurityGroups")
  valid_603362 = validateParameter(valid_603362, JArray, required = false,
                                 default = nil)
  if valid_603362 != nil:
    section.add "ClusterSecurityGroups", valid_603362
  var valid_603363 = formData.getOrDefault("AvailabilityZone")
  valid_603363 = validateParameter(valid_603363, JString, required = false,
                                 default = nil)
  if valid_603363 != nil:
    section.add "AvailabilityZone", valid_603363
  var valid_603364 = formData.getOrDefault("Encrypted")
  valid_603364 = validateParameter(valid_603364, JBool, required = false, default = nil)
  if valid_603364 != nil:
    section.add "Encrypted", valid_603364
  var valid_603365 = formData.getOrDefault("HsmConfigurationIdentifier")
  valid_603365 = validateParameter(valid_603365, JString, required = false,
                                 default = nil)
  if valid_603365 != nil:
    section.add "HsmConfigurationIdentifier", valid_603365
  var valid_603366 = formData.getOrDefault("HsmClientCertificateIdentifier")
  valid_603366 = validateParameter(valid_603366, JString, required = false,
                                 default = nil)
  if valid_603366 != nil:
    section.add "HsmClientCertificateIdentifier", valid_603366
  var valid_603367 = formData.getOrDefault("PubliclyAccessible")
  valid_603367 = validateParameter(valid_603367, JBool, required = false, default = nil)
  if valid_603367 != nil:
    section.add "PubliclyAccessible", valid_603367
  var valid_603368 = formData.getOrDefault("ClusterIdentifier")
  valid_603368 = validateParameter(valid_603368, JString, required = true,
                                 default = nil)
  if valid_603368 != nil:
    section.add "ClusterIdentifier", valid_603368
  var valid_603369 = formData.getOrDefault("MasterUsername")
  valid_603369 = validateParameter(valid_603369, JString, required = true,
                                 default = nil)
  if valid_603369 != nil:
    section.add "MasterUsername", valid_603369
  var valid_603370 = formData.getOrDefault("NumberOfNodes")
  valid_603370 = validateParameter(valid_603370, JInt, required = false, default = nil)
  if valid_603370 != nil:
    section.add "NumberOfNodes", valid_603370
  var valid_603371 = formData.getOrDefault("IamRoles")
  valid_603371 = validateParameter(valid_603371, JArray, required = false,
                                 default = nil)
  if valid_603371 != nil:
    section.add "IamRoles", valid_603371
  var valid_603372 = formData.getOrDefault("ClusterParameterGroupName")
  valid_603372 = validateParameter(valid_603372, JString, required = false,
                                 default = nil)
  if valid_603372 != nil:
    section.add "ClusterParameterGroupName", valid_603372
  var valid_603373 = formData.getOrDefault("SnapshotScheduleIdentifier")
  valid_603373 = validateParameter(valid_603373, JString, required = false,
                                 default = nil)
  if valid_603373 != nil:
    section.add "SnapshotScheduleIdentifier", valid_603373
  var valid_603374 = formData.getOrDefault("KmsKeyId")
  valid_603374 = validateParameter(valid_603374, JString, required = false,
                                 default = nil)
  if valid_603374 != nil:
    section.add "KmsKeyId", valid_603374
  var valid_603375 = formData.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_603375 = validateParameter(valid_603375, JInt, required = false, default = nil)
  if valid_603375 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_603375
  var valid_603376 = formData.getOrDefault("ElasticIp")
  valid_603376 = validateParameter(valid_603376, JString, required = false,
                                 default = nil)
  if valid_603376 != nil:
    section.add "ElasticIp", valid_603376
  var valid_603377 = formData.getOrDefault("AllowVersionUpgrade")
  valid_603377 = validateParameter(valid_603377, JBool, required = false, default = nil)
  if valid_603377 != nil:
    section.add "AllowVersionUpgrade", valid_603377
  var valid_603378 = formData.getOrDefault("AutomatedSnapshotRetentionPeriod")
  valid_603378 = validateParameter(valid_603378, JInt, required = false, default = nil)
  if valid_603378 != nil:
    section.add "AutomatedSnapshotRetentionPeriod", valid_603378
  var valid_603379 = formData.getOrDefault("NodeType")
  valid_603379 = validateParameter(valid_603379, JString, required = true,
                                 default = nil)
  if valid_603379 != nil:
    section.add "NodeType", valid_603379
  var valid_603380 = formData.getOrDefault("MaintenanceTrackName")
  valid_603380 = validateParameter(valid_603380, JString, required = false,
                                 default = nil)
  if valid_603380 != nil:
    section.add "MaintenanceTrackName", valid_603380
  var valid_603381 = formData.getOrDefault("ClusterSubnetGroupName")
  valid_603381 = validateParameter(valid_603381, JString, required = false,
                                 default = nil)
  if valid_603381 != nil:
    section.add "ClusterSubnetGroupName", valid_603381
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603382: Call_PostCreateCluster_603340; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a new cluster.</p> <p>To create a cluster in Virtual Private Cloud (VPC), you must provide a cluster subnet group name. The cluster subnet group identifies the subnets of your VPC that Amazon Redshift uses when creating the cluster. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_603382.validator(path, query, header, formData, body)
  let scheme = call_603382.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603382.url(scheme.get, call_603382.host, call_603382.base,
                         call_603382.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_603382, url, valid)

proc call*(call_603383: Call_PostCreateCluster_603340; MasterUserPassword: string;
          ClusterIdentifier: string; MasterUsername: string; NodeType: string;
          PreferredMaintenanceWindow: string = ""; EnhancedVpcRouting: bool = false;
          Port: int = 0; VpcSecurityGroupIds: JsonNode = nil; DBName: string = "";
          ClusterVersion: string = ""; ClusterType: string = ""; Tags: JsonNode = nil;
          AdditionalInfo: string = ""; ClusterSecurityGroups: JsonNode = nil;
          AvailabilityZone: string = ""; Encrypted: bool = false;
          HsmConfigurationIdentifier: string = ""; Action: string = "CreateCluster";
          HsmClientCertificateIdentifier: string = "";
          PubliclyAccessible: bool = false; NumberOfNodes: int = 0;
          IamRoles: JsonNode = nil; ClusterParameterGroupName: string = "";
          SnapshotScheduleIdentifier: string = ""; KmsKeyId: string = "";
          ManualSnapshotRetentionPeriod: int = 0; ElasticIp: string = "";
          AllowVersionUpgrade: bool = false;
          AutomatedSnapshotRetentionPeriod: int = 0; Version: string = "2012-12-01";
          MaintenanceTrackName: string = ""; ClusterSubnetGroupName: string = ""): Recallable =
  ## postCreateCluster
  ## <p>Creates a new cluster.</p> <p>To create a cluster in Virtual Private Cloud (VPC), you must provide a cluster subnet group name. The cluster subnet group identifies the subnets of your VPC that Amazon Redshift uses when creating the cluster. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   PreferredMaintenanceWindow: string
  ##                             : <p>The weekly time range (in UTC) during which automated cluster maintenance can occur.</p> <p> Format: <code>ddd:hh24:mi-ddd:hh24:mi</code> </p> <p> Default: A 30-minute window selected at random from an 8-hour block of time per region, occurring on a random day of the week. For more information about the time blocks for each region, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-maintenance-windows">Maintenance Windows</a> in Amazon Redshift Cluster Management Guide.</p> <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p> <p>Constraints: Minimum 30-minute window.</p>
  ##   EnhancedVpcRouting: bool
  ##                     : <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p> <p>Default: false</p>
  ##   Port: int
  ##       : <p>The port number on which the cluster accepts incoming connections.</p> <p>The cluster is accessible only via the JDBC and ODBC connection strings. Part of the connection string requires the port on which the cluster will listen for incoming connections.</p> <p>Default: <code>5439</code> </p> <p>Valid Values: <code>1150-65535</code> </p>
  ##   VpcSecurityGroupIds: JArray
  ##                      : <p>A list of Virtual Private Cloud (VPC) security groups to be associated with the cluster.</p> <p>Default: The default VPC security group is associated with the cluster.</p>
  ##   DBName: string
  ##         : <p>The name of the first database to be created when the cluster is created.</p> <p>To create additional databases after the cluster is created, connect to the cluster with a SQL client and use SQL commands to create a database. For more information, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/t_creating_database.html">Create a Database</a> in the Amazon Redshift Database Developer Guide. </p> <p>Default: <code>dev</code> </p> <p>Constraints:</p> <ul> <li> <p>Must contain 1 to 64 alphanumeric characters.</p> </li> <li> <p>Must contain only lowercase letters.</p> </li> <li> <p>Cannot be a word that is reserved by the service. A list of reserved words can be found in <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide. </p> </li> </ul>
  ##   ClusterVersion: string
  ##                 : <p>The version of the Amazon Redshift engine software that you want to deploy on the cluster.</p> <p>The version selected runs on all the nodes in the cluster.</p> <p>Constraints: Only version 1.0 is currently available.</p> <p>Example: <code>1.0</code> </p>
  ##   ClusterType: string
  ##              : <p>The type of the cluster. When cluster type is specified as</p> <ul> <li> <p> <code>single-node</code>, the <b>NumberOfNodes</b> parameter is not required.</p> </li> <li> <p> <code>multi-node</code>, the <b>NumberOfNodes</b> parameter is required.</p> </li> </ul> <p>Valid Values: <code>multi-node</code> | <code>single-node</code> </p> <p>Default: <code>multi-node</code> </p>
  ##   MasterUserPassword: string (required)
  ##                     : <p>The password associated with the master user account for the cluster that is being created.</p> <p>Constraints:</p> <ul> <li> <p>Must be between 8 and 64 characters in length.</p> </li> <li> <p>Must contain at least one uppercase letter.</p> </li> <li> <p>Must contain at least one lowercase letter.</p> </li> <li> <p>Must contain one number.</p> </li> <li> <p>Can be any printable ASCII character (ASCII code 33 to 126) except ' (single quote), " (double quote), \, /, @, or space.</p> </li> </ul>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   AdditionalInfo: string
  ##                 : Reserved.
  ##   ClusterSecurityGroups: JArray
  ##                        : <p>A list of security groups to be associated with this cluster.</p> <p>Default: The default cluster security group for Amazon Redshift.</p>
  ##   AvailabilityZone: string
  ##                   : <p>The EC2 Availability Zone (AZ) in which you want Amazon Redshift to provision the cluster. For example, if you have several EC2 instances running in a specific Availability Zone, then you might want the cluster to be provisioned in the same zone in order to decrease network latency.</p> <p>Default: A random, system-chosen Availability Zone in the region that is specified by the endpoint.</p> <p>Example: <code>us-east-1d</code> </p> <p>Constraint: The specified Availability Zone must be in the same region as the current endpoint.</p>
  ##   Encrypted: bool
  ##            : <p>If <code>true</code>, the data in the cluster is encrypted at rest. </p> <p>Default: false</p>
  ##   HsmConfigurationIdentifier: string
  ##                             : Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
  ##   Action: string (required)
  ##   HsmClientCertificateIdentifier: string
  ##                                 : Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM.
  ##   PubliclyAccessible: bool
  ##                     : If <code>true</code>, the cluster can be accessed from a public network. 
  ##   ClusterIdentifier: string (required)
  ##                    : <p>A unique identifier for the cluster. You use this identifier to refer to the cluster for any subsequent cluster operations such as deleting or modifying. The identifier also appears in the Amazon Redshift console.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul> <p>Example: <code>myexamplecluster</code> </p>
  ##   MasterUsername: string (required)
  ##                 : <p>The user name associated with the master user account for the cluster that is being created.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 - 128 alphanumeric characters. The user name can't be <code>PUBLIC</code>.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide. </p> </li> </ul>
  ##   NumberOfNodes: int
  ##                : <p>The number of compute nodes in the cluster. This parameter is required when the <b>ClusterType</b> parameter is specified as <code>multi-node</code>. </p> <p>For information about determining how many nodes you need, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#how-many-nodes"> Working with Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p> <p>If you don't specify this parameter, you get a single-node cluster. When requesting a multi-node cluster, you must specify the number of nodes that you want in the cluster.</p> <p>Default: <code>1</code> </p> <p>Constraints: Value must be at least 1 and no more than 100.</p>
  ##   IamRoles: JArray
  ##           : <p>A list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services. You must supply the IAM roles in their Amazon Resource Name (ARN) format. You can supply up to 10 IAM roles in a single request.</p> <p>A cluster can have up to 10 IAM roles associated with it at any time.</p>
  ##   ClusterParameterGroupName: string
  ##                            : <p>The name of the parameter group to be associated with this cluster.</p> <p>Default: The default Amazon Redshift cluster parameter group. For information about the default parameter group, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Working with Amazon Redshift Parameter Groups</a> </p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   SnapshotScheduleIdentifier: string
  ##                             : A unique identifier for the snapshot schedule.
  ##   KmsKeyId: string
  ##           : The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster.
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The default number of days to retain a manual snapshot. If the value is -1, the snapshot is retained indefinitely. This setting doesn't change the retention period of existing snapshots.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  ##   ElasticIp: string
  ##            : <p>The Elastic IP (EIP) address for the cluster.</p> <p>Constraints: The cluster must be provisioned in EC2-VPC and publicly-accessible through an Internet gateway. For more information about provisioning clusters in EC2-VPC, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#cluster-platforms">Supported Platforms to Launch Your Cluster</a> in the Amazon Redshift Cluster Management Guide.</p>
  ##   AllowVersionUpgrade: bool
  ##                      : <p>If <code>true</code>, major version upgrades can be applied during the maintenance window to the Amazon Redshift engine that is running on the cluster.</p> <p>When a new major version of the Amazon Redshift engine is released, you can request that the service automatically apply upgrades during the maintenance window to the Amazon Redshift engine that is running on your cluster.</p> <p>Default: <code>true</code> </p>
  ##   AutomatedSnapshotRetentionPeriod: int
  ##                                   : <p>The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p> <p>Default: <code>1</code> </p> <p>Constraints: Must be a value from 0 to 35.</p>
  ##   Version: string (required)
  ##   NodeType: string (required)
  ##           : <p>The node type to be provisioned for the cluster. For information about node types, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#how-many-nodes"> Working with Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p> <p>Valid Values: <code>ds2.xlarge</code> | <code>ds2.8xlarge</code> | <code>ds2.xlarge</code> | <code>ds2.8xlarge</code> | <code>dc1.large</code> | <code>dc1.8xlarge</code> | <code>dc2.large</code> | <code>dc2.8xlarge</code> </p>
  ##   MaintenanceTrackName: string
  ##                       : An optional parameter for the name of the maintenance track for the cluster. If you don't provide a maintenance track name, the cluster is assigned to the <code>current</code> track.
  ##   ClusterSubnetGroupName: string
  ##                         : <p>The name of a cluster subnet group to be associated with this cluster.</p> <p>If this parameter is not provided the resulting cluster will be deployed outside virtual private cloud (VPC).</p>
  var query_603384 = newJObject()
  var formData_603385 = newJObject()
  add(formData_603385, "PreferredMaintenanceWindow",
      newJString(PreferredMaintenanceWindow))
  add(formData_603385, "EnhancedVpcRouting", newJBool(EnhancedVpcRouting))
  add(formData_603385, "Port", newJInt(Port))
  if VpcSecurityGroupIds != nil:
    formData_603385.add "VpcSecurityGroupIds", VpcSecurityGroupIds
  add(formData_603385, "DBName", newJString(DBName))
  add(formData_603385, "ClusterVersion", newJString(ClusterVersion))
  add(formData_603385, "ClusterType", newJString(ClusterType))
  add(formData_603385, "MasterUserPassword", newJString(MasterUserPassword))
  if Tags != nil:
    formData_603385.add "Tags", Tags
  add(formData_603385, "AdditionalInfo", newJString(AdditionalInfo))
  if ClusterSecurityGroups != nil:
    formData_603385.add "ClusterSecurityGroups", ClusterSecurityGroups
  add(formData_603385, "AvailabilityZone", newJString(AvailabilityZone))
  add(formData_603385, "Encrypted", newJBool(Encrypted))
  add(formData_603385, "HsmConfigurationIdentifier",
      newJString(HsmConfigurationIdentifier))
  add(query_603384, "Action", newJString(Action))
  add(formData_603385, "HsmClientCertificateIdentifier",
      newJString(HsmClientCertificateIdentifier))
  add(formData_603385, "PubliclyAccessible", newJBool(PubliclyAccessible))
  add(formData_603385, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_603385, "MasterUsername", newJString(MasterUsername))
  add(formData_603385, "NumberOfNodes", newJInt(NumberOfNodes))
  if IamRoles != nil:
    formData_603385.add "IamRoles", IamRoles
  add(formData_603385, "ClusterParameterGroupName",
      newJString(ClusterParameterGroupName))
  add(formData_603385, "SnapshotScheduleIdentifier",
      newJString(SnapshotScheduleIdentifier))
  add(formData_603385, "KmsKeyId", newJString(KmsKeyId))
  add(formData_603385, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  add(formData_603385, "ElasticIp", newJString(ElasticIp))
  add(formData_603385, "AllowVersionUpgrade", newJBool(AllowVersionUpgrade))
  add(formData_603385, "AutomatedSnapshotRetentionPeriod",
      newJInt(AutomatedSnapshotRetentionPeriod))
  add(query_603384, "Version", newJString(Version))
  add(formData_603385, "NodeType", newJString(NodeType))
  add(formData_603385, "MaintenanceTrackName", newJString(MaintenanceTrackName))
  add(formData_603385, "ClusterSubnetGroupName",
      newJString(ClusterSubnetGroupName))
  result = call_603383.call(nil, query_603384, nil, formData_603385, nil)

var postCreateCluster* = Call_PostCreateCluster_603340(name: "postCreateCluster",
    meth: HttpMethod.HttpPost, host: "redshift.amazonaws.com",
    route: "/#Action=CreateCluster", validator: validate_PostCreateCluster_603341,
    base: "/", url: url_PostCreateCluster_603342,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCreateCluster_603295 = ref object of OpenApiRestCall_602450
proc url_GetCreateCluster_603297(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetCreateCluster_603296(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## <p>Creates a new cluster.</p> <p>To create a cluster in Virtual Private Cloud (VPC), you must provide a cluster subnet group name. The cluster subnet group identifies the subnets of your VPC that Amazon Redshift uses when creating the cluster. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ClusterSecurityGroups: JArray
  ##                        : <p>A list of security groups to be associated with this cluster.</p> <p>Default: The default cluster security group for Amazon Redshift.</p>
  ##   MasterUsername: JString (required)
  ##                 : <p>The user name associated with the master user account for the cluster that is being created.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 - 128 alphanumeric characters. The user name can't be <code>PUBLIC</code>.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide. </p> </li> </ul>
  ##   ClusterSubnetGroupName: JString
  ##                         : <p>The name of a cluster subnet group to be associated with this cluster.</p> <p>If this parameter is not provided the resulting cluster will be deployed outside virtual private cloud (VPC).</p>
  ##   HsmClientCertificateIdentifier: JString
  ##                                 : Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM.
  ##   PreferredMaintenanceWindow: JString
  ##                             : <p>The weekly time range (in UTC) during which automated cluster maintenance can occur.</p> <p> Format: <code>ddd:hh24:mi-ddd:hh24:mi</code> </p> <p> Default: A 30-minute window selected at random from an 8-hour block of time per region, occurring on a random day of the week. For more information about the time blocks for each region, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-maintenance-windows">Maintenance Windows</a> in Amazon Redshift Cluster Management Guide.</p> <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p> <p>Constraints: Minimum 30-minute window.</p>
  ##   Encrypted: JBool
  ##            : <p>If <code>true</code>, the data in the cluster is encrypted at rest. </p> <p>Default: false</p>
  ##   MaintenanceTrackName: JString
  ##                       : An optional parameter for the name of the maintenance track for the cluster. If you don't provide a maintenance track name, the cluster is assigned to the <code>current</code> track.
  ##   IamRoles: JArray
  ##           : <p>A list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services. You must supply the IAM roles in their Amazon Resource Name (ARN) format. You can supply up to 10 IAM roles in a single request.</p> <p>A cluster can have up to 10 IAM roles associated with it at any time.</p>
  ##   AvailabilityZone: JString
  ##                   : <p>The EC2 Availability Zone (AZ) in which you want Amazon Redshift to provision the cluster. For example, if you have several EC2 instances running in a specific Availability Zone, then you might want the cluster to be provisioned in the same zone in order to decrease network latency.</p> <p>Default: A random, system-chosen Availability Zone in the region that is specified by the endpoint.</p> <p>Example: <code>us-east-1d</code> </p> <p>Constraint: The specified Availability Zone must be in the same region as the current endpoint.</p>
  ##   MasterUserPassword: JString (required)
  ##                     : <p>The password associated with the master user account for the cluster that is being created.</p> <p>Constraints:</p> <ul> <li> <p>Must be between 8 and 64 characters in length.</p> </li> <li> <p>Must contain at least one uppercase letter.</p> </li> <li> <p>Must contain at least one lowercase letter.</p> </li> <li> <p>Must contain one number.</p> </li> <li> <p>Can be any printable ASCII character (ASCII code 33 to 126) except ' (single quote), " (double quote), \, /, @, or space.</p> </li> </ul>
  ##   AllowVersionUpgrade: JBool
  ##                      : <p>If <code>true</code>, major version upgrades can be applied during the maintenance window to the Amazon Redshift engine that is running on the cluster.</p> <p>When a new major version of the Amazon Redshift engine is released, you can request that the service automatically apply upgrades during the maintenance window to the Amazon Redshift engine that is running on your cluster.</p> <p>Default: <code>true</code> </p>
  ##   EnhancedVpcRouting: JBool
  ##                     : <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p> <p>Default: false</p>
  ##   VpcSecurityGroupIds: JArray
  ##                      : <p>A list of Virtual Private Cloud (VPC) security groups to be associated with the cluster.</p> <p>Default: The default VPC security group is associated with the cluster.</p>
  ##   ClusterParameterGroupName: JString
  ##                            : <p>The name of the parameter group to be associated with this cluster.</p> <p>Default: The default Amazon Redshift cluster parameter group. For information about the default parameter group, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Working with Amazon Redshift Parameter Groups</a> </p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   HsmConfigurationIdentifier: JString
  ##                             : Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   DBName: JString
  ##         : <p>The name of the first database to be created when the cluster is created.</p> <p>To create additional databases after the cluster is created, connect to the cluster with a SQL client and use SQL commands to create a database. For more information, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/t_creating_database.html">Create a Database</a> in the Amazon Redshift Database Developer Guide. </p> <p>Default: <code>dev</code> </p> <p>Constraints:</p> <ul> <li> <p>Must contain 1 to 64 alphanumeric characters.</p> </li> <li> <p>Must contain only lowercase letters.</p> </li> <li> <p>Cannot be a word that is reserved by the service. A list of reserved words can be found in <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide. </p> </li> </ul>
  ##   SnapshotScheduleIdentifier: JString
  ##                             : A unique identifier for the snapshot schedule.
  ##   AdditionalInfo: JString
  ##                 : Reserved.
  ##   ElasticIp: JString
  ##            : <p>The Elastic IP (EIP) address for the cluster.</p> <p>Constraints: The cluster must be provisioned in EC2-VPC and publicly-accessible through an Internet gateway. For more information about provisioning clusters in EC2-VPC, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#cluster-platforms">Supported Platforms to Launch Your Cluster</a> in the Amazon Redshift Cluster Management Guide.</p>
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>A unique identifier for the cluster. You use this identifier to refer to the cluster for any subsequent cluster operations such as deleting or modifying. The identifier also appears in the Amazon Redshift console.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul> <p>Example: <code>myexamplecluster</code> </p>
  ##   Action: JString (required)
  ##   KmsKeyId: JString
  ##           : The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster.
  ##   PubliclyAccessible: JBool
  ##                     : If <code>true</code>, the cluster can be accessed from a public network. 
  ##   Port: JInt
  ##       : <p>The port number on which the cluster accepts incoming connections.</p> <p>The cluster is accessible only via the JDBC and ODBC connection strings. Part of the connection string requires the port on which the cluster will listen for incoming connections.</p> <p>Default: <code>5439</code> </p> <p>Valid Values: <code>1150-65535</code> </p>
  ##   NumberOfNodes: JInt
  ##                : <p>The number of compute nodes in the cluster. This parameter is required when the <b>ClusterType</b> parameter is specified as <code>multi-node</code>. </p> <p>For information about determining how many nodes you need, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#how-many-nodes"> Working with Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p> <p>If you don't specify this parameter, you get a single-node cluster. When requesting a multi-node cluster, you must specify the number of nodes that you want in the cluster.</p> <p>Default: <code>1</code> </p> <p>Constraints: Value must be at least 1 and no more than 100.</p>
  ##   AutomatedSnapshotRetentionPeriod: JInt
  ##                                   : <p>The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p> <p>Default: <code>1</code> </p> <p>Constraints: Must be a value from 0 to 35.</p>
  ##   NodeType: JString (required)
  ##           : <p>The node type to be provisioned for the cluster. For information about node types, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#how-many-nodes"> Working with Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p> <p>Valid Values: <code>ds2.xlarge</code> | <code>ds2.8xlarge</code> | <code>ds2.xlarge</code> | <code>ds2.8xlarge</code> | <code>dc1.large</code> | <code>dc1.8xlarge</code> | <code>dc2.large</code> | <code>dc2.8xlarge</code> </p>
  ##   ClusterVersion: JString
  ##                 : <p>The version of the Amazon Redshift engine software that you want to deploy on the cluster.</p> <p>The version selected runs on all the nodes in the cluster.</p> <p>Constraints: Only version 1.0 is currently available.</p> <p>Example: <code>1.0</code> </p>
  ##   Version: JString (required)
  ##   ClusterType: JString
  ##              : <p>The type of the cluster. When cluster type is specified as</p> <ul> <li> <p> <code>single-node</code>, the <b>NumberOfNodes</b> parameter is not required.</p> </li> <li> <p> <code>multi-node</code>, the <b>NumberOfNodes</b> parameter is required.</p> </li> </ul> <p>Valid Values: <code>multi-node</code> | <code>single-node</code> </p> <p>Default: <code>multi-node</code> </p>
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The default number of days to retain a manual snapshot. If the value is -1, the snapshot is retained indefinitely. This setting doesn't change the retention period of existing snapshots.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  section = newJObject()
  var valid_603298 = query.getOrDefault("ClusterSecurityGroups")
  valid_603298 = validateParameter(valid_603298, JArray, required = false,
                                 default = nil)
  if valid_603298 != nil:
    section.add "ClusterSecurityGroups", valid_603298
  assert query != nil,
        "query argument is necessary due to required `MasterUsername` field"
  var valid_603299 = query.getOrDefault("MasterUsername")
  valid_603299 = validateParameter(valid_603299, JString, required = true,
                                 default = nil)
  if valid_603299 != nil:
    section.add "MasterUsername", valid_603299
  var valid_603300 = query.getOrDefault("ClusterSubnetGroupName")
  valid_603300 = validateParameter(valid_603300, JString, required = false,
                                 default = nil)
  if valid_603300 != nil:
    section.add "ClusterSubnetGroupName", valid_603300
  var valid_603301 = query.getOrDefault("HsmClientCertificateIdentifier")
  valid_603301 = validateParameter(valid_603301, JString, required = false,
                                 default = nil)
  if valid_603301 != nil:
    section.add "HsmClientCertificateIdentifier", valid_603301
  var valid_603302 = query.getOrDefault("PreferredMaintenanceWindow")
  valid_603302 = validateParameter(valid_603302, JString, required = false,
                                 default = nil)
  if valid_603302 != nil:
    section.add "PreferredMaintenanceWindow", valid_603302
  var valid_603303 = query.getOrDefault("Encrypted")
  valid_603303 = validateParameter(valid_603303, JBool, required = false, default = nil)
  if valid_603303 != nil:
    section.add "Encrypted", valid_603303
  var valid_603304 = query.getOrDefault("MaintenanceTrackName")
  valid_603304 = validateParameter(valid_603304, JString, required = false,
                                 default = nil)
  if valid_603304 != nil:
    section.add "MaintenanceTrackName", valid_603304
  var valid_603305 = query.getOrDefault("IamRoles")
  valid_603305 = validateParameter(valid_603305, JArray, required = false,
                                 default = nil)
  if valid_603305 != nil:
    section.add "IamRoles", valid_603305
  var valid_603306 = query.getOrDefault("AvailabilityZone")
  valid_603306 = validateParameter(valid_603306, JString, required = false,
                                 default = nil)
  if valid_603306 != nil:
    section.add "AvailabilityZone", valid_603306
  var valid_603307 = query.getOrDefault("MasterUserPassword")
  valid_603307 = validateParameter(valid_603307, JString, required = true,
                                 default = nil)
  if valid_603307 != nil:
    section.add "MasterUserPassword", valid_603307
  var valid_603308 = query.getOrDefault("AllowVersionUpgrade")
  valid_603308 = validateParameter(valid_603308, JBool, required = false, default = nil)
  if valid_603308 != nil:
    section.add "AllowVersionUpgrade", valid_603308
  var valid_603309 = query.getOrDefault("EnhancedVpcRouting")
  valid_603309 = validateParameter(valid_603309, JBool, required = false, default = nil)
  if valid_603309 != nil:
    section.add "EnhancedVpcRouting", valid_603309
  var valid_603310 = query.getOrDefault("VpcSecurityGroupIds")
  valid_603310 = validateParameter(valid_603310, JArray, required = false,
                                 default = nil)
  if valid_603310 != nil:
    section.add "VpcSecurityGroupIds", valid_603310
  var valid_603311 = query.getOrDefault("ClusterParameterGroupName")
  valid_603311 = validateParameter(valid_603311, JString, required = false,
                                 default = nil)
  if valid_603311 != nil:
    section.add "ClusterParameterGroupName", valid_603311
  var valid_603312 = query.getOrDefault("HsmConfigurationIdentifier")
  valid_603312 = validateParameter(valid_603312, JString, required = false,
                                 default = nil)
  if valid_603312 != nil:
    section.add "HsmConfigurationIdentifier", valid_603312
  var valid_603313 = query.getOrDefault("Tags")
  valid_603313 = validateParameter(valid_603313, JArray, required = false,
                                 default = nil)
  if valid_603313 != nil:
    section.add "Tags", valid_603313
  var valid_603314 = query.getOrDefault("DBName")
  valid_603314 = validateParameter(valid_603314, JString, required = false,
                                 default = nil)
  if valid_603314 != nil:
    section.add "DBName", valid_603314
  var valid_603315 = query.getOrDefault("SnapshotScheduleIdentifier")
  valid_603315 = validateParameter(valid_603315, JString, required = false,
                                 default = nil)
  if valid_603315 != nil:
    section.add "SnapshotScheduleIdentifier", valid_603315
  var valid_603316 = query.getOrDefault("AdditionalInfo")
  valid_603316 = validateParameter(valid_603316, JString, required = false,
                                 default = nil)
  if valid_603316 != nil:
    section.add "AdditionalInfo", valid_603316
  var valid_603317 = query.getOrDefault("ElasticIp")
  valid_603317 = validateParameter(valid_603317, JString, required = false,
                                 default = nil)
  if valid_603317 != nil:
    section.add "ElasticIp", valid_603317
  var valid_603318 = query.getOrDefault("ClusterIdentifier")
  valid_603318 = validateParameter(valid_603318, JString, required = true,
                                 default = nil)
  if valid_603318 != nil:
    section.add "ClusterIdentifier", valid_603318
  var valid_603319 = query.getOrDefault("Action")
  valid_603319 = validateParameter(valid_603319, JString, required = true,
                                 default = newJString("CreateCluster"))
  if valid_603319 != nil:
    section.add "Action", valid_603319
  var valid_603320 = query.getOrDefault("KmsKeyId")
  valid_603320 = validateParameter(valid_603320, JString, required = false,
                                 default = nil)
  if valid_603320 != nil:
    section.add "KmsKeyId", valid_603320
  var valid_603321 = query.getOrDefault("PubliclyAccessible")
  valid_603321 = validateParameter(valid_603321, JBool, required = false, default = nil)
  if valid_603321 != nil:
    section.add "PubliclyAccessible", valid_603321
  var valid_603322 = query.getOrDefault("Port")
  valid_603322 = validateParameter(valid_603322, JInt, required = false, default = nil)
  if valid_603322 != nil:
    section.add "Port", valid_603322
  var valid_603323 = query.getOrDefault("NumberOfNodes")
  valid_603323 = validateParameter(valid_603323, JInt, required = false, default = nil)
  if valid_603323 != nil:
    section.add "NumberOfNodes", valid_603323
  var valid_603324 = query.getOrDefault("AutomatedSnapshotRetentionPeriod")
  valid_603324 = validateParameter(valid_603324, JInt, required = false, default = nil)
  if valid_603324 != nil:
    section.add "AutomatedSnapshotRetentionPeriod", valid_603324
  var valid_603325 = query.getOrDefault("NodeType")
  valid_603325 = validateParameter(valid_603325, JString, required = true,
                                 default = nil)
  if valid_603325 != nil:
    section.add "NodeType", valid_603325
  var valid_603326 = query.getOrDefault("ClusterVersion")
  valid_603326 = validateParameter(valid_603326, JString, required = false,
                                 default = nil)
  if valid_603326 != nil:
    section.add "ClusterVersion", valid_603326
  var valid_603327 = query.getOrDefault("Version")
  valid_603327 = validateParameter(valid_603327, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_603327 != nil:
    section.add "Version", valid_603327
  var valid_603328 = query.getOrDefault("ClusterType")
  valid_603328 = validateParameter(valid_603328, JString, required = false,
                                 default = nil)
  if valid_603328 != nil:
    section.add "ClusterType", valid_603328
  var valid_603329 = query.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_603329 = validateParameter(valid_603329, JInt, required = false, default = nil)
  if valid_603329 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_603329
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603330 = header.getOrDefault("X-Amz-Date")
  valid_603330 = validateParameter(valid_603330, JString, required = false,
                                 default = nil)
  if valid_603330 != nil:
    section.add "X-Amz-Date", valid_603330
  var valid_603331 = header.getOrDefault("X-Amz-Security-Token")
  valid_603331 = validateParameter(valid_603331, JString, required = false,
                                 default = nil)
  if valid_603331 != nil:
    section.add "X-Amz-Security-Token", valid_603331
  var valid_603332 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603332 = validateParameter(valid_603332, JString, required = false,
                                 default = nil)
  if valid_603332 != nil:
    section.add "X-Amz-Content-Sha256", valid_603332
  var valid_603333 = header.getOrDefault("X-Amz-Algorithm")
  valid_603333 = validateParameter(valid_603333, JString, required = false,
                                 default = nil)
  if valid_603333 != nil:
    section.add "X-Amz-Algorithm", valid_603333
  var valid_603334 = header.getOrDefault("X-Amz-Signature")
  valid_603334 = validateParameter(valid_603334, JString, required = false,
                                 default = nil)
  if valid_603334 != nil:
    section.add "X-Amz-Signature", valid_603334
  var valid_603335 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603335 = validateParameter(valid_603335, JString, required = false,
                                 default = nil)
  if valid_603335 != nil:
    section.add "X-Amz-SignedHeaders", valid_603335
  var valid_603336 = header.getOrDefault("X-Amz-Credential")
  valid_603336 = validateParameter(valid_603336, JString, required = false,
                                 default = nil)
  if valid_603336 != nil:
    section.add "X-Amz-Credential", valid_603336
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603337: Call_GetCreateCluster_603295; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a new cluster.</p> <p>To create a cluster in Virtual Private Cloud (VPC), you must provide a cluster subnet group name. The cluster subnet group identifies the subnets of your VPC that Amazon Redshift uses when creating the cluster. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_603337.validator(path, query, header, formData, body)
  let scheme = call_603337.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603337.url(scheme.get, call_603337.host, call_603337.base,
                         call_603337.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_603337, url, valid)

proc call*(call_603338: Call_GetCreateCluster_603295; MasterUsername: string;
          MasterUserPassword: string; ClusterIdentifier: string; NodeType: string;
          ClusterSecurityGroups: JsonNode = nil;
          ClusterSubnetGroupName: string = "";
          HsmClientCertificateIdentifier: string = "";
          PreferredMaintenanceWindow: string = ""; Encrypted: bool = false;
          MaintenanceTrackName: string = ""; IamRoles: JsonNode = nil;
          AvailabilityZone: string = ""; AllowVersionUpgrade: bool = false;
          EnhancedVpcRouting: bool = false; VpcSecurityGroupIds: JsonNode = nil;
          ClusterParameterGroupName: string = "";
          HsmConfigurationIdentifier: string = ""; Tags: JsonNode = nil;
          DBName: string = ""; SnapshotScheduleIdentifier: string = "";
          AdditionalInfo: string = ""; ElasticIp: string = "";
          Action: string = "CreateCluster"; KmsKeyId: string = "";
          PubliclyAccessible: bool = false; Port: int = 0; NumberOfNodes: int = 0;
          AutomatedSnapshotRetentionPeriod: int = 0; ClusterVersion: string = "";
          Version: string = "2012-12-01"; ClusterType: string = "";
          ManualSnapshotRetentionPeriod: int = 0): Recallable =
  ## getCreateCluster
  ## <p>Creates a new cluster.</p> <p>To create a cluster in Virtual Private Cloud (VPC), you must provide a cluster subnet group name. The cluster subnet group identifies the subnets of your VPC that Amazon Redshift uses when creating the cluster. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   ClusterSecurityGroups: JArray
  ##                        : <p>A list of security groups to be associated with this cluster.</p> <p>Default: The default cluster security group for Amazon Redshift.</p>
  ##   MasterUsername: string (required)
  ##                 : <p>The user name associated with the master user account for the cluster that is being created.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 - 128 alphanumeric characters. The user name can't be <code>PUBLIC</code>.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide. </p> </li> </ul>
  ##   ClusterSubnetGroupName: string
  ##                         : <p>The name of a cluster subnet group to be associated with this cluster.</p> <p>If this parameter is not provided the resulting cluster will be deployed outside virtual private cloud (VPC).</p>
  ##   HsmClientCertificateIdentifier: string
  ##                                 : Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM.
  ##   PreferredMaintenanceWindow: string
  ##                             : <p>The weekly time range (in UTC) during which automated cluster maintenance can occur.</p> <p> Format: <code>ddd:hh24:mi-ddd:hh24:mi</code> </p> <p> Default: A 30-minute window selected at random from an 8-hour block of time per region, occurring on a random day of the week. For more information about the time blocks for each region, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-maintenance-windows">Maintenance Windows</a> in Amazon Redshift Cluster Management Guide.</p> <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p> <p>Constraints: Minimum 30-minute window.</p>
  ##   Encrypted: bool
  ##            : <p>If <code>true</code>, the data in the cluster is encrypted at rest. </p> <p>Default: false</p>
  ##   MaintenanceTrackName: string
  ##                       : An optional parameter for the name of the maintenance track for the cluster. If you don't provide a maintenance track name, the cluster is assigned to the <code>current</code> track.
  ##   IamRoles: JArray
  ##           : <p>A list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services. You must supply the IAM roles in their Amazon Resource Name (ARN) format. You can supply up to 10 IAM roles in a single request.</p> <p>A cluster can have up to 10 IAM roles associated with it at any time.</p>
  ##   AvailabilityZone: string
  ##                   : <p>The EC2 Availability Zone (AZ) in which you want Amazon Redshift to provision the cluster. For example, if you have several EC2 instances running in a specific Availability Zone, then you might want the cluster to be provisioned in the same zone in order to decrease network latency.</p> <p>Default: A random, system-chosen Availability Zone in the region that is specified by the endpoint.</p> <p>Example: <code>us-east-1d</code> </p> <p>Constraint: The specified Availability Zone must be in the same region as the current endpoint.</p>
  ##   MasterUserPassword: string (required)
  ##                     : <p>The password associated with the master user account for the cluster that is being created.</p> <p>Constraints:</p> <ul> <li> <p>Must be between 8 and 64 characters in length.</p> </li> <li> <p>Must contain at least one uppercase letter.</p> </li> <li> <p>Must contain at least one lowercase letter.</p> </li> <li> <p>Must contain one number.</p> </li> <li> <p>Can be any printable ASCII character (ASCII code 33 to 126) except ' (single quote), " (double quote), \, /, @, or space.</p> </li> </ul>
  ##   AllowVersionUpgrade: bool
  ##                      : <p>If <code>true</code>, major version upgrades can be applied during the maintenance window to the Amazon Redshift engine that is running on the cluster.</p> <p>When a new major version of the Amazon Redshift engine is released, you can request that the service automatically apply upgrades during the maintenance window to the Amazon Redshift engine that is running on your cluster.</p> <p>Default: <code>true</code> </p>
  ##   EnhancedVpcRouting: bool
  ##                     : <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p> <p>Default: false</p>
  ##   VpcSecurityGroupIds: JArray
  ##                      : <p>A list of Virtual Private Cloud (VPC) security groups to be associated with the cluster.</p> <p>Default: The default VPC security group is associated with the cluster.</p>
  ##   ClusterParameterGroupName: string
  ##                            : <p>The name of the parameter group to be associated with this cluster.</p> <p>Default: The default Amazon Redshift cluster parameter group. For information about the default parameter group, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Working with Amazon Redshift Parameter Groups</a> </p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   HsmConfigurationIdentifier: string
  ##                             : Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   DBName: string
  ##         : <p>The name of the first database to be created when the cluster is created.</p> <p>To create additional databases after the cluster is created, connect to the cluster with a SQL client and use SQL commands to create a database. For more information, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/t_creating_database.html">Create a Database</a> in the Amazon Redshift Database Developer Guide. </p> <p>Default: <code>dev</code> </p> <p>Constraints:</p> <ul> <li> <p>Must contain 1 to 64 alphanumeric characters.</p> </li> <li> <p>Must contain only lowercase letters.</p> </li> <li> <p>Cannot be a word that is reserved by the service. A list of reserved words can be found in <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide. </p> </li> </ul>
  ##   SnapshotScheduleIdentifier: string
  ##                             : A unique identifier for the snapshot schedule.
  ##   AdditionalInfo: string
  ##                 : Reserved.
  ##   ElasticIp: string
  ##            : <p>The Elastic IP (EIP) address for the cluster.</p> <p>Constraints: The cluster must be provisioned in EC2-VPC and publicly-accessible through an Internet gateway. For more information about provisioning clusters in EC2-VPC, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#cluster-platforms">Supported Platforms to Launch Your Cluster</a> in the Amazon Redshift Cluster Management Guide.</p>
  ##   ClusterIdentifier: string (required)
  ##                    : <p>A unique identifier for the cluster. You use this identifier to refer to the cluster for any subsequent cluster operations such as deleting or modifying. The identifier also appears in the Amazon Redshift console.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul> <p>Example: <code>myexamplecluster</code> </p>
  ##   Action: string (required)
  ##   KmsKeyId: string
  ##           : The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster.
  ##   PubliclyAccessible: bool
  ##                     : If <code>true</code>, the cluster can be accessed from a public network. 
  ##   Port: int
  ##       : <p>The port number on which the cluster accepts incoming connections.</p> <p>The cluster is accessible only via the JDBC and ODBC connection strings. Part of the connection string requires the port on which the cluster will listen for incoming connections.</p> <p>Default: <code>5439</code> </p> <p>Valid Values: <code>1150-65535</code> </p>
  ##   NumberOfNodes: int
  ##                : <p>The number of compute nodes in the cluster. This parameter is required when the <b>ClusterType</b> parameter is specified as <code>multi-node</code>. </p> <p>For information about determining how many nodes you need, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#how-many-nodes"> Working with Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p> <p>If you don't specify this parameter, you get a single-node cluster. When requesting a multi-node cluster, you must specify the number of nodes that you want in the cluster.</p> <p>Default: <code>1</code> </p> <p>Constraints: Value must be at least 1 and no more than 100.</p>
  ##   AutomatedSnapshotRetentionPeriod: int
  ##                                   : <p>The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p> <p>Default: <code>1</code> </p> <p>Constraints: Must be a value from 0 to 35.</p>
  ##   NodeType: string (required)
  ##           : <p>The node type to be provisioned for the cluster. For information about node types, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#how-many-nodes"> Working with Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p> <p>Valid Values: <code>ds2.xlarge</code> | <code>ds2.8xlarge</code> | <code>ds2.xlarge</code> | <code>ds2.8xlarge</code> | <code>dc1.large</code> | <code>dc1.8xlarge</code> | <code>dc2.large</code> | <code>dc2.8xlarge</code> </p>
  ##   ClusterVersion: string
  ##                 : <p>The version of the Amazon Redshift engine software that you want to deploy on the cluster.</p> <p>The version selected runs on all the nodes in the cluster.</p> <p>Constraints: Only version 1.0 is currently available.</p> <p>Example: <code>1.0</code> </p>
  ##   Version: string (required)
  ##   ClusterType: string
  ##              : <p>The type of the cluster. When cluster type is specified as</p> <ul> <li> <p> <code>single-node</code>, the <b>NumberOfNodes</b> parameter is not required.</p> </li> <li> <p> <code>multi-node</code>, the <b>NumberOfNodes</b> parameter is required.</p> </li> </ul> <p>Valid Values: <code>multi-node</code> | <code>single-node</code> </p> <p>Default: <code>multi-node</code> </p>
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The default number of days to retain a manual snapshot. If the value is -1, the snapshot is retained indefinitely. This setting doesn't change the retention period of existing snapshots.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  var query_603339 = newJObject()
  if ClusterSecurityGroups != nil:
    query_603339.add "ClusterSecurityGroups", ClusterSecurityGroups
  add(query_603339, "MasterUsername", newJString(MasterUsername))
  add(query_603339, "ClusterSubnetGroupName", newJString(ClusterSubnetGroupName))
  add(query_603339, "HsmClientCertificateIdentifier",
      newJString(HsmClientCertificateIdentifier))
  add(query_603339, "PreferredMaintenanceWindow",
      newJString(PreferredMaintenanceWindow))
  add(query_603339, "Encrypted", newJBool(Encrypted))
  add(query_603339, "MaintenanceTrackName", newJString(MaintenanceTrackName))
  if IamRoles != nil:
    query_603339.add "IamRoles", IamRoles
  add(query_603339, "AvailabilityZone", newJString(AvailabilityZone))
  add(query_603339, "MasterUserPassword", newJString(MasterUserPassword))
  add(query_603339, "AllowVersionUpgrade", newJBool(AllowVersionUpgrade))
  add(query_603339, "EnhancedVpcRouting", newJBool(EnhancedVpcRouting))
  if VpcSecurityGroupIds != nil:
    query_603339.add "VpcSecurityGroupIds", VpcSecurityGroupIds
  add(query_603339, "ClusterParameterGroupName",
      newJString(ClusterParameterGroupName))
  add(query_603339, "HsmConfigurationIdentifier",
      newJString(HsmConfigurationIdentifier))
  if Tags != nil:
    query_603339.add "Tags", Tags
  add(query_603339, "DBName", newJString(DBName))
  add(query_603339, "SnapshotScheduleIdentifier",
      newJString(SnapshotScheduleIdentifier))
  add(query_603339, "AdditionalInfo", newJString(AdditionalInfo))
  add(query_603339, "ElasticIp", newJString(ElasticIp))
  add(query_603339, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_603339, "Action", newJString(Action))
  add(query_603339, "KmsKeyId", newJString(KmsKeyId))
  add(query_603339, "PubliclyAccessible", newJBool(PubliclyAccessible))
  add(query_603339, "Port", newJInt(Port))
  add(query_603339, "NumberOfNodes", newJInt(NumberOfNodes))
  add(query_603339, "AutomatedSnapshotRetentionPeriod",
      newJInt(AutomatedSnapshotRetentionPeriod))
  add(query_603339, "NodeType", newJString(NodeType))
  add(query_603339, "ClusterVersion", newJString(ClusterVersion))
  add(query_603339, "Version", newJString(Version))
  add(query_603339, "ClusterType", newJString(ClusterType))
  add(query_603339, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  result = call_603338.call(nil, query_603339, nil, nil, nil)

var getCreateCluster* = Call_GetCreateCluster_603295(name: "getCreateCluster",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=CreateCluster", validator: validate_GetCreateCluster_603296,
    base: "/", url: url_GetCreateCluster_603297,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCreateClusterParameterGroup_603405 = ref object of OpenApiRestCall_602450
proc url_PostCreateClusterParameterGroup_603407(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostCreateClusterParameterGroup_603406(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates an Amazon Redshift parameter group.</p> <p>Creating parameter groups is independent of creating clusters. You can associate a cluster with a parameter group when you create the cluster. You can also associate an existing cluster with a parameter group after the cluster is created by using <a>ModifyCluster</a>. </p> <p>Parameters in the parameter group define specific behavior that applies to the databases you create on the cluster. For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_603408 = query.getOrDefault("Action")
  valid_603408 = validateParameter(valid_603408, JString, required = true, default = newJString(
      "CreateClusterParameterGroup"))
  if valid_603408 != nil:
    section.add "Action", valid_603408
  var valid_603409 = query.getOrDefault("Version")
  valid_603409 = validateParameter(valid_603409, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_603409 != nil:
    section.add "Version", valid_603409
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603410 = header.getOrDefault("X-Amz-Date")
  valid_603410 = validateParameter(valid_603410, JString, required = false,
                                 default = nil)
  if valid_603410 != nil:
    section.add "X-Amz-Date", valid_603410
  var valid_603411 = header.getOrDefault("X-Amz-Security-Token")
  valid_603411 = validateParameter(valid_603411, JString, required = false,
                                 default = nil)
  if valid_603411 != nil:
    section.add "X-Amz-Security-Token", valid_603411
  var valid_603412 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603412 = validateParameter(valid_603412, JString, required = false,
                                 default = nil)
  if valid_603412 != nil:
    section.add "X-Amz-Content-Sha256", valid_603412
  var valid_603413 = header.getOrDefault("X-Amz-Algorithm")
  valid_603413 = validateParameter(valid_603413, JString, required = false,
                                 default = nil)
  if valid_603413 != nil:
    section.add "X-Amz-Algorithm", valid_603413
  var valid_603414 = header.getOrDefault("X-Amz-Signature")
  valid_603414 = validateParameter(valid_603414, JString, required = false,
                                 default = nil)
  if valid_603414 != nil:
    section.add "X-Amz-Signature", valid_603414
  var valid_603415 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603415 = validateParameter(valid_603415, JString, required = false,
                                 default = nil)
  if valid_603415 != nil:
    section.add "X-Amz-SignedHeaders", valid_603415
  var valid_603416 = header.getOrDefault("X-Amz-Credential")
  valid_603416 = validateParameter(valid_603416, JString, required = false,
                                 default = nil)
  if valid_603416 != nil:
    section.add "X-Amz-Credential", valid_603416
  result.add "header", section
  ## parameters in `formData` object:
  ##   ParameterGroupName: JString (required)
  ##                     : <p>The name of the cluster parameter group.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique withing your AWS account.</p> </li> </ul> <note> <p>This value is stored as a lower-case string.</p> </note>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   ParameterGroupFamily: JString (required)
  ##                       : <p>The Amazon Redshift engine version to which the cluster parameter group applies. The cluster engine version determines the set of parameters.</p> <p>To get a list of valid parameter group family names, you can call <a>DescribeClusterParameterGroups</a>. By default, Amazon Redshift returns a list of all the parameter groups that are owned by your AWS account, including the default parameter groups for each Amazon Redshift engine version. The parameter group family names associated with the default parameter groups provide you the valid values. For example, a valid family name is "redshift-1.0". </p>
  ##   Description: JString (required)
  ##              : A description of the parameter group.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ParameterGroupName` field"
  var valid_603417 = formData.getOrDefault("ParameterGroupName")
  valid_603417 = validateParameter(valid_603417, JString, required = true,
                                 default = nil)
  if valid_603417 != nil:
    section.add "ParameterGroupName", valid_603417
  var valid_603418 = formData.getOrDefault("Tags")
  valid_603418 = validateParameter(valid_603418, JArray, required = false,
                                 default = nil)
  if valid_603418 != nil:
    section.add "Tags", valid_603418
  var valid_603419 = formData.getOrDefault("ParameterGroupFamily")
  valid_603419 = validateParameter(valid_603419, JString, required = true,
                                 default = nil)
  if valid_603419 != nil:
    section.add "ParameterGroupFamily", valid_603419
  var valid_603420 = formData.getOrDefault("Description")
  valid_603420 = validateParameter(valid_603420, JString, required = true,
                                 default = nil)
  if valid_603420 != nil:
    section.add "Description", valid_603420
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603421: Call_PostCreateClusterParameterGroup_603405;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Creates an Amazon Redshift parameter group.</p> <p>Creating parameter groups is independent of creating clusters. You can associate a cluster with a parameter group when you create the cluster. You can also associate an existing cluster with a parameter group after the cluster is created by using <a>ModifyCluster</a>. </p> <p>Parameters in the parameter group define specific behavior that applies to the databases you create on the cluster. For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_603421.validator(path, query, header, formData, body)
  let scheme = call_603421.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603421.url(scheme.get, call_603421.host, call_603421.base,
                         call_603421.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_603421, url, valid)

proc call*(call_603422: Call_PostCreateClusterParameterGroup_603405;
          ParameterGroupName: string; ParameterGroupFamily: string;
          Description: string; Tags: JsonNode = nil;
          Action: string = "CreateClusterParameterGroup";
          Version: string = "2012-12-01"): Recallable =
  ## postCreateClusterParameterGroup
  ## <p>Creates an Amazon Redshift parameter group.</p> <p>Creating parameter groups is independent of creating clusters. You can associate a cluster with a parameter group when you create the cluster. You can also associate an existing cluster with a parameter group after the cluster is created by using <a>ModifyCluster</a>. </p> <p>Parameters in the parameter group define specific behavior that applies to the databases you create on the cluster. For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   ParameterGroupName: string (required)
  ##                     : <p>The name of the cluster parameter group.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique withing your AWS account.</p> </li> </ul> <note> <p>This value is stored as a lower-case string.</p> </note>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Action: string (required)
  ##   ParameterGroupFamily: string (required)
  ##                       : <p>The Amazon Redshift engine version to which the cluster parameter group applies. The cluster engine version determines the set of parameters.</p> <p>To get a list of valid parameter group family names, you can call <a>DescribeClusterParameterGroups</a>. By default, Amazon Redshift returns a list of all the parameter groups that are owned by your AWS account, including the default parameter groups for each Amazon Redshift engine version. The parameter group family names associated with the default parameter groups provide you the valid values. For example, a valid family name is "redshift-1.0". </p>
  ##   Version: string (required)
  ##   Description: string (required)
  ##              : A description of the parameter group.
  var query_603423 = newJObject()
  var formData_603424 = newJObject()
  add(formData_603424, "ParameterGroupName", newJString(ParameterGroupName))
  if Tags != nil:
    formData_603424.add "Tags", Tags
  add(query_603423, "Action", newJString(Action))
  add(formData_603424, "ParameterGroupFamily", newJString(ParameterGroupFamily))
  add(query_603423, "Version", newJString(Version))
  add(formData_603424, "Description", newJString(Description))
  result = call_603422.call(nil, query_603423, nil, formData_603424, nil)

var postCreateClusterParameterGroup* = Call_PostCreateClusterParameterGroup_603405(
    name: "postCreateClusterParameterGroup", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=CreateClusterParameterGroup",
    validator: validate_PostCreateClusterParameterGroup_603406, base: "/",
    url: url_PostCreateClusterParameterGroup_603407,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCreateClusterParameterGroup_603386 = ref object of OpenApiRestCall_602450
proc url_GetCreateClusterParameterGroup_603388(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetCreateClusterParameterGroup_603387(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates an Amazon Redshift parameter group.</p> <p>Creating parameter groups is independent of creating clusters. You can associate a cluster with a parameter group when you create the cluster. You can also associate an existing cluster with a parameter group after the cluster is created by using <a>ModifyCluster</a>. </p> <p>Parameters in the parameter group define specific behavior that applies to the databases you create on the cluster. For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Description: JString (required)
  ##              : A description of the parameter group.
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   ParameterGroupName: JString (required)
  ##                     : <p>The name of the cluster parameter group.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique withing your AWS account.</p> </li> </ul> <note> <p>This value is stored as a lower-case string.</p> </note>
  ##   Action: JString (required)
  ##   ParameterGroupFamily: JString (required)
  ##                       : <p>The Amazon Redshift engine version to which the cluster parameter group applies. The cluster engine version determines the set of parameters.</p> <p>To get a list of valid parameter group family names, you can call <a>DescribeClusterParameterGroups</a>. By default, Amazon Redshift returns a list of all the parameter groups that are owned by your AWS account, including the default parameter groups for each Amazon Redshift engine version. The parameter group family names associated with the default parameter groups provide you the valid values. For example, a valid family name is "redshift-1.0". </p>
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `Description` field"
  var valid_603389 = query.getOrDefault("Description")
  valid_603389 = validateParameter(valid_603389, JString, required = true,
                                 default = nil)
  if valid_603389 != nil:
    section.add "Description", valid_603389
  var valid_603390 = query.getOrDefault("Tags")
  valid_603390 = validateParameter(valid_603390, JArray, required = false,
                                 default = nil)
  if valid_603390 != nil:
    section.add "Tags", valid_603390
  var valid_603391 = query.getOrDefault("ParameterGroupName")
  valid_603391 = validateParameter(valid_603391, JString, required = true,
                                 default = nil)
  if valid_603391 != nil:
    section.add "ParameterGroupName", valid_603391
  var valid_603392 = query.getOrDefault("Action")
  valid_603392 = validateParameter(valid_603392, JString, required = true, default = newJString(
      "CreateClusterParameterGroup"))
  if valid_603392 != nil:
    section.add "Action", valid_603392
  var valid_603393 = query.getOrDefault("ParameterGroupFamily")
  valid_603393 = validateParameter(valid_603393, JString, required = true,
                                 default = nil)
  if valid_603393 != nil:
    section.add "ParameterGroupFamily", valid_603393
  var valid_603394 = query.getOrDefault("Version")
  valid_603394 = validateParameter(valid_603394, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_603394 != nil:
    section.add "Version", valid_603394
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603395 = header.getOrDefault("X-Amz-Date")
  valid_603395 = validateParameter(valid_603395, JString, required = false,
                                 default = nil)
  if valid_603395 != nil:
    section.add "X-Amz-Date", valid_603395
  var valid_603396 = header.getOrDefault("X-Amz-Security-Token")
  valid_603396 = validateParameter(valid_603396, JString, required = false,
                                 default = nil)
  if valid_603396 != nil:
    section.add "X-Amz-Security-Token", valid_603396
  var valid_603397 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603397 = validateParameter(valid_603397, JString, required = false,
                                 default = nil)
  if valid_603397 != nil:
    section.add "X-Amz-Content-Sha256", valid_603397
  var valid_603398 = header.getOrDefault("X-Amz-Algorithm")
  valid_603398 = validateParameter(valid_603398, JString, required = false,
                                 default = nil)
  if valid_603398 != nil:
    section.add "X-Amz-Algorithm", valid_603398
  var valid_603399 = header.getOrDefault("X-Amz-Signature")
  valid_603399 = validateParameter(valid_603399, JString, required = false,
                                 default = nil)
  if valid_603399 != nil:
    section.add "X-Amz-Signature", valid_603399
  var valid_603400 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603400 = validateParameter(valid_603400, JString, required = false,
                                 default = nil)
  if valid_603400 != nil:
    section.add "X-Amz-SignedHeaders", valid_603400
  var valid_603401 = header.getOrDefault("X-Amz-Credential")
  valid_603401 = validateParameter(valid_603401, JString, required = false,
                                 default = nil)
  if valid_603401 != nil:
    section.add "X-Amz-Credential", valid_603401
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603402: Call_GetCreateClusterParameterGroup_603386; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates an Amazon Redshift parameter group.</p> <p>Creating parameter groups is independent of creating clusters. You can associate a cluster with a parameter group when you create the cluster. You can also associate an existing cluster with a parameter group after the cluster is created by using <a>ModifyCluster</a>. </p> <p>Parameters in the parameter group define specific behavior that applies to the databases you create on the cluster. For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_603402.validator(path, query, header, formData, body)
  let scheme = call_603402.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603402.url(scheme.get, call_603402.host, call_603402.base,
                         call_603402.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_603402, url, valid)

proc call*(call_603403: Call_GetCreateClusterParameterGroup_603386;
          Description: string; ParameterGroupName: string;
          ParameterGroupFamily: string; Tags: JsonNode = nil;
          Action: string = "CreateClusterParameterGroup";
          Version: string = "2012-12-01"): Recallable =
  ## getCreateClusterParameterGroup
  ## <p>Creates an Amazon Redshift parameter group.</p> <p>Creating parameter groups is independent of creating clusters. You can associate a cluster with a parameter group when you create the cluster. You can also associate an existing cluster with a parameter group after the cluster is created by using <a>ModifyCluster</a>. </p> <p>Parameters in the parameter group define specific behavior that applies to the databases you create on the cluster. For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   Description: string (required)
  ##              : A description of the parameter group.
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   ParameterGroupName: string (required)
  ##                     : <p>The name of the cluster parameter group.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique withing your AWS account.</p> </li> </ul> <note> <p>This value is stored as a lower-case string.</p> </note>
  ##   Action: string (required)
  ##   ParameterGroupFamily: string (required)
  ##                       : <p>The Amazon Redshift engine version to which the cluster parameter group applies. The cluster engine version determines the set of parameters.</p> <p>To get a list of valid parameter group family names, you can call <a>DescribeClusterParameterGroups</a>. By default, Amazon Redshift returns a list of all the parameter groups that are owned by your AWS account, including the default parameter groups for each Amazon Redshift engine version. The parameter group family names associated with the default parameter groups provide you the valid values. For example, a valid family name is "redshift-1.0". </p>
  ##   Version: string (required)
  var query_603404 = newJObject()
  add(query_603404, "Description", newJString(Description))
  if Tags != nil:
    query_603404.add "Tags", Tags
  add(query_603404, "ParameterGroupName", newJString(ParameterGroupName))
  add(query_603404, "Action", newJString(Action))
  add(query_603404, "ParameterGroupFamily", newJString(ParameterGroupFamily))
  add(query_603404, "Version", newJString(Version))
  result = call_603403.call(nil, query_603404, nil, nil, nil)

var getCreateClusterParameterGroup* = Call_GetCreateClusterParameterGroup_603386(
    name: "getCreateClusterParameterGroup", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=CreateClusterParameterGroup",
    validator: validate_GetCreateClusterParameterGroup_603387, base: "/",
    url: url_GetCreateClusterParameterGroup_603388,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCreateClusterSecurityGroup_603443 = ref object of OpenApiRestCall_602450
proc url_PostCreateClusterSecurityGroup_603445(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostCreateClusterSecurityGroup_603444(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a new Amazon Redshift security group. You use security groups to control access to non-VPC clusters.</p> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_603446 = query.getOrDefault("Action")
  valid_603446 = validateParameter(valid_603446, JString, required = true, default = newJString(
      "CreateClusterSecurityGroup"))
  if valid_603446 != nil:
    section.add "Action", valid_603446
  var valid_603447 = query.getOrDefault("Version")
  valid_603447 = validateParameter(valid_603447, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_603447 != nil:
    section.add "Version", valid_603447
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603448 = header.getOrDefault("X-Amz-Date")
  valid_603448 = validateParameter(valid_603448, JString, required = false,
                                 default = nil)
  if valid_603448 != nil:
    section.add "X-Amz-Date", valid_603448
  var valid_603449 = header.getOrDefault("X-Amz-Security-Token")
  valid_603449 = validateParameter(valid_603449, JString, required = false,
                                 default = nil)
  if valid_603449 != nil:
    section.add "X-Amz-Security-Token", valid_603449
  var valid_603450 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603450 = validateParameter(valid_603450, JString, required = false,
                                 default = nil)
  if valid_603450 != nil:
    section.add "X-Amz-Content-Sha256", valid_603450
  var valid_603451 = header.getOrDefault("X-Amz-Algorithm")
  valid_603451 = validateParameter(valid_603451, JString, required = false,
                                 default = nil)
  if valid_603451 != nil:
    section.add "X-Amz-Algorithm", valid_603451
  var valid_603452 = header.getOrDefault("X-Amz-Signature")
  valid_603452 = validateParameter(valid_603452, JString, required = false,
                                 default = nil)
  if valid_603452 != nil:
    section.add "X-Amz-Signature", valid_603452
  var valid_603453 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603453 = validateParameter(valid_603453, JString, required = false,
                                 default = nil)
  if valid_603453 != nil:
    section.add "X-Amz-SignedHeaders", valid_603453
  var valid_603454 = header.getOrDefault("X-Amz-Credential")
  valid_603454 = validateParameter(valid_603454, JString, required = false,
                                 default = nil)
  if valid_603454 != nil:
    section.add "X-Amz-Credential", valid_603454
  result.add "header", section
  ## parameters in `formData` object:
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Description: JString (required)
  ##              : A description for the security group.
  ##   ClusterSecurityGroupName: JString (required)
  ##                           : <p>The name for the security group. Amazon Redshift stores the value as a lowercase string.</p> <p>Constraints:</p> <ul> <li> <p>Must contain no more than 255 alphanumeric characters or hyphens.</p> </li> <li> <p>Must not be "Default".</p> </li> <li> <p>Must be unique for all security groups that are created by your AWS account.</p> </li> </ul> <p>Example: <code>examplesecuritygroup</code> </p>
  section = newJObject()
  var valid_603455 = formData.getOrDefault("Tags")
  valid_603455 = validateParameter(valid_603455, JArray, required = false,
                                 default = nil)
  if valid_603455 != nil:
    section.add "Tags", valid_603455
  assert formData != nil,
        "formData argument is necessary due to required `Description` field"
  var valid_603456 = formData.getOrDefault("Description")
  valid_603456 = validateParameter(valid_603456, JString, required = true,
                                 default = nil)
  if valid_603456 != nil:
    section.add "Description", valid_603456
  var valid_603457 = formData.getOrDefault("ClusterSecurityGroupName")
  valid_603457 = validateParameter(valid_603457, JString, required = true,
                                 default = nil)
  if valid_603457 != nil:
    section.add "ClusterSecurityGroupName", valid_603457
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603458: Call_PostCreateClusterSecurityGroup_603443; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a new Amazon Redshift security group. You use security groups to control access to non-VPC clusters.</p> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_603458.validator(path, query, header, formData, body)
  let scheme = call_603458.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603458.url(scheme.get, call_603458.host, call_603458.base,
                         call_603458.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_603458, url, valid)

proc call*(call_603459: Call_PostCreateClusterSecurityGroup_603443;
          Description: string; ClusterSecurityGroupName: string;
          Tags: JsonNode = nil; Action: string = "CreateClusterSecurityGroup";
          Version: string = "2012-12-01"): Recallable =
  ## postCreateClusterSecurityGroup
  ## <p>Creates a new Amazon Redshift security group. You use security groups to control access to non-VPC clusters.</p> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   Description: string (required)
  ##              : A description for the security group.
  ##   ClusterSecurityGroupName: string (required)
  ##                           : <p>The name for the security group. Amazon Redshift stores the value as a lowercase string.</p> <p>Constraints:</p> <ul> <li> <p>Must contain no more than 255 alphanumeric characters or hyphens.</p> </li> <li> <p>Must not be "Default".</p> </li> <li> <p>Must be unique for all security groups that are created by your AWS account.</p> </li> </ul> <p>Example: <code>examplesecuritygroup</code> </p>
  var query_603460 = newJObject()
  var formData_603461 = newJObject()
  if Tags != nil:
    formData_603461.add "Tags", Tags
  add(query_603460, "Action", newJString(Action))
  add(query_603460, "Version", newJString(Version))
  add(formData_603461, "Description", newJString(Description))
  add(formData_603461, "ClusterSecurityGroupName",
      newJString(ClusterSecurityGroupName))
  result = call_603459.call(nil, query_603460, nil, formData_603461, nil)

var postCreateClusterSecurityGroup* = Call_PostCreateClusterSecurityGroup_603443(
    name: "postCreateClusterSecurityGroup", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=CreateClusterSecurityGroup",
    validator: validate_PostCreateClusterSecurityGroup_603444, base: "/",
    url: url_PostCreateClusterSecurityGroup_603445,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCreateClusterSecurityGroup_603425 = ref object of OpenApiRestCall_602450
proc url_GetCreateClusterSecurityGroup_603427(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetCreateClusterSecurityGroup_603426(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a new Amazon Redshift security group. You use security groups to control access to non-VPC clusters.</p> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ClusterSecurityGroupName: JString (required)
  ##                           : <p>The name for the security group. Amazon Redshift stores the value as a lowercase string.</p> <p>Constraints:</p> <ul> <li> <p>Must contain no more than 255 alphanumeric characters or hyphens.</p> </li> <li> <p>Must not be "Default".</p> </li> <li> <p>Must be unique for all security groups that are created by your AWS account.</p> </li> </ul> <p>Example: <code>examplesecuritygroup</code> </p>
  ##   Description: JString (required)
  ##              : A description for the security group.
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `ClusterSecurityGroupName` field"
  var valid_603428 = query.getOrDefault("ClusterSecurityGroupName")
  valid_603428 = validateParameter(valid_603428, JString, required = true,
                                 default = nil)
  if valid_603428 != nil:
    section.add "ClusterSecurityGroupName", valid_603428
  var valid_603429 = query.getOrDefault("Description")
  valid_603429 = validateParameter(valid_603429, JString, required = true,
                                 default = nil)
  if valid_603429 != nil:
    section.add "Description", valid_603429
  var valid_603430 = query.getOrDefault("Tags")
  valid_603430 = validateParameter(valid_603430, JArray, required = false,
                                 default = nil)
  if valid_603430 != nil:
    section.add "Tags", valid_603430
  var valid_603431 = query.getOrDefault("Action")
  valid_603431 = validateParameter(valid_603431, JString, required = true, default = newJString(
      "CreateClusterSecurityGroup"))
  if valid_603431 != nil:
    section.add "Action", valid_603431
  var valid_603432 = query.getOrDefault("Version")
  valid_603432 = validateParameter(valid_603432, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_603432 != nil:
    section.add "Version", valid_603432
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603433 = header.getOrDefault("X-Amz-Date")
  valid_603433 = validateParameter(valid_603433, JString, required = false,
                                 default = nil)
  if valid_603433 != nil:
    section.add "X-Amz-Date", valid_603433
  var valid_603434 = header.getOrDefault("X-Amz-Security-Token")
  valid_603434 = validateParameter(valid_603434, JString, required = false,
                                 default = nil)
  if valid_603434 != nil:
    section.add "X-Amz-Security-Token", valid_603434
  var valid_603435 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603435 = validateParameter(valid_603435, JString, required = false,
                                 default = nil)
  if valid_603435 != nil:
    section.add "X-Amz-Content-Sha256", valid_603435
  var valid_603436 = header.getOrDefault("X-Amz-Algorithm")
  valid_603436 = validateParameter(valid_603436, JString, required = false,
                                 default = nil)
  if valid_603436 != nil:
    section.add "X-Amz-Algorithm", valid_603436
  var valid_603437 = header.getOrDefault("X-Amz-Signature")
  valid_603437 = validateParameter(valid_603437, JString, required = false,
                                 default = nil)
  if valid_603437 != nil:
    section.add "X-Amz-Signature", valid_603437
  var valid_603438 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603438 = validateParameter(valid_603438, JString, required = false,
                                 default = nil)
  if valid_603438 != nil:
    section.add "X-Amz-SignedHeaders", valid_603438
  var valid_603439 = header.getOrDefault("X-Amz-Credential")
  valid_603439 = validateParameter(valid_603439, JString, required = false,
                                 default = nil)
  if valid_603439 != nil:
    section.add "X-Amz-Credential", valid_603439
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603440: Call_GetCreateClusterSecurityGroup_603425; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a new Amazon Redshift security group. You use security groups to control access to non-VPC clusters.</p> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_603440.validator(path, query, header, formData, body)
  let scheme = call_603440.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603440.url(scheme.get, call_603440.host, call_603440.base,
                         call_603440.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_603440, url, valid)

proc call*(call_603441: Call_GetCreateClusterSecurityGroup_603425;
          ClusterSecurityGroupName: string; Description: string;
          Tags: JsonNode = nil; Action: string = "CreateClusterSecurityGroup";
          Version: string = "2012-12-01"): Recallable =
  ## getCreateClusterSecurityGroup
  ## <p>Creates a new Amazon Redshift security group. You use security groups to control access to non-VPC clusters.</p> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   ClusterSecurityGroupName: string (required)
  ##                           : <p>The name for the security group. Amazon Redshift stores the value as a lowercase string.</p> <p>Constraints:</p> <ul> <li> <p>Must contain no more than 255 alphanumeric characters or hyphens.</p> </li> <li> <p>Must not be "Default".</p> </li> <li> <p>Must be unique for all security groups that are created by your AWS account.</p> </li> </ul> <p>Example: <code>examplesecuritygroup</code> </p>
  ##   Description: string (required)
  ##              : A description for the security group.
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_603442 = newJObject()
  add(query_603442, "ClusterSecurityGroupName",
      newJString(ClusterSecurityGroupName))
  add(query_603442, "Description", newJString(Description))
  if Tags != nil:
    query_603442.add "Tags", Tags
  add(query_603442, "Action", newJString(Action))
  add(query_603442, "Version", newJString(Version))
  result = call_603441.call(nil, query_603442, nil, nil, nil)

var getCreateClusterSecurityGroup* = Call_GetCreateClusterSecurityGroup_603425(
    name: "getCreateClusterSecurityGroup", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=CreateClusterSecurityGroup",
    validator: validate_GetCreateClusterSecurityGroup_603426, base: "/",
    url: url_GetCreateClusterSecurityGroup_603427,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCreateClusterSnapshot_603481 = ref object of OpenApiRestCall_602450
proc url_PostCreateClusterSnapshot_603483(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostCreateClusterSnapshot_603482(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a manual snapshot of the specified cluster. The cluster must be in the <code>available</code> state. </p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_603484 = query.getOrDefault("Action")
  valid_603484 = validateParameter(valid_603484, JString, required = true,
                                 default = newJString("CreateClusterSnapshot"))
  if valid_603484 != nil:
    section.add "Action", valid_603484
  var valid_603485 = query.getOrDefault("Version")
  valid_603485 = validateParameter(valid_603485, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_603485 != nil:
    section.add "Version", valid_603485
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603486 = header.getOrDefault("X-Amz-Date")
  valid_603486 = validateParameter(valid_603486, JString, required = false,
                                 default = nil)
  if valid_603486 != nil:
    section.add "X-Amz-Date", valid_603486
  var valid_603487 = header.getOrDefault("X-Amz-Security-Token")
  valid_603487 = validateParameter(valid_603487, JString, required = false,
                                 default = nil)
  if valid_603487 != nil:
    section.add "X-Amz-Security-Token", valid_603487
  var valid_603488 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603488 = validateParameter(valid_603488, JString, required = false,
                                 default = nil)
  if valid_603488 != nil:
    section.add "X-Amz-Content-Sha256", valid_603488
  var valid_603489 = header.getOrDefault("X-Amz-Algorithm")
  valid_603489 = validateParameter(valid_603489, JString, required = false,
                                 default = nil)
  if valid_603489 != nil:
    section.add "X-Amz-Algorithm", valid_603489
  var valid_603490 = header.getOrDefault("X-Amz-Signature")
  valid_603490 = validateParameter(valid_603490, JString, required = false,
                                 default = nil)
  if valid_603490 != nil:
    section.add "X-Amz-Signature", valid_603490
  var valid_603491 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603491 = validateParameter(valid_603491, JString, required = false,
                                 default = nil)
  if valid_603491 != nil:
    section.add "X-Amz-SignedHeaders", valid_603491
  var valid_603492 = header.getOrDefault("X-Amz-Credential")
  valid_603492 = validateParameter(valid_603492, JString, required = false,
                                 default = nil)
  if valid_603492 != nil:
    section.add "X-Amz-Credential", valid_603492
  result.add "header", section
  ## parameters in `formData` object:
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   ClusterIdentifier: JString (required)
  ##                    : The cluster identifier for which you want a snapshot.
  ##   SnapshotIdentifier: JString (required)
  ##                     : <p>A unique identifier for the snapshot that you are requesting. This identifier must be unique for all snapshots within the AWS account.</p> <p>Constraints:</p> <ul> <li> <p>Cannot be null, empty, or blank</p> </li> <li> <p>Must contain from 1 to 255 alphanumeric characters or hyphens</p> </li> <li> <p>First character must be a letter</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens</p> </li> </ul> <p>Example: <code>my-snapshot-id</code> </p>
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. </p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  section = newJObject()
  var valid_603493 = formData.getOrDefault("Tags")
  valid_603493 = validateParameter(valid_603493, JArray, required = false,
                                 default = nil)
  if valid_603493 != nil:
    section.add "Tags", valid_603493
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_603494 = formData.getOrDefault("ClusterIdentifier")
  valid_603494 = validateParameter(valid_603494, JString, required = true,
                                 default = nil)
  if valid_603494 != nil:
    section.add "ClusterIdentifier", valid_603494
  var valid_603495 = formData.getOrDefault("SnapshotIdentifier")
  valid_603495 = validateParameter(valid_603495, JString, required = true,
                                 default = nil)
  if valid_603495 != nil:
    section.add "SnapshotIdentifier", valid_603495
  var valid_603496 = formData.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_603496 = validateParameter(valid_603496, JInt, required = false, default = nil)
  if valid_603496 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_603496
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603497: Call_PostCreateClusterSnapshot_603481; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a manual snapshot of the specified cluster. The cluster must be in the <code>available</code> state. </p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_603497.validator(path, query, header, formData, body)
  let scheme = call_603497.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603497.url(scheme.get, call_603497.host, call_603497.base,
                         call_603497.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_603497, url, valid)

proc call*(call_603498: Call_PostCreateClusterSnapshot_603481;
          ClusterIdentifier: string; SnapshotIdentifier: string;
          Tags: JsonNode = nil; Action: string = "CreateClusterSnapshot";
          ManualSnapshotRetentionPeriod: int = 0; Version: string = "2012-12-01"): Recallable =
  ## postCreateClusterSnapshot
  ## <p>Creates a manual snapshot of the specified cluster. The cluster must be in the <code>available</code> state. </p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : The cluster identifier for which you want a snapshot.
  ##   SnapshotIdentifier: string (required)
  ##                     : <p>A unique identifier for the snapshot that you are requesting. This identifier must be unique for all snapshots within the AWS account.</p> <p>Constraints:</p> <ul> <li> <p>Cannot be null, empty, or blank</p> </li> <li> <p>Must contain from 1 to 255 alphanumeric characters or hyphens</p> </li> <li> <p>First character must be a letter</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens</p> </li> </ul> <p>Example: <code>my-snapshot-id</code> </p>
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. </p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  ##   Version: string (required)
  var query_603499 = newJObject()
  var formData_603500 = newJObject()
  if Tags != nil:
    formData_603500.add "Tags", Tags
  add(query_603499, "Action", newJString(Action))
  add(formData_603500, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_603500, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(formData_603500, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  add(query_603499, "Version", newJString(Version))
  result = call_603498.call(nil, query_603499, nil, formData_603500, nil)

var postCreateClusterSnapshot* = Call_PostCreateClusterSnapshot_603481(
    name: "postCreateClusterSnapshot", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=CreateClusterSnapshot",
    validator: validate_PostCreateClusterSnapshot_603482, base: "/",
    url: url_PostCreateClusterSnapshot_603483,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCreateClusterSnapshot_603462 = ref object of OpenApiRestCall_602450
proc url_GetCreateClusterSnapshot_603464(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetCreateClusterSnapshot_603463(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a manual snapshot of the specified cluster. The cluster must be in the <code>available</code> state. </p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : The cluster identifier for which you want a snapshot.
  ##   SnapshotIdentifier: JString (required)
  ##                     : <p>A unique identifier for the snapshot that you are requesting. This identifier must be unique for all snapshots within the AWS account.</p> <p>Constraints:</p> <ul> <li> <p>Cannot be null, empty, or blank</p> </li> <li> <p>Must contain from 1 to 255 alphanumeric characters or hyphens</p> </li> <li> <p>First character must be a letter</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens</p> </li> </ul> <p>Example: <code>my-snapshot-id</code> </p>
  ##   Version: JString (required)
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. </p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  section = newJObject()
  var valid_603465 = query.getOrDefault("Tags")
  valid_603465 = validateParameter(valid_603465, JArray, required = false,
                                 default = nil)
  if valid_603465 != nil:
    section.add "Tags", valid_603465
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_603466 = query.getOrDefault("Action")
  valid_603466 = validateParameter(valid_603466, JString, required = true,
                                 default = newJString("CreateClusterSnapshot"))
  if valid_603466 != nil:
    section.add "Action", valid_603466
  var valid_603467 = query.getOrDefault("ClusterIdentifier")
  valid_603467 = validateParameter(valid_603467, JString, required = true,
                                 default = nil)
  if valid_603467 != nil:
    section.add "ClusterIdentifier", valid_603467
  var valid_603468 = query.getOrDefault("SnapshotIdentifier")
  valid_603468 = validateParameter(valid_603468, JString, required = true,
                                 default = nil)
  if valid_603468 != nil:
    section.add "SnapshotIdentifier", valid_603468
  var valid_603469 = query.getOrDefault("Version")
  valid_603469 = validateParameter(valid_603469, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_603469 != nil:
    section.add "Version", valid_603469
  var valid_603470 = query.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_603470 = validateParameter(valid_603470, JInt, required = false, default = nil)
  if valid_603470 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_603470
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603471 = header.getOrDefault("X-Amz-Date")
  valid_603471 = validateParameter(valid_603471, JString, required = false,
                                 default = nil)
  if valid_603471 != nil:
    section.add "X-Amz-Date", valid_603471
  var valid_603472 = header.getOrDefault("X-Amz-Security-Token")
  valid_603472 = validateParameter(valid_603472, JString, required = false,
                                 default = nil)
  if valid_603472 != nil:
    section.add "X-Amz-Security-Token", valid_603472
  var valid_603473 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603473 = validateParameter(valid_603473, JString, required = false,
                                 default = nil)
  if valid_603473 != nil:
    section.add "X-Amz-Content-Sha256", valid_603473
  var valid_603474 = header.getOrDefault("X-Amz-Algorithm")
  valid_603474 = validateParameter(valid_603474, JString, required = false,
                                 default = nil)
  if valid_603474 != nil:
    section.add "X-Amz-Algorithm", valid_603474
  var valid_603475 = header.getOrDefault("X-Amz-Signature")
  valid_603475 = validateParameter(valid_603475, JString, required = false,
                                 default = nil)
  if valid_603475 != nil:
    section.add "X-Amz-Signature", valid_603475
  var valid_603476 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603476 = validateParameter(valid_603476, JString, required = false,
                                 default = nil)
  if valid_603476 != nil:
    section.add "X-Amz-SignedHeaders", valid_603476
  var valid_603477 = header.getOrDefault("X-Amz-Credential")
  valid_603477 = validateParameter(valid_603477, JString, required = false,
                                 default = nil)
  if valid_603477 != nil:
    section.add "X-Amz-Credential", valid_603477
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603478: Call_GetCreateClusterSnapshot_603462; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a manual snapshot of the specified cluster. The cluster must be in the <code>available</code> state. </p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_603478.validator(path, query, header, formData, body)
  let scheme = call_603478.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603478.url(scheme.get, call_603478.host, call_603478.base,
                         call_603478.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_603478, url, valid)

proc call*(call_603479: Call_GetCreateClusterSnapshot_603462;
          ClusterIdentifier: string; SnapshotIdentifier: string;
          Tags: JsonNode = nil; Action: string = "CreateClusterSnapshot";
          Version: string = "2012-12-01"; ManualSnapshotRetentionPeriod: int = 0): Recallable =
  ## getCreateClusterSnapshot
  ## <p>Creates a manual snapshot of the specified cluster. The cluster must be in the <code>available</code> state. </p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : The cluster identifier for which you want a snapshot.
  ##   SnapshotIdentifier: string (required)
  ##                     : <p>A unique identifier for the snapshot that you are requesting. This identifier must be unique for all snapshots within the AWS account.</p> <p>Constraints:</p> <ul> <li> <p>Cannot be null, empty, or blank</p> </li> <li> <p>Must contain from 1 to 255 alphanumeric characters or hyphens</p> </li> <li> <p>First character must be a letter</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens</p> </li> </ul> <p>Example: <code>my-snapshot-id</code> </p>
  ##   Version: string (required)
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. </p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  var query_603480 = newJObject()
  if Tags != nil:
    query_603480.add "Tags", Tags
  add(query_603480, "Action", newJString(Action))
  add(query_603480, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_603480, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_603480, "Version", newJString(Version))
  add(query_603480, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  result = call_603479.call(nil, query_603480, nil, nil, nil)

var getCreateClusterSnapshot* = Call_GetCreateClusterSnapshot_603462(
    name: "getCreateClusterSnapshot", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=CreateClusterSnapshot",
    validator: validate_GetCreateClusterSnapshot_603463, base: "/",
    url: url_GetCreateClusterSnapshot_603464, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCreateClusterSubnetGroup_603520 = ref object of OpenApiRestCall_602450
proc url_PostCreateClusterSubnetGroup_603522(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostCreateClusterSubnetGroup_603521(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a new Amazon Redshift subnet group. You must provide a list of one or more subnets in your existing Amazon Virtual Private Cloud (Amazon VPC) when creating Amazon Redshift subnet group.</p> <p> For information about subnet groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-cluster-subnet-groups.html">Amazon Redshift Cluster Subnet Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_603523 = query.getOrDefault("Action")
  valid_603523 = validateParameter(valid_603523, JString, required = true, default = newJString(
      "CreateClusterSubnetGroup"))
  if valid_603523 != nil:
    section.add "Action", valid_603523
  var valid_603524 = query.getOrDefault("Version")
  valid_603524 = validateParameter(valid_603524, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_603524 != nil:
    section.add "Version", valid_603524
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603525 = header.getOrDefault("X-Amz-Date")
  valid_603525 = validateParameter(valid_603525, JString, required = false,
                                 default = nil)
  if valid_603525 != nil:
    section.add "X-Amz-Date", valid_603525
  var valid_603526 = header.getOrDefault("X-Amz-Security-Token")
  valid_603526 = validateParameter(valid_603526, JString, required = false,
                                 default = nil)
  if valid_603526 != nil:
    section.add "X-Amz-Security-Token", valid_603526
  var valid_603527 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603527 = validateParameter(valid_603527, JString, required = false,
                                 default = nil)
  if valid_603527 != nil:
    section.add "X-Amz-Content-Sha256", valid_603527
  var valid_603528 = header.getOrDefault("X-Amz-Algorithm")
  valid_603528 = validateParameter(valid_603528, JString, required = false,
                                 default = nil)
  if valid_603528 != nil:
    section.add "X-Amz-Algorithm", valid_603528
  var valid_603529 = header.getOrDefault("X-Amz-Signature")
  valid_603529 = validateParameter(valid_603529, JString, required = false,
                                 default = nil)
  if valid_603529 != nil:
    section.add "X-Amz-Signature", valid_603529
  var valid_603530 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603530 = validateParameter(valid_603530, JString, required = false,
                                 default = nil)
  if valid_603530 != nil:
    section.add "X-Amz-SignedHeaders", valid_603530
  var valid_603531 = header.getOrDefault("X-Amz-Credential")
  valid_603531 = validateParameter(valid_603531, JString, required = false,
                                 default = nil)
  if valid_603531 != nil:
    section.add "X-Amz-Credential", valid_603531
  result.add "header", section
  ## parameters in `formData` object:
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   SubnetIds: JArray (required)
  ##            : An array of VPC subnet IDs. A maximum of 20 subnets can be modified in a single request.
  ##   Description: JString (required)
  ##              : A description for the subnet group.
  ##   ClusterSubnetGroupName: JString (required)
  ##                         : <p>The name for the subnet group. Amazon Redshift stores the value as a lowercase string.</p> <p>Constraints:</p> <ul> <li> <p>Must contain no more than 255 alphanumeric characters or hyphens.</p> </li> <li> <p>Must not be "Default".</p> </li> <li> <p>Must be unique for all subnet groups that are created by your AWS account.</p> </li> </ul> <p>Example: <code>examplesubnetgroup</code> </p>
  section = newJObject()
  var valid_603532 = formData.getOrDefault("Tags")
  valid_603532 = validateParameter(valid_603532, JArray, required = false,
                                 default = nil)
  if valid_603532 != nil:
    section.add "Tags", valid_603532
  assert formData != nil,
        "formData argument is necessary due to required `SubnetIds` field"
  var valid_603533 = formData.getOrDefault("SubnetIds")
  valid_603533 = validateParameter(valid_603533, JArray, required = true, default = nil)
  if valid_603533 != nil:
    section.add "SubnetIds", valid_603533
  var valid_603534 = formData.getOrDefault("Description")
  valid_603534 = validateParameter(valid_603534, JString, required = true,
                                 default = nil)
  if valid_603534 != nil:
    section.add "Description", valid_603534
  var valid_603535 = formData.getOrDefault("ClusterSubnetGroupName")
  valid_603535 = validateParameter(valid_603535, JString, required = true,
                                 default = nil)
  if valid_603535 != nil:
    section.add "ClusterSubnetGroupName", valid_603535
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603536: Call_PostCreateClusterSubnetGroup_603520; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a new Amazon Redshift subnet group. You must provide a list of one or more subnets in your existing Amazon Virtual Private Cloud (Amazon VPC) when creating Amazon Redshift subnet group.</p> <p> For information about subnet groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-cluster-subnet-groups.html">Amazon Redshift Cluster Subnet Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_603536.validator(path, query, header, formData, body)
  let scheme = call_603536.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603536.url(scheme.get, call_603536.host, call_603536.base,
                         call_603536.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_603536, url, valid)

proc call*(call_603537: Call_PostCreateClusterSubnetGroup_603520;
          SubnetIds: JsonNode; Description: string; ClusterSubnetGroupName: string;
          Tags: JsonNode = nil; Action: string = "CreateClusterSubnetGroup";
          Version: string = "2012-12-01"): Recallable =
  ## postCreateClusterSubnetGroup
  ## <p>Creates a new Amazon Redshift subnet group. You must provide a list of one or more subnets in your existing Amazon Virtual Private Cloud (Amazon VPC) when creating Amazon Redshift subnet group.</p> <p> For information about subnet groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-cluster-subnet-groups.html">Amazon Redshift Cluster Subnet Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   SubnetIds: JArray (required)
  ##            : An array of VPC subnet IDs. A maximum of 20 subnets can be modified in a single request.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   Description: string (required)
  ##              : A description for the subnet group.
  ##   ClusterSubnetGroupName: string (required)
  ##                         : <p>The name for the subnet group. Amazon Redshift stores the value as a lowercase string.</p> <p>Constraints:</p> <ul> <li> <p>Must contain no more than 255 alphanumeric characters or hyphens.</p> </li> <li> <p>Must not be "Default".</p> </li> <li> <p>Must be unique for all subnet groups that are created by your AWS account.</p> </li> </ul> <p>Example: <code>examplesubnetgroup</code> </p>
  var query_603538 = newJObject()
  var formData_603539 = newJObject()
  if Tags != nil:
    formData_603539.add "Tags", Tags
  if SubnetIds != nil:
    formData_603539.add "SubnetIds", SubnetIds
  add(query_603538, "Action", newJString(Action))
  add(query_603538, "Version", newJString(Version))
  add(formData_603539, "Description", newJString(Description))
  add(formData_603539, "ClusterSubnetGroupName",
      newJString(ClusterSubnetGroupName))
  result = call_603537.call(nil, query_603538, nil, formData_603539, nil)

var postCreateClusterSubnetGroup* = Call_PostCreateClusterSubnetGroup_603520(
    name: "postCreateClusterSubnetGroup", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=CreateClusterSubnetGroup",
    validator: validate_PostCreateClusterSubnetGroup_603521, base: "/",
    url: url_PostCreateClusterSubnetGroup_603522,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCreateClusterSubnetGroup_603501 = ref object of OpenApiRestCall_602450
proc url_GetCreateClusterSubnetGroup_603503(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetCreateClusterSubnetGroup_603502(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a new Amazon Redshift subnet group. You must provide a list of one or more subnets in your existing Amazon Virtual Private Cloud (Amazon VPC) when creating Amazon Redshift subnet group.</p> <p> For information about subnet groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-cluster-subnet-groups.html">Amazon Redshift Cluster Subnet Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ClusterSubnetGroupName: JString (required)
  ##                         : <p>The name for the subnet group. Amazon Redshift stores the value as a lowercase string.</p> <p>Constraints:</p> <ul> <li> <p>Must contain no more than 255 alphanumeric characters or hyphens.</p> </li> <li> <p>Must not be "Default".</p> </li> <li> <p>Must be unique for all subnet groups that are created by your AWS account.</p> </li> </ul> <p>Example: <code>examplesubnetgroup</code> </p>
  ##   Description: JString (required)
  ##              : A description for the subnet group.
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Action: JString (required)
  ##   SubnetIds: JArray (required)
  ##            : An array of VPC subnet IDs. A maximum of 20 subnets can be modified in a single request.
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `ClusterSubnetGroupName` field"
  var valid_603504 = query.getOrDefault("ClusterSubnetGroupName")
  valid_603504 = validateParameter(valid_603504, JString, required = true,
                                 default = nil)
  if valid_603504 != nil:
    section.add "ClusterSubnetGroupName", valid_603504
  var valid_603505 = query.getOrDefault("Description")
  valid_603505 = validateParameter(valid_603505, JString, required = true,
                                 default = nil)
  if valid_603505 != nil:
    section.add "Description", valid_603505
  var valid_603506 = query.getOrDefault("Tags")
  valid_603506 = validateParameter(valid_603506, JArray, required = false,
                                 default = nil)
  if valid_603506 != nil:
    section.add "Tags", valid_603506
  var valid_603507 = query.getOrDefault("Action")
  valid_603507 = validateParameter(valid_603507, JString, required = true, default = newJString(
      "CreateClusterSubnetGroup"))
  if valid_603507 != nil:
    section.add "Action", valid_603507
  var valid_603508 = query.getOrDefault("SubnetIds")
  valid_603508 = validateParameter(valid_603508, JArray, required = true, default = nil)
  if valid_603508 != nil:
    section.add "SubnetIds", valid_603508
  var valid_603509 = query.getOrDefault("Version")
  valid_603509 = validateParameter(valid_603509, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_603509 != nil:
    section.add "Version", valid_603509
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603510 = header.getOrDefault("X-Amz-Date")
  valid_603510 = validateParameter(valid_603510, JString, required = false,
                                 default = nil)
  if valid_603510 != nil:
    section.add "X-Amz-Date", valid_603510
  var valid_603511 = header.getOrDefault("X-Amz-Security-Token")
  valid_603511 = validateParameter(valid_603511, JString, required = false,
                                 default = nil)
  if valid_603511 != nil:
    section.add "X-Amz-Security-Token", valid_603511
  var valid_603512 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603512 = validateParameter(valid_603512, JString, required = false,
                                 default = nil)
  if valid_603512 != nil:
    section.add "X-Amz-Content-Sha256", valid_603512
  var valid_603513 = header.getOrDefault("X-Amz-Algorithm")
  valid_603513 = validateParameter(valid_603513, JString, required = false,
                                 default = nil)
  if valid_603513 != nil:
    section.add "X-Amz-Algorithm", valid_603513
  var valid_603514 = header.getOrDefault("X-Amz-Signature")
  valid_603514 = validateParameter(valid_603514, JString, required = false,
                                 default = nil)
  if valid_603514 != nil:
    section.add "X-Amz-Signature", valid_603514
  var valid_603515 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603515 = validateParameter(valid_603515, JString, required = false,
                                 default = nil)
  if valid_603515 != nil:
    section.add "X-Amz-SignedHeaders", valid_603515
  var valid_603516 = header.getOrDefault("X-Amz-Credential")
  valid_603516 = validateParameter(valid_603516, JString, required = false,
                                 default = nil)
  if valid_603516 != nil:
    section.add "X-Amz-Credential", valid_603516
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603517: Call_GetCreateClusterSubnetGroup_603501; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a new Amazon Redshift subnet group. You must provide a list of one or more subnets in your existing Amazon Virtual Private Cloud (Amazon VPC) when creating Amazon Redshift subnet group.</p> <p> For information about subnet groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-cluster-subnet-groups.html">Amazon Redshift Cluster Subnet Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_603517.validator(path, query, header, formData, body)
  let scheme = call_603517.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603517.url(scheme.get, call_603517.host, call_603517.base,
                         call_603517.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_603517, url, valid)

proc call*(call_603518: Call_GetCreateClusterSubnetGroup_603501;
          ClusterSubnetGroupName: string; Description: string; SubnetIds: JsonNode;
          Tags: JsonNode = nil; Action: string = "CreateClusterSubnetGroup";
          Version: string = "2012-12-01"): Recallable =
  ## getCreateClusterSubnetGroup
  ## <p>Creates a new Amazon Redshift subnet group. You must provide a list of one or more subnets in your existing Amazon Virtual Private Cloud (Amazon VPC) when creating Amazon Redshift subnet group.</p> <p> For information about subnet groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-cluster-subnet-groups.html">Amazon Redshift Cluster Subnet Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   ClusterSubnetGroupName: string (required)
  ##                         : <p>The name for the subnet group. Amazon Redshift stores the value as a lowercase string.</p> <p>Constraints:</p> <ul> <li> <p>Must contain no more than 255 alphanumeric characters or hyphens.</p> </li> <li> <p>Must not be "Default".</p> </li> <li> <p>Must be unique for all subnet groups that are created by your AWS account.</p> </li> </ul> <p>Example: <code>examplesubnetgroup</code> </p>
  ##   Description: string (required)
  ##              : A description for the subnet group.
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Action: string (required)
  ##   SubnetIds: JArray (required)
  ##            : An array of VPC subnet IDs. A maximum of 20 subnets can be modified in a single request.
  ##   Version: string (required)
  var query_603519 = newJObject()
  add(query_603519, "ClusterSubnetGroupName", newJString(ClusterSubnetGroupName))
  add(query_603519, "Description", newJString(Description))
  if Tags != nil:
    query_603519.add "Tags", Tags
  add(query_603519, "Action", newJString(Action))
  if SubnetIds != nil:
    query_603519.add "SubnetIds", SubnetIds
  add(query_603519, "Version", newJString(Version))
  result = call_603518.call(nil, query_603519, nil, nil, nil)

var getCreateClusterSubnetGroup* = Call_GetCreateClusterSubnetGroup_603501(
    name: "getCreateClusterSubnetGroup", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=CreateClusterSubnetGroup",
    validator: validate_GetCreateClusterSubnetGroup_603502, base: "/",
    url: url_GetCreateClusterSubnetGroup_603503,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCreateEventSubscription_603563 = ref object of OpenApiRestCall_602450
proc url_PostCreateEventSubscription_603565(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostCreateEventSubscription_603564(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates an Amazon Redshift event notification subscription. This action requires an ARN (Amazon Resource Name) of an Amazon SNS topic created by either the Amazon Redshift console, the Amazon SNS console, or the Amazon SNS API. To obtain an ARN with Amazon SNS, you must create a topic in Amazon SNS and subscribe to the topic. The ARN is displayed in the SNS console.</p> <p>You can specify the source type, and lists of Amazon Redshift source IDs, event categories, and event severities. Notifications will be sent for all events you want that match those criteria. For example, you can specify source type = cluster, source ID = my-cluster-1 and mycluster2, event categories = Availability, Backup, and severity = ERROR. The subscription will only send notifications for those ERROR events in the Availability and Backup categories for the specified clusters.</p> <p>If you specify both the source type and source IDs, such as source type = cluster and source identifier = my-cluster-1, notifications will be sent for all the cluster events for my-cluster-1. If you specify a source type but do not specify a source identifier, you will receive notice of the events for the objects of that type in your AWS account. If you do not specify either the SourceType nor the SourceIdentifier, you will be notified of events generated from all Amazon Redshift sources belonging to your AWS account. You must specify a source type if you specify a source ID.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_603566 = query.getOrDefault("Action")
  valid_603566 = validateParameter(valid_603566, JString, required = true, default = newJString(
      "CreateEventSubscription"))
  if valid_603566 != nil:
    section.add "Action", valid_603566
  var valid_603567 = query.getOrDefault("Version")
  valid_603567 = validateParameter(valid_603567, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_603567 != nil:
    section.add "Version", valid_603567
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603568 = header.getOrDefault("X-Amz-Date")
  valid_603568 = validateParameter(valid_603568, JString, required = false,
                                 default = nil)
  if valid_603568 != nil:
    section.add "X-Amz-Date", valid_603568
  var valid_603569 = header.getOrDefault("X-Amz-Security-Token")
  valid_603569 = validateParameter(valid_603569, JString, required = false,
                                 default = nil)
  if valid_603569 != nil:
    section.add "X-Amz-Security-Token", valid_603569
  var valid_603570 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603570 = validateParameter(valid_603570, JString, required = false,
                                 default = nil)
  if valid_603570 != nil:
    section.add "X-Amz-Content-Sha256", valid_603570
  var valid_603571 = header.getOrDefault("X-Amz-Algorithm")
  valid_603571 = validateParameter(valid_603571, JString, required = false,
                                 default = nil)
  if valid_603571 != nil:
    section.add "X-Amz-Algorithm", valid_603571
  var valid_603572 = header.getOrDefault("X-Amz-Signature")
  valid_603572 = validateParameter(valid_603572, JString, required = false,
                                 default = nil)
  if valid_603572 != nil:
    section.add "X-Amz-Signature", valid_603572
  var valid_603573 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603573 = validateParameter(valid_603573, JString, required = false,
                                 default = nil)
  if valid_603573 != nil:
    section.add "X-Amz-SignedHeaders", valid_603573
  var valid_603574 = header.getOrDefault("X-Amz-Credential")
  valid_603574 = validateParameter(valid_603574, JString, required = false,
                                 default = nil)
  if valid_603574 != nil:
    section.add "X-Amz-Credential", valid_603574
  result.add "header", section
  ## parameters in `formData` object:
  ##   Enabled: JBool
  ##          : A boolean value; set to <code>true</code> to activate the subscription, and set to <code>false</code> to create the subscription but not activate it. 
  ##   EventCategories: JArray
  ##                  : <p>Specifies the Amazon Redshift event categories to be published by the event notification subscription.</p> <p>Values: configuration, management, monitoring, security</p>
  ##   SnsTopicArn: JString (required)
  ##              : The Amazon Resource Name (ARN) of the Amazon SNS topic used to transmit the event notifications. The ARN is created by Amazon SNS when you create a topic and subscribe to it.
  ##   Severity: JString
  ##           : <p>Specifies the Amazon Redshift event severity to be published by the event notification subscription.</p> <p>Values: ERROR, INFO</p>
  ##   SourceIds: JArray
  ##            : <p>A list of one or more identifiers of Amazon Redshift source objects. All of the objects must be of the same type as was specified in the source type parameter. The event subscription will return only events generated by the specified objects. If not specified, then events are returned for all objects within the source type specified.</p> <p>Example: my-cluster-1, my-cluster-2</p> <p>Example: my-snapshot-20131010</p>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   SubscriptionName: JString (required)
  ##                   : <p>The name of the event subscription to be created.</p> <p>Constraints:</p> <ul> <li> <p>Cannot be null, empty, or blank.</p> </li> <li> <p>Must contain from 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   SourceType: JString
  ##             : <p>The type of source that will be generating the events. For example, if you want to be notified of events generated by a cluster, you would set this parameter to cluster. If this value is not specified, events are returned for all Amazon Redshift objects in your AWS account. You must specify a source type in order to specify source IDs.</p> <p>Valid values: cluster, cluster-parameter-group, cluster-security-group, and cluster-snapshot.</p>
  section = newJObject()
  var valid_603575 = formData.getOrDefault("Enabled")
  valid_603575 = validateParameter(valid_603575, JBool, required = false, default = nil)
  if valid_603575 != nil:
    section.add "Enabled", valid_603575
  var valid_603576 = formData.getOrDefault("EventCategories")
  valid_603576 = validateParameter(valid_603576, JArray, required = false,
                                 default = nil)
  if valid_603576 != nil:
    section.add "EventCategories", valid_603576
  assert formData != nil,
        "formData argument is necessary due to required `SnsTopicArn` field"
  var valid_603577 = formData.getOrDefault("SnsTopicArn")
  valid_603577 = validateParameter(valid_603577, JString, required = true,
                                 default = nil)
  if valid_603577 != nil:
    section.add "SnsTopicArn", valid_603577
  var valid_603578 = formData.getOrDefault("Severity")
  valid_603578 = validateParameter(valid_603578, JString, required = false,
                                 default = nil)
  if valid_603578 != nil:
    section.add "Severity", valid_603578
  var valid_603579 = formData.getOrDefault("SourceIds")
  valid_603579 = validateParameter(valid_603579, JArray, required = false,
                                 default = nil)
  if valid_603579 != nil:
    section.add "SourceIds", valid_603579
  var valid_603580 = formData.getOrDefault("Tags")
  valid_603580 = validateParameter(valid_603580, JArray, required = false,
                                 default = nil)
  if valid_603580 != nil:
    section.add "Tags", valid_603580
  var valid_603581 = formData.getOrDefault("SubscriptionName")
  valid_603581 = validateParameter(valid_603581, JString, required = true,
                                 default = nil)
  if valid_603581 != nil:
    section.add "SubscriptionName", valid_603581
  var valid_603582 = formData.getOrDefault("SourceType")
  valid_603582 = validateParameter(valid_603582, JString, required = false,
                                 default = nil)
  if valid_603582 != nil:
    section.add "SourceType", valid_603582
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603583: Call_PostCreateEventSubscription_603563; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates an Amazon Redshift event notification subscription. This action requires an ARN (Amazon Resource Name) of an Amazon SNS topic created by either the Amazon Redshift console, the Amazon SNS console, or the Amazon SNS API. To obtain an ARN with Amazon SNS, you must create a topic in Amazon SNS and subscribe to the topic. The ARN is displayed in the SNS console.</p> <p>You can specify the source type, and lists of Amazon Redshift source IDs, event categories, and event severities. Notifications will be sent for all events you want that match those criteria. For example, you can specify source type = cluster, source ID = my-cluster-1 and mycluster2, event categories = Availability, Backup, and severity = ERROR. The subscription will only send notifications for those ERROR events in the Availability and Backup categories for the specified clusters.</p> <p>If you specify both the source type and source IDs, such as source type = cluster and source identifier = my-cluster-1, notifications will be sent for all the cluster events for my-cluster-1. If you specify a source type but do not specify a source identifier, you will receive notice of the events for the objects of that type in your AWS account. If you do not specify either the SourceType nor the SourceIdentifier, you will be notified of events generated from all Amazon Redshift sources belonging to your AWS account. You must specify a source type if you specify a source ID.</p>
  ## 
  let valid = call_603583.validator(path, query, header, formData, body)
  let scheme = call_603583.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603583.url(scheme.get, call_603583.host, call_603583.base,
                         call_603583.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_603583, url, valid)

proc call*(call_603584: Call_PostCreateEventSubscription_603563;
          SnsTopicArn: string; SubscriptionName: string; Enabled: bool = false;
          EventCategories: JsonNode = nil; Severity: string = "";
          SourceIds: JsonNode = nil; Tags: JsonNode = nil;
          Action: string = "CreateEventSubscription";
          Version: string = "2012-12-01"; SourceType: string = ""): Recallable =
  ## postCreateEventSubscription
  ## <p>Creates an Amazon Redshift event notification subscription. This action requires an ARN (Amazon Resource Name) of an Amazon SNS topic created by either the Amazon Redshift console, the Amazon SNS console, or the Amazon SNS API. To obtain an ARN with Amazon SNS, you must create a topic in Amazon SNS and subscribe to the topic. The ARN is displayed in the SNS console.</p> <p>You can specify the source type, and lists of Amazon Redshift source IDs, event categories, and event severities. Notifications will be sent for all events you want that match those criteria. For example, you can specify source type = cluster, source ID = my-cluster-1 and mycluster2, event categories = Availability, Backup, and severity = ERROR. The subscription will only send notifications for those ERROR events in the Availability and Backup categories for the specified clusters.</p> <p>If you specify both the source type and source IDs, such as source type = cluster and source identifier = my-cluster-1, notifications will be sent for all the cluster events for my-cluster-1. If you specify a source type but do not specify a source identifier, you will receive notice of the events for the objects of that type in your AWS account. If you do not specify either the SourceType nor the SourceIdentifier, you will be notified of events generated from all Amazon Redshift sources belonging to your AWS account. You must specify a source type if you specify a source ID.</p>
  ##   Enabled: bool
  ##          : A boolean value; set to <code>true</code> to activate the subscription, and set to <code>false</code> to create the subscription but not activate it. 
  ##   EventCategories: JArray
  ##                  : <p>Specifies the Amazon Redshift event categories to be published by the event notification subscription.</p> <p>Values: configuration, management, monitoring, security</p>
  ##   SnsTopicArn: string (required)
  ##              : The Amazon Resource Name (ARN) of the Amazon SNS topic used to transmit the event notifications. The ARN is created by Amazon SNS when you create a topic and subscribe to it.
  ##   Severity: string
  ##           : <p>Specifies the Amazon Redshift event severity to be published by the event notification subscription.</p> <p>Values: ERROR, INFO</p>
  ##   SourceIds: JArray
  ##            : <p>A list of one or more identifiers of Amazon Redshift source objects. All of the objects must be of the same type as was specified in the source type parameter. The event subscription will return only events generated by the specified objects. If not specified, then events are returned for all objects within the source type specified.</p> <p>Example: my-cluster-1, my-cluster-2</p> <p>Example: my-snapshot-20131010</p>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   SubscriptionName: string (required)
  ##                   : <p>The name of the event subscription to be created.</p> <p>Constraints:</p> <ul> <li> <p>Cannot be null, empty, or blank.</p> </li> <li> <p>Must contain from 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   Action: string (required)
  ##   Version: string (required)
  ##   SourceType: string
  ##             : <p>The type of source that will be generating the events. For example, if you want to be notified of events generated by a cluster, you would set this parameter to cluster. If this value is not specified, events are returned for all Amazon Redshift objects in your AWS account. You must specify a source type in order to specify source IDs.</p> <p>Valid values: cluster, cluster-parameter-group, cluster-security-group, and cluster-snapshot.</p>
  var query_603585 = newJObject()
  var formData_603586 = newJObject()
  add(formData_603586, "Enabled", newJBool(Enabled))
  if EventCategories != nil:
    formData_603586.add "EventCategories", EventCategories
  add(formData_603586, "SnsTopicArn", newJString(SnsTopicArn))
  add(formData_603586, "Severity", newJString(Severity))
  if SourceIds != nil:
    formData_603586.add "SourceIds", SourceIds
  if Tags != nil:
    formData_603586.add "Tags", Tags
  add(formData_603586, "SubscriptionName", newJString(SubscriptionName))
  add(query_603585, "Action", newJString(Action))
  add(query_603585, "Version", newJString(Version))
  add(formData_603586, "SourceType", newJString(SourceType))
  result = call_603584.call(nil, query_603585, nil, formData_603586, nil)

var postCreateEventSubscription* = Call_PostCreateEventSubscription_603563(
    name: "postCreateEventSubscription", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=CreateEventSubscription",
    validator: validate_PostCreateEventSubscription_603564, base: "/",
    url: url_PostCreateEventSubscription_603565,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCreateEventSubscription_603540 = ref object of OpenApiRestCall_602450
proc url_GetCreateEventSubscription_603542(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetCreateEventSubscription_603541(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates an Amazon Redshift event notification subscription. This action requires an ARN (Amazon Resource Name) of an Amazon SNS topic created by either the Amazon Redshift console, the Amazon SNS console, or the Amazon SNS API. To obtain an ARN with Amazon SNS, you must create a topic in Amazon SNS and subscribe to the topic. The ARN is displayed in the SNS console.</p> <p>You can specify the source type, and lists of Amazon Redshift source IDs, event categories, and event severities. Notifications will be sent for all events you want that match those criteria. For example, you can specify source type = cluster, source ID = my-cluster-1 and mycluster2, event categories = Availability, Backup, and severity = ERROR. The subscription will only send notifications for those ERROR events in the Availability and Backup categories for the specified clusters.</p> <p>If you specify both the source type and source IDs, such as source type = cluster and source identifier = my-cluster-1, notifications will be sent for all the cluster events for my-cluster-1. If you specify a source type but do not specify a source identifier, you will receive notice of the events for the objects of that type in your AWS account. If you do not specify either the SourceType nor the SourceIdentifier, you will be notified of events generated from all Amazon Redshift sources belonging to your AWS account. You must specify a source type if you specify a source ID.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   SourceType: JString
  ##             : <p>The type of source that will be generating the events. For example, if you want to be notified of events generated by a cluster, you would set this parameter to cluster. If this value is not specified, events are returned for all Amazon Redshift objects in your AWS account. You must specify a source type in order to specify source IDs.</p> <p>Valid values: cluster, cluster-parameter-group, cluster-security-group, and cluster-snapshot.</p>
  ##   SourceIds: JArray
  ##            : <p>A list of one or more identifiers of Amazon Redshift source objects. All of the objects must be of the same type as was specified in the source type parameter. The event subscription will return only events generated by the specified objects. If not specified, then events are returned for all objects within the source type specified.</p> <p>Example: my-cluster-1, my-cluster-2</p> <p>Example: my-snapshot-20131010</p>
  ##   Enabled: JBool
  ##          : A boolean value; set to <code>true</code> to activate the subscription, and set to <code>false</code> to create the subscription but not activate it. 
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Action: JString (required)
  ##   SnsTopicArn: JString (required)
  ##              : The Amazon Resource Name (ARN) of the Amazon SNS topic used to transmit the event notifications. The ARN is created by Amazon SNS when you create a topic and subscribe to it.
  ##   EventCategories: JArray
  ##                  : <p>Specifies the Amazon Redshift event categories to be published by the event notification subscription.</p> <p>Values: configuration, management, monitoring, security</p>
  ##   SubscriptionName: JString (required)
  ##                   : <p>The name of the event subscription to be created.</p> <p>Constraints:</p> <ul> <li> <p>Cannot be null, empty, or blank.</p> </li> <li> <p>Must contain from 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   Severity: JString
  ##           : <p>Specifies the Amazon Redshift event severity to be published by the event notification subscription.</p> <p>Values: ERROR, INFO</p>
  ##   Version: JString (required)
  section = newJObject()
  var valid_603543 = query.getOrDefault("SourceType")
  valid_603543 = validateParameter(valid_603543, JString, required = false,
                                 default = nil)
  if valid_603543 != nil:
    section.add "SourceType", valid_603543
  var valid_603544 = query.getOrDefault("SourceIds")
  valid_603544 = validateParameter(valid_603544, JArray, required = false,
                                 default = nil)
  if valid_603544 != nil:
    section.add "SourceIds", valid_603544
  var valid_603545 = query.getOrDefault("Enabled")
  valid_603545 = validateParameter(valid_603545, JBool, required = false, default = nil)
  if valid_603545 != nil:
    section.add "Enabled", valid_603545
  var valid_603546 = query.getOrDefault("Tags")
  valid_603546 = validateParameter(valid_603546, JArray, required = false,
                                 default = nil)
  if valid_603546 != nil:
    section.add "Tags", valid_603546
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_603547 = query.getOrDefault("Action")
  valid_603547 = validateParameter(valid_603547, JString, required = true, default = newJString(
      "CreateEventSubscription"))
  if valid_603547 != nil:
    section.add "Action", valid_603547
  var valid_603548 = query.getOrDefault("SnsTopicArn")
  valid_603548 = validateParameter(valid_603548, JString, required = true,
                                 default = nil)
  if valid_603548 != nil:
    section.add "SnsTopicArn", valid_603548
  var valid_603549 = query.getOrDefault("EventCategories")
  valid_603549 = validateParameter(valid_603549, JArray, required = false,
                                 default = nil)
  if valid_603549 != nil:
    section.add "EventCategories", valid_603549
  var valid_603550 = query.getOrDefault("SubscriptionName")
  valid_603550 = validateParameter(valid_603550, JString, required = true,
                                 default = nil)
  if valid_603550 != nil:
    section.add "SubscriptionName", valid_603550
  var valid_603551 = query.getOrDefault("Severity")
  valid_603551 = validateParameter(valid_603551, JString, required = false,
                                 default = nil)
  if valid_603551 != nil:
    section.add "Severity", valid_603551
  var valid_603552 = query.getOrDefault("Version")
  valid_603552 = validateParameter(valid_603552, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_603552 != nil:
    section.add "Version", valid_603552
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603553 = header.getOrDefault("X-Amz-Date")
  valid_603553 = validateParameter(valid_603553, JString, required = false,
                                 default = nil)
  if valid_603553 != nil:
    section.add "X-Amz-Date", valid_603553
  var valid_603554 = header.getOrDefault("X-Amz-Security-Token")
  valid_603554 = validateParameter(valid_603554, JString, required = false,
                                 default = nil)
  if valid_603554 != nil:
    section.add "X-Amz-Security-Token", valid_603554
  var valid_603555 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603555 = validateParameter(valid_603555, JString, required = false,
                                 default = nil)
  if valid_603555 != nil:
    section.add "X-Amz-Content-Sha256", valid_603555
  var valid_603556 = header.getOrDefault("X-Amz-Algorithm")
  valid_603556 = validateParameter(valid_603556, JString, required = false,
                                 default = nil)
  if valid_603556 != nil:
    section.add "X-Amz-Algorithm", valid_603556
  var valid_603557 = header.getOrDefault("X-Amz-Signature")
  valid_603557 = validateParameter(valid_603557, JString, required = false,
                                 default = nil)
  if valid_603557 != nil:
    section.add "X-Amz-Signature", valid_603557
  var valid_603558 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603558 = validateParameter(valid_603558, JString, required = false,
                                 default = nil)
  if valid_603558 != nil:
    section.add "X-Amz-SignedHeaders", valid_603558
  var valid_603559 = header.getOrDefault("X-Amz-Credential")
  valid_603559 = validateParameter(valid_603559, JString, required = false,
                                 default = nil)
  if valid_603559 != nil:
    section.add "X-Amz-Credential", valid_603559
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603560: Call_GetCreateEventSubscription_603540; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates an Amazon Redshift event notification subscription. This action requires an ARN (Amazon Resource Name) of an Amazon SNS topic created by either the Amazon Redshift console, the Amazon SNS console, or the Amazon SNS API. To obtain an ARN with Amazon SNS, you must create a topic in Amazon SNS and subscribe to the topic. The ARN is displayed in the SNS console.</p> <p>You can specify the source type, and lists of Amazon Redshift source IDs, event categories, and event severities. Notifications will be sent for all events you want that match those criteria. For example, you can specify source type = cluster, source ID = my-cluster-1 and mycluster2, event categories = Availability, Backup, and severity = ERROR. The subscription will only send notifications for those ERROR events in the Availability and Backup categories for the specified clusters.</p> <p>If you specify both the source type and source IDs, such as source type = cluster and source identifier = my-cluster-1, notifications will be sent for all the cluster events for my-cluster-1. If you specify a source type but do not specify a source identifier, you will receive notice of the events for the objects of that type in your AWS account. If you do not specify either the SourceType nor the SourceIdentifier, you will be notified of events generated from all Amazon Redshift sources belonging to your AWS account. You must specify a source type if you specify a source ID.</p>
  ## 
  let valid = call_603560.validator(path, query, header, formData, body)
  let scheme = call_603560.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603560.url(scheme.get, call_603560.host, call_603560.base,
                         call_603560.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_603560, url, valid)

proc call*(call_603561: Call_GetCreateEventSubscription_603540;
          SnsTopicArn: string; SubscriptionName: string; SourceType: string = "";
          SourceIds: JsonNode = nil; Enabled: bool = false; Tags: JsonNode = nil;
          Action: string = "CreateEventSubscription";
          EventCategories: JsonNode = nil; Severity: string = "";
          Version: string = "2012-12-01"): Recallable =
  ## getCreateEventSubscription
  ## <p>Creates an Amazon Redshift event notification subscription. This action requires an ARN (Amazon Resource Name) of an Amazon SNS topic created by either the Amazon Redshift console, the Amazon SNS console, or the Amazon SNS API. To obtain an ARN with Amazon SNS, you must create a topic in Amazon SNS and subscribe to the topic. The ARN is displayed in the SNS console.</p> <p>You can specify the source type, and lists of Amazon Redshift source IDs, event categories, and event severities. Notifications will be sent for all events you want that match those criteria. For example, you can specify source type = cluster, source ID = my-cluster-1 and mycluster2, event categories = Availability, Backup, and severity = ERROR. The subscription will only send notifications for those ERROR events in the Availability and Backup categories for the specified clusters.</p> <p>If you specify both the source type and source IDs, such as source type = cluster and source identifier = my-cluster-1, notifications will be sent for all the cluster events for my-cluster-1. If you specify a source type but do not specify a source identifier, you will receive notice of the events for the objects of that type in your AWS account. If you do not specify either the SourceType nor the SourceIdentifier, you will be notified of events generated from all Amazon Redshift sources belonging to your AWS account. You must specify a source type if you specify a source ID.</p>
  ##   SourceType: string
  ##             : <p>The type of source that will be generating the events. For example, if you want to be notified of events generated by a cluster, you would set this parameter to cluster. If this value is not specified, events are returned for all Amazon Redshift objects in your AWS account. You must specify a source type in order to specify source IDs.</p> <p>Valid values: cluster, cluster-parameter-group, cluster-security-group, and cluster-snapshot.</p>
  ##   SourceIds: JArray
  ##            : <p>A list of one or more identifiers of Amazon Redshift source objects. All of the objects must be of the same type as was specified in the source type parameter. The event subscription will return only events generated by the specified objects. If not specified, then events are returned for all objects within the source type specified.</p> <p>Example: my-cluster-1, my-cluster-2</p> <p>Example: my-snapshot-20131010</p>
  ##   Enabled: bool
  ##          : A boolean value; set to <code>true</code> to activate the subscription, and set to <code>false</code> to create the subscription but not activate it. 
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Action: string (required)
  ##   SnsTopicArn: string (required)
  ##              : The Amazon Resource Name (ARN) of the Amazon SNS topic used to transmit the event notifications. The ARN is created by Amazon SNS when you create a topic and subscribe to it.
  ##   EventCategories: JArray
  ##                  : <p>Specifies the Amazon Redshift event categories to be published by the event notification subscription.</p> <p>Values: configuration, management, monitoring, security</p>
  ##   SubscriptionName: string (required)
  ##                   : <p>The name of the event subscription to be created.</p> <p>Constraints:</p> <ul> <li> <p>Cannot be null, empty, or blank.</p> </li> <li> <p>Must contain from 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   Severity: string
  ##           : <p>Specifies the Amazon Redshift event severity to be published by the event notification subscription.</p> <p>Values: ERROR, INFO</p>
  ##   Version: string (required)
  var query_603562 = newJObject()
  add(query_603562, "SourceType", newJString(SourceType))
  if SourceIds != nil:
    query_603562.add "SourceIds", SourceIds
  add(query_603562, "Enabled", newJBool(Enabled))
  if Tags != nil:
    query_603562.add "Tags", Tags
  add(query_603562, "Action", newJString(Action))
  add(query_603562, "SnsTopicArn", newJString(SnsTopicArn))
  if EventCategories != nil:
    query_603562.add "EventCategories", EventCategories
  add(query_603562, "SubscriptionName", newJString(SubscriptionName))
  add(query_603562, "Severity", newJString(Severity))
  add(query_603562, "Version", newJString(Version))
  result = call_603561.call(nil, query_603562, nil, nil, nil)

var getCreateEventSubscription* = Call_GetCreateEventSubscription_603540(
    name: "getCreateEventSubscription", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=CreateEventSubscription",
    validator: validate_GetCreateEventSubscription_603541, base: "/",
    url: url_GetCreateEventSubscription_603542,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCreateHsmClientCertificate_603604 = ref object of OpenApiRestCall_602450
proc url_PostCreateHsmClientCertificate_603606(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostCreateHsmClientCertificate_603605(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates an HSM client certificate that an Amazon Redshift cluster will use to connect to the client's HSM in order to store and retrieve the keys used to encrypt the cluster databases.</p> <p>The command returns a public key, which you must store in the HSM. In addition to creating the HSM certificate, you must create an Amazon Redshift HSM configuration that provides a cluster the information needed to store and use encryption keys in the HSM. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a> in the Amazon Redshift Cluster Management Guide.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_603607 = query.getOrDefault("Action")
  valid_603607 = validateParameter(valid_603607, JString, required = true, default = newJString(
      "CreateHsmClientCertificate"))
  if valid_603607 != nil:
    section.add "Action", valid_603607
  var valid_603608 = query.getOrDefault("Version")
  valid_603608 = validateParameter(valid_603608, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_603608 != nil:
    section.add "Version", valid_603608
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603609 = header.getOrDefault("X-Amz-Date")
  valid_603609 = validateParameter(valid_603609, JString, required = false,
                                 default = nil)
  if valid_603609 != nil:
    section.add "X-Amz-Date", valid_603609
  var valid_603610 = header.getOrDefault("X-Amz-Security-Token")
  valid_603610 = validateParameter(valid_603610, JString, required = false,
                                 default = nil)
  if valid_603610 != nil:
    section.add "X-Amz-Security-Token", valid_603610
  var valid_603611 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603611 = validateParameter(valid_603611, JString, required = false,
                                 default = nil)
  if valid_603611 != nil:
    section.add "X-Amz-Content-Sha256", valid_603611
  var valid_603612 = header.getOrDefault("X-Amz-Algorithm")
  valid_603612 = validateParameter(valid_603612, JString, required = false,
                                 default = nil)
  if valid_603612 != nil:
    section.add "X-Amz-Algorithm", valid_603612
  var valid_603613 = header.getOrDefault("X-Amz-Signature")
  valid_603613 = validateParameter(valid_603613, JString, required = false,
                                 default = nil)
  if valid_603613 != nil:
    section.add "X-Amz-Signature", valid_603613
  var valid_603614 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603614 = validateParameter(valid_603614, JString, required = false,
                                 default = nil)
  if valid_603614 != nil:
    section.add "X-Amz-SignedHeaders", valid_603614
  var valid_603615 = header.getOrDefault("X-Amz-Credential")
  valid_603615 = validateParameter(valid_603615, JString, required = false,
                                 default = nil)
  if valid_603615 != nil:
    section.add "X-Amz-Credential", valid_603615
  result.add "header", section
  ## parameters in `formData` object:
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   HsmClientCertificateIdentifier: JString (required)
  ##                                 : The identifier to be assigned to the new HSM client certificate that the cluster will use to connect to the HSM to use the database encryption keys.
  section = newJObject()
  var valid_603616 = formData.getOrDefault("Tags")
  valid_603616 = validateParameter(valid_603616, JArray, required = false,
                                 default = nil)
  if valid_603616 != nil:
    section.add "Tags", valid_603616
  assert formData != nil, "formData argument is necessary due to required `HsmClientCertificateIdentifier` field"
  var valid_603617 = formData.getOrDefault("HsmClientCertificateIdentifier")
  valid_603617 = validateParameter(valid_603617, JString, required = true,
                                 default = nil)
  if valid_603617 != nil:
    section.add "HsmClientCertificateIdentifier", valid_603617
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603618: Call_PostCreateHsmClientCertificate_603604; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates an HSM client certificate that an Amazon Redshift cluster will use to connect to the client's HSM in order to store and retrieve the keys used to encrypt the cluster databases.</p> <p>The command returns a public key, which you must store in the HSM. In addition to creating the HSM certificate, you must create an Amazon Redshift HSM configuration that provides a cluster the information needed to store and use encryption keys in the HSM. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a> in the Amazon Redshift Cluster Management Guide.</p>
  ## 
  let valid = call_603618.validator(path, query, header, formData, body)
  let scheme = call_603618.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603618.url(scheme.get, call_603618.host, call_603618.base,
                         call_603618.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_603618, url, valid)

proc call*(call_603619: Call_PostCreateHsmClientCertificate_603604;
          HsmClientCertificateIdentifier: string; Tags: JsonNode = nil;
          Action: string = "CreateHsmClientCertificate";
          Version: string = "2012-12-01"): Recallable =
  ## postCreateHsmClientCertificate
  ## <p>Creates an HSM client certificate that an Amazon Redshift cluster will use to connect to the client's HSM in order to store and retrieve the keys used to encrypt the cluster databases.</p> <p>The command returns a public key, which you must store in the HSM. In addition to creating the HSM certificate, you must create an Amazon Redshift HSM configuration that provides a cluster the information needed to store and use encryption keys in the HSM. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a> in the Amazon Redshift Cluster Management Guide.</p>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Action: string (required)
  ##   HsmClientCertificateIdentifier: string (required)
  ##                                 : The identifier to be assigned to the new HSM client certificate that the cluster will use to connect to the HSM to use the database encryption keys.
  ##   Version: string (required)
  var query_603620 = newJObject()
  var formData_603621 = newJObject()
  if Tags != nil:
    formData_603621.add "Tags", Tags
  add(query_603620, "Action", newJString(Action))
  add(formData_603621, "HsmClientCertificateIdentifier",
      newJString(HsmClientCertificateIdentifier))
  add(query_603620, "Version", newJString(Version))
  result = call_603619.call(nil, query_603620, nil, formData_603621, nil)

var postCreateHsmClientCertificate* = Call_PostCreateHsmClientCertificate_603604(
    name: "postCreateHsmClientCertificate", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=CreateHsmClientCertificate",
    validator: validate_PostCreateHsmClientCertificate_603605, base: "/",
    url: url_PostCreateHsmClientCertificate_603606,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCreateHsmClientCertificate_603587 = ref object of OpenApiRestCall_602450
proc url_GetCreateHsmClientCertificate_603589(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetCreateHsmClientCertificate_603588(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates an HSM client certificate that an Amazon Redshift cluster will use to connect to the client's HSM in order to store and retrieve the keys used to encrypt the cluster databases.</p> <p>The command returns a public key, which you must store in the HSM. In addition to creating the HSM certificate, you must create an Amazon Redshift HSM configuration that provides a cluster the information needed to store and use encryption keys in the HSM. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a> in the Amazon Redshift Cluster Management Guide.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   HsmClientCertificateIdentifier: JString (required)
  ##                                 : The identifier to be assigned to the new HSM client certificate that the cluster will use to connect to the HSM to use the database encryption keys.
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `HsmClientCertificateIdentifier` field"
  var valid_603590 = query.getOrDefault("HsmClientCertificateIdentifier")
  valid_603590 = validateParameter(valid_603590, JString, required = true,
                                 default = nil)
  if valid_603590 != nil:
    section.add "HsmClientCertificateIdentifier", valid_603590
  var valid_603591 = query.getOrDefault("Tags")
  valid_603591 = validateParameter(valid_603591, JArray, required = false,
                                 default = nil)
  if valid_603591 != nil:
    section.add "Tags", valid_603591
  var valid_603592 = query.getOrDefault("Action")
  valid_603592 = validateParameter(valid_603592, JString, required = true, default = newJString(
      "CreateHsmClientCertificate"))
  if valid_603592 != nil:
    section.add "Action", valid_603592
  var valid_603593 = query.getOrDefault("Version")
  valid_603593 = validateParameter(valid_603593, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_603593 != nil:
    section.add "Version", valid_603593
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603594 = header.getOrDefault("X-Amz-Date")
  valid_603594 = validateParameter(valid_603594, JString, required = false,
                                 default = nil)
  if valid_603594 != nil:
    section.add "X-Amz-Date", valid_603594
  var valid_603595 = header.getOrDefault("X-Amz-Security-Token")
  valid_603595 = validateParameter(valid_603595, JString, required = false,
                                 default = nil)
  if valid_603595 != nil:
    section.add "X-Amz-Security-Token", valid_603595
  var valid_603596 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603596 = validateParameter(valid_603596, JString, required = false,
                                 default = nil)
  if valid_603596 != nil:
    section.add "X-Amz-Content-Sha256", valid_603596
  var valid_603597 = header.getOrDefault("X-Amz-Algorithm")
  valid_603597 = validateParameter(valid_603597, JString, required = false,
                                 default = nil)
  if valid_603597 != nil:
    section.add "X-Amz-Algorithm", valid_603597
  var valid_603598 = header.getOrDefault("X-Amz-Signature")
  valid_603598 = validateParameter(valid_603598, JString, required = false,
                                 default = nil)
  if valid_603598 != nil:
    section.add "X-Amz-Signature", valid_603598
  var valid_603599 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603599 = validateParameter(valid_603599, JString, required = false,
                                 default = nil)
  if valid_603599 != nil:
    section.add "X-Amz-SignedHeaders", valid_603599
  var valid_603600 = header.getOrDefault("X-Amz-Credential")
  valid_603600 = validateParameter(valid_603600, JString, required = false,
                                 default = nil)
  if valid_603600 != nil:
    section.add "X-Amz-Credential", valid_603600
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603601: Call_GetCreateHsmClientCertificate_603587; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates an HSM client certificate that an Amazon Redshift cluster will use to connect to the client's HSM in order to store and retrieve the keys used to encrypt the cluster databases.</p> <p>The command returns a public key, which you must store in the HSM. In addition to creating the HSM certificate, you must create an Amazon Redshift HSM configuration that provides a cluster the information needed to store and use encryption keys in the HSM. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a> in the Amazon Redshift Cluster Management Guide.</p>
  ## 
  let valid = call_603601.validator(path, query, header, formData, body)
  let scheme = call_603601.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603601.url(scheme.get, call_603601.host, call_603601.base,
                         call_603601.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_603601, url, valid)

proc call*(call_603602: Call_GetCreateHsmClientCertificate_603587;
          HsmClientCertificateIdentifier: string; Tags: JsonNode = nil;
          Action: string = "CreateHsmClientCertificate";
          Version: string = "2012-12-01"): Recallable =
  ## getCreateHsmClientCertificate
  ## <p>Creates an HSM client certificate that an Amazon Redshift cluster will use to connect to the client's HSM in order to store and retrieve the keys used to encrypt the cluster databases.</p> <p>The command returns a public key, which you must store in the HSM. In addition to creating the HSM certificate, you must create an Amazon Redshift HSM configuration that provides a cluster the information needed to store and use encryption keys in the HSM. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a> in the Amazon Redshift Cluster Management Guide.</p>
  ##   HsmClientCertificateIdentifier: string (required)
  ##                                 : The identifier to be assigned to the new HSM client certificate that the cluster will use to connect to the HSM to use the database encryption keys.
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_603603 = newJObject()
  add(query_603603, "HsmClientCertificateIdentifier",
      newJString(HsmClientCertificateIdentifier))
  if Tags != nil:
    query_603603.add "Tags", Tags
  add(query_603603, "Action", newJString(Action))
  add(query_603603, "Version", newJString(Version))
  result = call_603602.call(nil, query_603603, nil, nil, nil)

var getCreateHsmClientCertificate* = Call_GetCreateHsmClientCertificate_603587(
    name: "getCreateHsmClientCertificate", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=CreateHsmClientCertificate",
    validator: validate_GetCreateHsmClientCertificate_603588, base: "/",
    url: url_GetCreateHsmClientCertificate_603589,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCreateHsmConfiguration_603644 = ref object of OpenApiRestCall_602450
proc url_PostCreateHsmConfiguration_603646(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostCreateHsmConfiguration_603645(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates an HSM configuration that contains the information required by an Amazon Redshift cluster to store and use database encryption keys in a Hardware Security Module (HSM). After creating the HSM configuration, you can specify it as a parameter when creating a cluster. The cluster will then store its encryption keys in the HSM.</p> <p>In addition to creating an HSM configuration, you must also create an HSM client certificate. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a> in the Amazon Redshift Cluster Management Guide.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_603647 = query.getOrDefault("Action")
  valid_603647 = validateParameter(valid_603647, JString, required = true,
                                 default = newJString("CreateHsmConfiguration"))
  if valid_603647 != nil:
    section.add "Action", valid_603647
  var valid_603648 = query.getOrDefault("Version")
  valid_603648 = validateParameter(valid_603648, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_603648 != nil:
    section.add "Version", valid_603648
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603649 = header.getOrDefault("X-Amz-Date")
  valid_603649 = validateParameter(valid_603649, JString, required = false,
                                 default = nil)
  if valid_603649 != nil:
    section.add "X-Amz-Date", valid_603649
  var valid_603650 = header.getOrDefault("X-Amz-Security-Token")
  valid_603650 = validateParameter(valid_603650, JString, required = false,
                                 default = nil)
  if valid_603650 != nil:
    section.add "X-Amz-Security-Token", valid_603650
  var valid_603651 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603651 = validateParameter(valid_603651, JString, required = false,
                                 default = nil)
  if valid_603651 != nil:
    section.add "X-Amz-Content-Sha256", valid_603651
  var valid_603652 = header.getOrDefault("X-Amz-Algorithm")
  valid_603652 = validateParameter(valid_603652, JString, required = false,
                                 default = nil)
  if valid_603652 != nil:
    section.add "X-Amz-Algorithm", valid_603652
  var valid_603653 = header.getOrDefault("X-Amz-Signature")
  valid_603653 = validateParameter(valid_603653, JString, required = false,
                                 default = nil)
  if valid_603653 != nil:
    section.add "X-Amz-Signature", valid_603653
  var valid_603654 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603654 = validateParameter(valid_603654, JString, required = false,
                                 default = nil)
  if valid_603654 != nil:
    section.add "X-Amz-SignedHeaders", valid_603654
  var valid_603655 = header.getOrDefault("X-Amz-Credential")
  valid_603655 = validateParameter(valid_603655, JString, required = false,
                                 default = nil)
  if valid_603655 != nil:
    section.add "X-Amz-Credential", valid_603655
  result.add "header", section
  ## parameters in `formData` object:
  ##   HsmIpAddress: JString (required)
  ##               : The IP address that the Amazon Redshift cluster must use to access the HSM.
  ##   HsmPartitionName: JString (required)
  ##                   : The name of the partition in the HSM where the Amazon Redshift clusters will store their database encryption keys.
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   HsmPartitionPassword: JString (required)
  ##                       : The password required to access the HSM partition.
  ##   HsmConfigurationIdentifier: JString (required)
  ##                             : The identifier to be assigned to the new Amazon Redshift HSM configuration.
  ##   HsmServerPublicCertificate: JString (required)
  ##                             : The HSMs public certificate file. When using Cloud HSM, the file name is server.pem.
  ##   Description: JString (required)
  ##              : A text description of the HSM configuration to be created.
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `HsmIpAddress` field"
  var valid_603656 = formData.getOrDefault("HsmIpAddress")
  valid_603656 = validateParameter(valid_603656, JString, required = true,
                                 default = nil)
  if valid_603656 != nil:
    section.add "HsmIpAddress", valid_603656
  var valid_603657 = formData.getOrDefault("HsmPartitionName")
  valid_603657 = validateParameter(valid_603657, JString, required = true,
                                 default = nil)
  if valid_603657 != nil:
    section.add "HsmPartitionName", valid_603657
  var valid_603658 = formData.getOrDefault("Tags")
  valid_603658 = validateParameter(valid_603658, JArray, required = false,
                                 default = nil)
  if valid_603658 != nil:
    section.add "Tags", valid_603658
  var valid_603659 = formData.getOrDefault("HsmPartitionPassword")
  valid_603659 = validateParameter(valid_603659, JString, required = true,
                                 default = nil)
  if valid_603659 != nil:
    section.add "HsmPartitionPassword", valid_603659
  var valid_603660 = formData.getOrDefault("HsmConfigurationIdentifier")
  valid_603660 = validateParameter(valid_603660, JString, required = true,
                                 default = nil)
  if valid_603660 != nil:
    section.add "HsmConfigurationIdentifier", valid_603660
  var valid_603661 = formData.getOrDefault("HsmServerPublicCertificate")
  valid_603661 = validateParameter(valid_603661, JString, required = true,
                                 default = nil)
  if valid_603661 != nil:
    section.add "HsmServerPublicCertificate", valid_603661
  var valid_603662 = formData.getOrDefault("Description")
  valid_603662 = validateParameter(valid_603662, JString, required = true,
                                 default = nil)
  if valid_603662 != nil:
    section.add "Description", valid_603662
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603663: Call_PostCreateHsmConfiguration_603644; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates an HSM configuration that contains the information required by an Amazon Redshift cluster to store and use database encryption keys in a Hardware Security Module (HSM). After creating the HSM configuration, you can specify it as a parameter when creating a cluster. The cluster will then store its encryption keys in the HSM.</p> <p>In addition to creating an HSM configuration, you must also create an HSM client certificate. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a> in the Amazon Redshift Cluster Management Guide.</p>
  ## 
  let valid = call_603663.validator(path, query, header, formData, body)
  let scheme = call_603663.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603663.url(scheme.get, call_603663.host, call_603663.base,
                         call_603663.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_603663, url, valid)

proc call*(call_603664: Call_PostCreateHsmConfiguration_603644;
          HsmIpAddress: string; HsmPartitionName: string;
          HsmPartitionPassword: string; HsmConfigurationIdentifier: string;
          HsmServerPublicCertificate: string; Description: string;
          Tags: JsonNode = nil; Action: string = "CreateHsmConfiguration";
          Version: string = "2012-12-01"): Recallable =
  ## postCreateHsmConfiguration
  ## <p>Creates an HSM configuration that contains the information required by an Amazon Redshift cluster to store and use database encryption keys in a Hardware Security Module (HSM). After creating the HSM configuration, you can specify it as a parameter when creating a cluster. The cluster will then store its encryption keys in the HSM.</p> <p>In addition to creating an HSM configuration, you must also create an HSM client certificate. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a> in the Amazon Redshift Cluster Management Guide.</p>
  ##   HsmIpAddress: string (required)
  ##               : The IP address that the Amazon Redshift cluster must use to access the HSM.
  ##   HsmPartitionName: string (required)
  ##                   : The name of the partition in the HSM where the Amazon Redshift clusters will store their database encryption keys.
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   HsmPartitionPassword: string (required)
  ##                       : The password required to access the HSM partition.
  ##   HsmConfigurationIdentifier: string (required)
  ##                             : The identifier to be assigned to the new Amazon Redshift HSM configuration.
  ##   Action: string (required)
  ##   HsmServerPublicCertificate: string (required)
  ##                             : The HSMs public certificate file. When using Cloud HSM, the file name is server.pem.
  ##   Version: string (required)
  ##   Description: string (required)
  ##              : A text description of the HSM configuration to be created.
  var query_603665 = newJObject()
  var formData_603666 = newJObject()
  add(formData_603666, "HsmIpAddress", newJString(HsmIpAddress))
  add(formData_603666, "HsmPartitionName", newJString(HsmPartitionName))
  if Tags != nil:
    formData_603666.add "Tags", Tags
  add(formData_603666, "HsmPartitionPassword", newJString(HsmPartitionPassword))
  add(formData_603666, "HsmConfigurationIdentifier",
      newJString(HsmConfigurationIdentifier))
  add(query_603665, "Action", newJString(Action))
  add(formData_603666, "HsmServerPublicCertificate",
      newJString(HsmServerPublicCertificate))
  add(query_603665, "Version", newJString(Version))
  add(formData_603666, "Description", newJString(Description))
  result = call_603664.call(nil, query_603665, nil, formData_603666, nil)

var postCreateHsmConfiguration* = Call_PostCreateHsmConfiguration_603644(
    name: "postCreateHsmConfiguration", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=CreateHsmConfiguration",
    validator: validate_PostCreateHsmConfiguration_603645, base: "/",
    url: url_PostCreateHsmConfiguration_603646,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCreateHsmConfiguration_603622 = ref object of OpenApiRestCall_602450
proc url_GetCreateHsmConfiguration_603624(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetCreateHsmConfiguration_603623(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates an HSM configuration that contains the information required by an Amazon Redshift cluster to store and use database encryption keys in a Hardware Security Module (HSM). After creating the HSM configuration, you can specify it as a parameter when creating a cluster. The cluster will then store its encryption keys in the HSM.</p> <p>In addition to creating an HSM configuration, you must also create an HSM client certificate. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a> in the Amazon Redshift Cluster Management Guide.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   HsmPartitionPassword: JString (required)
  ##                       : The password required to access the HSM partition.
  ##   Description: JString (required)
  ##              : A text description of the HSM configuration to be created.
  ##   HsmPartitionName: JString (required)
  ##                   : The name of the partition in the HSM where the Amazon Redshift clusters will store their database encryption keys.
  ##   HsmConfigurationIdentifier: JString (required)
  ##                             : The identifier to be assigned to the new Amazon Redshift HSM configuration.
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Action: JString (required)
  ##   HsmServerPublicCertificate: JString (required)
  ##                             : The HSMs public certificate file. When using Cloud HSM, the file name is server.pem.
  ##   HsmIpAddress: JString (required)
  ##               : The IP address that the Amazon Redshift cluster must use to access the HSM.
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `HsmPartitionPassword` field"
  var valid_603625 = query.getOrDefault("HsmPartitionPassword")
  valid_603625 = validateParameter(valid_603625, JString, required = true,
                                 default = nil)
  if valid_603625 != nil:
    section.add "HsmPartitionPassword", valid_603625
  var valid_603626 = query.getOrDefault("Description")
  valid_603626 = validateParameter(valid_603626, JString, required = true,
                                 default = nil)
  if valid_603626 != nil:
    section.add "Description", valid_603626
  var valid_603627 = query.getOrDefault("HsmPartitionName")
  valid_603627 = validateParameter(valid_603627, JString, required = true,
                                 default = nil)
  if valid_603627 != nil:
    section.add "HsmPartitionName", valid_603627
  var valid_603628 = query.getOrDefault("HsmConfigurationIdentifier")
  valid_603628 = validateParameter(valid_603628, JString, required = true,
                                 default = nil)
  if valid_603628 != nil:
    section.add "HsmConfigurationIdentifier", valid_603628
  var valid_603629 = query.getOrDefault("Tags")
  valid_603629 = validateParameter(valid_603629, JArray, required = false,
                                 default = nil)
  if valid_603629 != nil:
    section.add "Tags", valid_603629
  var valid_603630 = query.getOrDefault("Action")
  valid_603630 = validateParameter(valid_603630, JString, required = true,
                                 default = newJString("CreateHsmConfiguration"))
  if valid_603630 != nil:
    section.add "Action", valid_603630
  var valid_603631 = query.getOrDefault("HsmServerPublicCertificate")
  valid_603631 = validateParameter(valid_603631, JString, required = true,
                                 default = nil)
  if valid_603631 != nil:
    section.add "HsmServerPublicCertificate", valid_603631
  var valid_603632 = query.getOrDefault("HsmIpAddress")
  valid_603632 = validateParameter(valid_603632, JString, required = true,
                                 default = nil)
  if valid_603632 != nil:
    section.add "HsmIpAddress", valid_603632
  var valid_603633 = query.getOrDefault("Version")
  valid_603633 = validateParameter(valid_603633, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_603633 != nil:
    section.add "Version", valid_603633
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603634 = header.getOrDefault("X-Amz-Date")
  valid_603634 = validateParameter(valid_603634, JString, required = false,
                                 default = nil)
  if valid_603634 != nil:
    section.add "X-Amz-Date", valid_603634
  var valid_603635 = header.getOrDefault("X-Amz-Security-Token")
  valid_603635 = validateParameter(valid_603635, JString, required = false,
                                 default = nil)
  if valid_603635 != nil:
    section.add "X-Amz-Security-Token", valid_603635
  var valid_603636 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603636 = validateParameter(valid_603636, JString, required = false,
                                 default = nil)
  if valid_603636 != nil:
    section.add "X-Amz-Content-Sha256", valid_603636
  var valid_603637 = header.getOrDefault("X-Amz-Algorithm")
  valid_603637 = validateParameter(valid_603637, JString, required = false,
                                 default = nil)
  if valid_603637 != nil:
    section.add "X-Amz-Algorithm", valid_603637
  var valid_603638 = header.getOrDefault("X-Amz-Signature")
  valid_603638 = validateParameter(valid_603638, JString, required = false,
                                 default = nil)
  if valid_603638 != nil:
    section.add "X-Amz-Signature", valid_603638
  var valid_603639 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603639 = validateParameter(valid_603639, JString, required = false,
                                 default = nil)
  if valid_603639 != nil:
    section.add "X-Amz-SignedHeaders", valid_603639
  var valid_603640 = header.getOrDefault("X-Amz-Credential")
  valid_603640 = validateParameter(valid_603640, JString, required = false,
                                 default = nil)
  if valid_603640 != nil:
    section.add "X-Amz-Credential", valid_603640
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603641: Call_GetCreateHsmConfiguration_603622; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates an HSM configuration that contains the information required by an Amazon Redshift cluster to store and use database encryption keys in a Hardware Security Module (HSM). After creating the HSM configuration, you can specify it as a parameter when creating a cluster. The cluster will then store its encryption keys in the HSM.</p> <p>In addition to creating an HSM configuration, you must also create an HSM client certificate. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a> in the Amazon Redshift Cluster Management Guide.</p>
  ## 
  let valid = call_603641.validator(path, query, header, formData, body)
  let scheme = call_603641.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603641.url(scheme.get, call_603641.host, call_603641.base,
                         call_603641.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_603641, url, valid)

proc call*(call_603642: Call_GetCreateHsmConfiguration_603622;
          HsmPartitionPassword: string; Description: string;
          HsmPartitionName: string; HsmConfigurationIdentifier: string;
          HsmServerPublicCertificate: string; HsmIpAddress: string;
          Tags: JsonNode = nil; Action: string = "CreateHsmConfiguration";
          Version: string = "2012-12-01"): Recallable =
  ## getCreateHsmConfiguration
  ## <p>Creates an HSM configuration that contains the information required by an Amazon Redshift cluster to store and use database encryption keys in a Hardware Security Module (HSM). After creating the HSM configuration, you can specify it as a parameter when creating a cluster. The cluster will then store its encryption keys in the HSM.</p> <p>In addition to creating an HSM configuration, you must also create an HSM client certificate. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a> in the Amazon Redshift Cluster Management Guide.</p>
  ##   HsmPartitionPassword: string (required)
  ##                       : The password required to access the HSM partition.
  ##   Description: string (required)
  ##              : A text description of the HSM configuration to be created.
  ##   HsmPartitionName: string (required)
  ##                   : The name of the partition in the HSM where the Amazon Redshift clusters will store their database encryption keys.
  ##   HsmConfigurationIdentifier: string (required)
  ##                             : The identifier to be assigned to the new Amazon Redshift HSM configuration.
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Action: string (required)
  ##   HsmServerPublicCertificate: string (required)
  ##                             : The HSMs public certificate file. When using Cloud HSM, the file name is server.pem.
  ##   HsmIpAddress: string (required)
  ##               : The IP address that the Amazon Redshift cluster must use to access the HSM.
  ##   Version: string (required)
  var query_603643 = newJObject()
  add(query_603643, "HsmPartitionPassword", newJString(HsmPartitionPassword))
  add(query_603643, "Description", newJString(Description))
  add(query_603643, "HsmPartitionName", newJString(HsmPartitionName))
  add(query_603643, "HsmConfigurationIdentifier",
      newJString(HsmConfigurationIdentifier))
  if Tags != nil:
    query_603643.add "Tags", Tags
  add(query_603643, "Action", newJString(Action))
  add(query_603643, "HsmServerPublicCertificate",
      newJString(HsmServerPublicCertificate))
  add(query_603643, "HsmIpAddress", newJString(HsmIpAddress))
  add(query_603643, "Version", newJString(Version))
  result = call_603642.call(nil, query_603643, nil, nil, nil)

var getCreateHsmConfiguration* = Call_GetCreateHsmConfiguration_603622(
    name: "getCreateHsmConfiguration", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=CreateHsmConfiguration",
    validator: validate_GetCreateHsmConfiguration_603623, base: "/",
    url: url_GetCreateHsmConfiguration_603624,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCreateSnapshotCopyGrant_603685 = ref object of OpenApiRestCall_602450
proc url_PostCreateSnapshotCopyGrant_603687(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostCreateSnapshotCopyGrant_603686(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a snapshot copy grant that permits Amazon Redshift to use a customer master key (CMK) from AWS Key Management Service (AWS KMS) to encrypt copied snapshots in a destination region.</p> <p> For more information about managing snapshot copy grants, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_603688 = query.getOrDefault("Action")
  valid_603688 = validateParameter(valid_603688, JString, required = true, default = newJString(
      "CreateSnapshotCopyGrant"))
  if valid_603688 != nil:
    section.add "Action", valid_603688
  var valid_603689 = query.getOrDefault("Version")
  valid_603689 = validateParameter(valid_603689, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_603689 != nil:
    section.add "Version", valid_603689
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603690 = header.getOrDefault("X-Amz-Date")
  valid_603690 = validateParameter(valid_603690, JString, required = false,
                                 default = nil)
  if valid_603690 != nil:
    section.add "X-Amz-Date", valid_603690
  var valid_603691 = header.getOrDefault("X-Amz-Security-Token")
  valid_603691 = validateParameter(valid_603691, JString, required = false,
                                 default = nil)
  if valid_603691 != nil:
    section.add "X-Amz-Security-Token", valid_603691
  var valid_603692 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603692 = validateParameter(valid_603692, JString, required = false,
                                 default = nil)
  if valid_603692 != nil:
    section.add "X-Amz-Content-Sha256", valid_603692
  var valid_603693 = header.getOrDefault("X-Amz-Algorithm")
  valid_603693 = validateParameter(valid_603693, JString, required = false,
                                 default = nil)
  if valid_603693 != nil:
    section.add "X-Amz-Algorithm", valid_603693
  var valid_603694 = header.getOrDefault("X-Amz-Signature")
  valid_603694 = validateParameter(valid_603694, JString, required = false,
                                 default = nil)
  if valid_603694 != nil:
    section.add "X-Amz-Signature", valid_603694
  var valid_603695 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603695 = validateParameter(valid_603695, JString, required = false,
                                 default = nil)
  if valid_603695 != nil:
    section.add "X-Amz-SignedHeaders", valid_603695
  var valid_603696 = header.getOrDefault("X-Amz-Credential")
  valid_603696 = validateParameter(valid_603696, JString, required = false,
                                 default = nil)
  if valid_603696 != nil:
    section.add "X-Amz-Credential", valid_603696
  result.add "header", section
  ## parameters in `formData` object:
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   SnapshotCopyGrantName: JString (required)
  ##                        : <p>The name of the snapshot copy grant. This name must be unique in the region for the AWS account.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul>
  ##   KmsKeyId: JString
  ##           : The unique identifier of the customer master key (CMK) to which to grant Amazon Redshift permission. If no key is specified, the default key is used.
  section = newJObject()
  var valid_603697 = formData.getOrDefault("Tags")
  valid_603697 = validateParameter(valid_603697, JArray, required = false,
                                 default = nil)
  if valid_603697 != nil:
    section.add "Tags", valid_603697
  assert formData != nil, "formData argument is necessary due to required `SnapshotCopyGrantName` field"
  var valid_603698 = formData.getOrDefault("SnapshotCopyGrantName")
  valid_603698 = validateParameter(valid_603698, JString, required = true,
                                 default = nil)
  if valid_603698 != nil:
    section.add "SnapshotCopyGrantName", valid_603698
  var valid_603699 = formData.getOrDefault("KmsKeyId")
  valid_603699 = validateParameter(valid_603699, JString, required = false,
                                 default = nil)
  if valid_603699 != nil:
    section.add "KmsKeyId", valid_603699
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603700: Call_PostCreateSnapshotCopyGrant_603685; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a snapshot copy grant that permits Amazon Redshift to use a customer master key (CMK) from AWS Key Management Service (AWS KMS) to encrypt copied snapshots in a destination region.</p> <p> For more information about managing snapshot copy grants, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ## 
  let valid = call_603700.validator(path, query, header, formData, body)
  let scheme = call_603700.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603700.url(scheme.get, call_603700.host, call_603700.base,
                         call_603700.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_603700, url, valid)

proc call*(call_603701: Call_PostCreateSnapshotCopyGrant_603685;
          SnapshotCopyGrantName: string; Tags: JsonNode = nil;
          Action: string = "CreateSnapshotCopyGrant"; KmsKeyId: string = "";
          Version: string = "2012-12-01"): Recallable =
  ## postCreateSnapshotCopyGrant
  ## <p>Creates a snapshot copy grant that permits Amazon Redshift to use a customer master key (CMK) from AWS Key Management Service (AWS KMS) to encrypt copied snapshots in a destination region.</p> <p> For more information about managing snapshot copy grants, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Action: string (required)
  ##   SnapshotCopyGrantName: string (required)
  ##                        : <p>The name of the snapshot copy grant. This name must be unique in the region for the AWS account.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul>
  ##   KmsKeyId: string
  ##           : The unique identifier of the customer master key (CMK) to which to grant Amazon Redshift permission. If no key is specified, the default key is used.
  ##   Version: string (required)
  var query_603702 = newJObject()
  var formData_603703 = newJObject()
  if Tags != nil:
    formData_603703.add "Tags", Tags
  add(query_603702, "Action", newJString(Action))
  add(formData_603703, "SnapshotCopyGrantName", newJString(SnapshotCopyGrantName))
  add(formData_603703, "KmsKeyId", newJString(KmsKeyId))
  add(query_603702, "Version", newJString(Version))
  result = call_603701.call(nil, query_603702, nil, formData_603703, nil)

var postCreateSnapshotCopyGrant* = Call_PostCreateSnapshotCopyGrant_603685(
    name: "postCreateSnapshotCopyGrant", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=CreateSnapshotCopyGrant",
    validator: validate_PostCreateSnapshotCopyGrant_603686, base: "/",
    url: url_PostCreateSnapshotCopyGrant_603687,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCreateSnapshotCopyGrant_603667 = ref object of OpenApiRestCall_602450
proc url_GetCreateSnapshotCopyGrant_603669(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetCreateSnapshotCopyGrant_603668(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a snapshot copy grant that permits Amazon Redshift to use a customer master key (CMK) from AWS Key Management Service (AWS KMS) to encrypt copied snapshots in a destination region.</p> <p> For more information about managing snapshot copy grants, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Action: JString (required)
  ##   KmsKeyId: JString
  ##           : The unique identifier of the customer master key (CMK) to which to grant Amazon Redshift permission. If no key is specified, the default key is used.
  ##   SnapshotCopyGrantName: JString (required)
  ##                        : <p>The name of the snapshot copy grant. This name must be unique in the region for the AWS account.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul>
  ##   Version: JString (required)
  section = newJObject()
  var valid_603670 = query.getOrDefault("Tags")
  valid_603670 = validateParameter(valid_603670, JArray, required = false,
                                 default = nil)
  if valid_603670 != nil:
    section.add "Tags", valid_603670
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_603671 = query.getOrDefault("Action")
  valid_603671 = validateParameter(valid_603671, JString, required = true, default = newJString(
      "CreateSnapshotCopyGrant"))
  if valid_603671 != nil:
    section.add "Action", valid_603671
  var valid_603672 = query.getOrDefault("KmsKeyId")
  valid_603672 = validateParameter(valid_603672, JString, required = false,
                                 default = nil)
  if valid_603672 != nil:
    section.add "KmsKeyId", valid_603672
  var valid_603673 = query.getOrDefault("SnapshotCopyGrantName")
  valid_603673 = validateParameter(valid_603673, JString, required = true,
                                 default = nil)
  if valid_603673 != nil:
    section.add "SnapshotCopyGrantName", valid_603673
  var valid_603674 = query.getOrDefault("Version")
  valid_603674 = validateParameter(valid_603674, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_603674 != nil:
    section.add "Version", valid_603674
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603675 = header.getOrDefault("X-Amz-Date")
  valid_603675 = validateParameter(valid_603675, JString, required = false,
                                 default = nil)
  if valid_603675 != nil:
    section.add "X-Amz-Date", valid_603675
  var valid_603676 = header.getOrDefault("X-Amz-Security-Token")
  valid_603676 = validateParameter(valid_603676, JString, required = false,
                                 default = nil)
  if valid_603676 != nil:
    section.add "X-Amz-Security-Token", valid_603676
  var valid_603677 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603677 = validateParameter(valid_603677, JString, required = false,
                                 default = nil)
  if valid_603677 != nil:
    section.add "X-Amz-Content-Sha256", valid_603677
  var valid_603678 = header.getOrDefault("X-Amz-Algorithm")
  valid_603678 = validateParameter(valid_603678, JString, required = false,
                                 default = nil)
  if valid_603678 != nil:
    section.add "X-Amz-Algorithm", valid_603678
  var valid_603679 = header.getOrDefault("X-Amz-Signature")
  valid_603679 = validateParameter(valid_603679, JString, required = false,
                                 default = nil)
  if valid_603679 != nil:
    section.add "X-Amz-Signature", valid_603679
  var valid_603680 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603680 = validateParameter(valid_603680, JString, required = false,
                                 default = nil)
  if valid_603680 != nil:
    section.add "X-Amz-SignedHeaders", valid_603680
  var valid_603681 = header.getOrDefault("X-Amz-Credential")
  valid_603681 = validateParameter(valid_603681, JString, required = false,
                                 default = nil)
  if valid_603681 != nil:
    section.add "X-Amz-Credential", valid_603681
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603682: Call_GetCreateSnapshotCopyGrant_603667; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a snapshot copy grant that permits Amazon Redshift to use a customer master key (CMK) from AWS Key Management Service (AWS KMS) to encrypt copied snapshots in a destination region.</p> <p> For more information about managing snapshot copy grants, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ## 
  let valid = call_603682.validator(path, query, header, formData, body)
  let scheme = call_603682.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603682.url(scheme.get, call_603682.host, call_603682.base,
                         call_603682.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_603682, url, valid)

proc call*(call_603683: Call_GetCreateSnapshotCopyGrant_603667;
          SnapshotCopyGrantName: string; Tags: JsonNode = nil;
          Action: string = "CreateSnapshotCopyGrant"; KmsKeyId: string = "";
          Version: string = "2012-12-01"): Recallable =
  ## getCreateSnapshotCopyGrant
  ## <p>Creates a snapshot copy grant that permits Amazon Redshift to use a customer master key (CMK) from AWS Key Management Service (AWS KMS) to encrypt copied snapshots in a destination region.</p> <p> For more information about managing snapshot copy grants, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Action: string (required)
  ##   KmsKeyId: string
  ##           : The unique identifier of the customer master key (CMK) to which to grant Amazon Redshift permission. If no key is specified, the default key is used.
  ##   SnapshotCopyGrantName: string (required)
  ##                        : <p>The name of the snapshot copy grant. This name must be unique in the region for the AWS account.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul>
  ##   Version: string (required)
  var query_603684 = newJObject()
  if Tags != nil:
    query_603684.add "Tags", Tags
  add(query_603684, "Action", newJString(Action))
  add(query_603684, "KmsKeyId", newJString(KmsKeyId))
  add(query_603684, "SnapshotCopyGrantName", newJString(SnapshotCopyGrantName))
  add(query_603684, "Version", newJString(Version))
  result = call_603683.call(nil, query_603684, nil, nil, nil)

var getCreateSnapshotCopyGrant* = Call_GetCreateSnapshotCopyGrant_603667(
    name: "getCreateSnapshotCopyGrant", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=CreateSnapshotCopyGrant",
    validator: validate_GetCreateSnapshotCopyGrant_603668, base: "/",
    url: url_GetCreateSnapshotCopyGrant_603669,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCreateSnapshotSchedule_603725 = ref object of OpenApiRestCall_602450
proc url_PostCreateSnapshotSchedule_603727(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostCreateSnapshotSchedule_603726(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Creates a new snapshot schedule.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_603728 = query.getOrDefault("Action")
  valid_603728 = validateParameter(valid_603728, JString, required = true,
                                 default = newJString("CreateSnapshotSchedule"))
  if valid_603728 != nil:
    section.add "Action", valid_603728
  var valid_603729 = query.getOrDefault("Version")
  valid_603729 = validateParameter(valid_603729, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_603729 != nil:
    section.add "Version", valid_603729
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603730 = header.getOrDefault("X-Amz-Date")
  valid_603730 = validateParameter(valid_603730, JString, required = false,
                                 default = nil)
  if valid_603730 != nil:
    section.add "X-Amz-Date", valid_603730
  var valid_603731 = header.getOrDefault("X-Amz-Security-Token")
  valid_603731 = validateParameter(valid_603731, JString, required = false,
                                 default = nil)
  if valid_603731 != nil:
    section.add "X-Amz-Security-Token", valid_603731
  var valid_603732 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603732 = validateParameter(valid_603732, JString, required = false,
                                 default = nil)
  if valid_603732 != nil:
    section.add "X-Amz-Content-Sha256", valid_603732
  var valid_603733 = header.getOrDefault("X-Amz-Algorithm")
  valid_603733 = validateParameter(valid_603733, JString, required = false,
                                 default = nil)
  if valid_603733 != nil:
    section.add "X-Amz-Algorithm", valid_603733
  var valid_603734 = header.getOrDefault("X-Amz-Signature")
  valid_603734 = validateParameter(valid_603734, JString, required = false,
                                 default = nil)
  if valid_603734 != nil:
    section.add "X-Amz-Signature", valid_603734
  var valid_603735 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603735 = validateParameter(valid_603735, JString, required = false,
                                 default = nil)
  if valid_603735 != nil:
    section.add "X-Amz-SignedHeaders", valid_603735
  var valid_603736 = header.getOrDefault("X-Amz-Credential")
  valid_603736 = validateParameter(valid_603736, JString, required = false,
                                 default = nil)
  if valid_603736 != nil:
    section.add "X-Amz-Credential", valid_603736
  result.add "header", section
  ## parameters in `formData` object:
  ##   ScheduleDefinitions: JArray
  ##                      : The definition of the snapshot schedule. The definition is made up of schedule expressions, for example "cron(30 12 *)" or "rate(12 hours)". 
  ##   DryRun: JBool
  ##         : <p/>
  ##   Tags: JArray
  ##       : An optional set of tags you can use to search for the schedule.
  ##   ScheduleDescription: JString
  ##                      : The description of the snapshot schedule.
  ##   ScheduleIdentifier: JString
  ##                     : A unique identifier for a snapshot schedule. Only alphanumeric characters are allowed for the identifier.
  ##   NextInvocations: JInt
  ##                  : <p/>
  section = newJObject()
  var valid_603737 = formData.getOrDefault("ScheduleDefinitions")
  valid_603737 = validateParameter(valid_603737, JArray, required = false,
                                 default = nil)
  if valid_603737 != nil:
    section.add "ScheduleDefinitions", valid_603737
  var valid_603738 = formData.getOrDefault("DryRun")
  valid_603738 = validateParameter(valid_603738, JBool, required = false, default = nil)
  if valid_603738 != nil:
    section.add "DryRun", valid_603738
  var valid_603739 = formData.getOrDefault("Tags")
  valid_603739 = validateParameter(valid_603739, JArray, required = false,
                                 default = nil)
  if valid_603739 != nil:
    section.add "Tags", valid_603739
  var valid_603740 = formData.getOrDefault("ScheduleDescription")
  valid_603740 = validateParameter(valid_603740, JString, required = false,
                                 default = nil)
  if valid_603740 != nil:
    section.add "ScheduleDescription", valid_603740
  var valid_603741 = formData.getOrDefault("ScheduleIdentifier")
  valid_603741 = validateParameter(valid_603741, JString, required = false,
                                 default = nil)
  if valid_603741 != nil:
    section.add "ScheduleIdentifier", valid_603741
  var valid_603742 = formData.getOrDefault("NextInvocations")
  valid_603742 = validateParameter(valid_603742, JInt, required = false, default = nil)
  if valid_603742 != nil:
    section.add "NextInvocations", valid_603742
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603743: Call_PostCreateSnapshotSchedule_603725; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a new snapshot schedule.
  ## 
  let valid = call_603743.validator(path, query, header, formData, body)
  let scheme = call_603743.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603743.url(scheme.get, call_603743.host, call_603743.base,
                         call_603743.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_603743, url, valid)

proc call*(call_603744: Call_PostCreateSnapshotSchedule_603725;
          ScheduleDefinitions: JsonNode = nil; DryRun: bool = false;
          Tags: JsonNode = nil; ScheduleDescription: string = "";
          Action: string = "CreateSnapshotSchedule";
          ScheduleIdentifier: string = ""; NextInvocations: int = 0;
          Version: string = "2012-12-01"): Recallable =
  ## postCreateSnapshotSchedule
  ## Creates a new snapshot schedule.
  ##   ScheduleDefinitions: JArray
  ##                      : The definition of the snapshot schedule. The definition is made up of schedule expressions, for example "cron(30 12 *)" or "rate(12 hours)". 
  ##   DryRun: bool
  ##         : <p/>
  ##   Tags: JArray
  ##       : An optional set of tags you can use to search for the schedule.
  ##   ScheduleDescription: string
  ##                      : The description of the snapshot schedule.
  ##   Action: string (required)
  ##   ScheduleIdentifier: string
  ##                     : A unique identifier for a snapshot schedule. Only alphanumeric characters are allowed for the identifier.
  ##   NextInvocations: int
  ##                  : <p/>
  ##   Version: string (required)
  var query_603745 = newJObject()
  var formData_603746 = newJObject()
  if ScheduleDefinitions != nil:
    formData_603746.add "ScheduleDefinitions", ScheduleDefinitions
  add(formData_603746, "DryRun", newJBool(DryRun))
  if Tags != nil:
    formData_603746.add "Tags", Tags
  add(formData_603746, "ScheduleDescription", newJString(ScheduleDescription))
  add(query_603745, "Action", newJString(Action))
  add(formData_603746, "ScheduleIdentifier", newJString(ScheduleIdentifier))
  add(formData_603746, "NextInvocations", newJInt(NextInvocations))
  add(query_603745, "Version", newJString(Version))
  result = call_603744.call(nil, query_603745, nil, formData_603746, nil)

var postCreateSnapshotSchedule* = Call_PostCreateSnapshotSchedule_603725(
    name: "postCreateSnapshotSchedule", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=CreateSnapshotSchedule",
    validator: validate_PostCreateSnapshotSchedule_603726, base: "/",
    url: url_PostCreateSnapshotSchedule_603727,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCreateSnapshotSchedule_603704 = ref object of OpenApiRestCall_602450
proc url_GetCreateSnapshotSchedule_603706(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetCreateSnapshotSchedule_603705(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Creates a new snapshot schedule.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   DryRun: JBool
  ##         : <p/>
  ##   ScheduleDefinitions: JArray
  ##                      : The definition of the snapshot schedule. The definition is made up of schedule expressions, for example "cron(30 12 *)" or "rate(12 hours)". 
  ##   Tags: JArray
  ##       : An optional set of tags you can use to search for the schedule.
  ##   Action: JString (required)
  ##   ScheduleIdentifier: JString
  ##                     : A unique identifier for a snapshot schedule. Only alphanumeric characters are allowed for the identifier.
  ##   ScheduleDescription: JString
  ##                      : The description of the snapshot schedule.
  ##   NextInvocations: JInt
  ##                  : <p/>
  ##   Version: JString (required)
  section = newJObject()
  var valid_603707 = query.getOrDefault("DryRun")
  valid_603707 = validateParameter(valid_603707, JBool, required = false, default = nil)
  if valid_603707 != nil:
    section.add "DryRun", valid_603707
  var valid_603708 = query.getOrDefault("ScheduleDefinitions")
  valid_603708 = validateParameter(valid_603708, JArray, required = false,
                                 default = nil)
  if valid_603708 != nil:
    section.add "ScheduleDefinitions", valid_603708
  var valid_603709 = query.getOrDefault("Tags")
  valid_603709 = validateParameter(valid_603709, JArray, required = false,
                                 default = nil)
  if valid_603709 != nil:
    section.add "Tags", valid_603709
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_603710 = query.getOrDefault("Action")
  valid_603710 = validateParameter(valid_603710, JString, required = true,
                                 default = newJString("CreateSnapshotSchedule"))
  if valid_603710 != nil:
    section.add "Action", valid_603710
  var valid_603711 = query.getOrDefault("ScheduleIdentifier")
  valid_603711 = validateParameter(valid_603711, JString, required = false,
                                 default = nil)
  if valid_603711 != nil:
    section.add "ScheduleIdentifier", valid_603711
  var valid_603712 = query.getOrDefault("ScheduleDescription")
  valid_603712 = validateParameter(valid_603712, JString, required = false,
                                 default = nil)
  if valid_603712 != nil:
    section.add "ScheduleDescription", valid_603712
  var valid_603713 = query.getOrDefault("NextInvocations")
  valid_603713 = validateParameter(valid_603713, JInt, required = false, default = nil)
  if valid_603713 != nil:
    section.add "NextInvocations", valid_603713
  var valid_603714 = query.getOrDefault("Version")
  valid_603714 = validateParameter(valid_603714, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_603714 != nil:
    section.add "Version", valid_603714
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603715 = header.getOrDefault("X-Amz-Date")
  valid_603715 = validateParameter(valid_603715, JString, required = false,
                                 default = nil)
  if valid_603715 != nil:
    section.add "X-Amz-Date", valid_603715
  var valid_603716 = header.getOrDefault("X-Amz-Security-Token")
  valid_603716 = validateParameter(valid_603716, JString, required = false,
                                 default = nil)
  if valid_603716 != nil:
    section.add "X-Amz-Security-Token", valid_603716
  var valid_603717 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603717 = validateParameter(valid_603717, JString, required = false,
                                 default = nil)
  if valid_603717 != nil:
    section.add "X-Amz-Content-Sha256", valid_603717
  var valid_603718 = header.getOrDefault("X-Amz-Algorithm")
  valid_603718 = validateParameter(valid_603718, JString, required = false,
                                 default = nil)
  if valid_603718 != nil:
    section.add "X-Amz-Algorithm", valid_603718
  var valid_603719 = header.getOrDefault("X-Amz-Signature")
  valid_603719 = validateParameter(valid_603719, JString, required = false,
                                 default = nil)
  if valid_603719 != nil:
    section.add "X-Amz-Signature", valid_603719
  var valid_603720 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603720 = validateParameter(valid_603720, JString, required = false,
                                 default = nil)
  if valid_603720 != nil:
    section.add "X-Amz-SignedHeaders", valid_603720
  var valid_603721 = header.getOrDefault("X-Amz-Credential")
  valid_603721 = validateParameter(valid_603721, JString, required = false,
                                 default = nil)
  if valid_603721 != nil:
    section.add "X-Amz-Credential", valid_603721
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603722: Call_GetCreateSnapshotSchedule_603704; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a new snapshot schedule.
  ## 
  let valid = call_603722.validator(path, query, header, formData, body)
  let scheme = call_603722.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603722.url(scheme.get, call_603722.host, call_603722.base,
                         call_603722.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_603722, url, valid)

proc call*(call_603723: Call_GetCreateSnapshotSchedule_603704;
          DryRun: bool = false; ScheduleDefinitions: JsonNode = nil;
          Tags: JsonNode = nil; Action: string = "CreateSnapshotSchedule";
          ScheduleIdentifier: string = ""; ScheduleDescription: string = "";
          NextInvocations: int = 0; Version: string = "2012-12-01"): Recallable =
  ## getCreateSnapshotSchedule
  ## Creates a new snapshot schedule.
  ##   DryRun: bool
  ##         : <p/>
  ##   ScheduleDefinitions: JArray
  ##                      : The definition of the snapshot schedule. The definition is made up of schedule expressions, for example "cron(30 12 *)" or "rate(12 hours)". 
  ##   Tags: JArray
  ##       : An optional set of tags you can use to search for the schedule.
  ##   Action: string (required)
  ##   ScheduleIdentifier: string
  ##                     : A unique identifier for a snapshot schedule. Only alphanumeric characters are allowed for the identifier.
  ##   ScheduleDescription: string
  ##                      : The description of the snapshot schedule.
  ##   NextInvocations: int
  ##                  : <p/>
  ##   Version: string (required)
  var query_603724 = newJObject()
  add(query_603724, "DryRun", newJBool(DryRun))
  if ScheduleDefinitions != nil:
    query_603724.add "ScheduleDefinitions", ScheduleDefinitions
  if Tags != nil:
    query_603724.add "Tags", Tags
  add(query_603724, "Action", newJString(Action))
  add(query_603724, "ScheduleIdentifier", newJString(ScheduleIdentifier))
  add(query_603724, "ScheduleDescription", newJString(ScheduleDescription))
  add(query_603724, "NextInvocations", newJInt(NextInvocations))
  add(query_603724, "Version", newJString(Version))
  result = call_603723.call(nil, query_603724, nil, nil, nil)

var getCreateSnapshotSchedule* = Call_GetCreateSnapshotSchedule_603704(
    name: "getCreateSnapshotSchedule", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=CreateSnapshotSchedule",
    validator: validate_GetCreateSnapshotSchedule_603705, base: "/",
    url: url_GetCreateSnapshotSchedule_603706,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCreateTags_603764 = ref object of OpenApiRestCall_602450
proc url_PostCreateTags_603766(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostCreateTags_603765(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode): JsonNode =
  ## <p>Adds one or more tags to a specified resource.</p> <p>A resource can have up to 50 tags. If you try to create more than 50 tags for a resource, you will receive an error and the attempt will fail.</p> <p>If you specify a key that already exists for the resource, the value for that key will be updated with the new value.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_603767 = query.getOrDefault("Action")
  valid_603767 = validateParameter(valid_603767, JString, required = true,
                                 default = newJString("CreateTags"))
  if valid_603767 != nil:
    section.add "Action", valid_603767
  var valid_603768 = query.getOrDefault("Version")
  valid_603768 = validateParameter(valid_603768, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_603768 != nil:
    section.add "Version", valid_603768
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603769 = header.getOrDefault("X-Amz-Date")
  valid_603769 = validateParameter(valid_603769, JString, required = false,
                                 default = nil)
  if valid_603769 != nil:
    section.add "X-Amz-Date", valid_603769
  var valid_603770 = header.getOrDefault("X-Amz-Security-Token")
  valid_603770 = validateParameter(valid_603770, JString, required = false,
                                 default = nil)
  if valid_603770 != nil:
    section.add "X-Amz-Security-Token", valid_603770
  var valid_603771 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603771 = validateParameter(valid_603771, JString, required = false,
                                 default = nil)
  if valid_603771 != nil:
    section.add "X-Amz-Content-Sha256", valid_603771
  var valid_603772 = header.getOrDefault("X-Amz-Algorithm")
  valid_603772 = validateParameter(valid_603772, JString, required = false,
                                 default = nil)
  if valid_603772 != nil:
    section.add "X-Amz-Algorithm", valid_603772
  var valid_603773 = header.getOrDefault("X-Amz-Signature")
  valid_603773 = validateParameter(valid_603773, JString, required = false,
                                 default = nil)
  if valid_603773 != nil:
    section.add "X-Amz-Signature", valid_603773
  var valid_603774 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603774 = validateParameter(valid_603774, JString, required = false,
                                 default = nil)
  if valid_603774 != nil:
    section.add "X-Amz-SignedHeaders", valid_603774
  var valid_603775 = header.getOrDefault("X-Amz-Credential")
  valid_603775 = validateParameter(valid_603775, JString, required = false,
                                 default = nil)
  if valid_603775 != nil:
    section.add "X-Amz-Credential", valid_603775
  result.add "header", section
  ## parameters in `formData` object:
  ##   Tags: JArray (required)
  ##       : One or more name/value pairs to add as tags to the specified resource. Each tag name is passed in with the parameter <code>Key</code> and the corresponding value is passed in with the parameter <code>Value</code>. The <code>Key</code> and <code>Value</code> parameters are separated by a comma (,). Separate multiple tags with a space. For example, <code>--tags "Key"="owner","Value"="admin" "Key"="environment","Value"="test" "Key"="version","Value"="1.0"</code>. 
  ##   ResourceName: JString (required)
  ##               : The Amazon Resource Name (ARN) to which you want to add the tag or tags. For example, <code>arn:aws:redshift:us-east-1:123456789:cluster:t1</code>. 
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `Tags` field"
  var valid_603776 = formData.getOrDefault("Tags")
  valid_603776 = validateParameter(valid_603776, JArray, required = true, default = nil)
  if valid_603776 != nil:
    section.add "Tags", valid_603776
  var valid_603777 = formData.getOrDefault("ResourceName")
  valid_603777 = validateParameter(valid_603777, JString, required = true,
                                 default = nil)
  if valid_603777 != nil:
    section.add "ResourceName", valid_603777
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603778: Call_PostCreateTags_603764; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Adds one or more tags to a specified resource.</p> <p>A resource can have up to 50 tags. If you try to create more than 50 tags for a resource, you will receive an error and the attempt will fail.</p> <p>If you specify a key that already exists for the resource, the value for that key will be updated with the new value.</p>
  ## 
  let valid = call_603778.validator(path, query, header, formData, body)
  let scheme = call_603778.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603778.url(scheme.get, call_603778.host, call_603778.base,
                         call_603778.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_603778, url, valid)

proc call*(call_603779: Call_PostCreateTags_603764; Tags: JsonNode;
          ResourceName: string; Action: string = "CreateTags";
          Version: string = "2012-12-01"): Recallable =
  ## postCreateTags
  ## <p>Adds one or more tags to a specified resource.</p> <p>A resource can have up to 50 tags. If you try to create more than 50 tags for a resource, you will receive an error and the attempt will fail.</p> <p>If you specify a key that already exists for the resource, the value for that key will be updated with the new value.</p>
  ##   Tags: JArray (required)
  ##       : One or more name/value pairs to add as tags to the specified resource. Each tag name is passed in with the parameter <code>Key</code> and the corresponding value is passed in with the parameter <code>Value</code>. The <code>Key</code> and <code>Value</code> parameters are separated by a comma (,). Separate multiple tags with a space. For example, <code>--tags "Key"="owner","Value"="admin" "Key"="environment","Value"="test" "Key"="version","Value"="1.0"</code>. 
  ##   Action: string (required)
  ##   ResourceName: string (required)
  ##               : The Amazon Resource Name (ARN) to which you want to add the tag or tags. For example, <code>arn:aws:redshift:us-east-1:123456789:cluster:t1</code>. 
  ##   Version: string (required)
  var query_603780 = newJObject()
  var formData_603781 = newJObject()
  if Tags != nil:
    formData_603781.add "Tags", Tags
  add(query_603780, "Action", newJString(Action))
  add(formData_603781, "ResourceName", newJString(ResourceName))
  add(query_603780, "Version", newJString(Version))
  result = call_603779.call(nil, query_603780, nil, formData_603781, nil)

var postCreateTags* = Call_PostCreateTags_603764(name: "postCreateTags",
    meth: HttpMethod.HttpPost, host: "redshift.amazonaws.com",
    route: "/#Action=CreateTags", validator: validate_PostCreateTags_603765,
    base: "/", url: url_PostCreateTags_603766, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCreateTags_603747 = ref object of OpenApiRestCall_602450
proc url_GetCreateTags_603749(protocol: Scheme; host: string; base: string;
                             route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetCreateTags_603748(path: JsonNode; query: JsonNode; header: JsonNode;
                                  formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Adds one or more tags to a specified resource.</p> <p>A resource can have up to 50 tags. If you try to create more than 50 tags for a resource, you will receive an error and the attempt will fail.</p> <p>If you specify a key that already exists for the resource, the value for that key will be updated with the new value.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Tags: JArray (required)
  ##       : One or more name/value pairs to add as tags to the specified resource. Each tag name is passed in with the parameter <code>Key</code> and the corresponding value is passed in with the parameter <code>Value</code>. The <code>Key</code> and <code>Value</code> parameters are separated by a comma (,). Separate multiple tags with a space. For example, <code>--tags "Key"="owner","Value"="admin" "Key"="environment","Value"="test" "Key"="version","Value"="1.0"</code>. 
  ##   ResourceName: JString (required)
  ##               : The Amazon Resource Name (ARN) to which you want to add the tag or tags. For example, <code>arn:aws:redshift:us-east-1:123456789:cluster:t1</code>. 
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Tags` field"
  var valid_603750 = query.getOrDefault("Tags")
  valid_603750 = validateParameter(valid_603750, JArray, required = true, default = nil)
  if valid_603750 != nil:
    section.add "Tags", valid_603750
  var valid_603751 = query.getOrDefault("ResourceName")
  valid_603751 = validateParameter(valid_603751, JString, required = true,
                                 default = nil)
  if valid_603751 != nil:
    section.add "ResourceName", valid_603751
  var valid_603752 = query.getOrDefault("Action")
  valid_603752 = validateParameter(valid_603752, JString, required = true,
                                 default = newJString("CreateTags"))
  if valid_603752 != nil:
    section.add "Action", valid_603752
  var valid_603753 = query.getOrDefault("Version")
  valid_603753 = validateParameter(valid_603753, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_603753 != nil:
    section.add "Version", valid_603753
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603754 = header.getOrDefault("X-Amz-Date")
  valid_603754 = validateParameter(valid_603754, JString, required = false,
                                 default = nil)
  if valid_603754 != nil:
    section.add "X-Amz-Date", valid_603754
  var valid_603755 = header.getOrDefault("X-Amz-Security-Token")
  valid_603755 = validateParameter(valid_603755, JString, required = false,
                                 default = nil)
  if valid_603755 != nil:
    section.add "X-Amz-Security-Token", valid_603755
  var valid_603756 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603756 = validateParameter(valid_603756, JString, required = false,
                                 default = nil)
  if valid_603756 != nil:
    section.add "X-Amz-Content-Sha256", valid_603756
  var valid_603757 = header.getOrDefault("X-Amz-Algorithm")
  valid_603757 = validateParameter(valid_603757, JString, required = false,
                                 default = nil)
  if valid_603757 != nil:
    section.add "X-Amz-Algorithm", valid_603757
  var valid_603758 = header.getOrDefault("X-Amz-Signature")
  valid_603758 = validateParameter(valid_603758, JString, required = false,
                                 default = nil)
  if valid_603758 != nil:
    section.add "X-Amz-Signature", valid_603758
  var valid_603759 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603759 = validateParameter(valid_603759, JString, required = false,
                                 default = nil)
  if valid_603759 != nil:
    section.add "X-Amz-SignedHeaders", valid_603759
  var valid_603760 = header.getOrDefault("X-Amz-Credential")
  valid_603760 = validateParameter(valid_603760, JString, required = false,
                                 default = nil)
  if valid_603760 != nil:
    section.add "X-Amz-Credential", valid_603760
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603761: Call_GetCreateTags_603747; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Adds one or more tags to a specified resource.</p> <p>A resource can have up to 50 tags. If you try to create more than 50 tags for a resource, you will receive an error and the attempt will fail.</p> <p>If you specify a key that already exists for the resource, the value for that key will be updated with the new value.</p>
  ## 
  let valid = call_603761.validator(path, query, header, formData, body)
  let scheme = call_603761.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603761.url(scheme.get, call_603761.host, call_603761.base,
                         call_603761.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_603761, url, valid)

proc call*(call_603762: Call_GetCreateTags_603747; Tags: JsonNode;
          ResourceName: string; Action: string = "CreateTags";
          Version: string = "2012-12-01"): Recallable =
  ## getCreateTags
  ## <p>Adds one or more tags to a specified resource.</p> <p>A resource can have up to 50 tags. If you try to create more than 50 tags for a resource, you will receive an error and the attempt will fail.</p> <p>If you specify a key that already exists for the resource, the value for that key will be updated with the new value.</p>
  ##   Tags: JArray (required)
  ##       : One or more name/value pairs to add as tags to the specified resource. Each tag name is passed in with the parameter <code>Key</code> and the corresponding value is passed in with the parameter <code>Value</code>. The <code>Key</code> and <code>Value</code> parameters are separated by a comma (,). Separate multiple tags with a space. For example, <code>--tags "Key"="owner","Value"="admin" "Key"="environment","Value"="test" "Key"="version","Value"="1.0"</code>. 
  ##   ResourceName: string (required)
  ##               : The Amazon Resource Name (ARN) to which you want to add the tag or tags. For example, <code>arn:aws:redshift:us-east-1:123456789:cluster:t1</code>. 
  ##   Action: string (required)
  ##   Version: string (required)
  var query_603763 = newJObject()
  if Tags != nil:
    query_603763.add "Tags", Tags
  add(query_603763, "ResourceName", newJString(ResourceName))
  add(query_603763, "Action", newJString(Action))
  add(query_603763, "Version", newJString(Version))
  result = call_603762.call(nil, query_603763, nil, nil, nil)

var getCreateTags* = Call_GetCreateTags_603747(name: "getCreateTags",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=CreateTags", validator: validate_GetCreateTags_603748,
    base: "/", url: url_GetCreateTags_603749, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDeleteCluster_603801 = ref object of OpenApiRestCall_602450
proc url_PostDeleteCluster_603803(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostDeleteCluster_603802(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## <p>Deletes a previously provisioned cluster. A successful response from the web service indicates that the request was received correctly. Use <a>DescribeClusters</a> to monitor the status of the deletion. The delete operation cannot be canceled or reverted once submitted. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you want to shut down the cluster and retain it for future use, set <i>SkipFinalClusterSnapshot</i> to <code>false</code> and specify a name for <i>FinalClusterSnapshotIdentifier</i>. You can later restore this snapshot to resume using the cluster. If a final cluster snapshot is requested, the status of the cluster will be "final-snapshot" while the snapshot is being taken, then it's "deleting" once Amazon Redshift begins deleting the cluster. </p> <p> For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_603804 = query.getOrDefault("Action")
  valid_603804 = validateParameter(valid_603804, JString, required = true,
                                 default = newJString("DeleteCluster"))
  if valid_603804 != nil:
    section.add "Action", valid_603804
  var valid_603805 = query.getOrDefault("Version")
  valid_603805 = validateParameter(valid_603805, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_603805 != nil:
    section.add "Version", valid_603805
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603806 = header.getOrDefault("X-Amz-Date")
  valid_603806 = validateParameter(valid_603806, JString, required = false,
                                 default = nil)
  if valid_603806 != nil:
    section.add "X-Amz-Date", valid_603806
  var valid_603807 = header.getOrDefault("X-Amz-Security-Token")
  valid_603807 = validateParameter(valid_603807, JString, required = false,
                                 default = nil)
  if valid_603807 != nil:
    section.add "X-Amz-Security-Token", valid_603807
  var valid_603808 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603808 = validateParameter(valid_603808, JString, required = false,
                                 default = nil)
  if valid_603808 != nil:
    section.add "X-Amz-Content-Sha256", valid_603808
  var valid_603809 = header.getOrDefault("X-Amz-Algorithm")
  valid_603809 = validateParameter(valid_603809, JString, required = false,
                                 default = nil)
  if valid_603809 != nil:
    section.add "X-Amz-Algorithm", valid_603809
  var valid_603810 = header.getOrDefault("X-Amz-Signature")
  valid_603810 = validateParameter(valid_603810, JString, required = false,
                                 default = nil)
  if valid_603810 != nil:
    section.add "X-Amz-Signature", valid_603810
  var valid_603811 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603811 = validateParameter(valid_603811, JString, required = false,
                                 default = nil)
  if valid_603811 != nil:
    section.add "X-Amz-SignedHeaders", valid_603811
  var valid_603812 = header.getOrDefault("X-Amz-Credential")
  valid_603812 = validateParameter(valid_603812, JString, required = false,
                                 default = nil)
  if valid_603812 != nil:
    section.add "X-Amz-Credential", valid_603812
  result.add "header", section
  ## parameters in `formData` object:
  ##   FinalClusterSnapshotIdentifier: JString
  ##                                 : <p>The identifier of the final snapshot that is to be created immediately before deleting the cluster. If this parameter is provided, <i>SkipFinalClusterSnapshot</i> must be <code>false</code>. </p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   FinalClusterSnapshotRetentionPeriod: JInt
  ##                                      : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The identifier of the cluster to be deleted.</p> <p>Constraints:</p> <ul> <li> <p>Must contain lowercase characters.</p> </li> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   SkipFinalClusterSnapshot: JBool
  ##                           : <p>Determines whether a final snapshot of the cluster is created before Amazon Redshift deletes the cluster. If <code>true</code>, a final cluster snapshot is not created. If <code>false</code>, a final cluster snapshot is created before the cluster is deleted. </p> <note> <p>The <i>FinalClusterSnapshotIdentifier</i> parameter must be specified if <i>SkipFinalClusterSnapshot</i> is <code>false</code>.</p> </note> <p>Default: <code>false</code> </p>
  section = newJObject()
  var valid_603813 = formData.getOrDefault("FinalClusterSnapshotIdentifier")
  valid_603813 = validateParameter(valid_603813, JString, required = false,
                                 default = nil)
  if valid_603813 != nil:
    section.add "FinalClusterSnapshotIdentifier", valid_603813
  var valid_603814 = formData.getOrDefault("FinalClusterSnapshotRetentionPeriod")
  valid_603814 = validateParameter(valid_603814, JInt, required = false, default = nil)
  if valid_603814 != nil:
    section.add "FinalClusterSnapshotRetentionPeriod", valid_603814
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_603815 = formData.getOrDefault("ClusterIdentifier")
  valid_603815 = validateParameter(valid_603815, JString, required = true,
                                 default = nil)
  if valid_603815 != nil:
    section.add "ClusterIdentifier", valid_603815
  var valid_603816 = formData.getOrDefault("SkipFinalClusterSnapshot")
  valid_603816 = validateParameter(valid_603816, JBool, required = false, default = nil)
  if valid_603816 != nil:
    section.add "SkipFinalClusterSnapshot", valid_603816
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603817: Call_PostDeleteCluster_603801; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Deletes a previously provisioned cluster. A successful response from the web service indicates that the request was received correctly. Use <a>DescribeClusters</a> to monitor the status of the deletion. The delete operation cannot be canceled or reverted once submitted. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you want to shut down the cluster and retain it for future use, set <i>SkipFinalClusterSnapshot</i> to <code>false</code> and specify a name for <i>FinalClusterSnapshotIdentifier</i>. You can later restore this snapshot to resume using the cluster. If a final cluster snapshot is requested, the status of the cluster will be "final-snapshot" while the snapshot is being taken, then it's "deleting" once Amazon Redshift begins deleting the cluster. </p> <p> For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_603817.validator(path, query, header, formData, body)
  let scheme = call_603817.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603817.url(scheme.get, call_603817.host, call_603817.base,
                         call_603817.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_603817, url, valid)

proc call*(call_603818: Call_PostDeleteCluster_603801; ClusterIdentifier: string;
          FinalClusterSnapshotIdentifier: string = "";
          Action: string = "DeleteCluster";
          FinalClusterSnapshotRetentionPeriod: int = 0;
          SkipFinalClusterSnapshot: bool = false; Version: string = "2012-12-01"): Recallable =
  ## postDeleteCluster
  ## <p>Deletes a previously provisioned cluster. A successful response from the web service indicates that the request was received correctly. Use <a>DescribeClusters</a> to monitor the status of the deletion. The delete operation cannot be canceled or reverted once submitted. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you want to shut down the cluster and retain it for future use, set <i>SkipFinalClusterSnapshot</i> to <code>false</code> and specify a name for <i>FinalClusterSnapshotIdentifier</i>. You can later restore this snapshot to resume using the cluster. If a final cluster snapshot is requested, the status of the cluster will be "final-snapshot" while the snapshot is being taken, then it's "deleting" once Amazon Redshift begins deleting the cluster. </p> <p> For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   FinalClusterSnapshotIdentifier: string
  ##                                 : <p>The identifier of the final snapshot that is to be created immediately before deleting the cluster. If this parameter is provided, <i>SkipFinalClusterSnapshot</i> must be <code>false</code>. </p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   Action: string (required)
  ##   FinalClusterSnapshotRetentionPeriod: int
  ##                                      : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The identifier of the cluster to be deleted.</p> <p>Constraints:</p> <ul> <li> <p>Must contain lowercase characters.</p> </li> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   SkipFinalClusterSnapshot: bool
  ##                           : <p>Determines whether a final snapshot of the cluster is created before Amazon Redshift deletes the cluster. If <code>true</code>, a final cluster snapshot is not created. If <code>false</code>, a final cluster snapshot is created before the cluster is deleted. </p> <note> <p>The <i>FinalClusterSnapshotIdentifier</i> parameter must be specified if <i>SkipFinalClusterSnapshot</i> is <code>false</code>.</p> </note> <p>Default: <code>false</code> </p>
  ##   Version: string (required)
  var query_603819 = newJObject()
  var formData_603820 = newJObject()
  add(formData_603820, "FinalClusterSnapshotIdentifier",
      newJString(FinalClusterSnapshotIdentifier))
  add(query_603819, "Action", newJString(Action))
  add(formData_603820, "FinalClusterSnapshotRetentionPeriod",
      newJInt(FinalClusterSnapshotRetentionPeriod))
  add(formData_603820, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_603820, "SkipFinalClusterSnapshot",
      newJBool(SkipFinalClusterSnapshot))
  add(query_603819, "Version", newJString(Version))
  result = call_603818.call(nil, query_603819, nil, formData_603820, nil)

var postDeleteCluster* = Call_PostDeleteCluster_603801(name: "postDeleteCluster",
    meth: HttpMethod.HttpPost, host: "redshift.amazonaws.com",
    route: "/#Action=DeleteCluster", validator: validate_PostDeleteCluster_603802,
    base: "/", url: url_PostDeleteCluster_603803,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeleteCluster_603782 = ref object of OpenApiRestCall_602450
proc url_GetDeleteCluster_603784(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetDeleteCluster_603783(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## <p>Deletes a previously provisioned cluster. A successful response from the web service indicates that the request was received correctly. Use <a>DescribeClusters</a> to monitor the status of the deletion. The delete operation cannot be canceled or reverted once submitted. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you want to shut down the cluster and retain it for future use, set <i>SkipFinalClusterSnapshot</i> to <code>false</code> and specify a name for <i>FinalClusterSnapshotIdentifier</i>. You can later restore this snapshot to resume using the cluster. If a final cluster snapshot is requested, the status of the cluster will be "final-snapshot" while the snapshot is being taken, then it's "deleting" once Amazon Redshift begins deleting the cluster. </p> <p> For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   FinalClusterSnapshotRetentionPeriod: JInt
  ##                                      : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The identifier of the cluster to be deleted.</p> <p>Constraints:</p> <ul> <li> <p>Must contain lowercase characters.</p> </li> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   SkipFinalClusterSnapshot: JBool
  ##                           : <p>Determines whether a final snapshot of the cluster is created before Amazon Redshift deletes the cluster. If <code>true</code>, a final cluster snapshot is not created. If <code>false</code>, a final cluster snapshot is created before the cluster is deleted. </p> <note> <p>The <i>FinalClusterSnapshotIdentifier</i> parameter must be specified if <i>SkipFinalClusterSnapshot</i> is <code>false</code>.</p> </note> <p>Default: <code>false</code> </p>
  ##   FinalClusterSnapshotIdentifier: JString
  ##                                 : <p>The identifier of the final snapshot that is to be created immediately before deleting the cluster. If this parameter is provided, <i>SkipFinalClusterSnapshot</i> must be <code>false</code>. </p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   Version: JString (required)
  section = newJObject()
  var valid_603785 = query.getOrDefault("FinalClusterSnapshotRetentionPeriod")
  valid_603785 = validateParameter(valid_603785, JInt, required = false, default = nil)
  if valid_603785 != nil:
    section.add "FinalClusterSnapshotRetentionPeriod", valid_603785
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_603786 = query.getOrDefault("Action")
  valid_603786 = validateParameter(valid_603786, JString, required = true,
                                 default = newJString("DeleteCluster"))
  if valid_603786 != nil:
    section.add "Action", valid_603786
  var valid_603787 = query.getOrDefault("ClusterIdentifier")
  valid_603787 = validateParameter(valid_603787, JString, required = true,
                                 default = nil)
  if valid_603787 != nil:
    section.add "ClusterIdentifier", valid_603787
  var valid_603788 = query.getOrDefault("SkipFinalClusterSnapshot")
  valid_603788 = validateParameter(valid_603788, JBool, required = false, default = nil)
  if valid_603788 != nil:
    section.add "SkipFinalClusterSnapshot", valid_603788
  var valid_603789 = query.getOrDefault("FinalClusterSnapshotIdentifier")
  valid_603789 = validateParameter(valid_603789, JString, required = false,
                                 default = nil)
  if valid_603789 != nil:
    section.add "FinalClusterSnapshotIdentifier", valid_603789
  var valid_603790 = query.getOrDefault("Version")
  valid_603790 = validateParameter(valid_603790, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_603790 != nil:
    section.add "Version", valid_603790
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603791 = header.getOrDefault("X-Amz-Date")
  valid_603791 = validateParameter(valid_603791, JString, required = false,
                                 default = nil)
  if valid_603791 != nil:
    section.add "X-Amz-Date", valid_603791
  var valid_603792 = header.getOrDefault("X-Amz-Security-Token")
  valid_603792 = validateParameter(valid_603792, JString, required = false,
                                 default = nil)
  if valid_603792 != nil:
    section.add "X-Amz-Security-Token", valid_603792
  var valid_603793 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603793 = validateParameter(valid_603793, JString, required = false,
                                 default = nil)
  if valid_603793 != nil:
    section.add "X-Amz-Content-Sha256", valid_603793
  var valid_603794 = header.getOrDefault("X-Amz-Algorithm")
  valid_603794 = validateParameter(valid_603794, JString, required = false,
                                 default = nil)
  if valid_603794 != nil:
    section.add "X-Amz-Algorithm", valid_603794
  var valid_603795 = header.getOrDefault("X-Amz-Signature")
  valid_603795 = validateParameter(valid_603795, JString, required = false,
                                 default = nil)
  if valid_603795 != nil:
    section.add "X-Amz-Signature", valid_603795
  var valid_603796 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603796 = validateParameter(valid_603796, JString, required = false,
                                 default = nil)
  if valid_603796 != nil:
    section.add "X-Amz-SignedHeaders", valid_603796
  var valid_603797 = header.getOrDefault("X-Amz-Credential")
  valid_603797 = validateParameter(valid_603797, JString, required = false,
                                 default = nil)
  if valid_603797 != nil:
    section.add "X-Amz-Credential", valid_603797
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603798: Call_GetDeleteCluster_603782; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Deletes a previously provisioned cluster. A successful response from the web service indicates that the request was received correctly. Use <a>DescribeClusters</a> to monitor the status of the deletion. The delete operation cannot be canceled or reverted once submitted. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you want to shut down the cluster and retain it for future use, set <i>SkipFinalClusterSnapshot</i> to <code>false</code> and specify a name for <i>FinalClusterSnapshotIdentifier</i>. You can later restore this snapshot to resume using the cluster. If a final cluster snapshot is requested, the status of the cluster will be "final-snapshot" while the snapshot is being taken, then it's "deleting" once Amazon Redshift begins deleting the cluster. </p> <p> For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_603798.validator(path, query, header, formData, body)
  let scheme = call_603798.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603798.url(scheme.get, call_603798.host, call_603798.base,
                         call_603798.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_603798, url, valid)

proc call*(call_603799: Call_GetDeleteCluster_603782; ClusterIdentifier: string;
          FinalClusterSnapshotRetentionPeriod: int = 0;
          Action: string = "DeleteCluster"; SkipFinalClusterSnapshot: bool = false;
          FinalClusterSnapshotIdentifier: string = "";
          Version: string = "2012-12-01"): Recallable =
  ## getDeleteCluster
  ## <p>Deletes a previously provisioned cluster. A successful response from the web service indicates that the request was received correctly. Use <a>DescribeClusters</a> to monitor the status of the deletion. The delete operation cannot be canceled or reverted once submitted. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you want to shut down the cluster and retain it for future use, set <i>SkipFinalClusterSnapshot</i> to <code>false</code> and specify a name for <i>FinalClusterSnapshotIdentifier</i>. You can later restore this snapshot to resume using the cluster. If a final cluster snapshot is requested, the status of the cluster will be "final-snapshot" while the snapshot is being taken, then it's "deleting" once Amazon Redshift begins deleting the cluster. </p> <p> For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   FinalClusterSnapshotRetentionPeriod: int
  ##                                      : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The identifier of the cluster to be deleted.</p> <p>Constraints:</p> <ul> <li> <p>Must contain lowercase characters.</p> </li> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   SkipFinalClusterSnapshot: bool
  ##                           : <p>Determines whether a final snapshot of the cluster is created before Amazon Redshift deletes the cluster. If <code>true</code>, a final cluster snapshot is not created. If <code>false</code>, a final cluster snapshot is created before the cluster is deleted. </p> <note> <p>The <i>FinalClusterSnapshotIdentifier</i> parameter must be specified if <i>SkipFinalClusterSnapshot</i> is <code>false</code>.</p> </note> <p>Default: <code>false</code> </p>
  ##   FinalClusterSnapshotIdentifier: string
  ##                                 : <p>The identifier of the final snapshot that is to be created immediately before deleting the cluster. If this parameter is provided, <i>SkipFinalClusterSnapshot</i> must be <code>false</code>. </p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   Version: string (required)
  var query_603800 = newJObject()
  add(query_603800, "FinalClusterSnapshotRetentionPeriod",
      newJInt(FinalClusterSnapshotRetentionPeriod))
  add(query_603800, "Action", newJString(Action))
  add(query_603800, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_603800, "SkipFinalClusterSnapshot", newJBool(SkipFinalClusterSnapshot))
  add(query_603800, "FinalClusterSnapshotIdentifier",
      newJString(FinalClusterSnapshotIdentifier))
  add(query_603800, "Version", newJString(Version))
  result = call_603799.call(nil, query_603800, nil, nil, nil)

var getDeleteCluster* = Call_GetDeleteCluster_603782(name: "getDeleteCluster",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=DeleteCluster", validator: validate_GetDeleteCluster_603783,
    base: "/", url: url_GetDeleteCluster_603784,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDeleteClusterParameterGroup_603837 = ref object of OpenApiRestCall_602450
proc url_PostDeleteClusterParameterGroup_603839(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostDeleteClusterParameterGroup_603838(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Deletes a specified Amazon Redshift parameter group.</p> <note> <p>You cannot delete a parameter group if it is associated with a cluster.</p> </note>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_603840 = query.getOrDefault("Action")
  valid_603840 = validateParameter(valid_603840, JString, required = true, default = newJString(
      "DeleteClusterParameterGroup"))
  if valid_603840 != nil:
    section.add "Action", valid_603840
  var valid_603841 = query.getOrDefault("Version")
  valid_603841 = validateParameter(valid_603841, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_603841 != nil:
    section.add "Version", valid_603841
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603842 = header.getOrDefault("X-Amz-Date")
  valid_603842 = validateParameter(valid_603842, JString, required = false,
                                 default = nil)
  if valid_603842 != nil:
    section.add "X-Amz-Date", valid_603842
  var valid_603843 = header.getOrDefault("X-Amz-Security-Token")
  valid_603843 = validateParameter(valid_603843, JString, required = false,
                                 default = nil)
  if valid_603843 != nil:
    section.add "X-Amz-Security-Token", valid_603843
  var valid_603844 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603844 = validateParameter(valid_603844, JString, required = false,
                                 default = nil)
  if valid_603844 != nil:
    section.add "X-Amz-Content-Sha256", valid_603844
  var valid_603845 = header.getOrDefault("X-Amz-Algorithm")
  valid_603845 = validateParameter(valid_603845, JString, required = false,
                                 default = nil)
  if valid_603845 != nil:
    section.add "X-Amz-Algorithm", valid_603845
  var valid_603846 = header.getOrDefault("X-Amz-Signature")
  valid_603846 = validateParameter(valid_603846, JString, required = false,
                                 default = nil)
  if valid_603846 != nil:
    section.add "X-Amz-Signature", valid_603846
  var valid_603847 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603847 = validateParameter(valid_603847, JString, required = false,
                                 default = nil)
  if valid_603847 != nil:
    section.add "X-Amz-SignedHeaders", valid_603847
  var valid_603848 = header.getOrDefault("X-Amz-Credential")
  valid_603848 = validateParameter(valid_603848, JString, required = false,
                                 default = nil)
  if valid_603848 != nil:
    section.add "X-Amz-Credential", valid_603848
  result.add "header", section
  ## parameters in `formData` object:
  ##   ParameterGroupName: JString (required)
  ##                     : <p>The name of the parameter group to be deleted.</p> <p>Constraints:</p> <ul> <li> <p>Must be the name of an existing cluster parameter group.</p> </li> <li> <p>Cannot delete a default cluster parameter group.</p> </li> </ul>
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ParameterGroupName` field"
  var valid_603849 = formData.getOrDefault("ParameterGroupName")
  valid_603849 = validateParameter(valid_603849, JString, required = true,
                                 default = nil)
  if valid_603849 != nil:
    section.add "ParameterGroupName", valid_603849
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603850: Call_PostDeleteClusterParameterGroup_603837;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Deletes a specified Amazon Redshift parameter group.</p> <note> <p>You cannot delete a parameter group if it is associated with a cluster.</p> </note>
  ## 
  let valid = call_603850.validator(path, query, header, formData, body)
  let scheme = call_603850.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603850.url(scheme.get, call_603850.host, call_603850.base,
                         call_603850.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_603850, url, valid)

proc call*(call_603851: Call_PostDeleteClusterParameterGroup_603837;
          ParameterGroupName: string;
          Action: string = "DeleteClusterParameterGroup";
          Version: string = "2012-12-01"): Recallable =
  ## postDeleteClusterParameterGroup
  ## <p>Deletes a specified Amazon Redshift parameter group.</p> <note> <p>You cannot delete a parameter group if it is associated with a cluster.</p> </note>
  ##   ParameterGroupName: string (required)
  ##                     : <p>The name of the parameter group to be deleted.</p> <p>Constraints:</p> <ul> <li> <p>Must be the name of an existing cluster parameter group.</p> </li> <li> <p>Cannot delete a default cluster parameter group.</p> </li> </ul>
  ##   Action: string (required)
  ##   Version: string (required)
  var query_603852 = newJObject()
  var formData_603853 = newJObject()
  add(formData_603853, "ParameterGroupName", newJString(ParameterGroupName))
  add(query_603852, "Action", newJString(Action))
  add(query_603852, "Version", newJString(Version))
  result = call_603851.call(nil, query_603852, nil, formData_603853, nil)

var postDeleteClusterParameterGroup* = Call_PostDeleteClusterParameterGroup_603837(
    name: "postDeleteClusterParameterGroup", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteClusterParameterGroup",
    validator: validate_PostDeleteClusterParameterGroup_603838, base: "/",
    url: url_PostDeleteClusterParameterGroup_603839,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeleteClusterParameterGroup_603821 = ref object of OpenApiRestCall_602450
proc url_GetDeleteClusterParameterGroup_603823(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetDeleteClusterParameterGroup_603822(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Deletes a specified Amazon Redshift parameter group.</p> <note> <p>You cannot delete a parameter group if it is associated with a cluster.</p> </note>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ParameterGroupName: JString (required)
  ##                     : <p>The name of the parameter group to be deleted.</p> <p>Constraints:</p> <ul> <li> <p>Must be the name of an existing cluster parameter group.</p> </li> <li> <p>Cannot delete a default cluster parameter group.</p> </li> </ul>
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `ParameterGroupName` field"
  var valid_603824 = query.getOrDefault("ParameterGroupName")
  valid_603824 = validateParameter(valid_603824, JString, required = true,
                                 default = nil)
  if valid_603824 != nil:
    section.add "ParameterGroupName", valid_603824
  var valid_603825 = query.getOrDefault("Action")
  valid_603825 = validateParameter(valid_603825, JString, required = true, default = newJString(
      "DeleteClusterParameterGroup"))
  if valid_603825 != nil:
    section.add "Action", valid_603825
  var valid_603826 = query.getOrDefault("Version")
  valid_603826 = validateParameter(valid_603826, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_603826 != nil:
    section.add "Version", valid_603826
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603827 = header.getOrDefault("X-Amz-Date")
  valid_603827 = validateParameter(valid_603827, JString, required = false,
                                 default = nil)
  if valid_603827 != nil:
    section.add "X-Amz-Date", valid_603827
  var valid_603828 = header.getOrDefault("X-Amz-Security-Token")
  valid_603828 = validateParameter(valid_603828, JString, required = false,
                                 default = nil)
  if valid_603828 != nil:
    section.add "X-Amz-Security-Token", valid_603828
  var valid_603829 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603829 = validateParameter(valid_603829, JString, required = false,
                                 default = nil)
  if valid_603829 != nil:
    section.add "X-Amz-Content-Sha256", valid_603829
  var valid_603830 = header.getOrDefault("X-Amz-Algorithm")
  valid_603830 = validateParameter(valid_603830, JString, required = false,
                                 default = nil)
  if valid_603830 != nil:
    section.add "X-Amz-Algorithm", valid_603830
  var valid_603831 = header.getOrDefault("X-Amz-Signature")
  valid_603831 = validateParameter(valid_603831, JString, required = false,
                                 default = nil)
  if valid_603831 != nil:
    section.add "X-Amz-Signature", valid_603831
  var valid_603832 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603832 = validateParameter(valid_603832, JString, required = false,
                                 default = nil)
  if valid_603832 != nil:
    section.add "X-Amz-SignedHeaders", valid_603832
  var valid_603833 = header.getOrDefault("X-Amz-Credential")
  valid_603833 = validateParameter(valid_603833, JString, required = false,
                                 default = nil)
  if valid_603833 != nil:
    section.add "X-Amz-Credential", valid_603833
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603834: Call_GetDeleteClusterParameterGroup_603821; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Deletes a specified Amazon Redshift parameter group.</p> <note> <p>You cannot delete a parameter group if it is associated with a cluster.</p> </note>
  ## 
  let valid = call_603834.validator(path, query, header, formData, body)
  let scheme = call_603834.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603834.url(scheme.get, call_603834.host, call_603834.base,
                         call_603834.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_603834, url, valid)

proc call*(call_603835: Call_GetDeleteClusterParameterGroup_603821;
          ParameterGroupName: string;
          Action: string = "DeleteClusterParameterGroup";
          Version: string = "2012-12-01"): Recallable =
  ## getDeleteClusterParameterGroup
  ## <p>Deletes a specified Amazon Redshift parameter group.</p> <note> <p>You cannot delete a parameter group if it is associated with a cluster.</p> </note>
  ##   ParameterGroupName: string (required)
  ##                     : <p>The name of the parameter group to be deleted.</p> <p>Constraints:</p> <ul> <li> <p>Must be the name of an existing cluster parameter group.</p> </li> <li> <p>Cannot delete a default cluster parameter group.</p> </li> </ul>
  ##   Action: string (required)
  ##   Version: string (required)
  var query_603836 = newJObject()
  add(query_603836, "ParameterGroupName", newJString(ParameterGroupName))
  add(query_603836, "Action", newJString(Action))
  add(query_603836, "Version", newJString(Version))
  result = call_603835.call(nil, query_603836, nil, nil, nil)

var getDeleteClusterParameterGroup* = Call_GetDeleteClusterParameterGroup_603821(
    name: "getDeleteClusterParameterGroup", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteClusterParameterGroup",
    validator: validate_GetDeleteClusterParameterGroup_603822, base: "/",
    url: url_GetDeleteClusterParameterGroup_603823,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDeleteClusterSecurityGroup_603870 = ref object of OpenApiRestCall_602450
proc url_PostDeleteClusterSecurityGroup_603872(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostDeleteClusterSecurityGroup_603871(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Deletes an Amazon Redshift security group.</p> <note> <p>You cannot delete a security group that is associated with any clusters. You cannot delete the default security group.</p> </note> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_603873 = query.getOrDefault("Action")
  valid_603873 = validateParameter(valid_603873, JString, required = true, default = newJString(
      "DeleteClusterSecurityGroup"))
  if valid_603873 != nil:
    section.add "Action", valid_603873
  var valid_603874 = query.getOrDefault("Version")
  valid_603874 = validateParameter(valid_603874, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_603874 != nil:
    section.add "Version", valid_603874
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603875 = header.getOrDefault("X-Amz-Date")
  valid_603875 = validateParameter(valid_603875, JString, required = false,
                                 default = nil)
  if valid_603875 != nil:
    section.add "X-Amz-Date", valid_603875
  var valid_603876 = header.getOrDefault("X-Amz-Security-Token")
  valid_603876 = validateParameter(valid_603876, JString, required = false,
                                 default = nil)
  if valid_603876 != nil:
    section.add "X-Amz-Security-Token", valid_603876
  var valid_603877 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603877 = validateParameter(valid_603877, JString, required = false,
                                 default = nil)
  if valid_603877 != nil:
    section.add "X-Amz-Content-Sha256", valid_603877
  var valid_603878 = header.getOrDefault("X-Amz-Algorithm")
  valid_603878 = validateParameter(valid_603878, JString, required = false,
                                 default = nil)
  if valid_603878 != nil:
    section.add "X-Amz-Algorithm", valid_603878
  var valid_603879 = header.getOrDefault("X-Amz-Signature")
  valid_603879 = validateParameter(valid_603879, JString, required = false,
                                 default = nil)
  if valid_603879 != nil:
    section.add "X-Amz-Signature", valid_603879
  var valid_603880 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603880 = validateParameter(valid_603880, JString, required = false,
                                 default = nil)
  if valid_603880 != nil:
    section.add "X-Amz-SignedHeaders", valid_603880
  var valid_603881 = header.getOrDefault("X-Amz-Credential")
  valid_603881 = validateParameter(valid_603881, JString, required = false,
                                 default = nil)
  if valid_603881 != nil:
    section.add "X-Amz-Credential", valid_603881
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterSecurityGroupName: JString (required)
  ##                           : The name of the cluster security group to be deleted.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterSecurityGroupName` field"
  var valid_603882 = formData.getOrDefault("ClusterSecurityGroupName")
  valid_603882 = validateParameter(valid_603882, JString, required = true,
                                 default = nil)
  if valid_603882 != nil:
    section.add "ClusterSecurityGroupName", valid_603882
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603883: Call_PostDeleteClusterSecurityGroup_603870; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Deletes an Amazon Redshift security group.</p> <note> <p>You cannot delete a security group that is associated with any clusters. You cannot delete the default security group.</p> </note> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_603883.validator(path, query, header, formData, body)
  let scheme = call_603883.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603883.url(scheme.get, call_603883.host, call_603883.base,
                         call_603883.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_603883, url, valid)

proc call*(call_603884: Call_PostDeleteClusterSecurityGroup_603870;
          ClusterSecurityGroupName: string;
          Action: string = "DeleteClusterSecurityGroup";
          Version: string = "2012-12-01"): Recallable =
  ## postDeleteClusterSecurityGroup
  ## <p>Deletes an Amazon Redshift security group.</p> <note> <p>You cannot delete a security group that is associated with any clusters. You cannot delete the default security group.</p> </note> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   Action: string (required)
  ##   Version: string (required)
  ##   ClusterSecurityGroupName: string (required)
  ##                           : The name of the cluster security group to be deleted.
  var query_603885 = newJObject()
  var formData_603886 = newJObject()
  add(query_603885, "Action", newJString(Action))
  add(query_603885, "Version", newJString(Version))
  add(formData_603886, "ClusterSecurityGroupName",
      newJString(ClusterSecurityGroupName))
  result = call_603884.call(nil, query_603885, nil, formData_603886, nil)

var postDeleteClusterSecurityGroup* = Call_PostDeleteClusterSecurityGroup_603870(
    name: "postDeleteClusterSecurityGroup", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteClusterSecurityGroup",
    validator: validate_PostDeleteClusterSecurityGroup_603871, base: "/",
    url: url_PostDeleteClusterSecurityGroup_603872,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeleteClusterSecurityGroup_603854 = ref object of OpenApiRestCall_602450
proc url_GetDeleteClusterSecurityGroup_603856(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetDeleteClusterSecurityGroup_603855(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Deletes an Amazon Redshift security group.</p> <note> <p>You cannot delete a security group that is associated with any clusters. You cannot delete the default security group.</p> </note> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ClusterSecurityGroupName: JString (required)
  ##                           : The name of the cluster security group to be deleted.
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `ClusterSecurityGroupName` field"
  var valid_603857 = query.getOrDefault("ClusterSecurityGroupName")
  valid_603857 = validateParameter(valid_603857, JString, required = true,
                                 default = nil)
  if valid_603857 != nil:
    section.add "ClusterSecurityGroupName", valid_603857
  var valid_603858 = query.getOrDefault("Action")
  valid_603858 = validateParameter(valid_603858, JString, required = true, default = newJString(
      "DeleteClusterSecurityGroup"))
  if valid_603858 != nil:
    section.add "Action", valid_603858
  var valid_603859 = query.getOrDefault("Version")
  valid_603859 = validateParameter(valid_603859, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_603859 != nil:
    section.add "Version", valid_603859
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603860 = header.getOrDefault("X-Amz-Date")
  valid_603860 = validateParameter(valid_603860, JString, required = false,
                                 default = nil)
  if valid_603860 != nil:
    section.add "X-Amz-Date", valid_603860
  var valid_603861 = header.getOrDefault("X-Amz-Security-Token")
  valid_603861 = validateParameter(valid_603861, JString, required = false,
                                 default = nil)
  if valid_603861 != nil:
    section.add "X-Amz-Security-Token", valid_603861
  var valid_603862 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603862 = validateParameter(valid_603862, JString, required = false,
                                 default = nil)
  if valid_603862 != nil:
    section.add "X-Amz-Content-Sha256", valid_603862
  var valid_603863 = header.getOrDefault("X-Amz-Algorithm")
  valid_603863 = validateParameter(valid_603863, JString, required = false,
                                 default = nil)
  if valid_603863 != nil:
    section.add "X-Amz-Algorithm", valid_603863
  var valid_603864 = header.getOrDefault("X-Amz-Signature")
  valid_603864 = validateParameter(valid_603864, JString, required = false,
                                 default = nil)
  if valid_603864 != nil:
    section.add "X-Amz-Signature", valid_603864
  var valid_603865 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603865 = validateParameter(valid_603865, JString, required = false,
                                 default = nil)
  if valid_603865 != nil:
    section.add "X-Amz-SignedHeaders", valid_603865
  var valid_603866 = header.getOrDefault("X-Amz-Credential")
  valid_603866 = validateParameter(valid_603866, JString, required = false,
                                 default = nil)
  if valid_603866 != nil:
    section.add "X-Amz-Credential", valid_603866
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603867: Call_GetDeleteClusterSecurityGroup_603854; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Deletes an Amazon Redshift security group.</p> <note> <p>You cannot delete a security group that is associated with any clusters. You cannot delete the default security group.</p> </note> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_603867.validator(path, query, header, formData, body)
  let scheme = call_603867.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603867.url(scheme.get, call_603867.host, call_603867.base,
                         call_603867.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_603867, url, valid)

proc call*(call_603868: Call_GetDeleteClusterSecurityGroup_603854;
          ClusterSecurityGroupName: string;
          Action: string = "DeleteClusterSecurityGroup";
          Version: string = "2012-12-01"): Recallable =
  ## getDeleteClusterSecurityGroup
  ## <p>Deletes an Amazon Redshift security group.</p> <note> <p>You cannot delete a security group that is associated with any clusters. You cannot delete the default security group.</p> </note> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   ClusterSecurityGroupName: string (required)
  ##                           : The name of the cluster security group to be deleted.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_603869 = newJObject()
  add(query_603869, "ClusterSecurityGroupName",
      newJString(ClusterSecurityGroupName))
  add(query_603869, "Action", newJString(Action))
  add(query_603869, "Version", newJString(Version))
  result = call_603868.call(nil, query_603869, nil, nil, nil)

var getDeleteClusterSecurityGroup* = Call_GetDeleteClusterSecurityGroup_603854(
    name: "getDeleteClusterSecurityGroup", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteClusterSecurityGroup",
    validator: validate_GetDeleteClusterSecurityGroup_603855, base: "/",
    url: url_GetDeleteClusterSecurityGroup_603856,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDeleteClusterSnapshot_603904 = ref object of OpenApiRestCall_602450
proc url_PostDeleteClusterSnapshot_603906(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostDeleteClusterSnapshot_603905(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Deletes the specified manual snapshot. The snapshot must be in the <code>available</code> state, with no other users authorized to access the snapshot. </p> <p>Unlike automated snapshots, manual snapshots are retained even after you delete your cluster. Amazon Redshift does not delete your manual snapshots. You must delete manual snapshot explicitly to avoid getting charged. If other accounts are authorized to access the snapshot, you must revoke all of the authorizations before you can delete the snapshot.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_603907 = query.getOrDefault("Action")
  valid_603907 = validateParameter(valid_603907, JString, required = true,
                                 default = newJString("DeleteClusterSnapshot"))
  if valid_603907 != nil:
    section.add "Action", valid_603907
  var valid_603908 = query.getOrDefault("Version")
  valid_603908 = validateParameter(valid_603908, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_603908 != nil:
    section.add "Version", valid_603908
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603909 = header.getOrDefault("X-Amz-Date")
  valid_603909 = validateParameter(valid_603909, JString, required = false,
                                 default = nil)
  if valid_603909 != nil:
    section.add "X-Amz-Date", valid_603909
  var valid_603910 = header.getOrDefault("X-Amz-Security-Token")
  valid_603910 = validateParameter(valid_603910, JString, required = false,
                                 default = nil)
  if valid_603910 != nil:
    section.add "X-Amz-Security-Token", valid_603910
  var valid_603911 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603911 = validateParameter(valid_603911, JString, required = false,
                                 default = nil)
  if valid_603911 != nil:
    section.add "X-Amz-Content-Sha256", valid_603911
  var valid_603912 = header.getOrDefault("X-Amz-Algorithm")
  valid_603912 = validateParameter(valid_603912, JString, required = false,
                                 default = nil)
  if valid_603912 != nil:
    section.add "X-Amz-Algorithm", valid_603912
  var valid_603913 = header.getOrDefault("X-Amz-Signature")
  valid_603913 = validateParameter(valid_603913, JString, required = false,
                                 default = nil)
  if valid_603913 != nil:
    section.add "X-Amz-Signature", valid_603913
  var valid_603914 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603914 = validateParameter(valid_603914, JString, required = false,
                                 default = nil)
  if valid_603914 != nil:
    section.add "X-Amz-SignedHeaders", valid_603914
  var valid_603915 = header.getOrDefault("X-Amz-Credential")
  valid_603915 = validateParameter(valid_603915, JString, required = false,
                                 default = nil)
  if valid_603915 != nil:
    section.add "X-Amz-Credential", valid_603915
  result.add "header", section
  ## parameters in `formData` object:
  ##   SnapshotClusterIdentifier: JString
  ##                            : <p>The unique identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.</p> <p>Constraints: Must be the name of valid cluster.</p>
  ##   SnapshotIdentifier: JString (required)
  ##                     : <p>The unique identifier of the manual snapshot to be deleted.</p> <p>Constraints: Must be the name of an existing snapshot that is in the <code>available</code>, <code>failed</code>, or <code>cancelled</code> state.</p>
  section = newJObject()
  var valid_603916 = formData.getOrDefault("SnapshotClusterIdentifier")
  valid_603916 = validateParameter(valid_603916, JString, required = false,
                                 default = nil)
  if valid_603916 != nil:
    section.add "SnapshotClusterIdentifier", valid_603916
  assert formData != nil, "formData argument is necessary due to required `SnapshotIdentifier` field"
  var valid_603917 = formData.getOrDefault("SnapshotIdentifier")
  valid_603917 = validateParameter(valid_603917, JString, required = true,
                                 default = nil)
  if valid_603917 != nil:
    section.add "SnapshotIdentifier", valid_603917
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603918: Call_PostDeleteClusterSnapshot_603904; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Deletes the specified manual snapshot. The snapshot must be in the <code>available</code> state, with no other users authorized to access the snapshot. </p> <p>Unlike automated snapshots, manual snapshots are retained even after you delete your cluster. Amazon Redshift does not delete your manual snapshots. You must delete manual snapshot explicitly to avoid getting charged. If other accounts are authorized to access the snapshot, you must revoke all of the authorizations before you can delete the snapshot.</p>
  ## 
  let valid = call_603918.validator(path, query, header, formData, body)
  let scheme = call_603918.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603918.url(scheme.get, call_603918.host, call_603918.base,
                         call_603918.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_603918, url, valid)

proc call*(call_603919: Call_PostDeleteClusterSnapshot_603904;
          SnapshotIdentifier: string; SnapshotClusterIdentifier: string = "";
          Action: string = "DeleteClusterSnapshot"; Version: string = "2012-12-01"): Recallable =
  ## postDeleteClusterSnapshot
  ## <p>Deletes the specified manual snapshot. The snapshot must be in the <code>available</code> state, with no other users authorized to access the snapshot. </p> <p>Unlike automated snapshots, manual snapshots are retained even after you delete your cluster. Amazon Redshift does not delete your manual snapshots. You must delete manual snapshot explicitly to avoid getting charged. If other accounts are authorized to access the snapshot, you must revoke all of the authorizations before you can delete the snapshot.</p>
  ##   SnapshotClusterIdentifier: string
  ##                            : <p>The unique identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.</p> <p>Constraints: Must be the name of valid cluster.</p>
  ##   Action: string (required)
  ##   SnapshotIdentifier: string (required)
  ##                     : <p>The unique identifier of the manual snapshot to be deleted.</p> <p>Constraints: Must be the name of an existing snapshot that is in the <code>available</code>, <code>failed</code>, or <code>cancelled</code> state.</p>
  ##   Version: string (required)
  var query_603920 = newJObject()
  var formData_603921 = newJObject()
  add(formData_603921, "SnapshotClusterIdentifier",
      newJString(SnapshotClusterIdentifier))
  add(query_603920, "Action", newJString(Action))
  add(formData_603921, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_603920, "Version", newJString(Version))
  result = call_603919.call(nil, query_603920, nil, formData_603921, nil)

var postDeleteClusterSnapshot* = Call_PostDeleteClusterSnapshot_603904(
    name: "postDeleteClusterSnapshot", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteClusterSnapshot",
    validator: validate_PostDeleteClusterSnapshot_603905, base: "/",
    url: url_PostDeleteClusterSnapshot_603906,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeleteClusterSnapshot_603887 = ref object of OpenApiRestCall_602450
proc url_GetDeleteClusterSnapshot_603889(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetDeleteClusterSnapshot_603888(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Deletes the specified manual snapshot. The snapshot must be in the <code>available</code> state, with no other users authorized to access the snapshot. </p> <p>Unlike automated snapshots, manual snapshots are retained even after you delete your cluster. Amazon Redshift does not delete your manual snapshots. You must delete manual snapshot explicitly to avoid getting charged. If other accounts are authorized to access the snapshot, you must revoke all of the authorizations before you can delete the snapshot.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   SnapshotClusterIdentifier: JString
  ##                            : <p>The unique identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.</p> <p>Constraints: Must be the name of valid cluster.</p>
  ##   SnapshotIdentifier: JString (required)
  ##                     : <p>The unique identifier of the manual snapshot to be deleted.</p> <p>Constraints: Must be the name of an existing snapshot that is in the <code>available</code>, <code>failed</code>, or <code>cancelled</code> state.</p>
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_603890 = query.getOrDefault("Action")
  valid_603890 = validateParameter(valid_603890, JString, required = true,
                                 default = newJString("DeleteClusterSnapshot"))
  if valid_603890 != nil:
    section.add "Action", valid_603890
  var valid_603891 = query.getOrDefault("SnapshotClusterIdentifier")
  valid_603891 = validateParameter(valid_603891, JString, required = false,
                                 default = nil)
  if valid_603891 != nil:
    section.add "SnapshotClusterIdentifier", valid_603891
  var valid_603892 = query.getOrDefault("SnapshotIdentifier")
  valid_603892 = validateParameter(valid_603892, JString, required = true,
                                 default = nil)
  if valid_603892 != nil:
    section.add "SnapshotIdentifier", valid_603892
  var valid_603893 = query.getOrDefault("Version")
  valid_603893 = validateParameter(valid_603893, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_603893 != nil:
    section.add "Version", valid_603893
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603894 = header.getOrDefault("X-Amz-Date")
  valid_603894 = validateParameter(valid_603894, JString, required = false,
                                 default = nil)
  if valid_603894 != nil:
    section.add "X-Amz-Date", valid_603894
  var valid_603895 = header.getOrDefault("X-Amz-Security-Token")
  valid_603895 = validateParameter(valid_603895, JString, required = false,
                                 default = nil)
  if valid_603895 != nil:
    section.add "X-Amz-Security-Token", valid_603895
  var valid_603896 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603896 = validateParameter(valid_603896, JString, required = false,
                                 default = nil)
  if valid_603896 != nil:
    section.add "X-Amz-Content-Sha256", valid_603896
  var valid_603897 = header.getOrDefault("X-Amz-Algorithm")
  valid_603897 = validateParameter(valid_603897, JString, required = false,
                                 default = nil)
  if valid_603897 != nil:
    section.add "X-Amz-Algorithm", valid_603897
  var valid_603898 = header.getOrDefault("X-Amz-Signature")
  valid_603898 = validateParameter(valid_603898, JString, required = false,
                                 default = nil)
  if valid_603898 != nil:
    section.add "X-Amz-Signature", valid_603898
  var valid_603899 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603899 = validateParameter(valid_603899, JString, required = false,
                                 default = nil)
  if valid_603899 != nil:
    section.add "X-Amz-SignedHeaders", valid_603899
  var valid_603900 = header.getOrDefault("X-Amz-Credential")
  valid_603900 = validateParameter(valid_603900, JString, required = false,
                                 default = nil)
  if valid_603900 != nil:
    section.add "X-Amz-Credential", valid_603900
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603901: Call_GetDeleteClusterSnapshot_603887; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Deletes the specified manual snapshot. The snapshot must be in the <code>available</code> state, with no other users authorized to access the snapshot. </p> <p>Unlike automated snapshots, manual snapshots are retained even after you delete your cluster. Amazon Redshift does not delete your manual snapshots. You must delete manual snapshot explicitly to avoid getting charged. If other accounts are authorized to access the snapshot, you must revoke all of the authorizations before you can delete the snapshot.</p>
  ## 
  let valid = call_603901.validator(path, query, header, formData, body)
  let scheme = call_603901.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603901.url(scheme.get, call_603901.host, call_603901.base,
                         call_603901.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_603901, url, valid)

proc call*(call_603902: Call_GetDeleteClusterSnapshot_603887;
          SnapshotIdentifier: string; Action: string = "DeleteClusterSnapshot";
          SnapshotClusterIdentifier: string = ""; Version: string = "2012-12-01"): Recallable =
  ## getDeleteClusterSnapshot
  ## <p>Deletes the specified manual snapshot. The snapshot must be in the <code>available</code> state, with no other users authorized to access the snapshot. </p> <p>Unlike automated snapshots, manual snapshots are retained even after you delete your cluster. Amazon Redshift does not delete your manual snapshots. You must delete manual snapshot explicitly to avoid getting charged. If other accounts are authorized to access the snapshot, you must revoke all of the authorizations before you can delete the snapshot.</p>
  ##   Action: string (required)
  ##   SnapshotClusterIdentifier: string
  ##                            : <p>The unique identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.</p> <p>Constraints: Must be the name of valid cluster.</p>
  ##   SnapshotIdentifier: string (required)
  ##                     : <p>The unique identifier of the manual snapshot to be deleted.</p> <p>Constraints: Must be the name of an existing snapshot that is in the <code>available</code>, <code>failed</code>, or <code>cancelled</code> state.</p>
  ##   Version: string (required)
  var query_603903 = newJObject()
  add(query_603903, "Action", newJString(Action))
  add(query_603903, "SnapshotClusterIdentifier",
      newJString(SnapshotClusterIdentifier))
  add(query_603903, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_603903, "Version", newJString(Version))
  result = call_603902.call(nil, query_603903, nil, nil, nil)

var getDeleteClusterSnapshot* = Call_GetDeleteClusterSnapshot_603887(
    name: "getDeleteClusterSnapshot", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteClusterSnapshot",
    validator: validate_GetDeleteClusterSnapshot_603888, base: "/",
    url: url_GetDeleteClusterSnapshot_603889, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDeleteClusterSubnetGroup_603938 = ref object of OpenApiRestCall_602450
proc url_PostDeleteClusterSubnetGroup_603940(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostDeleteClusterSubnetGroup_603939(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes the specified cluster subnet group.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_603941 = query.getOrDefault("Action")
  valid_603941 = validateParameter(valid_603941, JString, required = true, default = newJString(
      "DeleteClusterSubnetGroup"))
  if valid_603941 != nil:
    section.add "Action", valid_603941
  var valid_603942 = query.getOrDefault("Version")
  valid_603942 = validateParameter(valid_603942, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_603942 != nil:
    section.add "Version", valid_603942
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603943 = header.getOrDefault("X-Amz-Date")
  valid_603943 = validateParameter(valid_603943, JString, required = false,
                                 default = nil)
  if valid_603943 != nil:
    section.add "X-Amz-Date", valid_603943
  var valid_603944 = header.getOrDefault("X-Amz-Security-Token")
  valid_603944 = validateParameter(valid_603944, JString, required = false,
                                 default = nil)
  if valid_603944 != nil:
    section.add "X-Amz-Security-Token", valid_603944
  var valid_603945 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603945 = validateParameter(valid_603945, JString, required = false,
                                 default = nil)
  if valid_603945 != nil:
    section.add "X-Amz-Content-Sha256", valid_603945
  var valid_603946 = header.getOrDefault("X-Amz-Algorithm")
  valid_603946 = validateParameter(valid_603946, JString, required = false,
                                 default = nil)
  if valid_603946 != nil:
    section.add "X-Amz-Algorithm", valid_603946
  var valid_603947 = header.getOrDefault("X-Amz-Signature")
  valid_603947 = validateParameter(valid_603947, JString, required = false,
                                 default = nil)
  if valid_603947 != nil:
    section.add "X-Amz-Signature", valid_603947
  var valid_603948 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603948 = validateParameter(valid_603948, JString, required = false,
                                 default = nil)
  if valid_603948 != nil:
    section.add "X-Amz-SignedHeaders", valid_603948
  var valid_603949 = header.getOrDefault("X-Amz-Credential")
  valid_603949 = validateParameter(valid_603949, JString, required = false,
                                 default = nil)
  if valid_603949 != nil:
    section.add "X-Amz-Credential", valid_603949
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterSubnetGroupName: JString (required)
  ##                         : The name of the cluster subnet group name to be deleted.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterSubnetGroupName` field"
  var valid_603950 = formData.getOrDefault("ClusterSubnetGroupName")
  valid_603950 = validateParameter(valid_603950, JString, required = true,
                                 default = nil)
  if valid_603950 != nil:
    section.add "ClusterSubnetGroupName", valid_603950
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603951: Call_PostDeleteClusterSubnetGroup_603938; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes the specified cluster subnet group.
  ## 
  let valid = call_603951.validator(path, query, header, formData, body)
  let scheme = call_603951.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603951.url(scheme.get, call_603951.host, call_603951.base,
                         call_603951.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_603951, url, valid)

proc call*(call_603952: Call_PostDeleteClusterSubnetGroup_603938;
          ClusterSubnetGroupName: string;
          Action: string = "DeleteClusterSubnetGroup";
          Version: string = "2012-12-01"): Recallable =
  ## postDeleteClusterSubnetGroup
  ## Deletes the specified cluster subnet group.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   ClusterSubnetGroupName: string (required)
  ##                         : The name of the cluster subnet group name to be deleted.
  var query_603953 = newJObject()
  var formData_603954 = newJObject()
  add(query_603953, "Action", newJString(Action))
  add(query_603953, "Version", newJString(Version))
  add(formData_603954, "ClusterSubnetGroupName",
      newJString(ClusterSubnetGroupName))
  result = call_603952.call(nil, query_603953, nil, formData_603954, nil)

var postDeleteClusterSubnetGroup* = Call_PostDeleteClusterSubnetGroup_603938(
    name: "postDeleteClusterSubnetGroup", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteClusterSubnetGroup",
    validator: validate_PostDeleteClusterSubnetGroup_603939, base: "/",
    url: url_PostDeleteClusterSubnetGroup_603940,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeleteClusterSubnetGroup_603922 = ref object of OpenApiRestCall_602450
proc url_GetDeleteClusterSubnetGroup_603924(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetDeleteClusterSubnetGroup_603923(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes the specified cluster subnet group.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ClusterSubnetGroupName: JString (required)
  ##                         : The name of the cluster subnet group name to be deleted.
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `ClusterSubnetGroupName` field"
  var valid_603925 = query.getOrDefault("ClusterSubnetGroupName")
  valid_603925 = validateParameter(valid_603925, JString, required = true,
                                 default = nil)
  if valid_603925 != nil:
    section.add "ClusterSubnetGroupName", valid_603925
  var valid_603926 = query.getOrDefault("Action")
  valid_603926 = validateParameter(valid_603926, JString, required = true, default = newJString(
      "DeleteClusterSubnetGroup"))
  if valid_603926 != nil:
    section.add "Action", valid_603926
  var valid_603927 = query.getOrDefault("Version")
  valid_603927 = validateParameter(valid_603927, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_603927 != nil:
    section.add "Version", valid_603927
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603928 = header.getOrDefault("X-Amz-Date")
  valid_603928 = validateParameter(valid_603928, JString, required = false,
                                 default = nil)
  if valid_603928 != nil:
    section.add "X-Amz-Date", valid_603928
  var valid_603929 = header.getOrDefault("X-Amz-Security-Token")
  valid_603929 = validateParameter(valid_603929, JString, required = false,
                                 default = nil)
  if valid_603929 != nil:
    section.add "X-Amz-Security-Token", valid_603929
  var valid_603930 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603930 = validateParameter(valid_603930, JString, required = false,
                                 default = nil)
  if valid_603930 != nil:
    section.add "X-Amz-Content-Sha256", valid_603930
  var valid_603931 = header.getOrDefault("X-Amz-Algorithm")
  valid_603931 = validateParameter(valid_603931, JString, required = false,
                                 default = nil)
  if valid_603931 != nil:
    section.add "X-Amz-Algorithm", valid_603931
  var valid_603932 = header.getOrDefault("X-Amz-Signature")
  valid_603932 = validateParameter(valid_603932, JString, required = false,
                                 default = nil)
  if valid_603932 != nil:
    section.add "X-Amz-Signature", valid_603932
  var valid_603933 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603933 = validateParameter(valid_603933, JString, required = false,
                                 default = nil)
  if valid_603933 != nil:
    section.add "X-Amz-SignedHeaders", valid_603933
  var valid_603934 = header.getOrDefault("X-Amz-Credential")
  valid_603934 = validateParameter(valid_603934, JString, required = false,
                                 default = nil)
  if valid_603934 != nil:
    section.add "X-Amz-Credential", valid_603934
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603935: Call_GetDeleteClusterSubnetGroup_603922; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes the specified cluster subnet group.
  ## 
  let valid = call_603935.validator(path, query, header, formData, body)
  let scheme = call_603935.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603935.url(scheme.get, call_603935.host, call_603935.base,
                         call_603935.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_603935, url, valid)

proc call*(call_603936: Call_GetDeleteClusterSubnetGroup_603922;
          ClusterSubnetGroupName: string;
          Action: string = "DeleteClusterSubnetGroup";
          Version: string = "2012-12-01"): Recallable =
  ## getDeleteClusterSubnetGroup
  ## Deletes the specified cluster subnet group.
  ##   ClusterSubnetGroupName: string (required)
  ##                         : The name of the cluster subnet group name to be deleted.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_603937 = newJObject()
  add(query_603937, "ClusterSubnetGroupName", newJString(ClusterSubnetGroupName))
  add(query_603937, "Action", newJString(Action))
  add(query_603937, "Version", newJString(Version))
  result = call_603936.call(nil, query_603937, nil, nil, nil)

var getDeleteClusterSubnetGroup* = Call_GetDeleteClusterSubnetGroup_603922(
    name: "getDeleteClusterSubnetGroup", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteClusterSubnetGroup",
    validator: validate_GetDeleteClusterSubnetGroup_603923, base: "/",
    url: url_GetDeleteClusterSubnetGroup_603924,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDeleteEventSubscription_603971 = ref object of OpenApiRestCall_602450
proc url_PostDeleteEventSubscription_603973(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostDeleteEventSubscription_603972(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes an Amazon Redshift event notification subscription.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_603974 = query.getOrDefault("Action")
  valid_603974 = validateParameter(valid_603974, JString, required = true, default = newJString(
      "DeleteEventSubscription"))
  if valid_603974 != nil:
    section.add "Action", valid_603974
  var valid_603975 = query.getOrDefault("Version")
  valid_603975 = validateParameter(valid_603975, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_603975 != nil:
    section.add "Version", valid_603975
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603976 = header.getOrDefault("X-Amz-Date")
  valid_603976 = validateParameter(valid_603976, JString, required = false,
                                 default = nil)
  if valid_603976 != nil:
    section.add "X-Amz-Date", valid_603976
  var valid_603977 = header.getOrDefault("X-Amz-Security-Token")
  valid_603977 = validateParameter(valid_603977, JString, required = false,
                                 default = nil)
  if valid_603977 != nil:
    section.add "X-Amz-Security-Token", valid_603977
  var valid_603978 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603978 = validateParameter(valid_603978, JString, required = false,
                                 default = nil)
  if valid_603978 != nil:
    section.add "X-Amz-Content-Sha256", valid_603978
  var valid_603979 = header.getOrDefault("X-Amz-Algorithm")
  valid_603979 = validateParameter(valid_603979, JString, required = false,
                                 default = nil)
  if valid_603979 != nil:
    section.add "X-Amz-Algorithm", valid_603979
  var valid_603980 = header.getOrDefault("X-Amz-Signature")
  valid_603980 = validateParameter(valid_603980, JString, required = false,
                                 default = nil)
  if valid_603980 != nil:
    section.add "X-Amz-Signature", valid_603980
  var valid_603981 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603981 = validateParameter(valid_603981, JString, required = false,
                                 default = nil)
  if valid_603981 != nil:
    section.add "X-Amz-SignedHeaders", valid_603981
  var valid_603982 = header.getOrDefault("X-Amz-Credential")
  valid_603982 = validateParameter(valid_603982, JString, required = false,
                                 default = nil)
  if valid_603982 != nil:
    section.add "X-Amz-Credential", valid_603982
  result.add "header", section
  ## parameters in `formData` object:
  ##   SubscriptionName: JString (required)
  ##                   : The name of the Amazon Redshift event notification subscription to be deleted.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `SubscriptionName` field"
  var valid_603983 = formData.getOrDefault("SubscriptionName")
  valid_603983 = validateParameter(valid_603983, JString, required = true,
                                 default = nil)
  if valid_603983 != nil:
    section.add "SubscriptionName", valid_603983
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603984: Call_PostDeleteEventSubscription_603971; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes an Amazon Redshift event notification subscription.
  ## 
  let valid = call_603984.validator(path, query, header, formData, body)
  let scheme = call_603984.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603984.url(scheme.get, call_603984.host, call_603984.base,
                         call_603984.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_603984, url, valid)

proc call*(call_603985: Call_PostDeleteEventSubscription_603971;
          SubscriptionName: string; Action: string = "DeleteEventSubscription";
          Version: string = "2012-12-01"): Recallable =
  ## postDeleteEventSubscription
  ## Deletes an Amazon Redshift event notification subscription.
  ##   SubscriptionName: string (required)
  ##                   : The name of the Amazon Redshift event notification subscription to be deleted.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_603986 = newJObject()
  var formData_603987 = newJObject()
  add(formData_603987, "SubscriptionName", newJString(SubscriptionName))
  add(query_603986, "Action", newJString(Action))
  add(query_603986, "Version", newJString(Version))
  result = call_603985.call(nil, query_603986, nil, formData_603987, nil)

var postDeleteEventSubscription* = Call_PostDeleteEventSubscription_603971(
    name: "postDeleteEventSubscription", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteEventSubscription",
    validator: validate_PostDeleteEventSubscription_603972, base: "/",
    url: url_PostDeleteEventSubscription_603973,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeleteEventSubscription_603955 = ref object of OpenApiRestCall_602450
proc url_GetDeleteEventSubscription_603957(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetDeleteEventSubscription_603956(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes an Amazon Redshift event notification subscription.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   SubscriptionName: JString (required)
  ##                   : The name of the Amazon Redshift event notification subscription to be deleted.
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_603958 = query.getOrDefault("Action")
  valid_603958 = validateParameter(valid_603958, JString, required = true, default = newJString(
      "DeleteEventSubscription"))
  if valid_603958 != nil:
    section.add "Action", valid_603958
  var valid_603959 = query.getOrDefault("SubscriptionName")
  valid_603959 = validateParameter(valid_603959, JString, required = true,
                                 default = nil)
  if valid_603959 != nil:
    section.add "SubscriptionName", valid_603959
  var valid_603960 = query.getOrDefault("Version")
  valid_603960 = validateParameter(valid_603960, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_603960 != nil:
    section.add "Version", valid_603960
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603961 = header.getOrDefault("X-Amz-Date")
  valid_603961 = validateParameter(valid_603961, JString, required = false,
                                 default = nil)
  if valid_603961 != nil:
    section.add "X-Amz-Date", valid_603961
  var valid_603962 = header.getOrDefault("X-Amz-Security-Token")
  valid_603962 = validateParameter(valid_603962, JString, required = false,
                                 default = nil)
  if valid_603962 != nil:
    section.add "X-Amz-Security-Token", valid_603962
  var valid_603963 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603963 = validateParameter(valid_603963, JString, required = false,
                                 default = nil)
  if valid_603963 != nil:
    section.add "X-Amz-Content-Sha256", valid_603963
  var valid_603964 = header.getOrDefault("X-Amz-Algorithm")
  valid_603964 = validateParameter(valid_603964, JString, required = false,
                                 default = nil)
  if valid_603964 != nil:
    section.add "X-Amz-Algorithm", valid_603964
  var valid_603965 = header.getOrDefault("X-Amz-Signature")
  valid_603965 = validateParameter(valid_603965, JString, required = false,
                                 default = nil)
  if valid_603965 != nil:
    section.add "X-Amz-Signature", valid_603965
  var valid_603966 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603966 = validateParameter(valid_603966, JString, required = false,
                                 default = nil)
  if valid_603966 != nil:
    section.add "X-Amz-SignedHeaders", valid_603966
  var valid_603967 = header.getOrDefault("X-Amz-Credential")
  valid_603967 = validateParameter(valid_603967, JString, required = false,
                                 default = nil)
  if valid_603967 != nil:
    section.add "X-Amz-Credential", valid_603967
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603968: Call_GetDeleteEventSubscription_603955; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes an Amazon Redshift event notification subscription.
  ## 
  let valid = call_603968.validator(path, query, header, formData, body)
  let scheme = call_603968.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603968.url(scheme.get, call_603968.host, call_603968.base,
                         call_603968.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_603968, url, valid)

proc call*(call_603969: Call_GetDeleteEventSubscription_603955;
          SubscriptionName: string; Action: string = "DeleteEventSubscription";
          Version: string = "2012-12-01"): Recallable =
  ## getDeleteEventSubscription
  ## Deletes an Amazon Redshift event notification subscription.
  ##   Action: string (required)
  ##   SubscriptionName: string (required)
  ##                   : The name of the Amazon Redshift event notification subscription to be deleted.
  ##   Version: string (required)
  var query_603970 = newJObject()
  add(query_603970, "Action", newJString(Action))
  add(query_603970, "SubscriptionName", newJString(SubscriptionName))
  add(query_603970, "Version", newJString(Version))
  result = call_603969.call(nil, query_603970, nil, nil, nil)

var getDeleteEventSubscription* = Call_GetDeleteEventSubscription_603955(
    name: "getDeleteEventSubscription", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteEventSubscription",
    validator: validate_GetDeleteEventSubscription_603956, base: "/",
    url: url_GetDeleteEventSubscription_603957,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDeleteHsmClientCertificate_604004 = ref object of OpenApiRestCall_602450
proc url_PostDeleteHsmClientCertificate_604006(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostDeleteHsmClientCertificate_604005(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes the specified HSM client certificate.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_604007 = query.getOrDefault("Action")
  valid_604007 = validateParameter(valid_604007, JString, required = true, default = newJString(
      "DeleteHsmClientCertificate"))
  if valid_604007 != nil:
    section.add "Action", valid_604007
  var valid_604008 = query.getOrDefault("Version")
  valid_604008 = validateParameter(valid_604008, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_604008 != nil:
    section.add "Version", valid_604008
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_604009 = header.getOrDefault("X-Amz-Date")
  valid_604009 = validateParameter(valid_604009, JString, required = false,
                                 default = nil)
  if valid_604009 != nil:
    section.add "X-Amz-Date", valid_604009
  var valid_604010 = header.getOrDefault("X-Amz-Security-Token")
  valid_604010 = validateParameter(valid_604010, JString, required = false,
                                 default = nil)
  if valid_604010 != nil:
    section.add "X-Amz-Security-Token", valid_604010
  var valid_604011 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604011 = validateParameter(valid_604011, JString, required = false,
                                 default = nil)
  if valid_604011 != nil:
    section.add "X-Amz-Content-Sha256", valid_604011
  var valid_604012 = header.getOrDefault("X-Amz-Algorithm")
  valid_604012 = validateParameter(valid_604012, JString, required = false,
                                 default = nil)
  if valid_604012 != nil:
    section.add "X-Amz-Algorithm", valid_604012
  var valid_604013 = header.getOrDefault("X-Amz-Signature")
  valid_604013 = validateParameter(valid_604013, JString, required = false,
                                 default = nil)
  if valid_604013 != nil:
    section.add "X-Amz-Signature", valid_604013
  var valid_604014 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604014 = validateParameter(valid_604014, JString, required = false,
                                 default = nil)
  if valid_604014 != nil:
    section.add "X-Amz-SignedHeaders", valid_604014
  var valid_604015 = header.getOrDefault("X-Amz-Credential")
  valid_604015 = validateParameter(valid_604015, JString, required = false,
                                 default = nil)
  if valid_604015 != nil:
    section.add "X-Amz-Credential", valid_604015
  result.add "header", section
  ## parameters in `formData` object:
  ##   HsmClientCertificateIdentifier: JString (required)
  ##                                 : The identifier of the HSM client certificate to be deleted.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `HsmClientCertificateIdentifier` field"
  var valid_604016 = formData.getOrDefault("HsmClientCertificateIdentifier")
  valid_604016 = validateParameter(valid_604016, JString, required = true,
                                 default = nil)
  if valid_604016 != nil:
    section.add "HsmClientCertificateIdentifier", valid_604016
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604017: Call_PostDeleteHsmClientCertificate_604004; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes the specified HSM client certificate.
  ## 
  let valid = call_604017.validator(path, query, header, formData, body)
  let scheme = call_604017.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604017.url(scheme.get, call_604017.host, call_604017.base,
                         call_604017.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_604017, url, valid)

proc call*(call_604018: Call_PostDeleteHsmClientCertificate_604004;
          HsmClientCertificateIdentifier: string;
          Action: string = "DeleteHsmClientCertificate";
          Version: string = "2012-12-01"): Recallable =
  ## postDeleteHsmClientCertificate
  ## Deletes the specified HSM client certificate.
  ##   Action: string (required)
  ##   HsmClientCertificateIdentifier: string (required)
  ##                                 : The identifier of the HSM client certificate to be deleted.
  ##   Version: string (required)
  var query_604019 = newJObject()
  var formData_604020 = newJObject()
  add(query_604019, "Action", newJString(Action))
  add(formData_604020, "HsmClientCertificateIdentifier",
      newJString(HsmClientCertificateIdentifier))
  add(query_604019, "Version", newJString(Version))
  result = call_604018.call(nil, query_604019, nil, formData_604020, nil)

var postDeleteHsmClientCertificate* = Call_PostDeleteHsmClientCertificate_604004(
    name: "postDeleteHsmClientCertificate", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteHsmClientCertificate",
    validator: validate_PostDeleteHsmClientCertificate_604005, base: "/",
    url: url_PostDeleteHsmClientCertificate_604006,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeleteHsmClientCertificate_603988 = ref object of OpenApiRestCall_602450
proc url_GetDeleteHsmClientCertificate_603990(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetDeleteHsmClientCertificate_603989(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes the specified HSM client certificate.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   HsmClientCertificateIdentifier: JString (required)
  ##                                 : The identifier of the HSM client certificate to be deleted.
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `HsmClientCertificateIdentifier` field"
  var valid_603991 = query.getOrDefault("HsmClientCertificateIdentifier")
  valid_603991 = validateParameter(valid_603991, JString, required = true,
                                 default = nil)
  if valid_603991 != nil:
    section.add "HsmClientCertificateIdentifier", valid_603991
  var valid_603992 = query.getOrDefault("Action")
  valid_603992 = validateParameter(valid_603992, JString, required = true, default = newJString(
      "DeleteHsmClientCertificate"))
  if valid_603992 != nil:
    section.add "Action", valid_603992
  var valid_603993 = query.getOrDefault("Version")
  valid_603993 = validateParameter(valid_603993, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_603993 != nil:
    section.add "Version", valid_603993
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603994 = header.getOrDefault("X-Amz-Date")
  valid_603994 = validateParameter(valid_603994, JString, required = false,
                                 default = nil)
  if valid_603994 != nil:
    section.add "X-Amz-Date", valid_603994
  var valid_603995 = header.getOrDefault("X-Amz-Security-Token")
  valid_603995 = validateParameter(valid_603995, JString, required = false,
                                 default = nil)
  if valid_603995 != nil:
    section.add "X-Amz-Security-Token", valid_603995
  var valid_603996 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603996 = validateParameter(valid_603996, JString, required = false,
                                 default = nil)
  if valid_603996 != nil:
    section.add "X-Amz-Content-Sha256", valid_603996
  var valid_603997 = header.getOrDefault("X-Amz-Algorithm")
  valid_603997 = validateParameter(valid_603997, JString, required = false,
                                 default = nil)
  if valid_603997 != nil:
    section.add "X-Amz-Algorithm", valid_603997
  var valid_603998 = header.getOrDefault("X-Amz-Signature")
  valid_603998 = validateParameter(valid_603998, JString, required = false,
                                 default = nil)
  if valid_603998 != nil:
    section.add "X-Amz-Signature", valid_603998
  var valid_603999 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603999 = validateParameter(valid_603999, JString, required = false,
                                 default = nil)
  if valid_603999 != nil:
    section.add "X-Amz-SignedHeaders", valid_603999
  var valid_604000 = header.getOrDefault("X-Amz-Credential")
  valid_604000 = validateParameter(valid_604000, JString, required = false,
                                 default = nil)
  if valid_604000 != nil:
    section.add "X-Amz-Credential", valid_604000
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604001: Call_GetDeleteHsmClientCertificate_603988; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes the specified HSM client certificate.
  ## 
  let valid = call_604001.validator(path, query, header, formData, body)
  let scheme = call_604001.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604001.url(scheme.get, call_604001.host, call_604001.base,
                         call_604001.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_604001, url, valid)

proc call*(call_604002: Call_GetDeleteHsmClientCertificate_603988;
          HsmClientCertificateIdentifier: string;
          Action: string = "DeleteHsmClientCertificate";
          Version: string = "2012-12-01"): Recallable =
  ## getDeleteHsmClientCertificate
  ## Deletes the specified HSM client certificate.
  ##   HsmClientCertificateIdentifier: string (required)
  ##                                 : The identifier of the HSM client certificate to be deleted.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_604003 = newJObject()
  add(query_604003, "HsmClientCertificateIdentifier",
      newJString(HsmClientCertificateIdentifier))
  add(query_604003, "Action", newJString(Action))
  add(query_604003, "Version", newJString(Version))
  result = call_604002.call(nil, query_604003, nil, nil, nil)

var getDeleteHsmClientCertificate* = Call_GetDeleteHsmClientCertificate_603988(
    name: "getDeleteHsmClientCertificate", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteHsmClientCertificate",
    validator: validate_GetDeleteHsmClientCertificate_603989, base: "/",
    url: url_GetDeleteHsmClientCertificate_603990,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDeleteHsmConfiguration_604037 = ref object of OpenApiRestCall_602450
proc url_PostDeleteHsmConfiguration_604039(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostDeleteHsmConfiguration_604038(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes the specified Amazon Redshift HSM configuration.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_604040 = query.getOrDefault("Action")
  valid_604040 = validateParameter(valid_604040, JString, required = true,
                                 default = newJString("DeleteHsmConfiguration"))
  if valid_604040 != nil:
    section.add "Action", valid_604040
  var valid_604041 = query.getOrDefault("Version")
  valid_604041 = validateParameter(valid_604041, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_604041 != nil:
    section.add "Version", valid_604041
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_604042 = header.getOrDefault("X-Amz-Date")
  valid_604042 = validateParameter(valid_604042, JString, required = false,
                                 default = nil)
  if valid_604042 != nil:
    section.add "X-Amz-Date", valid_604042
  var valid_604043 = header.getOrDefault("X-Amz-Security-Token")
  valid_604043 = validateParameter(valid_604043, JString, required = false,
                                 default = nil)
  if valid_604043 != nil:
    section.add "X-Amz-Security-Token", valid_604043
  var valid_604044 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604044 = validateParameter(valid_604044, JString, required = false,
                                 default = nil)
  if valid_604044 != nil:
    section.add "X-Amz-Content-Sha256", valid_604044
  var valid_604045 = header.getOrDefault("X-Amz-Algorithm")
  valid_604045 = validateParameter(valid_604045, JString, required = false,
                                 default = nil)
  if valid_604045 != nil:
    section.add "X-Amz-Algorithm", valid_604045
  var valid_604046 = header.getOrDefault("X-Amz-Signature")
  valid_604046 = validateParameter(valid_604046, JString, required = false,
                                 default = nil)
  if valid_604046 != nil:
    section.add "X-Amz-Signature", valid_604046
  var valid_604047 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604047 = validateParameter(valid_604047, JString, required = false,
                                 default = nil)
  if valid_604047 != nil:
    section.add "X-Amz-SignedHeaders", valid_604047
  var valid_604048 = header.getOrDefault("X-Amz-Credential")
  valid_604048 = validateParameter(valid_604048, JString, required = false,
                                 default = nil)
  if valid_604048 != nil:
    section.add "X-Amz-Credential", valid_604048
  result.add "header", section
  ## parameters in `formData` object:
  ##   HsmConfigurationIdentifier: JString (required)
  ##                             : The identifier of the Amazon Redshift HSM configuration to be deleted.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `HsmConfigurationIdentifier` field"
  var valid_604049 = formData.getOrDefault("HsmConfigurationIdentifier")
  valid_604049 = validateParameter(valid_604049, JString, required = true,
                                 default = nil)
  if valid_604049 != nil:
    section.add "HsmConfigurationIdentifier", valid_604049
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604050: Call_PostDeleteHsmConfiguration_604037; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes the specified Amazon Redshift HSM configuration.
  ## 
  let valid = call_604050.validator(path, query, header, formData, body)
  let scheme = call_604050.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604050.url(scheme.get, call_604050.host, call_604050.base,
                         call_604050.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_604050, url, valid)

proc call*(call_604051: Call_PostDeleteHsmConfiguration_604037;
          HsmConfigurationIdentifier: string;
          Action: string = "DeleteHsmConfiguration"; Version: string = "2012-12-01"): Recallable =
  ## postDeleteHsmConfiguration
  ## Deletes the specified Amazon Redshift HSM configuration.
  ##   HsmConfigurationIdentifier: string (required)
  ##                             : The identifier of the Amazon Redshift HSM configuration to be deleted.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_604052 = newJObject()
  var formData_604053 = newJObject()
  add(formData_604053, "HsmConfigurationIdentifier",
      newJString(HsmConfigurationIdentifier))
  add(query_604052, "Action", newJString(Action))
  add(query_604052, "Version", newJString(Version))
  result = call_604051.call(nil, query_604052, nil, formData_604053, nil)

var postDeleteHsmConfiguration* = Call_PostDeleteHsmConfiguration_604037(
    name: "postDeleteHsmConfiguration", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteHsmConfiguration",
    validator: validate_PostDeleteHsmConfiguration_604038, base: "/",
    url: url_PostDeleteHsmConfiguration_604039,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeleteHsmConfiguration_604021 = ref object of OpenApiRestCall_602450
proc url_GetDeleteHsmConfiguration_604023(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetDeleteHsmConfiguration_604022(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes the specified Amazon Redshift HSM configuration.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   HsmConfigurationIdentifier: JString (required)
  ##                             : The identifier of the Amazon Redshift HSM configuration to be deleted.
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `HsmConfigurationIdentifier` field"
  var valid_604024 = query.getOrDefault("HsmConfigurationIdentifier")
  valid_604024 = validateParameter(valid_604024, JString, required = true,
                                 default = nil)
  if valid_604024 != nil:
    section.add "HsmConfigurationIdentifier", valid_604024
  var valid_604025 = query.getOrDefault("Action")
  valid_604025 = validateParameter(valid_604025, JString, required = true,
                                 default = newJString("DeleteHsmConfiguration"))
  if valid_604025 != nil:
    section.add "Action", valid_604025
  var valid_604026 = query.getOrDefault("Version")
  valid_604026 = validateParameter(valid_604026, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_604026 != nil:
    section.add "Version", valid_604026
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_604027 = header.getOrDefault("X-Amz-Date")
  valid_604027 = validateParameter(valid_604027, JString, required = false,
                                 default = nil)
  if valid_604027 != nil:
    section.add "X-Amz-Date", valid_604027
  var valid_604028 = header.getOrDefault("X-Amz-Security-Token")
  valid_604028 = validateParameter(valid_604028, JString, required = false,
                                 default = nil)
  if valid_604028 != nil:
    section.add "X-Amz-Security-Token", valid_604028
  var valid_604029 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604029 = validateParameter(valid_604029, JString, required = false,
                                 default = nil)
  if valid_604029 != nil:
    section.add "X-Amz-Content-Sha256", valid_604029
  var valid_604030 = header.getOrDefault("X-Amz-Algorithm")
  valid_604030 = validateParameter(valid_604030, JString, required = false,
                                 default = nil)
  if valid_604030 != nil:
    section.add "X-Amz-Algorithm", valid_604030
  var valid_604031 = header.getOrDefault("X-Amz-Signature")
  valid_604031 = validateParameter(valid_604031, JString, required = false,
                                 default = nil)
  if valid_604031 != nil:
    section.add "X-Amz-Signature", valid_604031
  var valid_604032 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604032 = validateParameter(valid_604032, JString, required = false,
                                 default = nil)
  if valid_604032 != nil:
    section.add "X-Amz-SignedHeaders", valid_604032
  var valid_604033 = header.getOrDefault("X-Amz-Credential")
  valid_604033 = validateParameter(valid_604033, JString, required = false,
                                 default = nil)
  if valid_604033 != nil:
    section.add "X-Amz-Credential", valid_604033
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604034: Call_GetDeleteHsmConfiguration_604021; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes the specified Amazon Redshift HSM configuration.
  ## 
  let valid = call_604034.validator(path, query, header, formData, body)
  let scheme = call_604034.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604034.url(scheme.get, call_604034.host, call_604034.base,
                         call_604034.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_604034, url, valid)

proc call*(call_604035: Call_GetDeleteHsmConfiguration_604021;
          HsmConfigurationIdentifier: string;
          Action: string = "DeleteHsmConfiguration"; Version: string = "2012-12-01"): Recallable =
  ## getDeleteHsmConfiguration
  ## Deletes the specified Amazon Redshift HSM configuration.
  ##   HsmConfigurationIdentifier: string (required)
  ##                             : The identifier of the Amazon Redshift HSM configuration to be deleted.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_604036 = newJObject()
  add(query_604036, "HsmConfigurationIdentifier",
      newJString(HsmConfigurationIdentifier))
  add(query_604036, "Action", newJString(Action))
  add(query_604036, "Version", newJString(Version))
  result = call_604035.call(nil, query_604036, nil, nil, nil)

var getDeleteHsmConfiguration* = Call_GetDeleteHsmConfiguration_604021(
    name: "getDeleteHsmConfiguration", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteHsmConfiguration",
    validator: validate_GetDeleteHsmConfiguration_604022, base: "/",
    url: url_GetDeleteHsmConfiguration_604023,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDeleteSnapshotCopyGrant_604070 = ref object of OpenApiRestCall_602450
proc url_PostDeleteSnapshotCopyGrant_604072(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostDeleteSnapshotCopyGrant_604071(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes the specified snapshot copy grant.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_604073 = query.getOrDefault("Action")
  valid_604073 = validateParameter(valid_604073, JString, required = true, default = newJString(
      "DeleteSnapshotCopyGrant"))
  if valid_604073 != nil:
    section.add "Action", valid_604073
  var valid_604074 = query.getOrDefault("Version")
  valid_604074 = validateParameter(valid_604074, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_604074 != nil:
    section.add "Version", valid_604074
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_604075 = header.getOrDefault("X-Amz-Date")
  valid_604075 = validateParameter(valid_604075, JString, required = false,
                                 default = nil)
  if valid_604075 != nil:
    section.add "X-Amz-Date", valid_604075
  var valid_604076 = header.getOrDefault("X-Amz-Security-Token")
  valid_604076 = validateParameter(valid_604076, JString, required = false,
                                 default = nil)
  if valid_604076 != nil:
    section.add "X-Amz-Security-Token", valid_604076
  var valid_604077 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604077 = validateParameter(valid_604077, JString, required = false,
                                 default = nil)
  if valid_604077 != nil:
    section.add "X-Amz-Content-Sha256", valid_604077
  var valid_604078 = header.getOrDefault("X-Amz-Algorithm")
  valid_604078 = validateParameter(valid_604078, JString, required = false,
                                 default = nil)
  if valid_604078 != nil:
    section.add "X-Amz-Algorithm", valid_604078
  var valid_604079 = header.getOrDefault("X-Amz-Signature")
  valid_604079 = validateParameter(valid_604079, JString, required = false,
                                 default = nil)
  if valid_604079 != nil:
    section.add "X-Amz-Signature", valid_604079
  var valid_604080 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604080 = validateParameter(valid_604080, JString, required = false,
                                 default = nil)
  if valid_604080 != nil:
    section.add "X-Amz-SignedHeaders", valid_604080
  var valid_604081 = header.getOrDefault("X-Amz-Credential")
  valid_604081 = validateParameter(valid_604081, JString, required = false,
                                 default = nil)
  if valid_604081 != nil:
    section.add "X-Amz-Credential", valid_604081
  result.add "header", section
  ## parameters in `formData` object:
  ##   SnapshotCopyGrantName: JString (required)
  ##                        : The name of the snapshot copy grant to delete.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `SnapshotCopyGrantName` field"
  var valid_604082 = formData.getOrDefault("SnapshotCopyGrantName")
  valid_604082 = validateParameter(valid_604082, JString, required = true,
                                 default = nil)
  if valid_604082 != nil:
    section.add "SnapshotCopyGrantName", valid_604082
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604083: Call_PostDeleteSnapshotCopyGrant_604070; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes the specified snapshot copy grant.
  ## 
  let valid = call_604083.validator(path, query, header, formData, body)
  let scheme = call_604083.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604083.url(scheme.get, call_604083.host, call_604083.base,
                         call_604083.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_604083, url, valid)

proc call*(call_604084: Call_PostDeleteSnapshotCopyGrant_604070;
          SnapshotCopyGrantName: string;
          Action: string = "DeleteSnapshotCopyGrant"; Version: string = "2012-12-01"): Recallable =
  ## postDeleteSnapshotCopyGrant
  ## Deletes the specified snapshot copy grant.
  ##   Action: string (required)
  ##   SnapshotCopyGrantName: string (required)
  ##                        : The name of the snapshot copy grant to delete.
  ##   Version: string (required)
  var query_604085 = newJObject()
  var formData_604086 = newJObject()
  add(query_604085, "Action", newJString(Action))
  add(formData_604086, "SnapshotCopyGrantName", newJString(SnapshotCopyGrantName))
  add(query_604085, "Version", newJString(Version))
  result = call_604084.call(nil, query_604085, nil, formData_604086, nil)

var postDeleteSnapshotCopyGrant* = Call_PostDeleteSnapshotCopyGrant_604070(
    name: "postDeleteSnapshotCopyGrant", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteSnapshotCopyGrant",
    validator: validate_PostDeleteSnapshotCopyGrant_604071, base: "/",
    url: url_PostDeleteSnapshotCopyGrant_604072,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeleteSnapshotCopyGrant_604054 = ref object of OpenApiRestCall_602450
proc url_GetDeleteSnapshotCopyGrant_604056(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetDeleteSnapshotCopyGrant_604055(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes the specified snapshot copy grant.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   SnapshotCopyGrantName: JString (required)
  ##                        : The name of the snapshot copy grant to delete.
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_604057 = query.getOrDefault("Action")
  valid_604057 = validateParameter(valid_604057, JString, required = true, default = newJString(
      "DeleteSnapshotCopyGrant"))
  if valid_604057 != nil:
    section.add "Action", valid_604057
  var valid_604058 = query.getOrDefault("SnapshotCopyGrantName")
  valid_604058 = validateParameter(valid_604058, JString, required = true,
                                 default = nil)
  if valid_604058 != nil:
    section.add "SnapshotCopyGrantName", valid_604058
  var valid_604059 = query.getOrDefault("Version")
  valid_604059 = validateParameter(valid_604059, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_604059 != nil:
    section.add "Version", valid_604059
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_604060 = header.getOrDefault("X-Amz-Date")
  valid_604060 = validateParameter(valid_604060, JString, required = false,
                                 default = nil)
  if valid_604060 != nil:
    section.add "X-Amz-Date", valid_604060
  var valid_604061 = header.getOrDefault("X-Amz-Security-Token")
  valid_604061 = validateParameter(valid_604061, JString, required = false,
                                 default = nil)
  if valid_604061 != nil:
    section.add "X-Amz-Security-Token", valid_604061
  var valid_604062 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604062 = validateParameter(valid_604062, JString, required = false,
                                 default = nil)
  if valid_604062 != nil:
    section.add "X-Amz-Content-Sha256", valid_604062
  var valid_604063 = header.getOrDefault("X-Amz-Algorithm")
  valid_604063 = validateParameter(valid_604063, JString, required = false,
                                 default = nil)
  if valid_604063 != nil:
    section.add "X-Amz-Algorithm", valid_604063
  var valid_604064 = header.getOrDefault("X-Amz-Signature")
  valid_604064 = validateParameter(valid_604064, JString, required = false,
                                 default = nil)
  if valid_604064 != nil:
    section.add "X-Amz-Signature", valid_604064
  var valid_604065 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604065 = validateParameter(valid_604065, JString, required = false,
                                 default = nil)
  if valid_604065 != nil:
    section.add "X-Amz-SignedHeaders", valid_604065
  var valid_604066 = header.getOrDefault("X-Amz-Credential")
  valid_604066 = validateParameter(valid_604066, JString, required = false,
                                 default = nil)
  if valid_604066 != nil:
    section.add "X-Amz-Credential", valid_604066
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604067: Call_GetDeleteSnapshotCopyGrant_604054; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes the specified snapshot copy grant.
  ## 
  let valid = call_604067.validator(path, query, header, formData, body)
  let scheme = call_604067.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604067.url(scheme.get, call_604067.host, call_604067.base,
                         call_604067.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_604067, url, valid)

proc call*(call_604068: Call_GetDeleteSnapshotCopyGrant_604054;
          SnapshotCopyGrantName: string;
          Action: string = "DeleteSnapshotCopyGrant"; Version: string = "2012-12-01"): Recallable =
  ## getDeleteSnapshotCopyGrant
  ## Deletes the specified snapshot copy grant.
  ##   Action: string (required)
  ##   SnapshotCopyGrantName: string (required)
  ##                        : The name of the snapshot copy grant to delete.
  ##   Version: string (required)
  var query_604069 = newJObject()
  add(query_604069, "Action", newJString(Action))
  add(query_604069, "SnapshotCopyGrantName", newJString(SnapshotCopyGrantName))
  add(query_604069, "Version", newJString(Version))
  result = call_604068.call(nil, query_604069, nil, nil, nil)

var getDeleteSnapshotCopyGrant* = Call_GetDeleteSnapshotCopyGrant_604054(
    name: "getDeleteSnapshotCopyGrant", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteSnapshotCopyGrant",
    validator: validate_GetDeleteSnapshotCopyGrant_604055, base: "/",
    url: url_GetDeleteSnapshotCopyGrant_604056,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDeleteSnapshotSchedule_604103 = ref object of OpenApiRestCall_602450
proc url_PostDeleteSnapshotSchedule_604105(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostDeleteSnapshotSchedule_604104(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a snapshot schedule.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_604106 = query.getOrDefault("Action")
  valid_604106 = validateParameter(valid_604106, JString, required = true,
                                 default = newJString("DeleteSnapshotSchedule"))
  if valid_604106 != nil:
    section.add "Action", valid_604106
  var valid_604107 = query.getOrDefault("Version")
  valid_604107 = validateParameter(valid_604107, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_604107 != nil:
    section.add "Version", valid_604107
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_604108 = header.getOrDefault("X-Amz-Date")
  valid_604108 = validateParameter(valid_604108, JString, required = false,
                                 default = nil)
  if valid_604108 != nil:
    section.add "X-Amz-Date", valid_604108
  var valid_604109 = header.getOrDefault("X-Amz-Security-Token")
  valid_604109 = validateParameter(valid_604109, JString, required = false,
                                 default = nil)
  if valid_604109 != nil:
    section.add "X-Amz-Security-Token", valid_604109
  var valid_604110 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604110 = validateParameter(valid_604110, JString, required = false,
                                 default = nil)
  if valid_604110 != nil:
    section.add "X-Amz-Content-Sha256", valid_604110
  var valid_604111 = header.getOrDefault("X-Amz-Algorithm")
  valid_604111 = validateParameter(valid_604111, JString, required = false,
                                 default = nil)
  if valid_604111 != nil:
    section.add "X-Amz-Algorithm", valid_604111
  var valid_604112 = header.getOrDefault("X-Amz-Signature")
  valid_604112 = validateParameter(valid_604112, JString, required = false,
                                 default = nil)
  if valid_604112 != nil:
    section.add "X-Amz-Signature", valid_604112
  var valid_604113 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604113 = validateParameter(valid_604113, JString, required = false,
                                 default = nil)
  if valid_604113 != nil:
    section.add "X-Amz-SignedHeaders", valid_604113
  var valid_604114 = header.getOrDefault("X-Amz-Credential")
  valid_604114 = validateParameter(valid_604114, JString, required = false,
                                 default = nil)
  if valid_604114 != nil:
    section.add "X-Amz-Credential", valid_604114
  result.add "header", section
  ## parameters in `formData` object:
  ##   ScheduleIdentifier: JString (required)
  ##                     : A unique identifier of the snapshot schedule to delete.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ScheduleIdentifier` field"
  var valid_604115 = formData.getOrDefault("ScheduleIdentifier")
  valid_604115 = validateParameter(valid_604115, JString, required = true,
                                 default = nil)
  if valid_604115 != nil:
    section.add "ScheduleIdentifier", valid_604115
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604116: Call_PostDeleteSnapshotSchedule_604103; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a snapshot schedule.
  ## 
  let valid = call_604116.validator(path, query, header, formData, body)
  let scheme = call_604116.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604116.url(scheme.get, call_604116.host, call_604116.base,
                         call_604116.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_604116, url, valid)

proc call*(call_604117: Call_PostDeleteSnapshotSchedule_604103;
          ScheduleIdentifier: string; Action: string = "DeleteSnapshotSchedule";
          Version: string = "2012-12-01"): Recallable =
  ## postDeleteSnapshotSchedule
  ## Deletes a snapshot schedule.
  ##   Action: string (required)
  ##   ScheduleIdentifier: string (required)
  ##                     : A unique identifier of the snapshot schedule to delete.
  ##   Version: string (required)
  var query_604118 = newJObject()
  var formData_604119 = newJObject()
  add(query_604118, "Action", newJString(Action))
  add(formData_604119, "ScheduleIdentifier", newJString(ScheduleIdentifier))
  add(query_604118, "Version", newJString(Version))
  result = call_604117.call(nil, query_604118, nil, formData_604119, nil)

var postDeleteSnapshotSchedule* = Call_PostDeleteSnapshotSchedule_604103(
    name: "postDeleteSnapshotSchedule", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteSnapshotSchedule",
    validator: validate_PostDeleteSnapshotSchedule_604104, base: "/",
    url: url_PostDeleteSnapshotSchedule_604105,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeleteSnapshotSchedule_604087 = ref object of OpenApiRestCall_602450
proc url_GetDeleteSnapshotSchedule_604089(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetDeleteSnapshotSchedule_604088(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a snapshot schedule.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   ScheduleIdentifier: JString (required)
  ##                     : A unique identifier of the snapshot schedule to delete.
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_604090 = query.getOrDefault("Action")
  valid_604090 = validateParameter(valid_604090, JString, required = true,
                                 default = newJString("DeleteSnapshotSchedule"))
  if valid_604090 != nil:
    section.add "Action", valid_604090
  var valid_604091 = query.getOrDefault("ScheduleIdentifier")
  valid_604091 = validateParameter(valid_604091, JString, required = true,
                                 default = nil)
  if valid_604091 != nil:
    section.add "ScheduleIdentifier", valid_604091
  var valid_604092 = query.getOrDefault("Version")
  valid_604092 = validateParameter(valid_604092, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_604092 != nil:
    section.add "Version", valid_604092
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_604093 = header.getOrDefault("X-Amz-Date")
  valid_604093 = validateParameter(valid_604093, JString, required = false,
                                 default = nil)
  if valid_604093 != nil:
    section.add "X-Amz-Date", valid_604093
  var valid_604094 = header.getOrDefault("X-Amz-Security-Token")
  valid_604094 = validateParameter(valid_604094, JString, required = false,
                                 default = nil)
  if valid_604094 != nil:
    section.add "X-Amz-Security-Token", valid_604094
  var valid_604095 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604095 = validateParameter(valid_604095, JString, required = false,
                                 default = nil)
  if valid_604095 != nil:
    section.add "X-Amz-Content-Sha256", valid_604095
  var valid_604096 = header.getOrDefault("X-Amz-Algorithm")
  valid_604096 = validateParameter(valid_604096, JString, required = false,
                                 default = nil)
  if valid_604096 != nil:
    section.add "X-Amz-Algorithm", valid_604096
  var valid_604097 = header.getOrDefault("X-Amz-Signature")
  valid_604097 = validateParameter(valid_604097, JString, required = false,
                                 default = nil)
  if valid_604097 != nil:
    section.add "X-Amz-Signature", valid_604097
  var valid_604098 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604098 = validateParameter(valid_604098, JString, required = false,
                                 default = nil)
  if valid_604098 != nil:
    section.add "X-Amz-SignedHeaders", valid_604098
  var valid_604099 = header.getOrDefault("X-Amz-Credential")
  valid_604099 = validateParameter(valid_604099, JString, required = false,
                                 default = nil)
  if valid_604099 != nil:
    section.add "X-Amz-Credential", valid_604099
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604100: Call_GetDeleteSnapshotSchedule_604087; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a snapshot schedule.
  ## 
  let valid = call_604100.validator(path, query, header, formData, body)
  let scheme = call_604100.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604100.url(scheme.get, call_604100.host, call_604100.base,
                         call_604100.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_604100, url, valid)

proc call*(call_604101: Call_GetDeleteSnapshotSchedule_604087;
          ScheduleIdentifier: string; Action: string = "DeleteSnapshotSchedule";
          Version: string = "2012-12-01"): Recallable =
  ## getDeleteSnapshotSchedule
  ## Deletes a snapshot schedule.
  ##   Action: string (required)
  ##   ScheduleIdentifier: string (required)
  ##                     : A unique identifier of the snapshot schedule to delete.
  ##   Version: string (required)
  var query_604102 = newJObject()
  add(query_604102, "Action", newJString(Action))
  add(query_604102, "ScheduleIdentifier", newJString(ScheduleIdentifier))
  add(query_604102, "Version", newJString(Version))
  result = call_604101.call(nil, query_604102, nil, nil, nil)

var getDeleteSnapshotSchedule* = Call_GetDeleteSnapshotSchedule_604087(
    name: "getDeleteSnapshotSchedule", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteSnapshotSchedule",
    validator: validate_GetDeleteSnapshotSchedule_604088, base: "/",
    url: url_GetDeleteSnapshotSchedule_604089,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDeleteTags_604137 = ref object of OpenApiRestCall_602450
proc url_PostDeleteTags_604139(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostDeleteTags_604138(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode): JsonNode =
  ## Deletes a tag or tags from a resource. You must provide the ARN of the resource from which you want to delete the tag or tags.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_604140 = query.getOrDefault("Action")
  valid_604140 = validateParameter(valid_604140, JString, required = true,
                                 default = newJString("DeleteTags"))
  if valid_604140 != nil:
    section.add "Action", valid_604140
  var valid_604141 = query.getOrDefault("Version")
  valid_604141 = validateParameter(valid_604141, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_604141 != nil:
    section.add "Version", valid_604141
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_604142 = header.getOrDefault("X-Amz-Date")
  valid_604142 = validateParameter(valid_604142, JString, required = false,
                                 default = nil)
  if valid_604142 != nil:
    section.add "X-Amz-Date", valid_604142
  var valid_604143 = header.getOrDefault("X-Amz-Security-Token")
  valid_604143 = validateParameter(valid_604143, JString, required = false,
                                 default = nil)
  if valid_604143 != nil:
    section.add "X-Amz-Security-Token", valid_604143
  var valid_604144 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604144 = validateParameter(valid_604144, JString, required = false,
                                 default = nil)
  if valid_604144 != nil:
    section.add "X-Amz-Content-Sha256", valid_604144
  var valid_604145 = header.getOrDefault("X-Amz-Algorithm")
  valid_604145 = validateParameter(valid_604145, JString, required = false,
                                 default = nil)
  if valid_604145 != nil:
    section.add "X-Amz-Algorithm", valid_604145
  var valid_604146 = header.getOrDefault("X-Amz-Signature")
  valid_604146 = validateParameter(valid_604146, JString, required = false,
                                 default = nil)
  if valid_604146 != nil:
    section.add "X-Amz-Signature", valid_604146
  var valid_604147 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604147 = validateParameter(valid_604147, JString, required = false,
                                 default = nil)
  if valid_604147 != nil:
    section.add "X-Amz-SignedHeaders", valid_604147
  var valid_604148 = header.getOrDefault("X-Amz-Credential")
  valid_604148 = validateParameter(valid_604148, JString, required = false,
                                 default = nil)
  if valid_604148 != nil:
    section.add "X-Amz-Credential", valid_604148
  result.add "header", section
  ## parameters in `formData` object:
  ##   TagKeys: JArray (required)
  ##          : The tag key that you want to delete.
  ##   ResourceName: JString (required)
  ##               : The Amazon Resource Name (ARN) from which you want to remove the tag or tags. For example, <code>arn:aws:redshift:us-east-1:123456789:cluster:t1</code>. 
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `TagKeys` field"
  var valid_604149 = formData.getOrDefault("TagKeys")
  valid_604149 = validateParameter(valid_604149, JArray, required = true, default = nil)
  if valid_604149 != nil:
    section.add "TagKeys", valid_604149
  var valid_604150 = formData.getOrDefault("ResourceName")
  valid_604150 = validateParameter(valid_604150, JString, required = true,
                                 default = nil)
  if valid_604150 != nil:
    section.add "ResourceName", valid_604150
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604151: Call_PostDeleteTags_604137; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a tag or tags from a resource. You must provide the ARN of the resource from which you want to delete the tag or tags.
  ## 
  let valid = call_604151.validator(path, query, header, formData, body)
  let scheme = call_604151.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604151.url(scheme.get, call_604151.host, call_604151.base,
                         call_604151.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_604151, url, valid)

proc call*(call_604152: Call_PostDeleteTags_604137; TagKeys: JsonNode;
          ResourceName: string; Action: string = "DeleteTags";
          Version: string = "2012-12-01"): Recallable =
  ## postDeleteTags
  ## Deletes a tag or tags from a resource. You must provide the ARN of the resource from which you want to delete the tag or tags.
  ##   Action: string (required)
  ##   TagKeys: JArray (required)
  ##          : The tag key that you want to delete.
  ##   ResourceName: string (required)
  ##               : The Amazon Resource Name (ARN) from which you want to remove the tag or tags. For example, <code>arn:aws:redshift:us-east-1:123456789:cluster:t1</code>. 
  ##   Version: string (required)
  var query_604153 = newJObject()
  var formData_604154 = newJObject()
  add(query_604153, "Action", newJString(Action))
  if TagKeys != nil:
    formData_604154.add "TagKeys", TagKeys
  add(formData_604154, "ResourceName", newJString(ResourceName))
  add(query_604153, "Version", newJString(Version))
  result = call_604152.call(nil, query_604153, nil, formData_604154, nil)

var postDeleteTags* = Call_PostDeleteTags_604137(name: "postDeleteTags",
    meth: HttpMethod.HttpPost, host: "redshift.amazonaws.com",
    route: "/#Action=DeleteTags", validator: validate_PostDeleteTags_604138,
    base: "/", url: url_PostDeleteTags_604139, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeleteTags_604120 = ref object of OpenApiRestCall_602450
proc url_GetDeleteTags_604122(protocol: Scheme; host: string; base: string;
                             route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetDeleteTags_604121(path: JsonNode; query: JsonNode; header: JsonNode;
                                  formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a tag or tags from a resource. You must provide the ARN of the resource from which you want to delete the tag or tags.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ResourceName: JString (required)
  ##               : The Amazon Resource Name (ARN) from which you want to remove the tag or tags. For example, <code>arn:aws:redshift:us-east-1:123456789:cluster:t1</code>. 
  ##   Action: JString (required)
  ##   TagKeys: JArray (required)
  ##          : The tag key that you want to delete.
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `ResourceName` field"
  var valid_604123 = query.getOrDefault("ResourceName")
  valid_604123 = validateParameter(valid_604123, JString, required = true,
                                 default = nil)
  if valid_604123 != nil:
    section.add "ResourceName", valid_604123
  var valid_604124 = query.getOrDefault("Action")
  valid_604124 = validateParameter(valid_604124, JString, required = true,
                                 default = newJString("DeleteTags"))
  if valid_604124 != nil:
    section.add "Action", valid_604124
  var valid_604125 = query.getOrDefault("TagKeys")
  valid_604125 = validateParameter(valid_604125, JArray, required = true, default = nil)
  if valid_604125 != nil:
    section.add "TagKeys", valid_604125
  var valid_604126 = query.getOrDefault("Version")
  valid_604126 = validateParameter(valid_604126, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_604126 != nil:
    section.add "Version", valid_604126
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_604127 = header.getOrDefault("X-Amz-Date")
  valid_604127 = validateParameter(valid_604127, JString, required = false,
                                 default = nil)
  if valid_604127 != nil:
    section.add "X-Amz-Date", valid_604127
  var valid_604128 = header.getOrDefault("X-Amz-Security-Token")
  valid_604128 = validateParameter(valid_604128, JString, required = false,
                                 default = nil)
  if valid_604128 != nil:
    section.add "X-Amz-Security-Token", valid_604128
  var valid_604129 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604129 = validateParameter(valid_604129, JString, required = false,
                                 default = nil)
  if valid_604129 != nil:
    section.add "X-Amz-Content-Sha256", valid_604129
  var valid_604130 = header.getOrDefault("X-Amz-Algorithm")
  valid_604130 = validateParameter(valid_604130, JString, required = false,
                                 default = nil)
  if valid_604130 != nil:
    section.add "X-Amz-Algorithm", valid_604130
  var valid_604131 = header.getOrDefault("X-Amz-Signature")
  valid_604131 = validateParameter(valid_604131, JString, required = false,
                                 default = nil)
  if valid_604131 != nil:
    section.add "X-Amz-Signature", valid_604131
  var valid_604132 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604132 = validateParameter(valid_604132, JString, required = false,
                                 default = nil)
  if valid_604132 != nil:
    section.add "X-Amz-SignedHeaders", valid_604132
  var valid_604133 = header.getOrDefault("X-Amz-Credential")
  valid_604133 = validateParameter(valid_604133, JString, required = false,
                                 default = nil)
  if valid_604133 != nil:
    section.add "X-Amz-Credential", valid_604133
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604134: Call_GetDeleteTags_604120; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a tag or tags from a resource. You must provide the ARN of the resource from which you want to delete the tag or tags.
  ## 
  let valid = call_604134.validator(path, query, header, formData, body)
  let scheme = call_604134.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604134.url(scheme.get, call_604134.host, call_604134.base,
                         call_604134.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_604134, url, valid)

proc call*(call_604135: Call_GetDeleteTags_604120; ResourceName: string;
          TagKeys: JsonNode; Action: string = "DeleteTags";
          Version: string = "2012-12-01"): Recallable =
  ## getDeleteTags
  ## Deletes a tag or tags from a resource. You must provide the ARN of the resource from which you want to delete the tag or tags.
  ##   ResourceName: string (required)
  ##               : The Amazon Resource Name (ARN) from which you want to remove the tag or tags. For example, <code>arn:aws:redshift:us-east-1:123456789:cluster:t1</code>. 
  ##   Action: string (required)
  ##   TagKeys: JArray (required)
  ##          : The tag key that you want to delete.
  ##   Version: string (required)
  var query_604136 = newJObject()
  add(query_604136, "ResourceName", newJString(ResourceName))
  add(query_604136, "Action", newJString(Action))
  if TagKeys != nil:
    query_604136.add "TagKeys", TagKeys
  add(query_604136, "Version", newJString(Version))
  result = call_604135.call(nil, query_604136, nil, nil, nil)

var getDeleteTags* = Call_GetDeleteTags_604120(name: "getDeleteTags",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=DeleteTags", validator: validate_GetDeleteTags_604121,
    base: "/", url: url_GetDeleteTags_604122, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeAccountAttributes_604171 = ref object of OpenApiRestCall_602450
proc url_PostDescribeAccountAttributes_604173(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostDescribeAccountAttributes_604172(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns a list of attributes attached to an account
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_604174 = query.getOrDefault("Action")
  valid_604174 = validateParameter(valid_604174, JString, required = true, default = newJString(
      "DescribeAccountAttributes"))
  if valid_604174 != nil:
    section.add "Action", valid_604174
  var valid_604175 = query.getOrDefault("Version")
  valid_604175 = validateParameter(valid_604175, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_604175 != nil:
    section.add "Version", valid_604175
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_604176 = header.getOrDefault("X-Amz-Date")
  valid_604176 = validateParameter(valid_604176, JString, required = false,
                                 default = nil)
  if valid_604176 != nil:
    section.add "X-Amz-Date", valid_604176
  var valid_604177 = header.getOrDefault("X-Amz-Security-Token")
  valid_604177 = validateParameter(valid_604177, JString, required = false,
                                 default = nil)
  if valid_604177 != nil:
    section.add "X-Amz-Security-Token", valid_604177
  var valid_604178 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604178 = validateParameter(valid_604178, JString, required = false,
                                 default = nil)
  if valid_604178 != nil:
    section.add "X-Amz-Content-Sha256", valid_604178
  var valid_604179 = header.getOrDefault("X-Amz-Algorithm")
  valid_604179 = validateParameter(valid_604179, JString, required = false,
                                 default = nil)
  if valid_604179 != nil:
    section.add "X-Amz-Algorithm", valid_604179
  var valid_604180 = header.getOrDefault("X-Amz-Signature")
  valid_604180 = validateParameter(valid_604180, JString, required = false,
                                 default = nil)
  if valid_604180 != nil:
    section.add "X-Amz-Signature", valid_604180
  var valid_604181 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604181 = validateParameter(valid_604181, JString, required = false,
                                 default = nil)
  if valid_604181 != nil:
    section.add "X-Amz-SignedHeaders", valid_604181
  var valid_604182 = header.getOrDefault("X-Amz-Credential")
  valid_604182 = validateParameter(valid_604182, JString, required = false,
                                 default = nil)
  if valid_604182 != nil:
    section.add "X-Amz-Credential", valid_604182
  result.add "header", section
  ## parameters in `formData` object:
  ##   AttributeNames: JArray
  ##                 : A list of attribute names.
  section = newJObject()
  var valid_604183 = formData.getOrDefault("AttributeNames")
  valid_604183 = validateParameter(valid_604183, JArray, required = false,
                                 default = nil)
  if valid_604183 != nil:
    section.add "AttributeNames", valid_604183
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604184: Call_PostDescribeAccountAttributes_604171; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns a list of attributes attached to an account
  ## 
  let valid = call_604184.validator(path, query, header, formData, body)
  let scheme = call_604184.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604184.url(scheme.get, call_604184.host, call_604184.base,
                         call_604184.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_604184, url, valid)

proc call*(call_604185: Call_PostDescribeAccountAttributes_604171;
          Action: string = "DescribeAccountAttributes";
          AttributeNames: JsonNode = nil; Version: string = "2012-12-01"): Recallable =
  ## postDescribeAccountAttributes
  ## Returns a list of attributes attached to an account
  ##   Action: string (required)
  ##   AttributeNames: JArray
  ##                 : A list of attribute names.
  ##   Version: string (required)
  var query_604186 = newJObject()
  var formData_604187 = newJObject()
  add(query_604186, "Action", newJString(Action))
  if AttributeNames != nil:
    formData_604187.add "AttributeNames", AttributeNames
  add(query_604186, "Version", newJString(Version))
  result = call_604185.call(nil, query_604186, nil, formData_604187, nil)

var postDescribeAccountAttributes* = Call_PostDescribeAccountAttributes_604171(
    name: "postDescribeAccountAttributes", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeAccountAttributes",
    validator: validate_PostDescribeAccountAttributes_604172, base: "/",
    url: url_PostDescribeAccountAttributes_604173,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeAccountAttributes_604155 = ref object of OpenApiRestCall_602450
proc url_GetDescribeAccountAttributes_604157(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetDescribeAccountAttributes_604156(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns a list of attributes attached to an account
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   AttributeNames: JArray
  ##                 : A list of attribute names.
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_604158 = query.getOrDefault("AttributeNames")
  valid_604158 = validateParameter(valid_604158, JArray, required = false,
                                 default = nil)
  if valid_604158 != nil:
    section.add "AttributeNames", valid_604158
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_604159 = query.getOrDefault("Action")
  valid_604159 = validateParameter(valid_604159, JString, required = true, default = newJString(
      "DescribeAccountAttributes"))
  if valid_604159 != nil:
    section.add "Action", valid_604159
  var valid_604160 = query.getOrDefault("Version")
  valid_604160 = validateParameter(valid_604160, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_604160 != nil:
    section.add "Version", valid_604160
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_604161 = header.getOrDefault("X-Amz-Date")
  valid_604161 = validateParameter(valid_604161, JString, required = false,
                                 default = nil)
  if valid_604161 != nil:
    section.add "X-Amz-Date", valid_604161
  var valid_604162 = header.getOrDefault("X-Amz-Security-Token")
  valid_604162 = validateParameter(valid_604162, JString, required = false,
                                 default = nil)
  if valid_604162 != nil:
    section.add "X-Amz-Security-Token", valid_604162
  var valid_604163 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604163 = validateParameter(valid_604163, JString, required = false,
                                 default = nil)
  if valid_604163 != nil:
    section.add "X-Amz-Content-Sha256", valid_604163
  var valid_604164 = header.getOrDefault("X-Amz-Algorithm")
  valid_604164 = validateParameter(valid_604164, JString, required = false,
                                 default = nil)
  if valid_604164 != nil:
    section.add "X-Amz-Algorithm", valid_604164
  var valid_604165 = header.getOrDefault("X-Amz-Signature")
  valid_604165 = validateParameter(valid_604165, JString, required = false,
                                 default = nil)
  if valid_604165 != nil:
    section.add "X-Amz-Signature", valid_604165
  var valid_604166 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604166 = validateParameter(valid_604166, JString, required = false,
                                 default = nil)
  if valid_604166 != nil:
    section.add "X-Amz-SignedHeaders", valid_604166
  var valid_604167 = header.getOrDefault("X-Amz-Credential")
  valid_604167 = validateParameter(valid_604167, JString, required = false,
                                 default = nil)
  if valid_604167 != nil:
    section.add "X-Amz-Credential", valid_604167
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604168: Call_GetDescribeAccountAttributes_604155; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns a list of attributes attached to an account
  ## 
  let valid = call_604168.validator(path, query, header, formData, body)
  let scheme = call_604168.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604168.url(scheme.get, call_604168.host, call_604168.base,
                         call_604168.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_604168, url, valid)

proc call*(call_604169: Call_GetDescribeAccountAttributes_604155;
          AttributeNames: JsonNode = nil;
          Action: string = "DescribeAccountAttributes";
          Version: string = "2012-12-01"): Recallable =
  ## getDescribeAccountAttributes
  ## Returns a list of attributes attached to an account
  ##   AttributeNames: JArray
  ##                 : A list of attribute names.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_604170 = newJObject()
  if AttributeNames != nil:
    query_604170.add "AttributeNames", AttributeNames
  add(query_604170, "Action", newJString(Action))
  add(query_604170, "Version", newJString(Version))
  result = call_604169.call(nil, query_604170, nil, nil, nil)

var getDescribeAccountAttributes* = Call_GetDescribeAccountAttributes_604155(
    name: "getDescribeAccountAttributes", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeAccountAttributes",
    validator: validate_GetDescribeAccountAttributes_604156, base: "/",
    url: url_GetDescribeAccountAttributes_604157,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeClusterDbRevisions_604206 = ref object of OpenApiRestCall_602450
proc url_PostDescribeClusterDbRevisions_604208(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostDescribeClusterDbRevisions_604207(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns an array of <code>ClusterDbRevision</code> objects.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_604209 = query.getOrDefault("Action")
  valid_604209 = validateParameter(valid_604209, JString, required = true, default = newJString(
      "DescribeClusterDbRevisions"))
  if valid_604209 != nil:
    section.add "Action", valid_604209
  var valid_604210 = query.getOrDefault("Version")
  valid_604210 = validateParameter(valid_604210, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_604210 != nil:
    section.add "Version", valid_604210
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_604211 = header.getOrDefault("X-Amz-Date")
  valid_604211 = validateParameter(valid_604211, JString, required = false,
                                 default = nil)
  if valid_604211 != nil:
    section.add "X-Amz-Date", valid_604211
  var valid_604212 = header.getOrDefault("X-Amz-Security-Token")
  valid_604212 = validateParameter(valid_604212, JString, required = false,
                                 default = nil)
  if valid_604212 != nil:
    section.add "X-Amz-Security-Token", valid_604212
  var valid_604213 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604213 = validateParameter(valid_604213, JString, required = false,
                                 default = nil)
  if valid_604213 != nil:
    section.add "X-Amz-Content-Sha256", valid_604213
  var valid_604214 = header.getOrDefault("X-Amz-Algorithm")
  valid_604214 = validateParameter(valid_604214, JString, required = false,
                                 default = nil)
  if valid_604214 != nil:
    section.add "X-Amz-Algorithm", valid_604214
  var valid_604215 = header.getOrDefault("X-Amz-Signature")
  valid_604215 = validateParameter(valid_604215, JString, required = false,
                                 default = nil)
  if valid_604215 != nil:
    section.add "X-Amz-Signature", valid_604215
  var valid_604216 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604216 = validateParameter(valid_604216, JString, required = false,
                                 default = nil)
  if valid_604216 != nil:
    section.add "X-Amz-SignedHeaders", valid_604216
  var valid_604217 = header.getOrDefault("X-Amz-Credential")
  valid_604217 = validateParameter(valid_604217, JString, required = false,
                                 default = nil)
  if valid_604217 != nil:
    section.add "X-Amz-Credential", valid_604217
  result.add "header", section
  ## parameters in `formData` object:
  ##   Marker: JString
  ##         : <p>An optional parameter that specifies the starting point for returning a set of response records. When the results of a <code>DescribeClusterDbRevisions</code> request exceed the value specified in <code>MaxRecords</code>, Amazon Redshift returns a value in the <code>marker</code> field of the response. You can retrieve the next set of response records by providing the returned <code>marker</code> value in the <code>marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <code>ClusterIdentifier</code> parameter, or the <code>marker</code> parameter, but not both.</p>
  ##   ClusterIdentifier: JString
  ##                    : A unique identifier for a cluster whose <code>ClusterDbRevisions</code> you are requesting. This parameter is case sensitive. All clusters defined for an account are returned by default.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified MaxRecords value, a value is returned in the <code>marker</code> field of the response. You can retrieve the next set of response records by providing the returned <code>marker</code> value in the <code>marker</code> parameter and retrying the request. </p> <p>Default: 100</p> <p>Constraints: minimum 20, maximum 100.</p>
  section = newJObject()
  var valid_604218 = formData.getOrDefault("Marker")
  valid_604218 = validateParameter(valid_604218, JString, required = false,
                                 default = nil)
  if valid_604218 != nil:
    section.add "Marker", valid_604218
  var valid_604219 = formData.getOrDefault("ClusterIdentifier")
  valid_604219 = validateParameter(valid_604219, JString, required = false,
                                 default = nil)
  if valid_604219 != nil:
    section.add "ClusterIdentifier", valid_604219
  var valid_604220 = formData.getOrDefault("MaxRecords")
  valid_604220 = validateParameter(valid_604220, JInt, required = false, default = nil)
  if valid_604220 != nil:
    section.add "MaxRecords", valid_604220
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604221: Call_PostDescribeClusterDbRevisions_604206; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns an array of <code>ClusterDbRevision</code> objects.
  ## 
  let valid = call_604221.validator(path, query, header, formData, body)
  let scheme = call_604221.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604221.url(scheme.get, call_604221.host, call_604221.base,
                         call_604221.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_604221, url, valid)

proc call*(call_604222: Call_PostDescribeClusterDbRevisions_604206;
          Marker: string = ""; Action: string = "DescribeClusterDbRevisions";
          ClusterIdentifier: string = ""; MaxRecords: int = 0;
          Version: string = "2012-12-01"): Recallable =
  ## postDescribeClusterDbRevisions
  ## Returns an array of <code>ClusterDbRevision</code> objects.
  ##   Marker: string
  ##         : <p>An optional parameter that specifies the starting point for returning a set of response records. When the results of a <code>DescribeClusterDbRevisions</code> request exceed the value specified in <code>MaxRecords</code>, Amazon Redshift returns a value in the <code>marker</code> field of the response. You can retrieve the next set of response records by providing the returned <code>marker</code> value in the <code>marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <code>ClusterIdentifier</code> parameter, or the <code>marker</code> parameter, but not both.</p>
  ##   Action: string (required)
  ##   ClusterIdentifier: string
  ##                    : A unique identifier for a cluster whose <code>ClusterDbRevisions</code> you are requesting. This parameter is case sensitive. All clusters defined for an account are returned by default.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified MaxRecords value, a value is returned in the <code>marker</code> field of the response. You can retrieve the next set of response records by providing the returned <code>marker</code> value in the <code>marker</code> parameter and retrying the request. </p> <p>Default: 100</p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Version: string (required)
  var query_604223 = newJObject()
  var formData_604224 = newJObject()
  add(formData_604224, "Marker", newJString(Marker))
  add(query_604223, "Action", newJString(Action))
  add(formData_604224, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_604224, "MaxRecords", newJInt(MaxRecords))
  add(query_604223, "Version", newJString(Version))
  result = call_604222.call(nil, query_604223, nil, formData_604224, nil)

var postDescribeClusterDbRevisions* = Call_PostDescribeClusterDbRevisions_604206(
    name: "postDescribeClusterDbRevisions", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusterDbRevisions",
    validator: validate_PostDescribeClusterDbRevisions_604207, base: "/",
    url: url_PostDescribeClusterDbRevisions_604208,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeClusterDbRevisions_604188 = ref object of OpenApiRestCall_602450
proc url_GetDescribeClusterDbRevisions_604190(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetDescribeClusterDbRevisions_604189(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns an array of <code>ClusterDbRevision</code> objects.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified MaxRecords value, a value is returned in the <code>marker</code> field of the response. You can retrieve the next set of response records by providing the returned <code>marker</code> value in the <code>marker</code> parameter and retrying the request. </p> <p>Default: 100</p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString
  ##                    : A unique identifier for a cluster whose <code>ClusterDbRevisions</code> you are requesting. This parameter is case sensitive. All clusters defined for an account are returned by default.
  ##   Marker: JString
  ##         : <p>An optional parameter that specifies the starting point for returning a set of response records. When the results of a <code>DescribeClusterDbRevisions</code> request exceed the value specified in <code>MaxRecords</code>, Amazon Redshift returns a value in the <code>marker</code> field of the response. You can retrieve the next set of response records by providing the returned <code>marker</code> value in the <code>marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <code>ClusterIdentifier</code> parameter, or the <code>marker</code> parameter, but not both.</p>
  ##   Version: JString (required)
  section = newJObject()
  var valid_604191 = query.getOrDefault("MaxRecords")
  valid_604191 = validateParameter(valid_604191, JInt, required = false, default = nil)
  if valid_604191 != nil:
    section.add "MaxRecords", valid_604191
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_604192 = query.getOrDefault("Action")
  valid_604192 = validateParameter(valid_604192, JString, required = true, default = newJString(
      "DescribeClusterDbRevisions"))
  if valid_604192 != nil:
    section.add "Action", valid_604192
  var valid_604193 = query.getOrDefault("ClusterIdentifier")
  valid_604193 = validateParameter(valid_604193, JString, required = false,
                                 default = nil)
  if valid_604193 != nil:
    section.add "ClusterIdentifier", valid_604193
  var valid_604194 = query.getOrDefault("Marker")
  valid_604194 = validateParameter(valid_604194, JString, required = false,
                                 default = nil)
  if valid_604194 != nil:
    section.add "Marker", valid_604194
  var valid_604195 = query.getOrDefault("Version")
  valid_604195 = validateParameter(valid_604195, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_604195 != nil:
    section.add "Version", valid_604195
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_604196 = header.getOrDefault("X-Amz-Date")
  valid_604196 = validateParameter(valid_604196, JString, required = false,
                                 default = nil)
  if valid_604196 != nil:
    section.add "X-Amz-Date", valid_604196
  var valid_604197 = header.getOrDefault("X-Amz-Security-Token")
  valid_604197 = validateParameter(valid_604197, JString, required = false,
                                 default = nil)
  if valid_604197 != nil:
    section.add "X-Amz-Security-Token", valid_604197
  var valid_604198 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604198 = validateParameter(valid_604198, JString, required = false,
                                 default = nil)
  if valid_604198 != nil:
    section.add "X-Amz-Content-Sha256", valid_604198
  var valid_604199 = header.getOrDefault("X-Amz-Algorithm")
  valid_604199 = validateParameter(valid_604199, JString, required = false,
                                 default = nil)
  if valid_604199 != nil:
    section.add "X-Amz-Algorithm", valid_604199
  var valid_604200 = header.getOrDefault("X-Amz-Signature")
  valid_604200 = validateParameter(valid_604200, JString, required = false,
                                 default = nil)
  if valid_604200 != nil:
    section.add "X-Amz-Signature", valid_604200
  var valid_604201 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604201 = validateParameter(valid_604201, JString, required = false,
                                 default = nil)
  if valid_604201 != nil:
    section.add "X-Amz-SignedHeaders", valid_604201
  var valid_604202 = header.getOrDefault("X-Amz-Credential")
  valid_604202 = validateParameter(valid_604202, JString, required = false,
                                 default = nil)
  if valid_604202 != nil:
    section.add "X-Amz-Credential", valid_604202
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604203: Call_GetDescribeClusterDbRevisions_604188; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns an array of <code>ClusterDbRevision</code> objects.
  ## 
  let valid = call_604203.validator(path, query, header, formData, body)
  let scheme = call_604203.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604203.url(scheme.get, call_604203.host, call_604203.base,
                         call_604203.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_604203, url, valid)

proc call*(call_604204: Call_GetDescribeClusterDbRevisions_604188;
          MaxRecords: int = 0; Action: string = "DescribeClusterDbRevisions";
          ClusterIdentifier: string = ""; Marker: string = "";
          Version: string = "2012-12-01"): Recallable =
  ## getDescribeClusterDbRevisions
  ## Returns an array of <code>ClusterDbRevision</code> objects.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified MaxRecords value, a value is returned in the <code>marker</code> field of the response. You can retrieve the next set of response records by providing the returned <code>marker</code> value in the <code>marker</code> parameter and retrying the request. </p> <p>Default: 100</p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Action: string (required)
  ##   ClusterIdentifier: string
  ##                    : A unique identifier for a cluster whose <code>ClusterDbRevisions</code> you are requesting. This parameter is case sensitive. All clusters defined for an account are returned by default.
  ##   Marker: string
  ##         : <p>An optional parameter that specifies the starting point for returning a set of response records. When the results of a <code>DescribeClusterDbRevisions</code> request exceed the value specified in <code>MaxRecords</code>, Amazon Redshift returns a value in the <code>marker</code> field of the response. You can retrieve the next set of response records by providing the returned <code>marker</code> value in the <code>marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <code>ClusterIdentifier</code> parameter, or the <code>marker</code> parameter, but not both.</p>
  ##   Version: string (required)
  var query_604205 = newJObject()
  add(query_604205, "MaxRecords", newJInt(MaxRecords))
  add(query_604205, "Action", newJString(Action))
  add(query_604205, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_604205, "Marker", newJString(Marker))
  add(query_604205, "Version", newJString(Version))
  result = call_604204.call(nil, query_604205, nil, nil, nil)

var getDescribeClusterDbRevisions* = Call_GetDescribeClusterDbRevisions_604188(
    name: "getDescribeClusterDbRevisions", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusterDbRevisions",
    validator: validate_GetDescribeClusterDbRevisions_604189, base: "/",
    url: url_GetDescribeClusterDbRevisions_604190,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeClusterParameterGroups_604245 = ref object of OpenApiRestCall_602450
proc url_PostDescribeClusterParameterGroups_604247(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostDescribeClusterParameterGroups_604246(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns a list of Amazon Redshift parameter groups, including parameter groups you created and the default parameter group. For each parameter group, the response includes the parameter group name, description, and parameter group family name. You can optionally specify a name to retrieve the description of a specific parameter group.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all parameter groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all parameter groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, parameter groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_604248 = query.getOrDefault("Action")
  valid_604248 = validateParameter(valid_604248, JString, required = true, default = newJString(
      "DescribeClusterParameterGroups"))
  if valid_604248 != nil:
    section.add "Action", valid_604248
  var valid_604249 = query.getOrDefault("Version")
  valid_604249 = validateParameter(valid_604249, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_604249 != nil:
    section.add "Version", valid_604249
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_604250 = header.getOrDefault("X-Amz-Date")
  valid_604250 = validateParameter(valid_604250, JString, required = false,
                                 default = nil)
  if valid_604250 != nil:
    section.add "X-Amz-Date", valid_604250
  var valid_604251 = header.getOrDefault("X-Amz-Security-Token")
  valid_604251 = validateParameter(valid_604251, JString, required = false,
                                 default = nil)
  if valid_604251 != nil:
    section.add "X-Amz-Security-Token", valid_604251
  var valid_604252 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604252 = validateParameter(valid_604252, JString, required = false,
                                 default = nil)
  if valid_604252 != nil:
    section.add "X-Amz-Content-Sha256", valid_604252
  var valid_604253 = header.getOrDefault("X-Amz-Algorithm")
  valid_604253 = validateParameter(valid_604253, JString, required = false,
                                 default = nil)
  if valid_604253 != nil:
    section.add "X-Amz-Algorithm", valid_604253
  var valid_604254 = header.getOrDefault("X-Amz-Signature")
  valid_604254 = validateParameter(valid_604254, JString, required = false,
                                 default = nil)
  if valid_604254 != nil:
    section.add "X-Amz-Signature", valid_604254
  var valid_604255 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604255 = validateParameter(valid_604255, JString, required = false,
                                 default = nil)
  if valid_604255 != nil:
    section.add "X-Amz-SignedHeaders", valid_604255
  var valid_604256 = header.getOrDefault("X-Amz-Credential")
  valid_604256 = validateParameter(valid_604256, JString, required = false,
                                 default = nil)
  if valid_604256 != nil:
    section.add "X-Amz-Credential", valid_604256
  result.add "header", section
  ## parameters in `formData` object:
  ##   ParameterGroupName: JString
  ##                     : The name of a specific parameter group for which to return details. By default, details about all parameter groups and the default parameter group are returned.
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterParameterGroups</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster parameter groups that are associated with the specified key or keys. For example, suppose that you have parameter groups that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the parameter groups that have either or both of these tag keys associated with them.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster parameter groups that are associated with the specified tag value or values. For example, suppose that you have parameter groups that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the parameter groups that have either or both of these tag values associated with them.
  section = newJObject()
  var valid_604257 = formData.getOrDefault("ParameterGroupName")
  valid_604257 = validateParameter(valid_604257, JString, required = false,
                                 default = nil)
  if valid_604257 != nil:
    section.add "ParameterGroupName", valid_604257
  var valid_604258 = formData.getOrDefault("Marker")
  valid_604258 = validateParameter(valid_604258, JString, required = false,
                                 default = nil)
  if valid_604258 != nil:
    section.add "Marker", valid_604258
  var valid_604259 = formData.getOrDefault("TagKeys")
  valid_604259 = validateParameter(valid_604259, JArray, required = false,
                                 default = nil)
  if valid_604259 != nil:
    section.add "TagKeys", valid_604259
  var valid_604260 = formData.getOrDefault("MaxRecords")
  valid_604260 = validateParameter(valid_604260, JInt, required = false, default = nil)
  if valid_604260 != nil:
    section.add "MaxRecords", valid_604260
  var valid_604261 = formData.getOrDefault("TagValues")
  valid_604261 = validateParameter(valid_604261, JArray, required = false,
                                 default = nil)
  if valid_604261 != nil:
    section.add "TagValues", valid_604261
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604262: Call_PostDescribeClusterParameterGroups_604245;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Returns a list of Amazon Redshift parameter groups, including parameter groups you created and the default parameter group. For each parameter group, the response includes the parameter group name, description, and parameter group family name. You can optionally specify a name to retrieve the description of a specific parameter group.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all parameter groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all parameter groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, parameter groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_604262.validator(path, query, header, formData, body)
  let scheme = call_604262.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604262.url(scheme.get, call_604262.host, call_604262.base,
                         call_604262.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_604262, url, valid)

proc call*(call_604263: Call_PostDescribeClusterParameterGroups_604245;
          ParameterGroupName: string = ""; Marker: string = "";
          Action: string = "DescribeClusterParameterGroups";
          TagKeys: JsonNode = nil; MaxRecords: int = 0; TagValues: JsonNode = nil;
          Version: string = "2012-12-01"): Recallable =
  ## postDescribeClusterParameterGroups
  ## <p>Returns a list of Amazon Redshift parameter groups, including parameter groups you created and the default parameter group. For each parameter group, the response includes the parameter group name, description, and parameter group family name. You can optionally specify a name to retrieve the description of a specific parameter group.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all parameter groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all parameter groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, parameter groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   ParameterGroupName: string
  ##                     : The name of a specific parameter group for which to return details. By default, details about all parameter groups and the default parameter group are returned.
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterParameterGroups</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Action: string (required)
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster parameter groups that are associated with the specified key or keys. For example, suppose that you have parameter groups that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the parameter groups that have either or both of these tag keys associated with them.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster parameter groups that are associated with the specified tag value or values. For example, suppose that you have parameter groups that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the parameter groups that have either or both of these tag values associated with them.
  ##   Version: string (required)
  var query_604264 = newJObject()
  var formData_604265 = newJObject()
  add(formData_604265, "ParameterGroupName", newJString(ParameterGroupName))
  add(formData_604265, "Marker", newJString(Marker))
  add(query_604264, "Action", newJString(Action))
  if TagKeys != nil:
    formData_604265.add "TagKeys", TagKeys
  add(formData_604265, "MaxRecords", newJInt(MaxRecords))
  if TagValues != nil:
    formData_604265.add "TagValues", TagValues
  add(query_604264, "Version", newJString(Version))
  result = call_604263.call(nil, query_604264, nil, formData_604265, nil)

var postDescribeClusterParameterGroups* = Call_PostDescribeClusterParameterGroups_604245(
    name: "postDescribeClusterParameterGroups", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeClusterParameterGroups",
    validator: validate_PostDescribeClusterParameterGroups_604246, base: "/",
    url: url_PostDescribeClusterParameterGroups_604247,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeClusterParameterGroups_604225 = ref object of OpenApiRestCall_602450
proc url_GetDescribeClusterParameterGroups_604227(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetDescribeClusterParameterGroups_604226(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns a list of Amazon Redshift parameter groups, including parameter groups you created and the default parameter group. For each parameter group, the response includes the parameter group name, description, and parameter group family name. You can optionally specify a name to retrieve the description of a specific parameter group.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all parameter groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all parameter groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, parameter groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster parameter groups that are associated with the specified tag value or values. For example, suppose that you have parameter groups that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the parameter groups that have either or both of these tag values associated with them.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   ParameterGroupName: JString
  ##                     : The name of a specific parameter group for which to return details. By default, details about all parameter groups and the default parameter group are returned.
  ##   Action: JString (required)
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterParameterGroups</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster parameter groups that are associated with the specified key or keys. For example, suppose that you have parameter groups that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the parameter groups that have either or both of these tag keys associated with them.
  ##   Version: JString (required)
  section = newJObject()
  var valid_604228 = query.getOrDefault("TagValues")
  valid_604228 = validateParameter(valid_604228, JArray, required = false,
                                 default = nil)
  if valid_604228 != nil:
    section.add "TagValues", valid_604228
  var valid_604229 = query.getOrDefault("MaxRecords")
  valid_604229 = validateParameter(valid_604229, JInt, required = false, default = nil)
  if valid_604229 != nil:
    section.add "MaxRecords", valid_604229
  var valid_604230 = query.getOrDefault("ParameterGroupName")
  valid_604230 = validateParameter(valid_604230, JString, required = false,
                                 default = nil)
  if valid_604230 != nil:
    section.add "ParameterGroupName", valid_604230
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_604231 = query.getOrDefault("Action")
  valid_604231 = validateParameter(valid_604231, JString, required = true, default = newJString(
      "DescribeClusterParameterGroups"))
  if valid_604231 != nil:
    section.add "Action", valid_604231
  var valid_604232 = query.getOrDefault("Marker")
  valid_604232 = validateParameter(valid_604232, JString, required = false,
                                 default = nil)
  if valid_604232 != nil:
    section.add "Marker", valid_604232
  var valid_604233 = query.getOrDefault("TagKeys")
  valid_604233 = validateParameter(valid_604233, JArray, required = false,
                                 default = nil)
  if valid_604233 != nil:
    section.add "TagKeys", valid_604233
  var valid_604234 = query.getOrDefault("Version")
  valid_604234 = validateParameter(valid_604234, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_604234 != nil:
    section.add "Version", valid_604234
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_604235 = header.getOrDefault("X-Amz-Date")
  valid_604235 = validateParameter(valid_604235, JString, required = false,
                                 default = nil)
  if valid_604235 != nil:
    section.add "X-Amz-Date", valid_604235
  var valid_604236 = header.getOrDefault("X-Amz-Security-Token")
  valid_604236 = validateParameter(valid_604236, JString, required = false,
                                 default = nil)
  if valid_604236 != nil:
    section.add "X-Amz-Security-Token", valid_604236
  var valid_604237 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604237 = validateParameter(valid_604237, JString, required = false,
                                 default = nil)
  if valid_604237 != nil:
    section.add "X-Amz-Content-Sha256", valid_604237
  var valid_604238 = header.getOrDefault("X-Amz-Algorithm")
  valid_604238 = validateParameter(valid_604238, JString, required = false,
                                 default = nil)
  if valid_604238 != nil:
    section.add "X-Amz-Algorithm", valid_604238
  var valid_604239 = header.getOrDefault("X-Amz-Signature")
  valid_604239 = validateParameter(valid_604239, JString, required = false,
                                 default = nil)
  if valid_604239 != nil:
    section.add "X-Amz-Signature", valid_604239
  var valid_604240 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604240 = validateParameter(valid_604240, JString, required = false,
                                 default = nil)
  if valid_604240 != nil:
    section.add "X-Amz-SignedHeaders", valid_604240
  var valid_604241 = header.getOrDefault("X-Amz-Credential")
  valid_604241 = validateParameter(valid_604241, JString, required = false,
                                 default = nil)
  if valid_604241 != nil:
    section.add "X-Amz-Credential", valid_604241
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604242: Call_GetDescribeClusterParameterGroups_604225;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Returns a list of Amazon Redshift parameter groups, including parameter groups you created and the default parameter group. For each parameter group, the response includes the parameter group name, description, and parameter group family name. You can optionally specify a name to retrieve the description of a specific parameter group.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all parameter groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all parameter groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, parameter groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_604242.validator(path, query, header, formData, body)
  let scheme = call_604242.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604242.url(scheme.get, call_604242.host, call_604242.base,
                         call_604242.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_604242, url, valid)

proc call*(call_604243: Call_GetDescribeClusterParameterGroups_604225;
          TagValues: JsonNode = nil; MaxRecords: int = 0;
          ParameterGroupName: string = "";
          Action: string = "DescribeClusterParameterGroups"; Marker: string = "";
          TagKeys: JsonNode = nil; Version: string = "2012-12-01"): Recallable =
  ## getDescribeClusterParameterGroups
  ## <p>Returns a list of Amazon Redshift parameter groups, including parameter groups you created and the default parameter group. For each parameter group, the response includes the parameter group name, description, and parameter group family name. You can optionally specify a name to retrieve the description of a specific parameter group.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all parameter groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all parameter groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, parameter groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster parameter groups that are associated with the specified tag value or values. For example, suppose that you have parameter groups that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the parameter groups that have either or both of these tag values associated with them.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   ParameterGroupName: string
  ##                     : The name of a specific parameter group for which to return details. By default, details about all parameter groups and the default parameter group are returned.
  ##   Action: string (required)
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterParameterGroups</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster parameter groups that are associated with the specified key or keys. For example, suppose that you have parameter groups that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the parameter groups that have either or both of these tag keys associated with them.
  ##   Version: string (required)
  var query_604244 = newJObject()
  if TagValues != nil:
    query_604244.add "TagValues", TagValues
  add(query_604244, "MaxRecords", newJInt(MaxRecords))
  add(query_604244, "ParameterGroupName", newJString(ParameterGroupName))
  add(query_604244, "Action", newJString(Action))
  add(query_604244, "Marker", newJString(Marker))
  if TagKeys != nil:
    query_604244.add "TagKeys", TagKeys
  add(query_604244, "Version", newJString(Version))
  result = call_604243.call(nil, query_604244, nil, nil, nil)

var getDescribeClusterParameterGroups* = Call_GetDescribeClusterParameterGroups_604225(
    name: "getDescribeClusterParameterGroups", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeClusterParameterGroups",
    validator: validate_GetDescribeClusterParameterGroups_604226, base: "/",
    url: url_GetDescribeClusterParameterGroups_604227,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeClusterParameters_604285 = ref object of OpenApiRestCall_602450
proc url_PostDescribeClusterParameters_604287(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostDescribeClusterParameters_604286(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns a detailed list of parameters contained within the specified Amazon Redshift parameter group. For each parameter the response includes information such as parameter name, description, data type, value, whether the parameter value is modifiable, and so on.</p> <p>You can specify <i>source</i> filter to retrieve parameters of only specific type. For example, to retrieve parameters that were modified by a user action such as from <a>ModifyClusterParameterGroup</a>, you can specify <i>source</i> equal to <i>user</i>.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_604288 = query.getOrDefault("Action")
  valid_604288 = validateParameter(valid_604288, JString, required = true, default = newJString(
      "DescribeClusterParameters"))
  if valid_604288 != nil:
    section.add "Action", valid_604288
  var valid_604289 = query.getOrDefault("Version")
  valid_604289 = validateParameter(valid_604289, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_604289 != nil:
    section.add "Version", valid_604289
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_604290 = header.getOrDefault("X-Amz-Date")
  valid_604290 = validateParameter(valid_604290, JString, required = false,
                                 default = nil)
  if valid_604290 != nil:
    section.add "X-Amz-Date", valid_604290
  var valid_604291 = header.getOrDefault("X-Amz-Security-Token")
  valid_604291 = validateParameter(valid_604291, JString, required = false,
                                 default = nil)
  if valid_604291 != nil:
    section.add "X-Amz-Security-Token", valid_604291
  var valid_604292 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604292 = validateParameter(valid_604292, JString, required = false,
                                 default = nil)
  if valid_604292 != nil:
    section.add "X-Amz-Content-Sha256", valid_604292
  var valid_604293 = header.getOrDefault("X-Amz-Algorithm")
  valid_604293 = validateParameter(valid_604293, JString, required = false,
                                 default = nil)
  if valid_604293 != nil:
    section.add "X-Amz-Algorithm", valid_604293
  var valid_604294 = header.getOrDefault("X-Amz-Signature")
  valid_604294 = validateParameter(valid_604294, JString, required = false,
                                 default = nil)
  if valid_604294 != nil:
    section.add "X-Amz-Signature", valid_604294
  var valid_604295 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604295 = validateParameter(valid_604295, JString, required = false,
                                 default = nil)
  if valid_604295 != nil:
    section.add "X-Amz-SignedHeaders", valid_604295
  var valid_604296 = header.getOrDefault("X-Amz-Credential")
  valid_604296 = validateParameter(valid_604296, JString, required = false,
                                 default = nil)
  if valid_604296 != nil:
    section.add "X-Amz-Credential", valid_604296
  result.add "header", section
  ## parameters in `formData` object:
  ##   ParameterGroupName: JString (required)
  ##                     : The name of a cluster parameter group for which to return details.
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterParameters</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Source: JString
  ##         : <p>The parameter types to return. Specify <code>user</code> to show parameters that are different form the default. Similarly, specify <code>engine-default</code> to show parameters that are the same as the default parameter group. </p> <p>Default: All parameter types returned.</p> <p>Valid Values: <code>user</code> | <code>engine-default</code> </p>
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ParameterGroupName` field"
  var valid_604297 = formData.getOrDefault("ParameterGroupName")
  valid_604297 = validateParameter(valid_604297, JString, required = true,
                                 default = nil)
  if valid_604297 != nil:
    section.add "ParameterGroupName", valid_604297
  var valid_604298 = formData.getOrDefault("Marker")
  valid_604298 = validateParameter(valid_604298, JString, required = false,
                                 default = nil)
  if valid_604298 != nil:
    section.add "Marker", valid_604298
  var valid_604299 = formData.getOrDefault("MaxRecords")
  valid_604299 = validateParameter(valid_604299, JInt, required = false, default = nil)
  if valid_604299 != nil:
    section.add "MaxRecords", valid_604299
  var valid_604300 = formData.getOrDefault("Source")
  valid_604300 = validateParameter(valid_604300, JString, required = false,
                                 default = nil)
  if valid_604300 != nil:
    section.add "Source", valid_604300
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604301: Call_PostDescribeClusterParameters_604285; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns a detailed list of parameters contained within the specified Amazon Redshift parameter group. For each parameter the response includes information such as parameter name, description, data type, value, whether the parameter value is modifiable, and so on.</p> <p>You can specify <i>source</i> filter to retrieve parameters of only specific type. For example, to retrieve parameters that were modified by a user action such as from <a>ModifyClusterParameterGroup</a>, you can specify <i>source</i> equal to <i>user</i>.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_604301.validator(path, query, header, formData, body)
  let scheme = call_604301.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604301.url(scheme.get, call_604301.host, call_604301.base,
                         call_604301.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_604301, url, valid)

proc call*(call_604302: Call_PostDescribeClusterParameters_604285;
          ParameterGroupName: string; Marker: string = "";
          Action: string = "DescribeClusterParameters"; MaxRecords: int = 0;
          Version: string = "2012-12-01"; Source: string = ""): Recallable =
  ## postDescribeClusterParameters
  ## <p>Returns a detailed list of parameters contained within the specified Amazon Redshift parameter group. For each parameter the response includes information such as parameter name, description, data type, value, whether the parameter value is modifiable, and so on.</p> <p>You can specify <i>source</i> filter to retrieve parameters of only specific type. For example, to retrieve parameters that were modified by a user action such as from <a>ModifyClusterParameterGroup</a>, you can specify <i>source</i> equal to <i>user</i>.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   ParameterGroupName: string (required)
  ##                     : The name of a cluster parameter group for which to return details.
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterParameters</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Action: string (required)
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Version: string (required)
  ##   Source: string
  ##         : <p>The parameter types to return. Specify <code>user</code> to show parameters that are different form the default. Similarly, specify <code>engine-default</code> to show parameters that are the same as the default parameter group. </p> <p>Default: All parameter types returned.</p> <p>Valid Values: <code>user</code> | <code>engine-default</code> </p>
  var query_604303 = newJObject()
  var formData_604304 = newJObject()
  add(formData_604304, "ParameterGroupName", newJString(ParameterGroupName))
  add(formData_604304, "Marker", newJString(Marker))
  add(query_604303, "Action", newJString(Action))
  add(formData_604304, "MaxRecords", newJInt(MaxRecords))
  add(query_604303, "Version", newJString(Version))
  add(formData_604304, "Source", newJString(Source))
  result = call_604302.call(nil, query_604303, nil, formData_604304, nil)

var postDescribeClusterParameters* = Call_PostDescribeClusterParameters_604285(
    name: "postDescribeClusterParameters", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusterParameters",
    validator: validate_PostDescribeClusterParameters_604286, base: "/",
    url: url_PostDescribeClusterParameters_604287,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeClusterParameters_604266 = ref object of OpenApiRestCall_602450
proc url_GetDescribeClusterParameters_604268(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetDescribeClusterParameters_604267(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns a detailed list of parameters contained within the specified Amazon Redshift parameter group. For each parameter the response includes information such as parameter name, description, data type, value, whether the parameter value is modifiable, and so on.</p> <p>You can specify <i>source</i> filter to retrieve parameters of only specific type. For example, to retrieve parameters that were modified by a user action such as from <a>ModifyClusterParameterGroup</a>, you can specify <i>source</i> equal to <i>user</i>.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   ParameterGroupName: JString (required)
  ##                     : The name of a cluster parameter group for which to return details.
  ##   Action: JString (required)
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterParameters</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Source: JString
  ##         : <p>The parameter types to return. Specify <code>user</code> to show parameters that are different form the default. Similarly, specify <code>engine-default</code> to show parameters that are the same as the default parameter group. </p> <p>Default: All parameter types returned.</p> <p>Valid Values: <code>user</code> | <code>engine-default</code> </p>
  ##   Version: JString (required)
  section = newJObject()
  var valid_604269 = query.getOrDefault("MaxRecords")
  valid_604269 = validateParameter(valid_604269, JInt, required = false, default = nil)
  if valid_604269 != nil:
    section.add "MaxRecords", valid_604269
  assert query != nil, "query argument is necessary due to required `ParameterGroupName` field"
  var valid_604270 = query.getOrDefault("ParameterGroupName")
  valid_604270 = validateParameter(valid_604270, JString, required = true,
                                 default = nil)
  if valid_604270 != nil:
    section.add "ParameterGroupName", valid_604270
  var valid_604271 = query.getOrDefault("Action")
  valid_604271 = validateParameter(valid_604271, JString, required = true, default = newJString(
      "DescribeClusterParameters"))
  if valid_604271 != nil:
    section.add "Action", valid_604271
  var valid_604272 = query.getOrDefault("Marker")
  valid_604272 = validateParameter(valid_604272, JString, required = false,
                                 default = nil)
  if valid_604272 != nil:
    section.add "Marker", valid_604272
  var valid_604273 = query.getOrDefault("Source")
  valid_604273 = validateParameter(valid_604273, JString, required = false,
                                 default = nil)
  if valid_604273 != nil:
    section.add "Source", valid_604273
  var valid_604274 = query.getOrDefault("Version")
  valid_604274 = validateParameter(valid_604274, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_604274 != nil:
    section.add "Version", valid_604274
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_604275 = header.getOrDefault("X-Amz-Date")
  valid_604275 = validateParameter(valid_604275, JString, required = false,
                                 default = nil)
  if valid_604275 != nil:
    section.add "X-Amz-Date", valid_604275
  var valid_604276 = header.getOrDefault("X-Amz-Security-Token")
  valid_604276 = validateParameter(valid_604276, JString, required = false,
                                 default = nil)
  if valid_604276 != nil:
    section.add "X-Amz-Security-Token", valid_604276
  var valid_604277 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604277 = validateParameter(valid_604277, JString, required = false,
                                 default = nil)
  if valid_604277 != nil:
    section.add "X-Amz-Content-Sha256", valid_604277
  var valid_604278 = header.getOrDefault("X-Amz-Algorithm")
  valid_604278 = validateParameter(valid_604278, JString, required = false,
                                 default = nil)
  if valid_604278 != nil:
    section.add "X-Amz-Algorithm", valid_604278
  var valid_604279 = header.getOrDefault("X-Amz-Signature")
  valid_604279 = validateParameter(valid_604279, JString, required = false,
                                 default = nil)
  if valid_604279 != nil:
    section.add "X-Amz-Signature", valid_604279
  var valid_604280 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604280 = validateParameter(valid_604280, JString, required = false,
                                 default = nil)
  if valid_604280 != nil:
    section.add "X-Amz-SignedHeaders", valid_604280
  var valid_604281 = header.getOrDefault("X-Amz-Credential")
  valid_604281 = validateParameter(valid_604281, JString, required = false,
                                 default = nil)
  if valid_604281 != nil:
    section.add "X-Amz-Credential", valid_604281
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604282: Call_GetDescribeClusterParameters_604266; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns a detailed list of parameters contained within the specified Amazon Redshift parameter group. For each parameter the response includes information such as parameter name, description, data type, value, whether the parameter value is modifiable, and so on.</p> <p>You can specify <i>source</i> filter to retrieve parameters of only specific type. For example, to retrieve parameters that were modified by a user action such as from <a>ModifyClusterParameterGroup</a>, you can specify <i>source</i> equal to <i>user</i>.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_604282.validator(path, query, header, formData, body)
  let scheme = call_604282.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604282.url(scheme.get, call_604282.host, call_604282.base,
                         call_604282.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_604282, url, valid)

proc call*(call_604283: Call_GetDescribeClusterParameters_604266;
          ParameterGroupName: string; MaxRecords: int = 0;
          Action: string = "DescribeClusterParameters"; Marker: string = "";
          Source: string = ""; Version: string = "2012-12-01"): Recallable =
  ## getDescribeClusterParameters
  ## <p>Returns a detailed list of parameters contained within the specified Amazon Redshift parameter group. For each parameter the response includes information such as parameter name, description, data type, value, whether the parameter value is modifiable, and so on.</p> <p>You can specify <i>source</i> filter to retrieve parameters of only specific type. For example, to retrieve parameters that were modified by a user action such as from <a>ModifyClusterParameterGroup</a>, you can specify <i>source</i> equal to <i>user</i>.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   ParameterGroupName: string (required)
  ##                     : The name of a cluster parameter group for which to return details.
  ##   Action: string (required)
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterParameters</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Source: string
  ##         : <p>The parameter types to return. Specify <code>user</code> to show parameters that are different form the default. Similarly, specify <code>engine-default</code> to show parameters that are the same as the default parameter group. </p> <p>Default: All parameter types returned.</p> <p>Valid Values: <code>user</code> | <code>engine-default</code> </p>
  ##   Version: string (required)
  var query_604284 = newJObject()
  add(query_604284, "MaxRecords", newJInt(MaxRecords))
  add(query_604284, "ParameterGroupName", newJString(ParameterGroupName))
  add(query_604284, "Action", newJString(Action))
  add(query_604284, "Marker", newJString(Marker))
  add(query_604284, "Source", newJString(Source))
  add(query_604284, "Version", newJString(Version))
  result = call_604283.call(nil, query_604284, nil, nil, nil)

var getDescribeClusterParameters* = Call_GetDescribeClusterParameters_604266(
    name: "getDescribeClusterParameters", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusterParameters",
    validator: validate_GetDescribeClusterParameters_604267, base: "/",
    url: url_GetDescribeClusterParameters_604268,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeClusterSecurityGroups_604325 = ref object of OpenApiRestCall_602450
proc url_PostDescribeClusterSecurityGroups_604327(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostDescribeClusterSecurityGroups_604326(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns information about Amazon Redshift security groups. If the name of a security group is specified, the response will contain only information about only that security group.</p> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all security groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all security groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, security groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_604328 = query.getOrDefault("Action")
  valid_604328 = validateParameter(valid_604328, JString, required = true, default = newJString(
      "DescribeClusterSecurityGroups"))
  if valid_604328 != nil:
    section.add "Action", valid_604328
  var valid_604329 = query.getOrDefault("Version")
  valid_604329 = validateParameter(valid_604329, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_604329 != nil:
    section.add "Version", valid_604329
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_604330 = header.getOrDefault("X-Amz-Date")
  valid_604330 = validateParameter(valid_604330, JString, required = false,
                                 default = nil)
  if valid_604330 != nil:
    section.add "X-Amz-Date", valid_604330
  var valid_604331 = header.getOrDefault("X-Amz-Security-Token")
  valid_604331 = validateParameter(valid_604331, JString, required = false,
                                 default = nil)
  if valid_604331 != nil:
    section.add "X-Amz-Security-Token", valid_604331
  var valid_604332 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604332 = validateParameter(valid_604332, JString, required = false,
                                 default = nil)
  if valid_604332 != nil:
    section.add "X-Amz-Content-Sha256", valid_604332
  var valid_604333 = header.getOrDefault("X-Amz-Algorithm")
  valid_604333 = validateParameter(valid_604333, JString, required = false,
                                 default = nil)
  if valid_604333 != nil:
    section.add "X-Amz-Algorithm", valid_604333
  var valid_604334 = header.getOrDefault("X-Amz-Signature")
  valid_604334 = validateParameter(valid_604334, JString, required = false,
                                 default = nil)
  if valid_604334 != nil:
    section.add "X-Amz-Signature", valid_604334
  var valid_604335 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604335 = validateParameter(valid_604335, JString, required = false,
                                 default = nil)
  if valid_604335 != nil:
    section.add "X-Amz-SignedHeaders", valid_604335
  var valid_604336 = header.getOrDefault("X-Amz-Credential")
  valid_604336 = validateParameter(valid_604336, JString, required = false,
                                 default = nil)
  if valid_604336 != nil:
    section.add "X-Amz-Credential", valid_604336
  result.add "header", section
  ## parameters in `formData` object:
  ##   Marker: JString
  ##         : <p>An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterSecurityGroups</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <b>ClusterSecurityGroupName</b> parameter or the <b>Marker</b> parameter, but not both. </p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster security groups that are associated with the specified key or keys. For example, suppose that you have security groups that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the security groups that have either or both of these tag keys associated with them.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster security groups that are associated with the specified tag value or values. For example, suppose that you have security groups that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the security groups that have either or both of these tag values associated with them.
  ##   ClusterSecurityGroupName: JString
  ##                           : <p>The name of a cluster security group for which you are requesting details. You can specify either the <b>Marker</b> parameter or a <b>ClusterSecurityGroupName</b> parameter, but not both. </p> <p> Example: <code>securitygroup1</code> </p>
  section = newJObject()
  var valid_604337 = formData.getOrDefault("Marker")
  valid_604337 = validateParameter(valid_604337, JString, required = false,
                                 default = nil)
  if valid_604337 != nil:
    section.add "Marker", valid_604337
  var valid_604338 = formData.getOrDefault("TagKeys")
  valid_604338 = validateParameter(valid_604338, JArray, required = false,
                                 default = nil)
  if valid_604338 != nil:
    section.add "TagKeys", valid_604338
  var valid_604339 = formData.getOrDefault("MaxRecords")
  valid_604339 = validateParameter(valid_604339, JInt, required = false, default = nil)
  if valid_604339 != nil:
    section.add "MaxRecords", valid_604339
  var valid_604340 = formData.getOrDefault("TagValues")
  valid_604340 = validateParameter(valid_604340, JArray, required = false,
                                 default = nil)
  if valid_604340 != nil:
    section.add "TagValues", valid_604340
  var valid_604341 = formData.getOrDefault("ClusterSecurityGroupName")
  valid_604341 = validateParameter(valid_604341, JString, required = false,
                                 default = nil)
  if valid_604341 != nil:
    section.add "ClusterSecurityGroupName", valid_604341
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604342: Call_PostDescribeClusterSecurityGroups_604325;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Returns information about Amazon Redshift security groups. If the name of a security group is specified, the response will contain only information about only that security group.</p> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all security groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all security groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, security groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_604342.validator(path, query, header, formData, body)
  let scheme = call_604342.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604342.url(scheme.get, call_604342.host, call_604342.base,
                         call_604342.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_604342, url, valid)

proc call*(call_604343: Call_PostDescribeClusterSecurityGroups_604325;
          Marker: string = ""; Action: string = "DescribeClusterSecurityGroups";
          TagKeys: JsonNode = nil; MaxRecords: int = 0; TagValues: JsonNode = nil;
          Version: string = "2012-12-01"; ClusterSecurityGroupName: string = ""): Recallable =
  ## postDescribeClusterSecurityGroups
  ## <p>Returns information about Amazon Redshift security groups. If the name of a security group is specified, the response will contain only information about only that security group.</p> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all security groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all security groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, security groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   Marker: string
  ##         : <p>An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterSecurityGroups</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <b>ClusterSecurityGroupName</b> parameter or the <b>Marker</b> parameter, but not both. </p>
  ##   Action: string (required)
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster security groups that are associated with the specified key or keys. For example, suppose that you have security groups that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the security groups that have either or both of these tag keys associated with them.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster security groups that are associated with the specified tag value or values. For example, suppose that you have security groups that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the security groups that have either or both of these tag values associated with them.
  ##   Version: string (required)
  ##   ClusterSecurityGroupName: string
  ##                           : <p>The name of a cluster security group for which you are requesting details. You can specify either the <b>Marker</b> parameter or a <b>ClusterSecurityGroupName</b> parameter, but not both. </p> <p> Example: <code>securitygroup1</code> </p>
  var query_604344 = newJObject()
  var formData_604345 = newJObject()
  add(formData_604345, "Marker", newJString(Marker))
  add(query_604344, "Action", newJString(Action))
  if TagKeys != nil:
    formData_604345.add "TagKeys", TagKeys
  add(formData_604345, "MaxRecords", newJInt(MaxRecords))
  if TagValues != nil:
    formData_604345.add "TagValues", TagValues
  add(query_604344, "Version", newJString(Version))
  add(formData_604345, "ClusterSecurityGroupName",
      newJString(ClusterSecurityGroupName))
  result = call_604343.call(nil, query_604344, nil, formData_604345, nil)

var postDescribeClusterSecurityGroups* = Call_PostDescribeClusterSecurityGroups_604325(
    name: "postDescribeClusterSecurityGroups", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeClusterSecurityGroups",
    validator: validate_PostDescribeClusterSecurityGroups_604326, base: "/",
    url: url_PostDescribeClusterSecurityGroups_604327,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeClusterSecurityGroups_604305 = ref object of OpenApiRestCall_602450
proc url_GetDescribeClusterSecurityGroups_604307(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetDescribeClusterSecurityGroups_604306(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns information about Amazon Redshift security groups. If the name of a security group is specified, the response will contain only information about only that security group.</p> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all security groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all security groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, security groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster security groups that are associated with the specified tag value or values. For example, suppose that you have security groups that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the security groups that have either or both of these tag values associated with them.
  ##   ClusterSecurityGroupName: JString
  ##                           : <p>The name of a cluster security group for which you are requesting details. You can specify either the <b>Marker</b> parameter or a <b>ClusterSecurityGroupName</b> parameter, but not both. </p> <p> Example: <code>securitygroup1</code> </p>
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Action: JString (required)
  ##   Marker: JString
  ##         : <p>An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterSecurityGroups</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <b>ClusterSecurityGroupName</b> parameter or the <b>Marker</b> parameter, but not both. </p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster security groups that are associated with the specified key or keys. For example, suppose that you have security groups that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the security groups that have either or both of these tag keys associated with them.
  ##   Version: JString (required)
  section = newJObject()
  var valid_604308 = query.getOrDefault("TagValues")
  valid_604308 = validateParameter(valid_604308, JArray, required = false,
                                 default = nil)
  if valid_604308 != nil:
    section.add "TagValues", valid_604308
  var valid_604309 = query.getOrDefault("ClusterSecurityGroupName")
  valid_604309 = validateParameter(valid_604309, JString, required = false,
                                 default = nil)
  if valid_604309 != nil:
    section.add "ClusterSecurityGroupName", valid_604309
  var valid_604310 = query.getOrDefault("MaxRecords")
  valid_604310 = validateParameter(valid_604310, JInt, required = false, default = nil)
  if valid_604310 != nil:
    section.add "MaxRecords", valid_604310
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_604311 = query.getOrDefault("Action")
  valid_604311 = validateParameter(valid_604311, JString, required = true, default = newJString(
      "DescribeClusterSecurityGroups"))
  if valid_604311 != nil:
    section.add "Action", valid_604311
  var valid_604312 = query.getOrDefault("Marker")
  valid_604312 = validateParameter(valid_604312, JString, required = false,
                                 default = nil)
  if valid_604312 != nil:
    section.add "Marker", valid_604312
  var valid_604313 = query.getOrDefault("TagKeys")
  valid_604313 = validateParameter(valid_604313, JArray, required = false,
                                 default = nil)
  if valid_604313 != nil:
    section.add "TagKeys", valid_604313
  var valid_604314 = query.getOrDefault("Version")
  valid_604314 = validateParameter(valid_604314, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_604314 != nil:
    section.add "Version", valid_604314
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_604315 = header.getOrDefault("X-Amz-Date")
  valid_604315 = validateParameter(valid_604315, JString, required = false,
                                 default = nil)
  if valid_604315 != nil:
    section.add "X-Amz-Date", valid_604315
  var valid_604316 = header.getOrDefault("X-Amz-Security-Token")
  valid_604316 = validateParameter(valid_604316, JString, required = false,
                                 default = nil)
  if valid_604316 != nil:
    section.add "X-Amz-Security-Token", valid_604316
  var valid_604317 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604317 = validateParameter(valid_604317, JString, required = false,
                                 default = nil)
  if valid_604317 != nil:
    section.add "X-Amz-Content-Sha256", valid_604317
  var valid_604318 = header.getOrDefault("X-Amz-Algorithm")
  valid_604318 = validateParameter(valid_604318, JString, required = false,
                                 default = nil)
  if valid_604318 != nil:
    section.add "X-Amz-Algorithm", valid_604318
  var valid_604319 = header.getOrDefault("X-Amz-Signature")
  valid_604319 = validateParameter(valid_604319, JString, required = false,
                                 default = nil)
  if valid_604319 != nil:
    section.add "X-Amz-Signature", valid_604319
  var valid_604320 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604320 = validateParameter(valid_604320, JString, required = false,
                                 default = nil)
  if valid_604320 != nil:
    section.add "X-Amz-SignedHeaders", valid_604320
  var valid_604321 = header.getOrDefault("X-Amz-Credential")
  valid_604321 = validateParameter(valid_604321, JString, required = false,
                                 default = nil)
  if valid_604321 != nil:
    section.add "X-Amz-Credential", valid_604321
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604322: Call_GetDescribeClusterSecurityGroups_604305;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Returns information about Amazon Redshift security groups. If the name of a security group is specified, the response will contain only information about only that security group.</p> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all security groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all security groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, security groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_604322.validator(path, query, header, formData, body)
  let scheme = call_604322.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604322.url(scheme.get, call_604322.host, call_604322.base,
                         call_604322.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_604322, url, valid)

proc call*(call_604323: Call_GetDescribeClusterSecurityGroups_604305;
          TagValues: JsonNode = nil; ClusterSecurityGroupName: string = "";
          MaxRecords: int = 0; Action: string = "DescribeClusterSecurityGroups";
          Marker: string = ""; TagKeys: JsonNode = nil; Version: string = "2012-12-01"): Recallable =
  ## getDescribeClusterSecurityGroups
  ## <p>Returns information about Amazon Redshift security groups. If the name of a security group is specified, the response will contain only information about only that security group.</p> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all security groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all security groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, security groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster security groups that are associated with the specified tag value or values. For example, suppose that you have security groups that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the security groups that have either or both of these tag values associated with them.
  ##   ClusterSecurityGroupName: string
  ##                           : <p>The name of a cluster security group for which you are requesting details. You can specify either the <b>Marker</b> parameter or a <b>ClusterSecurityGroupName</b> parameter, but not both. </p> <p> Example: <code>securitygroup1</code> </p>
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Action: string (required)
  ##   Marker: string
  ##         : <p>An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterSecurityGroups</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <b>ClusterSecurityGroupName</b> parameter or the <b>Marker</b> parameter, but not both. </p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster security groups that are associated with the specified key or keys. For example, suppose that you have security groups that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the security groups that have either or both of these tag keys associated with them.
  ##   Version: string (required)
  var query_604324 = newJObject()
  if TagValues != nil:
    query_604324.add "TagValues", TagValues
  add(query_604324, "ClusterSecurityGroupName",
      newJString(ClusterSecurityGroupName))
  add(query_604324, "MaxRecords", newJInt(MaxRecords))
  add(query_604324, "Action", newJString(Action))
  add(query_604324, "Marker", newJString(Marker))
  if TagKeys != nil:
    query_604324.add "TagKeys", TagKeys
  add(query_604324, "Version", newJString(Version))
  result = call_604323.call(nil, query_604324, nil, nil, nil)

var getDescribeClusterSecurityGroups* = Call_GetDescribeClusterSecurityGroups_604305(
    name: "getDescribeClusterSecurityGroups", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeClusterSecurityGroups",
    validator: validate_GetDescribeClusterSecurityGroups_604306, base: "/",
    url: url_GetDescribeClusterSecurityGroups_604307,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeClusterSnapshots_604373 = ref object of OpenApiRestCall_602450
proc url_PostDescribeClusterSnapshots_604375(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostDescribeClusterSnapshots_604374(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns one or more snapshot objects, which contain metadata about your cluster snapshots. By default, this operation returns information about all snapshots of all clusters that are owned by you AWS customer account. No information is returned for snapshots owned by inactive AWS customer accounts.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all snapshots that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all snapshots that have any combination of those values are returned. Only snapshots that you own are returned in the response; shared snapshots are not returned with the tag key and tag value request parameters.</p> <p>If both tag keys and values are omitted from the request, snapshots are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_604376 = query.getOrDefault("Action")
  valid_604376 = validateParameter(valid_604376, JString, required = true, default = newJString(
      "DescribeClusterSnapshots"))
  if valid_604376 != nil:
    section.add "Action", valid_604376
  var valid_604377 = query.getOrDefault("Version")
  valid_604377 = validateParameter(valid_604377, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_604377 != nil:
    section.add "Version", valid_604377
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_604378 = header.getOrDefault("X-Amz-Date")
  valid_604378 = validateParameter(valid_604378, JString, required = false,
                                 default = nil)
  if valid_604378 != nil:
    section.add "X-Amz-Date", valid_604378
  var valid_604379 = header.getOrDefault("X-Amz-Security-Token")
  valid_604379 = validateParameter(valid_604379, JString, required = false,
                                 default = nil)
  if valid_604379 != nil:
    section.add "X-Amz-Security-Token", valid_604379
  var valid_604380 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604380 = validateParameter(valid_604380, JString, required = false,
                                 default = nil)
  if valid_604380 != nil:
    section.add "X-Amz-Content-Sha256", valid_604380
  var valid_604381 = header.getOrDefault("X-Amz-Algorithm")
  valid_604381 = validateParameter(valid_604381, JString, required = false,
                                 default = nil)
  if valid_604381 != nil:
    section.add "X-Amz-Algorithm", valid_604381
  var valid_604382 = header.getOrDefault("X-Amz-Signature")
  valid_604382 = validateParameter(valid_604382, JString, required = false,
                                 default = nil)
  if valid_604382 != nil:
    section.add "X-Amz-Signature", valid_604382
  var valid_604383 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604383 = validateParameter(valid_604383, JString, required = false,
                                 default = nil)
  if valid_604383 != nil:
    section.add "X-Amz-SignedHeaders", valid_604383
  var valid_604384 = header.getOrDefault("X-Amz-Credential")
  valid_604384 = validateParameter(valid_604384, JString, required = false,
                                 default = nil)
  if valid_604384 != nil:
    section.add "X-Amz-Credential", valid_604384
  result.add "header", section
  ## parameters in `formData` object:
  ##   SortingEntities: JArray
  ##                  : <p/>
  ##   SnapshotType: JString
  ##               : <p>The type of snapshots for which you are requesting information. By default, snapshots of all types are returned.</p> <p>Valid Values: <code>automated</code> | <code>manual</code> </p>
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterSnapshots</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   StartTime: JString
  ##            : <p>A value that requests only snapshots created at or after the specified time. The time value is specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2012-07-16T18:00:00Z</code> </p>
  ##   OwnerAccount: JString
  ##               : The AWS customer account used to create or copy the snapshot. Use this field to filter the results to snapshots owned by a particular account. To describe snapshots you own, either specify your AWS customer account, or do not specify the parameter.
  ##   ClusterIdentifier: JString
  ##                    : The identifier of the cluster which generated the requested snapshots.
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster snapshots that are associated with the specified key or keys. For example, suppose that you have snapshots that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the snapshots that have either or both of these tag keys associated with them.
  ##   EndTime: JString
  ##          : <p>A time value that requests only snapshots created at or before the specified time. The time value is specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2012-07-16T18:00:00Z</code> </p>
  ##   ClusterExists: JBool
  ##                : <p>A value that indicates whether to return snapshots only for an existing cluster. You can perform table-level restore only by using a snapshot of an existing cluster, that is, a cluster that has not been deleted. Values for this parameter work as follows: </p> <ul> <li> <p>If <code>ClusterExists</code> is set to <code>true</code>, <code>ClusterIdentifier</code> is required.</p> </li> <li> <p>If <code>ClusterExists</code> is set to <code>false</code> and <code>ClusterIdentifier</code> isn't specified, all snapshots associated with deleted clusters (orphaned snapshots) are returned. </p> </li> <li> <p>If <code>ClusterExists</code> is set to <code>false</code> and <code>ClusterIdentifier</code> is specified for a deleted cluster, snapshots associated with that cluster are returned.</p> </li> <li> <p>If <code>ClusterExists</code> is set to <code>false</code> and <code>ClusterIdentifier</code> is specified for an existing cluster, no snapshots are returned. </p> </li> </ul>
  ##   SnapshotIdentifier: JString
  ##                     : The snapshot identifier of the snapshot about which to return information.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster snapshots that are associated with the specified tag value or values. For example, suppose that you have snapshots that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the snapshots that have either or both of these tag values associated with them.
  section = newJObject()
  var valid_604385 = formData.getOrDefault("SortingEntities")
  valid_604385 = validateParameter(valid_604385, JArray, required = false,
                                 default = nil)
  if valid_604385 != nil:
    section.add "SortingEntities", valid_604385
  var valid_604386 = formData.getOrDefault("SnapshotType")
  valid_604386 = validateParameter(valid_604386, JString, required = false,
                                 default = nil)
  if valid_604386 != nil:
    section.add "SnapshotType", valid_604386
  var valid_604387 = formData.getOrDefault("Marker")
  valid_604387 = validateParameter(valid_604387, JString, required = false,
                                 default = nil)
  if valid_604387 != nil:
    section.add "Marker", valid_604387
  var valid_604388 = formData.getOrDefault("StartTime")
  valid_604388 = validateParameter(valid_604388, JString, required = false,
                                 default = nil)
  if valid_604388 != nil:
    section.add "StartTime", valid_604388
  var valid_604389 = formData.getOrDefault("OwnerAccount")
  valid_604389 = validateParameter(valid_604389, JString, required = false,
                                 default = nil)
  if valid_604389 != nil:
    section.add "OwnerAccount", valid_604389
  var valid_604390 = formData.getOrDefault("ClusterIdentifier")
  valid_604390 = validateParameter(valid_604390, JString, required = false,
                                 default = nil)
  if valid_604390 != nil:
    section.add "ClusterIdentifier", valid_604390
  var valid_604391 = formData.getOrDefault("TagKeys")
  valid_604391 = validateParameter(valid_604391, JArray, required = false,
                                 default = nil)
  if valid_604391 != nil:
    section.add "TagKeys", valid_604391
  var valid_604392 = formData.getOrDefault("EndTime")
  valid_604392 = validateParameter(valid_604392, JString, required = false,
                                 default = nil)
  if valid_604392 != nil:
    section.add "EndTime", valid_604392
  var valid_604393 = formData.getOrDefault("ClusterExists")
  valid_604393 = validateParameter(valid_604393, JBool, required = false, default = nil)
  if valid_604393 != nil:
    section.add "ClusterExists", valid_604393
  var valid_604394 = formData.getOrDefault("SnapshotIdentifier")
  valid_604394 = validateParameter(valid_604394, JString, required = false,
                                 default = nil)
  if valid_604394 != nil:
    section.add "SnapshotIdentifier", valid_604394
  var valid_604395 = formData.getOrDefault("MaxRecords")
  valid_604395 = validateParameter(valid_604395, JInt, required = false, default = nil)
  if valid_604395 != nil:
    section.add "MaxRecords", valid_604395
  var valid_604396 = formData.getOrDefault("TagValues")
  valid_604396 = validateParameter(valid_604396, JArray, required = false,
                                 default = nil)
  if valid_604396 != nil:
    section.add "TagValues", valid_604396
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604397: Call_PostDescribeClusterSnapshots_604373; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns one or more snapshot objects, which contain metadata about your cluster snapshots. By default, this operation returns information about all snapshots of all clusters that are owned by you AWS customer account. No information is returned for snapshots owned by inactive AWS customer accounts.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all snapshots that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all snapshots that have any combination of those values are returned. Only snapshots that you own are returned in the response; shared snapshots are not returned with the tag key and tag value request parameters.</p> <p>If both tag keys and values are omitted from the request, snapshots are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_604397.validator(path, query, header, formData, body)
  let scheme = call_604397.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604397.url(scheme.get, call_604397.host, call_604397.base,
                         call_604397.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_604397, url, valid)

proc call*(call_604398: Call_PostDescribeClusterSnapshots_604373;
          SortingEntities: JsonNode = nil; SnapshotType: string = "";
          Marker: string = ""; StartTime: string = "";
          Action: string = "DescribeClusterSnapshots"; OwnerAccount: string = "";
          ClusterIdentifier: string = ""; TagKeys: JsonNode = nil; EndTime: string = "";
          ClusterExists: bool = false; SnapshotIdentifier: string = "";
          MaxRecords: int = 0; TagValues: JsonNode = nil; Version: string = "2012-12-01"): Recallable =
  ## postDescribeClusterSnapshots
  ## <p>Returns one or more snapshot objects, which contain metadata about your cluster snapshots. By default, this operation returns information about all snapshots of all clusters that are owned by you AWS customer account. No information is returned for snapshots owned by inactive AWS customer accounts.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all snapshots that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all snapshots that have any combination of those values are returned. Only snapshots that you own are returned in the response; shared snapshots are not returned with the tag key and tag value request parameters.</p> <p>If both tag keys and values are omitted from the request, snapshots are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   SortingEntities: JArray
  ##                  : <p/>
  ##   SnapshotType: string
  ##               : <p>The type of snapshots for which you are requesting information. By default, snapshots of all types are returned.</p> <p>Valid Values: <code>automated</code> | <code>manual</code> </p>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterSnapshots</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   StartTime: string
  ##            : <p>A value that requests only snapshots created at or after the specified time. The time value is specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2012-07-16T18:00:00Z</code> </p>
  ##   Action: string (required)
  ##   OwnerAccount: string
  ##               : The AWS customer account used to create or copy the snapshot. Use this field to filter the results to snapshots owned by a particular account. To describe snapshots you own, either specify your AWS customer account, or do not specify the parameter.
  ##   ClusterIdentifier: string
  ##                    : The identifier of the cluster which generated the requested snapshots.
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster snapshots that are associated with the specified key or keys. For example, suppose that you have snapshots that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the snapshots that have either or both of these tag keys associated with them.
  ##   EndTime: string
  ##          : <p>A time value that requests only snapshots created at or before the specified time. The time value is specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2012-07-16T18:00:00Z</code> </p>
  ##   ClusterExists: bool
  ##                : <p>A value that indicates whether to return snapshots only for an existing cluster. You can perform table-level restore only by using a snapshot of an existing cluster, that is, a cluster that has not been deleted. Values for this parameter work as follows: </p> <ul> <li> <p>If <code>ClusterExists</code> is set to <code>true</code>, <code>ClusterIdentifier</code> is required.</p> </li> <li> <p>If <code>ClusterExists</code> is set to <code>false</code> and <code>ClusterIdentifier</code> isn't specified, all snapshots associated with deleted clusters (orphaned snapshots) are returned. </p> </li> <li> <p>If <code>ClusterExists</code> is set to <code>false</code> and <code>ClusterIdentifier</code> is specified for a deleted cluster, snapshots associated with that cluster are returned.</p> </li> <li> <p>If <code>ClusterExists</code> is set to <code>false</code> and <code>ClusterIdentifier</code> is specified for an existing cluster, no snapshots are returned. </p> </li> </ul>
  ##   SnapshotIdentifier: string
  ##                     : The snapshot identifier of the snapshot about which to return information.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster snapshots that are associated with the specified tag value or values. For example, suppose that you have snapshots that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the snapshots that have either or both of these tag values associated with them.
  ##   Version: string (required)
  var query_604399 = newJObject()
  var formData_604400 = newJObject()
  if SortingEntities != nil:
    formData_604400.add "SortingEntities", SortingEntities
  add(formData_604400, "SnapshotType", newJString(SnapshotType))
  add(formData_604400, "Marker", newJString(Marker))
  add(formData_604400, "StartTime", newJString(StartTime))
  add(query_604399, "Action", newJString(Action))
  add(formData_604400, "OwnerAccount", newJString(OwnerAccount))
  add(formData_604400, "ClusterIdentifier", newJString(ClusterIdentifier))
  if TagKeys != nil:
    formData_604400.add "TagKeys", TagKeys
  add(formData_604400, "EndTime", newJString(EndTime))
  add(formData_604400, "ClusterExists", newJBool(ClusterExists))
  add(formData_604400, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(formData_604400, "MaxRecords", newJInt(MaxRecords))
  if TagValues != nil:
    formData_604400.add "TagValues", TagValues
  add(query_604399, "Version", newJString(Version))
  result = call_604398.call(nil, query_604399, nil, formData_604400, nil)

var postDescribeClusterSnapshots* = Call_PostDescribeClusterSnapshots_604373(
    name: "postDescribeClusterSnapshots", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusterSnapshots",
    validator: validate_PostDescribeClusterSnapshots_604374, base: "/",
    url: url_PostDescribeClusterSnapshots_604375,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeClusterSnapshots_604346 = ref object of OpenApiRestCall_602450
proc url_GetDescribeClusterSnapshots_604348(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetDescribeClusterSnapshots_604347(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns one or more snapshot objects, which contain metadata about your cluster snapshots. By default, this operation returns information about all snapshots of all clusters that are owned by you AWS customer account. No information is returned for snapshots owned by inactive AWS customer accounts.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all snapshots that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all snapshots that have any combination of those values are returned. Only snapshots that you own are returned in the response; shared snapshots are not returned with the tag key and tag value request parameters.</p> <p>If both tag keys and values are omitted from the request, snapshots are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster snapshots that are associated with the specified tag value or values. For example, suppose that you have snapshots that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the snapshots that have either or both of these tag values associated with them.
  ##   SortingEntities: JArray
  ##                  : <p/>
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   StartTime: JString
  ##            : <p>A value that requests only snapshots created at or after the specified time. The time value is specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2012-07-16T18:00:00Z</code> </p>
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString
  ##                    : The identifier of the cluster which generated the requested snapshots.
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterSnapshots</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   OwnerAccount: JString
  ##               : The AWS customer account used to create or copy the snapshot. Use this field to filter the results to snapshots owned by a particular account. To describe snapshots you own, either specify your AWS customer account, or do not specify the parameter.
  ##   ClusterExists: JBool
  ##                : <p>A value that indicates whether to return snapshots only for an existing cluster. You can perform table-level restore only by using a snapshot of an existing cluster, that is, a cluster that has not been deleted. Values for this parameter work as follows: </p> <ul> <li> <p>If <code>ClusterExists</code> is set to <code>true</code>, <code>ClusterIdentifier</code> is required.</p> </li> <li> <p>If <code>ClusterExists</code> is set to <code>false</code> and <code>ClusterIdentifier</code> isn't specified, all snapshots associated with deleted clusters (orphaned snapshots) are returned. </p> </li> <li> <p>If <code>ClusterExists</code> is set to <code>false</code> and <code>ClusterIdentifier</code> is specified for a deleted cluster, snapshots associated with that cluster are returned.</p> </li> <li> <p>If <code>ClusterExists</code> is set to <code>false</code> and <code>ClusterIdentifier</code> is specified for an existing cluster, no snapshots are returned. </p> </li> </ul>
  ##   SnapshotIdentifier: JString
  ##                     : The snapshot identifier of the snapshot about which to return information.
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster snapshots that are associated with the specified key or keys. For example, suppose that you have snapshots that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the snapshots that have either or both of these tag keys associated with them.
  ##   SnapshotType: JString
  ##               : <p>The type of snapshots for which you are requesting information. By default, snapshots of all types are returned.</p> <p>Valid Values: <code>automated</code> | <code>manual</code> </p>
  ##   EndTime: JString
  ##          : <p>A time value that requests only snapshots created at or before the specified time. The time value is specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2012-07-16T18:00:00Z</code> </p>
  ##   Version: JString (required)
  section = newJObject()
  var valid_604349 = query.getOrDefault("TagValues")
  valid_604349 = validateParameter(valid_604349, JArray, required = false,
                                 default = nil)
  if valid_604349 != nil:
    section.add "TagValues", valid_604349
  var valid_604350 = query.getOrDefault("SortingEntities")
  valid_604350 = validateParameter(valid_604350, JArray, required = false,
                                 default = nil)
  if valid_604350 != nil:
    section.add "SortingEntities", valid_604350
  var valid_604351 = query.getOrDefault("MaxRecords")
  valid_604351 = validateParameter(valid_604351, JInt, required = false, default = nil)
  if valid_604351 != nil:
    section.add "MaxRecords", valid_604351
  var valid_604352 = query.getOrDefault("StartTime")
  valid_604352 = validateParameter(valid_604352, JString, required = false,
                                 default = nil)
  if valid_604352 != nil:
    section.add "StartTime", valid_604352
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_604353 = query.getOrDefault("Action")
  valid_604353 = validateParameter(valid_604353, JString, required = true, default = newJString(
      "DescribeClusterSnapshots"))
  if valid_604353 != nil:
    section.add "Action", valid_604353
  var valid_604354 = query.getOrDefault("ClusterIdentifier")
  valid_604354 = validateParameter(valid_604354, JString, required = false,
                                 default = nil)
  if valid_604354 != nil:
    section.add "ClusterIdentifier", valid_604354
  var valid_604355 = query.getOrDefault("Marker")
  valid_604355 = validateParameter(valid_604355, JString, required = false,
                                 default = nil)
  if valid_604355 != nil:
    section.add "Marker", valid_604355
  var valid_604356 = query.getOrDefault("OwnerAccount")
  valid_604356 = validateParameter(valid_604356, JString, required = false,
                                 default = nil)
  if valid_604356 != nil:
    section.add "OwnerAccount", valid_604356
  var valid_604357 = query.getOrDefault("ClusterExists")
  valid_604357 = validateParameter(valid_604357, JBool, required = false, default = nil)
  if valid_604357 != nil:
    section.add "ClusterExists", valid_604357
  var valid_604358 = query.getOrDefault("SnapshotIdentifier")
  valid_604358 = validateParameter(valid_604358, JString, required = false,
                                 default = nil)
  if valid_604358 != nil:
    section.add "SnapshotIdentifier", valid_604358
  var valid_604359 = query.getOrDefault("TagKeys")
  valid_604359 = validateParameter(valid_604359, JArray, required = false,
                                 default = nil)
  if valid_604359 != nil:
    section.add "TagKeys", valid_604359
  var valid_604360 = query.getOrDefault("SnapshotType")
  valid_604360 = validateParameter(valid_604360, JString, required = false,
                                 default = nil)
  if valid_604360 != nil:
    section.add "SnapshotType", valid_604360
  var valid_604361 = query.getOrDefault("EndTime")
  valid_604361 = validateParameter(valid_604361, JString, required = false,
                                 default = nil)
  if valid_604361 != nil:
    section.add "EndTime", valid_604361
  var valid_604362 = query.getOrDefault("Version")
  valid_604362 = validateParameter(valid_604362, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_604362 != nil:
    section.add "Version", valid_604362
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_604363 = header.getOrDefault("X-Amz-Date")
  valid_604363 = validateParameter(valid_604363, JString, required = false,
                                 default = nil)
  if valid_604363 != nil:
    section.add "X-Amz-Date", valid_604363
  var valid_604364 = header.getOrDefault("X-Amz-Security-Token")
  valid_604364 = validateParameter(valid_604364, JString, required = false,
                                 default = nil)
  if valid_604364 != nil:
    section.add "X-Amz-Security-Token", valid_604364
  var valid_604365 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604365 = validateParameter(valid_604365, JString, required = false,
                                 default = nil)
  if valid_604365 != nil:
    section.add "X-Amz-Content-Sha256", valid_604365
  var valid_604366 = header.getOrDefault("X-Amz-Algorithm")
  valid_604366 = validateParameter(valid_604366, JString, required = false,
                                 default = nil)
  if valid_604366 != nil:
    section.add "X-Amz-Algorithm", valid_604366
  var valid_604367 = header.getOrDefault("X-Amz-Signature")
  valid_604367 = validateParameter(valid_604367, JString, required = false,
                                 default = nil)
  if valid_604367 != nil:
    section.add "X-Amz-Signature", valid_604367
  var valid_604368 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604368 = validateParameter(valid_604368, JString, required = false,
                                 default = nil)
  if valid_604368 != nil:
    section.add "X-Amz-SignedHeaders", valid_604368
  var valid_604369 = header.getOrDefault("X-Amz-Credential")
  valid_604369 = validateParameter(valid_604369, JString, required = false,
                                 default = nil)
  if valid_604369 != nil:
    section.add "X-Amz-Credential", valid_604369
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604370: Call_GetDescribeClusterSnapshots_604346; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns one or more snapshot objects, which contain metadata about your cluster snapshots. By default, this operation returns information about all snapshots of all clusters that are owned by you AWS customer account. No information is returned for snapshots owned by inactive AWS customer accounts.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all snapshots that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all snapshots that have any combination of those values are returned. Only snapshots that you own are returned in the response; shared snapshots are not returned with the tag key and tag value request parameters.</p> <p>If both tag keys and values are omitted from the request, snapshots are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_604370.validator(path, query, header, formData, body)
  let scheme = call_604370.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604370.url(scheme.get, call_604370.host, call_604370.base,
                         call_604370.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_604370, url, valid)

proc call*(call_604371: Call_GetDescribeClusterSnapshots_604346;
          TagValues: JsonNode = nil; SortingEntities: JsonNode = nil;
          MaxRecords: int = 0; StartTime: string = "";
          Action: string = "DescribeClusterSnapshots";
          ClusterIdentifier: string = ""; Marker: string = "";
          OwnerAccount: string = ""; ClusterExists: bool = false;
          SnapshotIdentifier: string = ""; TagKeys: JsonNode = nil;
          SnapshotType: string = ""; EndTime: string = "";
          Version: string = "2012-12-01"): Recallable =
  ## getDescribeClusterSnapshots
  ## <p>Returns one or more snapshot objects, which contain metadata about your cluster snapshots. By default, this operation returns information about all snapshots of all clusters that are owned by you AWS customer account. No information is returned for snapshots owned by inactive AWS customer accounts.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all snapshots that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all snapshots that have any combination of those values are returned. Only snapshots that you own are returned in the response; shared snapshots are not returned with the tag key and tag value request parameters.</p> <p>If both tag keys and values are omitted from the request, snapshots are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster snapshots that are associated with the specified tag value or values. For example, suppose that you have snapshots that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the snapshots that have either or both of these tag values associated with them.
  ##   SortingEntities: JArray
  ##                  : <p/>
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   StartTime: string
  ##            : <p>A value that requests only snapshots created at or after the specified time. The time value is specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2012-07-16T18:00:00Z</code> </p>
  ##   Action: string (required)
  ##   ClusterIdentifier: string
  ##                    : The identifier of the cluster which generated the requested snapshots.
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterSnapshots</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   OwnerAccount: string
  ##               : The AWS customer account used to create or copy the snapshot. Use this field to filter the results to snapshots owned by a particular account. To describe snapshots you own, either specify your AWS customer account, or do not specify the parameter.
  ##   ClusterExists: bool
  ##                : <p>A value that indicates whether to return snapshots only for an existing cluster. You can perform table-level restore only by using a snapshot of an existing cluster, that is, a cluster that has not been deleted. Values for this parameter work as follows: </p> <ul> <li> <p>If <code>ClusterExists</code> is set to <code>true</code>, <code>ClusterIdentifier</code> is required.</p> </li> <li> <p>If <code>ClusterExists</code> is set to <code>false</code> and <code>ClusterIdentifier</code> isn't specified, all snapshots associated with deleted clusters (orphaned snapshots) are returned. </p> </li> <li> <p>If <code>ClusterExists</code> is set to <code>false</code> and <code>ClusterIdentifier</code> is specified for a deleted cluster, snapshots associated with that cluster are returned.</p> </li> <li> <p>If <code>ClusterExists</code> is set to <code>false</code> and <code>ClusterIdentifier</code> is specified for an existing cluster, no snapshots are returned. </p> </li> </ul>
  ##   SnapshotIdentifier: string
  ##                     : The snapshot identifier of the snapshot about which to return information.
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster snapshots that are associated with the specified key or keys. For example, suppose that you have snapshots that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the snapshots that have either or both of these tag keys associated with them.
  ##   SnapshotType: string
  ##               : <p>The type of snapshots for which you are requesting information. By default, snapshots of all types are returned.</p> <p>Valid Values: <code>automated</code> | <code>manual</code> </p>
  ##   EndTime: string
  ##          : <p>A time value that requests only snapshots created at or before the specified time. The time value is specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2012-07-16T18:00:00Z</code> </p>
  ##   Version: string (required)
  var query_604372 = newJObject()
  if TagValues != nil:
    query_604372.add "TagValues", TagValues
  if SortingEntities != nil:
    query_604372.add "SortingEntities", SortingEntities
  add(query_604372, "MaxRecords", newJInt(MaxRecords))
  add(query_604372, "StartTime", newJString(StartTime))
  add(query_604372, "Action", newJString(Action))
  add(query_604372, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_604372, "Marker", newJString(Marker))
  add(query_604372, "OwnerAccount", newJString(OwnerAccount))
  add(query_604372, "ClusterExists", newJBool(ClusterExists))
  add(query_604372, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  if TagKeys != nil:
    query_604372.add "TagKeys", TagKeys
  add(query_604372, "SnapshotType", newJString(SnapshotType))
  add(query_604372, "EndTime", newJString(EndTime))
  add(query_604372, "Version", newJString(Version))
  result = call_604371.call(nil, query_604372, nil, nil, nil)

var getDescribeClusterSnapshots* = Call_GetDescribeClusterSnapshots_604346(
    name: "getDescribeClusterSnapshots", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusterSnapshots",
    validator: validate_GetDescribeClusterSnapshots_604347, base: "/",
    url: url_GetDescribeClusterSnapshots_604348,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeClusterSubnetGroups_604421 = ref object of OpenApiRestCall_602450
proc url_PostDescribeClusterSubnetGroups_604423(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostDescribeClusterSubnetGroups_604422(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns one or more cluster subnet group objects, which contain metadata about your cluster subnet groups. By default, this operation returns information about all cluster subnet groups that are defined in you AWS account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all subnet groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all subnet groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, subnet groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_604424 = query.getOrDefault("Action")
  valid_604424 = validateParameter(valid_604424, JString, required = true, default = newJString(
      "DescribeClusterSubnetGroups"))
  if valid_604424 != nil:
    section.add "Action", valid_604424
  var valid_604425 = query.getOrDefault("Version")
  valid_604425 = validateParameter(valid_604425, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_604425 != nil:
    section.add "Version", valid_604425
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_604426 = header.getOrDefault("X-Amz-Date")
  valid_604426 = validateParameter(valid_604426, JString, required = false,
                                 default = nil)
  if valid_604426 != nil:
    section.add "X-Amz-Date", valid_604426
  var valid_604427 = header.getOrDefault("X-Amz-Security-Token")
  valid_604427 = validateParameter(valid_604427, JString, required = false,
                                 default = nil)
  if valid_604427 != nil:
    section.add "X-Amz-Security-Token", valid_604427
  var valid_604428 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604428 = validateParameter(valid_604428, JString, required = false,
                                 default = nil)
  if valid_604428 != nil:
    section.add "X-Amz-Content-Sha256", valid_604428
  var valid_604429 = header.getOrDefault("X-Amz-Algorithm")
  valid_604429 = validateParameter(valid_604429, JString, required = false,
                                 default = nil)
  if valid_604429 != nil:
    section.add "X-Amz-Algorithm", valid_604429
  var valid_604430 = header.getOrDefault("X-Amz-Signature")
  valid_604430 = validateParameter(valid_604430, JString, required = false,
                                 default = nil)
  if valid_604430 != nil:
    section.add "X-Amz-Signature", valid_604430
  var valid_604431 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604431 = validateParameter(valid_604431, JString, required = false,
                                 default = nil)
  if valid_604431 != nil:
    section.add "X-Amz-SignedHeaders", valid_604431
  var valid_604432 = header.getOrDefault("X-Amz-Credential")
  valid_604432 = validateParameter(valid_604432, JString, required = false,
                                 default = nil)
  if valid_604432 != nil:
    section.add "X-Amz-Credential", valid_604432
  result.add "header", section
  ## parameters in `formData` object:
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterSubnetGroups</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster subnet groups that are associated with the specified key or keys. For example, suppose that you have subnet groups that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the subnet groups that have either or both of these tag keys associated with them.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster subnet groups that are associated with the specified tag value or values. For example, suppose that you have subnet groups that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the subnet groups that have either or both of these tag values associated with them.
  ##   ClusterSubnetGroupName: JString
  ##                         : The name of the cluster subnet group for which information is requested.
  section = newJObject()
  var valid_604433 = formData.getOrDefault("Marker")
  valid_604433 = validateParameter(valid_604433, JString, required = false,
                                 default = nil)
  if valid_604433 != nil:
    section.add "Marker", valid_604433
  var valid_604434 = formData.getOrDefault("TagKeys")
  valid_604434 = validateParameter(valid_604434, JArray, required = false,
                                 default = nil)
  if valid_604434 != nil:
    section.add "TagKeys", valid_604434
  var valid_604435 = formData.getOrDefault("MaxRecords")
  valid_604435 = validateParameter(valid_604435, JInt, required = false, default = nil)
  if valid_604435 != nil:
    section.add "MaxRecords", valid_604435
  var valid_604436 = formData.getOrDefault("TagValues")
  valid_604436 = validateParameter(valid_604436, JArray, required = false,
                                 default = nil)
  if valid_604436 != nil:
    section.add "TagValues", valid_604436
  var valid_604437 = formData.getOrDefault("ClusterSubnetGroupName")
  valid_604437 = validateParameter(valid_604437, JString, required = false,
                                 default = nil)
  if valid_604437 != nil:
    section.add "ClusterSubnetGroupName", valid_604437
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604438: Call_PostDescribeClusterSubnetGroups_604421;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Returns one or more cluster subnet group objects, which contain metadata about your cluster subnet groups. By default, this operation returns information about all cluster subnet groups that are defined in you AWS account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all subnet groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all subnet groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, subnet groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_604438.validator(path, query, header, formData, body)
  let scheme = call_604438.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604438.url(scheme.get, call_604438.host, call_604438.base,
                         call_604438.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_604438, url, valid)

proc call*(call_604439: Call_PostDescribeClusterSubnetGroups_604421;
          Marker: string = ""; Action: string = "DescribeClusterSubnetGroups";
          TagKeys: JsonNode = nil; MaxRecords: int = 0; TagValues: JsonNode = nil;
          Version: string = "2012-12-01"; ClusterSubnetGroupName: string = ""): Recallable =
  ## postDescribeClusterSubnetGroups
  ## <p>Returns one or more cluster subnet group objects, which contain metadata about your cluster subnet groups. By default, this operation returns information about all cluster subnet groups that are defined in you AWS account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all subnet groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all subnet groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, subnet groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterSubnetGroups</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Action: string (required)
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster subnet groups that are associated with the specified key or keys. For example, suppose that you have subnet groups that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the subnet groups that have either or both of these tag keys associated with them.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster subnet groups that are associated with the specified tag value or values. For example, suppose that you have subnet groups that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the subnet groups that have either or both of these tag values associated with them.
  ##   Version: string (required)
  ##   ClusterSubnetGroupName: string
  ##                         : The name of the cluster subnet group for which information is requested.
  var query_604440 = newJObject()
  var formData_604441 = newJObject()
  add(formData_604441, "Marker", newJString(Marker))
  add(query_604440, "Action", newJString(Action))
  if TagKeys != nil:
    formData_604441.add "TagKeys", TagKeys
  add(formData_604441, "MaxRecords", newJInt(MaxRecords))
  if TagValues != nil:
    formData_604441.add "TagValues", TagValues
  add(query_604440, "Version", newJString(Version))
  add(formData_604441, "ClusterSubnetGroupName",
      newJString(ClusterSubnetGroupName))
  result = call_604439.call(nil, query_604440, nil, formData_604441, nil)

var postDescribeClusterSubnetGroups* = Call_PostDescribeClusterSubnetGroups_604421(
    name: "postDescribeClusterSubnetGroups", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusterSubnetGroups",
    validator: validate_PostDescribeClusterSubnetGroups_604422, base: "/",
    url: url_PostDescribeClusterSubnetGroups_604423,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeClusterSubnetGroups_604401 = ref object of OpenApiRestCall_602450
proc url_GetDescribeClusterSubnetGroups_604403(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetDescribeClusterSubnetGroups_604402(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns one or more cluster subnet group objects, which contain metadata about your cluster subnet groups. By default, this operation returns information about all cluster subnet groups that are defined in you AWS account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all subnet groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all subnet groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, subnet groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster subnet groups that are associated with the specified tag value or values. For example, suppose that you have subnet groups that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the subnet groups that have either or both of these tag values associated with them.
  ##   ClusterSubnetGroupName: JString
  ##                         : The name of the cluster subnet group for which information is requested.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Action: JString (required)
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterSubnetGroups</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster subnet groups that are associated with the specified key or keys. For example, suppose that you have subnet groups that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the subnet groups that have either or both of these tag keys associated with them.
  ##   Version: JString (required)
  section = newJObject()
  var valid_604404 = query.getOrDefault("TagValues")
  valid_604404 = validateParameter(valid_604404, JArray, required = false,
                                 default = nil)
  if valid_604404 != nil:
    section.add "TagValues", valid_604404
  var valid_604405 = query.getOrDefault("ClusterSubnetGroupName")
  valid_604405 = validateParameter(valid_604405, JString, required = false,
                                 default = nil)
  if valid_604405 != nil:
    section.add "ClusterSubnetGroupName", valid_604405
  var valid_604406 = query.getOrDefault("MaxRecords")
  valid_604406 = validateParameter(valid_604406, JInt, required = false, default = nil)
  if valid_604406 != nil:
    section.add "MaxRecords", valid_604406
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_604407 = query.getOrDefault("Action")
  valid_604407 = validateParameter(valid_604407, JString, required = true, default = newJString(
      "DescribeClusterSubnetGroups"))
  if valid_604407 != nil:
    section.add "Action", valid_604407
  var valid_604408 = query.getOrDefault("Marker")
  valid_604408 = validateParameter(valid_604408, JString, required = false,
                                 default = nil)
  if valid_604408 != nil:
    section.add "Marker", valid_604408
  var valid_604409 = query.getOrDefault("TagKeys")
  valid_604409 = validateParameter(valid_604409, JArray, required = false,
                                 default = nil)
  if valid_604409 != nil:
    section.add "TagKeys", valid_604409
  var valid_604410 = query.getOrDefault("Version")
  valid_604410 = validateParameter(valid_604410, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_604410 != nil:
    section.add "Version", valid_604410
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_604411 = header.getOrDefault("X-Amz-Date")
  valid_604411 = validateParameter(valid_604411, JString, required = false,
                                 default = nil)
  if valid_604411 != nil:
    section.add "X-Amz-Date", valid_604411
  var valid_604412 = header.getOrDefault("X-Amz-Security-Token")
  valid_604412 = validateParameter(valid_604412, JString, required = false,
                                 default = nil)
  if valid_604412 != nil:
    section.add "X-Amz-Security-Token", valid_604412
  var valid_604413 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604413 = validateParameter(valid_604413, JString, required = false,
                                 default = nil)
  if valid_604413 != nil:
    section.add "X-Amz-Content-Sha256", valid_604413
  var valid_604414 = header.getOrDefault("X-Amz-Algorithm")
  valid_604414 = validateParameter(valid_604414, JString, required = false,
                                 default = nil)
  if valid_604414 != nil:
    section.add "X-Amz-Algorithm", valid_604414
  var valid_604415 = header.getOrDefault("X-Amz-Signature")
  valid_604415 = validateParameter(valid_604415, JString, required = false,
                                 default = nil)
  if valid_604415 != nil:
    section.add "X-Amz-Signature", valid_604415
  var valid_604416 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604416 = validateParameter(valid_604416, JString, required = false,
                                 default = nil)
  if valid_604416 != nil:
    section.add "X-Amz-SignedHeaders", valid_604416
  var valid_604417 = header.getOrDefault("X-Amz-Credential")
  valid_604417 = validateParameter(valid_604417, JString, required = false,
                                 default = nil)
  if valid_604417 != nil:
    section.add "X-Amz-Credential", valid_604417
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604418: Call_GetDescribeClusterSubnetGroups_604401; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns one or more cluster subnet group objects, which contain metadata about your cluster subnet groups. By default, this operation returns information about all cluster subnet groups that are defined in you AWS account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all subnet groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all subnet groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, subnet groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_604418.validator(path, query, header, formData, body)
  let scheme = call_604418.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604418.url(scheme.get, call_604418.host, call_604418.base,
                         call_604418.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_604418, url, valid)

proc call*(call_604419: Call_GetDescribeClusterSubnetGroups_604401;
          TagValues: JsonNode = nil; ClusterSubnetGroupName: string = "";
          MaxRecords: int = 0; Action: string = "DescribeClusterSubnetGroups";
          Marker: string = ""; TagKeys: JsonNode = nil; Version: string = "2012-12-01"): Recallable =
  ## getDescribeClusterSubnetGroups
  ## <p>Returns one or more cluster subnet group objects, which contain metadata about your cluster subnet groups. By default, this operation returns information about all cluster subnet groups that are defined in you AWS account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all subnet groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all subnet groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, subnet groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster subnet groups that are associated with the specified tag value or values. For example, suppose that you have subnet groups that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the subnet groups that have either or both of these tag values associated with them.
  ##   ClusterSubnetGroupName: string
  ##                         : The name of the cluster subnet group for which information is requested.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Action: string (required)
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterSubnetGroups</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster subnet groups that are associated with the specified key or keys. For example, suppose that you have subnet groups that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the subnet groups that have either or both of these tag keys associated with them.
  ##   Version: string (required)
  var query_604420 = newJObject()
  if TagValues != nil:
    query_604420.add "TagValues", TagValues
  add(query_604420, "ClusterSubnetGroupName", newJString(ClusterSubnetGroupName))
  add(query_604420, "MaxRecords", newJInt(MaxRecords))
  add(query_604420, "Action", newJString(Action))
  add(query_604420, "Marker", newJString(Marker))
  if TagKeys != nil:
    query_604420.add "TagKeys", TagKeys
  add(query_604420, "Version", newJString(Version))
  result = call_604419.call(nil, query_604420, nil, nil, nil)

var getDescribeClusterSubnetGroups* = Call_GetDescribeClusterSubnetGroups_604401(
    name: "getDescribeClusterSubnetGroups", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusterSubnetGroups",
    validator: validate_GetDescribeClusterSubnetGroups_604402, base: "/",
    url: url_GetDescribeClusterSubnetGroups_604403,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeClusterTracks_604460 = ref object of OpenApiRestCall_602450
proc url_PostDescribeClusterTracks_604462(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostDescribeClusterTracks_604461(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns a list of all the available maintenance tracks.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_604463 = query.getOrDefault("Action")
  valid_604463 = validateParameter(valid_604463, JString, required = true,
                                 default = newJString("DescribeClusterTracks"))
  if valid_604463 != nil:
    section.add "Action", valid_604463
  var valid_604464 = query.getOrDefault("Version")
  valid_604464 = validateParameter(valid_604464, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_604464 != nil:
    section.add "Version", valid_604464
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_604465 = header.getOrDefault("X-Amz-Date")
  valid_604465 = validateParameter(valid_604465, JString, required = false,
                                 default = nil)
  if valid_604465 != nil:
    section.add "X-Amz-Date", valid_604465
  var valid_604466 = header.getOrDefault("X-Amz-Security-Token")
  valid_604466 = validateParameter(valid_604466, JString, required = false,
                                 default = nil)
  if valid_604466 != nil:
    section.add "X-Amz-Security-Token", valid_604466
  var valid_604467 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604467 = validateParameter(valid_604467, JString, required = false,
                                 default = nil)
  if valid_604467 != nil:
    section.add "X-Amz-Content-Sha256", valid_604467
  var valid_604468 = header.getOrDefault("X-Amz-Algorithm")
  valid_604468 = validateParameter(valid_604468, JString, required = false,
                                 default = nil)
  if valid_604468 != nil:
    section.add "X-Amz-Algorithm", valid_604468
  var valid_604469 = header.getOrDefault("X-Amz-Signature")
  valid_604469 = validateParameter(valid_604469, JString, required = false,
                                 default = nil)
  if valid_604469 != nil:
    section.add "X-Amz-Signature", valid_604469
  var valid_604470 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604470 = validateParameter(valid_604470, JString, required = false,
                                 default = nil)
  if valid_604470 != nil:
    section.add "X-Amz-SignedHeaders", valid_604470
  var valid_604471 = header.getOrDefault("X-Amz-Credential")
  valid_604471 = validateParameter(valid_604471, JString, required = false,
                                 default = nil)
  if valid_604471 != nil:
    section.add "X-Amz-Credential", valid_604471
  result.add "header", section
  ## parameters in `formData` object:
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <code>DescribeClusterTracks</code> request exceed the value specified in <code>MaxRecords</code>, Amazon Redshift returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   MaxRecords: JInt
  ##             : An integer value for the maximum number of maintenance tracks to return.
  ##   MaintenanceTrackName: JString
  ##                       : The name of the maintenance track. 
  section = newJObject()
  var valid_604472 = formData.getOrDefault("Marker")
  valid_604472 = validateParameter(valid_604472, JString, required = false,
                                 default = nil)
  if valid_604472 != nil:
    section.add "Marker", valid_604472
  var valid_604473 = formData.getOrDefault("MaxRecords")
  valid_604473 = validateParameter(valid_604473, JInt, required = false, default = nil)
  if valid_604473 != nil:
    section.add "MaxRecords", valid_604473
  var valid_604474 = formData.getOrDefault("MaintenanceTrackName")
  valid_604474 = validateParameter(valid_604474, JString, required = false,
                                 default = nil)
  if valid_604474 != nil:
    section.add "MaintenanceTrackName", valid_604474
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604475: Call_PostDescribeClusterTracks_604460; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns a list of all the available maintenance tracks.
  ## 
  let valid = call_604475.validator(path, query, header, formData, body)
  let scheme = call_604475.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604475.url(scheme.get, call_604475.host, call_604475.base,
                         call_604475.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_604475, url, valid)

proc call*(call_604476: Call_PostDescribeClusterTracks_604460; Marker: string = "";
          Action: string = "DescribeClusterTracks"; MaxRecords: int = 0;
          Version: string = "2012-12-01"; MaintenanceTrackName: string = ""): Recallable =
  ## postDescribeClusterTracks
  ## Returns a list of all the available maintenance tracks.
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <code>DescribeClusterTracks</code> request exceed the value specified in <code>MaxRecords</code>, Amazon Redshift returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Action: string (required)
  ##   MaxRecords: int
  ##             : An integer value for the maximum number of maintenance tracks to return.
  ##   Version: string (required)
  ##   MaintenanceTrackName: string
  ##                       : The name of the maintenance track. 
  var query_604477 = newJObject()
  var formData_604478 = newJObject()
  add(formData_604478, "Marker", newJString(Marker))
  add(query_604477, "Action", newJString(Action))
  add(formData_604478, "MaxRecords", newJInt(MaxRecords))
  add(query_604477, "Version", newJString(Version))
  add(formData_604478, "MaintenanceTrackName", newJString(MaintenanceTrackName))
  result = call_604476.call(nil, query_604477, nil, formData_604478, nil)

var postDescribeClusterTracks* = Call_PostDescribeClusterTracks_604460(
    name: "postDescribeClusterTracks", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusterTracks",
    validator: validate_PostDescribeClusterTracks_604461, base: "/",
    url: url_PostDescribeClusterTracks_604462,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeClusterTracks_604442 = ref object of OpenApiRestCall_602450
proc url_GetDescribeClusterTracks_604444(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetDescribeClusterTracks_604443(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns a list of all the available maintenance tracks.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   MaintenanceTrackName: JString
  ##                       : The name of the maintenance track. 
  ##   MaxRecords: JInt
  ##             : An integer value for the maximum number of maintenance tracks to return.
  ##   Action: JString (required)
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <code>DescribeClusterTracks</code> request exceed the value specified in <code>MaxRecords</code>, Amazon Redshift returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Version: JString (required)
  section = newJObject()
  var valid_604445 = query.getOrDefault("MaintenanceTrackName")
  valid_604445 = validateParameter(valid_604445, JString, required = false,
                                 default = nil)
  if valid_604445 != nil:
    section.add "MaintenanceTrackName", valid_604445
  var valid_604446 = query.getOrDefault("MaxRecords")
  valid_604446 = validateParameter(valid_604446, JInt, required = false, default = nil)
  if valid_604446 != nil:
    section.add "MaxRecords", valid_604446
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_604447 = query.getOrDefault("Action")
  valid_604447 = validateParameter(valid_604447, JString, required = true,
                                 default = newJString("DescribeClusterTracks"))
  if valid_604447 != nil:
    section.add "Action", valid_604447
  var valid_604448 = query.getOrDefault("Marker")
  valid_604448 = validateParameter(valid_604448, JString, required = false,
                                 default = nil)
  if valid_604448 != nil:
    section.add "Marker", valid_604448
  var valid_604449 = query.getOrDefault("Version")
  valid_604449 = validateParameter(valid_604449, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_604449 != nil:
    section.add "Version", valid_604449
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_604450 = header.getOrDefault("X-Amz-Date")
  valid_604450 = validateParameter(valid_604450, JString, required = false,
                                 default = nil)
  if valid_604450 != nil:
    section.add "X-Amz-Date", valid_604450
  var valid_604451 = header.getOrDefault("X-Amz-Security-Token")
  valid_604451 = validateParameter(valid_604451, JString, required = false,
                                 default = nil)
  if valid_604451 != nil:
    section.add "X-Amz-Security-Token", valid_604451
  var valid_604452 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604452 = validateParameter(valid_604452, JString, required = false,
                                 default = nil)
  if valid_604452 != nil:
    section.add "X-Amz-Content-Sha256", valid_604452
  var valid_604453 = header.getOrDefault("X-Amz-Algorithm")
  valid_604453 = validateParameter(valid_604453, JString, required = false,
                                 default = nil)
  if valid_604453 != nil:
    section.add "X-Amz-Algorithm", valid_604453
  var valid_604454 = header.getOrDefault("X-Amz-Signature")
  valid_604454 = validateParameter(valid_604454, JString, required = false,
                                 default = nil)
  if valid_604454 != nil:
    section.add "X-Amz-Signature", valid_604454
  var valid_604455 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604455 = validateParameter(valid_604455, JString, required = false,
                                 default = nil)
  if valid_604455 != nil:
    section.add "X-Amz-SignedHeaders", valid_604455
  var valid_604456 = header.getOrDefault("X-Amz-Credential")
  valid_604456 = validateParameter(valid_604456, JString, required = false,
                                 default = nil)
  if valid_604456 != nil:
    section.add "X-Amz-Credential", valid_604456
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604457: Call_GetDescribeClusterTracks_604442; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns a list of all the available maintenance tracks.
  ## 
  let valid = call_604457.validator(path, query, header, formData, body)
  let scheme = call_604457.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604457.url(scheme.get, call_604457.host, call_604457.base,
                         call_604457.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_604457, url, valid)

proc call*(call_604458: Call_GetDescribeClusterTracks_604442;
          MaintenanceTrackName: string = ""; MaxRecords: int = 0;
          Action: string = "DescribeClusterTracks"; Marker: string = "";
          Version: string = "2012-12-01"): Recallable =
  ## getDescribeClusterTracks
  ## Returns a list of all the available maintenance tracks.
  ##   MaintenanceTrackName: string
  ##                       : The name of the maintenance track. 
  ##   MaxRecords: int
  ##             : An integer value for the maximum number of maintenance tracks to return.
  ##   Action: string (required)
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <code>DescribeClusterTracks</code> request exceed the value specified in <code>MaxRecords</code>, Amazon Redshift returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Version: string (required)
  var query_604459 = newJObject()
  add(query_604459, "MaintenanceTrackName", newJString(MaintenanceTrackName))
  add(query_604459, "MaxRecords", newJInt(MaxRecords))
  add(query_604459, "Action", newJString(Action))
  add(query_604459, "Marker", newJString(Marker))
  add(query_604459, "Version", newJString(Version))
  result = call_604458.call(nil, query_604459, nil, nil, nil)

var getDescribeClusterTracks* = Call_GetDescribeClusterTracks_604442(
    name: "getDescribeClusterTracks", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusterTracks",
    validator: validate_GetDescribeClusterTracks_604443, base: "/",
    url: url_GetDescribeClusterTracks_604444, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeClusterVersions_604498 = ref object of OpenApiRestCall_602450
proc url_PostDescribeClusterVersions_604500(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostDescribeClusterVersions_604499(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns descriptions of the available Amazon Redshift cluster versions. You can call this operation even before creating any clusters to learn more about the Amazon Redshift versions. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_604501 = query.getOrDefault("Action")
  valid_604501 = validateParameter(valid_604501, JString, required = true, default = newJString(
      "DescribeClusterVersions"))
  if valid_604501 != nil:
    section.add "Action", valid_604501
  var valid_604502 = query.getOrDefault("Version")
  valid_604502 = validateParameter(valid_604502, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_604502 != nil:
    section.add "Version", valid_604502
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_604503 = header.getOrDefault("X-Amz-Date")
  valid_604503 = validateParameter(valid_604503, JString, required = false,
                                 default = nil)
  if valid_604503 != nil:
    section.add "X-Amz-Date", valid_604503
  var valid_604504 = header.getOrDefault("X-Amz-Security-Token")
  valid_604504 = validateParameter(valid_604504, JString, required = false,
                                 default = nil)
  if valid_604504 != nil:
    section.add "X-Amz-Security-Token", valid_604504
  var valid_604505 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604505 = validateParameter(valid_604505, JString, required = false,
                                 default = nil)
  if valid_604505 != nil:
    section.add "X-Amz-Content-Sha256", valid_604505
  var valid_604506 = header.getOrDefault("X-Amz-Algorithm")
  valid_604506 = validateParameter(valid_604506, JString, required = false,
                                 default = nil)
  if valid_604506 != nil:
    section.add "X-Amz-Algorithm", valid_604506
  var valid_604507 = header.getOrDefault("X-Amz-Signature")
  valid_604507 = validateParameter(valid_604507, JString, required = false,
                                 default = nil)
  if valid_604507 != nil:
    section.add "X-Amz-Signature", valid_604507
  var valid_604508 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604508 = validateParameter(valid_604508, JString, required = false,
                                 default = nil)
  if valid_604508 != nil:
    section.add "X-Amz-SignedHeaders", valid_604508
  var valid_604509 = header.getOrDefault("X-Amz-Credential")
  valid_604509 = validateParameter(valid_604509, JString, required = false,
                                 default = nil)
  if valid_604509 != nil:
    section.add "X-Amz-Credential", valid_604509
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterVersion: JString
  ##                 : <p>The specific cluster version to return.</p> <p>Example: <code>1.0</code> </p>
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterVersions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   ClusterParameterGroupFamily: JString
  ##                              : <p>The name of a specific cluster parameter group family to return details for.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters</p> </li> <li> <p>First character must be a letter</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens</p> </li> </ul>
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  section = newJObject()
  var valid_604510 = formData.getOrDefault("ClusterVersion")
  valid_604510 = validateParameter(valid_604510, JString, required = false,
                                 default = nil)
  if valid_604510 != nil:
    section.add "ClusterVersion", valid_604510
  var valid_604511 = formData.getOrDefault("Marker")
  valid_604511 = validateParameter(valid_604511, JString, required = false,
                                 default = nil)
  if valid_604511 != nil:
    section.add "Marker", valid_604511
  var valid_604512 = formData.getOrDefault("ClusterParameterGroupFamily")
  valid_604512 = validateParameter(valid_604512, JString, required = false,
                                 default = nil)
  if valid_604512 != nil:
    section.add "ClusterParameterGroupFamily", valid_604512
  var valid_604513 = formData.getOrDefault("MaxRecords")
  valid_604513 = validateParameter(valid_604513, JInt, required = false, default = nil)
  if valid_604513 != nil:
    section.add "MaxRecords", valid_604513
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604514: Call_PostDescribeClusterVersions_604498; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns descriptions of the available Amazon Redshift cluster versions. You can call this operation even before creating any clusters to learn more about the Amazon Redshift versions. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.
  ## 
  let valid = call_604514.validator(path, query, header, formData, body)
  let scheme = call_604514.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604514.url(scheme.get, call_604514.host, call_604514.base,
                         call_604514.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_604514, url, valid)

proc call*(call_604515: Call_PostDescribeClusterVersions_604498;
          ClusterVersion: string = ""; Marker: string = "";
          Action: string = "DescribeClusterVersions";
          ClusterParameterGroupFamily: string = ""; MaxRecords: int = 0;
          Version: string = "2012-12-01"): Recallable =
  ## postDescribeClusterVersions
  ## Returns descriptions of the available Amazon Redshift cluster versions. You can call this operation even before creating any clusters to learn more about the Amazon Redshift versions. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.
  ##   ClusterVersion: string
  ##                 : <p>The specific cluster version to return.</p> <p>Example: <code>1.0</code> </p>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterVersions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Action: string (required)
  ##   ClusterParameterGroupFamily: string
  ##                              : <p>The name of a specific cluster parameter group family to return details for.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters</p> </li> <li> <p>First character must be a letter</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens</p> </li> </ul>
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Version: string (required)
  var query_604516 = newJObject()
  var formData_604517 = newJObject()
  add(formData_604517, "ClusterVersion", newJString(ClusterVersion))
  add(formData_604517, "Marker", newJString(Marker))
  add(query_604516, "Action", newJString(Action))
  add(formData_604517, "ClusterParameterGroupFamily",
      newJString(ClusterParameterGroupFamily))
  add(formData_604517, "MaxRecords", newJInt(MaxRecords))
  add(query_604516, "Version", newJString(Version))
  result = call_604515.call(nil, query_604516, nil, formData_604517, nil)

var postDescribeClusterVersions* = Call_PostDescribeClusterVersions_604498(
    name: "postDescribeClusterVersions", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusterVersions",
    validator: validate_PostDescribeClusterVersions_604499, base: "/",
    url: url_PostDescribeClusterVersions_604500,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeClusterVersions_604479 = ref object of OpenApiRestCall_602450
proc url_GetDescribeClusterVersions_604481(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetDescribeClusterVersions_604480(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns descriptions of the available Amazon Redshift cluster versions. You can call this operation even before creating any clusters to learn more about the Amazon Redshift versions. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Action: JString (required)
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterVersions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   ClusterVersion: JString
  ##                 : <p>The specific cluster version to return.</p> <p>Example: <code>1.0</code> </p>
  ##   Version: JString (required)
  ##   ClusterParameterGroupFamily: JString
  ##                              : <p>The name of a specific cluster parameter group family to return details for.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters</p> </li> <li> <p>First character must be a letter</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens</p> </li> </ul>
  section = newJObject()
  var valid_604482 = query.getOrDefault("MaxRecords")
  valid_604482 = validateParameter(valid_604482, JInt, required = false, default = nil)
  if valid_604482 != nil:
    section.add "MaxRecords", valid_604482
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_604483 = query.getOrDefault("Action")
  valid_604483 = validateParameter(valid_604483, JString, required = true, default = newJString(
      "DescribeClusterVersions"))
  if valid_604483 != nil:
    section.add "Action", valid_604483
  var valid_604484 = query.getOrDefault("Marker")
  valid_604484 = validateParameter(valid_604484, JString, required = false,
                                 default = nil)
  if valid_604484 != nil:
    section.add "Marker", valid_604484
  var valid_604485 = query.getOrDefault("ClusterVersion")
  valid_604485 = validateParameter(valid_604485, JString, required = false,
                                 default = nil)
  if valid_604485 != nil:
    section.add "ClusterVersion", valid_604485
  var valid_604486 = query.getOrDefault("Version")
  valid_604486 = validateParameter(valid_604486, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_604486 != nil:
    section.add "Version", valid_604486
  var valid_604487 = query.getOrDefault("ClusterParameterGroupFamily")
  valid_604487 = validateParameter(valid_604487, JString, required = false,
                                 default = nil)
  if valid_604487 != nil:
    section.add "ClusterParameterGroupFamily", valid_604487
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_604488 = header.getOrDefault("X-Amz-Date")
  valid_604488 = validateParameter(valid_604488, JString, required = false,
                                 default = nil)
  if valid_604488 != nil:
    section.add "X-Amz-Date", valid_604488
  var valid_604489 = header.getOrDefault("X-Amz-Security-Token")
  valid_604489 = validateParameter(valid_604489, JString, required = false,
                                 default = nil)
  if valid_604489 != nil:
    section.add "X-Amz-Security-Token", valid_604489
  var valid_604490 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604490 = validateParameter(valid_604490, JString, required = false,
                                 default = nil)
  if valid_604490 != nil:
    section.add "X-Amz-Content-Sha256", valid_604490
  var valid_604491 = header.getOrDefault("X-Amz-Algorithm")
  valid_604491 = validateParameter(valid_604491, JString, required = false,
                                 default = nil)
  if valid_604491 != nil:
    section.add "X-Amz-Algorithm", valid_604491
  var valid_604492 = header.getOrDefault("X-Amz-Signature")
  valid_604492 = validateParameter(valid_604492, JString, required = false,
                                 default = nil)
  if valid_604492 != nil:
    section.add "X-Amz-Signature", valid_604492
  var valid_604493 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604493 = validateParameter(valid_604493, JString, required = false,
                                 default = nil)
  if valid_604493 != nil:
    section.add "X-Amz-SignedHeaders", valid_604493
  var valid_604494 = header.getOrDefault("X-Amz-Credential")
  valid_604494 = validateParameter(valid_604494, JString, required = false,
                                 default = nil)
  if valid_604494 != nil:
    section.add "X-Amz-Credential", valid_604494
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604495: Call_GetDescribeClusterVersions_604479; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns descriptions of the available Amazon Redshift cluster versions. You can call this operation even before creating any clusters to learn more about the Amazon Redshift versions. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.
  ## 
  let valid = call_604495.validator(path, query, header, formData, body)
  let scheme = call_604495.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604495.url(scheme.get, call_604495.host, call_604495.base,
                         call_604495.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_604495, url, valid)

proc call*(call_604496: Call_GetDescribeClusterVersions_604479;
          MaxRecords: int = 0; Action: string = "DescribeClusterVersions";
          Marker: string = ""; ClusterVersion: string = "";
          Version: string = "2012-12-01"; ClusterParameterGroupFamily: string = ""): Recallable =
  ## getDescribeClusterVersions
  ## Returns descriptions of the available Amazon Redshift cluster versions. You can call this operation even before creating any clusters to learn more about the Amazon Redshift versions. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Action: string (required)
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterVersions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   ClusterVersion: string
  ##                 : <p>The specific cluster version to return.</p> <p>Example: <code>1.0</code> </p>
  ##   Version: string (required)
  ##   ClusterParameterGroupFamily: string
  ##                              : <p>The name of a specific cluster parameter group family to return details for.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters</p> </li> <li> <p>First character must be a letter</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens</p> </li> </ul>
  var query_604497 = newJObject()
  add(query_604497, "MaxRecords", newJInt(MaxRecords))
  add(query_604497, "Action", newJString(Action))
  add(query_604497, "Marker", newJString(Marker))
  add(query_604497, "ClusterVersion", newJString(ClusterVersion))
  add(query_604497, "Version", newJString(Version))
  add(query_604497, "ClusterParameterGroupFamily",
      newJString(ClusterParameterGroupFamily))
  result = call_604496.call(nil, query_604497, nil, nil, nil)

var getDescribeClusterVersions* = Call_GetDescribeClusterVersions_604479(
    name: "getDescribeClusterVersions", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusterVersions",
    validator: validate_GetDescribeClusterVersions_604480, base: "/",
    url: url_GetDescribeClusterVersions_604481,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeClusters_604538 = ref object of OpenApiRestCall_602450
proc url_PostDescribeClusters_604540(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostDescribeClusters_604539(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns properties of provisioned clusters including general cluster properties, cluster database properties, maintenance and backup properties, and security and access properties. This operation supports pagination. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all clusters that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all clusters that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, clusters are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_604541 = query.getOrDefault("Action")
  valid_604541 = validateParameter(valid_604541, JString, required = true,
                                 default = newJString("DescribeClusters"))
  if valid_604541 != nil:
    section.add "Action", valid_604541
  var valid_604542 = query.getOrDefault("Version")
  valid_604542 = validateParameter(valid_604542, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_604542 != nil:
    section.add "Version", valid_604542
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_604543 = header.getOrDefault("X-Amz-Date")
  valid_604543 = validateParameter(valid_604543, JString, required = false,
                                 default = nil)
  if valid_604543 != nil:
    section.add "X-Amz-Date", valid_604543
  var valid_604544 = header.getOrDefault("X-Amz-Security-Token")
  valid_604544 = validateParameter(valid_604544, JString, required = false,
                                 default = nil)
  if valid_604544 != nil:
    section.add "X-Amz-Security-Token", valid_604544
  var valid_604545 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604545 = validateParameter(valid_604545, JString, required = false,
                                 default = nil)
  if valid_604545 != nil:
    section.add "X-Amz-Content-Sha256", valid_604545
  var valid_604546 = header.getOrDefault("X-Amz-Algorithm")
  valid_604546 = validateParameter(valid_604546, JString, required = false,
                                 default = nil)
  if valid_604546 != nil:
    section.add "X-Amz-Algorithm", valid_604546
  var valid_604547 = header.getOrDefault("X-Amz-Signature")
  valid_604547 = validateParameter(valid_604547, JString, required = false,
                                 default = nil)
  if valid_604547 != nil:
    section.add "X-Amz-Signature", valid_604547
  var valid_604548 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604548 = validateParameter(valid_604548, JString, required = false,
                                 default = nil)
  if valid_604548 != nil:
    section.add "X-Amz-SignedHeaders", valid_604548
  var valid_604549 = header.getOrDefault("X-Amz-Credential")
  valid_604549 = validateParameter(valid_604549, JString, required = false,
                                 default = nil)
  if valid_604549 != nil:
    section.add "X-Amz-Credential", valid_604549
  result.add "header", section
  ## parameters in `formData` object:
  ##   Marker: JString
  ##         : <p>An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusters</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <b>ClusterIdentifier</b> parameter or the <b>Marker</b> parameter, but not both. </p>
  ##   ClusterIdentifier: JString
  ##                    : <p>The unique identifier of a cluster whose properties you are requesting. This parameter is case sensitive.</p> <p>The default is that all clusters defined for an account are returned.</p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching clusters that are associated with the specified key or keys. For example, suppose that you have clusters that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the clusters that have either or both of these tag keys associated with them.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching clusters that are associated with the specified tag value or values. For example, suppose that you have clusters that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the clusters that have either or both of these tag values associated with them.
  section = newJObject()
  var valid_604550 = formData.getOrDefault("Marker")
  valid_604550 = validateParameter(valid_604550, JString, required = false,
                                 default = nil)
  if valid_604550 != nil:
    section.add "Marker", valid_604550
  var valid_604551 = formData.getOrDefault("ClusterIdentifier")
  valid_604551 = validateParameter(valid_604551, JString, required = false,
                                 default = nil)
  if valid_604551 != nil:
    section.add "ClusterIdentifier", valid_604551
  var valid_604552 = formData.getOrDefault("TagKeys")
  valid_604552 = validateParameter(valid_604552, JArray, required = false,
                                 default = nil)
  if valid_604552 != nil:
    section.add "TagKeys", valid_604552
  var valid_604553 = formData.getOrDefault("MaxRecords")
  valid_604553 = validateParameter(valid_604553, JInt, required = false, default = nil)
  if valid_604553 != nil:
    section.add "MaxRecords", valid_604553
  var valid_604554 = formData.getOrDefault("TagValues")
  valid_604554 = validateParameter(valid_604554, JArray, required = false,
                                 default = nil)
  if valid_604554 != nil:
    section.add "TagValues", valid_604554
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604555: Call_PostDescribeClusters_604538; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns properties of provisioned clusters including general cluster properties, cluster database properties, maintenance and backup properties, and security and access properties. This operation supports pagination. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all clusters that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all clusters that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, clusters are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_604555.validator(path, query, header, formData, body)
  let scheme = call_604555.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604555.url(scheme.get, call_604555.host, call_604555.base,
                         call_604555.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_604555, url, valid)

proc call*(call_604556: Call_PostDescribeClusters_604538; Marker: string = "";
          Action: string = "DescribeClusters"; ClusterIdentifier: string = "";
          TagKeys: JsonNode = nil; MaxRecords: int = 0; TagValues: JsonNode = nil;
          Version: string = "2012-12-01"): Recallable =
  ## postDescribeClusters
  ## <p>Returns properties of provisioned clusters including general cluster properties, cluster database properties, maintenance and backup properties, and security and access properties. This operation supports pagination. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all clusters that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all clusters that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, clusters are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   Marker: string
  ##         : <p>An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusters</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <b>ClusterIdentifier</b> parameter or the <b>Marker</b> parameter, but not both. </p>
  ##   Action: string (required)
  ##   ClusterIdentifier: string
  ##                    : <p>The unique identifier of a cluster whose properties you are requesting. This parameter is case sensitive.</p> <p>The default is that all clusters defined for an account are returned.</p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching clusters that are associated with the specified key or keys. For example, suppose that you have clusters that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the clusters that have either or both of these tag keys associated with them.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching clusters that are associated with the specified tag value or values. For example, suppose that you have clusters that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the clusters that have either or both of these tag values associated with them.
  ##   Version: string (required)
  var query_604557 = newJObject()
  var formData_604558 = newJObject()
  add(formData_604558, "Marker", newJString(Marker))
  add(query_604557, "Action", newJString(Action))
  add(formData_604558, "ClusterIdentifier", newJString(ClusterIdentifier))
  if TagKeys != nil:
    formData_604558.add "TagKeys", TagKeys
  add(formData_604558, "MaxRecords", newJInt(MaxRecords))
  if TagValues != nil:
    formData_604558.add "TagValues", TagValues
  add(query_604557, "Version", newJString(Version))
  result = call_604556.call(nil, query_604557, nil, formData_604558, nil)

var postDescribeClusters* = Call_PostDescribeClusters_604538(
    name: "postDescribeClusters", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusters",
    validator: validate_PostDescribeClusters_604539, base: "/",
    url: url_PostDescribeClusters_604540, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeClusters_604518 = ref object of OpenApiRestCall_602450
proc url_GetDescribeClusters_604520(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetDescribeClusters_604519(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## <p>Returns properties of provisioned clusters including general cluster properties, cluster database properties, maintenance and backup properties, and security and access properties. This operation supports pagination. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all clusters that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all clusters that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, clusters are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching clusters that are associated with the specified tag value or values. For example, suppose that you have clusters that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the clusters that have either or both of these tag values associated with them.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString
  ##                    : <p>The unique identifier of a cluster whose properties you are requesting. This parameter is case sensitive.</p> <p>The default is that all clusters defined for an account are returned.</p>
  ##   Marker: JString
  ##         : <p>An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusters</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <b>ClusterIdentifier</b> parameter or the <b>Marker</b> parameter, but not both. </p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching clusters that are associated with the specified key or keys. For example, suppose that you have clusters that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the clusters that have either or both of these tag keys associated with them.
  ##   Version: JString (required)
  section = newJObject()
  var valid_604521 = query.getOrDefault("TagValues")
  valid_604521 = validateParameter(valid_604521, JArray, required = false,
                                 default = nil)
  if valid_604521 != nil:
    section.add "TagValues", valid_604521
  var valid_604522 = query.getOrDefault("MaxRecords")
  valid_604522 = validateParameter(valid_604522, JInt, required = false, default = nil)
  if valid_604522 != nil:
    section.add "MaxRecords", valid_604522
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_604523 = query.getOrDefault("Action")
  valid_604523 = validateParameter(valid_604523, JString, required = true,
                                 default = newJString("DescribeClusters"))
  if valid_604523 != nil:
    section.add "Action", valid_604523
  var valid_604524 = query.getOrDefault("ClusterIdentifier")
  valid_604524 = validateParameter(valid_604524, JString, required = false,
                                 default = nil)
  if valid_604524 != nil:
    section.add "ClusterIdentifier", valid_604524
  var valid_604525 = query.getOrDefault("Marker")
  valid_604525 = validateParameter(valid_604525, JString, required = false,
                                 default = nil)
  if valid_604525 != nil:
    section.add "Marker", valid_604525
  var valid_604526 = query.getOrDefault("TagKeys")
  valid_604526 = validateParameter(valid_604526, JArray, required = false,
                                 default = nil)
  if valid_604526 != nil:
    section.add "TagKeys", valid_604526
  var valid_604527 = query.getOrDefault("Version")
  valid_604527 = validateParameter(valid_604527, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_604527 != nil:
    section.add "Version", valid_604527
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_604528 = header.getOrDefault("X-Amz-Date")
  valid_604528 = validateParameter(valid_604528, JString, required = false,
                                 default = nil)
  if valid_604528 != nil:
    section.add "X-Amz-Date", valid_604528
  var valid_604529 = header.getOrDefault("X-Amz-Security-Token")
  valid_604529 = validateParameter(valid_604529, JString, required = false,
                                 default = nil)
  if valid_604529 != nil:
    section.add "X-Amz-Security-Token", valid_604529
  var valid_604530 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604530 = validateParameter(valid_604530, JString, required = false,
                                 default = nil)
  if valid_604530 != nil:
    section.add "X-Amz-Content-Sha256", valid_604530
  var valid_604531 = header.getOrDefault("X-Amz-Algorithm")
  valid_604531 = validateParameter(valid_604531, JString, required = false,
                                 default = nil)
  if valid_604531 != nil:
    section.add "X-Amz-Algorithm", valid_604531
  var valid_604532 = header.getOrDefault("X-Amz-Signature")
  valid_604532 = validateParameter(valid_604532, JString, required = false,
                                 default = nil)
  if valid_604532 != nil:
    section.add "X-Amz-Signature", valid_604532
  var valid_604533 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604533 = validateParameter(valid_604533, JString, required = false,
                                 default = nil)
  if valid_604533 != nil:
    section.add "X-Amz-SignedHeaders", valid_604533
  var valid_604534 = header.getOrDefault("X-Amz-Credential")
  valid_604534 = validateParameter(valid_604534, JString, required = false,
                                 default = nil)
  if valid_604534 != nil:
    section.add "X-Amz-Credential", valid_604534
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604535: Call_GetDescribeClusters_604518; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns properties of provisioned clusters including general cluster properties, cluster database properties, maintenance and backup properties, and security and access properties. This operation supports pagination. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all clusters that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all clusters that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, clusters are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_604535.validator(path, query, header, formData, body)
  let scheme = call_604535.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604535.url(scheme.get, call_604535.host, call_604535.base,
                         call_604535.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_604535, url, valid)

proc call*(call_604536: Call_GetDescribeClusters_604518; TagValues: JsonNode = nil;
          MaxRecords: int = 0; Action: string = "DescribeClusters";
          ClusterIdentifier: string = ""; Marker: string = ""; TagKeys: JsonNode = nil;
          Version: string = "2012-12-01"): Recallable =
  ## getDescribeClusters
  ## <p>Returns properties of provisioned clusters including general cluster properties, cluster database properties, maintenance and backup properties, and security and access properties. This operation supports pagination. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all clusters that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all clusters that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, clusters are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching clusters that are associated with the specified tag value or values. For example, suppose that you have clusters that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the clusters that have either or both of these tag values associated with them.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Action: string (required)
  ##   ClusterIdentifier: string
  ##                    : <p>The unique identifier of a cluster whose properties you are requesting. This parameter is case sensitive.</p> <p>The default is that all clusters defined for an account are returned.</p>
  ##   Marker: string
  ##         : <p>An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusters</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <b>ClusterIdentifier</b> parameter or the <b>Marker</b> parameter, but not both. </p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching clusters that are associated with the specified key or keys. For example, suppose that you have clusters that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the clusters that have either or both of these tag keys associated with them.
  ##   Version: string (required)
  var query_604537 = newJObject()
  if TagValues != nil:
    query_604537.add "TagValues", TagValues
  add(query_604537, "MaxRecords", newJInt(MaxRecords))
  add(query_604537, "Action", newJString(Action))
  add(query_604537, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_604537, "Marker", newJString(Marker))
  if TagKeys != nil:
    query_604537.add "TagKeys", TagKeys
  add(query_604537, "Version", newJString(Version))
  result = call_604536.call(nil, query_604537, nil, nil, nil)

var getDescribeClusters* = Call_GetDescribeClusters_604518(
    name: "getDescribeClusters", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusters",
    validator: validate_GetDescribeClusters_604519, base: "/",
    url: url_GetDescribeClusters_604520, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeDefaultClusterParameters_604577 = ref object of OpenApiRestCall_602450
proc url_PostDescribeDefaultClusterParameters_604579(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostDescribeDefaultClusterParameters_604578(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns a list of parameter settings for the specified parameter group family.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_604580 = query.getOrDefault("Action")
  valid_604580 = validateParameter(valid_604580, JString, required = true, default = newJString(
      "DescribeDefaultClusterParameters"))
  if valid_604580 != nil:
    section.add "Action", valid_604580
  var valid_604581 = query.getOrDefault("Version")
  valid_604581 = validateParameter(valid_604581, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_604581 != nil:
    section.add "Version", valid_604581
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_604582 = header.getOrDefault("X-Amz-Date")
  valid_604582 = validateParameter(valid_604582, JString, required = false,
                                 default = nil)
  if valid_604582 != nil:
    section.add "X-Amz-Date", valid_604582
  var valid_604583 = header.getOrDefault("X-Amz-Security-Token")
  valid_604583 = validateParameter(valid_604583, JString, required = false,
                                 default = nil)
  if valid_604583 != nil:
    section.add "X-Amz-Security-Token", valid_604583
  var valid_604584 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604584 = validateParameter(valid_604584, JString, required = false,
                                 default = nil)
  if valid_604584 != nil:
    section.add "X-Amz-Content-Sha256", valid_604584
  var valid_604585 = header.getOrDefault("X-Amz-Algorithm")
  valid_604585 = validateParameter(valid_604585, JString, required = false,
                                 default = nil)
  if valid_604585 != nil:
    section.add "X-Amz-Algorithm", valid_604585
  var valid_604586 = header.getOrDefault("X-Amz-Signature")
  valid_604586 = validateParameter(valid_604586, JString, required = false,
                                 default = nil)
  if valid_604586 != nil:
    section.add "X-Amz-Signature", valid_604586
  var valid_604587 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604587 = validateParameter(valid_604587, JString, required = false,
                                 default = nil)
  if valid_604587 != nil:
    section.add "X-Amz-SignedHeaders", valid_604587
  var valid_604588 = header.getOrDefault("X-Amz-Credential")
  valid_604588 = validateParameter(valid_604588, JString, required = false,
                                 default = nil)
  if valid_604588 != nil:
    section.add "X-Amz-Credential", valid_604588
  result.add "header", section
  ## parameters in `formData` object:
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeDefaultClusterParameters</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   ParameterGroupFamily: JString (required)
  ##                       : The name of the cluster parameter group family.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  section = newJObject()
  var valid_604589 = formData.getOrDefault("Marker")
  valid_604589 = validateParameter(valid_604589, JString, required = false,
                                 default = nil)
  if valid_604589 != nil:
    section.add "Marker", valid_604589
  assert formData != nil, "formData argument is necessary due to required `ParameterGroupFamily` field"
  var valid_604590 = formData.getOrDefault("ParameterGroupFamily")
  valid_604590 = validateParameter(valid_604590, JString, required = true,
                                 default = nil)
  if valid_604590 != nil:
    section.add "ParameterGroupFamily", valid_604590
  var valid_604591 = formData.getOrDefault("MaxRecords")
  valid_604591 = validateParameter(valid_604591, JInt, required = false, default = nil)
  if valid_604591 != nil:
    section.add "MaxRecords", valid_604591
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604592: Call_PostDescribeDefaultClusterParameters_604577;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Returns a list of parameter settings for the specified parameter group family.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_604592.validator(path, query, header, formData, body)
  let scheme = call_604592.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604592.url(scheme.get, call_604592.host, call_604592.base,
                         call_604592.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_604592, url, valid)

proc call*(call_604593: Call_PostDescribeDefaultClusterParameters_604577;
          ParameterGroupFamily: string; Marker: string = "";
          Action: string = "DescribeDefaultClusterParameters"; MaxRecords: int = 0;
          Version: string = "2012-12-01"): Recallable =
  ## postDescribeDefaultClusterParameters
  ## <p>Returns a list of parameter settings for the specified parameter group family.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeDefaultClusterParameters</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Action: string (required)
  ##   ParameterGroupFamily: string (required)
  ##                       : The name of the cluster parameter group family.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Version: string (required)
  var query_604594 = newJObject()
  var formData_604595 = newJObject()
  add(formData_604595, "Marker", newJString(Marker))
  add(query_604594, "Action", newJString(Action))
  add(formData_604595, "ParameterGroupFamily", newJString(ParameterGroupFamily))
  add(formData_604595, "MaxRecords", newJInt(MaxRecords))
  add(query_604594, "Version", newJString(Version))
  result = call_604593.call(nil, query_604594, nil, formData_604595, nil)

var postDescribeDefaultClusterParameters* = Call_PostDescribeDefaultClusterParameters_604577(
    name: "postDescribeDefaultClusterParameters", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeDefaultClusterParameters",
    validator: validate_PostDescribeDefaultClusterParameters_604578, base: "/",
    url: url_PostDescribeDefaultClusterParameters_604579,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeDefaultClusterParameters_604559 = ref object of OpenApiRestCall_602450
proc url_GetDescribeDefaultClusterParameters_604561(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetDescribeDefaultClusterParameters_604560(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns a list of parameter settings for the specified parameter group family.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Action: JString (required)
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeDefaultClusterParameters</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   ParameterGroupFamily: JString (required)
  ##                       : The name of the cluster parameter group family.
  ##   Version: JString (required)
  section = newJObject()
  var valid_604562 = query.getOrDefault("MaxRecords")
  valid_604562 = validateParameter(valid_604562, JInt, required = false, default = nil)
  if valid_604562 != nil:
    section.add "MaxRecords", valid_604562
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_604563 = query.getOrDefault("Action")
  valid_604563 = validateParameter(valid_604563, JString, required = true, default = newJString(
      "DescribeDefaultClusterParameters"))
  if valid_604563 != nil:
    section.add "Action", valid_604563
  var valid_604564 = query.getOrDefault("Marker")
  valid_604564 = validateParameter(valid_604564, JString, required = false,
                                 default = nil)
  if valid_604564 != nil:
    section.add "Marker", valid_604564
  var valid_604565 = query.getOrDefault("ParameterGroupFamily")
  valid_604565 = validateParameter(valid_604565, JString, required = true,
                                 default = nil)
  if valid_604565 != nil:
    section.add "ParameterGroupFamily", valid_604565
  var valid_604566 = query.getOrDefault("Version")
  valid_604566 = validateParameter(valid_604566, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_604566 != nil:
    section.add "Version", valid_604566
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_604567 = header.getOrDefault("X-Amz-Date")
  valid_604567 = validateParameter(valid_604567, JString, required = false,
                                 default = nil)
  if valid_604567 != nil:
    section.add "X-Amz-Date", valid_604567
  var valid_604568 = header.getOrDefault("X-Amz-Security-Token")
  valid_604568 = validateParameter(valid_604568, JString, required = false,
                                 default = nil)
  if valid_604568 != nil:
    section.add "X-Amz-Security-Token", valid_604568
  var valid_604569 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604569 = validateParameter(valid_604569, JString, required = false,
                                 default = nil)
  if valid_604569 != nil:
    section.add "X-Amz-Content-Sha256", valid_604569
  var valid_604570 = header.getOrDefault("X-Amz-Algorithm")
  valid_604570 = validateParameter(valid_604570, JString, required = false,
                                 default = nil)
  if valid_604570 != nil:
    section.add "X-Amz-Algorithm", valid_604570
  var valid_604571 = header.getOrDefault("X-Amz-Signature")
  valid_604571 = validateParameter(valid_604571, JString, required = false,
                                 default = nil)
  if valid_604571 != nil:
    section.add "X-Amz-Signature", valid_604571
  var valid_604572 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604572 = validateParameter(valid_604572, JString, required = false,
                                 default = nil)
  if valid_604572 != nil:
    section.add "X-Amz-SignedHeaders", valid_604572
  var valid_604573 = header.getOrDefault("X-Amz-Credential")
  valid_604573 = validateParameter(valid_604573, JString, required = false,
                                 default = nil)
  if valid_604573 != nil:
    section.add "X-Amz-Credential", valid_604573
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604574: Call_GetDescribeDefaultClusterParameters_604559;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Returns a list of parameter settings for the specified parameter group family.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_604574.validator(path, query, header, formData, body)
  let scheme = call_604574.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604574.url(scheme.get, call_604574.host, call_604574.base,
                         call_604574.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_604574, url, valid)

proc call*(call_604575: Call_GetDescribeDefaultClusterParameters_604559;
          ParameterGroupFamily: string; MaxRecords: int = 0;
          Action: string = "DescribeDefaultClusterParameters"; Marker: string = "";
          Version: string = "2012-12-01"): Recallable =
  ## getDescribeDefaultClusterParameters
  ## <p>Returns a list of parameter settings for the specified parameter group family.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Action: string (required)
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeDefaultClusterParameters</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   ParameterGroupFamily: string (required)
  ##                       : The name of the cluster parameter group family.
  ##   Version: string (required)
  var query_604576 = newJObject()
  add(query_604576, "MaxRecords", newJInt(MaxRecords))
  add(query_604576, "Action", newJString(Action))
  add(query_604576, "Marker", newJString(Marker))
  add(query_604576, "ParameterGroupFamily", newJString(ParameterGroupFamily))
  add(query_604576, "Version", newJString(Version))
  result = call_604575.call(nil, query_604576, nil, nil, nil)

var getDescribeDefaultClusterParameters* = Call_GetDescribeDefaultClusterParameters_604559(
    name: "getDescribeDefaultClusterParameters", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeDefaultClusterParameters",
    validator: validate_GetDescribeDefaultClusterParameters_604560, base: "/",
    url: url_GetDescribeDefaultClusterParameters_604561,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeEventCategories_604612 = ref object of OpenApiRestCall_602450
proc url_PostDescribeEventCategories_604614(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostDescribeEventCategories_604613(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Displays a list of event categories for all event source types, or for a specified source type. For a list of the event categories and source types, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-event-notifications.html">Amazon Redshift Event Notifications</a>.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_604615 = query.getOrDefault("Action")
  valid_604615 = validateParameter(valid_604615, JString, required = true, default = newJString(
      "DescribeEventCategories"))
  if valid_604615 != nil:
    section.add "Action", valid_604615
  var valid_604616 = query.getOrDefault("Version")
  valid_604616 = validateParameter(valid_604616, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_604616 != nil:
    section.add "Version", valid_604616
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_604617 = header.getOrDefault("X-Amz-Date")
  valid_604617 = validateParameter(valid_604617, JString, required = false,
                                 default = nil)
  if valid_604617 != nil:
    section.add "X-Amz-Date", valid_604617
  var valid_604618 = header.getOrDefault("X-Amz-Security-Token")
  valid_604618 = validateParameter(valid_604618, JString, required = false,
                                 default = nil)
  if valid_604618 != nil:
    section.add "X-Amz-Security-Token", valid_604618
  var valid_604619 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604619 = validateParameter(valid_604619, JString, required = false,
                                 default = nil)
  if valid_604619 != nil:
    section.add "X-Amz-Content-Sha256", valid_604619
  var valid_604620 = header.getOrDefault("X-Amz-Algorithm")
  valid_604620 = validateParameter(valid_604620, JString, required = false,
                                 default = nil)
  if valid_604620 != nil:
    section.add "X-Amz-Algorithm", valid_604620
  var valid_604621 = header.getOrDefault("X-Amz-Signature")
  valid_604621 = validateParameter(valid_604621, JString, required = false,
                                 default = nil)
  if valid_604621 != nil:
    section.add "X-Amz-Signature", valid_604621
  var valid_604622 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604622 = validateParameter(valid_604622, JString, required = false,
                                 default = nil)
  if valid_604622 != nil:
    section.add "X-Amz-SignedHeaders", valid_604622
  var valid_604623 = header.getOrDefault("X-Amz-Credential")
  valid_604623 = validateParameter(valid_604623, JString, required = false,
                                 default = nil)
  if valid_604623 != nil:
    section.add "X-Amz-Credential", valid_604623
  result.add "header", section
  ## parameters in `formData` object:
  ##   SourceType: JString
  ##             : <p>The source type, such as cluster or parameter group, to which the described event categories apply.</p> <p>Valid values: cluster, cluster-snapshot, cluster-parameter-group, and cluster-security-group.</p>
  section = newJObject()
  var valid_604624 = formData.getOrDefault("SourceType")
  valid_604624 = validateParameter(valid_604624, JString, required = false,
                                 default = nil)
  if valid_604624 != nil:
    section.add "SourceType", valid_604624
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604625: Call_PostDescribeEventCategories_604612; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Displays a list of event categories for all event source types, or for a specified source type. For a list of the event categories and source types, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-event-notifications.html">Amazon Redshift Event Notifications</a>.
  ## 
  let valid = call_604625.validator(path, query, header, formData, body)
  let scheme = call_604625.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604625.url(scheme.get, call_604625.host, call_604625.base,
                         call_604625.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_604625, url, valid)

proc call*(call_604626: Call_PostDescribeEventCategories_604612;
          Action: string = "DescribeEventCategories";
          Version: string = "2012-12-01"; SourceType: string = ""): Recallable =
  ## postDescribeEventCategories
  ## Displays a list of event categories for all event source types, or for a specified source type. For a list of the event categories and source types, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-event-notifications.html">Amazon Redshift Event Notifications</a>.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   SourceType: string
  ##             : <p>The source type, such as cluster or parameter group, to which the described event categories apply.</p> <p>Valid values: cluster, cluster-snapshot, cluster-parameter-group, and cluster-security-group.</p>
  var query_604627 = newJObject()
  var formData_604628 = newJObject()
  add(query_604627, "Action", newJString(Action))
  add(query_604627, "Version", newJString(Version))
  add(formData_604628, "SourceType", newJString(SourceType))
  result = call_604626.call(nil, query_604627, nil, formData_604628, nil)

var postDescribeEventCategories* = Call_PostDescribeEventCategories_604612(
    name: "postDescribeEventCategories", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeEventCategories",
    validator: validate_PostDescribeEventCategories_604613, base: "/",
    url: url_PostDescribeEventCategories_604614,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeEventCategories_604596 = ref object of OpenApiRestCall_602450
proc url_GetDescribeEventCategories_604598(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetDescribeEventCategories_604597(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Displays a list of event categories for all event source types, or for a specified source type. For a list of the event categories and source types, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-event-notifications.html">Amazon Redshift Event Notifications</a>.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   SourceType: JString
  ##             : <p>The source type, such as cluster or parameter group, to which the described event categories apply.</p> <p>Valid values: cluster, cluster-snapshot, cluster-parameter-group, and cluster-security-group.</p>
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_604599 = query.getOrDefault("SourceType")
  valid_604599 = validateParameter(valid_604599, JString, required = false,
                                 default = nil)
  if valid_604599 != nil:
    section.add "SourceType", valid_604599
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_604600 = query.getOrDefault("Action")
  valid_604600 = validateParameter(valid_604600, JString, required = true, default = newJString(
      "DescribeEventCategories"))
  if valid_604600 != nil:
    section.add "Action", valid_604600
  var valid_604601 = query.getOrDefault("Version")
  valid_604601 = validateParameter(valid_604601, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_604601 != nil:
    section.add "Version", valid_604601
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_604602 = header.getOrDefault("X-Amz-Date")
  valid_604602 = validateParameter(valid_604602, JString, required = false,
                                 default = nil)
  if valid_604602 != nil:
    section.add "X-Amz-Date", valid_604602
  var valid_604603 = header.getOrDefault("X-Amz-Security-Token")
  valid_604603 = validateParameter(valid_604603, JString, required = false,
                                 default = nil)
  if valid_604603 != nil:
    section.add "X-Amz-Security-Token", valid_604603
  var valid_604604 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604604 = validateParameter(valid_604604, JString, required = false,
                                 default = nil)
  if valid_604604 != nil:
    section.add "X-Amz-Content-Sha256", valid_604604
  var valid_604605 = header.getOrDefault("X-Amz-Algorithm")
  valid_604605 = validateParameter(valid_604605, JString, required = false,
                                 default = nil)
  if valid_604605 != nil:
    section.add "X-Amz-Algorithm", valid_604605
  var valid_604606 = header.getOrDefault("X-Amz-Signature")
  valid_604606 = validateParameter(valid_604606, JString, required = false,
                                 default = nil)
  if valid_604606 != nil:
    section.add "X-Amz-Signature", valid_604606
  var valid_604607 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604607 = validateParameter(valid_604607, JString, required = false,
                                 default = nil)
  if valid_604607 != nil:
    section.add "X-Amz-SignedHeaders", valid_604607
  var valid_604608 = header.getOrDefault("X-Amz-Credential")
  valid_604608 = validateParameter(valid_604608, JString, required = false,
                                 default = nil)
  if valid_604608 != nil:
    section.add "X-Amz-Credential", valid_604608
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604609: Call_GetDescribeEventCategories_604596; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Displays a list of event categories for all event source types, or for a specified source type. For a list of the event categories and source types, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-event-notifications.html">Amazon Redshift Event Notifications</a>.
  ## 
  let valid = call_604609.validator(path, query, header, formData, body)
  let scheme = call_604609.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604609.url(scheme.get, call_604609.host, call_604609.base,
                         call_604609.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_604609, url, valid)

proc call*(call_604610: Call_GetDescribeEventCategories_604596;
          SourceType: string = ""; Action: string = "DescribeEventCategories";
          Version: string = "2012-12-01"): Recallable =
  ## getDescribeEventCategories
  ## Displays a list of event categories for all event source types, or for a specified source type. For a list of the event categories and source types, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-event-notifications.html">Amazon Redshift Event Notifications</a>.
  ##   SourceType: string
  ##             : <p>The source type, such as cluster or parameter group, to which the described event categories apply.</p> <p>Valid values: cluster, cluster-snapshot, cluster-parameter-group, and cluster-security-group.</p>
  ##   Action: string (required)
  ##   Version: string (required)
  var query_604611 = newJObject()
  add(query_604611, "SourceType", newJString(SourceType))
  add(query_604611, "Action", newJString(Action))
  add(query_604611, "Version", newJString(Version))
  result = call_604610.call(nil, query_604611, nil, nil, nil)

var getDescribeEventCategories* = Call_GetDescribeEventCategories_604596(
    name: "getDescribeEventCategories", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeEventCategories",
    validator: validate_GetDescribeEventCategories_604597, base: "/",
    url: url_GetDescribeEventCategories_604598,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeEventSubscriptions_604649 = ref object of OpenApiRestCall_602450
proc url_PostDescribeEventSubscriptions_604651(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostDescribeEventSubscriptions_604650(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Lists descriptions of all the Amazon Redshift event notification subscriptions for a customer account. If you specify a subscription name, lists the description for that subscription.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all event notification subscriptions that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all subscriptions that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, subscriptions are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_604652 = query.getOrDefault("Action")
  valid_604652 = validateParameter(valid_604652, JString, required = true, default = newJString(
      "DescribeEventSubscriptions"))
  if valid_604652 != nil:
    section.add "Action", valid_604652
  var valid_604653 = query.getOrDefault("Version")
  valid_604653 = validateParameter(valid_604653, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_604653 != nil:
    section.add "Version", valid_604653
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_604654 = header.getOrDefault("X-Amz-Date")
  valid_604654 = validateParameter(valid_604654, JString, required = false,
                                 default = nil)
  if valid_604654 != nil:
    section.add "X-Amz-Date", valid_604654
  var valid_604655 = header.getOrDefault("X-Amz-Security-Token")
  valid_604655 = validateParameter(valid_604655, JString, required = false,
                                 default = nil)
  if valid_604655 != nil:
    section.add "X-Amz-Security-Token", valid_604655
  var valid_604656 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604656 = validateParameter(valid_604656, JString, required = false,
                                 default = nil)
  if valid_604656 != nil:
    section.add "X-Amz-Content-Sha256", valid_604656
  var valid_604657 = header.getOrDefault("X-Amz-Algorithm")
  valid_604657 = validateParameter(valid_604657, JString, required = false,
                                 default = nil)
  if valid_604657 != nil:
    section.add "X-Amz-Algorithm", valid_604657
  var valid_604658 = header.getOrDefault("X-Amz-Signature")
  valid_604658 = validateParameter(valid_604658, JString, required = false,
                                 default = nil)
  if valid_604658 != nil:
    section.add "X-Amz-Signature", valid_604658
  var valid_604659 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604659 = validateParameter(valid_604659, JString, required = false,
                                 default = nil)
  if valid_604659 != nil:
    section.add "X-Amz-SignedHeaders", valid_604659
  var valid_604660 = header.getOrDefault("X-Amz-Credential")
  valid_604660 = validateParameter(valid_604660, JString, required = false,
                                 default = nil)
  if valid_604660 != nil:
    section.add "X-Amz-Credential", valid_604660
  result.add "header", section
  ## parameters in `formData` object:
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a DescribeEventSubscriptions request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   SubscriptionName: JString
  ##                   : The name of the Amazon Redshift event notification subscription to be described.
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching event notification subscriptions that are associated with the specified key or keys. For example, suppose that you have subscriptions that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the subscriptions that have either or both of these tag keys associated with them.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching event notification subscriptions that are associated with the specified tag value or values. For example, suppose that you have subscriptions that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the subscriptions that have either or both of these tag values associated with them.
  section = newJObject()
  var valid_604661 = formData.getOrDefault("Marker")
  valid_604661 = validateParameter(valid_604661, JString, required = false,
                                 default = nil)
  if valid_604661 != nil:
    section.add "Marker", valid_604661
  var valid_604662 = formData.getOrDefault("SubscriptionName")
  valid_604662 = validateParameter(valid_604662, JString, required = false,
                                 default = nil)
  if valid_604662 != nil:
    section.add "SubscriptionName", valid_604662
  var valid_604663 = formData.getOrDefault("TagKeys")
  valid_604663 = validateParameter(valid_604663, JArray, required = false,
                                 default = nil)
  if valid_604663 != nil:
    section.add "TagKeys", valid_604663
  var valid_604664 = formData.getOrDefault("MaxRecords")
  valid_604664 = validateParameter(valid_604664, JInt, required = false, default = nil)
  if valid_604664 != nil:
    section.add "MaxRecords", valid_604664
  var valid_604665 = formData.getOrDefault("TagValues")
  valid_604665 = validateParameter(valid_604665, JArray, required = false,
                                 default = nil)
  if valid_604665 != nil:
    section.add "TagValues", valid_604665
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604666: Call_PostDescribeEventSubscriptions_604649; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Lists descriptions of all the Amazon Redshift event notification subscriptions for a customer account. If you specify a subscription name, lists the description for that subscription.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all event notification subscriptions that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all subscriptions that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, subscriptions are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_604666.validator(path, query, header, formData, body)
  let scheme = call_604666.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604666.url(scheme.get, call_604666.host, call_604666.base,
                         call_604666.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_604666, url, valid)

proc call*(call_604667: Call_PostDescribeEventSubscriptions_604649;
          Marker: string = ""; SubscriptionName: string = "";
          Action: string = "DescribeEventSubscriptions"; TagKeys: JsonNode = nil;
          MaxRecords: int = 0; TagValues: JsonNode = nil; Version: string = "2012-12-01"): Recallable =
  ## postDescribeEventSubscriptions
  ## <p>Lists descriptions of all the Amazon Redshift event notification subscriptions for a customer account. If you specify a subscription name, lists the description for that subscription.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all event notification subscriptions that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all subscriptions that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, subscriptions are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a DescribeEventSubscriptions request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   SubscriptionName: string
  ##                   : The name of the Amazon Redshift event notification subscription to be described.
  ##   Action: string (required)
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching event notification subscriptions that are associated with the specified key or keys. For example, suppose that you have subscriptions that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the subscriptions that have either or both of these tag keys associated with them.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching event notification subscriptions that are associated with the specified tag value or values. For example, suppose that you have subscriptions that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the subscriptions that have either or both of these tag values associated with them.
  ##   Version: string (required)
  var query_604668 = newJObject()
  var formData_604669 = newJObject()
  add(formData_604669, "Marker", newJString(Marker))
  add(formData_604669, "SubscriptionName", newJString(SubscriptionName))
  add(query_604668, "Action", newJString(Action))
  if TagKeys != nil:
    formData_604669.add "TagKeys", TagKeys
  add(formData_604669, "MaxRecords", newJInt(MaxRecords))
  if TagValues != nil:
    formData_604669.add "TagValues", TagValues
  add(query_604668, "Version", newJString(Version))
  result = call_604667.call(nil, query_604668, nil, formData_604669, nil)

var postDescribeEventSubscriptions* = Call_PostDescribeEventSubscriptions_604649(
    name: "postDescribeEventSubscriptions", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeEventSubscriptions",
    validator: validate_PostDescribeEventSubscriptions_604650, base: "/",
    url: url_PostDescribeEventSubscriptions_604651,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeEventSubscriptions_604629 = ref object of OpenApiRestCall_602450
proc url_GetDescribeEventSubscriptions_604631(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetDescribeEventSubscriptions_604630(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Lists descriptions of all the Amazon Redshift event notification subscriptions for a customer account. If you specify a subscription name, lists the description for that subscription.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all event notification subscriptions that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all subscriptions that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, subscriptions are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching event notification subscriptions that are associated with the specified tag value or values. For example, suppose that you have subscriptions that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the subscriptions that have either or both of these tag values associated with them.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Action: JString (required)
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a DescribeEventSubscriptions request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   SubscriptionName: JString
  ##                   : The name of the Amazon Redshift event notification subscription to be described.
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching event notification subscriptions that are associated with the specified key or keys. For example, suppose that you have subscriptions that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the subscriptions that have either or both of these tag keys associated with them.
  ##   Version: JString (required)
  section = newJObject()
  var valid_604632 = query.getOrDefault("TagValues")
  valid_604632 = validateParameter(valid_604632, JArray, required = false,
                                 default = nil)
  if valid_604632 != nil:
    section.add "TagValues", valid_604632
  var valid_604633 = query.getOrDefault("MaxRecords")
  valid_604633 = validateParameter(valid_604633, JInt, required = false, default = nil)
  if valid_604633 != nil:
    section.add "MaxRecords", valid_604633
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_604634 = query.getOrDefault("Action")
  valid_604634 = validateParameter(valid_604634, JString, required = true, default = newJString(
      "DescribeEventSubscriptions"))
  if valid_604634 != nil:
    section.add "Action", valid_604634
  var valid_604635 = query.getOrDefault("Marker")
  valid_604635 = validateParameter(valid_604635, JString, required = false,
                                 default = nil)
  if valid_604635 != nil:
    section.add "Marker", valid_604635
  var valid_604636 = query.getOrDefault("SubscriptionName")
  valid_604636 = validateParameter(valid_604636, JString, required = false,
                                 default = nil)
  if valid_604636 != nil:
    section.add "SubscriptionName", valid_604636
  var valid_604637 = query.getOrDefault("TagKeys")
  valid_604637 = validateParameter(valid_604637, JArray, required = false,
                                 default = nil)
  if valid_604637 != nil:
    section.add "TagKeys", valid_604637
  var valid_604638 = query.getOrDefault("Version")
  valid_604638 = validateParameter(valid_604638, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_604638 != nil:
    section.add "Version", valid_604638
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_604639 = header.getOrDefault("X-Amz-Date")
  valid_604639 = validateParameter(valid_604639, JString, required = false,
                                 default = nil)
  if valid_604639 != nil:
    section.add "X-Amz-Date", valid_604639
  var valid_604640 = header.getOrDefault("X-Amz-Security-Token")
  valid_604640 = validateParameter(valid_604640, JString, required = false,
                                 default = nil)
  if valid_604640 != nil:
    section.add "X-Amz-Security-Token", valid_604640
  var valid_604641 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604641 = validateParameter(valid_604641, JString, required = false,
                                 default = nil)
  if valid_604641 != nil:
    section.add "X-Amz-Content-Sha256", valid_604641
  var valid_604642 = header.getOrDefault("X-Amz-Algorithm")
  valid_604642 = validateParameter(valid_604642, JString, required = false,
                                 default = nil)
  if valid_604642 != nil:
    section.add "X-Amz-Algorithm", valid_604642
  var valid_604643 = header.getOrDefault("X-Amz-Signature")
  valid_604643 = validateParameter(valid_604643, JString, required = false,
                                 default = nil)
  if valid_604643 != nil:
    section.add "X-Amz-Signature", valid_604643
  var valid_604644 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604644 = validateParameter(valid_604644, JString, required = false,
                                 default = nil)
  if valid_604644 != nil:
    section.add "X-Amz-SignedHeaders", valid_604644
  var valid_604645 = header.getOrDefault("X-Amz-Credential")
  valid_604645 = validateParameter(valid_604645, JString, required = false,
                                 default = nil)
  if valid_604645 != nil:
    section.add "X-Amz-Credential", valid_604645
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604646: Call_GetDescribeEventSubscriptions_604629; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Lists descriptions of all the Amazon Redshift event notification subscriptions for a customer account. If you specify a subscription name, lists the description for that subscription.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all event notification subscriptions that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all subscriptions that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, subscriptions are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_604646.validator(path, query, header, formData, body)
  let scheme = call_604646.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604646.url(scheme.get, call_604646.host, call_604646.base,
                         call_604646.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_604646, url, valid)

proc call*(call_604647: Call_GetDescribeEventSubscriptions_604629;
          TagValues: JsonNode = nil; MaxRecords: int = 0;
          Action: string = "DescribeEventSubscriptions"; Marker: string = "";
          SubscriptionName: string = ""; TagKeys: JsonNode = nil;
          Version: string = "2012-12-01"): Recallable =
  ## getDescribeEventSubscriptions
  ## <p>Lists descriptions of all the Amazon Redshift event notification subscriptions for a customer account. If you specify a subscription name, lists the description for that subscription.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all event notification subscriptions that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all subscriptions that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, subscriptions are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching event notification subscriptions that are associated with the specified tag value or values. For example, suppose that you have subscriptions that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the subscriptions that have either or both of these tag values associated with them.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Action: string (required)
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a DescribeEventSubscriptions request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   SubscriptionName: string
  ##                   : The name of the Amazon Redshift event notification subscription to be described.
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching event notification subscriptions that are associated with the specified key or keys. For example, suppose that you have subscriptions that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the subscriptions that have either or both of these tag keys associated with them.
  ##   Version: string (required)
  var query_604648 = newJObject()
  if TagValues != nil:
    query_604648.add "TagValues", TagValues
  add(query_604648, "MaxRecords", newJInt(MaxRecords))
  add(query_604648, "Action", newJString(Action))
  add(query_604648, "Marker", newJString(Marker))
  add(query_604648, "SubscriptionName", newJString(SubscriptionName))
  if TagKeys != nil:
    query_604648.add "TagKeys", TagKeys
  add(query_604648, "Version", newJString(Version))
  result = call_604647.call(nil, query_604648, nil, nil, nil)

var getDescribeEventSubscriptions* = Call_GetDescribeEventSubscriptions_604629(
    name: "getDescribeEventSubscriptions", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeEventSubscriptions",
    validator: validate_GetDescribeEventSubscriptions_604630, base: "/",
    url: url_GetDescribeEventSubscriptions_604631,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeEvents_604692 = ref object of OpenApiRestCall_602450
proc url_PostDescribeEvents_604694(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostDescribeEvents_604693(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Returns events related to clusters, security groups, snapshots, and parameter groups for the past 14 days. Events specific to a particular cluster, security group, snapshot or parameter group can be obtained by providing the name as a parameter. By default, the past hour of events are returned.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_604695 = query.getOrDefault("Action")
  valid_604695 = validateParameter(valid_604695, JString, required = true,
                                 default = newJString("DescribeEvents"))
  if valid_604695 != nil:
    section.add "Action", valid_604695
  var valid_604696 = query.getOrDefault("Version")
  valid_604696 = validateParameter(valid_604696, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_604696 != nil:
    section.add "Version", valid_604696
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_604697 = header.getOrDefault("X-Amz-Date")
  valid_604697 = validateParameter(valid_604697, JString, required = false,
                                 default = nil)
  if valid_604697 != nil:
    section.add "X-Amz-Date", valid_604697
  var valid_604698 = header.getOrDefault("X-Amz-Security-Token")
  valid_604698 = validateParameter(valid_604698, JString, required = false,
                                 default = nil)
  if valid_604698 != nil:
    section.add "X-Amz-Security-Token", valid_604698
  var valid_604699 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604699 = validateParameter(valid_604699, JString, required = false,
                                 default = nil)
  if valid_604699 != nil:
    section.add "X-Amz-Content-Sha256", valid_604699
  var valid_604700 = header.getOrDefault("X-Amz-Algorithm")
  valid_604700 = validateParameter(valid_604700, JString, required = false,
                                 default = nil)
  if valid_604700 != nil:
    section.add "X-Amz-Algorithm", valid_604700
  var valid_604701 = header.getOrDefault("X-Amz-Signature")
  valid_604701 = validateParameter(valid_604701, JString, required = false,
                                 default = nil)
  if valid_604701 != nil:
    section.add "X-Amz-Signature", valid_604701
  var valid_604702 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604702 = validateParameter(valid_604702, JString, required = false,
                                 default = nil)
  if valid_604702 != nil:
    section.add "X-Amz-SignedHeaders", valid_604702
  var valid_604703 = header.getOrDefault("X-Amz-Credential")
  valid_604703 = validateParameter(valid_604703, JString, required = false,
                                 default = nil)
  if valid_604703 != nil:
    section.add "X-Amz-Credential", valid_604703
  result.add "header", section
  ## parameters in `formData` object:
  ##   SourceIdentifier: JString
  ##                   : <p>The identifier of the event source for which events will be returned. If this parameter is not specified, then all sources are included in the response.</p> <p>Constraints:</p> <p>If <i>SourceIdentifier</i> is supplied, <i>SourceType</i> must also be provided.</p> <ul> <li> <p>Specify a cluster identifier when <i>SourceType</i> is <code>cluster</code>.</p> </li> <li> <p>Specify a cluster security group name when <i>SourceType</i> is <code>cluster-security-group</code>.</p> </li> <li> <p>Specify a cluster parameter group name when <i>SourceType</i> is <code>cluster-parameter-group</code>.</p> </li> <li> <p>Specify a cluster snapshot identifier when <i>SourceType</i> is <code>cluster-snapshot</code>.</p> </li> </ul>
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeEvents</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   StartTime: JString
  ##            : <p>The beginning of the time interval to retrieve events for, specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2009-07-08T18:00Z</code> </p>
  ##   Duration: JInt
  ##           : <p>The number of minutes prior to the time of the request for which to retrieve events. For example, if the request is sent at 18:00 and you specify a duration of 60, then only events which have occurred after 17:00 will be returned.</p> <p>Default: <code>60</code> </p>
  ##   EndTime: JString
  ##          : <p>The end of the time interval for which to retrieve events, specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2009-07-08T18:00Z</code> </p>
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   SourceType: JString
  ##             : <p>The event source to retrieve events for. If no value is specified, all events are returned.</p> <p>Constraints:</p> <p>If <i>SourceType</i> is supplied, <i>SourceIdentifier</i> must also be provided.</p> <ul> <li> <p>Specify <code>cluster</code> when <i>SourceIdentifier</i> is a cluster identifier.</p> </li> <li> <p>Specify <code>cluster-security-group</code> when <i>SourceIdentifier</i> is a cluster security group name.</p> </li> <li> <p>Specify <code>cluster-parameter-group</code> when <i>SourceIdentifier</i> is a cluster parameter group name.</p> </li> <li> <p>Specify <code>cluster-snapshot</code> when <i>SourceIdentifier</i> is a cluster snapshot identifier.</p> </li> </ul>
  section = newJObject()
  var valid_604704 = formData.getOrDefault("SourceIdentifier")
  valid_604704 = validateParameter(valid_604704, JString, required = false,
                                 default = nil)
  if valid_604704 != nil:
    section.add "SourceIdentifier", valid_604704
  var valid_604705 = formData.getOrDefault("Marker")
  valid_604705 = validateParameter(valid_604705, JString, required = false,
                                 default = nil)
  if valid_604705 != nil:
    section.add "Marker", valid_604705
  var valid_604706 = formData.getOrDefault("StartTime")
  valid_604706 = validateParameter(valid_604706, JString, required = false,
                                 default = nil)
  if valid_604706 != nil:
    section.add "StartTime", valid_604706
  var valid_604707 = formData.getOrDefault("Duration")
  valid_604707 = validateParameter(valid_604707, JInt, required = false, default = nil)
  if valid_604707 != nil:
    section.add "Duration", valid_604707
  var valid_604708 = formData.getOrDefault("EndTime")
  valid_604708 = validateParameter(valid_604708, JString, required = false,
                                 default = nil)
  if valid_604708 != nil:
    section.add "EndTime", valid_604708
  var valid_604709 = formData.getOrDefault("MaxRecords")
  valid_604709 = validateParameter(valid_604709, JInt, required = false, default = nil)
  if valid_604709 != nil:
    section.add "MaxRecords", valid_604709
  var valid_604710 = formData.getOrDefault("SourceType")
  valid_604710 = validateParameter(valid_604710, JString, required = false,
                                 default = newJString("cluster"))
  if valid_604710 != nil:
    section.add "SourceType", valid_604710
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604711: Call_PostDescribeEvents_604692; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns events related to clusters, security groups, snapshots, and parameter groups for the past 14 days. Events specific to a particular cluster, security group, snapshot or parameter group can be obtained by providing the name as a parameter. By default, the past hour of events are returned.
  ## 
  let valid = call_604711.validator(path, query, header, formData, body)
  let scheme = call_604711.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604711.url(scheme.get, call_604711.host, call_604711.base,
                         call_604711.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_604711, url, valid)

proc call*(call_604712: Call_PostDescribeEvents_604692;
          SourceIdentifier: string = ""; Marker: string = ""; StartTime: string = "";
          Action: string = "DescribeEvents"; Duration: int = 0; EndTime: string = "";
          MaxRecords: int = 0; Version: string = "2012-12-01";
          SourceType: string = "cluster"): Recallable =
  ## postDescribeEvents
  ## Returns events related to clusters, security groups, snapshots, and parameter groups for the past 14 days. Events specific to a particular cluster, security group, snapshot or parameter group can be obtained by providing the name as a parameter. By default, the past hour of events are returned.
  ##   SourceIdentifier: string
  ##                   : <p>The identifier of the event source for which events will be returned. If this parameter is not specified, then all sources are included in the response.</p> <p>Constraints:</p> <p>If <i>SourceIdentifier</i> is supplied, <i>SourceType</i> must also be provided.</p> <ul> <li> <p>Specify a cluster identifier when <i>SourceType</i> is <code>cluster</code>.</p> </li> <li> <p>Specify a cluster security group name when <i>SourceType</i> is <code>cluster-security-group</code>.</p> </li> <li> <p>Specify a cluster parameter group name when <i>SourceType</i> is <code>cluster-parameter-group</code>.</p> </li> <li> <p>Specify a cluster snapshot identifier when <i>SourceType</i> is <code>cluster-snapshot</code>.</p> </li> </ul>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeEvents</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   StartTime: string
  ##            : <p>The beginning of the time interval to retrieve events for, specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2009-07-08T18:00Z</code> </p>
  ##   Action: string (required)
  ##   Duration: int
  ##           : <p>The number of minutes prior to the time of the request for which to retrieve events. For example, if the request is sent at 18:00 and you specify a duration of 60, then only events which have occurred after 17:00 will be returned.</p> <p>Default: <code>60</code> </p>
  ##   EndTime: string
  ##          : <p>The end of the time interval for which to retrieve events, specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2009-07-08T18:00Z</code> </p>
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Version: string (required)
  ##   SourceType: string
  ##             : <p>The event source to retrieve events for. If no value is specified, all events are returned.</p> <p>Constraints:</p> <p>If <i>SourceType</i> is supplied, <i>SourceIdentifier</i> must also be provided.</p> <ul> <li> <p>Specify <code>cluster</code> when <i>SourceIdentifier</i> is a cluster identifier.</p> </li> <li> <p>Specify <code>cluster-security-group</code> when <i>SourceIdentifier</i> is a cluster security group name.</p> </li> <li> <p>Specify <code>cluster-parameter-group</code> when <i>SourceIdentifier</i> is a cluster parameter group name.</p> </li> <li> <p>Specify <code>cluster-snapshot</code> when <i>SourceIdentifier</i> is a cluster snapshot identifier.</p> </li> </ul>
  var query_604713 = newJObject()
  var formData_604714 = newJObject()
  add(formData_604714, "SourceIdentifier", newJString(SourceIdentifier))
  add(formData_604714, "Marker", newJString(Marker))
  add(formData_604714, "StartTime", newJString(StartTime))
  add(query_604713, "Action", newJString(Action))
  add(formData_604714, "Duration", newJInt(Duration))
  add(formData_604714, "EndTime", newJString(EndTime))
  add(formData_604714, "MaxRecords", newJInt(MaxRecords))
  add(query_604713, "Version", newJString(Version))
  add(formData_604714, "SourceType", newJString(SourceType))
  result = call_604712.call(nil, query_604713, nil, formData_604714, nil)

var postDescribeEvents* = Call_PostDescribeEvents_604692(
    name: "postDescribeEvents", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeEvents",
    validator: validate_PostDescribeEvents_604693, base: "/",
    url: url_PostDescribeEvents_604694, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeEvents_604670 = ref object of OpenApiRestCall_602450
proc url_GetDescribeEvents_604672(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetDescribeEvents_604671(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## Returns events related to clusters, security groups, snapshots, and parameter groups for the past 14 days. Events specific to a particular cluster, security group, snapshot or parameter group can be obtained by providing the name as a parameter. By default, the past hour of events are returned.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   SourceType: JString
  ##             : <p>The event source to retrieve events for. If no value is specified, all events are returned.</p> <p>Constraints:</p> <p>If <i>SourceType</i> is supplied, <i>SourceIdentifier</i> must also be provided.</p> <ul> <li> <p>Specify <code>cluster</code> when <i>SourceIdentifier</i> is a cluster identifier.</p> </li> <li> <p>Specify <code>cluster-security-group</code> when <i>SourceIdentifier</i> is a cluster security group name.</p> </li> <li> <p>Specify <code>cluster-parameter-group</code> when <i>SourceIdentifier</i> is a cluster parameter group name.</p> </li> <li> <p>Specify <code>cluster-snapshot</code> when <i>SourceIdentifier</i> is a cluster snapshot identifier.</p> </li> </ul>
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   StartTime: JString
  ##            : <p>The beginning of the time interval to retrieve events for, specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2009-07-08T18:00Z</code> </p>
  ##   Action: JString (required)
  ##   SourceIdentifier: JString
  ##                   : <p>The identifier of the event source for which events will be returned. If this parameter is not specified, then all sources are included in the response.</p> <p>Constraints:</p> <p>If <i>SourceIdentifier</i> is supplied, <i>SourceType</i> must also be provided.</p> <ul> <li> <p>Specify a cluster identifier when <i>SourceType</i> is <code>cluster</code>.</p> </li> <li> <p>Specify a cluster security group name when <i>SourceType</i> is <code>cluster-security-group</code>.</p> </li> <li> <p>Specify a cluster parameter group name when <i>SourceType</i> is <code>cluster-parameter-group</code>.</p> </li> <li> <p>Specify a cluster snapshot identifier when <i>SourceType</i> is <code>cluster-snapshot</code>.</p> </li> </ul>
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeEvents</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Duration: JInt
  ##           : <p>The number of minutes prior to the time of the request for which to retrieve events. For example, if the request is sent at 18:00 and you specify a duration of 60, then only events which have occurred after 17:00 will be returned.</p> <p>Default: <code>60</code> </p>
  ##   EndTime: JString
  ##          : <p>The end of the time interval for which to retrieve events, specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2009-07-08T18:00Z</code> </p>
  ##   Version: JString (required)
  section = newJObject()
  var valid_604673 = query.getOrDefault("SourceType")
  valid_604673 = validateParameter(valid_604673, JString, required = false,
                                 default = newJString("cluster"))
  if valid_604673 != nil:
    section.add "SourceType", valid_604673
  var valid_604674 = query.getOrDefault("MaxRecords")
  valid_604674 = validateParameter(valid_604674, JInt, required = false, default = nil)
  if valid_604674 != nil:
    section.add "MaxRecords", valid_604674
  var valid_604675 = query.getOrDefault("StartTime")
  valid_604675 = validateParameter(valid_604675, JString, required = false,
                                 default = nil)
  if valid_604675 != nil:
    section.add "StartTime", valid_604675
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_604676 = query.getOrDefault("Action")
  valid_604676 = validateParameter(valid_604676, JString, required = true,
                                 default = newJString("DescribeEvents"))
  if valid_604676 != nil:
    section.add "Action", valid_604676
  var valid_604677 = query.getOrDefault("SourceIdentifier")
  valid_604677 = validateParameter(valid_604677, JString, required = false,
                                 default = nil)
  if valid_604677 != nil:
    section.add "SourceIdentifier", valid_604677
  var valid_604678 = query.getOrDefault("Marker")
  valid_604678 = validateParameter(valid_604678, JString, required = false,
                                 default = nil)
  if valid_604678 != nil:
    section.add "Marker", valid_604678
  var valid_604679 = query.getOrDefault("Duration")
  valid_604679 = validateParameter(valid_604679, JInt, required = false, default = nil)
  if valid_604679 != nil:
    section.add "Duration", valid_604679
  var valid_604680 = query.getOrDefault("EndTime")
  valid_604680 = validateParameter(valid_604680, JString, required = false,
                                 default = nil)
  if valid_604680 != nil:
    section.add "EndTime", valid_604680
  var valid_604681 = query.getOrDefault("Version")
  valid_604681 = validateParameter(valid_604681, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_604681 != nil:
    section.add "Version", valid_604681
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_604682 = header.getOrDefault("X-Amz-Date")
  valid_604682 = validateParameter(valid_604682, JString, required = false,
                                 default = nil)
  if valid_604682 != nil:
    section.add "X-Amz-Date", valid_604682
  var valid_604683 = header.getOrDefault("X-Amz-Security-Token")
  valid_604683 = validateParameter(valid_604683, JString, required = false,
                                 default = nil)
  if valid_604683 != nil:
    section.add "X-Amz-Security-Token", valid_604683
  var valid_604684 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604684 = validateParameter(valid_604684, JString, required = false,
                                 default = nil)
  if valid_604684 != nil:
    section.add "X-Amz-Content-Sha256", valid_604684
  var valid_604685 = header.getOrDefault("X-Amz-Algorithm")
  valid_604685 = validateParameter(valid_604685, JString, required = false,
                                 default = nil)
  if valid_604685 != nil:
    section.add "X-Amz-Algorithm", valid_604685
  var valid_604686 = header.getOrDefault("X-Amz-Signature")
  valid_604686 = validateParameter(valid_604686, JString, required = false,
                                 default = nil)
  if valid_604686 != nil:
    section.add "X-Amz-Signature", valid_604686
  var valid_604687 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604687 = validateParameter(valid_604687, JString, required = false,
                                 default = nil)
  if valid_604687 != nil:
    section.add "X-Amz-SignedHeaders", valid_604687
  var valid_604688 = header.getOrDefault("X-Amz-Credential")
  valid_604688 = validateParameter(valid_604688, JString, required = false,
                                 default = nil)
  if valid_604688 != nil:
    section.add "X-Amz-Credential", valid_604688
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604689: Call_GetDescribeEvents_604670; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns events related to clusters, security groups, snapshots, and parameter groups for the past 14 days. Events specific to a particular cluster, security group, snapshot or parameter group can be obtained by providing the name as a parameter. By default, the past hour of events are returned.
  ## 
  let valid = call_604689.validator(path, query, header, formData, body)
  let scheme = call_604689.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604689.url(scheme.get, call_604689.host, call_604689.base,
                         call_604689.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_604689, url, valid)

proc call*(call_604690: Call_GetDescribeEvents_604670;
          SourceType: string = "cluster"; MaxRecords: int = 0; StartTime: string = "";
          Action: string = "DescribeEvents"; SourceIdentifier: string = "";
          Marker: string = ""; Duration: int = 0; EndTime: string = "";
          Version: string = "2012-12-01"): Recallable =
  ## getDescribeEvents
  ## Returns events related to clusters, security groups, snapshots, and parameter groups for the past 14 days. Events specific to a particular cluster, security group, snapshot or parameter group can be obtained by providing the name as a parameter. By default, the past hour of events are returned.
  ##   SourceType: string
  ##             : <p>The event source to retrieve events for. If no value is specified, all events are returned.</p> <p>Constraints:</p> <p>If <i>SourceType</i> is supplied, <i>SourceIdentifier</i> must also be provided.</p> <ul> <li> <p>Specify <code>cluster</code> when <i>SourceIdentifier</i> is a cluster identifier.</p> </li> <li> <p>Specify <code>cluster-security-group</code> when <i>SourceIdentifier</i> is a cluster security group name.</p> </li> <li> <p>Specify <code>cluster-parameter-group</code> when <i>SourceIdentifier</i> is a cluster parameter group name.</p> </li> <li> <p>Specify <code>cluster-snapshot</code> when <i>SourceIdentifier</i> is a cluster snapshot identifier.</p> </li> </ul>
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   StartTime: string
  ##            : <p>The beginning of the time interval to retrieve events for, specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2009-07-08T18:00Z</code> </p>
  ##   Action: string (required)
  ##   SourceIdentifier: string
  ##                   : <p>The identifier of the event source for which events will be returned. If this parameter is not specified, then all sources are included in the response.</p> <p>Constraints:</p> <p>If <i>SourceIdentifier</i> is supplied, <i>SourceType</i> must also be provided.</p> <ul> <li> <p>Specify a cluster identifier when <i>SourceType</i> is <code>cluster</code>.</p> </li> <li> <p>Specify a cluster security group name when <i>SourceType</i> is <code>cluster-security-group</code>.</p> </li> <li> <p>Specify a cluster parameter group name when <i>SourceType</i> is <code>cluster-parameter-group</code>.</p> </li> <li> <p>Specify a cluster snapshot identifier when <i>SourceType</i> is <code>cluster-snapshot</code>.</p> </li> </ul>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeEvents</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Duration: int
  ##           : <p>The number of minutes prior to the time of the request for which to retrieve events. For example, if the request is sent at 18:00 and you specify a duration of 60, then only events which have occurred after 17:00 will be returned.</p> <p>Default: <code>60</code> </p>
  ##   EndTime: string
  ##          : <p>The end of the time interval for which to retrieve events, specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2009-07-08T18:00Z</code> </p>
  ##   Version: string (required)
  var query_604691 = newJObject()
  add(query_604691, "SourceType", newJString(SourceType))
  add(query_604691, "MaxRecords", newJInt(MaxRecords))
  add(query_604691, "StartTime", newJString(StartTime))
  add(query_604691, "Action", newJString(Action))
  add(query_604691, "SourceIdentifier", newJString(SourceIdentifier))
  add(query_604691, "Marker", newJString(Marker))
  add(query_604691, "Duration", newJInt(Duration))
  add(query_604691, "EndTime", newJString(EndTime))
  add(query_604691, "Version", newJString(Version))
  result = call_604690.call(nil, query_604691, nil, nil, nil)

var getDescribeEvents* = Call_GetDescribeEvents_604670(name: "getDescribeEvents",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=DescribeEvents", validator: validate_GetDescribeEvents_604671,
    base: "/", url: url_GetDescribeEvents_604672,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeHsmClientCertificates_604735 = ref object of OpenApiRestCall_602450
proc url_PostDescribeHsmClientCertificates_604737(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostDescribeHsmClientCertificates_604736(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns information about the specified HSM client certificate. If no certificate ID is specified, returns information about all the HSM certificates owned by your AWS customer account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM client certificates that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all HSM client certificates that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, HSM client certificates are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_604738 = query.getOrDefault("Action")
  valid_604738 = validateParameter(valid_604738, JString, required = true, default = newJString(
      "DescribeHsmClientCertificates"))
  if valid_604738 != nil:
    section.add "Action", valid_604738
  var valid_604739 = query.getOrDefault("Version")
  valid_604739 = validateParameter(valid_604739, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_604739 != nil:
    section.add "Version", valid_604739
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_604740 = header.getOrDefault("X-Amz-Date")
  valid_604740 = validateParameter(valid_604740, JString, required = false,
                                 default = nil)
  if valid_604740 != nil:
    section.add "X-Amz-Date", valid_604740
  var valid_604741 = header.getOrDefault("X-Amz-Security-Token")
  valid_604741 = validateParameter(valid_604741, JString, required = false,
                                 default = nil)
  if valid_604741 != nil:
    section.add "X-Amz-Security-Token", valid_604741
  var valid_604742 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604742 = validateParameter(valid_604742, JString, required = false,
                                 default = nil)
  if valid_604742 != nil:
    section.add "X-Amz-Content-Sha256", valid_604742
  var valid_604743 = header.getOrDefault("X-Amz-Algorithm")
  valid_604743 = validateParameter(valid_604743, JString, required = false,
                                 default = nil)
  if valid_604743 != nil:
    section.add "X-Amz-Algorithm", valid_604743
  var valid_604744 = header.getOrDefault("X-Amz-Signature")
  valid_604744 = validateParameter(valid_604744, JString, required = false,
                                 default = nil)
  if valid_604744 != nil:
    section.add "X-Amz-Signature", valid_604744
  var valid_604745 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604745 = validateParameter(valid_604745, JString, required = false,
                                 default = nil)
  if valid_604745 != nil:
    section.add "X-Amz-SignedHeaders", valid_604745
  var valid_604746 = header.getOrDefault("X-Amz-Credential")
  valid_604746 = validateParameter(valid_604746, JString, required = false,
                                 default = nil)
  if valid_604746 != nil:
    section.add "X-Amz-Credential", valid_604746
  result.add "header", section
  ## parameters in `formData` object:
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeHsmClientCertificates</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   HsmClientCertificateIdentifier: JString
  ##                                 : The identifier of a specific HSM client certificate for which you want information. If no identifier is specified, information is returned for all HSM client certificates owned by your AWS customer account.
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching HSM client certificates that are associated with the specified key or keys. For example, suppose that you have HSM client certificates that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the HSM client certificates that have either or both of these tag keys associated with them.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching HSM client certificates that are associated with the specified tag value or values. For example, suppose that you have HSM client certificates that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the HSM client certificates that have either or both of these tag values associated with them.
  section = newJObject()
  var valid_604747 = formData.getOrDefault("Marker")
  valid_604747 = validateParameter(valid_604747, JString, required = false,
                                 default = nil)
  if valid_604747 != nil:
    section.add "Marker", valid_604747
  var valid_604748 = formData.getOrDefault("HsmClientCertificateIdentifier")
  valid_604748 = validateParameter(valid_604748, JString, required = false,
                                 default = nil)
  if valid_604748 != nil:
    section.add "HsmClientCertificateIdentifier", valid_604748
  var valid_604749 = formData.getOrDefault("TagKeys")
  valid_604749 = validateParameter(valid_604749, JArray, required = false,
                                 default = nil)
  if valid_604749 != nil:
    section.add "TagKeys", valid_604749
  var valid_604750 = formData.getOrDefault("MaxRecords")
  valid_604750 = validateParameter(valid_604750, JInt, required = false, default = nil)
  if valid_604750 != nil:
    section.add "MaxRecords", valid_604750
  var valid_604751 = formData.getOrDefault("TagValues")
  valid_604751 = validateParameter(valid_604751, JArray, required = false,
                                 default = nil)
  if valid_604751 != nil:
    section.add "TagValues", valid_604751
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604752: Call_PostDescribeHsmClientCertificates_604735;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Returns information about the specified HSM client certificate. If no certificate ID is specified, returns information about all the HSM certificates owned by your AWS customer account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM client certificates that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all HSM client certificates that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, HSM client certificates are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_604752.validator(path, query, header, formData, body)
  let scheme = call_604752.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604752.url(scheme.get, call_604752.host, call_604752.base,
                         call_604752.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_604752, url, valid)

proc call*(call_604753: Call_PostDescribeHsmClientCertificates_604735;
          Marker: string = ""; Action: string = "DescribeHsmClientCertificates";
          HsmClientCertificateIdentifier: string = ""; TagKeys: JsonNode = nil;
          MaxRecords: int = 0; TagValues: JsonNode = nil; Version: string = "2012-12-01"): Recallable =
  ## postDescribeHsmClientCertificates
  ## <p>Returns information about the specified HSM client certificate. If no certificate ID is specified, returns information about all the HSM certificates owned by your AWS customer account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM client certificates that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all HSM client certificates that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, HSM client certificates are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeHsmClientCertificates</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Action: string (required)
  ##   HsmClientCertificateIdentifier: string
  ##                                 : The identifier of a specific HSM client certificate for which you want information. If no identifier is specified, information is returned for all HSM client certificates owned by your AWS customer account.
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching HSM client certificates that are associated with the specified key or keys. For example, suppose that you have HSM client certificates that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the HSM client certificates that have either or both of these tag keys associated with them.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching HSM client certificates that are associated with the specified tag value or values. For example, suppose that you have HSM client certificates that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the HSM client certificates that have either or both of these tag values associated with them.
  ##   Version: string (required)
  var query_604754 = newJObject()
  var formData_604755 = newJObject()
  add(formData_604755, "Marker", newJString(Marker))
  add(query_604754, "Action", newJString(Action))
  add(formData_604755, "HsmClientCertificateIdentifier",
      newJString(HsmClientCertificateIdentifier))
  if TagKeys != nil:
    formData_604755.add "TagKeys", TagKeys
  add(formData_604755, "MaxRecords", newJInt(MaxRecords))
  if TagValues != nil:
    formData_604755.add "TagValues", TagValues
  add(query_604754, "Version", newJString(Version))
  result = call_604753.call(nil, query_604754, nil, formData_604755, nil)

var postDescribeHsmClientCertificates* = Call_PostDescribeHsmClientCertificates_604735(
    name: "postDescribeHsmClientCertificates", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeHsmClientCertificates",
    validator: validate_PostDescribeHsmClientCertificates_604736, base: "/",
    url: url_PostDescribeHsmClientCertificates_604737,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeHsmClientCertificates_604715 = ref object of OpenApiRestCall_602450
proc url_GetDescribeHsmClientCertificates_604717(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetDescribeHsmClientCertificates_604716(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns information about the specified HSM client certificate. If no certificate ID is specified, returns information about all the HSM certificates owned by your AWS customer account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM client certificates that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all HSM client certificates that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, HSM client certificates are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching HSM client certificates that are associated with the specified tag value or values. For example, suppose that you have HSM client certificates that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the HSM client certificates that have either or both of these tag values associated with them.
  ##   HsmClientCertificateIdentifier: JString
  ##                                 : The identifier of a specific HSM client certificate for which you want information. If no identifier is specified, information is returned for all HSM client certificates owned by your AWS customer account.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Action: JString (required)
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeHsmClientCertificates</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching HSM client certificates that are associated with the specified key or keys. For example, suppose that you have HSM client certificates that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the HSM client certificates that have either or both of these tag keys associated with them.
  ##   Version: JString (required)
  section = newJObject()
  var valid_604718 = query.getOrDefault("TagValues")
  valid_604718 = validateParameter(valid_604718, JArray, required = false,
                                 default = nil)
  if valid_604718 != nil:
    section.add "TagValues", valid_604718
  var valid_604719 = query.getOrDefault("HsmClientCertificateIdentifier")
  valid_604719 = validateParameter(valid_604719, JString, required = false,
                                 default = nil)
  if valid_604719 != nil:
    section.add "HsmClientCertificateIdentifier", valid_604719
  var valid_604720 = query.getOrDefault("MaxRecords")
  valid_604720 = validateParameter(valid_604720, JInt, required = false, default = nil)
  if valid_604720 != nil:
    section.add "MaxRecords", valid_604720
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_604721 = query.getOrDefault("Action")
  valid_604721 = validateParameter(valid_604721, JString, required = true, default = newJString(
      "DescribeHsmClientCertificates"))
  if valid_604721 != nil:
    section.add "Action", valid_604721
  var valid_604722 = query.getOrDefault("Marker")
  valid_604722 = validateParameter(valid_604722, JString, required = false,
                                 default = nil)
  if valid_604722 != nil:
    section.add "Marker", valid_604722
  var valid_604723 = query.getOrDefault("TagKeys")
  valid_604723 = validateParameter(valid_604723, JArray, required = false,
                                 default = nil)
  if valid_604723 != nil:
    section.add "TagKeys", valid_604723
  var valid_604724 = query.getOrDefault("Version")
  valid_604724 = validateParameter(valid_604724, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_604724 != nil:
    section.add "Version", valid_604724
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_604725 = header.getOrDefault("X-Amz-Date")
  valid_604725 = validateParameter(valid_604725, JString, required = false,
                                 default = nil)
  if valid_604725 != nil:
    section.add "X-Amz-Date", valid_604725
  var valid_604726 = header.getOrDefault("X-Amz-Security-Token")
  valid_604726 = validateParameter(valid_604726, JString, required = false,
                                 default = nil)
  if valid_604726 != nil:
    section.add "X-Amz-Security-Token", valid_604726
  var valid_604727 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604727 = validateParameter(valid_604727, JString, required = false,
                                 default = nil)
  if valid_604727 != nil:
    section.add "X-Amz-Content-Sha256", valid_604727
  var valid_604728 = header.getOrDefault("X-Amz-Algorithm")
  valid_604728 = validateParameter(valid_604728, JString, required = false,
                                 default = nil)
  if valid_604728 != nil:
    section.add "X-Amz-Algorithm", valid_604728
  var valid_604729 = header.getOrDefault("X-Amz-Signature")
  valid_604729 = validateParameter(valid_604729, JString, required = false,
                                 default = nil)
  if valid_604729 != nil:
    section.add "X-Amz-Signature", valid_604729
  var valid_604730 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604730 = validateParameter(valid_604730, JString, required = false,
                                 default = nil)
  if valid_604730 != nil:
    section.add "X-Amz-SignedHeaders", valid_604730
  var valid_604731 = header.getOrDefault("X-Amz-Credential")
  valid_604731 = validateParameter(valid_604731, JString, required = false,
                                 default = nil)
  if valid_604731 != nil:
    section.add "X-Amz-Credential", valid_604731
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604732: Call_GetDescribeHsmClientCertificates_604715;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Returns information about the specified HSM client certificate. If no certificate ID is specified, returns information about all the HSM certificates owned by your AWS customer account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM client certificates that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all HSM client certificates that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, HSM client certificates are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_604732.validator(path, query, header, formData, body)
  let scheme = call_604732.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604732.url(scheme.get, call_604732.host, call_604732.base,
                         call_604732.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_604732, url, valid)

proc call*(call_604733: Call_GetDescribeHsmClientCertificates_604715;
          TagValues: JsonNode = nil; HsmClientCertificateIdentifier: string = "";
          MaxRecords: int = 0; Action: string = "DescribeHsmClientCertificates";
          Marker: string = ""; TagKeys: JsonNode = nil; Version: string = "2012-12-01"): Recallable =
  ## getDescribeHsmClientCertificates
  ## <p>Returns information about the specified HSM client certificate. If no certificate ID is specified, returns information about all the HSM certificates owned by your AWS customer account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM client certificates that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all HSM client certificates that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, HSM client certificates are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching HSM client certificates that are associated with the specified tag value or values. For example, suppose that you have HSM client certificates that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the HSM client certificates that have either or both of these tag values associated with them.
  ##   HsmClientCertificateIdentifier: string
  ##                                 : The identifier of a specific HSM client certificate for which you want information. If no identifier is specified, information is returned for all HSM client certificates owned by your AWS customer account.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Action: string (required)
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeHsmClientCertificates</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching HSM client certificates that are associated with the specified key or keys. For example, suppose that you have HSM client certificates that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the HSM client certificates that have either or both of these tag keys associated with them.
  ##   Version: string (required)
  var query_604734 = newJObject()
  if TagValues != nil:
    query_604734.add "TagValues", TagValues
  add(query_604734, "HsmClientCertificateIdentifier",
      newJString(HsmClientCertificateIdentifier))
  add(query_604734, "MaxRecords", newJInt(MaxRecords))
  add(query_604734, "Action", newJString(Action))
  add(query_604734, "Marker", newJString(Marker))
  if TagKeys != nil:
    query_604734.add "TagKeys", TagKeys
  add(query_604734, "Version", newJString(Version))
  result = call_604733.call(nil, query_604734, nil, nil, nil)

var getDescribeHsmClientCertificates* = Call_GetDescribeHsmClientCertificates_604715(
    name: "getDescribeHsmClientCertificates", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeHsmClientCertificates",
    validator: validate_GetDescribeHsmClientCertificates_604716, base: "/",
    url: url_GetDescribeHsmClientCertificates_604717,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeHsmConfigurations_604776 = ref object of OpenApiRestCall_602450
proc url_PostDescribeHsmConfigurations_604778(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostDescribeHsmConfigurations_604777(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns information about the specified Amazon Redshift HSM configuration. If no configuration ID is specified, returns information about all the HSM configurations owned by your AWS customer account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM connections that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all HSM connections that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, HSM connections are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_604779 = query.getOrDefault("Action")
  valid_604779 = validateParameter(valid_604779, JString, required = true, default = newJString(
      "DescribeHsmConfigurations"))
  if valid_604779 != nil:
    section.add "Action", valid_604779
  var valid_604780 = query.getOrDefault("Version")
  valid_604780 = validateParameter(valid_604780, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_604780 != nil:
    section.add "Version", valid_604780
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_604781 = header.getOrDefault("X-Amz-Date")
  valid_604781 = validateParameter(valid_604781, JString, required = false,
                                 default = nil)
  if valid_604781 != nil:
    section.add "X-Amz-Date", valid_604781
  var valid_604782 = header.getOrDefault("X-Amz-Security-Token")
  valid_604782 = validateParameter(valid_604782, JString, required = false,
                                 default = nil)
  if valid_604782 != nil:
    section.add "X-Amz-Security-Token", valid_604782
  var valid_604783 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604783 = validateParameter(valid_604783, JString, required = false,
                                 default = nil)
  if valid_604783 != nil:
    section.add "X-Amz-Content-Sha256", valid_604783
  var valid_604784 = header.getOrDefault("X-Amz-Algorithm")
  valid_604784 = validateParameter(valid_604784, JString, required = false,
                                 default = nil)
  if valid_604784 != nil:
    section.add "X-Amz-Algorithm", valid_604784
  var valid_604785 = header.getOrDefault("X-Amz-Signature")
  valid_604785 = validateParameter(valid_604785, JString, required = false,
                                 default = nil)
  if valid_604785 != nil:
    section.add "X-Amz-Signature", valid_604785
  var valid_604786 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604786 = validateParameter(valid_604786, JString, required = false,
                                 default = nil)
  if valid_604786 != nil:
    section.add "X-Amz-SignedHeaders", valid_604786
  var valid_604787 = header.getOrDefault("X-Amz-Credential")
  valid_604787 = validateParameter(valid_604787, JString, required = false,
                                 default = nil)
  if valid_604787 != nil:
    section.add "X-Amz-Credential", valid_604787
  result.add "header", section
  ## parameters in `formData` object:
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeHsmConfigurations</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   HsmConfigurationIdentifier: JString
  ##                             : The identifier of a specific Amazon Redshift HSM configuration to be described. If no identifier is specified, information is returned for all HSM configurations owned by your AWS customer account.
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching HSM configurations that are associated with the specified key or keys. For example, suppose that you have HSM configurations that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the HSM configurations that have either or both of these tag keys associated with them.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching HSM configurations that are associated with the specified tag value or values. For example, suppose that you have HSM configurations that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the HSM configurations that have either or both of these tag values associated with them.
  section = newJObject()
  var valid_604788 = formData.getOrDefault("Marker")
  valid_604788 = validateParameter(valid_604788, JString, required = false,
                                 default = nil)
  if valid_604788 != nil:
    section.add "Marker", valid_604788
  var valid_604789 = formData.getOrDefault("HsmConfigurationIdentifier")
  valid_604789 = validateParameter(valid_604789, JString, required = false,
                                 default = nil)
  if valid_604789 != nil:
    section.add "HsmConfigurationIdentifier", valid_604789
  var valid_604790 = formData.getOrDefault("TagKeys")
  valid_604790 = validateParameter(valid_604790, JArray, required = false,
                                 default = nil)
  if valid_604790 != nil:
    section.add "TagKeys", valid_604790
  var valid_604791 = formData.getOrDefault("MaxRecords")
  valid_604791 = validateParameter(valid_604791, JInt, required = false, default = nil)
  if valid_604791 != nil:
    section.add "MaxRecords", valid_604791
  var valid_604792 = formData.getOrDefault("TagValues")
  valid_604792 = validateParameter(valid_604792, JArray, required = false,
                                 default = nil)
  if valid_604792 != nil:
    section.add "TagValues", valid_604792
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604793: Call_PostDescribeHsmConfigurations_604776; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns information about the specified Amazon Redshift HSM configuration. If no configuration ID is specified, returns information about all the HSM configurations owned by your AWS customer account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM connections that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all HSM connections that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, HSM connections are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_604793.validator(path, query, header, formData, body)
  let scheme = call_604793.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604793.url(scheme.get, call_604793.host, call_604793.base,
                         call_604793.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_604793, url, valid)

proc call*(call_604794: Call_PostDescribeHsmConfigurations_604776;
          Marker: string = ""; HsmConfigurationIdentifier: string = "";
          Action: string = "DescribeHsmConfigurations"; TagKeys: JsonNode = nil;
          MaxRecords: int = 0; TagValues: JsonNode = nil; Version: string = "2012-12-01"): Recallable =
  ## postDescribeHsmConfigurations
  ## <p>Returns information about the specified Amazon Redshift HSM configuration. If no configuration ID is specified, returns information about all the HSM configurations owned by your AWS customer account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM connections that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all HSM connections that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, HSM connections are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeHsmConfigurations</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   HsmConfigurationIdentifier: string
  ##                             : The identifier of a specific Amazon Redshift HSM configuration to be described. If no identifier is specified, information is returned for all HSM configurations owned by your AWS customer account.
  ##   Action: string (required)
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching HSM configurations that are associated with the specified key or keys. For example, suppose that you have HSM configurations that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the HSM configurations that have either or both of these tag keys associated with them.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching HSM configurations that are associated with the specified tag value or values. For example, suppose that you have HSM configurations that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the HSM configurations that have either or both of these tag values associated with them.
  ##   Version: string (required)
  var query_604795 = newJObject()
  var formData_604796 = newJObject()
  add(formData_604796, "Marker", newJString(Marker))
  add(formData_604796, "HsmConfigurationIdentifier",
      newJString(HsmConfigurationIdentifier))
  add(query_604795, "Action", newJString(Action))
  if TagKeys != nil:
    formData_604796.add "TagKeys", TagKeys
  add(formData_604796, "MaxRecords", newJInt(MaxRecords))
  if TagValues != nil:
    formData_604796.add "TagValues", TagValues
  add(query_604795, "Version", newJString(Version))
  result = call_604794.call(nil, query_604795, nil, formData_604796, nil)

var postDescribeHsmConfigurations* = Call_PostDescribeHsmConfigurations_604776(
    name: "postDescribeHsmConfigurations", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeHsmConfigurations",
    validator: validate_PostDescribeHsmConfigurations_604777, base: "/",
    url: url_PostDescribeHsmConfigurations_604778,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeHsmConfigurations_604756 = ref object of OpenApiRestCall_602450
proc url_GetDescribeHsmConfigurations_604758(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetDescribeHsmConfigurations_604757(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns information about the specified Amazon Redshift HSM configuration. If no configuration ID is specified, returns information about all the HSM configurations owned by your AWS customer account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM connections that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all HSM connections that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, HSM connections are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching HSM configurations that are associated with the specified tag value or values. For example, suppose that you have HSM configurations that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the HSM configurations that have either or both of these tag values associated with them.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   HsmConfigurationIdentifier: JString
  ##                             : The identifier of a specific Amazon Redshift HSM configuration to be described. If no identifier is specified, information is returned for all HSM configurations owned by your AWS customer account.
  ##   Action: JString (required)
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeHsmConfigurations</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching HSM configurations that are associated with the specified key or keys. For example, suppose that you have HSM configurations that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the HSM configurations that have either or both of these tag keys associated with them.
  ##   Version: JString (required)
  section = newJObject()
  var valid_604759 = query.getOrDefault("TagValues")
  valid_604759 = validateParameter(valid_604759, JArray, required = false,
                                 default = nil)
  if valid_604759 != nil:
    section.add "TagValues", valid_604759
  var valid_604760 = query.getOrDefault("MaxRecords")
  valid_604760 = validateParameter(valid_604760, JInt, required = false, default = nil)
  if valid_604760 != nil:
    section.add "MaxRecords", valid_604760
  var valid_604761 = query.getOrDefault("HsmConfigurationIdentifier")
  valid_604761 = validateParameter(valid_604761, JString, required = false,
                                 default = nil)
  if valid_604761 != nil:
    section.add "HsmConfigurationIdentifier", valid_604761
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_604762 = query.getOrDefault("Action")
  valid_604762 = validateParameter(valid_604762, JString, required = true, default = newJString(
      "DescribeHsmConfigurations"))
  if valid_604762 != nil:
    section.add "Action", valid_604762
  var valid_604763 = query.getOrDefault("Marker")
  valid_604763 = validateParameter(valid_604763, JString, required = false,
                                 default = nil)
  if valid_604763 != nil:
    section.add "Marker", valid_604763
  var valid_604764 = query.getOrDefault("TagKeys")
  valid_604764 = validateParameter(valid_604764, JArray, required = false,
                                 default = nil)
  if valid_604764 != nil:
    section.add "TagKeys", valid_604764
  var valid_604765 = query.getOrDefault("Version")
  valid_604765 = validateParameter(valid_604765, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_604765 != nil:
    section.add "Version", valid_604765
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_604766 = header.getOrDefault("X-Amz-Date")
  valid_604766 = validateParameter(valid_604766, JString, required = false,
                                 default = nil)
  if valid_604766 != nil:
    section.add "X-Amz-Date", valid_604766
  var valid_604767 = header.getOrDefault("X-Amz-Security-Token")
  valid_604767 = validateParameter(valid_604767, JString, required = false,
                                 default = nil)
  if valid_604767 != nil:
    section.add "X-Amz-Security-Token", valid_604767
  var valid_604768 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604768 = validateParameter(valid_604768, JString, required = false,
                                 default = nil)
  if valid_604768 != nil:
    section.add "X-Amz-Content-Sha256", valid_604768
  var valid_604769 = header.getOrDefault("X-Amz-Algorithm")
  valid_604769 = validateParameter(valid_604769, JString, required = false,
                                 default = nil)
  if valid_604769 != nil:
    section.add "X-Amz-Algorithm", valid_604769
  var valid_604770 = header.getOrDefault("X-Amz-Signature")
  valid_604770 = validateParameter(valid_604770, JString, required = false,
                                 default = nil)
  if valid_604770 != nil:
    section.add "X-Amz-Signature", valid_604770
  var valid_604771 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604771 = validateParameter(valid_604771, JString, required = false,
                                 default = nil)
  if valid_604771 != nil:
    section.add "X-Amz-SignedHeaders", valid_604771
  var valid_604772 = header.getOrDefault("X-Amz-Credential")
  valid_604772 = validateParameter(valid_604772, JString, required = false,
                                 default = nil)
  if valid_604772 != nil:
    section.add "X-Amz-Credential", valid_604772
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604773: Call_GetDescribeHsmConfigurations_604756; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns information about the specified Amazon Redshift HSM configuration. If no configuration ID is specified, returns information about all the HSM configurations owned by your AWS customer account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM connections that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all HSM connections that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, HSM connections are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_604773.validator(path, query, header, formData, body)
  let scheme = call_604773.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604773.url(scheme.get, call_604773.host, call_604773.base,
                         call_604773.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_604773, url, valid)

proc call*(call_604774: Call_GetDescribeHsmConfigurations_604756;
          TagValues: JsonNode = nil; MaxRecords: int = 0;
          HsmConfigurationIdentifier: string = "";
          Action: string = "DescribeHsmConfigurations"; Marker: string = "";
          TagKeys: JsonNode = nil; Version: string = "2012-12-01"): Recallable =
  ## getDescribeHsmConfigurations
  ## <p>Returns information about the specified Amazon Redshift HSM configuration. If no configuration ID is specified, returns information about all the HSM configurations owned by your AWS customer account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM connections that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all HSM connections that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, HSM connections are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching HSM configurations that are associated with the specified tag value or values. For example, suppose that you have HSM configurations that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the HSM configurations that have either or both of these tag values associated with them.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   HsmConfigurationIdentifier: string
  ##                             : The identifier of a specific Amazon Redshift HSM configuration to be described. If no identifier is specified, information is returned for all HSM configurations owned by your AWS customer account.
  ##   Action: string (required)
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeHsmConfigurations</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching HSM configurations that are associated with the specified key or keys. For example, suppose that you have HSM configurations that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the HSM configurations that have either or both of these tag keys associated with them.
  ##   Version: string (required)
  var query_604775 = newJObject()
  if TagValues != nil:
    query_604775.add "TagValues", TagValues
  add(query_604775, "MaxRecords", newJInt(MaxRecords))
  add(query_604775, "HsmConfigurationIdentifier",
      newJString(HsmConfigurationIdentifier))
  add(query_604775, "Action", newJString(Action))
  add(query_604775, "Marker", newJString(Marker))
  if TagKeys != nil:
    query_604775.add "TagKeys", TagKeys
  add(query_604775, "Version", newJString(Version))
  result = call_604774.call(nil, query_604775, nil, nil, nil)

var getDescribeHsmConfigurations* = Call_GetDescribeHsmConfigurations_604756(
    name: "getDescribeHsmConfigurations", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeHsmConfigurations",
    validator: validate_GetDescribeHsmConfigurations_604757, base: "/",
    url: url_GetDescribeHsmConfigurations_604758,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeLoggingStatus_604813 = ref object of OpenApiRestCall_602450
proc url_PostDescribeLoggingStatus_604815(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostDescribeLoggingStatus_604814(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Describes whether information, such as queries and connection attempts, is being logged for the specified Amazon Redshift cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_604816 = query.getOrDefault("Action")
  valid_604816 = validateParameter(valid_604816, JString, required = true,
                                 default = newJString("DescribeLoggingStatus"))
  if valid_604816 != nil:
    section.add "Action", valid_604816
  var valid_604817 = query.getOrDefault("Version")
  valid_604817 = validateParameter(valid_604817, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_604817 != nil:
    section.add "Version", valid_604817
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_604818 = header.getOrDefault("X-Amz-Date")
  valid_604818 = validateParameter(valid_604818, JString, required = false,
                                 default = nil)
  if valid_604818 != nil:
    section.add "X-Amz-Date", valid_604818
  var valid_604819 = header.getOrDefault("X-Amz-Security-Token")
  valid_604819 = validateParameter(valid_604819, JString, required = false,
                                 default = nil)
  if valid_604819 != nil:
    section.add "X-Amz-Security-Token", valid_604819
  var valid_604820 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604820 = validateParameter(valid_604820, JString, required = false,
                                 default = nil)
  if valid_604820 != nil:
    section.add "X-Amz-Content-Sha256", valid_604820
  var valid_604821 = header.getOrDefault("X-Amz-Algorithm")
  valid_604821 = validateParameter(valid_604821, JString, required = false,
                                 default = nil)
  if valid_604821 != nil:
    section.add "X-Amz-Algorithm", valid_604821
  var valid_604822 = header.getOrDefault("X-Amz-Signature")
  valid_604822 = validateParameter(valid_604822, JString, required = false,
                                 default = nil)
  if valid_604822 != nil:
    section.add "X-Amz-Signature", valid_604822
  var valid_604823 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604823 = validateParameter(valid_604823, JString, required = false,
                                 default = nil)
  if valid_604823 != nil:
    section.add "X-Amz-SignedHeaders", valid_604823
  var valid_604824 = header.getOrDefault("X-Amz-Credential")
  valid_604824 = validateParameter(valid_604824, JString, required = false,
                                 default = nil)
  if valid_604824 != nil:
    section.add "X-Amz-Credential", valid_604824
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The identifier of the cluster from which to get the logging status.</p> <p>Example: <code>examplecluster</code> </p>
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_604825 = formData.getOrDefault("ClusterIdentifier")
  valid_604825 = validateParameter(valid_604825, JString, required = true,
                                 default = nil)
  if valid_604825 != nil:
    section.add "ClusterIdentifier", valid_604825
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604826: Call_PostDescribeLoggingStatus_604813; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Describes whether information, such as queries and connection attempts, is being logged for the specified Amazon Redshift cluster.
  ## 
  let valid = call_604826.validator(path, query, header, formData, body)
  let scheme = call_604826.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604826.url(scheme.get, call_604826.host, call_604826.base,
                         call_604826.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_604826, url, valid)

proc call*(call_604827: Call_PostDescribeLoggingStatus_604813;
          ClusterIdentifier: string; Action: string = "DescribeLoggingStatus";
          Version: string = "2012-12-01"): Recallable =
  ## postDescribeLoggingStatus
  ## Describes whether information, such as queries and connection attempts, is being logged for the specified Amazon Redshift cluster.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The identifier of the cluster from which to get the logging status.</p> <p>Example: <code>examplecluster</code> </p>
  ##   Version: string (required)
  var query_604828 = newJObject()
  var formData_604829 = newJObject()
  add(query_604828, "Action", newJString(Action))
  add(formData_604829, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_604828, "Version", newJString(Version))
  result = call_604827.call(nil, query_604828, nil, formData_604829, nil)

var postDescribeLoggingStatus* = Call_PostDescribeLoggingStatus_604813(
    name: "postDescribeLoggingStatus", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeLoggingStatus",
    validator: validate_PostDescribeLoggingStatus_604814, base: "/",
    url: url_PostDescribeLoggingStatus_604815,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeLoggingStatus_604797 = ref object of OpenApiRestCall_602450
proc url_GetDescribeLoggingStatus_604799(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetDescribeLoggingStatus_604798(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Describes whether information, such as queries and connection attempts, is being logged for the specified Amazon Redshift cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The identifier of the cluster from which to get the logging status.</p> <p>Example: <code>examplecluster</code> </p>
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_604800 = query.getOrDefault("Action")
  valid_604800 = validateParameter(valid_604800, JString, required = true,
                                 default = newJString("DescribeLoggingStatus"))
  if valid_604800 != nil:
    section.add "Action", valid_604800
  var valid_604801 = query.getOrDefault("ClusterIdentifier")
  valid_604801 = validateParameter(valid_604801, JString, required = true,
                                 default = nil)
  if valid_604801 != nil:
    section.add "ClusterIdentifier", valid_604801
  var valid_604802 = query.getOrDefault("Version")
  valid_604802 = validateParameter(valid_604802, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_604802 != nil:
    section.add "Version", valid_604802
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_604803 = header.getOrDefault("X-Amz-Date")
  valid_604803 = validateParameter(valid_604803, JString, required = false,
                                 default = nil)
  if valid_604803 != nil:
    section.add "X-Amz-Date", valid_604803
  var valid_604804 = header.getOrDefault("X-Amz-Security-Token")
  valid_604804 = validateParameter(valid_604804, JString, required = false,
                                 default = nil)
  if valid_604804 != nil:
    section.add "X-Amz-Security-Token", valid_604804
  var valid_604805 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604805 = validateParameter(valid_604805, JString, required = false,
                                 default = nil)
  if valid_604805 != nil:
    section.add "X-Amz-Content-Sha256", valid_604805
  var valid_604806 = header.getOrDefault("X-Amz-Algorithm")
  valid_604806 = validateParameter(valid_604806, JString, required = false,
                                 default = nil)
  if valid_604806 != nil:
    section.add "X-Amz-Algorithm", valid_604806
  var valid_604807 = header.getOrDefault("X-Amz-Signature")
  valid_604807 = validateParameter(valid_604807, JString, required = false,
                                 default = nil)
  if valid_604807 != nil:
    section.add "X-Amz-Signature", valid_604807
  var valid_604808 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604808 = validateParameter(valid_604808, JString, required = false,
                                 default = nil)
  if valid_604808 != nil:
    section.add "X-Amz-SignedHeaders", valid_604808
  var valid_604809 = header.getOrDefault("X-Amz-Credential")
  valid_604809 = validateParameter(valid_604809, JString, required = false,
                                 default = nil)
  if valid_604809 != nil:
    section.add "X-Amz-Credential", valid_604809
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604810: Call_GetDescribeLoggingStatus_604797; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Describes whether information, such as queries and connection attempts, is being logged for the specified Amazon Redshift cluster.
  ## 
  let valid = call_604810.validator(path, query, header, formData, body)
  let scheme = call_604810.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604810.url(scheme.get, call_604810.host, call_604810.base,
                         call_604810.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_604810, url, valid)

proc call*(call_604811: Call_GetDescribeLoggingStatus_604797;
          ClusterIdentifier: string; Action: string = "DescribeLoggingStatus";
          Version: string = "2012-12-01"): Recallable =
  ## getDescribeLoggingStatus
  ## Describes whether information, such as queries and connection attempts, is being logged for the specified Amazon Redshift cluster.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The identifier of the cluster from which to get the logging status.</p> <p>Example: <code>examplecluster</code> </p>
  ##   Version: string (required)
  var query_604812 = newJObject()
  add(query_604812, "Action", newJString(Action))
  add(query_604812, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_604812, "Version", newJString(Version))
  result = call_604811.call(nil, query_604812, nil, nil, nil)

var getDescribeLoggingStatus* = Call_GetDescribeLoggingStatus_604797(
    name: "getDescribeLoggingStatus", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeLoggingStatus",
    validator: validate_GetDescribeLoggingStatus_604798, base: "/",
    url: url_GetDescribeLoggingStatus_604799, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeNodeConfigurationOptions_604851 = ref object of OpenApiRestCall_602450
proc url_PostDescribeNodeConfigurationOptions_604853(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostDescribeNodeConfigurationOptions_604852(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns properties of possible node configurations such as node type, number of nodes, and disk usage for the specified action type.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_604854 = query.getOrDefault("Action")
  valid_604854 = validateParameter(valid_604854, JString, required = true, default = newJString(
      "DescribeNodeConfigurationOptions"))
  if valid_604854 != nil:
    section.add "Action", valid_604854
  var valid_604855 = query.getOrDefault("Version")
  valid_604855 = validateParameter(valid_604855, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_604855 != nil:
    section.add "Version", valid_604855
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_604856 = header.getOrDefault("X-Amz-Date")
  valid_604856 = validateParameter(valid_604856, JString, required = false,
                                 default = nil)
  if valid_604856 != nil:
    section.add "X-Amz-Date", valid_604856
  var valid_604857 = header.getOrDefault("X-Amz-Security-Token")
  valid_604857 = validateParameter(valid_604857, JString, required = false,
                                 default = nil)
  if valid_604857 != nil:
    section.add "X-Amz-Security-Token", valid_604857
  var valid_604858 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604858 = validateParameter(valid_604858, JString, required = false,
                                 default = nil)
  if valid_604858 != nil:
    section.add "X-Amz-Content-Sha256", valid_604858
  var valid_604859 = header.getOrDefault("X-Amz-Algorithm")
  valid_604859 = validateParameter(valid_604859, JString, required = false,
                                 default = nil)
  if valid_604859 != nil:
    section.add "X-Amz-Algorithm", valid_604859
  var valid_604860 = header.getOrDefault("X-Amz-Signature")
  valid_604860 = validateParameter(valid_604860, JString, required = false,
                                 default = nil)
  if valid_604860 != nil:
    section.add "X-Amz-Signature", valid_604860
  var valid_604861 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604861 = validateParameter(valid_604861, JString, required = false,
                                 default = nil)
  if valid_604861 != nil:
    section.add "X-Amz-SignedHeaders", valid_604861
  var valid_604862 = header.getOrDefault("X-Amz-Credential")
  valid_604862 = validateParameter(valid_604862, JString, required = false,
                                 default = nil)
  if valid_604862 != nil:
    section.add "X-Amz-Credential", valid_604862
  result.add "header", section
  ## parameters in `formData` object:
  ##   Filter: JArray
  ##         : A set of name, operator, and value items to filter the results.
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeNodeConfigurationOptions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   OwnerAccount: JString
  ##               : The AWS customer account used to create or copy the snapshot. Required if you are restoring a snapshot you do not own, optional if you own the snapshot.
  ##   ActionType: JString (required)
  ##             : The action type to evaluate for possible node configurations. Currently, it must be "restore-cluster".
  ##   SnapshotIdentifier: JString
  ##                     : The identifier of the snapshot to evaluate for possible node configurations.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>500</code> </p> <p>Constraints: minimum 100, maximum 500.</p>
  section = newJObject()
  var valid_604863 = formData.getOrDefault("Filter")
  valid_604863 = validateParameter(valid_604863, JArray, required = false,
                                 default = nil)
  if valid_604863 != nil:
    section.add "Filter", valid_604863
  var valid_604864 = formData.getOrDefault("Marker")
  valid_604864 = validateParameter(valid_604864, JString, required = false,
                                 default = nil)
  if valid_604864 != nil:
    section.add "Marker", valid_604864
  var valid_604865 = formData.getOrDefault("OwnerAccount")
  valid_604865 = validateParameter(valid_604865, JString, required = false,
                                 default = nil)
  if valid_604865 != nil:
    section.add "OwnerAccount", valid_604865
  assert formData != nil,
        "formData argument is necessary due to required `ActionType` field"
  var valid_604866 = formData.getOrDefault("ActionType")
  valid_604866 = validateParameter(valid_604866, JString, required = true,
                                 default = newJString("restore-cluster"))
  if valid_604866 != nil:
    section.add "ActionType", valid_604866
  var valid_604867 = formData.getOrDefault("SnapshotIdentifier")
  valid_604867 = validateParameter(valid_604867, JString, required = false,
                                 default = nil)
  if valid_604867 != nil:
    section.add "SnapshotIdentifier", valid_604867
  var valid_604868 = formData.getOrDefault("MaxRecords")
  valid_604868 = validateParameter(valid_604868, JInt, required = false, default = nil)
  if valid_604868 != nil:
    section.add "MaxRecords", valid_604868
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604869: Call_PostDescribeNodeConfigurationOptions_604851;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Returns properties of possible node configurations such as node type, number of nodes, and disk usage for the specified action type.
  ## 
  let valid = call_604869.validator(path, query, header, formData, body)
  let scheme = call_604869.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604869.url(scheme.get, call_604869.host, call_604869.base,
                         call_604869.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_604869, url, valid)

proc call*(call_604870: Call_PostDescribeNodeConfigurationOptions_604851;
          Filter: JsonNode = nil; Marker: string = "";
          Action: string = "DescribeNodeConfigurationOptions";
          OwnerAccount: string = ""; ActionType: string = "restore-cluster";
          SnapshotIdentifier: string = ""; MaxRecords: int = 0;
          Version: string = "2012-12-01"): Recallable =
  ## postDescribeNodeConfigurationOptions
  ## Returns properties of possible node configurations such as node type, number of nodes, and disk usage for the specified action type.
  ##   Filter: JArray
  ##         : A set of name, operator, and value items to filter the results.
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeNodeConfigurationOptions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Action: string (required)
  ##   OwnerAccount: string
  ##               : The AWS customer account used to create or copy the snapshot. Required if you are restoring a snapshot you do not own, optional if you own the snapshot.
  ##   ActionType: string (required)
  ##             : The action type to evaluate for possible node configurations. Currently, it must be "restore-cluster".
  ##   SnapshotIdentifier: string
  ##                     : The identifier of the snapshot to evaluate for possible node configurations.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>500</code> </p> <p>Constraints: minimum 100, maximum 500.</p>
  ##   Version: string (required)
  var query_604871 = newJObject()
  var formData_604872 = newJObject()
  if Filter != nil:
    formData_604872.add "Filter", Filter
  add(formData_604872, "Marker", newJString(Marker))
  add(query_604871, "Action", newJString(Action))
  add(formData_604872, "OwnerAccount", newJString(OwnerAccount))
  add(formData_604872, "ActionType", newJString(ActionType))
  add(formData_604872, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(formData_604872, "MaxRecords", newJInt(MaxRecords))
  add(query_604871, "Version", newJString(Version))
  result = call_604870.call(nil, query_604871, nil, formData_604872, nil)

var postDescribeNodeConfigurationOptions* = Call_PostDescribeNodeConfigurationOptions_604851(
    name: "postDescribeNodeConfigurationOptions", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeNodeConfigurationOptions",
    validator: validate_PostDescribeNodeConfigurationOptions_604852, base: "/",
    url: url_PostDescribeNodeConfigurationOptions_604853,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeNodeConfigurationOptions_604830 = ref object of OpenApiRestCall_602450
proc url_GetDescribeNodeConfigurationOptions_604832(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetDescribeNodeConfigurationOptions_604831(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns properties of possible node configurations such as node type, number of nodes, and disk usage for the specified action type.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>500</code> </p> <p>Constraints: minimum 100, maximum 500.</p>
  ##   Filter: JArray
  ##         : A set of name, operator, and value items to filter the results.
  ##   ActionType: JString (required)
  ##             : The action type to evaluate for possible node configurations. Currently, it must be "restore-cluster".
  ##   Action: JString (required)
  ##   OwnerAccount: JString
  ##               : The AWS customer account used to create or copy the snapshot. Required if you are restoring a snapshot you do not own, optional if you own the snapshot.
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeNodeConfigurationOptions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   SnapshotIdentifier: JString
  ##                     : The identifier of the snapshot to evaluate for possible node configurations.
  ##   Version: JString (required)
  section = newJObject()
  var valid_604833 = query.getOrDefault("MaxRecords")
  valid_604833 = validateParameter(valid_604833, JInt, required = false, default = nil)
  if valid_604833 != nil:
    section.add "MaxRecords", valid_604833
  var valid_604834 = query.getOrDefault("Filter")
  valid_604834 = validateParameter(valid_604834, JArray, required = false,
                                 default = nil)
  if valid_604834 != nil:
    section.add "Filter", valid_604834
  assert query != nil,
        "query argument is necessary due to required `ActionType` field"
  var valid_604835 = query.getOrDefault("ActionType")
  valid_604835 = validateParameter(valid_604835, JString, required = true,
                                 default = newJString("restore-cluster"))
  if valid_604835 != nil:
    section.add "ActionType", valid_604835
  var valid_604836 = query.getOrDefault("Action")
  valid_604836 = validateParameter(valid_604836, JString, required = true, default = newJString(
      "DescribeNodeConfigurationOptions"))
  if valid_604836 != nil:
    section.add "Action", valid_604836
  var valid_604837 = query.getOrDefault("OwnerAccount")
  valid_604837 = validateParameter(valid_604837, JString, required = false,
                                 default = nil)
  if valid_604837 != nil:
    section.add "OwnerAccount", valid_604837
  var valid_604838 = query.getOrDefault("Marker")
  valid_604838 = validateParameter(valid_604838, JString, required = false,
                                 default = nil)
  if valid_604838 != nil:
    section.add "Marker", valid_604838
  var valid_604839 = query.getOrDefault("SnapshotIdentifier")
  valid_604839 = validateParameter(valid_604839, JString, required = false,
                                 default = nil)
  if valid_604839 != nil:
    section.add "SnapshotIdentifier", valid_604839
  var valid_604840 = query.getOrDefault("Version")
  valid_604840 = validateParameter(valid_604840, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_604840 != nil:
    section.add "Version", valid_604840
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_604841 = header.getOrDefault("X-Amz-Date")
  valid_604841 = validateParameter(valid_604841, JString, required = false,
                                 default = nil)
  if valid_604841 != nil:
    section.add "X-Amz-Date", valid_604841
  var valid_604842 = header.getOrDefault("X-Amz-Security-Token")
  valid_604842 = validateParameter(valid_604842, JString, required = false,
                                 default = nil)
  if valid_604842 != nil:
    section.add "X-Amz-Security-Token", valid_604842
  var valid_604843 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604843 = validateParameter(valid_604843, JString, required = false,
                                 default = nil)
  if valid_604843 != nil:
    section.add "X-Amz-Content-Sha256", valid_604843
  var valid_604844 = header.getOrDefault("X-Amz-Algorithm")
  valid_604844 = validateParameter(valid_604844, JString, required = false,
                                 default = nil)
  if valid_604844 != nil:
    section.add "X-Amz-Algorithm", valid_604844
  var valid_604845 = header.getOrDefault("X-Amz-Signature")
  valid_604845 = validateParameter(valid_604845, JString, required = false,
                                 default = nil)
  if valid_604845 != nil:
    section.add "X-Amz-Signature", valid_604845
  var valid_604846 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604846 = validateParameter(valid_604846, JString, required = false,
                                 default = nil)
  if valid_604846 != nil:
    section.add "X-Amz-SignedHeaders", valid_604846
  var valid_604847 = header.getOrDefault("X-Amz-Credential")
  valid_604847 = validateParameter(valid_604847, JString, required = false,
                                 default = nil)
  if valid_604847 != nil:
    section.add "X-Amz-Credential", valid_604847
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604848: Call_GetDescribeNodeConfigurationOptions_604830;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Returns properties of possible node configurations such as node type, number of nodes, and disk usage for the specified action type.
  ## 
  let valid = call_604848.validator(path, query, header, formData, body)
  let scheme = call_604848.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604848.url(scheme.get, call_604848.host, call_604848.base,
                         call_604848.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_604848, url, valid)

proc call*(call_604849: Call_GetDescribeNodeConfigurationOptions_604830;
          MaxRecords: int = 0; Filter: JsonNode = nil;
          ActionType: string = "restore-cluster";
          Action: string = "DescribeNodeConfigurationOptions";
          OwnerAccount: string = ""; Marker: string = "";
          SnapshotIdentifier: string = ""; Version: string = "2012-12-01"): Recallable =
  ## getDescribeNodeConfigurationOptions
  ## Returns properties of possible node configurations such as node type, number of nodes, and disk usage for the specified action type.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>500</code> </p> <p>Constraints: minimum 100, maximum 500.</p>
  ##   Filter: JArray
  ##         : A set of name, operator, and value items to filter the results.
  ##   ActionType: string (required)
  ##             : The action type to evaluate for possible node configurations. Currently, it must be "restore-cluster".
  ##   Action: string (required)
  ##   OwnerAccount: string
  ##               : The AWS customer account used to create or copy the snapshot. Required if you are restoring a snapshot you do not own, optional if you own the snapshot.
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeNodeConfigurationOptions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   SnapshotIdentifier: string
  ##                     : The identifier of the snapshot to evaluate for possible node configurations.
  ##   Version: string (required)
  var query_604850 = newJObject()
  add(query_604850, "MaxRecords", newJInt(MaxRecords))
  if Filter != nil:
    query_604850.add "Filter", Filter
  add(query_604850, "ActionType", newJString(ActionType))
  add(query_604850, "Action", newJString(Action))
  add(query_604850, "OwnerAccount", newJString(OwnerAccount))
  add(query_604850, "Marker", newJString(Marker))
  add(query_604850, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_604850, "Version", newJString(Version))
  result = call_604849.call(nil, query_604850, nil, nil, nil)

var getDescribeNodeConfigurationOptions* = Call_GetDescribeNodeConfigurationOptions_604830(
    name: "getDescribeNodeConfigurationOptions", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeNodeConfigurationOptions",
    validator: validate_GetDescribeNodeConfigurationOptions_604831, base: "/",
    url: url_GetDescribeNodeConfigurationOptions_604832,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeOrderableClusterOptions_604892 = ref object of OpenApiRestCall_602450
proc url_PostDescribeOrderableClusterOptions_604894(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostDescribeOrderableClusterOptions_604893(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns a list of orderable cluster options. Before you create a new cluster you can use this operation to find what options are available, such as the EC2 Availability Zones (AZ) in the specific AWS Region that you can specify, and the node types you can request. The node types differ by available storage, memory, CPU and price. With the cost involved you might want to obtain a list of cluster options in the specific region and specify values when creating a cluster. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_604895 = query.getOrDefault("Action")
  valid_604895 = validateParameter(valid_604895, JString, required = true, default = newJString(
      "DescribeOrderableClusterOptions"))
  if valid_604895 != nil:
    section.add "Action", valid_604895
  var valid_604896 = query.getOrDefault("Version")
  valid_604896 = validateParameter(valid_604896, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_604896 != nil:
    section.add "Version", valid_604896
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_604897 = header.getOrDefault("X-Amz-Date")
  valid_604897 = validateParameter(valid_604897, JString, required = false,
                                 default = nil)
  if valid_604897 != nil:
    section.add "X-Amz-Date", valid_604897
  var valid_604898 = header.getOrDefault("X-Amz-Security-Token")
  valid_604898 = validateParameter(valid_604898, JString, required = false,
                                 default = nil)
  if valid_604898 != nil:
    section.add "X-Amz-Security-Token", valid_604898
  var valid_604899 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604899 = validateParameter(valid_604899, JString, required = false,
                                 default = nil)
  if valid_604899 != nil:
    section.add "X-Amz-Content-Sha256", valid_604899
  var valid_604900 = header.getOrDefault("X-Amz-Algorithm")
  valid_604900 = validateParameter(valid_604900, JString, required = false,
                                 default = nil)
  if valid_604900 != nil:
    section.add "X-Amz-Algorithm", valid_604900
  var valid_604901 = header.getOrDefault("X-Amz-Signature")
  valid_604901 = validateParameter(valid_604901, JString, required = false,
                                 default = nil)
  if valid_604901 != nil:
    section.add "X-Amz-Signature", valid_604901
  var valid_604902 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604902 = validateParameter(valid_604902, JString, required = false,
                                 default = nil)
  if valid_604902 != nil:
    section.add "X-Amz-SignedHeaders", valid_604902
  var valid_604903 = header.getOrDefault("X-Amz-Credential")
  valid_604903 = validateParameter(valid_604903, JString, required = false,
                                 default = nil)
  if valid_604903 != nil:
    section.add "X-Amz-Credential", valid_604903
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterVersion: JString
  ##                 : <p>The version filter value. Specify this parameter to show only the available offerings matching the specified version.</p> <p>Default: All versions.</p> <p>Constraints: Must be one of the version returned from <a>DescribeClusterVersions</a>.</p>
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeOrderableClusterOptions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   NodeType: JString
  ##           : The node type filter value. Specify this parameter to show only the available offerings matching the specified node type.
  section = newJObject()
  var valid_604904 = formData.getOrDefault("ClusterVersion")
  valid_604904 = validateParameter(valid_604904, JString, required = false,
                                 default = nil)
  if valid_604904 != nil:
    section.add "ClusterVersion", valid_604904
  var valid_604905 = formData.getOrDefault("Marker")
  valid_604905 = validateParameter(valid_604905, JString, required = false,
                                 default = nil)
  if valid_604905 != nil:
    section.add "Marker", valid_604905
  var valid_604906 = formData.getOrDefault("MaxRecords")
  valid_604906 = validateParameter(valid_604906, JInt, required = false, default = nil)
  if valid_604906 != nil:
    section.add "MaxRecords", valid_604906
  var valid_604907 = formData.getOrDefault("NodeType")
  valid_604907 = validateParameter(valid_604907, JString, required = false,
                                 default = nil)
  if valid_604907 != nil:
    section.add "NodeType", valid_604907
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604908: Call_PostDescribeOrderableClusterOptions_604892;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Returns a list of orderable cluster options. Before you create a new cluster you can use this operation to find what options are available, such as the EC2 Availability Zones (AZ) in the specific AWS Region that you can specify, and the node types you can request. The node types differ by available storage, memory, CPU and price. With the cost involved you might want to obtain a list of cluster options in the specific region and specify values when creating a cluster. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.
  ## 
  let valid = call_604908.validator(path, query, header, formData, body)
  let scheme = call_604908.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604908.url(scheme.get, call_604908.host, call_604908.base,
                         call_604908.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_604908, url, valid)

proc call*(call_604909: Call_PostDescribeOrderableClusterOptions_604892;
          ClusterVersion: string = ""; Marker: string = "";
          Action: string = "DescribeOrderableClusterOptions"; MaxRecords: int = 0;
          Version: string = "2012-12-01"; NodeType: string = ""): Recallable =
  ## postDescribeOrderableClusterOptions
  ## Returns a list of orderable cluster options. Before you create a new cluster you can use this operation to find what options are available, such as the EC2 Availability Zones (AZ) in the specific AWS Region that you can specify, and the node types you can request. The node types differ by available storage, memory, CPU and price. With the cost involved you might want to obtain a list of cluster options in the specific region and specify values when creating a cluster. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.
  ##   ClusterVersion: string
  ##                 : <p>The version filter value. Specify this parameter to show only the available offerings matching the specified version.</p> <p>Default: All versions.</p> <p>Constraints: Must be one of the version returned from <a>DescribeClusterVersions</a>.</p>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeOrderableClusterOptions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Action: string (required)
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Version: string (required)
  ##   NodeType: string
  ##           : The node type filter value. Specify this parameter to show only the available offerings matching the specified node type.
  var query_604910 = newJObject()
  var formData_604911 = newJObject()
  add(formData_604911, "ClusterVersion", newJString(ClusterVersion))
  add(formData_604911, "Marker", newJString(Marker))
  add(query_604910, "Action", newJString(Action))
  add(formData_604911, "MaxRecords", newJInt(MaxRecords))
  add(query_604910, "Version", newJString(Version))
  add(formData_604911, "NodeType", newJString(NodeType))
  result = call_604909.call(nil, query_604910, nil, formData_604911, nil)

var postDescribeOrderableClusterOptions* = Call_PostDescribeOrderableClusterOptions_604892(
    name: "postDescribeOrderableClusterOptions", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeOrderableClusterOptions",
    validator: validate_PostDescribeOrderableClusterOptions_604893, base: "/",
    url: url_PostDescribeOrderableClusterOptions_604894,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeOrderableClusterOptions_604873 = ref object of OpenApiRestCall_602450
proc url_GetDescribeOrderableClusterOptions_604875(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetDescribeOrderableClusterOptions_604874(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns a list of orderable cluster options. Before you create a new cluster you can use this operation to find what options are available, such as the EC2 Availability Zones (AZ) in the specific AWS Region that you can specify, and the node types you can request. The node types differ by available storage, memory, CPU and price. With the cost involved you might want to obtain a list of cluster options in the specific region and specify values when creating a cluster. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Action: JString (required)
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeOrderableClusterOptions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   NodeType: JString
  ##           : The node type filter value. Specify this parameter to show only the available offerings matching the specified node type.
  ##   ClusterVersion: JString
  ##                 : <p>The version filter value. Specify this parameter to show only the available offerings matching the specified version.</p> <p>Default: All versions.</p> <p>Constraints: Must be one of the version returned from <a>DescribeClusterVersions</a>.</p>
  ##   Version: JString (required)
  section = newJObject()
  var valid_604876 = query.getOrDefault("MaxRecords")
  valid_604876 = validateParameter(valid_604876, JInt, required = false, default = nil)
  if valid_604876 != nil:
    section.add "MaxRecords", valid_604876
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_604877 = query.getOrDefault("Action")
  valid_604877 = validateParameter(valid_604877, JString, required = true, default = newJString(
      "DescribeOrderableClusterOptions"))
  if valid_604877 != nil:
    section.add "Action", valid_604877
  var valid_604878 = query.getOrDefault("Marker")
  valid_604878 = validateParameter(valid_604878, JString, required = false,
                                 default = nil)
  if valid_604878 != nil:
    section.add "Marker", valid_604878
  var valid_604879 = query.getOrDefault("NodeType")
  valid_604879 = validateParameter(valid_604879, JString, required = false,
                                 default = nil)
  if valid_604879 != nil:
    section.add "NodeType", valid_604879
  var valid_604880 = query.getOrDefault("ClusterVersion")
  valid_604880 = validateParameter(valid_604880, JString, required = false,
                                 default = nil)
  if valid_604880 != nil:
    section.add "ClusterVersion", valid_604880
  var valid_604881 = query.getOrDefault("Version")
  valid_604881 = validateParameter(valid_604881, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_604881 != nil:
    section.add "Version", valid_604881
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_604882 = header.getOrDefault("X-Amz-Date")
  valid_604882 = validateParameter(valid_604882, JString, required = false,
                                 default = nil)
  if valid_604882 != nil:
    section.add "X-Amz-Date", valid_604882
  var valid_604883 = header.getOrDefault("X-Amz-Security-Token")
  valid_604883 = validateParameter(valid_604883, JString, required = false,
                                 default = nil)
  if valid_604883 != nil:
    section.add "X-Amz-Security-Token", valid_604883
  var valid_604884 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604884 = validateParameter(valid_604884, JString, required = false,
                                 default = nil)
  if valid_604884 != nil:
    section.add "X-Amz-Content-Sha256", valid_604884
  var valid_604885 = header.getOrDefault("X-Amz-Algorithm")
  valid_604885 = validateParameter(valid_604885, JString, required = false,
                                 default = nil)
  if valid_604885 != nil:
    section.add "X-Amz-Algorithm", valid_604885
  var valid_604886 = header.getOrDefault("X-Amz-Signature")
  valid_604886 = validateParameter(valid_604886, JString, required = false,
                                 default = nil)
  if valid_604886 != nil:
    section.add "X-Amz-Signature", valid_604886
  var valid_604887 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604887 = validateParameter(valid_604887, JString, required = false,
                                 default = nil)
  if valid_604887 != nil:
    section.add "X-Amz-SignedHeaders", valid_604887
  var valid_604888 = header.getOrDefault("X-Amz-Credential")
  valid_604888 = validateParameter(valid_604888, JString, required = false,
                                 default = nil)
  if valid_604888 != nil:
    section.add "X-Amz-Credential", valid_604888
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604889: Call_GetDescribeOrderableClusterOptions_604873;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Returns a list of orderable cluster options. Before you create a new cluster you can use this operation to find what options are available, such as the EC2 Availability Zones (AZ) in the specific AWS Region that you can specify, and the node types you can request. The node types differ by available storage, memory, CPU and price. With the cost involved you might want to obtain a list of cluster options in the specific region and specify values when creating a cluster. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.
  ## 
  let valid = call_604889.validator(path, query, header, formData, body)
  let scheme = call_604889.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604889.url(scheme.get, call_604889.host, call_604889.base,
                         call_604889.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_604889, url, valid)

proc call*(call_604890: Call_GetDescribeOrderableClusterOptions_604873;
          MaxRecords: int = 0; Action: string = "DescribeOrderableClusterOptions";
          Marker: string = ""; NodeType: string = ""; ClusterVersion: string = "";
          Version: string = "2012-12-01"): Recallable =
  ## getDescribeOrderableClusterOptions
  ## Returns a list of orderable cluster options. Before you create a new cluster you can use this operation to find what options are available, such as the EC2 Availability Zones (AZ) in the specific AWS Region that you can specify, and the node types you can request. The node types differ by available storage, memory, CPU and price. With the cost involved you might want to obtain a list of cluster options in the specific region and specify values when creating a cluster. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Action: string (required)
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeOrderableClusterOptions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   NodeType: string
  ##           : The node type filter value. Specify this parameter to show only the available offerings matching the specified node type.
  ##   ClusterVersion: string
  ##                 : <p>The version filter value. Specify this parameter to show only the available offerings matching the specified version.</p> <p>Default: All versions.</p> <p>Constraints: Must be one of the version returned from <a>DescribeClusterVersions</a>.</p>
  ##   Version: string (required)
  var query_604891 = newJObject()
  add(query_604891, "MaxRecords", newJInt(MaxRecords))
  add(query_604891, "Action", newJString(Action))
  add(query_604891, "Marker", newJString(Marker))
  add(query_604891, "NodeType", newJString(NodeType))
  add(query_604891, "ClusterVersion", newJString(ClusterVersion))
  add(query_604891, "Version", newJString(Version))
  result = call_604890.call(nil, query_604891, nil, nil, nil)

var getDescribeOrderableClusterOptions* = Call_GetDescribeOrderableClusterOptions_604873(
    name: "getDescribeOrderableClusterOptions", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeOrderableClusterOptions",
    validator: validate_GetDescribeOrderableClusterOptions_604874, base: "/",
    url: url_GetDescribeOrderableClusterOptions_604875,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeReservedNodeOfferings_604930 = ref object of OpenApiRestCall_602450
proc url_PostDescribeReservedNodeOfferings_604932(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostDescribeReservedNodeOfferings_604931(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns a list of the available reserved node offerings by Amazon Redshift with their descriptions including the node type, the fixed and recurring costs of reserving the node and duration the node will be reserved for you. These descriptions help you determine which reserve node offering you want to purchase. You then use the unique offering ID in you call to <a>PurchaseReservedNodeOffering</a> to reserve one or more nodes for your Amazon Redshift cluster. </p> <p> For more information about reserved node offerings, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_604933 = query.getOrDefault("Action")
  valid_604933 = validateParameter(valid_604933, JString, required = true, default = newJString(
      "DescribeReservedNodeOfferings"))
  if valid_604933 != nil:
    section.add "Action", valid_604933
  var valid_604934 = query.getOrDefault("Version")
  valid_604934 = validateParameter(valid_604934, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_604934 != nil:
    section.add "Version", valid_604934
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_604935 = header.getOrDefault("X-Amz-Date")
  valid_604935 = validateParameter(valid_604935, JString, required = false,
                                 default = nil)
  if valid_604935 != nil:
    section.add "X-Amz-Date", valid_604935
  var valid_604936 = header.getOrDefault("X-Amz-Security-Token")
  valid_604936 = validateParameter(valid_604936, JString, required = false,
                                 default = nil)
  if valid_604936 != nil:
    section.add "X-Amz-Security-Token", valid_604936
  var valid_604937 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604937 = validateParameter(valid_604937, JString, required = false,
                                 default = nil)
  if valid_604937 != nil:
    section.add "X-Amz-Content-Sha256", valid_604937
  var valid_604938 = header.getOrDefault("X-Amz-Algorithm")
  valid_604938 = validateParameter(valid_604938, JString, required = false,
                                 default = nil)
  if valid_604938 != nil:
    section.add "X-Amz-Algorithm", valid_604938
  var valid_604939 = header.getOrDefault("X-Amz-Signature")
  valid_604939 = validateParameter(valid_604939, JString, required = false,
                                 default = nil)
  if valid_604939 != nil:
    section.add "X-Amz-Signature", valid_604939
  var valid_604940 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604940 = validateParameter(valid_604940, JString, required = false,
                                 default = nil)
  if valid_604940 != nil:
    section.add "X-Amz-SignedHeaders", valid_604940
  var valid_604941 = header.getOrDefault("X-Amz-Credential")
  valid_604941 = validateParameter(valid_604941, JString, required = false,
                                 default = nil)
  if valid_604941 != nil:
    section.add "X-Amz-Credential", valid_604941
  result.add "header", section
  ## parameters in `formData` object:
  ##   ReservedNodeOfferingId: JString
  ##                         : The unique identifier for the offering.
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeReservedNodeOfferings</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  section = newJObject()
  var valid_604942 = formData.getOrDefault("ReservedNodeOfferingId")
  valid_604942 = validateParameter(valid_604942, JString, required = false,
                                 default = nil)
  if valid_604942 != nil:
    section.add "ReservedNodeOfferingId", valid_604942
  var valid_604943 = formData.getOrDefault("Marker")
  valid_604943 = validateParameter(valid_604943, JString, required = false,
                                 default = nil)
  if valid_604943 != nil:
    section.add "Marker", valid_604943
  var valid_604944 = formData.getOrDefault("MaxRecords")
  valid_604944 = validateParameter(valid_604944, JInt, required = false, default = nil)
  if valid_604944 != nil:
    section.add "MaxRecords", valid_604944
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604945: Call_PostDescribeReservedNodeOfferings_604930;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Returns a list of the available reserved node offerings by Amazon Redshift with their descriptions including the node type, the fixed and recurring costs of reserving the node and duration the node will be reserved for you. These descriptions help you determine which reserve node offering you want to purchase. You then use the unique offering ID in you call to <a>PurchaseReservedNodeOffering</a> to reserve one or more nodes for your Amazon Redshift cluster. </p> <p> For more information about reserved node offerings, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_604945.validator(path, query, header, formData, body)
  let scheme = call_604945.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604945.url(scheme.get, call_604945.host, call_604945.base,
                         call_604945.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_604945, url, valid)

proc call*(call_604946: Call_PostDescribeReservedNodeOfferings_604930;
          ReservedNodeOfferingId: string = ""; Marker: string = "";
          Action: string = "DescribeReservedNodeOfferings"; MaxRecords: int = 0;
          Version: string = "2012-12-01"): Recallable =
  ## postDescribeReservedNodeOfferings
  ## <p>Returns a list of the available reserved node offerings by Amazon Redshift with their descriptions including the node type, the fixed and recurring costs of reserving the node and duration the node will be reserved for you. These descriptions help you determine which reserve node offering you want to purchase. You then use the unique offering ID in you call to <a>PurchaseReservedNodeOffering</a> to reserve one or more nodes for your Amazon Redshift cluster. </p> <p> For more information about reserved node offerings, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   ReservedNodeOfferingId: string
  ##                         : The unique identifier for the offering.
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeReservedNodeOfferings</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Action: string (required)
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Version: string (required)
  var query_604947 = newJObject()
  var formData_604948 = newJObject()
  add(formData_604948, "ReservedNodeOfferingId",
      newJString(ReservedNodeOfferingId))
  add(formData_604948, "Marker", newJString(Marker))
  add(query_604947, "Action", newJString(Action))
  add(formData_604948, "MaxRecords", newJInt(MaxRecords))
  add(query_604947, "Version", newJString(Version))
  result = call_604946.call(nil, query_604947, nil, formData_604948, nil)

var postDescribeReservedNodeOfferings* = Call_PostDescribeReservedNodeOfferings_604930(
    name: "postDescribeReservedNodeOfferings", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeReservedNodeOfferings",
    validator: validate_PostDescribeReservedNodeOfferings_604931, base: "/",
    url: url_PostDescribeReservedNodeOfferings_604932,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeReservedNodeOfferings_604912 = ref object of OpenApiRestCall_602450
proc url_GetDescribeReservedNodeOfferings_604914(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetDescribeReservedNodeOfferings_604913(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns a list of the available reserved node offerings by Amazon Redshift with their descriptions including the node type, the fixed and recurring costs of reserving the node and duration the node will be reserved for you. These descriptions help you determine which reserve node offering you want to purchase. You then use the unique offering ID in you call to <a>PurchaseReservedNodeOffering</a> to reserve one or more nodes for your Amazon Redshift cluster. </p> <p> For more information about reserved node offerings, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   ReservedNodeOfferingId: JString
  ##                         : The unique identifier for the offering.
  ##   Action: JString (required)
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeReservedNodeOfferings</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Version: JString (required)
  section = newJObject()
  var valid_604915 = query.getOrDefault("MaxRecords")
  valid_604915 = validateParameter(valid_604915, JInt, required = false, default = nil)
  if valid_604915 != nil:
    section.add "MaxRecords", valid_604915
  var valid_604916 = query.getOrDefault("ReservedNodeOfferingId")
  valid_604916 = validateParameter(valid_604916, JString, required = false,
                                 default = nil)
  if valid_604916 != nil:
    section.add "ReservedNodeOfferingId", valid_604916
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_604917 = query.getOrDefault("Action")
  valid_604917 = validateParameter(valid_604917, JString, required = true, default = newJString(
      "DescribeReservedNodeOfferings"))
  if valid_604917 != nil:
    section.add "Action", valid_604917
  var valid_604918 = query.getOrDefault("Marker")
  valid_604918 = validateParameter(valid_604918, JString, required = false,
                                 default = nil)
  if valid_604918 != nil:
    section.add "Marker", valid_604918
  var valid_604919 = query.getOrDefault("Version")
  valid_604919 = validateParameter(valid_604919, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_604919 != nil:
    section.add "Version", valid_604919
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_604920 = header.getOrDefault("X-Amz-Date")
  valid_604920 = validateParameter(valid_604920, JString, required = false,
                                 default = nil)
  if valid_604920 != nil:
    section.add "X-Amz-Date", valid_604920
  var valid_604921 = header.getOrDefault("X-Amz-Security-Token")
  valid_604921 = validateParameter(valid_604921, JString, required = false,
                                 default = nil)
  if valid_604921 != nil:
    section.add "X-Amz-Security-Token", valid_604921
  var valid_604922 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604922 = validateParameter(valid_604922, JString, required = false,
                                 default = nil)
  if valid_604922 != nil:
    section.add "X-Amz-Content-Sha256", valid_604922
  var valid_604923 = header.getOrDefault("X-Amz-Algorithm")
  valid_604923 = validateParameter(valid_604923, JString, required = false,
                                 default = nil)
  if valid_604923 != nil:
    section.add "X-Amz-Algorithm", valid_604923
  var valid_604924 = header.getOrDefault("X-Amz-Signature")
  valid_604924 = validateParameter(valid_604924, JString, required = false,
                                 default = nil)
  if valid_604924 != nil:
    section.add "X-Amz-Signature", valid_604924
  var valid_604925 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604925 = validateParameter(valid_604925, JString, required = false,
                                 default = nil)
  if valid_604925 != nil:
    section.add "X-Amz-SignedHeaders", valid_604925
  var valid_604926 = header.getOrDefault("X-Amz-Credential")
  valid_604926 = validateParameter(valid_604926, JString, required = false,
                                 default = nil)
  if valid_604926 != nil:
    section.add "X-Amz-Credential", valid_604926
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604927: Call_GetDescribeReservedNodeOfferings_604912;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Returns a list of the available reserved node offerings by Amazon Redshift with their descriptions including the node type, the fixed and recurring costs of reserving the node and duration the node will be reserved for you. These descriptions help you determine which reserve node offering you want to purchase. You then use the unique offering ID in you call to <a>PurchaseReservedNodeOffering</a> to reserve one or more nodes for your Amazon Redshift cluster. </p> <p> For more information about reserved node offerings, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_604927.validator(path, query, header, formData, body)
  let scheme = call_604927.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604927.url(scheme.get, call_604927.host, call_604927.base,
                         call_604927.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_604927, url, valid)

proc call*(call_604928: Call_GetDescribeReservedNodeOfferings_604912;
          MaxRecords: int = 0; ReservedNodeOfferingId: string = "";
          Action: string = "DescribeReservedNodeOfferings"; Marker: string = "";
          Version: string = "2012-12-01"): Recallable =
  ## getDescribeReservedNodeOfferings
  ## <p>Returns a list of the available reserved node offerings by Amazon Redshift with their descriptions including the node type, the fixed and recurring costs of reserving the node and duration the node will be reserved for you. These descriptions help you determine which reserve node offering you want to purchase. You then use the unique offering ID in you call to <a>PurchaseReservedNodeOffering</a> to reserve one or more nodes for your Amazon Redshift cluster. </p> <p> For more information about reserved node offerings, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   ReservedNodeOfferingId: string
  ##                         : The unique identifier for the offering.
  ##   Action: string (required)
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeReservedNodeOfferings</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Version: string (required)
  var query_604929 = newJObject()
  add(query_604929, "MaxRecords", newJInt(MaxRecords))
  add(query_604929, "ReservedNodeOfferingId", newJString(ReservedNodeOfferingId))
  add(query_604929, "Action", newJString(Action))
  add(query_604929, "Marker", newJString(Marker))
  add(query_604929, "Version", newJString(Version))
  result = call_604928.call(nil, query_604929, nil, nil, nil)

var getDescribeReservedNodeOfferings* = Call_GetDescribeReservedNodeOfferings_604912(
    name: "getDescribeReservedNodeOfferings", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeReservedNodeOfferings",
    validator: validate_GetDescribeReservedNodeOfferings_604913, base: "/",
    url: url_GetDescribeReservedNodeOfferings_604914,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeReservedNodes_604967 = ref object of OpenApiRestCall_602450
proc url_PostDescribeReservedNodes_604969(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostDescribeReservedNodes_604968(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns the descriptions of the reserved nodes.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_604970 = query.getOrDefault("Action")
  valid_604970 = validateParameter(valid_604970, JString, required = true,
                                 default = newJString("DescribeReservedNodes"))
  if valid_604970 != nil:
    section.add "Action", valid_604970
  var valid_604971 = query.getOrDefault("Version")
  valid_604971 = validateParameter(valid_604971, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_604971 != nil:
    section.add "Version", valid_604971
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_604972 = header.getOrDefault("X-Amz-Date")
  valid_604972 = validateParameter(valid_604972, JString, required = false,
                                 default = nil)
  if valid_604972 != nil:
    section.add "X-Amz-Date", valid_604972
  var valid_604973 = header.getOrDefault("X-Amz-Security-Token")
  valid_604973 = validateParameter(valid_604973, JString, required = false,
                                 default = nil)
  if valid_604973 != nil:
    section.add "X-Amz-Security-Token", valid_604973
  var valid_604974 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604974 = validateParameter(valid_604974, JString, required = false,
                                 default = nil)
  if valid_604974 != nil:
    section.add "X-Amz-Content-Sha256", valid_604974
  var valid_604975 = header.getOrDefault("X-Amz-Algorithm")
  valid_604975 = validateParameter(valid_604975, JString, required = false,
                                 default = nil)
  if valid_604975 != nil:
    section.add "X-Amz-Algorithm", valid_604975
  var valid_604976 = header.getOrDefault("X-Amz-Signature")
  valid_604976 = validateParameter(valid_604976, JString, required = false,
                                 default = nil)
  if valid_604976 != nil:
    section.add "X-Amz-Signature", valid_604976
  var valid_604977 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604977 = validateParameter(valid_604977, JString, required = false,
                                 default = nil)
  if valid_604977 != nil:
    section.add "X-Amz-SignedHeaders", valid_604977
  var valid_604978 = header.getOrDefault("X-Amz-Credential")
  valid_604978 = validateParameter(valid_604978, JString, required = false,
                                 default = nil)
  if valid_604978 != nil:
    section.add "X-Amz-Credential", valid_604978
  result.add "header", section
  ## parameters in `formData` object:
  ##   ReservedNodeId: JString
  ##                 : Identifier for the node reservation.
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeReservedNodes</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  section = newJObject()
  var valid_604979 = formData.getOrDefault("ReservedNodeId")
  valid_604979 = validateParameter(valid_604979, JString, required = false,
                                 default = nil)
  if valid_604979 != nil:
    section.add "ReservedNodeId", valid_604979
  var valid_604980 = formData.getOrDefault("Marker")
  valid_604980 = validateParameter(valid_604980, JString, required = false,
                                 default = nil)
  if valid_604980 != nil:
    section.add "Marker", valid_604980
  var valid_604981 = formData.getOrDefault("MaxRecords")
  valid_604981 = validateParameter(valid_604981, JInt, required = false, default = nil)
  if valid_604981 != nil:
    section.add "MaxRecords", valid_604981
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604982: Call_PostDescribeReservedNodes_604967; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns the descriptions of the reserved nodes.
  ## 
  let valid = call_604982.validator(path, query, header, formData, body)
  let scheme = call_604982.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604982.url(scheme.get, call_604982.host, call_604982.base,
                         call_604982.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_604982, url, valid)

proc call*(call_604983: Call_PostDescribeReservedNodes_604967;
          ReservedNodeId: string = ""; Marker: string = "";
          Action: string = "DescribeReservedNodes"; MaxRecords: int = 0;
          Version: string = "2012-12-01"): Recallable =
  ## postDescribeReservedNodes
  ## Returns the descriptions of the reserved nodes.
  ##   ReservedNodeId: string
  ##                 : Identifier for the node reservation.
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeReservedNodes</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Action: string (required)
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Version: string (required)
  var query_604984 = newJObject()
  var formData_604985 = newJObject()
  add(formData_604985, "ReservedNodeId", newJString(ReservedNodeId))
  add(formData_604985, "Marker", newJString(Marker))
  add(query_604984, "Action", newJString(Action))
  add(formData_604985, "MaxRecords", newJInt(MaxRecords))
  add(query_604984, "Version", newJString(Version))
  result = call_604983.call(nil, query_604984, nil, formData_604985, nil)

var postDescribeReservedNodes* = Call_PostDescribeReservedNodes_604967(
    name: "postDescribeReservedNodes", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeReservedNodes",
    validator: validate_PostDescribeReservedNodes_604968, base: "/",
    url: url_PostDescribeReservedNodes_604969,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeReservedNodes_604949 = ref object of OpenApiRestCall_602450
proc url_GetDescribeReservedNodes_604951(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetDescribeReservedNodes_604950(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns the descriptions of the reserved nodes.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Action: JString (required)
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeReservedNodes</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Version: JString (required)
  ##   ReservedNodeId: JString
  ##                 : Identifier for the node reservation.
  section = newJObject()
  var valid_604952 = query.getOrDefault("MaxRecords")
  valid_604952 = validateParameter(valid_604952, JInt, required = false, default = nil)
  if valid_604952 != nil:
    section.add "MaxRecords", valid_604952
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_604953 = query.getOrDefault("Action")
  valid_604953 = validateParameter(valid_604953, JString, required = true,
                                 default = newJString("DescribeReservedNodes"))
  if valid_604953 != nil:
    section.add "Action", valid_604953
  var valid_604954 = query.getOrDefault("Marker")
  valid_604954 = validateParameter(valid_604954, JString, required = false,
                                 default = nil)
  if valid_604954 != nil:
    section.add "Marker", valid_604954
  var valid_604955 = query.getOrDefault("Version")
  valid_604955 = validateParameter(valid_604955, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_604955 != nil:
    section.add "Version", valid_604955
  var valid_604956 = query.getOrDefault("ReservedNodeId")
  valid_604956 = validateParameter(valid_604956, JString, required = false,
                                 default = nil)
  if valid_604956 != nil:
    section.add "ReservedNodeId", valid_604956
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_604957 = header.getOrDefault("X-Amz-Date")
  valid_604957 = validateParameter(valid_604957, JString, required = false,
                                 default = nil)
  if valid_604957 != nil:
    section.add "X-Amz-Date", valid_604957
  var valid_604958 = header.getOrDefault("X-Amz-Security-Token")
  valid_604958 = validateParameter(valid_604958, JString, required = false,
                                 default = nil)
  if valid_604958 != nil:
    section.add "X-Amz-Security-Token", valid_604958
  var valid_604959 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604959 = validateParameter(valid_604959, JString, required = false,
                                 default = nil)
  if valid_604959 != nil:
    section.add "X-Amz-Content-Sha256", valid_604959
  var valid_604960 = header.getOrDefault("X-Amz-Algorithm")
  valid_604960 = validateParameter(valid_604960, JString, required = false,
                                 default = nil)
  if valid_604960 != nil:
    section.add "X-Amz-Algorithm", valid_604960
  var valid_604961 = header.getOrDefault("X-Amz-Signature")
  valid_604961 = validateParameter(valid_604961, JString, required = false,
                                 default = nil)
  if valid_604961 != nil:
    section.add "X-Amz-Signature", valid_604961
  var valid_604962 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604962 = validateParameter(valid_604962, JString, required = false,
                                 default = nil)
  if valid_604962 != nil:
    section.add "X-Amz-SignedHeaders", valid_604962
  var valid_604963 = header.getOrDefault("X-Amz-Credential")
  valid_604963 = validateParameter(valid_604963, JString, required = false,
                                 default = nil)
  if valid_604963 != nil:
    section.add "X-Amz-Credential", valid_604963
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604964: Call_GetDescribeReservedNodes_604949; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns the descriptions of the reserved nodes.
  ## 
  let valid = call_604964.validator(path, query, header, formData, body)
  let scheme = call_604964.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604964.url(scheme.get, call_604964.host, call_604964.base,
                         call_604964.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_604964, url, valid)

proc call*(call_604965: Call_GetDescribeReservedNodes_604949; MaxRecords: int = 0;
          Action: string = "DescribeReservedNodes"; Marker: string = "";
          Version: string = "2012-12-01"; ReservedNodeId: string = ""): Recallable =
  ## getDescribeReservedNodes
  ## Returns the descriptions of the reserved nodes.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Action: string (required)
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeReservedNodes</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Version: string (required)
  ##   ReservedNodeId: string
  ##                 : Identifier for the node reservation.
  var query_604966 = newJObject()
  add(query_604966, "MaxRecords", newJInt(MaxRecords))
  add(query_604966, "Action", newJString(Action))
  add(query_604966, "Marker", newJString(Marker))
  add(query_604966, "Version", newJString(Version))
  add(query_604966, "ReservedNodeId", newJString(ReservedNodeId))
  result = call_604965.call(nil, query_604966, nil, nil, nil)

var getDescribeReservedNodes* = Call_GetDescribeReservedNodes_604949(
    name: "getDescribeReservedNodes", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeReservedNodes",
    validator: validate_GetDescribeReservedNodes_604950, base: "/",
    url: url_GetDescribeReservedNodes_604951, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeResize_605002 = ref object of OpenApiRestCall_602450
proc url_PostDescribeResize_605004(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostDescribeResize_605003(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## <p>Returns information about the last resize operation for the specified cluster. If no resize operation has ever been initiated for the specified cluster, a <code>HTTP 404</code> error is returned. If a resize operation was initiated and completed, the status of the resize remains as <code>SUCCEEDED</code> until the next resize. </p> <p>A resize operation can be requested using <a>ModifyCluster</a> and specifying a different number or type of nodes for the cluster. </p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_605005 = query.getOrDefault("Action")
  valid_605005 = validateParameter(valid_605005, JString, required = true,
                                 default = newJString("DescribeResize"))
  if valid_605005 != nil:
    section.add "Action", valid_605005
  var valid_605006 = query.getOrDefault("Version")
  valid_605006 = validateParameter(valid_605006, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_605006 != nil:
    section.add "Version", valid_605006
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_605007 = header.getOrDefault("X-Amz-Date")
  valid_605007 = validateParameter(valid_605007, JString, required = false,
                                 default = nil)
  if valid_605007 != nil:
    section.add "X-Amz-Date", valid_605007
  var valid_605008 = header.getOrDefault("X-Amz-Security-Token")
  valid_605008 = validateParameter(valid_605008, JString, required = false,
                                 default = nil)
  if valid_605008 != nil:
    section.add "X-Amz-Security-Token", valid_605008
  var valid_605009 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605009 = validateParameter(valid_605009, JString, required = false,
                                 default = nil)
  if valid_605009 != nil:
    section.add "X-Amz-Content-Sha256", valid_605009
  var valid_605010 = header.getOrDefault("X-Amz-Algorithm")
  valid_605010 = validateParameter(valid_605010, JString, required = false,
                                 default = nil)
  if valid_605010 != nil:
    section.add "X-Amz-Algorithm", valid_605010
  var valid_605011 = header.getOrDefault("X-Amz-Signature")
  valid_605011 = validateParameter(valid_605011, JString, required = false,
                                 default = nil)
  if valid_605011 != nil:
    section.add "X-Amz-Signature", valid_605011
  var valid_605012 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605012 = validateParameter(valid_605012, JString, required = false,
                                 default = nil)
  if valid_605012 != nil:
    section.add "X-Amz-SignedHeaders", valid_605012
  var valid_605013 = header.getOrDefault("X-Amz-Credential")
  valid_605013 = validateParameter(valid_605013, JString, required = false,
                                 default = nil)
  if valid_605013 != nil:
    section.add "X-Amz-Credential", valid_605013
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of a cluster whose resize progress you are requesting. This parameter is case-sensitive.</p> <p>By default, resize operations for all clusters defined for an AWS account are returned.</p>
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_605014 = formData.getOrDefault("ClusterIdentifier")
  valid_605014 = validateParameter(valid_605014, JString, required = true,
                                 default = nil)
  if valid_605014 != nil:
    section.add "ClusterIdentifier", valid_605014
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_605015: Call_PostDescribeResize_605002; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns information about the last resize operation for the specified cluster. If no resize operation has ever been initiated for the specified cluster, a <code>HTTP 404</code> error is returned. If a resize operation was initiated and completed, the status of the resize remains as <code>SUCCEEDED</code> until the next resize. </p> <p>A resize operation can be requested using <a>ModifyCluster</a> and specifying a different number or type of nodes for the cluster. </p>
  ## 
  let valid = call_605015.validator(path, query, header, formData, body)
  let scheme = call_605015.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605015.url(scheme.get, call_605015.host, call_605015.base,
                         call_605015.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_605015, url, valid)

proc call*(call_605016: Call_PostDescribeResize_605002; ClusterIdentifier: string;
          Action: string = "DescribeResize"; Version: string = "2012-12-01"): Recallable =
  ## postDescribeResize
  ## <p>Returns information about the last resize operation for the specified cluster. If no resize operation has ever been initiated for the specified cluster, a <code>HTTP 404</code> error is returned. If a resize operation was initiated and completed, the status of the resize remains as <code>SUCCEEDED</code> until the next resize. </p> <p>A resize operation can be requested using <a>ModifyCluster</a> and specifying a different number or type of nodes for the cluster. </p>
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of a cluster whose resize progress you are requesting. This parameter is case-sensitive.</p> <p>By default, resize operations for all clusters defined for an AWS account are returned.</p>
  ##   Version: string (required)
  var query_605017 = newJObject()
  var formData_605018 = newJObject()
  add(query_605017, "Action", newJString(Action))
  add(formData_605018, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_605017, "Version", newJString(Version))
  result = call_605016.call(nil, query_605017, nil, formData_605018, nil)

var postDescribeResize* = Call_PostDescribeResize_605002(
    name: "postDescribeResize", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeResize",
    validator: validate_PostDescribeResize_605003, base: "/",
    url: url_PostDescribeResize_605004, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeResize_604986 = ref object of OpenApiRestCall_602450
proc url_GetDescribeResize_604988(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetDescribeResize_604987(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## <p>Returns information about the last resize operation for the specified cluster. If no resize operation has ever been initiated for the specified cluster, a <code>HTTP 404</code> error is returned. If a resize operation was initiated and completed, the status of the resize remains as <code>SUCCEEDED</code> until the next resize. </p> <p>A resize operation can be requested using <a>ModifyCluster</a> and specifying a different number or type of nodes for the cluster. </p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of a cluster whose resize progress you are requesting. This parameter is case-sensitive.</p> <p>By default, resize operations for all clusters defined for an AWS account are returned.</p>
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_604989 = query.getOrDefault("Action")
  valid_604989 = validateParameter(valid_604989, JString, required = true,
                                 default = newJString("DescribeResize"))
  if valid_604989 != nil:
    section.add "Action", valid_604989
  var valid_604990 = query.getOrDefault("ClusterIdentifier")
  valid_604990 = validateParameter(valid_604990, JString, required = true,
                                 default = nil)
  if valid_604990 != nil:
    section.add "ClusterIdentifier", valid_604990
  var valid_604991 = query.getOrDefault("Version")
  valid_604991 = validateParameter(valid_604991, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_604991 != nil:
    section.add "Version", valid_604991
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_604992 = header.getOrDefault("X-Amz-Date")
  valid_604992 = validateParameter(valid_604992, JString, required = false,
                                 default = nil)
  if valid_604992 != nil:
    section.add "X-Amz-Date", valid_604992
  var valid_604993 = header.getOrDefault("X-Amz-Security-Token")
  valid_604993 = validateParameter(valid_604993, JString, required = false,
                                 default = nil)
  if valid_604993 != nil:
    section.add "X-Amz-Security-Token", valid_604993
  var valid_604994 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604994 = validateParameter(valid_604994, JString, required = false,
                                 default = nil)
  if valid_604994 != nil:
    section.add "X-Amz-Content-Sha256", valid_604994
  var valid_604995 = header.getOrDefault("X-Amz-Algorithm")
  valid_604995 = validateParameter(valid_604995, JString, required = false,
                                 default = nil)
  if valid_604995 != nil:
    section.add "X-Amz-Algorithm", valid_604995
  var valid_604996 = header.getOrDefault("X-Amz-Signature")
  valid_604996 = validateParameter(valid_604996, JString, required = false,
                                 default = nil)
  if valid_604996 != nil:
    section.add "X-Amz-Signature", valid_604996
  var valid_604997 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604997 = validateParameter(valid_604997, JString, required = false,
                                 default = nil)
  if valid_604997 != nil:
    section.add "X-Amz-SignedHeaders", valid_604997
  var valid_604998 = header.getOrDefault("X-Amz-Credential")
  valid_604998 = validateParameter(valid_604998, JString, required = false,
                                 default = nil)
  if valid_604998 != nil:
    section.add "X-Amz-Credential", valid_604998
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604999: Call_GetDescribeResize_604986; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns information about the last resize operation for the specified cluster. If no resize operation has ever been initiated for the specified cluster, a <code>HTTP 404</code> error is returned. If a resize operation was initiated and completed, the status of the resize remains as <code>SUCCEEDED</code> until the next resize. </p> <p>A resize operation can be requested using <a>ModifyCluster</a> and specifying a different number or type of nodes for the cluster. </p>
  ## 
  let valid = call_604999.validator(path, query, header, formData, body)
  let scheme = call_604999.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604999.url(scheme.get, call_604999.host, call_604999.base,
                         call_604999.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_604999, url, valid)

proc call*(call_605000: Call_GetDescribeResize_604986; ClusterIdentifier: string;
          Action: string = "DescribeResize"; Version: string = "2012-12-01"): Recallable =
  ## getDescribeResize
  ## <p>Returns information about the last resize operation for the specified cluster. If no resize operation has ever been initiated for the specified cluster, a <code>HTTP 404</code> error is returned. If a resize operation was initiated and completed, the status of the resize remains as <code>SUCCEEDED</code> until the next resize. </p> <p>A resize operation can be requested using <a>ModifyCluster</a> and specifying a different number or type of nodes for the cluster. </p>
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of a cluster whose resize progress you are requesting. This parameter is case-sensitive.</p> <p>By default, resize operations for all clusters defined for an AWS account are returned.</p>
  ##   Version: string (required)
  var query_605001 = newJObject()
  add(query_605001, "Action", newJString(Action))
  add(query_605001, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_605001, "Version", newJString(Version))
  result = call_605000.call(nil, query_605001, nil, nil, nil)

var getDescribeResize* = Call_GetDescribeResize_604986(name: "getDescribeResize",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=DescribeResize", validator: validate_GetDescribeResize_604987,
    base: "/", url: url_GetDescribeResize_604988,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeSnapshotCopyGrants_605039 = ref object of OpenApiRestCall_602450
proc url_PostDescribeSnapshotCopyGrants_605041(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostDescribeSnapshotCopyGrants_605040(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns a list of snapshot copy grants owned by the AWS account in the destination region.</p> <p> For more information about managing snapshot copy grants, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_605042 = query.getOrDefault("Action")
  valid_605042 = validateParameter(valid_605042, JString, required = true, default = newJString(
      "DescribeSnapshotCopyGrants"))
  if valid_605042 != nil:
    section.add "Action", valid_605042
  var valid_605043 = query.getOrDefault("Version")
  valid_605043 = validateParameter(valid_605043, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_605043 != nil:
    section.add "Version", valid_605043
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_605044 = header.getOrDefault("X-Amz-Date")
  valid_605044 = validateParameter(valid_605044, JString, required = false,
                                 default = nil)
  if valid_605044 != nil:
    section.add "X-Amz-Date", valid_605044
  var valid_605045 = header.getOrDefault("X-Amz-Security-Token")
  valid_605045 = validateParameter(valid_605045, JString, required = false,
                                 default = nil)
  if valid_605045 != nil:
    section.add "X-Amz-Security-Token", valid_605045
  var valid_605046 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605046 = validateParameter(valid_605046, JString, required = false,
                                 default = nil)
  if valid_605046 != nil:
    section.add "X-Amz-Content-Sha256", valid_605046
  var valid_605047 = header.getOrDefault("X-Amz-Algorithm")
  valid_605047 = validateParameter(valid_605047, JString, required = false,
                                 default = nil)
  if valid_605047 != nil:
    section.add "X-Amz-Algorithm", valid_605047
  var valid_605048 = header.getOrDefault("X-Amz-Signature")
  valid_605048 = validateParameter(valid_605048, JString, required = false,
                                 default = nil)
  if valid_605048 != nil:
    section.add "X-Amz-Signature", valid_605048
  var valid_605049 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605049 = validateParameter(valid_605049, JString, required = false,
                                 default = nil)
  if valid_605049 != nil:
    section.add "X-Amz-SignedHeaders", valid_605049
  var valid_605050 = header.getOrDefault("X-Amz-Credential")
  valid_605050 = validateParameter(valid_605050, JString, required = false,
                                 default = nil)
  if valid_605050 != nil:
    section.add "X-Amz-Credential", valid_605050
  result.add "header", section
  ## parameters in `formData` object:
  ##   Marker: JString
  ##         : <p>An optional parameter that specifies the starting point to return a set of response records. When the results of a <code>DescribeSnapshotCopyGrant</code> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <b>SnapshotCopyGrantName</b> parameter or the <b>Marker</b> parameter, but not both. </p>
  ##   SnapshotCopyGrantName: JString
  ##                        : The name of the snapshot copy grant.
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching resources that are associated with the specified key or keys. For example, suppose that you have resources tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with all resources that have either or both of these tag keys associated with them.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching resources that are associated with the specified value or values. For example, suppose that you have resources tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with all resources that have either or both of these tag values associated with them.
  section = newJObject()
  var valid_605051 = formData.getOrDefault("Marker")
  valid_605051 = validateParameter(valid_605051, JString, required = false,
                                 default = nil)
  if valid_605051 != nil:
    section.add "Marker", valid_605051
  var valid_605052 = formData.getOrDefault("SnapshotCopyGrantName")
  valid_605052 = validateParameter(valid_605052, JString, required = false,
                                 default = nil)
  if valid_605052 != nil:
    section.add "SnapshotCopyGrantName", valid_605052
  var valid_605053 = formData.getOrDefault("TagKeys")
  valid_605053 = validateParameter(valid_605053, JArray, required = false,
                                 default = nil)
  if valid_605053 != nil:
    section.add "TagKeys", valid_605053
  var valid_605054 = formData.getOrDefault("MaxRecords")
  valid_605054 = validateParameter(valid_605054, JInt, required = false, default = nil)
  if valid_605054 != nil:
    section.add "MaxRecords", valid_605054
  var valid_605055 = formData.getOrDefault("TagValues")
  valid_605055 = validateParameter(valid_605055, JArray, required = false,
                                 default = nil)
  if valid_605055 != nil:
    section.add "TagValues", valid_605055
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_605056: Call_PostDescribeSnapshotCopyGrants_605039; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns a list of snapshot copy grants owned by the AWS account in the destination region.</p> <p> For more information about managing snapshot copy grants, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ## 
  let valid = call_605056.validator(path, query, header, formData, body)
  let scheme = call_605056.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605056.url(scheme.get, call_605056.host, call_605056.base,
                         call_605056.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_605056, url, valid)

proc call*(call_605057: Call_PostDescribeSnapshotCopyGrants_605039;
          Marker: string = ""; Action: string = "DescribeSnapshotCopyGrants";
          SnapshotCopyGrantName: string = ""; TagKeys: JsonNode = nil;
          MaxRecords: int = 0; TagValues: JsonNode = nil; Version: string = "2012-12-01"): Recallable =
  ## postDescribeSnapshotCopyGrants
  ## <p>Returns a list of snapshot copy grants owned by the AWS account in the destination region.</p> <p> For more information about managing snapshot copy grants, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ##   Marker: string
  ##         : <p>An optional parameter that specifies the starting point to return a set of response records. When the results of a <code>DescribeSnapshotCopyGrant</code> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <b>SnapshotCopyGrantName</b> parameter or the <b>Marker</b> parameter, but not both. </p>
  ##   Action: string (required)
  ##   SnapshotCopyGrantName: string
  ##                        : The name of the snapshot copy grant.
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching resources that are associated with the specified key or keys. For example, suppose that you have resources tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with all resources that have either or both of these tag keys associated with them.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching resources that are associated with the specified value or values. For example, suppose that you have resources tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with all resources that have either or both of these tag values associated with them.
  ##   Version: string (required)
  var query_605058 = newJObject()
  var formData_605059 = newJObject()
  add(formData_605059, "Marker", newJString(Marker))
  add(query_605058, "Action", newJString(Action))
  add(formData_605059, "SnapshotCopyGrantName", newJString(SnapshotCopyGrantName))
  if TagKeys != nil:
    formData_605059.add "TagKeys", TagKeys
  add(formData_605059, "MaxRecords", newJInt(MaxRecords))
  if TagValues != nil:
    formData_605059.add "TagValues", TagValues
  add(query_605058, "Version", newJString(Version))
  result = call_605057.call(nil, query_605058, nil, formData_605059, nil)

var postDescribeSnapshotCopyGrants* = Call_PostDescribeSnapshotCopyGrants_605039(
    name: "postDescribeSnapshotCopyGrants", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeSnapshotCopyGrants",
    validator: validate_PostDescribeSnapshotCopyGrants_605040, base: "/",
    url: url_PostDescribeSnapshotCopyGrants_605041,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeSnapshotCopyGrants_605019 = ref object of OpenApiRestCall_602450
proc url_GetDescribeSnapshotCopyGrants_605021(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetDescribeSnapshotCopyGrants_605020(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns a list of snapshot copy grants owned by the AWS account in the destination region.</p> <p> For more information about managing snapshot copy grants, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching resources that are associated with the specified value or values. For example, suppose that you have resources tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with all resources that have either or both of these tag values associated with them.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Action: JString (required)
  ##   Marker: JString
  ##         : <p>An optional parameter that specifies the starting point to return a set of response records. When the results of a <code>DescribeSnapshotCopyGrant</code> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <b>SnapshotCopyGrantName</b> parameter or the <b>Marker</b> parameter, but not both. </p>
  ##   SnapshotCopyGrantName: JString
  ##                        : The name of the snapshot copy grant.
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching resources that are associated with the specified key or keys. For example, suppose that you have resources tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with all resources that have either or both of these tag keys associated with them.
  ##   Version: JString (required)
  section = newJObject()
  var valid_605022 = query.getOrDefault("TagValues")
  valid_605022 = validateParameter(valid_605022, JArray, required = false,
                                 default = nil)
  if valid_605022 != nil:
    section.add "TagValues", valid_605022
  var valid_605023 = query.getOrDefault("MaxRecords")
  valid_605023 = validateParameter(valid_605023, JInt, required = false, default = nil)
  if valid_605023 != nil:
    section.add "MaxRecords", valid_605023
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_605024 = query.getOrDefault("Action")
  valid_605024 = validateParameter(valid_605024, JString, required = true, default = newJString(
      "DescribeSnapshotCopyGrants"))
  if valid_605024 != nil:
    section.add "Action", valid_605024
  var valid_605025 = query.getOrDefault("Marker")
  valid_605025 = validateParameter(valid_605025, JString, required = false,
                                 default = nil)
  if valid_605025 != nil:
    section.add "Marker", valid_605025
  var valid_605026 = query.getOrDefault("SnapshotCopyGrantName")
  valid_605026 = validateParameter(valid_605026, JString, required = false,
                                 default = nil)
  if valid_605026 != nil:
    section.add "SnapshotCopyGrantName", valid_605026
  var valid_605027 = query.getOrDefault("TagKeys")
  valid_605027 = validateParameter(valid_605027, JArray, required = false,
                                 default = nil)
  if valid_605027 != nil:
    section.add "TagKeys", valid_605027
  var valid_605028 = query.getOrDefault("Version")
  valid_605028 = validateParameter(valid_605028, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_605028 != nil:
    section.add "Version", valid_605028
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_605029 = header.getOrDefault("X-Amz-Date")
  valid_605029 = validateParameter(valid_605029, JString, required = false,
                                 default = nil)
  if valid_605029 != nil:
    section.add "X-Amz-Date", valid_605029
  var valid_605030 = header.getOrDefault("X-Amz-Security-Token")
  valid_605030 = validateParameter(valid_605030, JString, required = false,
                                 default = nil)
  if valid_605030 != nil:
    section.add "X-Amz-Security-Token", valid_605030
  var valid_605031 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605031 = validateParameter(valid_605031, JString, required = false,
                                 default = nil)
  if valid_605031 != nil:
    section.add "X-Amz-Content-Sha256", valid_605031
  var valid_605032 = header.getOrDefault("X-Amz-Algorithm")
  valid_605032 = validateParameter(valid_605032, JString, required = false,
                                 default = nil)
  if valid_605032 != nil:
    section.add "X-Amz-Algorithm", valid_605032
  var valid_605033 = header.getOrDefault("X-Amz-Signature")
  valid_605033 = validateParameter(valid_605033, JString, required = false,
                                 default = nil)
  if valid_605033 != nil:
    section.add "X-Amz-Signature", valid_605033
  var valid_605034 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605034 = validateParameter(valid_605034, JString, required = false,
                                 default = nil)
  if valid_605034 != nil:
    section.add "X-Amz-SignedHeaders", valid_605034
  var valid_605035 = header.getOrDefault("X-Amz-Credential")
  valid_605035 = validateParameter(valid_605035, JString, required = false,
                                 default = nil)
  if valid_605035 != nil:
    section.add "X-Amz-Credential", valid_605035
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_605036: Call_GetDescribeSnapshotCopyGrants_605019; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns a list of snapshot copy grants owned by the AWS account in the destination region.</p> <p> For more information about managing snapshot copy grants, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ## 
  let valid = call_605036.validator(path, query, header, formData, body)
  let scheme = call_605036.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605036.url(scheme.get, call_605036.host, call_605036.base,
                         call_605036.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_605036, url, valid)

proc call*(call_605037: Call_GetDescribeSnapshotCopyGrants_605019;
          TagValues: JsonNode = nil; MaxRecords: int = 0;
          Action: string = "DescribeSnapshotCopyGrants"; Marker: string = "";
          SnapshotCopyGrantName: string = ""; TagKeys: JsonNode = nil;
          Version: string = "2012-12-01"): Recallable =
  ## getDescribeSnapshotCopyGrants
  ## <p>Returns a list of snapshot copy grants owned by the AWS account in the destination region.</p> <p> For more information about managing snapshot copy grants, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching resources that are associated with the specified value or values. For example, suppose that you have resources tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with all resources that have either or both of these tag values associated with them.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Action: string (required)
  ##   Marker: string
  ##         : <p>An optional parameter that specifies the starting point to return a set of response records. When the results of a <code>DescribeSnapshotCopyGrant</code> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <b>SnapshotCopyGrantName</b> parameter or the <b>Marker</b> parameter, but not both. </p>
  ##   SnapshotCopyGrantName: string
  ##                        : The name of the snapshot copy grant.
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching resources that are associated with the specified key or keys. For example, suppose that you have resources tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with all resources that have either or both of these tag keys associated with them.
  ##   Version: string (required)
  var query_605038 = newJObject()
  if TagValues != nil:
    query_605038.add "TagValues", TagValues
  add(query_605038, "MaxRecords", newJInt(MaxRecords))
  add(query_605038, "Action", newJString(Action))
  add(query_605038, "Marker", newJString(Marker))
  add(query_605038, "SnapshotCopyGrantName", newJString(SnapshotCopyGrantName))
  if TagKeys != nil:
    query_605038.add "TagKeys", TagKeys
  add(query_605038, "Version", newJString(Version))
  result = call_605037.call(nil, query_605038, nil, nil, nil)

var getDescribeSnapshotCopyGrants* = Call_GetDescribeSnapshotCopyGrants_605019(
    name: "getDescribeSnapshotCopyGrants", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeSnapshotCopyGrants",
    validator: validate_GetDescribeSnapshotCopyGrants_605020, base: "/",
    url: url_GetDescribeSnapshotCopyGrants_605021,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeSnapshotSchedules_605081 = ref object of OpenApiRestCall_602450
proc url_PostDescribeSnapshotSchedules_605083(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostDescribeSnapshotSchedules_605082(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns a list of snapshot schedules. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_605084 = query.getOrDefault("Action")
  valid_605084 = validateParameter(valid_605084, JString, required = true, default = newJString(
      "DescribeSnapshotSchedules"))
  if valid_605084 != nil:
    section.add "Action", valid_605084
  var valid_605085 = query.getOrDefault("Version")
  valid_605085 = validateParameter(valid_605085, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_605085 != nil:
    section.add "Version", valid_605085
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_605086 = header.getOrDefault("X-Amz-Date")
  valid_605086 = validateParameter(valid_605086, JString, required = false,
                                 default = nil)
  if valid_605086 != nil:
    section.add "X-Amz-Date", valid_605086
  var valid_605087 = header.getOrDefault("X-Amz-Security-Token")
  valid_605087 = validateParameter(valid_605087, JString, required = false,
                                 default = nil)
  if valid_605087 != nil:
    section.add "X-Amz-Security-Token", valid_605087
  var valid_605088 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605088 = validateParameter(valid_605088, JString, required = false,
                                 default = nil)
  if valid_605088 != nil:
    section.add "X-Amz-Content-Sha256", valid_605088
  var valid_605089 = header.getOrDefault("X-Amz-Algorithm")
  valid_605089 = validateParameter(valid_605089, JString, required = false,
                                 default = nil)
  if valid_605089 != nil:
    section.add "X-Amz-Algorithm", valid_605089
  var valid_605090 = header.getOrDefault("X-Amz-Signature")
  valid_605090 = validateParameter(valid_605090, JString, required = false,
                                 default = nil)
  if valid_605090 != nil:
    section.add "X-Amz-Signature", valid_605090
  var valid_605091 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605091 = validateParameter(valid_605091, JString, required = false,
                                 default = nil)
  if valid_605091 != nil:
    section.add "X-Amz-SignedHeaders", valid_605091
  var valid_605092 = header.getOrDefault("X-Amz-Credential")
  valid_605092 = validateParameter(valid_605092, JString, required = false,
                                 default = nil)
  if valid_605092 != nil:
    section.add "X-Amz-Credential", valid_605092
  result.add "header", section
  ## parameters in `formData` object:
  ##   Marker: JString
  ##         : A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned marker value in the <code>marker</code> parameter and retrying the command. If the <code>marker</code> field is empty, all response records have been retrieved for the request.
  ##   ClusterIdentifier: JString
  ##                    : The unique identifier for the cluster whose snapshot schedules you want to view.
  ##   ScheduleIdentifier: JString
  ##                     : A unique identifier for a snapshot schedule.
  ##   TagKeys: JArray
  ##          : The key value for a snapshot schedule tag.
  ##   MaxRecords: JInt
  ##             : The maximum number or response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned <code>marker</code> value.
  ##   TagValues: JArray
  ##            : The value corresponding to the key of the snapshot schedule tag.
  section = newJObject()
  var valid_605093 = formData.getOrDefault("Marker")
  valid_605093 = validateParameter(valid_605093, JString, required = false,
                                 default = nil)
  if valid_605093 != nil:
    section.add "Marker", valid_605093
  var valid_605094 = formData.getOrDefault("ClusterIdentifier")
  valid_605094 = validateParameter(valid_605094, JString, required = false,
                                 default = nil)
  if valid_605094 != nil:
    section.add "ClusterIdentifier", valid_605094
  var valid_605095 = formData.getOrDefault("ScheduleIdentifier")
  valid_605095 = validateParameter(valid_605095, JString, required = false,
                                 default = nil)
  if valid_605095 != nil:
    section.add "ScheduleIdentifier", valid_605095
  var valid_605096 = formData.getOrDefault("TagKeys")
  valid_605096 = validateParameter(valid_605096, JArray, required = false,
                                 default = nil)
  if valid_605096 != nil:
    section.add "TagKeys", valid_605096
  var valid_605097 = formData.getOrDefault("MaxRecords")
  valid_605097 = validateParameter(valid_605097, JInt, required = false, default = nil)
  if valid_605097 != nil:
    section.add "MaxRecords", valid_605097
  var valid_605098 = formData.getOrDefault("TagValues")
  valid_605098 = validateParameter(valid_605098, JArray, required = false,
                                 default = nil)
  if valid_605098 != nil:
    section.add "TagValues", valid_605098
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_605099: Call_PostDescribeSnapshotSchedules_605081; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns a list of snapshot schedules. 
  ## 
  let valid = call_605099.validator(path, query, header, formData, body)
  let scheme = call_605099.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605099.url(scheme.get, call_605099.host, call_605099.base,
                         call_605099.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_605099, url, valid)

proc call*(call_605100: Call_PostDescribeSnapshotSchedules_605081;
          Marker: string = ""; Action: string = "DescribeSnapshotSchedules";
          ClusterIdentifier: string = ""; ScheduleIdentifier: string = "";
          TagKeys: JsonNode = nil; MaxRecords: int = 0; TagValues: JsonNode = nil;
          Version: string = "2012-12-01"): Recallable =
  ## postDescribeSnapshotSchedules
  ## Returns a list of snapshot schedules. 
  ##   Marker: string
  ##         : A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned marker value in the <code>marker</code> parameter and retrying the command. If the <code>marker</code> field is empty, all response records have been retrieved for the request.
  ##   Action: string (required)
  ##   ClusterIdentifier: string
  ##                    : The unique identifier for the cluster whose snapshot schedules you want to view.
  ##   ScheduleIdentifier: string
  ##                     : A unique identifier for a snapshot schedule.
  ##   TagKeys: JArray
  ##          : The key value for a snapshot schedule tag.
  ##   MaxRecords: int
  ##             : The maximum number or response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned <code>marker</code> value.
  ##   TagValues: JArray
  ##            : The value corresponding to the key of the snapshot schedule tag.
  ##   Version: string (required)
  var query_605101 = newJObject()
  var formData_605102 = newJObject()
  add(formData_605102, "Marker", newJString(Marker))
  add(query_605101, "Action", newJString(Action))
  add(formData_605102, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_605102, "ScheduleIdentifier", newJString(ScheduleIdentifier))
  if TagKeys != nil:
    formData_605102.add "TagKeys", TagKeys
  add(formData_605102, "MaxRecords", newJInt(MaxRecords))
  if TagValues != nil:
    formData_605102.add "TagValues", TagValues
  add(query_605101, "Version", newJString(Version))
  result = call_605100.call(nil, query_605101, nil, formData_605102, nil)

var postDescribeSnapshotSchedules* = Call_PostDescribeSnapshotSchedules_605081(
    name: "postDescribeSnapshotSchedules", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeSnapshotSchedules",
    validator: validate_PostDescribeSnapshotSchedules_605082, base: "/",
    url: url_PostDescribeSnapshotSchedules_605083,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeSnapshotSchedules_605060 = ref object of OpenApiRestCall_602450
proc url_GetDescribeSnapshotSchedules_605062(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetDescribeSnapshotSchedules_605061(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns a list of snapshot schedules. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   TagValues: JArray
  ##            : The value corresponding to the key of the snapshot schedule tag.
  ##   MaxRecords: JInt
  ##             : The maximum number or response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned <code>marker</code> value.
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString
  ##                    : The unique identifier for the cluster whose snapshot schedules you want to view.
  ##   ScheduleIdentifier: JString
  ##                     : A unique identifier for a snapshot schedule.
  ##   Marker: JString
  ##         : A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned marker value in the <code>marker</code> parameter and retrying the command. If the <code>marker</code> field is empty, all response records have been retrieved for the request.
  ##   TagKeys: JArray
  ##          : The key value for a snapshot schedule tag.
  ##   Version: JString (required)
  section = newJObject()
  var valid_605063 = query.getOrDefault("TagValues")
  valid_605063 = validateParameter(valid_605063, JArray, required = false,
                                 default = nil)
  if valid_605063 != nil:
    section.add "TagValues", valid_605063
  var valid_605064 = query.getOrDefault("MaxRecords")
  valid_605064 = validateParameter(valid_605064, JInt, required = false, default = nil)
  if valid_605064 != nil:
    section.add "MaxRecords", valid_605064
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_605065 = query.getOrDefault("Action")
  valid_605065 = validateParameter(valid_605065, JString, required = true, default = newJString(
      "DescribeSnapshotSchedules"))
  if valid_605065 != nil:
    section.add "Action", valid_605065
  var valid_605066 = query.getOrDefault("ClusterIdentifier")
  valid_605066 = validateParameter(valid_605066, JString, required = false,
                                 default = nil)
  if valid_605066 != nil:
    section.add "ClusterIdentifier", valid_605066
  var valid_605067 = query.getOrDefault("ScheduleIdentifier")
  valid_605067 = validateParameter(valid_605067, JString, required = false,
                                 default = nil)
  if valid_605067 != nil:
    section.add "ScheduleIdentifier", valid_605067
  var valid_605068 = query.getOrDefault("Marker")
  valid_605068 = validateParameter(valid_605068, JString, required = false,
                                 default = nil)
  if valid_605068 != nil:
    section.add "Marker", valid_605068
  var valid_605069 = query.getOrDefault("TagKeys")
  valid_605069 = validateParameter(valid_605069, JArray, required = false,
                                 default = nil)
  if valid_605069 != nil:
    section.add "TagKeys", valid_605069
  var valid_605070 = query.getOrDefault("Version")
  valid_605070 = validateParameter(valid_605070, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_605070 != nil:
    section.add "Version", valid_605070
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_605071 = header.getOrDefault("X-Amz-Date")
  valid_605071 = validateParameter(valid_605071, JString, required = false,
                                 default = nil)
  if valid_605071 != nil:
    section.add "X-Amz-Date", valid_605071
  var valid_605072 = header.getOrDefault("X-Amz-Security-Token")
  valid_605072 = validateParameter(valid_605072, JString, required = false,
                                 default = nil)
  if valid_605072 != nil:
    section.add "X-Amz-Security-Token", valid_605072
  var valid_605073 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605073 = validateParameter(valid_605073, JString, required = false,
                                 default = nil)
  if valid_605073 != nil:
    section.add "X-Amz-Content-Sha256", valid_605073
  var valid_605074 = header.getOrDefault("X-Amz-Algorithm")
  valid_605074 = validateParameter(valid_605074, JString, required = false,
                                 default = nil)
  if valid_605074 != nil:
    section.add "X-Amz-Algorithm", valid_605074
  var valid_605075 = header.getOrDefault("X-Amz-Signature")
  valid_605075 = validateParameter(valid_605075, JString, required = false,
                                 default = nil)
  if valid_605075 != nil:
    section.add "X-Amz-Signature", valid_605075
  var valid_605076 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605076 = validateParameter(valid_605076, JString, required = false,
                                 default = nil)
  if valid_605076 != nil:
    section.add "X-Amz-SignedHeaders", valid_605076
  var valid_605077 = header.getOrDefault("X-Amz-Credential")
  valid_605077 = validateParameter(valid_605077, JString, required = false,
                                 default = nil)
  if valid_605077 != nil:
    section.add "X-Amz-Credential", valid_605077
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_605078: Call_GetDescribeSnapshotSchedules_605060; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns a list of snapshot schedules. 
  ## 
  let valid = call_605078.validator(path, query, header, formData, body)
  let scheme = call_605078.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605078.url(scheme.get, call_605078.host, call_605078.base,
                         call_605078.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_605078, url, valid)

proc call*(call_605079: Call_GetDescribeSnapshotSchedules_605060;
          TagValues: JsonNode = nil; MaxRecords: int = 0;
          Action: string = "DescribeSnapshotSchedules";
          ClusterIdentifier: string = ""; ScheduleIdentifier: string = "";
          Marker: string = ""; TagKeys: JsonNode = nil; Version: string = "2012-12-01"): Recallable =
  ## getDescribeSnapshotSchedules
  ## Returns a list of snapshot schedules. 
  ##   TagValues: JArray
  ##            : The value corresponding to the key of the snapshot schedule tag.
  ##   MaxRecords: int
  ##             : The maximum number or response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned <code>marker</code> value.
  ##   Action: string (required)
  ##   ClusterIdentifier: string
  ##                    : The unique identifier for the cluster whose snapshot schedules you want to view.
  ##   ScheduleIdentifier: string
  ##                     : A unique identifier for a snapshot schedule.
  ##   Marker: string
  ##         : A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned marker value in the <code>marker</code> parameter and retrying the command. If the <code>marker</code> field is empty, all response records have been retrieved for the request.
  ##   TagKeys: JArray
  ##          : The key value for a snapshot schedule tag.
  ##   Version: string (required)
  var query_605080 = newJObject()
  if TagValues != nil:
    query_605080.add "TagValues", TagValues
  add(query_605080, "MaxRecords", newJInt(MaxRecords))
  add(query_605080, "Action", newJString(Action))
  add(query_605080, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_605080, "ScheduleIdentifier", newJString(ScheduleIdentifier))
  add(query_605080, "Marker", newJString(Marker))
  if TagKeys != nil:
    query_605080.add "TagKeys", TagKeys
  add(query_605080, "Version", newJString(Version))
  result = call_605079.call(nil, query_605080, nil, nil, nil)

var getDescribeSnapshotSchedules* = Call_GetDescribeSnapshotSchedules_605060(
    name: "getDescribeSnapshotSchedules", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeSnapshotSchedules",
    validator: validate_GetDescribeSnapshotSchedules_605061, base: "/",
    url: url_GetDescribeSnapshotSchedules_605062,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeStorage_605118 = ref object of OpenApiRestCall_602450
proc url_PostDescribeStorage_605120(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostDescribeStorage_605119(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Returns the total amount of snapshot usage and provisioned storage in megabytes.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_605121 = query.getOrDefault("Action")
  valid_605121 = validateParameter(valid_605121, JString, required = true,
                                 default = newJString("DescribeStorage"))
  if valid_605121 != nil:
    section.add "Action", valid_605121
  var valid_605122 = query.getOrDefault("Version")
  valid_605122 = validateParameter(valid_605122, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_605122 != nil:
    section.add "Version", valid_605122
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_605123 = header.getOrDefault("X-Amz-Date")
  valid_605123 = validateParameter(valid_605123, JString, required = false,
                                 default = nil)
  if valid_605123 != nil:
    section.add "X-Amz-Date", valid_605123
  var valid_605124 = header.getOrDefault("X-Amz-Security-Token")
  valid_605124 = validateParameter(valid_605124, JString, required = false,
                                 default = nil)
  if valid_605124 != nil:
    section.add "X-Amz-Security-Token", valid_605124
  var valid_605125 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605125 = validateParameter(valid_605125, JString, required = false,
                                 default = nil)
  if valid_605125 != nil:
    section.add "X-Amz-Content-Sha256", valid_605125
  var valid_605126 = header.getOrDefault("X-Amz-Algorithm")
  valid_605126 = validateParameter(valid_605126, JString, required = false,
                                 default = nil)
  if valid_605126 != nil:
    section.add "X-Amz-Algorithm", valid_605126
  var valid_605127 = header.getOrDefault("X-Amz-Signature")
  valid_605127 = validateParameter(valid_605127, JString, required = false,
                                 default = nil)
  if valid_605127 != nil:
    section.add "X-Amz-Signature", valid_605127
  var valid_605128 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605128 = validateParameter(valid_605128, JString, required = false,
                                 default = nil)
  if valid_605128 != nil:
    section.add "X-Amz-SignedHeaders", valid_605128
  var valid_605129 = header.getOrDefault("X-Amz-Credential")
  valid_605129 = validateParameter(valid_605129, JString, required = false,
                                 default = nil)
  if valid_605129 != nil:
    section.add "X-Amz-Credential", valid_605129
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_605130: Call_PostDescribeStorage_605118; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns the total amount of snapshot usage and provisioned storage in megabytes.
  ## 
  let valid = call_605130.validator(path, query, header, formData, body)
  let scheme = call_605130.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605130.url(scheme.get, call_605130.host, call_605130.base,
                         call_605130.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_605130, url, valid)

proc call*(call_605131: Call_PostDescribeStorage_605118;
          Action: string = "DescribeStorage"; Version: string = "2012-12-01"): Recallable =
  ## postDescribeStorage
  ## Returns the total amount of snapshot usage and provisioned storage in megabytes.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_605132 = newJObject()
  add(query_605132, "Action", newJString(Action))
  add(query_605132, "Version", newJString(Version))
  result = call_605131.call(nil, query_605132, nil, nil, nil)

var postDescribeStorage* = Call_PostDescribeStorage_605118(
    name: "postDescribeStorage", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeStorage",
    validator: validate_PostDescribeStorage_605119, base: "/",
    url: url_PostDescribeStorage_605120, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeStorage_605103 = ref object of OpenApiRestCall_602450
proc url_GetDescribeStorage_605105(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetDescribeStorage_605104(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Returns the total amount of snapshot usage and provisioned storage in megabytes.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_605106 = query.getOrDefault("Action")
  valid_605106 = validateParameter(valid_605106, JString, required = true,
                                 default = newJString("DescribeStorage"))
  if valid_605106 != nil:
    section.add "Action", valid_605106
  var valid_605107 = query.getOrDefault("Version")
  valid_605107 = validateParameter(valid_605107, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_605107 != nil:
    section.add "Version", valid_605107
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_605108 = header.getOrDefault("X-Amz-Date")
  valid_605108 = validateParameter(valid_605108, JString, required = false,
                                 default = nil)
  if valid_605108 != nil:
    section.add "X-Amz-Date", valid_605108
  var valid_605109 = header.getOrDefault("X-Amz-Security-Token")
  valid_605109 = validateParameter(valid_605109, JString, required = false,
                                 default = nil)
  if valid_605109 != nil:
    section.add "X-Amz-Security-Token", valid_605109
  var valid_605110 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605110 = validateParameter(valid_605110, JString, required = false,
                                 default = nil)
  if valid_605110 != nil:
    section.add "X-Amz-Content-Sha256", valid_605110
  var valid_605111 = header.getOrDefault("X-Amz-Algorithm")
  valid_605111 = validateParameter(valid_605111, JString, required = false,
                                 default = nil)
  if valid_605111 != nil:
    section.add "X-Amz-Algorithm", valid_605111
  var valid_605112 = header.getOrDefault("X-Amz-Signature")
  valid_605112 = validateParameter(valid_605112, JString, required = false,
                                 default = nil)
  if valid_605112 != nil:
    section.add "X-Amz-Signature", valid_605112
  var valid_605113 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605113 = validateParameter(valid_605113, JString, required = false,
                                 default = nil)
  if valid_605113 != nil:
    section.add "X-Amz-SignedHeaders", valid_605113
  var valid_605114 = header.getOrDefault("X-Amz-Credential")
  valid_605114 = validateParameter(valid_605114, JString, required = false,
                                 default = nil)
  if valid_605114 != nil:
    section.add "X-Amz-Credential", valid_605114
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_605115: Call_GetDescribeStorage_605103; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns the total amount of snapshot usage and provisioned storage in megabytes.
  ## 
  let valid = call_605115.validator(path, query, header, formData, body)
  let scheme = call_605115.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605115.url(scheme.get, call_605115.host, call_605115.base,
                         call_605115.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_605115, url, valid)

proc call*(call_605116: Call_GetDescribeStorage_605103;
          Action: string = "DescribeStorage"; Version: string = "2012-12-01"): Recallable =
  ## getDescribeStorage
  ## Returns the total amount of snapshot usage and provisioned storage in megabytes.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_605117 = newJObject()
  add(query_605117, "Action", newJString(Action))
  add(query_605117, "Version", newJString(Version))
  result = call_605116.call(nil, query_605117, nil, nil, nil)

var getDescribeStorage* = Call_GetDescribeStorage_605103(
    name: "getDescribeStorage", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeStorage",
    validator: validate_GetDescribeStorage_605104, base: "/",
    url: url_GetDescribeStorage_605105, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeTableRestoreStatus_605152 = ref object of OpenApiRestCall_602450
proc url_PostDescribeTableRestoreStatus_605154(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostDescribeTableRestoreStatus_605153(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists the status of one or more table restore requests made using the <a>RestoreTableFromClusterSnapshot</a> API action. If you don't specify a value for the <code>TableRestoreRequestId</code> parameter, then <code>DescribeTableRestoreStatus</code> returns the status of all table restore requests ordered by the date and time of the request in ascending order. Otherwise <code>DescribeTableRestoreStatus</code> returns the status of the table specified by <code>TableRestoreRequestId</code>.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_605155 = query.getOrDefault("Action")
  valid_605155 = validateParameter(valid_605155, JString, required = true, default = newJString(
      "DescribeTableRestoreStatus"))
  if valid_605155 != nil:
    section.add "Action", valid_605155
  var valid_605156 = query.getOrDefault("Version")
  valid_605156 = validateParameter(valid_605156, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_605156 != nil:
    section.add "Version", valid_605156
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_605157 = header.getOrDefault("X-Amz-Date")
  valid_605157 = validateParameter(valid_605157, JString, required = false,
                                 default = nil)
  if valid_605157 != nil:
    section.add "X-Amz-Date", valid_605157
  var valid_605158 = header.getOrDefault("X-Amz-Security-Token")
  valid_605158 = validateParameter(valid_605158, JString, required = false,
                                 default = nil)
  if valid_605158 != nil:
    section.add "X-Amz-Security-Token", valid_605158
  var valid_605159 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605159 = validateParameter(valid_605159, JString, required = false,
                                 default = nil)
  if valid_605159 != nil:
    section.add "X-Amz-Content-Sha256", valid_605159
  var valid_605160 = header.getOrDefault("X-Amz-Algorithm")
  valid_605160 = validateParameter(valid_605160, JString, required = false,
                                 default = nil)
  if valid_605160 != nil:
    section.add "X-Amz-Algorithm", valid_605160
  var valid_605161 = header.getOrDefault("X-Amz-Signature")
  valid_605161 = validateParameter(valid_605161, JString, required = false,
                                 default = nil)
  if valid_605161 != nil:
    section.add "X-Amz-Signature", valid_605161
  var valid_605162 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605162 = validateParameter(valid_605162, JString, required = false,
                                 default = nil)
  if valid_605162 != nil:
    section.add "X-Amz-SignedHeaders", valid_605162
  var valid_605163 = header.getOrDefault("X-Amz-Credential")
  valid_605163 = validateParameter(valid_605163, JString, required = false,
                                 default = nil)
  if valid_605163 != nil:
    section.add "X-Amz-Credential", valid_605163
  result.add "header", section
  ## parameters in `formData` object:
  ##   TableRestoreRequestId: JString
  ##                        : The identifier of the table restore request to return status for. If you don't specify a <code>TableRestoreRequestId</code> value, then <code>DescribeTableRestoreStatus</code> returns the status of all in-progress table restore requests.
  ##   Marker: JString
  ##         : An optional pagination token provided by a previous <code>DescribeTableRestoreStatus</code> request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by the <code>MaxRecords</code> parameter.
  ##   ClusterIdentifier: JString
  ##                    : The Amazon Redshift cluster that the table is being restored to.
  ##   MaxRecords: JInt
  ##             : The maximum number of records to include in the response. If more records exist than the specified <code>MaxRecords</code> value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.
  section = newJObject()
  var valid_605164 = formData.getOrDefault("TableRestoreRequestId")
  valid_605164 = validateParameter(valid_605164, JString, required = false,
                                 default = nil)
  if valid_605164 != nil:
    section.add "TableRestoreRequestId", valid_605164
  var valid_605165 = formData.getOrDefault("Marker")
  valid_605165 = validateParameter(valid_605165, JString, required = false,
                                 default = nil)
  if valid_605165 != nil:
    section.add "Marker", valid_605165
  var valid_605166 = formData.getOrDefault("ClusterIdentifier")
  valid_605166 = validateParameter(valid_605166, JString, required = false,
                                 default = nil)
  if valid_605166 != nil:
    section.add "ClusterIdentifier", valid_605166
  var valid_605167 = formData.getOrDefault("MaxRecords")
  valid_605167 = validateParameter(valid_605167, JInt, required = false, default = nil)
  if valid_605167 != nil:
    section.add "MaxRecords", valid_605167
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_605168: Call_PostDescribeTableRestoreStatus_605152; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the status of one or more table restore requests made using the <a>RestoreTableFromClusterSnapshot</a> API action. If you don't specify a value for the <code>TableRestoreRequestId</code> parameter, then <code>DescribeTableRestoreStatus</code> returns the status of all table restore requests ordered by the date and time of the request in ascending order. Otherwise <code>DescribeTableRestoreStatus</code> returns the status of the table specified by <code>TableRestoreRequestId</code>.
  ## 
  let valid = call_605168.validator(path, query, header, formData, body)
  let scheme = call_605168.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605168.url(scheme.get, call_605168.host, call_605168.base,
                         call_605168.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_605168, url, valid)

proc call*(call_605169: Call_PostDescribeTableRestoreStatus_605152;
          TableRestoreRequestId: string = ""; Marker: string = "";
          Action: string = "DescribeTableRestoreStatus";
          ClusterIdentifier: string = ""; MaxRecords: int = 0;
          Version: string = "2012-12-01"): Recallable =
  ## postDescribeTableRestoreStatus
  ## Lists the status of one or more table restore requests made using the <a>RestoreTableFromClusterSnapshot</a> API action. If you don't specify a value for the <code>TableRestoreRequestId</code> parameter, then <code>DescribeTableRestoreStatus</code> returns the status of all table restore requests ordered by the date and time of the request in ascending order. Otherwise <code>DescribeTableRestoreStatus</code> returns the status of the table specified by <code>TableRestoreRequestId</code>.
  ##   TableRestoreRequestId: string
  ##                        : The identifier of the table restore request to return status for. If you don't specify a <code>TableRestoreRequestId</code> value, then <code>DescribeTableRestoreStatus</code> returns the status of all in-progress table restore requests.
  ##   Marker: string
  ##         : An optional pagination token provided by a previous <code>DescribeTableRestoreStatus</code> request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by the <code>MaxRecords</code> parameter.
  ##   Action: string (required)
  ##   ClusterIdentifier: string
  ##                    : The Amazon Redshift cluster that the table is being restored to.
  ##   MaxRecords: int
  ##             : The maximum number of records to include in the response. If more records exist than the specified <code>MaxRecords</code> value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.
  ##   Version: string (required)
  var query_605170 = newJObject()
  var formData_605171 = newJObject()
  add(formData_605171, "TableRestoreRequestId", newJString(TableRestoreRequestId))
  add(formData_605171, "Marker", newJString(Marker))
  add(query_605170, "Action", newJString(Action))
  add(formData_605171, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_605171, "MaxRecords", newJInt(MaxRecords))
  add(query_605170, "Version", newJString(Version))
  result = call_605169.call(nil, query_605170, nil, formData_605171, nil)

var postDescribeTableRestoreStatus* = Call_PostDescribeTableRestoreStatus_605152(
    name: "postDescribeTableRestoreStatus", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeTableRestoreStatus",
    validator: validate_PostDescribeTableRestoreStatus_605153, base: "/",
    url: url_PostDescribeTableRestoreStatus_605154,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeTableRestoreStatus_605133 = ref object of OpenApiRestCall_602450
proc url_GetDescribeTableRestoreStatus_605135(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetDescribeTableRestoreStatus_605134(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists the status of one or more table restore requests made using the <a>RestoreTableFromClusterSnapshot</a> API action. If you don't specify a value for the <code>TableRestoreRequestId</code> parameter, then <code>DescribeTableRestoreStatus</code> returns the status of all table restore requests ordered by the date and time of the request in ascending order. Otherwise <code>DescribeTableRestoreStatus</code> returns the status of the table specified by <code>TableRestoreRequestId</code>.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   MaxRecords: JInt
  ##             : The maximum number of records to include in the response. If more records exist than the specified <code>MaxRecords</code> value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString
  ##                    : The Amazon Redshift cluster that the table is being restored to.
  ##   Marker: JString
  ##         : An optional pagination token provided by a previous <code>DescribeTableRestoreStatus</code> request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by the <code>MaxRecords</code> parameter.
  ##   Version: JString (required)
  ##   TableRestoreRequestId: JString
  ##                        : The identifier of the table restore request to return status for. If you don't specify a <code>TableRestoreRequestId</code> value, then <code>DescribeTableRestoreStatus</code> returns the status of all in-progress table restore requests.
  section = newJObject()
  var valid_605136 = query.getOrDefault("MaxRecords")
  valid_605136 = validateParameter(valid_605136, JInt, required = false, default = nil)
  if valid_605136 != nil:
    section.add "MaxRecords", valid_605136
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_605137 = query.getOrDefault("Action")
  valid_605137 = validateParameter(valid_605137, JString, required = true, default = newJString(
      "DescribeTableRestoreStatus"))
  if valid_605137 != nil:
    section.add "Action", valid_605137
  var valid_605138 = query.getOrDefault("ClusterIdentifier")
  valid_605138 = validateParameter(valid_605138, JString, required = false,
                                 default = nil)
  if valid_605138 != nil:
    section.add "ClusterIdentifier", valid_605138
  var valid_605139 = query.getOrDefault("Marker")
  valid_605139 = validateParameter(valid_605139, JString, required = false,
                                 default = nil)
  if valid_605139 != nil:
    section.add "Marker", valid_605139
  var valid_605140 = query.getOrDefault("Version")
  valid_605140 = validateParameter(valid_605140, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_605140 != nil:
    section.add "Version", valid_605140
  var valid_605141 = query.getOrDefault("TableRestoreRequestId")
  valid_605141 = validateParameter(valid_605141, JString, required = false,
                                 default = nil)
  if valid_605141 != nil:
    section.add "TableRestoreRequestId", valid_605141
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_605142 = header.getOrDefault("X-Amz-Date")
  valid_605142 = validateParameter(valid_605142, JString, required = false,
                                 default = nil)
  if valid_605142 != nil:
    section.add "X-Amz-Date", valid_605142
  var valid_605143 = header.getOrDefault("X-Amz-Security-Token")
  valid_605143 = validateParameter(valid_605143, JString, required = false,
                                 default = nil)
  if valid_605143 != nil:
    section.add "X-Amz-Security-Token", valid_605143
  var valid_605144 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605144 = validateParameter(valid_605144, JString, required = false,
                                 default = nil)
  if valid_605144 != nil:
    section.add "X-Amz-Content-Sha256", valid_605144
  var valid_605145 = header.getOrDefault("X-Amz-Algorithm")
  valid_605145 = validateParameter(valid_605145, JString, required = false,
                                 default = nil)
  if valid_605145 != nil:
    section.add "X-Amz-Algorithm", valid_605145
  var valid_605146 = header.getOrDefault("X-Amz-Signature")
  valid_605146 = validateParameter(valid_605146, JString, required = false,
                                 default = nil)
  if valid_605146 != nil:
    section.add "X-Amz-Signature", valid_605146
  var valid_605147 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605147 = validateParameter(valid_605147, JString, required = false,
                                 default = nil)
  if valid_605147 != nil:
    section.add "X-Amz-SignedHeaders", valid_605147
  var valid_605148 = header.getOrDefault("X-Amz-Credential")
  valid_605148 = validateParameter(valid_605148, JString, required = false,
                                 default = nil)
  if valid_605148 != nil:
    section.add "X-Amz-Credential", valid_605148
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_605149: Call_GetDescribeTableRestoreStatus_605133; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the status of one or more table restore requests made using the <a>RestoreTableFromClusterSnapshot</a> API action. If you don't specify a value for the <code>TableRestoreRequestId</code> parameter, then <code>DescribeTableRestoreStatus</code> returns the status of all table restore requests ordered by the date and time of the request in ascending order. Otherwise <code>DescribeTableRestoreStatus</code> returns the status of the table specified by <code>TableRestoreRequestId</code>.
  ## 
  let valid = call_605149.validator(path, query, header, formData, body)
  let scheme = call_605149.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605149.url(scheme.get, call_605149.host, call_605149.base,
                         call_605149.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_605149, url, valid)

proc call*(call_605150: Call_GetDescribeTableRestoreStatus_605133;
          MaxRecords: int = 0; Action: string = "DescribeTableRestoreStatus";
          ClusterIdentifier: string = ""; Marker: string = "";
          Version: string = "2012-12-01"; TableRestoreRequestId: string = ""): Recallable =
  ## getDescribeTableRestoreStatus
  ## Lists the status of one or more table restore requests made using the <a>RestoreTableFromClusterSnapshot</a> API action. If you don't specify a value for the <code>TableRestoreRequestId</code> parameter, then <code>DescribeTableRestoreStatus</code> returns the status of all table restore requests ordered by the date and time of the request in ascending order. Otherwise <code>DescribeTableRestoreStatus</code> returns the status of the table specified by <code>TableRestoreRequestId</code>.
  ##   MaxRecords: int
  ##             : The maximum number of records to include in the response. If more records exist than the specified <code>MaxRecords</code> value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.
  ##   Action: string (required)
  ##   ClusterIdentifier: string
  ##                    : The Amazon Redshift cluster that the table is being restored to.
  ##   Marker: string
  ##         : An optional pagination token provided by a previous <code>DescribeTableRestoreStatus</code> request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by the <code>MaxRecords</code> parameter.
  ##   Version: string (required)
  ##   TableRestoreRequestId: string
  ##                        : The identifier of the table restore request to return status for. If you don't specify a <code>TableRestoreRequestId</code> value, then <code>DescribeTableRestoreStatus</code> returns the status of all in-progress table restore requests.
  var query_605151 = newJObject()
  add(query_605151, "MaxRecords", newJInt(MaxRecords))
  add(query_605151, "Action", newJString(Action))
  add(query_605151, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_605151, "Marker", newJString(Marker))
  add(query_605151, "Version", newJString(Version))
  add(query_605151, "TableRestoreRequestId", newJString(TableRestoreRequestId))
  result = call_605150.call(nil, query_605151, nil, nil, nil)

var getDescribeTableRestoreStatus* = Call_GetDescribeTableRestoreStatus_605133(
    name: "getDescribeTableRestoreStatus", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeTableRestoreStatus",
    validator: validate_GetDescribeTableRestoreStatus_605134, base: "/",
    url: url_GetDescribeTableRestoreStatus_605135,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeTags_605193 = ref object of OpenApiRestCall_602450
proc url_PostDescribeTags_605195(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostDescribeTags_605194(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## <p>Returns a list of tags. You can return tags from a specific resource by specifying an ARN, or you can return all tags for a given type of resource, such as clusters, snapshots, and so on.</p> <p>The following are limitations for <code>DescribeTags</code>: </p> <ul> <li> <p>You cannot specify an ARN and a resource-type value together in the same request.</p> </li> <li> <p>You cannot use the <code>MaxRecords</code> and <code>Marker</code> parameters together with the ARN parameter.</p> </li> <li> <p>The <code>MaxRecords</code> parameter can be a range from 10 to 50 results to return in a request.</p> </li> </ul> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all resources that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all resources that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, resources are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_605196 = query.getOrDefault("Action")
  valid_605196 = validateParameter(valid_605196, JString, required = true,
                                 default = newJString("DescribeTags"))
  if valid_605196 != nil:
    section.add "Action", valid_605196
  var valid_605197 = query.getOrDefault("Version")
  valid_605197 = validateParameter(valid_605197, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_605197 != nil:
    section.add "Version", valid_605197
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_605198 = header.getOrDefault("X-Amz-Date")
  valid_605198 = validateParameter(valid_605198, JString, required = false,
                                 default = nil)
  if valid_605198 != nil:
    section.add "X-Amz-Date", valid_605198
  var valid_605199 = header.getOrDefault("X-Amz-Security-Token")
  valid_605199 = validateParameter(valid_605199, JString, required = false,
                                 default = nil)
  if valid_605199 != nil:
    section.add "X-Amz-Security-Token", valid_605199
  var valid_605200 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605200 = validateParameter(valid_605200, JString, required = false,
                                 default = nil)
  if valid_605200 != nil:
    section.add "X-Amz-Content-Sha256", valid_605200
  var valid_605201 = header.getOrDefault("X-Amz-Algorithm")
  valid_605201 = validateParameter(valid_605201, JString, required = false,
                                 default = nil)
  if valid_605201 != nil:
    section.add "X-Amz-Algorithm", valid_605201
  var valid_605202 = header.getOrDefault("X-Amz-Signature")
  valid_605202 = validateParameter(valid_605202, JString, required = false,
                                 default = nil)
  if valid_605202 != nil:
    section.add "X-Amz-Signature", valid_605202
  var valid_605203 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605203 = validateParameter(valid_605203, JString, required = false,
                                 default = nil)
  if valid_605203 != nil:
    section.add "X-Amz-SignedHeaders", valid_605203
  var valid_605204 = header.getOrDefault("X-Amz-Credential")
  valid_605204 = validateParameter(valid_605204, JString, required = false,
                                 default = nil)
  if valid_605204 != nil:
    section.add "X-Amz-Credential", valid_605204
  result.add "header", section
  ## parameters in `formData` object:
  ##   Marker: JString
  ##         : A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned marker value in the <code>marker</code> parameter and retrying the command. If the <code>marker</code> field is empty, all response records have been retrieved for the request. 
  ##   ResourceType: JString
  ##               : <p>The type of resource with which you want to view tags. Valid resource types are: </p> <ul> <li> <p>Cluster</p> </li> <li> <p>CIDR/IP</p> </li> <li> <p>EC2 security group</p> </li> <li> <p>Snapshot</p> </li> <li> <p>Cluster security group</p> </li> <li> <p>Subnet group</p> </li> <li> <p>HSM connection</p> </li> <li> <p>HSM certificate</p> </li> <li> <p>Parameter group</p> </li> <li> <p>Snapshot copy grant</p> </li> </ul> <p>For more information about Amazon Redshift resource types and constructing ARNs, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-overview.html#redshift-iam-access-control-specify-actions">Specifying Policy Elements: Actions, Effects, Resources, and Principals</a> in the Amazon Redshift Cluster Management Guide. </p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching resources that are associated with the specified key or keys. For example, suppose that you have resources tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with all resources that have either or both of these tag keys associated with them.
  ##   ResourceName: JString
  ##               : The Amazon Resource Name (ARN) for which you want to describe the tag or tags. For example, <code>arn:aws:redshift:us-east-1:123456789:cluster:t1</code>. 
  ##   MaxRecords: JInt
  ##             : The maximum number or response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned <code>marker</code> value. 
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching resources that are associated with the specified value or values. For example, suppose that you have resources tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with all resources that have either or both of these tag values associated with them.
  section = newJObject()
  var valid_605205 = formData.getOrDefault("Marker")
  valid_605205 = validateParameter(valid_605205, JString, required = false,
                                 default = nil)
  if valid_605205 != nil:
    section.add "Marker", valid_605205
  var valid_605206 = formData.getOrDefault("ResourceType")
  valid_605206 = validateParameter(valid_605206, JString, required = false,
                                 default = nil)
  if valid_605206 != nil:
    section.add "ResourceType", valid_605206
  var valid_605207 = formData.getOrDefault("TagKeys")
  valid_605207 = validateParameter(valid_605207, JArray, required = false,
                                 default = nil)
  if valid_605207 != nil:
    section.add "TagKeys", valid_605207
  var valid_605208 = formData.getOrDefault("ResourceName")
  valid_605208 = validateParameter(valid_605208, JString, required = false,
                                 default = nil)
  if valid_605208 != nil:
    section.add "ResourceName", valid_605208
  var valid_605209 = formData.getOrDefault("MaxRecords")
  valid_605209 = validateParameter(valid_605209, JInt, required = false, default = nil)
  if valid_605209 != nil:
    section.add "MaxRecords", valid_605209
  var valid_605210 = formData.getOrDefault("TagValues")
  valid_605210 = validateParameter(valid_605210, JArray, required = false,
                                 default = nil)
  if valid_605210 != nil:
    section.add "TagValues", valid_605210
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_605211: Call_PostDescribeTags_605193; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns a list of tags. You can return tags from a specific resource by specifying an ARN, or you can return all tags for a given type of resource, such as clusters, snapshots, and so on.</p> <p>The following are limitations for <code>DescribeTags</code>: </p> <ul> <li> <p>You cannot specify an ARN and a resource-type value together in the same request.</p> </li> <li> <p>You cannot use the <code>MaxRecords</code> and <code>Marker</code> parameters together with the ARN parameter.</p> </li> <li> <p>The <code>MaxRecords</code> parameter can be a range from 10 to 50 results to return in a request.</p> </li> </ul> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all resources that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all resources that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, resources are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_605211.validator(path, query, header, formData, body)
  let scheme = call_605211.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605211.url(scheme.get, call_605211.host, call_605211.base,
                         call_605211.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_605211, url, valid)

proc call*(call_605212: Call_PostDescribeTags_605193; Marker: string = "";
          Action: string = "DescribeTags"; ResourceType: string = "";
          TagKeys: JsonNode = nil; ResourceName: string = ""; MaxRecords: int = 0;
          TagValues: JsonNode = nil; Version: string = "2012-12-01"): Recallable =
  ## postDescribeTags
  ## <p>Returns a list of tags. You can return tags from a specific resource by specifying an ARN, or you can return all tags for a given type of resource, such as clusters, snapshots, and so on.</p> <p>The following are limitations for <code>DescribeTags</code>: </p> <ul> <li> <p>You cannot specify an ARN and a resource-type value together in the same request.</p> </li> <li> <p>You cannot use the <code>MaxRecords</code> and <code>Marker</code> parameters together with the ARN parameter.</p> </li> <li> <p>The <code>MaxRecords</code> parameter can be a range from 10 to 50 results to return in a request.</p> </li> </ul> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all resources that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all resources that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, resources are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   Marker: string
  ##         : A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned marker value in the <code>marker</code> parameter and retrying the command. If the <code>marker</code> field is empty, all response records have been retrieved for the request. 
  ##   Action: string (required)
  ##   ResourceType: string
  ##               : <p>The type of resource with which you want to view tags. Valid resource types are: </p> <ul> <li> <p>Cluster</p> </li> <li> <p>CIDR/IP</p> </li> <li> <p>EC2 security group</p> </li> <li> <p>Snapshot</p> </li> <li> <p>Cluster security group</p> </li> <li> <p>Subnet group</p> </li> <li> <p>HSM connection</p> </li> <li> <p>HSM certificate</p> </li> <li> <p>Parameter group</p> </li> <li> <p>Snapshot copy grant</p> </li> </ul> <p>For more information about Amazon Redshift resource types and constructing ARNs, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-overview.html#redshift-iam-access-control-specify-actions">Specifying Policy Elements: Actions, Effects, Resources, and Principals</a> in the Amazon Redshift Cluster Management Guide. </p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching resources that are associated with the specified key or keys. For example, suppose that you have resources tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with all resources that have either or both of these tag keys associated with them.
  ##   ResourceName: string
  ##               : The Amazon Resource Name (ARN) for which you want to describe the tag or tags. For example, <code>arn:aws:redshift:us-east-1:123456789:cluster:t1</code>. 
  ##   MaxRecords: int
  ##             : The maximum number or response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned <code>marker</code> value. 
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching resources that are associated with the specified value or values. For example, suppose that you have resources tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with all resources that have either or both of these tag values associated with them.
  ##   Version: string (required)
  var query_605213 = newJObject()
  var formData_605214 = newJObject()
  add(formData_605214, "Marker", newJString(Marker))
  add(query_605213, "Action", newJString(Action))
  add(formData_605214, "ResourceType", newJString(ResourceType))
  if TagKeys != nil:
    formData_605214.add "TagKeys", TagKeys
  add(formData_605214, "ResourceName", newJString(ResourceName))
  add(formData_605214, "MaxRecords", newJInt(MaxRecords))
  if TagValues != nil:
    formData_605214.add "TagValues", TagValues
  add(query_605213, "Version", newJString(Version))
  result = call_605212.call(nil, query_605213, nil, formData_605214, nil)

var postDescribeTags* = Call_PostDescribeTags_605193(name: "postDescribeTags",
    meth: HttpMethod.HttpPost, host: "redshift.amazonaws.com",
    route: "/#Action=DescribeTags", validator: validate_PostDescribeTags_605194,
    base: "/", url: url_PostDescribeTags_605195,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeTags_605172 = ref object of OpenApiRestCall_602450
proc url_GetDescribeTags_605174(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetDescribeTags_605173(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## <p>Returns a list of tags. You can return tags from a specific resource by specifying an ARN, or you can return all tags for a given type of resource, such as clusters, snapshots, and so on.</p> <p>The following are limitations for <code>DescribeTags</code>: </p> <ul> <li> <p>You cannot specify an ARN and a resource-type value together in the same request.</p> </li> <li> <p>You cannot use the <code>MaxRecords</code> and <code>Marker</code> parameters together with the ARN parameter.</p> </li> <li> <p>The <code>MaxRecords</code> parameter can be a range from 10 to 50 results to return in a request.</p> </li> </ul> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all resources that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all resources that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, resources are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching resources that are associated with the specified value or values. For example, suppose that you have resources tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with all resources that have either or both of these tag values associated with them.
  ##   MaxRecords: JInt
  ##             : The maximum number or response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned <code>marker</code> value. 
  ##   ResourceName: JString
  ##               : The Amazon Resource Name (ARN) for which you want to describe the tag or tags. For example, <code>arn:aws:redshift:us-east-1:123456789:cluster:t1</code>. 
  ##   Action: JString (required)
  ##   Marker: JString
  ##         : A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned marker value in the <code>marker</code> parameter and retrying the command. If the <code>marker</code> field is empty, all response records have been retrieved for the request. 
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching resources that are associated with the specified key or keys. For example, suppose that you have resources tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with all resources that have either or both of these tag keys associated with them.
  ##   ResourceType: JString
  ##               : <p>The type of resource with which you want to view tags. Valid resource types are: </p> <ul> <li> <p>Cluster</p> </li> <li> <p>CIDR/IP</p> </li> <li> <p>EC2 security group</p> </li> <li> <p>Snapshot</p> </li> <li> <p>Cluster security group</p> </li> <li> <p>Subnet group</p> </li> <li> <p>HSM connection</p> </li> <li> <p>HSM certificate</p> </li> <li> <p>Parameter group</p> </li> <li> <p>Snapshot copy grant</p> </li> </ul> <p>For more information about Amazon Redshift resource types and constructing ARNs, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-overview.html#redshift-iam-access-control-specify-actions">Specifying Policy Elements: Actions, Effects, Resources, and Principals</a> in the Amazon Redshift Cluster Management Guide. </p>
  ##   Version: JString (required)
  section = newJObject()
  var valid_605175 = query.getOrDefault("TagValues")
  valid_605175 = validateParameter(valid_605175, JArray, required = false,
                                 default = nil)
  if valid_605175 != nil:
    section.add "TagValues", valid_605175
  var valid_605176 = query.getOrDefault("MaxRecords")
  valid_605176 = validateParameter(valid_605176, JInt, required = false, default = nil)
  if valid_605176 != nil:
    section.add "MaxRecords", valid_605176
  var valid_605177 = query.getOrDefault("ResourceName")
  valid_605177 = validateParameter(valid_605177, JString, required = false,
                                 default = nil)
  if valid_605177 != nil:
    section.add "ResourceName", valid_605177
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_605178 = query.getOrDefault("Action")
  valid_605178 = validateParameter(valid_605178, JString, required = true,
                                 default = newJString("DescribeTags"))
  if valid_605178 != nil:
    section.add "Action", valid_605178
  var valid_605179 = query.getOrDefault("Marker")
  valid_605179 = validateParameter(valid_605179, JString, required = false,
                                 default = nil)
  if valid_605179 != nil:
    section.add "Marker", valid_605179
  var valid_605180 = query.getOrDefault("TagKeys")
  valid_605180 = validateParameter(valid_605180, JArray, required = false,
                                 default = nil)
  if valid_605180 != nil:
    section.add "TagKeys", valid_605180
  var valid_605181 = query.getOrDefault("ResourceType")
  valid_605181 = validateParameter(valid_605181, JString, required = false,
                                 default = nil)
  if valid_605181 != nil:
    section.add "ResourceType", valid_605181
  var valid_605182 = query.getOrDefault("Version")
  valid_605182 = validateParameter(valid_605182, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_605182 != nil:
    section.add "Version", valid_605182
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_605183 = header.getOrDefault("X-Amz-Date")
  valid_605183 = validateParameter(valid_605183, JString, required = false,
                                 default = nil)
  if valid_605183 != nil:
    section.add "X-Amz-Date", valid_605183
  var valid_605184 = header.getOrDefault("X-Amz-Security-Token")
  valid_605184 = validateParameter(valid_605184, JString, required = false,
                                 default = nil)
  if valid_605184 != nil:
    section.add "X-Amz-Security-Token", valid_605184
  var valid_605185 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605185 = validateParameter(valid_605185, JString, required = false,
                                 default = nil)
  if valid_605185 != nil:
    section.add "X-Amz-Content-Sha256", valid_605185
  var valid_605186 = header.getOrDefault("X-Amz-Algorithm")
  valid_605186 = validateParameter(valid_605186, JString, required = false,
                                 default = nil)
  if valid_605186 != nil:
    section.add "X-Amz-Algorithm", valid_605186
  var valid_605187 = header.getOrDefault("X-Amz-Signature")
  valid_605187 = validateParameter(valid_605187, JString, required = false,
                                 default = nil)
  if valid_605187 != nil:
    section.add "X-Amz-Signature", valid_605187
  var valid_605188 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605188 = validateParameter(valid_605188, JString, required = false,
                                 default = nil)
  if valid_605188 != nil:
    section.add "X-Amz-SignedHeaders", valid_605188
  var valid_605189 = header.getOrDefault("X-Amz-Credential")
  valid_605189 = validateParameter(valid_605189, JString, required = false,
                                 default = nil)
  if valid_605189 != nil:
    section.add "X-Amz-Credential", valid_605189
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_605190: Call_GetDescribeTags_605172; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns a list of tags. You can return tags from a specific resource by specifying an ARN, or you can return all tags for a given type of resource, such as clusters, snapshots, and so on.</p> <p>The following are limitations for <code>DescribeTags</code>: </p> <ul> <li> <p>You cannot specify an ARN and a resource-type value together in the same request.</p> </li> <li> <p>You cannot use the <code>MaxRecords</code> and <code>Marker</code> parameters together with the ARN parameter.</p> </li> <li> <p>The <code>MaxRecords</code> parameter can be a range from 10 to 50 results to return in a request.</p> </li> </ul> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all resources that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all resources that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, resources are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_605190.validator(path, query, header, formData, body)
  let scheme = call_605190.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605190.url(scheme.get, call_605190.host, call_605190.base,
                         call_605190.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_605190, url, valid)

proc call*(call_605191: Call_GetDescribeTags_605172; TagValues: JsonNode = nil;
          MaxRecords: int = 0; ResourceName: string = "";
          Action: string = "DescribeTags"; Marker: string = ""; TagKeys: JsonNode = nil;
          ResourceType: string = ""; Version: string = "2012-12-01"): Recallable =
  ## getDescribeTags
  ## <p>Returns a list of tags. You can return tags from a specific resource by specifying an ARN, or you can return all tags for a given type of resource, such as clusters, snapshots, and so on.</p> <p>The following are limitations for <code>DescribeTags</code>: </p> <ul> <li> <p>You cannot specify an ARN and a resource-type value together in the same request.</p> </li> <li> <p>You cannot use the <code>MaxRecords</code> and <code>Marker</code> parameters together with the ARN parameter.</p> </li> <li> <p>The <code>MaxRecords</code> parameter can be a range from 10 to 50 results to return in a request.</p> </li> </ul> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all resources that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all resources that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, resources are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching resources that are associated with the specified value or values. For example, suppose that you have resources tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with all resources that have either or both of these tag values associated with them.
  ##   MaxRecords: int
  ##             : The maximum number or response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned <code>marker</code> value. 
  ##   ResourceName: string
  ##               : The Amazon Resource Name (ARN) for which you want to describe the tag or tags. For example, <code>arn:aws:redshift:us-east-1:123456789:cluster:t1</code>. 
  ##   Action: string (required)
  ##   Marker: string
  ##         : A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned marker value in the <code>marker</code> parameter and retrying the command. If the <code>marker</code> field is empty, all response records have been retrieved for the request. 
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching resources that are associated with the specified key or keys. For example, suppose that you have resources tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with all resources that have either or both of these tag keys associated with them.
  ##   ResourceType: string
  ##               : <p>The type of resource with which you want to view tags. Valid resource types are: </p> <ul> <li> <p>Cluster</p> </li> <li> <p>CIDR/IP</p> </li> <li> <p>EC2 security group</p> </li> <li> <p>Snapshot</p> </li> <li> <p>Cluster security group</p> </li> <li> <p>Subnet group</p> </li> <li> <p>HSM connection</p> </li> <li> <p>HSM certificate</p> </li> <li> <p>Parameter group</p> </li> <li> <p>Snapshot copy grant</p> </li> </ul> <p>For more information about Amazon Redshift resource types and constructing ARNs, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-overview.html#redshift-iam-access-control-specify-actions">Specifying Policy Elements: Actions, Effects, Resources, and Principals</a> in the Amazon Redshift Cluster Management Guide. </p>
  ##   Version: string (required)
  var query_605192 = newJObject()
  if TagValues != nil:
    query_605192.add "TagValues", TagValues
  add(query_605192, "MaxRecords", newJInt(MaxRecords))
  add(query_605192, "ResourceName", newJString(ResourceName))
  add(query_605192, "Action", newJString(Action))
  add(query_605192, "Marker", newJString(Marker))
  if TagKeys != nil:
    query_605192.add "TagKeys", TagKeys
  add(query_605192, "ResourceType", newJString(ResourceType))
  add(query_605192, "Version", newJString(Version))
  result = call_605191.call(nil, query_605192, nil, nil, nil)

var getDescribeTags* = Call_GetDescribeTags_605172(name: "getDescribeTags",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=DescribeTags", validator: validate_GetDescribeTags_605173,
    base: "/", url: url_GetDescribeTags_605174, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDisableLogging_605231 = ref object of OpenApiRestCall_602450
proc url_PostDisableLogging_605233(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostDisableLogging_605232(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Stops logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_605234 = query.getOrDefault("Action")
  valid_605234 = validateParameter(valid_605234, JString, required = true,
                                 default = newJString("DisableLogging"))
  if valid_605234 != nil:
    section.add "Action", valid_605234
  var valid_605235 = query.getOrDefault("Version")
  valid_605235 = validateParameter(valid_605235, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_605235 != nil:
    section.add "Version", valid_605235
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_605236 = header.getOrDefault("X-Amz-Date")
  valid_605236 = validateParameter(valid_605236, JString, required = false,
                                 default = nil)
  if valid_605236 != nil:
    section.add "X-Amz-Date", valid_605236
  var valid_605237 = header.getOrDefault("X-Amz-Security-Token")
  valid_605237 = validateParameter(valid_605237, JString, required = false,
                                 default = nil)
  if valid_605237 != nil:
    section.add "X-Amz-Security-Token", valid_605237
  var valid_605238 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605238 = validateParameter(valid_605238, JString, required = false,
                                 default = nil)
  if valid_605238 != nil:
    section.add "X-Amz-Content-Sha256", valid_605238
  var valid_605239 = header.getOrDefault("X-Amz-Algorithm")
  valid_605239 = validateParameter(valid_605239, JString, required = false,
                                 default = nil)
  if valid_605239 != nil:
    section.add "X-Amz-Algorithm", valid_605239
  var valid_605240 = header.getOrDefault("X-Amz-Signature")
  valid_605240 = validateParameter(valid_605240, JString, required = false,
                                 default = nil)
  if valid_605240 != nil:
    section.add "X-Amz-Signature", valid_605240
  var valid_605241 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605241 = validateParameter(valid_605241, JString, required = false,
                                 default = nil)
  if valid_605241 != nil:
    section.add "X-Amz-SignedHeaders", valid_605241
  var valid_605242 = header.getOrDefault("X-Amz-Credential")
  valid_605242 = validateParameter(valid_605242, JString, required = false,
                                 default = nil)
  if valid_605242 != nil:
    section.add "X-Amz-Credential", valid_605242
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The identifier of the cluster on which logging is to be stopped.</p> <p>Example: <code>examplecluster</code> </p>
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_605243 = formData.getOrDefault("ClusterIdentifier")
  valid_605243 = validateParameter(valid_605243, JString, required = true,
                                 default = nil)
  if valid_605243 != nil:
    section.add "ClusterIdentifier", valid_605243
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_605244: Call_PostDisableLogging_605231; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Stops logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
  ## 
  let valid = call_605244.validator(path, query, header, formData, body)
  let scheme = call_605244.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605244.url(scheme.get, call_605244.host, call_605244.base,
                         call_605244.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_605244, url, valid)

proc call*(call_605245: Call_PostDisableLogging_605231; ClusterIdentifier: string;
          Action: string = "DisableLogging"; Version: string = "2012-12-01"): Recallable =
  ## postDisableLogging
  ## Stops logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The identifier of the cluster on which logging is to be stopped.</p> <p>Example: <code>examplecluster</code> </p>
  ##   Version: string (required)
  var query_605246 = newJObject()
  var formData_605247 = newJObject()
  add(query_605246, "Action", newJString(Action))
  add(formData_605247, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_605246, "Version", newJString(Version))
  result = call_605245.call(nil, query_605246, nil, formData_605247, nil)

var postDisableLogging* = Call_PostDisableLogging_605231(
    name: "postDisableLogging", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DisableLogging",
    validator: validate_PostDisableLogging_605232, base: "/",
    url: url_PostDisableLogging_605233, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDisableLogging_605215 = ref object of OpenApiRestCall_602450
proc url_GetDisableLogging_605217(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetDisableLogging_605216(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## Stops logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The identifier of the cluster on which logging is to be stopped.</p> <p>Example: <code>examplecluster</code> </p>
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_605218 = query.getOrDefault("Action")
  valid_605218 = validateParameter(valid_605218, JString, required = true,
                                 default = newJString("DisableLogging"))
  if valid_605218 != nil:
    section.add "Action", valid_605218
  var valid_605219 = query.getOrDefault("ClusterIdentifier")
  valid_605219 = validateParameter(valid_605219, JString, required = true,
                                 default = nil)
  if valid_605219 != nil:
    section.add "ClusterIdentifier", valid_605219
  var valid_605220 = query.getOrDefault("Version")
  valid_605220 = validateParameter(valid_605220, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_605220 != nil:
    section.add "Version", valid_605220
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_605221 = header.getOrDefault("X-Amz-Date")
  valid_605221 = validateParameter(valid_605221, JString, required = false,
                                 default = nil)
  if valid_605221 != nil:
    section.add "X-Amz-Date", valid_605221
  var valid_605222 = header.getOrDefault("X-Amz-Security-Token")
  valid_605222 = validateParameter(valid_605222, JString, required = false,
                                 default = nil)
  if valid_605222 != nil:
    section.add "X-Amz-Security-Token", valid_605222
  var valid_605223 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605223 = validateParameter(valid_605223, JString, required = false,
                                 default = nil)
  if valid_605223 != nil:
    section.add "X-Amz-Content-Sha256", valid_605223
  var valid_605224 = header.getOrDefault("X-Amz-Algorithm")
  valid_605224 = validateParameter(valid_605224, JString, required = false,
                                 default = nil)
  if valid_605224 != nil:
    section.add "X-Amz-Algorithm", valid_605224
  var valid_605225 = header.getOrDefault("X-Amz-Signature")
  valid_605225 = validateParameter(valid_605225, JString, required = false,
                                 default = nil)
  if valid_605225 != nil:
    section.add "X-Amz-Signature", valid_605225
  var valid_605226 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605226 = validateParameter(valid_605226, JString, required = false,
                                 default = nil)
  if valid_605226 != nil:
    section.add "X-Amz-SignedHeaders", valid_605226
  var valid_605227 = header.getOrDefault("X-Amz-Credential")
  valid_605227 = validateParameter(valid_605227, JString, required = false,
                                 default = nil)
  if valid_605227 != nil:
    section.add "X-Amz-Credential", valid_605227
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_605228: Call_GetDisableLogging_605215; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Stops logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
  ## 
  let valid = call_605228.validator(path, query, header, formData, body)
  let scheme = call_605228.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605228.url(scheme.get, call_605228.host, call_605228.base,
                         call_605228.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_605228, url, valid)

proc call*(call_605229: Call_GetDisableLogging_605215; ClusterIdentifier: string;
          Action: string = "DisableLogging"; Version: string = "2012-12-01"): Recallable =
  ## getDisableLogging
  ## Stops logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The identifier of the cluster on which logging is to be stopped.</p> <p>Example: <code>examplecluster</code> </p>
  ##   Version: string (required)
  var query_605230 = newJObject()
  add(query_605230, "Action", newJString(Action))
  add(query_605230, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_605230, "Version", newJString(Version))
  result = call_605229.call(nil, query_605230, nil, nil, nil)

var getDisableLogging* = Call_GetDisableLogging_605215(name: "getDisableLogging",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=DisableLogging", validator: validate_GetDisableLogging_605216,
    base: "/", url: url_GetDisableLogging_605217,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDisableSnapshotCopy_605264 = ref object of OpenApiRestCall_602450
proc url_PostDisableSnapshotCopy_605266(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostDisableSnapshotCopy_605265(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Disables the automatic copying of snapshots from one region to another region for a specified cluster.</p> <p>If your cluster and its snapshots are encrypted using a customer master key (CMK) from AWS KMS, use <a>DeleteSnapshotCopyGrant</a> to delete the grant that grants Amazon Redshift permission to the CMK in the destination region. </p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_605267 = query.getOrDefault("Action")
  valid_605267 = validateParameter(valid_605267, JString, required = true,
                                 default = newJString("DisableSnapshotCopy"))
  if valid_605267 != nil:
    section.add "Action", valid_605267
  var valid_605268 = query.getOrDefault("Version")
  valid_605268 = validateParameter(valid_605268, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_605268 != nil:
    section.add "Version", valid_605268
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_605269 = header.getOrDefault("X-Amz-Date")
  valid_605269 = validateParameter(valid_605269, JString, required = false,
                                 default = nil)
  if valid_605269 != nil:
    section.add "X-Amz-Date", valid_605269
  var valid_605270 = header.getOrDefault("X-Amz-Security-Token")
  valid_605270 = validateParameter(valid_605270, JString, required = false,
                                 default = nil)
  if valid_605270 != nil:
    section.add "X-Amz-Security-Token", valid_605270
  var valid_605271 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605271 = validateParameter(valid_605271, JString, required = false,
                                 default = nil)
  if valid_605271 != nil:
    section.add "X-Amz-Content-Sha256", valid_605271
  var valid_605272 = header.getOrDefault("X-Amz-Algorithm")
  valid_605272 = validateParameter(valid_605272, JString, required = false,
                                 default = nil)
  if valid_605272 != nil:
    section.add "X-Amz-Algorithm", valid_605272
  var valid_605273 = header.getOrDefault("X-Amz-Signature")
  valid_605273 = validateParameter(valid_605273, JString, required = false,
                                 default = nil)
  if valid_605273 != nil:
    section.add "X-Amz-Signature", valid_605273
  var valid_605274 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605274 = validateParameter(valid_605274, JString, required = false,
                                 default = nil)
  if valid_605274 != nil:
    section.add "X-Amz-SignedHeaders", valid_605274
  var valid_605275 = header.getOrDefault("X-Amz-Credential")
  valid_605275 = validateParameter(valid_605275, JString, required = false,
                                 default = nil)
  if valid_605275 != nil:
    section.add "X-Amz-Credential", valid_605275
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of the source cluster that you want to disable copying of snapshots to a destination region.</p> <p>Constraints: Must be the valid name of an existing cluster that has cross-region snapshot copy enabled.</p>
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_605276 = formData.getOrDefault("ClusterIdentifier")
  valid_605276 = validateParameter(valid_605276, JString, required = true,
                                 default = nil)
  if valid_605276 != nil:
    section.add "ClusterIdentifier", valid_605276
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_605277: Call_PostDisableSnapshotCopy_605264; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Disables the automatic copying of snapshots from one region to another region for a specified cluster.</p> <p>If your cluster and its snapshots are encrypted using a customer master key (CMK) from AWS KMS, use <a>DeleteSnapshotCopyGrant</a> to delete the grant that grants Amazon Redshift permission to the CMK in the destination region. </p>
  ## 
  let valid = call_605277.validator(path, query, header, formData, body)
  let scheme = call_605277.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605277.url(scheme.get, call_605277.host, call_605277.base,
                         call_605277.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_605277, url, valid)

proc call*(call_605278: Call_PostDisableSnapshotCopy_605264;
          ClusterIdentifier: string; Action: string = "DisableSnapshotCopy";
          Version: string = "2012-12-01"): Recallable =
  ## postDisableSnapshotCopy
  ## <p>Disables the automatic copying of snapshots from one region to another region for a specified cluster.</p> <p>If your cluster and its snapshots are encrypted using a customer master key (CMK) from AWS KMS, use <a>DeleteSnapshotCopyGrant</a> to delete the grant that grants Amazon Redshift permission to the CMK in the destination region. </p>
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of the source cluster that you want to disable copying of snapshots to a destination region.</p> <p>Constraints: Must be the valid name of an existing cluster that has cross-region snapshot copy enabled.</p>
  ##   Version: string (required)
  var query_605279 = newJObject()
  var formData_605280 = newJObject()
  add(query_605279, "Action", newJString(Action))
  add(formData_605280, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_605279, "Version", newJString(Version))
  result = call_605278.call(nil, query_605279, nil, formData_605280, nil)

var postDisableSnapshotCopy* = Call_PostDisableSnapshotCopy_605264(
    name: "postDisableSnapshotCopy", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DisableSnapshotCopy",
    validator: validate_PostDisableSnapshotCopy_605265, base: "/",
    url: url_PostDisableSnapshotCopy_605266, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDisableSnapshotCopy_605248 = ref object of OpenApiRestCall_602450
proc url_GetDisableSnapshotCopy_605250(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetDisableSnapshotCopy_605249(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Disables the automatic copying of snapshots from one region to another region for a specified cluster.</p> <p>If your cluster and its snapshots are encrypted using a customer master key (CMK) from AWS KMS, use <a>DeleteSnapshotCopyGrant</a> to delete the grant that grants Amazon Redshift permission to the CMK in the destination region. </p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of the source cluster that you want to disable copying of snapshots to a destination region.</p> <p>Constraints: Must be the valid name of an existing cluster that has cross-region snapshot copy enabled.</p>
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_605251 = query.getOrDefault("Action")
  valid_605251 = validateParameter(valid_605251, JString, required = true,
                                 default = newJString("DisableSnapshotCopy"))
  if valid_605251 != nil:
    section.add "Action", valid_605251
  var valid_605252 = query.getOrDefault("ClusterIdentifier")
  valid_605252 = validateParameter(valid_605252, JString, required = true,
                                 default = nil)
  if valid_605252 != nil:
    section.add "ClusterIdentifier", valid_605252
  var valid_605253 = query.getOrDefault("Version")
  valid_605253 = validateParameter(valid_605253, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_605253 != nil:
    section.add "Version", valid_605253
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_605254 = header.getOrDefault("X-Amz-Date")
  valid_605254 = validateParameter(valid_605254, JString, required = false,
                                 default = nil)
  if valid_605254 != nil:
    section.add "X-Amz-Date", valid_605254
  var valid_605255 = header.getOrDefault("X-Amz-Security-Token")
  valid_605255 = validateParameter(valid_605255, JString, required = false,
                                 default = nil)
  if valid_605255 != nil:
    section.add "X-Amz-Security-Token", valid_605255
  var valid_605256 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605256 = validateParameter(valid_605256, JString, required = false,
                                 default = nil)
  if valid_605256 != nil:
    section.add "X-Amz-Content-Sha256", valid_605256
  var valid_605257 = header.getOrDefault("X-Amz-Algorithm")
  valid_605257 = validateParameter(valid_605257, JString, required = false,
                                 default = nil)
  if valid_605257 != nil:
    section.add "X-Amz-Algorithm", valid_605257
  var valid_605258 = header.getOrDefault("X-Amz-Signature")
  valid_605258 = validateParameter(valid_605258, JString, required = false,
                                 default = nil)
  if valid_605258 != nil:
    section.add "X-Amz-Signature", valid_605258
  var valid_605259 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605259 = validateParameter(valid_605259, JString, required = false,
                                 default = nil)
  if valid_605259 != nil:
    section.add "X-Amz-SignedHeaders", valid_605259
  var valid_605260 = header.getOrDefault("X-Amz-Credential")
  valid_605260 = validateParameter(valid_605260, JString, required = false,
                                 default = nil)
  if valid_605260 != nil:
    section.add "X-Amz-Credential", valid_605260
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_605261: Call_GetDisableSnapshotCopy_605248; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Disables the automatic copying of snapshots from one region to another region for a specified cluster.</p> <p>If your cluster and its snapshots are encrypted using a customer master key (CMK) from AWS KMS, use <a>DeleteSnapshotCopyGrant</a> to delete the grant that grants Amazon Redshift permission to the CMK in the destination region. </p>
  ## 
  let valid = call_605261.validator(path, query, header, formData, body)
  let scheme = call_605261.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605261.url(scheme.get, call_605261.host, call_605261.base,
                         call_605261.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_605261, url, valid)

proc call*(call_605262: Call_GetDisableSnapshotCopy_605248;
          ClusterIdentifier: string; Action: string = "DisableSnapshotCopy";
          Version: string = "2012-12-01"): Recallable =
  ## getDisableSnapshotCopy
  ## <p>Disables the automatic copying of snapshots from one region to another region for a specified cluster.</p> <p>If your cluster and its snapshots are encrypted using a customer master key (CMK) from AWS KMS, use <a>DeleteSnapshotCopyGrant</a> to delete the grant that grants Amazon Redshift permission to the CMK in the destination region. </p>
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of the source cluster that you want to disable copying of snapshots to a destination region.</p> <p>Constraints: Must be the valid name of an existing cluster that has cross-region snapshot copy enabled.</p>
  ##   Version: string (required)
  var query_605263 = newJObject()
  add(query_605263, "Action", newJString(Action))
  add(query_605263, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_605263, "Version", newJString(Version))
  result = call_605262.call(nil, query_605263, nil, nil, nil)

var getDisableSnapshotCopy* = Call_GetDisableSnapshotCopy_605248(
    name: "getDisableSnapshotCopy", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DisableSnapshotCopy",
    validator: validate_GetDisableSnapshotCopy_605249, base: "/",
    url: url_GetDisableSnapshotCopy_605250, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostEnableLogging_605299 = ref object of OpenApiRestCall_602450
proc url_PostEnableLogging_605301(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostEnableLogging_605300(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## Starts logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_605302 = query.getOrDefault("Action")
  valid_605302 = validateParameter(valid_605302, JString, required = true,
                                 default = newJString("EnableLogging"))
  if valid_605302 != nil:
    section.add "Action", valid_605302
  var valid_605303 = query.getOrDefault("Version")
  valid_605303 = validateParameter(valid_605303, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_605303 != nil:
    section.add "Version", valid_605303
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_605304 = header.getOrDefault("X-Amz-Date")
  valid_605304 = validateParameter(valid_605304, JString, required = false,
                                 default = nil)
  if valid_605304 != nil:
    section.add "X-Amz-Date", valid_605304
  var valid_605305 = header.getOrDefault("X-Amz-Security-Token")
  valid_605305 = validateParameter(valid_605305, JString, required = false,
                                 default = nil)
  if valid_605305 != nil:
    section.add "X-Amz-Security-Token", valid_605305
  var valid_605306 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605306 = validateParameter(valid_605306, JString, required = false,
                                 default = nil)
  if valid_605306 != nil:
    section.add "X-Amz-Content-Sha256", valid_605306
  var valid_605307 = header.getOrDefault("X-Amz-Algorithm")
  valid_605307 = validateParameter(valid_605307, JString, required = false,
                                 default = nil)
  if valid_605307 != nil:
    section.add "X-Amz-Algorithm", valid_605307
  var valid_605308 = header.getOrDefault("X-Amz-Signature")
  valid_605308 = validateParameter(valid_605308, JString, required = false,
                                 default = nil)
  if valid_605308 != nil:
    section.add "X-Amz-Signature", valid_605308
  var valid_605309 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605309 = validateParameter(valid_605309, JString, required = false,
                                 default = nil)
  if valid_605309 != nil:
    section.add "X-Amz-SignedHeaders", valid_605309
  var valid_605310 = header.getOrDefault("X-Amz-Credential")
  valid_605310 = validateParameter(valid_605310, JString, required = false,
                                 default = nil)
  if valid_605310 != nil:
    section.add "X-Amz-Credential", valid_605310
  result.add "header", section
  ## parameters in `formData` object:
  ##   S3KeyPrefix: JString
  ##              : <p>The prefix applied to the log file names.</p> <p>Constraints:</p> <ul> <li> <p>Cannot exceed 512 characters</p> </li> <li> <p>Cannot contain spaces( ), double quotes ("), single quotes ('), a backslash (\), or control characters. The hexadecimal codes for invalid characters are: </p> <ul> <li> <p>x00 to x20</p> </li> <li> <p>x22</p> </li> <li> <p>x27</p> </li> <li> <p>x5c</p> </li> <li> <p>x7f or larger</p> </li> </ul> </li> </ul>
  ##   BucketName: JString (required)
  ##             : <p>The name of an existing S3 bucket where the log files are to be stored.</p> <p>Constraints:</p> <ul> <li> <p>Must be in the same region as the cluster</p> </li> <li> <p>The cluster must have read bucket and put object permissions</p> </li> </ul>
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The identifier of the cluster on which logging is to be started.</p> <p>Example: <code>examplecluster</code> </p>
  section = newJObject()
  var valid_605311 = formData.getOrDefault("S3KeyPrefix")
  valid_605311 = validateParameter(valid_605311, JString, required = false,
                                 default = nil)
  if valid_605311 != nil:
    section.add "S3KeyPrefix", valid_605311
  assert formData != nil,
        "formData argument is necessary due to required `BucketName` field"
  var valid_605312 = formData.getOrDefault("BucketName")
  valid_605312 = validateParameter(valid_605312, JString, required = true,
                                 default = nil)
  if valid_605312 != nil:
    section.add "BucketName", valid_605312
  var valid_605313 = formData.getOrDefault("ClusterIdentifier")
  valid_605313 = validateParameter(valid_605313, JString, required = true,
                                 default = nil)
  if valid_605313 != nil:
    section.add "ClusterIdentifier", valid_605313
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_605314: Call_PostEnableLogging_605299; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Starts logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
  ## 
  let valid = call_605314.validator(path, query, header, formData, body)
  let scheme = call_605314.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605314.url(scheme.get, call_605314.host, call_605314.base,
                         call_605314.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_605314, url, valid)

proc call*(call_605315: Call_PostEnableLogging_605299; BucketName: string;
          ClusterIdentifier: string; S3KeyPrefix: string = "";
          Action: string = "EnableLogging"; Version: string = "2012-12-01"): Recallable =
  ## postEnableLogging
  ## Starts logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
  ##   S3KeyPrefix: string
  ##              : <p>The prefix applied to the log file names.</p> <p>Constraints:</p> <ul> <li> <p>Cannot exceed 512 characters</p> </li> <li> <p>Cannot contain spaces( ), double quotes ("), single quotes ('), a backslash (\), or control characters. The hexadecimal codes for invalid characters are: </p> <ul> <li> <p>x00 to x20</p> </li> <li> <p>x22</p> </li> <li> <p>x27</p> </li> <li> <p>x5c</p> </li> <li> <p>x7f or larger</p> </li> </ul> </li> </ul>
  ##   BucketName: string (required)
  ##             : <p>The name of an existing S3 bucket where the log files are to be stored.</p> <p>Constraints:</p> <ul> <li> <p>Must be in the same region as the cluster</p> </li> <li> <p>The cluster must have read bucket and put object permissions</p> </li> </ul>
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The identifier of the cluster on which logging is to be started.</p> <p>Example: <code>examplecluster</code> </p>
  ##   Version: string (required)
  var query_605316 = newJObject()
  var formData_605317 = newJObject()
  add(formData_605317, "S3KeyPrefix", newJString(S3KeyPrefix))
  add(formData_605317, "BucketName", newJString(BucketName))
  add(query_605316, "Action", newJString(Action))
  add(formData_605317, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_605316, "Version", newJString(Version))
  result = call_605315.call(nil, query_605316, nil, formData_605317, nil)

var postEnableLogging* = Call_PostEnableLogging_605299(name: "postEnableLogging",
    meth: HttpMethod.HttpPost, host: "redshift.amazonaws.com",
    route: "/#Action=EnableLogging", validator: validate_PostEnableLogging_605300,
    base: "/", url: url_PostEnableLogging_605301,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetEnableLogging_605281 = ref object of OpenApiRestCall_602450
proc url_GetEnableLogging_605283(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetEnableLogging_605282(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Starts logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   S3KeyPrefix: JString
  ##              : <p>The prefix applied to the log file names.</p> <p>Constraints:</p> <ul> <li> <p>Cannot exceed 512 characters</p> </li> <li> <p>Cannot contain spaces( ), double quotes ("), single quotes ('), a backslash (\), or control characters. The hexadecimal codes for invalid characters are: </p> <ul> <li> <p>x00 to x20</p> </li> <li> <p>x22</p> </li> <li> <p>x27</p> </li> <li> <p>x5c</p> </li> <li> <p>x7f or larger</p> </li> </ul> </li> </ul>
  ##   BucketName: JString (required)
  ##             : <p>The name of an existing S3 bucket where the log files are to be stored.</p> <p>Constraints:</p> <ul> <li> <p>Must be in the same region as the cluster</p> </li> <li> <p>The cluster must have read bucket and put object permissions</p> </li> </ul>
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The identifier of the cluster on which logging is to be started.</p> <p>Example: <code>examplecluster</code> </p>
  ##   Version: JString (required)
  section = newJObject()
  var valid_605284 = query.getOrDefault("S3KeyPrefix")
  valid_605284 = validateParameter(valid_605284, JString, required = false,
                                 default = nil)
  if valid_605284 != nil:
    section.add "S3KeyPrefix", valid_605284
  assert query != nil,
        "query argument is necessary due to required `BucketName` field"
  var valid_605285 = query.getOrDefault("BucketName")
  valid_605285 = validateParameter(valid_605285, JString, required = true,
                                 default = nil)
  if valid_605285 != nil:
    section.add "BucketName", valid_605285
  var valid_605286 = query.getOrDefault("Action")
  valid_605286 = validateParameter(valid_605286, JString, required = true,
                                 default = newJString("EnableLogging"))
  if valid_605286 != nil:
    section.add "Action", valid_605286
  var valid_605287 = query.getOrDefault("ClusterIdentifier")
  valid_605287 = validateParameter(valid_605287, JString, required = true,
                                 default = nil)
  if valid_605287 != nil:
    section.add "ClusterIdentifier", valid_605287
  var valid_605288 = query.getOrDefault("Version")
  valid_605288 = validateParameter(valid_605288, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_605288 != nil:
    section.add "Version", valid_605288
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_605289 = header.getOrDefault("X-Amz-Date")
  valid_605289 = validateParameter(valid_605289, JString, required = false,
                                 default = nil)
  if valid_605289 != nil:
    section.add "X-Amz-Date", valid_605289
  var valid_605290 = header.getOrDefault("X-Amz-Security-Token")
  valid_605290 = validateParameter(valid_605290, JString, required = false,
                                 default = nil)
  if valid_605290 != nil:
    section.add "X-Amz-Security-Token", valid_605290
  var valid_605291 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605291 = validateParameter(valid_605291, JString, required = false,
                                 default = nil)
  if valid_605291 != nil:
    section.add "X-Amz-Content-Sha256", valid_605291
  var valid_605292 = header.getOrDefault("X-Amz-Algorithm")
  valid_605292 = validateParameter(valid_605292, JString, required = false,
                                 default = nil)
  if valid_605292 != nil:
    section.add "X-Amz-Algorithm", valid_605292
  var valid_605293 = header.getOrDefault("X-Amz-Signature")
  valid_605293 = validateParameter(valid_605293, JString, required = false,
                                 default = nil)
  if valid_605293 != nil:
    section.add "X-Amz-Signature", valid_605293
  var valid_605294 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605294 = validateParameter(valid_605294, JString, required = false,
                                 default = nil)
  if valid_605294 != nil:
    section.add "X-Amz-SignedHeaders", valid_605294
  var valid_605295 = header.getOrDefault("X-Amz-Credential")
  valid_605295 = validateParameter(valid_605295, JString, required = false,
                                 default = nil)
  if valid_605295 != nil:
    section.add "X-Amz-Credential", valid_605295
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_605296: Call_GetEnableLogging_605281; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Starts logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
  ## 
  let valid = call_605296.validator(path, query, header, formData, body)
  let scheme = call_605296.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605296.url(scheme.get, call_605296.host, call_605296.base,
                         call_605296.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_605296, url, valid)

proc call*(call_605297: Call_GetEnableLogging_605281; BucketName: string;
          ClusterIdentifier: string; S3KeyPrefix: string = "";
          Action: string = "EnableLogging"; Version: string = "2012-12-01"): Recallable =
  ## getEnableLogging
  ## Starts logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
  ##   S3KeyPrefix: string
  ##              : <p>The prefix applied to the log file names.</p> <p>Constraints:</p> <ul> <li> <p>Cannot exceed 512 characters</p> </li> <li> <p>Cannot contain spaces( ), double quotes ("), single quotes ('), a backslash (\), or control characters. The hexadecimal codes for invalid characters are: </p> <ul> <li> <p>x00 to x20</p> </li> <li> <p>x22</p> </li> <li> <p>x27</p> </li> <li> <p>x5c</p> </li> <li> <p>x7f or larger</p> </li> </ul> </li> </ul>
  ##   BucketName: string (required)
  ##             : <p>The name of an existing S3 bucket where the log files are to be stored.</p> <p>Constraints:</p> <ul> <li> <p>Must be in the same region as the cluster</p> </li> <li> <p>The cluster must have read bucket and put object permissions</p> </li> </ul>
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The identifier of the cluster on which logging is to be started.</p> <p>Example: <code>examplecluster</code> </p>
  ##   Version: string (required)
  var query_605298 = newJObject()
  add(query_605298, "S3KeyPrefix", newJString(S3KeyPrefix))
  add(query_605298, "BucketName", newJString(BucketName))
  add(query_605298, "Action", newJString(Action))
  add(query_605298, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_605298, "Version", newJString(Version))
  result = call_605297.call(nil, query_605298, nil, nil, nil)

var getEnableLogging* = Call_GetEnableLogging_605281(name: "getEnableLogging",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=EnableLogging", validator: validate_GetEnableLogging_605282,
    base: "/", url: url_GetEnableLogging_605283,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostEnableSnapshotCopy_605338 = ref object of OpenApiRestCall_602450
proc url_PostEnableSnapshotCopy_605340(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostEnableSnapshotCopy_605339(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Enables the automatic copy of snapshots from one region to another region for a specified cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_605341 = query.getOrDefault("Action")
  valid_605341 = validateParameter(valid_605341, JString, required = true,
                                 default = newJString("EnableSnapshotCopy"))
  if valid_605341 != nil:
    section.add "Action", valid_605341
  var valid_605342 = query.getOrDefault("Version")
  valid_605342 = validateParameter(valid_605342, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_605342 != nil:
    section.add "Version", valid_605342
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_605343 = header.getOrDefault("X-Amz-Date")
  valid_605343 = validateParameter(valid_605343, JString, required = false,
                                 default = nil)
  if valid_605343 != nil:
    section.add "X-Amz-Date", valid_605343
  var valid_605344 = header.getOrDefault("X-Amz-Security-Token")
  valid_605344 = validateParameter(valid_605344, JString, required = false,
                                 default = nil)
  if valid_605344 != nil:
    section.add "X-Amz-Security-Token", valid_605344
  var valid_605345 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605345 = validateParameter(valid_605345, JString, required = false,
                                 default = nil)
  if valid_605345 != nil:
    section.add "X-Amz-Content-Sha256", valid_605345
  var valid_605346 = header.getOrDefault("X-Amz-Algorithm")
  valid_605346 = validateParameter(valid_605346, JString, required = false,
                                 default = nil)
  if valid_605346 != nil:
    section.add "X-Amz-Algorithm", valid_605346
  var valid_605347 = header.getOrDefault("X-Amz-Signature")
  valid_605347 = validateParameter(valid_605347, JString, required = false,
                                 default = nil)
  if valid_605347 != nil:
    section.add "X-Amz-Signature", valid_605347
  var valid_605348 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605348 = validateParameter(valid_605348, JString, required = false,
                                 default = nil)
  if valid_605348 != nil:
    section.add "X-Amz-SignedHeaders", valid_605348
  var valid_605349 = header.getOrDefault("X-Amz-Credential")
  valid_605349 = validateParameter(valid_605349, JString, required = false,
                                 default = nil)
  if valid_605349 != nil:
    section.add "X-Amz-Credential", valid_605349
  result.add "header", section
  ## parameters in `formData` object:
  ##   RetentionPeriod: JInt
  ##                  : <p>The number of days to retain automated snapshots in the destination region after they are copied from the source region.</p> <p>Default: 7.</p> <p>Constraints: Must be at least 1 and no more than 35.</p>
  ##   SnapshotCopyGrantName: JString
  ##                        : The name of the snapshot copy grant to use when snapshots of an AWS KMS-encrypted cluster are copied to the destination region.
  ##   DestinationRegion: JString (required)
  ##                    : <p>The destination AWS Region that you want to copy snapshots to.</p> <p>Constraints: Must be the name of a valid AWS Region. For more information, see <a 
  ## href="https://docs.aws.amazon.com/general/latest/gr/rande.html#redshift_region">Regions and Endpoints</a> in the Amazon Web Services General Reference. </p>
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of the source cluster to copy snapshots from.</p> <p>Constraints: Must be the valid name of an existing cluster that does not already have cross-region snapshot copy enabled.</p>
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The number of days to retain newly copied snapshots in the destination AWS Region after they are copied from the source AWS Region. If the value is -1, the manual snapshot is retained indefinitely. </p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  section = newJObject()
  var valid_605350 = formData.getOrDefault("RetentionPeriod")
  valid_605350 = validateParameter(valid_605350, JInt, required = false, default = nil)
  if valid_605350 != nil:
    section.add "RetentionPeriod", valid_605350
  var valid_605351 = formData.getOrDefault("SnapshotCopyGrantName")
  valid_605351 = validateParameter(valid_605351, JString, required = false,
                                 default = nil)
  if valid_605351 != nil:
    section.add "SnapshotCopyGrantName", valid_605351
  assert formData != nil, "formData argument is necessary due to required `DestinationRegion` field"
  var valid_605352 = formData.getOrDefault("DestinationRegion")
  valid_605352 = validateParameter(valid_605352, JString, required = true,
                                 default = nil)
  if valid_605352 != nil:
    section.add "DestinationRegion", valid_605352
  var valid_605353 = formData.getOrDefault("ClusterIdentifier")
  valid_605353 = validateParameter(valid_605353, JString, required = true,
                                 default = nil)
  if valid_605353 != nil:
    section.add "ClusterIdentifier", valid_605353
  var valid_605354 = formData.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_605354 = validateParameter(valid_605354, JInt, required = false, default = nil)
  if valid_605354 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_605354
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_605355: Call_PostEnableSnapshotCopy_605338; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Enables the automatic copy of snapshots from one region to another region for a specified cluster.
  ## 
  let valid = call_605355.validator(path, query, header, formData, body)
  let scheme = call_605355.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605355.url(scheme.get, call_605355.host, call_605355.base,
                         call_605355.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_605355, url, valid)

proc call*(call_605356: Call_PostEnableSnapshotCopy_605338;
          DestinationRegion: string; ClusterIdentifier: string;
          RetentionPeriod: int = 0; Action: string = "EnableSnapshotCopy";
          SnapshotCopyGrantName: string = "";
          ManualSnapshotRetentionPeriod: int = 0; Version: string = "2012-12-01"): Recallable =
  ## postEnableSnapshotCopy
  ## Enables the automatic copy of snapshots from one region to another region for a specified cluster.
  ##   RetentionPeriod: int
  ##                  : <p>The number of days to retain automated snapshots in the destination region after they are copied from the source region.</p> <p>Default: 7.</p> <p>Constraints: Must be at least 1 and no more than 35.</p>
  ##   Action: string (required)
  ##   SnapshotCopyGrantName: string
  ##                        : The name of the snapshot copy grant to use when snapshots of an AWS KMS-encrypted cluster are copied to the destination region.
  ##   DestinationRegion: string (required)
  ##                    : <p>The destination AWS Region that you want to copy snapshots to.</p> <p>Constraints: Must be the name of a valid AWS Region. For more information, see <a 
  ## href="https://docs.aws.amazon.com/general/latest/gr/rande.html#redshift_region">Regions and Endpoints</a> in the Amazon Web Services General Reference. </p>
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of the source cluster to copy snapshots from.</p> <p>Constraints: Must be the valid name of an existing cluster that does not already have cross-region snapshot copy enabled.</p>
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The number of days to retain newly copied snapshots in the destination AWS Region after they are copied from the source AWS Region. If the value is -1, the manual snapshot is retained indefinitely. </p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  ##   Version: string (required)
  var query_605357 = newJObject()
  var formData_605358 = newJObject()
  add(formData_605358, "RetentionPeriod", newJInt(RetentionPeriod))
  add(query_605357, "Action", newJString(Action))
  add(formData_605358, "SnapshotCopyGrantName", newJString(SnapshotCopyGrantName))
  add(formData_605358, "DestinationRegion", newJString(DestinationRegion))
  add(formData_605358, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_605358, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  add(query_605357, "Version", newJString(Version))
  result = call_605356.call(nil, query_605357, nil, formData_605358, nil)

var postEnableSnapshotCopy* = Call_PostEnableSnapshotCopy_605338(
    name: "postEnableSnapshotCopy", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=EnableSnapshotCopy",
    validator: validate_PostEnableSnapshotCopy_605339, base: "/",
    url: url_PostEnableSnapshotCopy_605340, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetEnableSnapshotCopy_605318 = ref object of OpenApiRestCall_602450
proc url_GetEnableSnapshotCopy_605320(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetEnableSnapshotCopy_605319(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Enables the automatic copy of snapshots from one region to another region for a specified cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   DestinationRegion: JString (required)
  ##                    : <p>The destination AWS Region that you want to copy snapshots to.</p> <p>Constraints: Must be the name of a valid AWS Region. For more information, see <a 
  ## href="https://docs.aws.amazon.com/general/latest/gr/rande.html#redshift_region">Regions and Endpoints</a> in the Amazon Web Services General Reference. </p>
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of the source cluster to copy snapshots from.</p> <p>Constraints: Must be the valid name of an existing cluster that does not already have cross-region snapshot copy enabled.</p>
  ##   SnapshotCopyGrantName: JString
  ##                        : The name of the snapshot copy grant to use when snapshots of an AWS KMS-encrypted cluster are copied to the destination region.
  ##   RetentionPeriod: JInt
  ##                  : <p>The number of days to retain automated snapshots in the destination region after they are copied from the source region.</p> <p>Default: 7.</p> <p>Constraints: Must be at least 1 and no more than 35.</p>
  ##   Version: JString (required)
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The number of days to retain newly copied snapshots in the destination AWS Region after they are copied from the source AWS Region. If the value is -1, the manual snapshot is retained indefinitely. </p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `DestinationRegion` field"
  var valid_605321 = query.getOrDefault("DestinationRegion")
  valid_605321 = validateParameter(valid_605321, JString, required = true,
                                 default = nil)
  if valid_605321 != nil:
    section.add "DestinationRegion", valid_605321
  var valid_605322 = query.getOrDefault("Action")
  valid_605322 = validateParameter(valid_605322, JString, required = true,
                                 default = newJString("EnableSnapshotCopy"))
  if valid_605322 != nil:
    section.add "Action", valid_605322
  var valid_605323 = query.getOrDefault("ClusterIdentifier")
  valid_605323 = validateParameter(valid_605323, JString, required = true,
                                 default = nil)
  if valid_605323 != nil:
    section.add "ClusterIdentifier", valid_605323
  var valid_605324 = query.getOrDefault("SnapshotCopyGrantName")
  valid_605324 = validateParameter(valid_605324, JString, required = false,
                                 default = nil)
  if valid_605324 != nil:
    section.add "SnapshotCopyGrantName", valid_605324
  var valid_605325 = query.getOrDefault("RetentionPeriod")
  valid_605325 = validateParameter(valid_605325, JInt, required = false, default = nil)
  if valid_605325 != nil:
    section.add "RetentionPeriod", valid_605325
  var valid_605326 = query.getOrDefault("Version")
  valid_605326 = validateParameter(valid_605326, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_605326 != nil:
    section.add "Version", valid_605326
  var valid_605327 = query.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_605327 = validateParameter(valid_605327, JInt, required = false, default = nil)
  if valid_605327 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_605327
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_605328 = header.getOrDefault("X-Amz-Date")
  valid_605328 = validateParameter(valid_605328, JString, required = false,
                                 default = nil)
  if valid_605328 != nil:
    section.add "X-Amz-Date", valid_605328
  var valid_605329 = header.getOrDefault("X-Amz-Security-Token")
  valid_605329 = validateParameter(valid_605329, JString, required = false,
                                 default = nil)
  if valid_605329 != nil:
    section.add "X-Amz-Security-Token", valid_605329
  var valid_605330 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605330 = validateParameter(valid_605330, JString, required = false,
                                 default = nil)
  if valid_605330 != nil:
    section.add "X-Amz-Content-Sha256", valid_605330
  var valid_605331 = header.getOrDefault("X-Amz-Algorithm")
  valid_605331 = validateParameter(valid_605331, JString, required = false,
                                 default = nil)
  if valid_605331 != nil:
    section.add "X-Amz-Algorithm", valid_605331
  var valid_605332 = header.getOrDefault("X-Amz-Signature")
  valid_605332 = validateParameter(valid_605332, JString, required = false,
                                 default = nil)
  if valid_605332 != nil:
    section.add "X-Amz-Signature", valid_605332
  var valid_605333 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605333 = validateParameter(valid_605333, JString, required = false,
                                 default = nil)
  if valid_605333 != nil:
    section.add "X-Amz-SignedHeaders", valid_605333
  var valid_605334 = header.getOrDefault("X-Amz-Credential")
  valid_605334 = validateParameter(valid_605334, JString, required = false,
                                 default = nil)
  if valid_605334 != nil:
    section.add "X-Amz-Credential", valid_605334
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_605335: Call_GetEnableSnapshotCopy_605318; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Enables the automatic copy of snapshots from one region to another region for a specified cluster.
  ## 
  let valid = call_605335.validator(path, query, header, formData, body)
  let scheme = call_605335.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605335.url(scheme.get, call_605335.host, call_605335.base,
                         call_605335.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_605335, url, valid)

proc call*(call_605336: Call_GetEnableSnapshotCopy_605318;
          DestinationRegion: string; ClusterIdentifier: string;
          Action: string = "EnableSnapshotCopy"; SnapshotCopyGrantName: string = "";
          RetentionPeriod: int = 0; Version: string = "2012-12-01";
          ManualSnapshotRetentionPeriod: int = 0): Recallable =
  ## getEnableSnapshotCopy
  ## Enables the automatic copy of snapshots from one region to another region for a specified cluster.
  ##   DestinationRegion: string (required)
  ##                    : <p>The destination AWS Region that you want to copy snapshots to.</p> <p>Constraints: Must be the name of a valid AWS Region. For more information, see <a 
  ## href="https://docs.aws.amazon.com/general/latest/gr/rande.html#redshift_region">Regions and Endpoints</a> in the Amazon Web Services General Reference. </p>
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of the source cluster to copy snapshots from.</p> <p>Constraints: Must be the valid name of an existing cluster that does not already have cross-region snapshot copy enabled.</p>
  ##   SnapshotCopyGrantName: string
  ##                        : The name of the snapshot copy grant to use when snapshots of an AWS KMS-encrypted cluster are copied to the destination region.
  ##   RetentionPeriod: int
  ##                  : <p>The number of days to retain automated snapshots in the destination region after they are copied from the source region.</p> <p>Default: 7.</p> <p>Constraints: Must be at least 1 and no more than 35.</p>
  ##   Version: string (required)
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The number of days to retain newly copied snapshots in the destination AWS Region after they are copied from the source AWS Region. If the value is -1, the manual snapshot is retained indefinitely. </p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  var query_605337 = newJObject()
  add(query_605337, "DestinationRegion", newJString(DestinationRegion))
  add(query_605337, "Action", newJString(Action))
  add(query_605337, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_605337, "SnapshotCopyGrantName", newJString(SnapshotCopyGrantName))
  add(query_605337, "RetentionPeriod", newJInt(RetentionPeriod))
  add(query_605337, "Version", newJString(Version))
  add(query_605337, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  result = call_605336.call(nil, query_605337, nil, nil, nil)

var getEnableSnapshotCopy* = Call_GetEnableSnapshotCopy_605318(
    name: "getEnableSnapshotCopy", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=EnableSnapshotCopy",
    validator: validate_GetEnableSnapshotCopy_605319, base: "/",
    url: url_GetEnableSnapshotCopy_605320, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostGetClusterCredentials_605380 = ref object of OpenApiRestCall_602450
proc url_PostGetClusterCredentials_605382(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostGetClusterCredentials_605381(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns a database user name and temporary password with temporary authorization to log on to an Amazon Redshift database. The action returns the database user name prefixed with <code>IAM:</code> if <code>AutoCreate</code> is <code>False</code> or <code>IAMA:</code> if <code>AutoCreate</code> is <code>True</code>. You can optionally specify one or more database user groups that the user will join at log on. By default, the temporary credentials expire in 900 seconds. You can optionally specify a duration between 900 seconds (15 minutes) and 3600 seconds (60 minutes). For more information, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/generating-user-credentials.html">Using IAM Authentication to Generate Database User Credentials</a> in the Amazon Redshift Cluster Management Guide.</p> <p>The AWS Identity and Access Management (IAM)user or role that executes GetClusterCredentials must have an IAM policy attached that allows access to all necessary actions and resources. For more information about permissions, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-identity-based.html#redshift-policy-resources.getclustercredentials-resources">Resource Policies for GetClusterCredentials</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If the <code>DbGroups</code> parameter is specified, the IAM policy must allow the <code>redshift:JoinGroup</code> action with access to the listed <code>dbgroups</code>. </p> <p>In addition, if the <code>AutoCreate</code> parameter is set to <code>True</code>, then the policy must include the <code>redshift:CreateClusterUser</code> privilege.</p> <p>If the <code>DbName</code> parameter is specified, the IAM policy must allow access to the resource <code>dbname</code> for the specified database name. </p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_605383 = query.getOrDefault("Action")
  valid_605383 = validateParameter(valid_605383, JString, required = true,
                                 default = newJString("GetClusterCredentials"))
  if valid_605383 != nil:
    section.add "Action", valid_605383
  var valid_605384 = query.getOrDefault("Version")
  valid_605384 = validateParameter(valid_605384, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_605384 != nil:
    section.add "Version", valid_605384
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_605385 = header.getOrDefault("X-Amz-Date")
  valid_605385 = validateParameter(valid_605385, JString, required = false,
                                 default = nil)
  if valid_605385 != nil:
    section.add "X-Amz-Date", valid_605385
  var valid_605386 = header.getOrDefault("X-Amz-Security-Token")
  valid_605386 = validateParameter(valid_605386, JString, required = false,
                                 default = nil)
  if valid_605386 != nil:
    section.add "X-Amz-Security-Token", valid_605386
  var valid_605387 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605387 = validateParameter(valid_605387, JString, required = false,
                                 default = nil)
  if valid_605387 != nil:
    section.add "X-Amz-Content-Sha256", valid_605387
  var valid_605388 = header.getOrDefault("X-Amz-Algorithm")
  valid_605388 = validateParameter(valid_605388, JString, required = false,
                                 default = nil)
  if valid_605388 != nil:
    section.add "X-Amz-Algorithm", valid_605388
  var valid_605389 = header.getOrDefault("X-Amz-Signature")
  valid_605389 = validateParameter(valid_605389, JString, required = false,
                                 default = nil)
  if valid_605389 != nil:
    section.add "X-Amz-Signature", valid_605389
  var valid_605390 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605390 = validateParameter(valid_605390, JString, required = false,
                                 default = nil)
  if valid_605390 != nil:
    section.add "X-Amz-SignedHeaders", valid_605390
  var valid_605391 = header.getOrDefault("X-Amz-Credential")
  valid_605391 = validateParameter(valid_605391, JString, required = false,
                                 default = nil)
  if valid_605391 != nil:
    section.add "X-Amz-Credential", valid_605391
  result.add "header", section
  ## parameters in `formData` object:
  ##   DbUser: JString (required)
  ##         : <p>The name of a database user. If a user name matching <code>DbUser</code> exists in the database, the temporary user credentials have the same permissions as the existing user. If <code>DbUser</code> doesn't exist in the database and <code>Autocreate</code> is <code>True</code>, a new user is created using the value for <code>DbUser</code> with PUBLIC permissions. If a database user matching the value for <code>DbUser</code> doesn't exist and <code>Autocreate</code> is <code>False</code>, then the command succeeds but the connection attempt will fail because the user doesn't exist in the database.</p> <p>For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/r_CREATE_USER.html">CREATE USER</a> in the Amazon Redshift Database Developer Guide. </p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 64 alphanumeric characters or hyphens. The user name can't be <code>PUBLIC</code>.</p> </li> <li> <p>Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Must not contain a colon ( : ) or slash ( / ). </p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p> </li> </ul>
  ##   AutoCreate: JBool
  ##             : Create a database user with the name specified for the user named in <code>DbUser</code> if one does not exist.
  ##   ClusterIdentifier: JString (required)
  ##                    : The unique identifier of the cluster that contains the database for which your are requesting credentials. This parameter is case sensitive.
  ##   DbName: JString
  ##         : <p>The name of a database that <code>DbUser</code> is authorized to log on to. If <code>DbName</code> is not specified, <code>DbUser</code> can log on to any existing database.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 64 alphanumeric characters or hyphens</p> </li> <li> <p>Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Must not contain a colon ( : ) or slash ( / ). </p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p> </li> </ul>
  ##   DbGroups: JArray
  ##           : <p>A list of the names of existing database groups that the user named in <code>DbUser</code> will join for the current session, in addition to any group memberships for an existing user. If not specified, a new user is added only to PUBLIC.</p> <p>Database group name constraints</p> <ul> <li> <p>Must be 1 to 64 alphanumeric characters or hyphens</p> </li> <li> <p>Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Must not contain a colon ( : ) or slash ( / ). </p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p> </li> </ul>
  ##   DurationSeconds: JInt
  ##                  : <p>The number of seconds until the returned temporary password expires.</p> <p>Constraint: minimum 900, maximum 3600.</p> <p>Default: 900</p>
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `DbUser` field"
  var valid_605392 = formData.getOrDefault("DbUser")
  valid_605392 = validateParameter(valid_605392, JString, required = true,
                                 default = nil)
  if valid_605392 != nil:
    section.add "DbUser", valid_605392
  var valid_605393 = formData.getOrDefault("AutoCreate")
  valid_605393 = validateParameter(valid_605393, JBool, required = false, default = nil)
  if valid_605393 != nil:
    section.add "AutoCreate", valid_605393
  var valid_605394 = formData.getOrDefault("ClusterIdentifier")
  valid_605394 = validateParameter(valid_605394, JString, required = true,
                                 default = nil)
  if valid_605394 != nil:
    section.add "ClusterIdentifier", valid_605394
  var valid_605395 = formData.getOrDefault("DbName")
  valid_605395 = validateParameter(valid_605395, JString, required = false,
                                 default = nil)
  if valid_605395 != nil:
    section.add "DbName", valid_605395
  var valid_605396 = formData.getOrDefault("DbGroups")
  valid_605396 = validateParameter(valid_605396, JArray, required = false,
                                 default = nil)
  if valid_605396 != nil:
    section.add "DbGroups", valid_605396
  var valid_605397 = formData.getOrDefault("DurationSeconds")
  valid_605397 = validateParameter(valid_605397, JInt, required = false, default = nil)
  if valid_605397 != nil:
    section.add "DurationSeconds", valid_605397
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_605398: Call_PostGetClusterCredentials_605380; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns a database user name and temporary password with temporary authorization to log on to an Amazon Redshift database. The action returns the database user name prefixed with <code>IAM:</code> if <code>AutoCreate</code> is <code>False</code> or <code>IAMA:</code> if <code>AutoCreate</code> is <code>True</code>. You can optionally specify one or more database user groups that the user will join at log on. By default, the temporary credentials expire in 900 seconds. You can optionally specify a duration between 900 seconds (15 minutes) and 3600 seconds (60 minutes). For more information, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/generating-user-credentials.html">Using IAM Authentication to Generate Database User Credentials</a> in the Amazon Redshift Cluster Management Guide.</p> <p>The AWS Identity and Access Management (IAM)user or role that executes GetClusterCredentials must have an IAM policy attached that allows access to all necessary actions and resources. For more information about permissions, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-identity-based.html#redshift-policy-resources.getclustercredentials-resources">Resource Policies for GetClusterCredentials</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If the <code>DbGroups</code> parameter is specified, the IAM policy must allow the <code>redshift:JoinGroup</code> action with access to the listed <code>dbgroups</code>. </p> <p>In addition, if the <code>AutoCreate</code> parameter is set to <code>True</code>, then the policy must include the <code>redshift:CreateClusterUser</code> privilege.</p> <p>If the <code>DbName</code> parameter is specified, the IAM policy must allow access to the resource <code>dbname</code> for the specified database name. </p>
  ## 
  let valid = call_605398.validator(path, query, header, formData, body)
  let scheme = call_605398.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605398.url(scheme.get, call_605398.host, call_605398.base,
                         call_605398.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_605398, url, valid)

proc call*(call_605399: Call_PostGetClusterCredentials_605380; DbUser: string;
          ClusterIdentifier: string; Action: string = "GetClusterCredentials";
          AutoCreate: bool = false; DbName: string = ""; DbGroups: JsonNode = nil;
          Version: string = "2012-12-01"; DurationSeconds: int = 0): Recallable =
  ## postGetClusterCredentials
  ## <p>Returns a database user name and temporary password with temporary authorization to log on to an Amazon Redshift database. The action returns the database user name prefixed with <code>IAM:</code> if <code>AutoCreate</code> is <code>False</code> or <code>IAMA:</code> if <code>AutoCreate</code> is <code>True</code>. You can optionally specify one or more database user groups that the user will join at log on. By default, the temporary credentials expire in 900 seconds. You can optionally specify a duration between 900 seconds (15 minutes) and 3600 seconds (60 minutes). For more information, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/generating-user-credentials.html">Using IAM Authentication to Generate Database User Credentials</a> in the Amazon Redshift Cluster Management Guide.</p> <p>The AWS Identity and Access Management (IAM)user or role that executes GetClusterCredentials must have an IAM policy attached that allows access to all necessary actions and resources. For more information about permissions, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-identity-based.html#redshift-policy-resources.getclustercredentials-resources">Resource Policies for GetClusterCredentials</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If the <code>DbGroups</code> parameter is specified, the IAM policy must allow the <code>redshift:JoinGroup</code> action with access to the listed <code>dbgroups</code>. </p> <p>In addition, if the <code>AutoCreate</code> parameter is set to <code>True</code>, then the policy must include the <code>redshift:CreateClusterUser</code> privilege.</p> <p>If the <code>DbName</code> parameter is specified, the IAM policy must allow access to the resource <code>dbname</code> for the specified database name. </p>
  ##   DbUser: string (required)
  ##         : <p>The name of a database user. If a user name matching <code>DbUser</code> exists in the database, the temporary user credentials have the same permissions as the existing user. If <code>DbUser</code> doesn't exist in the database and <code>Autocreate</code> is <code>True</code>, a new user is created using the value for <code>DbUser</code> with PUBLIC permissions. If a database user matching the value for <code>DbUser</code> doesn't exist and <code>Autocreate</code> is <code>False</code>, then the command succeeds but the connection attempt will fail because the user doesn't exist in the database.</p> <p>For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/r_CREATE_USER.html">CREATE USER</a> in the Amazon Redshift Database Developer Guide. </p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 64 alphanumeric characters or hyphens. The user name can't be <code>PUBLIC</code>.</p> </li> <li> <p>Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Must not contain a colon ( : ) or slash ( / ). </p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p> </li> </ul>
  ##   Action: string (required)
  ##   AutoCreate: bool
  ##             : Create a database user with the name specified for the user named in <code>DbUser</code> if one does not exist.
  ##   ClusterIdentifier: string (required)
  ##                    : The unique identifier of the cluster that contains the database for which your are requesting credentials. This parameter is case sensitive.
  ##   DbName: string
  ##         : <p>The name of a database that <code>DbUser</code> is authorized to log on to. If <code>DbName</code> is not specified, <code>DbUser</code> can log on to any existing database.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 64 alphanumeric characters or hyphens</p> </li> <li> <p>Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Must not contain a colon ( : ) or slash ( / ). </p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p> </li> </ul>
  ##   DbGroups: JArray
  ##           : <p>A list of the names of existing database groups that the user named in <code>DbUser</code> will join for the current session, in addition to any group memberships for an existing user. If not specified, a new user is added only to PUBLIC.</p> <p>Database group name constraints</p> <ul> <li> <p>Must be 1 to 64 alphanumeric characters or hyphens</p> </li> <li> <p>Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Must not contain a colon ( : ) or slash ( / ). </p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p> </li> </ul>
  ##   Version: string (required)
  ##   DurationSeconds: int
  ##                  : <p>The number of seconds until the returned temporary password expires.</p> <p>Constraint: minimum 900, maximum 3600.</p> <p>Default: 900</p>
  var query_605400 = newJObject()
  var formData_605401 = newJObject()
  add(formData_605401, "DbUser", newJString(DbUser))
  add(query_605400, "Action", newJString(Action))
  add(formData_605401, "AutoCreate", newJBool(AutoCreate))
  add(formData_605401, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_605401, "DbName", newJString(DbName))
  if DbGroups != nil:
    formData_605401.add "DbGroups", DbGroups
  add(query_605400, "Version", newJString(Version))
  add(formData_605401, "DurationSeconds", newJInt(DurationSeconds))
  result = call_605399.call(nil, query_605400, nil, formData_605401, nil)

var postGetClusterCredentials* = Call_PostGetClusterCredentials_605380(
    name: "postGetClusterCredentials", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=GetClusterCredentials",
    validator: validate_PostGetClusterCredentials_605381, base: "/",
    url: url_PostGetClusterCredentials_605382,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetGetClusterCredentials_605359 = ref object of OpenApiRestCall_602450
proc url_GetGetClusterCredentials_605361(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetGetClusterCredentials_605360(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns a database user name and temporary password with temporary authorization to log on to an Amazon Redshift database. The action returns the database user name prefixed with <code>IAM:</code> if <code>AutoCreate</code> is <code>False</code> or <code>IAMA:</code> if <code>AutoCreate</code> is <code>True</code>. You can optionally specify one or more database user groups that the user will join at log on. By default, the temporary credentials expire in 900 seconds. You can optionally specify a duration between 900 seconds (15 minutes) and 3600 seconds (60 minutes). For more information, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/generating-user-credentials.html">Using IAM Authentication to Generate Database User Credentials</a> in the Amazon Redshift Cluster Management Guide.</p> <p>The AWS Identity and Access Management (IAM)user or role that executes GetClusterCredentials must have an IAM policy attached that allows access to all necessary actions and resources. For more information about permissions, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-identity-based.html#redshift-policy-resources.getclustercredentials-resources">Resource Policies for GetClusterCredentials</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If the <code>DbGroups</code> parameter is specified, the IAM policy must allow the <code>redshift:JoinGroup</code> action with access to the listed <code>dbgroups</code>. </p> <p>In addition, if the <code>AutoCreate</code> parameter is set to <code>True</code>, then the policy must include the <code>redshift:CreateClusterUser</code> privilege.</p> <p>If the <code>DbName</code> parameter is specified, the IAM policy must allow access to the resource <code>dbname</code> for the specified database name. </p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   DbGroups: JArray
  ##           : <p>A list of the names of existing database groups that the user named in <code>DbUser</code> will join for the current session, in addition to any group memberships for an existing user. If not specified, a new user is added only to PUBLIC.</p> <p>Database group name constraints</p> <ul> <li> <p>Must be 1 to 64 alphanumeric characters or hyphens</p> </li> <li> <p>Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Must not contain a colon ( : ) or slash ( / ). </p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p> </li> </ul>
  ##   DurationSeconds: JInt
  ##                  : <p>The number of seconds until the returned temporary password expires.</p> <p>Constraint: minimum 900, maximum 3600.</p> <p>Default: 900</p>
  ##   DbName: JString
  ##         : <p>The name of a database that <code>DbUser</code> is authorized to log on to. If <code>DbName</code> is not specified, <code>DbUser</code> can log on to any existing database.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 64 alphanumeric characters or hyphens</p> </li> <li> <p>Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Must not contain a colon ( : ) or slash ( / ). </p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p> </li> </ul>
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : The unique identifier of the cluster that contains the database for which your are requesting credentials. This parameter is case sensitive.
  ##   AutoCreate: JBool
  ##             : Create a database user with the name specified for the user named in <code>DbUser</code> if one does not exist.
  ##   DbUser: JString (required)
  ##         : <p>The name of a database user. If a user name matching <code>DbUser</code> exists in the database, the temporary user credentials have the same permissions as the existing user. If <code>DbUser</code> doesn't exist in the database and <code>Autocreate</code> is <code>True</code>, a new user is created using the value for <code>DbUser</code> with PUBLIC permissions. If a database user matching the value for <code>DbUser</code> doesn't exist and <code>Autocreate</code> is <code>False</code>, then the command succeeds but the connection attempt will fail because the user doesn't exist in the database.</p> <p>For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/r_CREATE_USER.html">CREATE USER</a> in the Amazon Redshift Database Developer Guide. </p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 64 alphanumeric characters or hyphens. The user name can't be <code>PUBLIC</code>.</p> </li> <li> <p>Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Must not contain a colon ( : ) or slash ( / ). </p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p> </li> </ul>
  ##   Version: JString (required)
  section = newJObject()
  var valid_605362 = query.getOrDefault("DbGroups")
  valid_605362 = validateParameter(valid_605362, JArray, required = false,
                                 default = nil)
  if valid_605362 != nil:
    section.add "DbGroups", valid_605362
  var valid_605363 = query.getOrDefault("DurationSeconds")
  valid_605363 = validateParameter(valid_605363, JInt, required = false, default = nil)
  if valid_605363 != nil:
    section.add "DurationSeconds", valid_605363
  var valid_605364 = query.getOrDefault("DbName")
  valid_605364 = validateParameter(valid_605364, JString, required = false,
                                 default = nil)
  if valid_605364 != nil:
    section.add "DbName", valid_605364
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_605365 = query.getOrDefault("Action")
  valid_605365 = validateParameter(valid_605365, JString, required = true,
                                 default = newJString("GetClusterCredentials"))
  if valid_605365 != nil:
    section.add "Action", valid_605365
  var valid_605366 = query.getOrDefault("ClusterIdentifier")
  valid_605366 = validateParameter(valid_605366, JString, required = true,
                                 default = nil)
  if valid_605366 != nil:
    section.add "ClusterIdentifier", valid_605366
  var valid_605367 = query.getOrDefault("AutoCreate")
  valid_605367 = validateParameter(valid_605367, JBool, required = false, default = nil)
  if valid_605367 != nil:
    section.add "AutoCreate", valid_605367
  var valid_605368 = query.getOrDefault("DbUser")
  valid_605368 = validateParameter(valid_605368, JString, required = true,
                                 default = nil)
  if valid_605368 != nil:
    section.add "DbUser", valid_605368
  var valid_605369 = query.getOrDefault("Version")
  valid_605369 = validateParameter(valid_605369, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_605369 != nil:
    section.add "Version", valid_605369
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_605370 = header.getOrDefault("X-Amz-Date")
  valid_605370 = validateParameter(valid_605370, JString, required = false,
                                 default = nil)
  if valid_605370 != nil:
    section.add "X-Amz-Date", valid_605370
  var valid_605371 = header.getOrDefault("X-Amz-Security-Token")
  valid_605371 = validateParameter(valid_605371, JString, required = false,
                                 default = nil)
  if valid_605371 != nil:
    section.add "X-Amz-Security-Token", valid_605371
  var valid_605372 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605372 = validateParameter(valid_605372, JString, required = false,
                                 default = nil)
  if valid_605372 != nil:
    section.add "X-Amz-Content-Sha256", valid_605372
  var valid_605373 = header.getOrDefault("X-Amz-Algorithm")
  valid_605373 = validateParameter(valid_605373, JString, required = false,
                                 default = nil)
  if valid_605373 != nil:
    section.add "X-Amz-Algorithm", valid_605373
  var valid_605374 = header.getOrDefault("X-Amz-Signature")
  valid_605374 = validateParameter(valid_605374, JString, required = false,
                                 default = nil)
  if valid_605374 != nil:
    section.add "X-Amz-Signature", valid_605374
  var valid_605375 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605375 = validateParameter(valid_605375, JString, required = false,
                                 default = nil)
  if valid_605375 != nil:
    section.add "X-Amz-SignedHeaders", valid_605375
  var valid_605376 = header.getOrDefault("X-Amz-Credential")
  valid_605376 = validateParameter(valid_605376, JString, required = false,
                                 default = nil)
  if valid_605376 != nil:
    section.add "X-Amz-Credential", valid_605376
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_605377: Call_GetGetClusterCredentials_605359; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns a database user name and temporary password with temporary authorization to log on to an Amazon Redshift database. The action returns the database user name prefixed with <code>IAM:</code> if <code>AutoCreate</code> is <code>False</code> or <code>IAMA:</code> if <code>AutoCreate</code> is <code>True</code>. You can optionally specify one or more database user groups that the user will join at log on. By default, the temporary credentials expire in 900 seconds. You can optionally specify a duration between 900 seconds (15 minutes) and 3600 seconds (60 minutes). For more information, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/generating-user-credentials.html">Using IAM Authentication to Generate Database User Credentials</a> in the Amazon Redshift Cluster Management Guide.</p> <p>The AWS Identity and Access Management (IAM)user or role that executes GetClusterCredentials must have an IAM policy attached that allows access to all necessary actions and resources. For more information about permissions, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-identity-based.html#redshift-policy-resources.getclustercredentials-resources">Resource Policies for GetClusterCredentials</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If the <code>DbGroups</code> parameter is specified, the IAM policy must allow the <code>redshift:JoinGroup</code> action with access to the listed <code>dbgroups</code>. </p> <p>In addition, if the <code>AutoCreate</code> parameter is set to <code>True</code>, then the policy must include the <code>redshift:CreateClusterUser</code> privilege.</p> <p>If the <code>DbName</code> parameter is specified, the IAM policy must allow access to the resource <code>dbname</code> for the specified database name. </p>
  ## 
  let valid = call_605377.validator(path, query, header, formData, body)
  let scheme = call_605377.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605377.url(scheme.get, call_605377.host, call_605377.base,
                         call_605377.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_605377, url, valid)

proc call*(call_605378: Call_GetGetClusterCredentials_605359;
          ClusterIdentifier: string; DbUser: string; DbGroups: JsonNode = nil;
          DurationSeconds: int = 0; DbName: string = "";
          Action: string = "GetClusterCredentials"; AutoCreate: bool = false;
          Version: string = "2012-12-01"): Recallable =
  ## getGetClusterCredentials
  ## <p>Returns a database user name and temporary password with temporary authorization to log on to an Amazon Redshift database. The action returns the database user name prefixed with <code>IAM:</code> if <code>AutoCreate</code> is <code>False</code> or <code>IAMA:</code> if <code>AutoCreate</code> is <code>True</code>. You can optionally specify one or more database user groups that the user will join at log on. By default, the temporary credentials expire in 900 seconds. You can optionally specify a duration between 900 seconds (15 minutes) and 3600 seconds (60 minutes). For more information, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/generating-user-credentials.html">Using IAM Authentication to Generate Database User Credentials</a> in the Amazon Redshift Cluster Management Guide.</p> <p>The AWS Identity and Access Management (IAM)user or role that executes GetClusterCredentials must have an IAM policy attached that allows access to all necessary actions and resources. For more information about permissions, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-identity-based.html#redshift-policy-resources.getclustercredentials-resources">Resource Policies for GetClusterCredentials</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If the <code>DbGroups</code> parameter is specified, the IAM policy must allow the <code>redshift:JoinGroup</code> action with access to the listed <code>dbgroups</code>. </p> <p>In addition, if the <code>AutoCreate</code> parameter is set to <code>True</code>, then the policy must include the <code>redshift:CreateClusterUser</code> privilege.</p> <p>If the <code>DbName</code> parameter is specified, the IAM policy must allow access to the resource <code>dbname</code> for the specified database name. </p>
  ##   DbGroups: JArray
  ##           : <p>A list of the names of existing database groups that the user named in <code>DbUser</code> will join for the current session, in addition to any group memberships for an existing user. If not specified, a new user is added only to PUBLIC.</p> <p>Database group name constraints</p> <ul> <li> <p>Must be 1 to 64 alphanumeric characters or hyphens</p> </li> <li> <p>Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Must not contain a colon ( : ) or slash ( / ). </p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p> </li> </ul>
  ##   DurationSeconds: int
  ##                  : <p>The number of seconds until the returned temporary password expires.</p> <p>Constraint: minimum 900, maximum 3600.</p> <p>Default: 900</p>
  ##   DbName: string
  ##         : <p>The name of a database that <code>DbUser</code> is authorized to log on to. If <code>DbName</code> is not specified, <code>DbUser</code> can log on to any existing database.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 64 alphanumeric characters or hyphens</p> </li> <li> <p>Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Must not contain a colon ( : ) or slash ( / ). </p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p> </li> </ul>
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : The unique identifier of the cluster that contains the database for which your are requesting credentials. This parameter is case sensitive.
  ##   AutoCreate: bool
  ##             : Create a database user with the name specified for the user named in <code>DbUser</code> if one does not exist.
  ##   DbUser: string (required)
  ##         : <p>The name of a database user. If a user name matching <code>DbUser</code> exists in the database, the temporary user credentials have the same permissions as the existing user. If <code>DbUser</code> doesn't exist in the database and <code>Autocreate</code> is <code>True</code>, a new user is created using the value for <code>DbUser</code> with PUBLIC permissions. If a database user matching the value for <code>DbUser</code> doesn't exist and <code>Autocreate</code> is <code>False</code>, then the command succeeds but the connection attempt will fail because the user doesn't exist in the database.</p> <p>For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/r_CREATE_USER.html">CREATE USER</a> in the Amazon Redshift Database Developer Guide. </p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 64 alphanumeric characters or hyphens. The user name can't be <code>PUBLIC</code>.</p> </li> <li> <p>Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Must not contain a colon ( : ) or slash ( / ). </p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p> </li> </ul>
  ##   Version: string (required)
  var query_605379 = newJObject()
  if DbGroups != nil:
    query_605379.add "DbGroups", DbGroups
  add(query_605379, "DurationSeconds", newJInt(DurationSeconds))
  add(query_605379, "DbName", newJString(DbName))
  add(query_605379, "Action", newJString(Action))
  add(query_605379, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_605379, "AutoCreate", newJBool(AutoCreate))
  add(query_605379, "DbUser", newJString(DbUser))
  add(query_605379, "Version", newJString(Version))
  result = call_605378.call(nil, query_605379, nil, nil, nil)

var getGetClusterCredentials* = Call_GetGetClusterCredentials_605359(
    name: "getGetClusterCredentials", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=GetClusterCredentials",
    validator: validate_GetGetClusterCredentials_605360, base: "/",
    url: url_GetGetClusterCredentials_605361, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostGetReservedNodeExchangeOfferings_605420 = ref object of OpenApiRestCall_602450
proc url_PostGetReservedNodeExchangeOfferings_605422(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostGetReservedNodeExchangeOfferings_605421(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns an array of DC2 ReservedNodeOfferings that matches the payment type, term, and usage price of the given DC1 reserved node.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_605423 = query.getOrDefault("Action")
  valid_605423 = validateParameter(valid_605423, JString, required = true, default = newJString(
      "GetReservedNodeExchangeOfferings"))
  if valid_605423 != nil:
    section.add "Action", valid_605423
  var valid_605424 = query.getOrDefault("Version")
  valid_605424 = validateParameter(valid_605424, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_605424 != nil:
    section.add "Version", valid_605424
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_605425 = header.getOrDefault("X-Amz-Date")
  valid_605425 = validateParameter(valid_605425, JString, required = false,
                                 default = nil)
  if valid_605425 != nil:
    section.add "X-Amz-Date", valid_605425
  var valid_605426 = header.getOrDefault("X-Amz-Security-Token")
  valid_605426 = validateParameter(valid_605426, JString, required = false,
                                 default = nil)
  if valid_605426 != nil:
    section.add "X-Amz-Security-Token", valid_605426
  var valid_605427 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605427 = validateParameter(valid_605427, JString, required = false,
                                 default = nil)
  if valid_605427 != nil:
    section.add "X-Amz-Content-Sha256", valid_605427
  var valid_605428 = header.getOrDefault("X-Amz-Algorithm")
  valid_605428 = validateParameter(valid_605428, JString, required = false,
                                 default = nil)
  if valid_605428 != nil:
    section.add "X-Amz-Algorithm", valid_605428
  var valid_605429 = header.getOrDefault("X-Amz-Signature")
  valid_605429 = validateParameter(valid_605429, JString, required = false,
                                 default = nil)
  if valid_605429 != nil:
    section.add "X-Amz-Signature", valid_605429
  var valid_605430 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605430 = validateParameter(valid_605430, JString, required = false,
                                 default = nil)
  if valid_605430 != nil:
    section.add "X-Amz-SignedHeaders", valid_605430
  var valid_605431 = header.getOrDefault("X-Amz-Credential")
  valid_605431 = validateParameter(valid_605431, JString, required = false,
                                 default = nil)
  if valid_605431 != nil:
    section.add "X-Amz-Credential", valid_605431
  result.add "header", section
  ## parameters in `formData` object:
  ##   ReservedNodeId: JString (required)
  ##                 : A string representing the node identifier for the DC1 Reserved Node to be exchanged.
  ##   Marker: JString
  ##         : A value that indicates the starting point for the next set of ReservedNodeOfferings.
  ##   MaxRecords: JInt
  ##             : An integer setting the maximum number of ReservedNodeOfferings to retrieve.
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `ReservedNodeId` field"
  var valid_605432 = formData.getOrDefault("ReservedNodeId")
  valid_605432 = validateParameter(valid_605432, JString, required = true,
                                 default = nil)
  if valid_605432 != nil:
    section.add "ReservedNodeId", valid_605432
  var valid_605433 = formData.getOrDefault("Marker")
  valid_605433 = validateParameter(valid_605433, JString, required = false,
                                 default = nil)
  if valid_605433 != nil:
    section.add "Marker", valid_605433
  var valid_605434 = formData.getOrDefault("MaxRecords")
  valid_605434 = validateParameter(valid_605434, JInt, required = false, default = nil)
  if valid_605434 != nil:
    section.add "MaxRecords", valid_605434
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_605435: Call_PostGetReservedNodeExchangeOfferings_605420;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Returns an array of DC2 ReservedNodeOfferings that matches the payment type, term, and usage price of the given DC1 reserved node.
  ## 
  let valid = call_605435.validator(path, query, header, formData, body)
  let scheme = call_605435.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605435.url(scheme.get, call_605435.host, call_605435.base,
                         call_605435.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_605435, url, valid)

proc call*(call_605436: Call_PostGetReservedNodeExchangeOfferings_605420;
          ReservedNodeId: string; Marker: string = "";
          Action: string = "GetReservedNodeExchangeOfferings"; MaxRecords: int = 0;
          Version: string = "2012-12-01"): Recallable =
  ## postGetReservedNodeExchangeOfferings
  ## Returns an array of DC2 ReservedNodeOfferings that matches the payment type, term, and usage price of the given DC1 reserved node.
  ##   ReservedNodeId: string (required)
  ##                 : A string representing the node identifier for the DC1 Reserved Node to be exchanged.
  ##   Marker: string
  ##         : A value that indicates the starting point for the next set of ReservedNodeOfferings.
  ##   Action: string (required)
  ##   MaxRecords: int
  ##             : An integer setting the maximum number of ReservedNodeOfferings to retrieve.
  ##   Version: string (required)
  var query_605437 = newJObject()
  var formData_605438 = newJObject()
  add(formData_605438, "ReservedNodeId", newJString(ReservedNodeId))
  add(formData_605438, "Marker", newJString(Marker))
  add(query_605437, "Action", newJString(Action))
  add(formData_605438, "MaxRecords", newJInt(MaxRecords))
  add(query_605437, "Version", newJString(Version))
  result = call_605436.call(nil, query_605437, nil, formData_605438, nil)

var postGetReservedNodeExchangeOfferings* = Call_PostGetReservedNodeExchangeOfferings_605420(
    name: "postGetReservedNodeExchangeOfferings", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=GetReservedNodeExchangeOfferings",
    validator: validate_PostGetReservedNodeExchangeOfferings_605421, base: "/",
    url: url_PostGetReservedNodeExchangeOfferings_605422,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetGetReservedNodeExchangeOfferings_605402 = ref object of OpenApiRestCall_602450
proc url_GetGetReservedNodeExchangeOfferings_605404(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetGetReservedNodeExchangeOfferings_605403(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns an array of DC2 ReservedNodeOfferings that matches the payment type, term, and usage price of the given DC1 reserved node.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   MaxRecords: JInt
  ##             : An integer setting the maximum number of ReservedNodeOfferings to retrieve.
  ##   Action: JString (required)
  ##   Marker: JString
  ##         : A value that indicates the starting point for the next set of ReservedNodeOfferings.
  ##   Version: JString (required)
  ##   ReservedNodeId: JString (required)
  ##                 : A string representing the node identifier for the DC1 Reserved Node to be exchanged.
  section = newJObject()
  var valid_605405 = query.getOrDefault("MaxRecords")
  valid_605405 = validateParameter(valid_605405, JInt, required = false, default = nil)
  if valid_605405 != nil:
    section.add "MaxRecords", valid_605405
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_605406 = query.getOrDefault("Action")
  valid_605406 = validateParameter(valid_605406, JString, required = true, default = newJString(
      "GetReservedNodeExchangeOfferings"))
  if valid_605406 != nil:
    section.add "Action", valid_605406
  var valid_605407 = query.getOrDefault("Marker")
  valid_605407 = validateParameter(valid_605407, JString, required = false,
                                 default = nil)
  if valid_605407 != nil:
    section.add "Marker", valid_605407
  var valid_605408 = query.getOrDefault("Version")
  valid_605408 = validateParameter(valid_605408, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_605408 != nil:
    section.add "Version", valid_605408
  var valid_605409 = query.getOrDefault("ReservedNodeId")
  valid_605409 = validateParameter(valid_605409, JString, required = true,
                                 default = nil)
  if valid_605409 != nil:
    section.add "ReservedNodeId", valid_605409
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_605410 = header.getOrDefault("X-Amz-Date")
  valid_605410 = validateParameter(valid_605410, JString, required = false,
                                 default = nil)
  if valid_605410 != nil:
    section.add "X-Amz-Date", valid_605410
  var valid_605411 = header.getOrDefault("X-Amz-Security-Token")
  valid_605411 = validateParameter(valid_605411, JString, required = false,
                                 default = nil)
  if valid_605411 != nil:
    section.add "X-Amz-Security-Token", valid_605411
  var valid_605412 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605412 = validateParameter(valid_605412, JString, required = false,
                                 default = nil)
  if valid_605412 != nil:
    section.add "X-Amz-Content-Sha256", valid_605412
  var valid_605413 = header.getOrDefault("X-Amz-Algorithm")
  valid_605413 = validateParameter(valid_605413, JString, required = false,
                                 default = nil)
  if valid_605413 != nil:
    section.add "X-Amz-Algorithm", valid_605413
  var valid_605414 = header.getOrDefault("X-Amz-Signature")
  valid_605414 = validateParameter(valid_605414, JString, required = false,
                                 default = nil)
  if valid_605414 != nil:
    section.add "X-Amz-Signature", valid_605414
  var valid_605415 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605415 = validateParameter(valid_605415, JString, required = false,
                                 default = nil)
  if valid_605415 != nil:
    section.add "X-Amz-SignedHeaders", valid_605415
  var valid_605416 = header.getOrDefault("X-Amz-Credential")
  valid_605416 = validateParameter(valid_605416, JString, required = false,
                                 default = nil)
  if valid_605416 != nil:
    section.add "X-Amz-Credential", valid_605416
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_605417: Call_GetGetReservedNodeExchangeOfferings_605402;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Returns an array of DC2 ReservedNodeOfferings that matches the payment type, term, and usage price of the given DC1 reserved node.
  ## 
  let valid = call_605417.validator(path, query, header, formData, body)
  let scheme = call_605417.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605417.url(scheme.get, call_605417.host, call_605417.base,
                         call_605417.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_605417, url, valid)

proc call*(call_605418: Call_GetGetReservedNodeExchangeOfferings_605402;
          ReservedNodeId: string; MaxRecords: int = 0;
          Action: string = "GetReservedNodeExchangeOfferings"; Marker: string = "";
          Version: string = "2012-12-01"): Recallable =
  ## getGetReservedNodeExchangeOfferings
  ## Returns an array of DC2 ReservedNodeOfferings that matches the payment type, term, and usage price of the given DC1 reserved node.
  ##   MaxRecords: int
  ##             : An integer setting the maximum number of ReservedNodeOfferings to retrieve.
  ##   Action: string (required)
  ##   Marker: string
  ##         : A value that indicates the starting point for the next set of ReservedNodeOfferings.
  ##   Version: string (required)
  ##   ReservedNodeId: string (required)
  ##                 : A string representing the node identifier for the DC1 Reserved Node to be exchanged.
  var query_605419 = newJObject()
  add(query_605419, "MaxRecords", newJInt(MaxRecords))
  add(query_605419, "Action", newJString(Action))
  add(query_605419, "Marker", newJString(Marker))
  add(query_605419, "Version", newJString(Version))
  add(query_605419, "ReservedNodeId", newJString(ReservedNodeId))
  result = call_605418.call(nil, query_605419, nil, nil, nil)

var getGetReservedNodeExchangeOfferings* = Call_GetGetReservedNodeExchangeOfferings_605402(
    name: "getGetReservedNodeExchangeOfferings", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=GetReservedNodeExchangeOfferings",
    validator: validate_GetGetReservedNodeExchangeOfferings_605403, base: "/",
    url: url_GetGetReservedNodeExchangeOfferings_605404,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostModifyCluster_605476 = ref object of OpenApiRestCall_602450
proc url_PostModifyCluster_605478(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostModifyCluster_605477(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## <p>Modifies the settings for a cluster. For example, you can add another security or parameter group, update the preferred maintenance window, or change the master user password. Resetting a cluster password or modifying the security groups associated with a cluster do not need a reboot. However, modifying a parameter group requires a reboot for parameters to take effect. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>You can also change node type and the number of nodes to scale up or down the cluster. When resizing a cluster, you must specify both the number of nodes and the node type even if one of the parameters does not change.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_605479 = query.getOrDefault("Action")
  valid_605479 = validateParameter(valid_605479, JString, required = true,
                                 default = newJString("ModifyCluster"))
  if valid_605479 != nil:
    section.add "Action", valid_605479
  var valid_605480 = query.getOrDefault("Version")
  valid_605480 = validateParameter(valid_605480, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_605480 != nil:
    section.add "Version", valid_605480
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_605481 = header.getOrDefault("X-Amz-Date")
  valid_605481 = validateParameter(valid_605481, JString, required = false,
                                 default = nil)
  if valid_605481 != nil:
    section.add "X-Amz-Date", valid_605481
  var valid_605482 = header.getOrDefault("X-Amz-Security-Token")
  valid_605482 = validateParameter(valid_605482, JString, required = false,
                                 default = nil)
  if valid_605482 != nil:
    section.add "X-Amz-Security-Token", valid_605482
  var valid_605483 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605483 = validateParameter(valid_605483, JString, required = false,
                                 default = nil)
  if valid_605483 != nil:
    section.add "X-Amz-Content-Sha256", valid_605483
  var valid_605484 = header.getOrDefault("X-Amz-Algorithm")
  valid_605484 = validateParameter(valid_605484, JString, required = false,
                                 default = nil)
  if valid_605484 != nil:
    section.add "X-Amz-Algorithm", valid_605484
  var valid_605485 = header.getOrDefault("X-Amz-Signature")
  valid_605485 = validateParameter(valid_605485, JString, required = false,
                                 default = nil)
  if valid_605485 != nil:
    section.add "X-Amz-Signature", valid_605485
  var valid_605486 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605486 = validateParameter(valid_605486, JString, required = false,
                                 default = nil)
  if valid_605486 != nil:
    section.add "X-Amz-SignedHeaders", valid_605486
  var valid_605487 = header.getOrDefault("X-Amz-Credential")
  valid_605487 = validateParameter(valid_605487, JString, required = false,
                                 default = nil)
  if valid_605487 != nil:
    section.add "X-Amz-Credential", valid_605487
  result.add "header", section
  ## parameters in `formData` object:
  ##   EnhancedVpcRouting: JBool
  ##                     : <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p> <p>Default: false</p>
  ##   VpcSecurityGroupIds: JArray
  ##                      : A list of virtual private cloud (VPC) security groups to be associated with the cluster. This change is asynchronously applied as soon as possible.
  ##   ClusterVersion: JString
  ##                 : <p>The new version number of the Amazon Redshift engine to upgrade to.</p> <p>For major version upgrades, if a non-default cluster parameter group is currently in use, a new cluster parameter group in the cluster parameter group family for the new version must be specified. The new cluster parameter group can be the default for that cluster parameter group family. For more information about parameters and parameter groups, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>Example: <code>1.0</code> </p>
  ##   ClusterType: JString
  ##              : <p>The new cluster type.</p> <p>When you submit your cluster resize request, your existing cluster goes into a read-only mode. After Amazon Redshift provisions a new cluster based on your resize requirements, there will be outage for a period while the old cluster is deleted and your connection is switched to the new cluster. You can use <a>DescribeResize</a> to track the progress of the resize request. </p> <p>Valid Values: <code> multi-node | single-node </code> </p>
  ##   MasterUserPassword: JString
  ##                     : <p>The new password for the cluster master user. This change is asynchronously applied as soon as possible. Between the time of the request and the completion of the request, the <code>MasterUserPassword</code> element exists in the <code>PendingModifiedValues</code> element of the operation response. </p> <note> <p>Operations never return the password, so this operation provides a way to regain access to the master user account for a cluster if the password is lost.</p> </note> <p>Default: Uses existing setting.</p> <p>Constraints:</p> <ul> <li> <p>Must be between 8 and 64 characters in length.</p> </li> <li> <p>Must contain at least one uppercase letter.</p> </li> <li> <p>Must contain at least one lowercase letter.</p> </li> <li> <p>Must contain one number.</p> </li> <li> <p>Can be any printable ASCII character (ASCII code 33 to 126) except ' (single quote), " (double quote), \, /, @, or space.</p> </li> </ul>
  ##   ClusterSecurityGroups: JArray
  ##                        : <p>A list of cluster security groups to be authorized on this cluster. This change is asynchronously applied as soon as possible.</p> <p>Security groups currently associated with the cluster, and not in the list of groups to apply, will be revoked from the cluster.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens</p> </li> <li> <p>First character must be a letter</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens</p> </li> </ul>
  ##   Encrypted: JBool
  ##            : Indicates whether the cluster is encrypted. If the cluster is encrypted and you provide a value for the <code>KmsKeyId</code> parameter, we will encrypt the cluster with the provided <code>KmsKeyId</code>. If you don't provide a <code>KmsKeyId</code>, we will encrypt with the default key. In the China region we will use legacy encryption if you specify that the cluster is encrypted.
  ##   HsmConfigurationIdentifier: JString
  ##                             : Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
  ##   HsmClientCertificateIdentifier: JString
  ##                                 : Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM.
  ##   PubliclyAccessible: JBool
  ##                     : If <code>true</code>, the cluster can be accessed from a public network. Only clusters in VPCs can be set to be publicly available.
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of the cluster to be modified.</p> <p>Example: <code>examplecluster</code> </p>
  ##   NumberOfNodes: JInt
  ##                : <p>The new number of nodes of the cluster. If you specify a new number of nodes, you must also specify the node type parameter.</p> <p>When you submit your request to resize a cluster, Amazon Redshift sets access permissions for the cluster to read-only. After Amazon Redshift provisions a new cluster according to your resize requirements, there will be a temporary outage while the old cluster is deleted and your connection is switched to the new cluster. When the new connection is complete, the original access permissions for the cluster are restored. You can use <a>DescribeResize</a> to track the progress of the resize request. </p> <p>Valid Values: Integer greater than <code>0</code>.</p>
  ##   ClusterParameterGroupName: JString
  ##                            : <p>The name of the cluster parameter group to apply to this cluster. This change is applied only after the cluster is rebooted. To reboot a cluster use <a>RebootCluster</a>. </p> <p>Default: Uses existing setting.</p> <p>Constraints: The cluster parameter group must be in the same parameter group family that matches the cluster version.</p>
  ##   KmsKeyId: JString
  ##           : The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster.
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The default for number of days that a newly created manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. This value doesn't retroactively change the retention periods of existing manual snapshots.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  ##   ElasticIp: JString
  ##            : <p>The Elastic IP (EIP) address for the cluster.</p> <p>Constraints: The cluster must be provisioned in EC2-VPC and publicly-accessible through an Internet gateway. For more information about provisioning clusters in EC2-VPC, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#cluster-platforms">Supported Platforms to Launch Your Cluster</a> in the Amazon Redshift Cluster Management Guide.</p>
  ##   NewClusterIdentifier: JString
  ##                       : <p>The new identifier for the cluster.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul> <p>Example: <code>examplecluster</code> </p>
  ##   AllowVersionUpgrade: JBool
  ##                      : <p>If <code>true</code>, major version upgrades will be applied automatically to the cluster during the maintenance window. </p> <p>Default: <code>false</code> </p>
  ##   AutomatedSnapshotRetentionPeriod: JInt
  ##                                   : <p>The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p> <p>If you decrease the automated snapshot retention period from its current value, existing automated snapshots that fall outside of the new retention period will be immediately deleted.</p> <p>Default: Uses existing setting.</p> <p>Constraints: Must be a value from 0 to 35.</p>
  ##   NodeType: JString
  ##           : <p>The new node type of the cluster. If you specify a new node type, you must also specify the number of nodes parameter.</p> <p>When you submit your request to resize a cluster, Amazon Redshift sets access permissions for the cluster to read-only. After Amazon Redshift provisions a new cluster according to your resize requirements, there will be a temporary outage while the old cluster is deleted and your connection is switched to the new cluster. When the new connection is complete, the original access permissions for the cluster are restored. You can use <a>DescribeResize</a> to track the progress of the resize request. </p> <p>Valid Values: <code>ds2.xlarge</code> | <code>ds2.8xlarge</code> | <code>dc1.large</code> | <code>dc1.8xlarge</code> | <code>dc2.large</code> | <code>dc2.8xlarge</code> </p>
  ##   MaintenanceTrackName: JString
  ##                       : The name for the maintenance track that you want to assign for the cluster. This name change is asynchronous. The new track name stays in the <code>PendingModifiedValues</code> for the cluster until the next maintenance window. When the maintenance track changes, the cluster is switched to the latest cluster release available for the maintenance track. At this point, the maintenance track name is applied.
  ##   PreferredMaintenanceWindow: JString
  ##                             : <p>The weekly time range (in UTC) during which system maintenance can occur, if necessary. If system maintenance is necessary during the window, it may result in an outage.</p> <p>This maintenance window change is made immediately. If the new maintenance window indicates the current time, there must be at least 120 minutes between the current time and end of the window in order to ensure that pending changes are applied.</p> <p>Default: Uses existing setting.</p> <p>Format: ddd:hh24:mi-ddd:hh24:mi, for example <code>wed:07:30-wed:08:00</code>.</p> <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p> <p>Constraints: Must be at least 30 minutes.</p>
  section = newJObject()
  var valid_605488 = formData.getOrDefault("EnhancedVpcRouting")
  valid_605488 = validateParameter(valid_605488, JBool, required = false, default = nil)
  if valid_605488 != nil:
    section.add "EnhancedVpcRouting", valid_605488
  var valid_605489 = formData.getOrDefault("VpcSecurityGroupIds")
  valid_605489 = validateParameter(valid_605489, JArray, required = false,
                                 default = nil)
  if valid_605489 != nil:
    section.add "VpcSecurityGroupIds", valid_605489
  var valid_605490 = formData.getOrDefault("ClusterVersion")
  valid_605490 = validateParameter(valid_605490, JString, required = false,
                                 default = nil)
  if valid_605490 != nil:
    section.add "ClusterVersion", valid_605490
  var valid_605491 = formData.getOrDefault("ClusterType")
  valid_605491 = validateParameter(valid_605491, JString, required = false,
                                 default = nil)
  if valid_605491 != nil:
    section.add "ClusterType", valid_605491
  var valid_605492 = formData.getOrDefault("MasterUserPassword")
  valid_605492 = validateParameter(valid_605492, JString, required = false,
                                 default = nil)
  if valid_605492 != nil:
    section.add "MasterUserPassword", valid_605492
  var valid_605493 = formData.getOrDefault("ClusterSecurityGroups")
  valid_605493 = validateParameter(valid_605493, JArray, required = false,
                                 default = nil)
  if valid_605493 != nil:
    section.add "ClusterSecurityGroups", valid_605493
  var valid_605494 = formData.getOrDefault("Encrypted")
  valid_605494 = validateParameter(valid_605494, JBool, required = false, default = nil)
  if valid_605494 != nil:
    section.add "Encrypted", valid_605494
  var valid_605495 = formData.getOrDefault("HsmConfigurationIdentifier")
  valid_605495 = validateParameter(valid_605495, JString, required = false,
                                 default = nil)
  if valid_605495 != nil:
    section.add "HsmConfigurationIdentifier", valid_605495
  var valid_605496 = formData.getOrDefault("HsmClientCertificateIdentifier")
  valid_605496 = validateParameter(valid_605496, JString, required = false,
                                 default = nil)
  if valid_605496 != nil:
    section.add "HsmClientCertificateIdentifier", valid_605496
  var valid_605497 = formData.getOrDefault("PubliclyAccessible")
  valid_605497 = validateParameter(valid_605497, JBool, required = false, default = nil)
  if valid_605497 != nil:
    section.add "PubliclyAccessible", valid_605497
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_605498 = formData.getOrDefault("ClusterIdentifier")
  valid_605498 = validateParameter(valid_605498, JString, required = true,
                                 default = nil)
  if valid_605498 != nil:
    section.add "ClusterIdentifier", valid_605498
  var valid_605499 = formData.getOrDefault("NumberOfNodes")
  valid_605499 = validateParameter(valid_605499, JInt, required = false, default = nil)
  if valid_605499 != nil:
    section.add "NumberOfNodes", valid_605499
  var valid_605500 = formData.getOrDefault("ClusterParameterGroupName")
  valid_605500 = validateParameter(valid_605500, JString, required = false,
                                 default = nil)
  if valid_605500 != nil:
    section.add "ClusterParameterGroupName", valid_605500
  var valid_605501 = formData.getOrDefault("KmsKeyId")
  valid_605501 = validateParameter(valid_605501, JString, required = false,
                                 default = nil)
  if valid_605501 != nil:
    section.add "KmsKeyId", valid_605501
  var valid_605502 = formData.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_605502 = validateParameter(valid_605502, JInt, required = false, default = nil)
  if valid_605502 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_605502
  var valid_605503 = formData.getOrDefault("ElasticIp")
  valid_605503 = validateParameter(valid_605503, JString, required = false,
                                 default = nil)
  if valid_605503 != nil:
    section.add "ElasticIp", valid_605503
  var valid_605504 = formData.getOrDefault("NewClusterIdentifier")
  valid_605504 = validateParameter(valid_605504, JString, required = false,
                                 default = nil)
  if valid_605504 != nil:
    section.add "NewClusterIdentifier", valid_605504
  var valid_605505 = formData.getOrDefault("AllowVersionUpgrade")
  valid_605505 = validateParameter(valid_605505, JBool, required = false, default = nil)
  if valid_605505 != nil:
    section.add "AllowVersionUpgrade", valid_605505
  var valid_605506 = formData.getOrDefault("AutomatedSnapshotRetentionPeriod")
  valid_605506 = validateParameter(valid_605506, JInt, required = false, default = nil)
  if valid_605506 != nil:
    section.add "AutomatedSnapshotRetentionPeriod", valid_605506
  var valid_605507 = formData.getOrDefault("NodeType")
  valid_605507 = validateParameter(valid_605507, JString, required = false,
                                 default = nil)
  if valid_605507 != nil:
    section.add "NodeType", valid_605507
  var valid_605508 = formData.getOrDefault("MaintenanceTrackName")
  valid_605508 = validateParameter(valid_605508, JString, required = false,
                                 default = nil)
  if valid_605508 != nil:
    section.add "MaintenanceTrackName", valid_605508
  var valid_605509 = formData.getOrDefault("PreferredMaintenanceWindow")
  valid_605509 = validateParameter(valid_605509, JString, required = false,
                                 default = nil)
  if valid_605509 != nil:
    section.add "PreferredMaintenanceWindow", valid_605509
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_605510: Call_PostModifyCluster_605476; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Modifies the settings for a cluster. For example, you can add another security or parameter group, update the preferred maintenance window, or change the master user password. Resetting a cluster password or modifying the security groups associated with a cluster do not need a reboot. However, modifying a parameter group requires a reboot for parameters to take effect. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>You can also change node type and the number of nodes to scale up or down the cluster. When resizing a cluster, you must specify both the number of nodes and the node type even if one of the parameters does not change.</p>
  ## 
  let valid = call_605510.validator(path, query, header, formData, body)
  let scheme = call_605510.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605510.url(scheme.get, call_605510.host, call_605510.base,
                         call_605510.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_605510, url, valid)

proc call*(call_605511: Call_PostModifyCluster_605476; ClusterIdentifier: string;
          EnhancedVpcRouting: bool = false; VpcSecurityGroupIds: JsonNode = nil;
          ClusterVersion: string = ""; ClusterType: string = "";
          MasterUserPassword: string = ""; ClusterSecurityGroups: JsonNode = nil;
          Encrypted: bool = false; HsmConfigurationIdentifier: string = "";
          Action: string = "ModifyCluster";
          HsmClientCertificateIdentifier: string = "";
          PubliclyAccessible: bool = false; NumberOfNodes: int = 0;
          ClusterParameterGroupName: string = ""; KmsKeyId: string = "";
          ManualSnapshotRetentionPeriod: int = 0; ElasticIp: string = "";
          NewClusterIdentifier: string = ""; AllowVersionUpgrade: bool = false;
          AutomatedSnapshotRetentionPeriod: int = 0; Version: string = "2012-12-01";
          NodeType: string = ""; MaintenanceTrackName: string = "";
          PreferredMaintenanceWindow: string = ""): Recallable =
  ## postModifyCluster
  ## <p>Modifies the settings for a cluster. For example, you can add another security or parameter group, update the preferred maintenance window, or change the master user password. Resetting a cluster password or modifying the security groups associated with a cluster do not need a reboot. However, modifying a parameter group requires a reboot for parameters to take effect. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>You can also change node type and the number of nodes to scale up or down the cluster. When resizing a cluster, you must specify both the number of nodes and the node type even if one of the parameters does not change.</p>
  ##   EnhancedVpcRouting: bool
  ##                     : <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p> <p>Default: false</p>
  ##   VpcSecurityGroupIds: JArray
  ##                      : A list of virtual private cloud (VPC) security groups to be associated with the cluster. This change is asynchronously applied as soon as possible.
  ##   ClusterVersion: string
  ##                 : <p>The new version number of the Amazon Redshift engine to upgrade to.</p> <p>For major version upgrades, if a non-default cluster parameter group is currently in use, a new cluster parameter group in the cluster parameter group family for the new version must be specified. The new cluster parameter group can be the default for that cluster parameter group family. For more information about parameters and parameter groups, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>Example: <code>1.0</code> </p>
  ##   ClusterType: string
  ##              : <p>The new cluster type.</p> <p>When you submit your cluster resize request, your existing cluster goes into a read-only mode. After Amazon Redshift provisions a new cluster based on your resize requirements, there will be outage for a period while the old cluster is deleted and your connection is switched to the new cluster. You can use <a>DescribeResize</a> to track the progress of the resize request. </p> <p>Valid Values: <code> multi-node | single-node </code> </p>
  ##   MasterUserPassword: string
  ##                     : <p>The new password for the cluster master user. This change is asynchronously applied as soon as possible. Between the time of the request and the completion of the request, the <code>MasterUserPassword</code> element exists in the <code>PendingModifiedValues</code> element of the operation response. </p> <note> <p>Operations never return the password, so this operation provides a way to regain access to the master user account for a cluster if the password is lost.</p> </note> <p>Default: Uses existing setting.</p> <p>Constraints:</p> <ul> <li> <p>Must be between 8 and 64 characters in length.</p> </li> <li> <p>Must contain at least one uppercase letter.</p> </li> <li> <p>Must contain at least one lowercase letter.</p> </li> <li> <p>Must contain one number.</p> </li> <li> <p>Can be any printable ASCII character (ASCII code 33 to 126) except ' (single quote), " (double quote), \, /, @, or space.</p> </li> </ul>
  ##   ClusterSecurityGroups: JArray
  ##                        : <p>A list of cluster security groups to be authorized on this cluster. This change is asynchronously applied as soon as possible.</p> <p>Security groups currently associated with the cluster, and not in the list of groups to apply, will be revoked from the cluster.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens</p> </li> <li> <p>First character must be a letter</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens</p> </li> </ul>
  ##   Encrypted: bool
  ##            : Indicates whether the cluster is encrypted. If the cluster is encrypted and you provide a value for the <code>KmsKeyId</code> parameter, we will encrypt the cluster with the provided <code>KmsKeyId</code>. If you don't provide a <code>KmsKeyId</code>, we will encrypt with the default key. In the China region we will use legacy encryption if you specify that the cluster is encrypted.
  ##   HsmConfigurationIdentifier: string
  ##                             : Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
  ##   Action: string (required)
  ##   HsmClientCertificateIdentifier: string
  ##                                 : Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM.
  ##   PubliclyAccessible: bool
  ##                     : If <code>true</code>, the cluster can be accessed from a public network. Only clusters in VPCs can be set to be publicly available.
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of the cluster to be modified.</p> <p>Example: <code>examplecluster</code> </p>
  ##   NumberOfNodes: int
  ##                : <p>The new number of nodes of the cluster. If you specify a new number of nodes, you must also specify the node type parameter.</p> <p>When you submit your request to resize a cluster, Amazon Redshift sets access permissions for the cluster to read-only. After Amazon Redshift provisions a new cluster according to your resize requirements, there will be a temporary outage while the old cluster is deleted and your connection is switched to the new cluster. When the new connection is complete, the original access permissions for the cluster are restored. You can use <a>DescribeResize</a> to track the progress of the resize request. </p> <p>Valid Values: Integer greater than <code>0</code>.</p>
  ##   ClusterParameterGroupName: string
  ##                            : <p>The name of the cluster parameter group to apply to this cluster. This change is applied only after the cluster is rebooted. To reboot a cluster use <a>RebootCluster</a>. </p> <p>Default: Uses existing setting.</p> <p>Constraints: The cluster parameter group must be in the same parameter group family that matches the cluster version.</p>
  ##   KmsKeyId: string
  ##           : The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster.
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The default for number of days that a newly created manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. This value doesn't retroactively change the retention periods of existing manual snapshots.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  ##   ElasticIp: string
  ##            : <p>The Elastic IP (EIP) address for the cluster.</p> <p>Constraints: The cluster must be provisioned in EC2-VPC and publicly-accessible through an Internet gateway. For more information about provisioning clusters in EC2-VPC, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#cluster-platforms">Supported Platforms to Launch Your Cluster</a> in the Amazon Redshift Cluster Management Guide.</p>
  ##   NewClusterIdentifier: string
  ##                       : <p>The new identifier for the cluster.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul> <p>Example: <code>examplecluster</code> </p>
  ##   AllowVersionUpgrade: bool
  ##                      : <p>If <code>true</code>, major version upgrades will be applied automatically to the cluster during the maintenance window. </p> <p>Default: <code>false</code> </p>
  ##   AutomatedSnapshotRetentionPeriod: int
  ##                                   : <p>The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p> <p>If you decrease the automated snapshot retention period from its current value, existing automated snapshots that fall outside of the new retention period will be immediately deleted.</p> <p>Default: Uses existing setting.</p> <p>Constraints: Must be a value from 0 to 35.</p>
  ##   Version: string (required)
  ##   NodeType: string
  ##           : <p>The new node type of the cluster. If you specify a new node type, you must also specify the number of nodes parameter.</p> <p>When you submit your request to resize a cluster, Amazon Redshift sets access permissions for the cluster to read-only. After Amazon Redshift provisions a new cluster according to your resize requirements, there will be a temporary outage while the old cluster is deleted and your connection is switched to the new cluster. When the new connection is complete, the original access permissions for the cluster are restored. You can use <a>DescribeResize</a> to track the progress of the resize request. </p> <p>Valid Values: <code>ds2.xlarge</code> | <code>ds2.8xlarge</code> | <code>dc1.large</code> | <code>dc1.8xlarge</code> | <code>dc2.large</code> | <code>dc2.8xlarge</code> </p>
  ##   MaintenanceTrackName: string
  ##                       : The name for the maintenance track that you want to assign for the cluster. This name change is asynchronous. The new track name stays in the <code>PendingModifiedValues</code> for the cluster until the next maintenance window. When the maintenance track changes, the cluster is switched to the latest cluster release available for the maintenance track. At this point, the maintenance track name is applied.
  ##   PreferredMaintenanceWindow: string
  ##                             : <p>The weekly time range (in UTC) during which system maintenance can occur, if necessary. If system maintenance is necessary during the window, it may result in an outage.</p> <p>This maintenance window change is made immediately. If the new maintenance window indicates the current time, there must be at least 120 minutes between the current time and end of the window in order to ensure that pending changes are applied.</p> <p>Default: Uses existing setting.</p> <p>Format: ddd:hh24:mi-ddd:hh24:mi, for example <code>wed:07:30-wed:08:00</code>.</p> <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p> <p>Constraints: Must be at least 30 minutes.</p>
  var query_605512 = newJObject()
  var formData_605513 = newJObject()
  add(formData_605513, "EnhancedVpcRouting", newJBool(EnhancedVpcRouting))
  if VpcSecurityGroupIds != nil:
    formData_605513.add "VpcSecurityGroupIds", VpcSecurityGroupIds
  add(formData_605513, "ClusterVersion", newJString(ClusterVersion))
  add(formData_605513, "ClusterType", newJString(ClusterType))
  add(formData_605513, "MasterUserPassword", newJString(MasterUserPassword))
  if ClusterSecurityGroups != nil:
    formData_605513.add "ClusterSecurityGroups", ClusterSecurityGroups
  add(formData_605513, "Encrypted", newJBool(Encrypted))
  add(formData_605513, "HsmConfigurationIdentifier",
      newJString(HsmConfigurationIdentifier))
  add(query_605512, "Action", newJString(Action))
  add(formData_605513, "HsmClientCertificateIdentifier",
      newJString(HsmClientCertificateIdentifier))
  add(formData_605513, "PubliclyAccessible", newJBool(PubliclyAccessible))
  add(formData_605513, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_605513, "NumberOfNodes", newJInt(NumberOfNodes))
  add(formData_605513, "ClusterParameterGroupName",
      newJString(ClusterParameterGroupName))
  add(formData_605513, "KmsKeyId", newJString(KmsKeyId))
  add(formData_605513, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  add(formData_605513, "ElasticIp", newJString(ElasticIp))
  add(formData_605513, "NewClusterIdentifier", newJString(NewClusterIdentifier))
  add(formData_605513, "AllowVersionUpgrade", newJBool(AllowVersionUpgrade))
  add(formData_605513, "AutomatedSnapshotRetentionPeriod",
      newJInt(AutomatedSnapshotRetentionPeriod))
  add(query_605512, "Version", newJString(Version))
  add(formData_605513, "NodeType", newJString(NodeType))
  add(formData_605513, "MaintenanceTrackName", newJString(MaintenanceTrackName))
  add(formData_605513, "PreferredMaintenanceWindow",
      newJString(PreferredMaintenanceWindow))
  result = call_605511.call(nil, query_605512, nil, formData_605513, nil)

var postModifyCluster* = Call_PostModifyCluster_605476(name: "postModifyCluster",
    meth: HttpMethod.HttpPost, host: "redshift.amazonaws.com",
    route: "/#Action=ModifyCluster", validator: validate_PostModifyCluster_605477,
    base: "/", url: url_PostModifyCluster_605478,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetModifyCluster_605439 = ref object of OpenApiRestCall_602450
proc url_GetModifyCluster_605441(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetModifyCluster_605440(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## <p>Modifies the settings for a cluster. For example, you can add another security or parameter group, update the preferred maintenance window, or change the master user password. Resetting a cluster password or modifying the security groups associated with a cluster do not need a reboot. However, modifying a parameter group requires a reboot for parameters to take effect. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>You can also change node type and the number of nodes to scale up or down the cluster. When resizing a cluster, you must specify both the number of nodes and the node type even if one of the parameters does not change.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ClusterSecurityGroups: JArray
  ##                        : <p>A list of cluster security groups to be authorized on this cluster. This change is asynchronously applied as soon as possible.</p> <p>Security groups currently associated with the cluster, and not in the list of groups to apply, will be revoked from the cluster.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens</p> </li> <li> <p>First character must be a letter</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens</p> </li> </ul>
  ##   HsmClientCertificateIdentifier: JString
  ##                                 : Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM.
  ##   PreferredMaintenanceWindow: JString
  ##                             : <p>The weekly time range (in UTC) during which system maintenance can occur, if necessary. If system maintenance is necessary during the window, it may result in an outage.</p> <p>This maintenance window change is made immediately. If the new maintenance window indicates the current time, there must be at least 120 minutes between the current time and end of the window in order to ensure that pending changes are applied.</p> <p>Default: Uses existing setting.</p> <p>Format: ddd:hh24:mi-ddd:hh24:mi, for example <code>wed:07:30-wed:08:00</code>.</p> <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p> <p>Constraints: Must be at least 30 minutes.</p>
  ##   Encrypted: JBool
  ##            : Indicates whether the cluster is encrypted. If the cluster is encrypted and you provide a value for the <code>KmsKeyId</code> parameter, we will encrypt the cluster with the provided <code>KmsKeyId</code>. If you don't provide a <code>KmsKeyId</code>, we will encrypt with the default key. In the China region we will use legacy encryption if you specify that the cluster is encrypted.
  ##   MaintenanceTrackName: JString
  ##                       : The name for the maintenance track that you want to assign for the cluster. This name change is asynchronous. The new track name stays in the <code>PendingModifiedValues</code> for the cluster until the next maintenance window. When the maintenance track changes, the cluster is switched to the latest cluster release available for the maintenance track. At this point, the maintenance track name is applied.
  ##   MasterUserPassword: JString
  ##                     : <p>The new password for the cluster master user. This change is asynchronously applied as soon as possible. Between the time of the request and the completion of the request, the <code>MasterUserPassword</code> element exists in the <code>PendingModifiedValues</code> element of the operation response. </p> <note> <p>Operations never return the password, so this operation provides a way to regain access to the master user account for a cluster if the password is lost.</p> </note> <p>Default: Uses existing setting.</p> <p>Constraints:</p> <ul> <li> <p>Must be between 8 and 64 characters in length.</p> </li> <li> <p>Must contain at least one uppercase letter.</p> </li> <li> <p>Must contain at least one lowercase letter.</p> </li> <li> <p>Must contain one number.</p> </li> <li> <p>Can be any printable ASCII character (ASCII code 33 to 126) except ' (single quote), " (double quote), \, /, @, or space.</p> </li> </ul>
  ##   AllowVersionUpgrade: JBool
  ##                      : <p>If <code>true</code>, major version upgrades will be applied automatically to the cluster during the maintenance window. </p> <p>Default: <code>false</code> </p>
  ##   EnhancedVpcRouting: JBool
  ##                     : <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p> <p>Default: false</p>
  ##   VpcSecurityGroupIds: JArray
  ##                      : A list of virtual private cloud (VPC) security groups to be associated with the cluster. This change is asynchronously applied as soon as possible.
  ##   ClusterParameterGroupName: JString
  ##                            : <p>The name of the cluster parameter group to apply to this cluster. This change is applied only after the cluster is rebooted. To reboot a cluster use <a>RebootCluster</a>. </p> <p>Default: Uses existing setting.</p> <p>Constraints: The cluster parameter group must be in the same parameter group family that matches the cluster version.</p>
  ##   HsmConfigurationIdentifier: JString
  ##                             : Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
  ##   NewClusterIdentifier: JString
  ##                       : <p>The new identifier for the cluster.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul> <p>Example: <code>examplecluster</code> </p>
  ##   ElasticIp: JString
  ##            : <p>The Elastic IP (EIP) address for the cluster.</p> <p>Constraints: The cluster must be provisioned in EC2-VPC and publicly-accessible through an Internet gateway. For more information about provisioning clusters in EC2-VPC, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#cluster-platforms">Supported Platforms to Launch Your Cluster</a> in the Amazon Redshift Cluster Management Guide.</p>
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of the cluster to be modified.</p> <p>Example: <code>examplecluster</code> </p>
  ##   Action: JString (required)
  ##   KmsKeyId: JString
  ##           : The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster.
  ##   PubliclyAccessible: JBool
  ##                     : If <code>true</code>, the cluster can be accessed from a public network. Only clusters in VPCs can be set to be publicly available.
  ##   NumberOfNodes: JInt
  ##                : <p>The new number of nodes of the cluster. If you specify a new number of nodes, you must also specify the node type parameter.</p> <p>When you submit your request to resize a cluster, Amazon Redshift sets access permissions for the cluster to read-only. After Amazon Redshift provisions a new cluster according to your resize requirements, there will be a temporary outage while the old cluster is deleted and your connection is switched to the new cluster. When the new connection is complete, the original access permissions for the cluster are restored. You can use <a>DescribeResize</a> to track the progress of the resize request. </p> <p>Valid Values: Integer greater than <code>0</code>.</p>
  ##   AutomatedSnapshotRetentionPeriod: JInt
  ##                                   : <p>The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p> <p>If you decrease the automated snapshot retention period from its current value, existing automated snapshots that fall outside of the new retention period will be immediately deleted.</p> <p>Default: Uses existing setting.</p> <p>Constraints: Must be a value from 0 to 35.</p>
  ##   NodeType: JString
  ##           : <p>The new node type of the cluster. If you specify a new node type, you must also specify the number of nodes parameter.</p> <p>When you submit your request to resize a cluster, Amazon Redshift sets access permissions for the cluster to read-only. After Amazon Redshift provisions a new cluster according to your resize requirements, there will be a temporary outage while the old cluster is deleted and your connection is switched to the new cluster. When the new connection is complete, the original access permissions for the cluster are restored. You can use <a>DescribeResize</a> to track the progress of the resize request. </p> <p>Valid Values: <code>ds2.xlarge</code> | <code>ds2.8xlarge</code> | <code>dc1.large</code> | <code>dc1.8xlarge</code> | <code>dc2.large</code> | <code>dc2.8xlarge</code> </p>
  ##   ClusterVersion: JString
  ##                 : <p>The new version number of the Amazon Redshift engine to upgrade to.</p> <p>For major version upgrades, if a non-default cluster parameter group is currently in use, a new cluster parameter group in the cluster parameter group family for the new version must be specified. The new cluster parameter group can be the default for that cluster parameter group family. For more information about parameters and parameter groups, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>Example: <code>1.0</code> </p>
  ##   Version: JString (required)
  ##   ClusterType: JString
  ##              : <p>The new cluster type.</p> <p>When you submit your cluster resize request, your existing cluster goes into a read-only mode. After Amazon Redshift provisions a new cluster based on your resize requirements, there will be outage for a period while the old cluster is deleted and your connection is switched to the new cluster. You can use <a>DescribeResize</a> to track the progress of the resize request. </p> <p>Valid Values: <code> multi-node | single-node </code> </p>
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The default for number of days that a newly created manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. This value doesn't retroactively change the retention periods of existing manual snapshots.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  section = newJObject()
  var valid_605442 = query.getOrDefault("ClusterSecurityGroups")
  valid_605442 = validateParameter(valid_605442, JArray, required = false,
                                 default = nil)
  if valid_605442 != nil:
    section.add "ClusterSecurityGroups", valid_605442
  var valid_605443 = query.getOrDefault("HsmClientCertificateIdentifier")
  valid_605443 = validateParameter(valid_605443, JString, required = false,
                                 default = nil)
  if valid_605443 != nil:
    section.add "HsmClientCertificateIdentifier", valid_605443
  var valid_605444 = query.getOrDefault("PreferredMaintenanceWindow")
  valid_605444 = validateParameter(valid_605444, JString, required = false,
                                 default = nil)
  if valid_605444 != nil:
    section.add "PreferredMaintenanceWindow", valid_605444
  var valid_605445 = query.getOrDefault("Encrypted")
  valid_605445 = validateParameter(valid_605445, JBool, required = false, default = nil)
  if valid_605445 != nil:
    section.add "Encrypted", valid_605445
  var valid_605446 = query.getOrDefault("MaintenanceTrackName")
  valid_605446 = validateParameter(valid_605446, JString, required = false,
                                 default = nil)
  if valid_605446 != nil:
    section.add "MaintenanceTrackName", valid_605446
  var valid_605447 = query.getOrDefault("MasterUserPassword")
  valid_605447 = validateParameter(valid_605447, JString, required = false,
                                 default = nil)
  if valid_605447 != nil:
    section.add "MasterUserPassword", valid_605447
  var valid_605448 = query.getOrDefault("AllowVersionUpgrade")
  valid_605448 = validateParameter(valid_605448, JBool, required = false, default = nil)
  if valid_605448 != nil:
    section.add "AllowVersionUpgrade", valid_605448
  var valid_605449 = query.getOrDefault("EnhancedVpcRouting")
  valid_605449 = validateParameter(valid_605449, JBool, required = false, default = nil)
  if valid_605449 != nil:
    section.add "EnhancedVpcRouting", valid_605449
  var valid_605450 = query.getOrDefault("VpcSecurityGroupIds")
  valid_605450 = validateParameter(valid_605450, JArray, required = false,
                                 default = nil)
  if valid_605450 != nil:
    section.add "VpcSecurityGroupIds", valid_605450
  var valid_605451 = query.getOrDefault("ClusterParameterGroupName")
  valid_605451 = validateParameter(valid_605451, JString, required = false,
                                 default = nil)
  if valid_605451 != nil:
    section.add "ClusterParameterGroupName", valid_605451
  var valid_605452 = query.getOrDefault("HsmConfigurationIdentifier")
  valid_605452 = validateParameter(valid_605452, JString, required = false,
                                 default = nil)
  if valid_605452 != nil:
    section.add "HsmConfigurationIdentifier", valid_605452
  var valid_605453 = query.getOrDefault("NewClusterIdentifier")
  valid_605453 = validateParameter(valid_605453, JString, required = false,
                                 default = nil)
  if valid_605453 != nil:
    section.add "NewClusterIdentifier", valid_605453
  var valid_605454 = query.getOrDefault("ElasticIp")
  valid_605454 = validateParameter(valid_605454, JString, required = false,
                                 default = nil)
  if valid_605454 != nil:
    section.add "ElasticIp", valid_605454
  assert query != nil,
        "query argument is necessary due to required `ClusterIdentifier` field"
  var valid_605455 = query.getOrDefault("ClusterIdentifier")
  valid_605455 = validateParameter(valid_605455, JString, required = true,
                                 default = nil)
  if valid_605455 != nil:
    section.add "ClusterIdentifier", valid_605455
  var valid_605456 = query.getOrDefault("Action")
  valid_605456 = validateParameter(valid_605456, JString, required = true,
                                 default = newJString("ModifyCluster"))
  if valid_605456 != nil:
    section.add "Action", valid_605456
  var valid_605457 = query.getOrDefault("KmsKeyId")
  valid_605457 = validateParameter(valid_605457, JString, required = false,
                                 default = nil)
  if valid_605457 != nil:
    section.add "KmsKeyId", valid_605457
  var valid_605458 = query.getOrDefault("PubliclyAccessible")
  valid_605458 = validateParameter(valid_605458, JBool, required = false, default = nil)
  if valid_605458 != nil:
    section.add "PubliclyAccessible", valid_605458
  var valid_605459 = query.getOrDefault("NumberOfNodes")
  valid_605459 = validateParameter(valid_605459, JInt, required = false, default = nil)
  if valid_605459 != nil:
    section.add "NumberOfNodes", valid_605459
  var valid_605460 = query.getOrDefault("AutomatedSnapshotRetentionPeriod")
  valid_605460 = validateParameter(valid_605460, JInt, required = false, default = nil)
  if valid_605460 != nil:
    section.add "AutomatedSnapshotRetentionPeriod", valid_605460
  var valid_605461 = query.getOrDefault("NodeType")
  valid_605461 = validateParameter(valid_605461, JString, required = false,
                                 default = nil)
  if valid_605461 != nil:
    section.add "NodeType", valid_605461
  var valid_605462 = query.getOrDefault("ClusterVersion")
  valid_605462 = validateParameter(valid_605462, JString, required = false,
                                 default = nil)
  if valid_605462 != nil:
    section.add "ClusterVersion", valid_605462
  var valid_605463 = query.getOrDefault("Version")
  valid_605463 = validateParameter(valid_605463, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_605463 != nil:
    section.add "Version", valid_605463
  var valid_605464 = query.getOrDefault("ClusterType")
  valid_605464 = validateParameter(valid_605464, JString, required = false,
                                 default = nil)
  if valid_605464 != nil:
    section.add "ClusterType", valid_605464
  var valid_605465 = query.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_605465 = validateParameter(valid_605465, JInt, required = false, default = nil)
  if valid_605465 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_605465
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_605466 = header.getOrDefault("X-Amz-Date")
  valid_605466 = validateParameter(valid_605466, JString, required = false,
                                 default = nil)
  if valid_605466 != nil:
    section.add "X-Amz-Date", valid_605466
  var valid_605467 = header.getOrDefault("X-Amz-Security-Token")
  valid_605467 = validateParameter(valid_605467, JString, required = false,
                                 default = nil)
  if valid_605467 != nil:
    section.add "X-Amz-Security-Token", valid_605467
  var valid_605468 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605468 = validateParameter(valid_605468, JString, required = false,
                                 default = nil)
  if valid_605468 != nil:
    section.add "X-Amz-Content-Sha256", valid_605468
  var valid_605469 = header.getOrDefault("X-Amz-Algorithm")
  valid_605469 = validateParameter(valid_605469, JString, required = false,
                                 default = nil)
  if valid_605469 != nil:
    section.add "X-Amz-Algorithm", valid_605469
  var valid_605470 = header.getOrDefault("X-Amz-Signature")
  valid_605470 = validateParameter(valid_605470, JString, required = false,
                                 default = nil)
  if valid_605470 != nil:
    section.add "X-Amz-Signature", valid_605470
  var valid_605471 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605471 = validateParameter(valid_605471, JString, required = false,
                                 default = nil)
  if valid_605471 != nil:
    section.add "X-Amz-SignedHeaders", valid_605471
  var valid_605472 = header.getOrDefault("X-Amz-Credential")
  valid_605472 = validateParameter(valid_605472, JString, required = false,
                                 default = nil)
  if valid_605472 != nil:
    section.add "X-Amz-Credential", valid_605472
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_605473: Call_GetModifyCluster_605439; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Modifies the settings for a cluster. For example, you can add another security or parameter group, update the preferred maintenance window, or change the master user password. Resetting a cluster password or modifying the security groups associated with a cluster do not need a reboot. However, modifying a parameter group requires a reboot for parameters to take effect. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>You can also change node type and the number of nodes to scale up or down the cluster. When resizing a cluster, you must specify both the number of nodes and the node type even if one of the parameters does not change.</p>
  ## 
  let valid = call_605473.validator(path, query, header, formData, body)
  let scheme = call_605473.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605473.url(scheme.get, call_605473.host, call_605473.base,
                         call_605473.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_605473, url, valid)

proc call*(call_605474: Call_GetModifyCluster_605439; ClusterIdentifier: string;
          ClusterSecurityGroups: JsonNode = nil;
          HsmClientCertificateIdentifier: string = "";
          PreferredMaintenanceWindow: string = ""; Encrypted: bool = false;
          MaintenanceTrackName: string = ""; MasterUserPassword: string = "";
          AllowVersionUpgrade: bool = false; EnhancedVpcRouting: bool = false;
          VpcSecurityGroupIds: JsonNode = nil;
          ClusterParameterGroupName: string = "";
          HsmConfigurationIdentifier: string = "";
          NewClusterIdentifier: string = ""; ElasticIp: string = "";
          Action: string = "ModifyCluster"; KmsKeyId: string = "";
          PubliclyAccessible: bool = false; NumberOfNodes: int = 0;
          AutomatedSnapshotRetentionPeriod: int = 0; NodeType: string = "";
          ClusterVersion: string = ""; Version: string = "2012-12-01";
          ClusterType: string = ""; ManualSnapshotRetentionPeriod: int = 0): Recallable =
  ## getModifyCluster
  ## <p>Modifies the settings for a cluster. For example, you can add another security or parameter group, update the preferred maintenance window, or change the master user password. Resetting a cluster password or modifying the security groups associated with a cluster do not need a reboot. However, modifying a parameter group requires a reboot for parameters to take effect. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>You can also change node type and the number of nodes to scale up or down the cluster. When resizing a cluster, you must specify both the number of nodes and the node type even if one of the parameters does not change.</p>
  ##   ClusterSecurityGroups: JArray
  ##                        : <p>A list of cluster security groups to be authorized on this cluster. This change is asynchronously applied as soon as possible.</p> <p>Security groups currently associated with the cluster, and not in the list of groups to apply, will be revoked from the cluster.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens</p> </li> <li> <p>First character must be a letter</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens</p> </li> </ul>
  ##   HsmClientCertificateIdentifier: string
  ##                                 : Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM.
  ##   PreferredMaintenanceWindow: string
  ##                             : <p>The weekly time range (in UTC) during which system maintenance can occur, if necessary. If system maintenance is necessary during the window, it may result in an outage.</p> <p>This maintenance window change is made immediately. If the new maintenance window indicates the current time, there must be at least 120 minutes between the current time and end of the window in order to ensure that pending changes are applied.</p> <p>Default: Uses existing setting.</p> <p>Format: ddd:hh24:mi-ddd:hh24:mi, for example <code>wed:07:30-wed:08:00</code>.</p> <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p> <p>Constraints: Must be at least 30 minutes.</p>
  ##   Encrypted: bool
  ##            : Indicates whether the cluster is encrypted. If the cluster is encrypted and you provide a value for the <code>KmsKeyId</code> parameter, we will encrypt the cluster with the provided <code>KmsKeyId</code>. If you don't provide a <code>KmsKeyId</code>, we will encrypt with the default key. In the China region we will use legacy encryption if you specify that the cluster is encrypted.
  ##   MaintenanceTrackName: string
  ##                       : The name for the maintenance track that you want to assign for the cluster. This name change is asynchronous. The new track name stays in the <code>PendingModifiedValues</code> for the cluster until the next maintenance window. When the maintenance track changes, the cluster is switched to the latest cluster release available for the maintenance track. At this point, the maintenance track name is applied.
  ##   MasterUserPassword: string
  ##                     : <p>The new password for the cluster master user. This change is asynchronously applied as soon as possible. Between the time of the request and the completion of the request, the <code>MasterUserPassword</code> element exists in the <code>PendingModifiedValues</code> element of the operation response. </p> <note> <p>Operations never return the password, so this operation provides a way to regain access to the master user account for a cluster if the password is lost.</p> </note> <p>Default: Uses existing setting.</p> <p>Constraints:</p> <ul> <li> <p>Must be between 8 and 64 characters in length.</p> </li> <li> <p>Must contain at least one uppercase letter.</p> </li> <li> <p>Must contain at least one lowercase letter.</p> </li> <li> <p>Must contain one number.</p> </li> <li> <p>Can be any printable ASCII character (ASCII code 33 to 126) except ' (single quote), " (double quote), \, /, @, or space.</p> </li> </ul>
  ##   AllowVersionUpgrade: bool
  ##                      : <p>If <code>true</code>, major version upgrades will be applied automatically to the cluster during the maintenance window. </p> <p>Default: <code>false</code> </p>
  ##   EnhancedVpcRouting: bool
  ##                     : <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p> <p>Default: false</p>
  ##   VpcSecurityGroupIds: JArray
  ##                      : A list of virtual private cloud (VPC) security groups to be associated with the cluster. This change is asynchronously applied as soon as possible.
  ##   ClusterParameterGroupName: string
  ##                            : <p>The name of the cluster parameter group to apply to this cluster. This change is applied only after the cluster is rebooted. To reboot a cluster use <a>RebootCluster</a>. </p> <p>Default: Uses existing setting.</p> <p>Constraints: The cluster parameter group must be in the same parameter group family that matches the cluster version.</p>
  ##   HsmConfigurationIdentifier: string
  ##                             : Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
  ##   NewClusterIdentifier: string
  ##                       : <p>The new identifier for the cluster.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul> <p>Example: <code>examplecluster</code> </p>
  ##   ElasticIp: string
  ##            : <p>The Elastic IP (EIP) address for the cluster.</p> <p>Constraints: The cluster must be provisioned in EC2-VPC and publicly-accessible through an Internet gateway. For more information about provisioning clusters in EC2-VPC, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#cluster-platforms">Supported Platforms to Launch Your Cluster</a> in the Amazon Redshift Cluster Management Guide.</p>
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of the cluster to be modified.</p> <p>Example: <code>examplecluster</code> </p>
  ##   Action: string (required)
  ##   KmsKeyId: string
  ##           : The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster.
  ##   PubliclyAccessible: bool
  ##                     : If <code>true</code>, the cluster can be accessed from a public network. Only clusters in VPCs can be set to be publicly available.
  ##   NumberOfNodes: int
  ##                : <p>The new number of nodes of the cluster. If you specify a new number of nodes, you must also specify the node type parameter.</p> <p>When you submit your request to resize a cluster, Amazon Redshift sets access permissions for the cluster to read-only. After Amazon Redshift provisions a new cluster according to your resize requirements, there will be a temporary outage while the old cluster is deleted and your connection is switched to the new cluster. When the new connection is complete, the original access permissions for the cluster are restored. You can use <a>DescribeResize</a> to track the progress of the resize request. </p> <p>Valid Values: Integer greater than <code>0</code>.</p>
  ##   AutomatedSnapshotRetentionPeriod: int
  ##                                   : <p>The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p> <p>If you decrease the automated snapshot retention period from its current value, existing automated snapshots that fall outside of the new retention period will be immediately deleted.</p> <p>Default: Uses existing setting.</p> <p>Constraints: Must be a value from 0 to 35.</p>
  ##   NodeType: string
  ##           : <p>The new node type of the cluster. If you specify a new node type, you must also specify the number of nodes parameter.</p> <p>When you submit your request to resize a cluster, Amazon Redshift sets access permissions for the cluster to read-only. After Amazon Redshift provisions a new cluster according to your resize requirements, there will be a temporary outage while the old cluster is deleted and your connection is switched to the new cluster. When the new connection is complete, the original access permissions for the cluster are restored. You can use <a>DescribeResize</a> to track the progress of the resize request. </p> <p>Valid Values: <code>ds2.xlarge</code> | <code>ds2.8xlarge</code> | <code>dc1.large</code> | <code>dc1.8xlarge</code> | <code>dc2.large</code> | <code>dc2.8xlarge</code> </p>
  ##   ClusterVersion: string
  ##                 : <p>The new version number of the Amazon Redshift engine to upgrade to.</p> <p>For major version upgrades, if a non-default cluster parameter group is currently in use, a new cluster parameter group in the cluster parameter group family for the new version must be specified. The new cluster parameter group can be the default for that cluster parameter group family. For more information about parameters and parameter groups, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>Example: <code>1.0</code> </p>
  ##   Version: string (required)
  ##   ClusterType: string
  ##              : <p>The new cluster type.</p> <p>When you submit your cluster resize request, your existing cluster goes into a read-only mode. After Amazon Redshift provisions a new cluster based on your resize requirements, there will be outage for a period while the old cluster is deleted and your connection is switched to the new cluster. You can use <a>DescribeResize</a> to track the progress of the resize request. </p> <p>Valid Values: <code> multi-node | single-node </code> </p>
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The default for number of days that a newly created manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. This value doesn't retroactively change the retention periods of existing manual snapshots.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  var query_605475 = newJObject()
  if ClusterSecurityGroups != nil:
    query_605475.add "ClusterSecurityGroups", ClusterSecurityGroups
  add(query_605475, "HsmClientCertificateIdentifier",
      newJString(HsmClientCertificateIdentifier))
  add(query_605475, "PreferredMaintenanceWindow",
      newJString(PreferredMaintenanceWindow))
  add(query_605475, "Encrypted", newJBool(Encrypted))
  add(query_605475, "MaintenanceTrackName", newJString(MaintenanceTrackName))
  add(query_605475, "MasterUserPassword", newJString(MasterUserPassword))
  add(query_605475, "AllowVersionUpgrade", newJBool(AllowVersionUpgrade))
  add(query_605475, "EnhancedVpcRouting", newJBool(EnhancedVpcRouting))
  if VpcSecurityGroupIds != nil:
    query_605475.add "VpcSecurityGroupIds", VpcSecurityGroupIds
  add(query_605475, "ClusterParameterGroupName",
      newJString(ClusterParameterGroupName))
  add(query_605475, "HsmConfigurationIdentifier",
      newJString(HsmConfigurationIdentifier))
  add(query_605475, "NewClusterIdentifier", newJString(NewClusterIdentifier))
  add(query_605475, "ElasticIp", newJString(ElasticIp))
  add(query_605475, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_605475, "Action", newJString(Action))
  add(query_605475, "KmsKeyId", newJString(KmsKeyId))
  add(query_605475, "PubliclyAccessible", newJBool(PubliclyAccessible))
  add(query_605475, "NumberOfNodes", newJInt(NumberOfNodes))
  add(query_605475, "AutomatedSnapshotRetentionPeriod",
      newJInt(AutomatedSnapshotRetentionPeriod))
  add(query_605475, "NodeType", newJString(NodeType))
  add(query_605475, "ClusterVersion", newJString(ClusterVersion))
  add(query_605475, "Version", newJString(Version))
  add(query_605475, "ClusterType", newJString(ClusterType))
  add(query_605475, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  result = call_605474.call(nil, query_605475, nil, nil, nil)

var getModifyCluster* = Call_GetModifyCluster_605439(name: "getModifyCluster",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=ModifyCluster", validator: validate_GetModifyCluster_605440,
    base: "/", url: url_GetModifyCluster_605441,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostModifyClusterDbRevision_605531 = ref object of OpenApiRestCall_602450
proc url_PostModifyClusterDbRevision_605533(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostModifyClusterDbRevision_605532(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies the database revision of a cluster. The database revision is a unique revision of the database running in a cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_605534 = query.getOrDefault("Action")
  valid_605534 = validateParameter(valid_605534, JString, required = true, default = newJString(
      "ModifyClusterDbRevision"))
  if valid_605534 != nil:
    section.add "Action", valid_605534
  var valid_605535 = query.getOrDefault("Version")
  valid_605535 = validateParameter(valid_605535, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_605535 != nil:
    section.add "Version", valid_605535
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_605536 = header.getOrDefault("X-Amz-Date")
  valid_605536 = validateParameter(valid_605536, JString, required = false,
                                 default = nil)
  if valid_605536 != nil:
    section.add "X-Amz-Date", valid_605536
  var valid_605537 = header.getOrDefault("X-Amz-Security-Token")
  valid_605537 = validateParameter(valid_605537, JString, required = false,
                                 default = nil)
  if valid_605537 != nil:
    section.add "X-Amz-Security-Token", valid_605537
  var valid_605538 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605538 = validateParameter(valid_605538, JString, required = false,
                                 default = nil)
  if valid_605538 != nil:
    section.add "X-Amz-Content-Sha256", valid_605538
  var valid_605539 = header.getOrDefault("X-Amz-Algorithm")
  valid_605539 = validateParameter(valid_605539, JString, required = false,
                                 default = nil)
  if valid_605539 != nil:
    section.add "X-Amz-Algorithm", valid_605539
  var valid_605540 = header.getOrDefault("X-Amz-Signature")
  valid_605540 = validateParameter(valid_605540, JString, required = false,
                                 default = nil)
  if valid_605540 != nil:
    section.add "X-Amz-Signature", valid_605540
  var valid_605541 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605541 = validateParameter(valid_605541, JString, required = false,
                                 default = nil)
  if valid_605541 != nil:
    section.add "X-Amz-SignedHeaders", valid_605541
  var valid_605542 = header.getOrDefault("X-Amz-Credential")
  valid_605542 = validateParameter(valid_605542, JString, required = false,
                                 default = nil)
  if valid_605542 != nil:
    section.add "X-Amz-Credential", valid_605542
  result.add "header", section
  ## parameters in `formData` object:
  ##   RevisionTarget: JString (required)
  ##                 : The identifier of the database revision. You can retrieve this value from the response to the <a>DescribeClusterDbRevisions</a> request.
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of a cluster whose database revision you want to modify. </p> <p>Example: <code>examplecluster</code> </p>
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `RevisionTarget` field"
  var valid_605543 = formData.getOrDefault("RevisionTarget")
  valid_605543 = validateParameter(valid_605543, JString, required = true,
                                 default = nil)
  if valid_605543 != nil:
    section.add "RevisionTarget", valid_605543
  var valid_605544 = formData.getOrDefault("ClusterIdentifier")
  valid_605544 = validateParameter(valid_605544, JString, required = true,
                                 default = nil)
  if valid_605544 != nil:
    section.add "ClusterIdentifier", valid_605544
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_605545: Call_PostModifyClusterDbRevision_605531; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Modifies the database revision of a cluster. The database revision is a unique revision of the database running in a cluster.
  ## 
  let valid = call_605545.validator(path, query, header, formData, body)
  let scheme = call_605545.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605545.url(scheme.get, call_605545.host, call_605545.base,
                         call_605545.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_605545, url, valid)

proc call*(call_605546: Call_PostModifyClusterDbRevision_605531;
          RevisionTarget: string; ClusterIdentifier: string;
          Action: string = "ModifyClusterDbRevision"; Version: string = "2012-12-01"): Recallable =
  ## postModifyClusterDbRevision
  ## Modifies the database revision of a cluster. The database revision is a unique revision of the database running in a cluster.
  ##   RevisionTarget: string (required)
  ##                 : The identifier of the database revision. You can retrieve this value from the response to the <a>DescribeClusterDbRevisions</a> request.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of a cluster whose database revision you want to modify. </p> <p>Example: <code>examplecluster</code> </p>
  ##   Version: string (required)
  var query_605547 = newJObject()
  var formData_605548 = newJObject()
  add(formData_605548, "RevisionTarget", newJString(RevisionTarget))
  add(query_605547, "Action", newJString(Action))
  add(formData_605548, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_605547, "Version", newJString(Version))
  result = call_605546.call(nil, query_605547, nil, formData_605548, nil)

var postModifyClusterDbRevision* = Call_PostModifyClusterDbRevision_605531(
    name: "postModifyClusterDbRevision", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyClusterDbRevision",
    validator: validate_PostModifyClusterDbRevision_605532, base: "/",
    url: url_PostModifyClusterDbRevision_605533,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetModifyClusterDbRevision_605514 = ref object of OpenApiRestCall_602450
proc url_GetModifyClusterDbRevision_605516(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetModifyClusterDbRevision_605515(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies the database revision of a cluster. The database revision is a unique revision of the database running in a cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   RevisionTarget: JString (required)
  ##                 : The identifier of the database revision. You can retrieve this value from the response to the <a>DescribeClusterDbRevisions</a> request.
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of a cluster whose database revision you want to modify. </p> <p>Example: <code>examplecluster</code> </p>
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `RevisionTarget` field"
  var valid_605517 = query.getOrDefault("RevisionTarget")
  valid_605517 = validateParameter(valid_605517, JString, required = true,
                                 default = nil)
  if valid_605517 != nil:
    section.add "RevisionTarget", valid_605517
  var valid_605518 = query.getOrDefault("Action")
  valid_605518 = validateParameter(valid_605518, JString, required = true, default = newJString(
      "ModifyClusterDbRevision"))
  if valid_605518 != nil:
    section.add "Action", valid_605518
  var valid_605519 = query.getOrDefault("ClusterIdentifier")
  valid_605519 = validateParameter(valid_605519, JString, required = true,
                                 default = nil)
  if valid_605519 != nil:
    section.add "ClusterIdentifier", valid_605519
  var valid_605520 = query.getOrDefault("Version")
  valid_605520 = validateParameter(valid_605520, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_605520 != nil:
    section.add "Version", valid_605520
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_605521 = header.getOrDefault("X-Amz-Date")
  valid_605521 = validateParameter(valid_605521, JString, required = false,
                                 default = nil)
  if valid_605521 != nil:
    section.add "X-Amz-Date", valid_605521
  var valid_605522 = header.getOrDefault("X-Amz-Security-Token")
  valid_605522 = validateParameter(valid_605522, JString, required = false,
                                 default = nil)
  if valid_605522 != nil:
    section.add "X-Amz-Security-Token", valid_605522
  var valid_605523 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605523 = validateParameter(valid_605523, JString, required = false,
                                 default = nil)
  if valid_605523 != nil:
    section.add "X-Amz-Content-Sha256", valid_605523
  var valid_605524 = header.getOrDefault("X-Amz-Algorithm")
  valid_605524 = validateParameter(valid_605524, JString, required = false,
                                 default = nil)
  if valid_605524 != nil:
    section.add "X-Amz-Algorithm", valid_605524
  var valid_605525 = header.getOrDefault("X-Amz-Signature")
  valid_605525 = validateParameter(valid_605525, JString, required = false,
                                 default = nil)
  if valid_605525 != nil:
    section.add "X-Amz-Signature", valid_605525
  var valid_605526 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605526 = validateParameter(valid_605526, JString, required = false,
                                 default = nil)
  if valid_605526 != nil:
    section.add "X-Amz-SignedHeaders", valid_605526
  var valid_605527 = header.getOrDefault("X-Amz-Credential")
  valid_605527 = validateParameter(valid_605527, JString, required = false,
                                 default = nil)
  if valid_605527 != nil:
    section.add "X-Amz-Credential", valid_605527
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_605528: Call_GetModifyClusterDbRevision_605514; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Modifies the database revision of a cluster. The database revision is a unique revision of the database running in a cluster.
  ## 
  let valid = call_605528.validator(path, query, header, formData, body)
  let scheme = call_605528.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605528.url(scheme.get, call_605528.host, call_605528.base,
                         call_605528.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_605528, url, valid)

proc call*(call_605529: Call_GetModifyClusterDbRevision_605514;
          RevisionTarget: string; ClusterIdentifier: string;
          Action: string = "ModifyClusterDbRevision"; Version: string = "2012-12-01"): Recallable =
  ## getModifyClusterDbRevision
  ## Modifies the database revision of a cluster. The database revision is a unique revision of the database running in a cluster.
  ##   RevisionTarget: string (required)
  ##                 : The identifier of the database revision. You can retrieve this value from the response to the <a>DescribeClusterDbRevisions</a> request.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of a cluster whose database revision you want to modify. </p> <p>Example: <code>examplecluster</code> </p>
  ##   Version: string (required)
  var query_605530 = newJObject()
  add(query_605530, "RevisionTarget", newJString(RevisionTarget))
  add(query_605530, "Action", newJString(Action))
  add(query_605530, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_605530, "Version", newJString(Version))
  result = call_605529.call(nil, query_605530, nil, nil, nil)

var getModifyClusterDbRevision* = Call_GetModifyClusterDbRevision_605514(
    name: "getModifyClusterDbRevision", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyClusterDbRevision",
    validator: validate_GetModifyClusterDbRevision_605515, base: "/",
    url: url_GetModifyClusterDbRevision_605516,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostModifyClusterIamRoles_605567 = ref object of OpenApiRestCall_602450
proc url_PostModifyClusterIamRoles_605569(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostModifyClusterIamRoles_605568(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Modifies the list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services.</p> <p>A cluster can have up to 10 IAM roles associated at any time.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_605570 = query.getOrDefault("Action")
  valid_605570 = validateParameter(valid_605570, JString, required = true,
                                 default = newJString("ModifyClusterIamRoles"))
  if valid_605570 != nil:
    section.add "Action", valid_605570
  var valid_605571 = query.getOrDefault("Version")
  valid_605571 = validateParameter(valid_605571, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_605571 != nil:
    section.add "Version", valid_605571
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_605572 = header.getOrDefault("X-Amz-Date")
  valid_605572 = validateParameter(valid_605572, JString, required = false,
                                 default = nil)
  if valid_605572 != nil:
    section.add "X-Amz-Date", valid_605572
  var valid_605573 = header.getOrDefault("X-Amz-Security-Token")
  valid_605573 = validateParameter(valid_605573, JString, required = false,
                                 default = nil)
  if valid_605573 != nil:
    section.add "X-Amz-Security-Token", valid_605573
  var valid_605574 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605574 = validateParameter(valid_605574, JString, required = false,
                                 default = nil)
  if valid_605574 != nil:
    section.add "X-Amz-Content-Sha256", valid_605574
  var valid_605575 = header.getOrDefault("X-Amz-Algorithm")
  valid_605575 = validateParameter(valid_605575, JString, required = false,
                                 default = nil)
  if valid_605575 != nil:
    section.add "X-Amz-Algorithm", valid_605575
  var valid_605576 = header.getOrDefault("X-Amz-Signature")
  valid_605576 = validateParameter(valid_605576, JString, required = false,
                                 default = nil)
  if valid_605576 != nil:
    section.add "X-Amz-Signature", valid_605576
  var valid_605577 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605577 = validateParameter(valid_605577, JString, required = false,
                                 default = nil)
  if valid_605577 != nil:
    section.add "X-Amz-SignedHeaders", valid_605577
  var valid_605578 = header.getOrDefault("X-Amz-Credential")
  valid_605578 = validateParameter(valid_605578, JString, required = false,
                                 default = nil)
  if valid_605578 != nil:
    section.add "X-Amz-Credential", valid_605578
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : The unique identifier of the cluster for which you want to associate or disassociate IAM roles.
  ##   AddIamRoles: JArray
  ##              : Zero or more IAM roles to associate with the cluster. The roles must be in their Amazon Resource Name (ARN) format. You can associate up to 10 IAM roles with a single cluster in a single request.
  ##   RemoveIamRoles: JArray
  ##                 : Zero or more IAM roles in ARN format to disassociate from the cluster. You can disassociate up to 10 IAM roles from a single cluster in a single request.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_605579 = formData.getOrDefault("ClusterIdentifier")
  valid_605579 = validateParameter(valid_605579, JString, required = true,
                                 default = nil)
  if valid_605579 != nil:
    section.add "ClusterIdentifier", valid_605579
  var valid_605580 = formData.getOrDefault("AddIamRoles")
  valid_605580 = validateParameter(valid_605580, JArray, required = false,
                                 default = nil)
  if valid_605580 != nil:
    section.add "AddIamRoles", valid_605580
  var valid_605581 = formData.getOrDefault("RemoveIamRoles")
  valid_605581 = validateParameter(valid_605581, JArray, required = false,
                                 default = nil)
  if valid_605581 != nil:
    section.add "RemoveIamRoles", valid_605581
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_605582: Call_PostModifyClusterIamRoles_605567; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Modifies the list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services.</p> <p>A cluster can have up to 10 IAM roles associated at any time.</p>
  ## 
  let valid = call_605582.validator(path, query, header, formData, body)
  let scheme = call_605582.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605582.url(scheme.get, call_605582.host, call_605582.base,
                         call_605582.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_605582, url, valid)

proc call*(call_605583: Call_PostModifyClusterIamRoles_605567;
          ClusterIdentifier: string; Action: string = "ModifyClusterIamRoles";
          AddIamRoles: JsonNode = nil; RemoveIamRoles: JsonNode = nil;
          Version: string = "2012-12-01"): Recallable =
  ## postModifyClusterIamRoles
  ## <p>Modifies the list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services.</p> <p>A cluster can have up to 10 IAM roles associated at any time.</p>
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : The unique identifier of the cluster for which you want to associate or disassociate IAM roles.
  ##   AddIamRoles: JArray
  ##              : Zero or more IAM roles to associate with the cluster. The roles must be in their Amazon Resource Name (ARN) format. You can associate up to 10 IAM roles with a single cluster in a single request.
  ##   RemoveIamRoles: JArray
  ##                 : Zero or more IAM roles in ARN format to disassociate from the cluster. You can disassociate up to 10 IAM roles from a single cluster in a single request.
  ##   Version: string (required)
  var query_605584 = newJObject()
  var formData_605585 = newJObject()
  add(query_605584, "Action", newJString(Action))
  add(formData_605585, "ClusterIdentifier", newJString(ClusterIdentifier))
  if AddIamRoles != nil:
    formData_605585.add "AddIamRoles", AddIamRoles
  if RemoveIamRoles != nil:
    formData_605585.add "RemoveIamRoles", RemoveIamRoles
  add(query_605584, "Version", newJString(Version))
  result = call_605583.call(nil, query_605584, nil, formData_605585, nil)

var postModifyClusterIamRoles* = Call_PostModifyClusterIamRoles_605567(
    name: "postModifyClusterIamRoles", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyClusterIamRoles",
    validator: validate_PostModifyClusterIamRoles_605568, base: "/",
    url: url_PostModifyClusterIamRoles_605569,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetModifyClusterIamRoles_605549 = ref object of OpenApiRestCall_602450
proc url_GetModifyClusterIamRoles_605551(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetModifyClusterIamRoles_605550(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Modifies the list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services.</p> <p>A cluster can have up to 10 IAM roles associated at any time.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   AddIamRoles: JArray
  ##              : Zero or more IAM roles to associate with the cluster. The roles must be in their Amazon Resource Name (ARN) format. You can associate up to 10 IAM roles with a single cluster in a single request.
  ##   RemoveIamRoles: JArray
  ##                 : Zero or more IAM roles in ARN format to disassociate from the cluster. You can disassociate up to 10 IAM roles from a single cluster in a single request.
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : The unique identifier of the cluster for which you want to associate or disassociate IAM roles.
  ##   Version: JString (required)
  section = newJObject()
  var valid_605552 = query.getOrDefault("AddIamRoles")
  valid_605552 = validateParameter(valid_605552, JArray, required = false,
                                 default = nil)
  if valid_605552 != nil:
    section.add "AddIamRoles", valid_605552
  var valid_605553 = query.getOrDefault("RemoveIamRoles")
  valid_605553 = validateParameter(valid_605553, JArray, required = false,
                                 default = nil)
  if valid_605553 != nil:
    section.add "RemoveIamRoles", valid_605553
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_605554 = query.getOrDefault("Action")
  valid_605554 = validateParameter(valid_605554, JString, required = true,
                                 default = newJString("ModifyClusterIamRoles"))
  if valid_605554 != nil:
    section.add "Action", valid_605554
  var valid_605555 = query.getOrDefault("ClusterIdentifier")
  valid_605555 = validateParameter(valid_605555, JString, required = true,
                                 default = nil)
  if valid_605555 != nil:
    section.add "ClusterIdentifier", valid_605555
  var valid_605556 = query.getOrDefault("Version")
  valid_605556 = validateParameter(valid_605556, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_605556 != nil:
    section.add "Version", valid_605556
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_605557 = header.getOrDefault("X-Amz-Date")
  valid_605557 = validateParameter(valid_605557, JString, required = false,
                                 default = nil)
  if valid_605557 != nil:
    section.add "X-Amz-Date", valid_605557
  var valid_605558 = header.getOrDefault("X-Amz-Security-Token")
  valid_605558 = validateParameter(valid_605558, JString, required = false,
                                 default = nil)
  if valid_605558 != nil:
    section.add "X-Amz-Security-Token", valid_605558
  var valid_605559 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605559 = validateParameter(valid_605559, JString, required = false,
                                 default = nil)
  if valid_605559 != nil:
    section.add "X-Amz-Content-Sha256", valid_605559
  var valid_605560 = header.getOrDefault("X-Amz-Algorithm")
  valid_605560 = validateParameter(valid_605560, JString, required = false,
                                 default = nil)
  if valid_605560 != nil:
    section.add "X-Amz-Algorithm", valid_605560
  var valid_605561 = header.getOrDefault("X-Amz-Signature")
  valid_605561 = validateParameter(valid_605561, JString, required = false,
                                 default = nil)
  if valid_605561 != nil:
    section.add "X-Amz-Signature", valid_605561
  var valid_605562 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605562 = validateParameter(valid_605562, JString, required = false,
                                 default = nil)
  if valid_605562 != nil:
    section.add "X-Amz-SignedHeaders", valid_605562
  var valid_605563 = header.getOrDefault("X-Amz-Credential")
  valid_605563 = validateParameter(valid_605563, JString, required = false,
                                 default = nil)
  if valid_605563 != nil:
    section.add "X-Amz-Credential", valid_605563
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_605564: Call_GetModifyClusterIamRoles_605549; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Modifies the list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services.</p> <p>A cluster can have up to 10 IAM roles associated at any time.</p>
  ## 
  let valid = call_605564.validator(path, query, header, formData, body)
  let scheme = call_605564.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605564.url(scheme.get, call_605564.host, call_605564.base,
                         call_605564.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_605564, url, valid)

proc call*(call_605565: Call_GetModifyClusterIamRoles_605549;
          ClusterIdentifier: string; AddIamRoles: JsonNode = nil;
          RemoveIamRoles: JsonNode = nil; Action: string = "ModifyClusterIamRoles";
          Version: string = "2012-12-01"): Recallable =
  ## getModifyClusterIamRoles
  ## <p>Modifies the list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services.</p> <p>A cluster can have up to 10 IAM roles associated at any time.</p>
  ##   AddIamRoles: JArray
  ##              : Zero or more IAM roles to associate with the cluster. The roles must be in their Amazon Resource Name (ARN) format. You can associate up to 10 IAM roles with a single cluster in a single request.
  ##   RemoveIamRoles: JArray
  ##                 : Zero or more IAM roles in ARN format to disassociate from the cluster. You can disassociate up to 10 IAM roles from a single cluster in a single request.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : The unique identifier of the cluster for which you want to associate or disassociate IAM roles.
  ##   Version: string (required)
  var query_605566 = newJObject()
  if AddIamRoles != nil:
    query_605566.add "AddIamRoles", AddIamRoles
  if RemoveIamRoles != nil:
    query_605566.add "RemoveIamRoles", RemoveIamRoles
  add(query_605566, "Action", newJString(Action))
  add(query_605566, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_605566, "Version", newJString(Version))
  result = call_605565.call(nil, query_605566, nil, nil, nil)

var getModifyClusterIamRoles* = Call_GetModifyClusterIamRoles_605549(
    name: "getModifyClusterIamRoles", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyClusterIamRoles",
    validator: validate_GetModifyClusterIamRoles_605550, base: "/",
    url: url_GetModifyClusterIamRoles_605551, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostModifyClusterMaintenance_605607 = ref object of OpenApiRestCall_602450
proc url_PostModifyClusterMaintenance_605609(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostModifyClusterMaintenance_605608(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies the maintenance settings of a cluster. For example, you can defer a maintenance window. You can also update or cancel a deferment. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_605610 = query.getOrDefault("Action")
  valid_605610 = validateParameter(valid_605610, JString, required = true, default = newJString(
      "ModifyClusterMaintenance"))
  if valid_605610 != nil:
    section.add "Action", valid_605610
  var valid_605611 = query.getOrDefault("Version")
  valid_605611 = validateParameter(valid_605611, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_605611 != nil:
    section.add "Version", valid_605611
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_605612 = header.getOrDefault("X-Amz-Date")
  valid_605612 = validateParameter(valid_605612, JString, required = false,
                                 default = nil)
  if valid_605612 != nil:
    section.add "X-Amz-Date", valid_605612
  var valid_605613 = header.getOrDefault("X-Amz-Security-Token")
  valid_605613 = validateParameter(valid_605613, JString, required = false,
                                 default = nil)
  if valid_605613 != nil:
    section.add "X-Amz-Security-Token", valid_605613
  var valid_605614 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605614 = validateParameter(valid_605614, JString, required = false,
                                 default = nil)
  if valid_605614 != nil:
    section.add "X-Amz-Content-Sha256", valid_605614
  var valid_605615 = header.getOrDefault("X-Amz-Algorithm")
  valid_605615 = validateParameter(valid_605615, JString, required = false,
                                 default = nil)
  if valid_605615 != nil:
    section.add "X-Amz-Algorithm", valid_605615
  var valid_605616 = header.getOrDefault("X-Amz-Signature")
  valid_605616 = validateParameter(valid_605616, JString, required = false,
                                 default = nil)
  if valid_605616 != nil:
    section.add "X-Amz-Signature", valid_605616
  var valid_605617 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605617 = validateParameter(valid_605617, JString, required = false,
                                 default = nil)
  if valid_605617 != nil:
    section.add "X-Amz-SignedHeaders", valid_605617
  var valid_605618 = header.getOrDefault("X-Amz-Credential")
  valid_605618 = validateParameter(valid_605618, JString, required = false,
                                 default = nil)
  if valid_605618 != nil:
    section.add "X-Amz-Credential", valid_605618
  result.add "header", section
  ## parameters in `formData` object:
  ##   DeferMaintenanceDuration: JInt
  ##                           : An integer indicating the duration of the maintenance window in days. If you specify a duration, you can't specify an end time. The duration must be 45 days or less.
  ##   DeferMaintenanceIdentifier: JString
  ##                             : A unique identifier for the deferred maintenance window.
  ##   DeferMaintenanceStartTime: JString
  ##                            : A timestamp indicating the start time for the deferred maintenance window.
  ##   ClusterIdentifier: JString (required)
  ##                    : A unique identifier for the cluster.
  ##   DeferMaintenanceEndTime: JString
  ##                          : A timestamp indicating end time for the deferred maintenance window. If you specify an end time, you can't specify a duration.
  ##   DeferMaintenance: JBool
  ##                   : A boolean indicating whether to enable the deferred maintenance window. 
  section = newJObject()
  var valid_605619 = formData.getOrDefault("DeferMaintenanceDuration")
  valid_605619 = validateParameter(valid_605619, JInt, required = false, default = nil)
  if valid_605619 != nil:
    section.add "DeferMaintenanceDuration", valid_605619
  var valid_605620 = formData.getOrDefault("DeferMaintenanceIdentifier")
  valid_605620 = validateParameter(valid_605620, JString, required = false,
                                 default = nil)
  if valid_605620 != nil:
    section.add "DeferMaintenanceIdentifier", valid_605620
  var valid_605621 = formData.getOrDefault("DeferMaintenanceStartTime")
  valid_605621 = validateParameter(valid_605621, JString, required = false,
                                 default = nil)
  if valid_605621 != nil:
    section.add "DeferMaintenanceStartTime", valid_605621
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_605622 = formData.getOrDefault("ClusterIdentifier")
  valid_605622 = validateParameter(valid_605622, JString, required = true,
                                 default = nil)
  if valid_605622 != nil:
    section.add "ClusterIdentifier", valid_605622
  var valid_605623 = formData.getOrDefault("DeferMaintenanceEndTime")
  valid_605623 = validateParameter(valid_605623, JString, required = false,
                                 default = nil)
  if valid_605623 != nil:
    section.add "DeferMaintenanceEndTime", valid_605623
  var valid_605624 = formData.getOrDefault("DeferMaintenance")
  valid_605624 = validateParameter(valid_605624, JBool, required = false, default = nil)
  if valid_605624 != nil:
    section.add "DeferMaintenance", valid_605624
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_605625: Call_PostModifyClusterMaintenance_605607; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Modifies the maintenance settings of a cluster. For example, you can defer a maintenance window. You can also update or cancel a deferment. 
  ## 
  let valid = call_605625.validator(path, query, header, formData, body)
  let scheme = call_605625.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605625.url(scheme.get, call_605625.host, call_605625.base,
                         call_605625.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_605625, url, valid)

proc call*(call_605626: Call_PostModifyClusterMaintenance_605607;
          ClusterIdentifier: string; DeferMaintenanceDuration: int = 0;
          DeferMaintenanceIdentifier: string = "";
          Action: string = "ModifyClusterMaintenance";
          DeferMaintenanceStartTime: string = "";
          DeferMaintenanceEndTime: string = ""; DeferMaintenance: bool = false;
          Version: string = "2012-12-01"): Recallable =
  ## postModifyClusterMaintenance
  ## Modifies the maintenance settings of a cluster. For example, you can defer a maintenance window. You can also update or cancel a deferment. 
  ##   DeferMaintenanceDuration: int
  ##                           : An integer indicating the duration of the maintenance window in days. If you specify a duration, you can't specify an end time. The duration must be 45 days or less.
  ##   DeferMaintenanceIdentifier: string
  ##                             : A unique identifier for the deferred maintenance window.
  ##   Action: string (required)
  ##   DeferMaintenanceStartTime: string
  ##                            : A timestamp indicating the start time for the deferred maintenance window.
  ##   ClusterIdentifier: string (required)
  ##                    : A unique identifier for the cluster.
  ##   DeferMaintenanceEndTime: string
  ##                          : A timestamp indicating end time for the deferred maintenance window. If you specify an end time, you can't specify a duration.
  ##   DeferMaintenance: bool
  ##                   : A boolean indicating whether to enable the deferred maintenance window. 
  ##   Version: string (required)
  var query_605627 = newJObject()
  var formData_605628 = newJObject()
  add(formData_605628, "DeferMaintenanceDuration",
      newJInt(DeferMaintenanceDuration))
  add(formData_605628, "DeferMaintenanceIdentifier",
      newJString(DeferMaintenanceIdentifier))
  add(query_605627, "Action", newJString(Action))
  add(formData_605628, "DeferMaintenanceStartTime",
      newJString(DeferMaintenanceStartTime))
  add(formData_605628, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_605628, "DeferMaintenanceEndTime",
      newJString(DeferMaintenanceEndTime))
  add(formData_605628, "DeferMaintenance", newJBool(DeferMaintenance))
  add(query_605627, "Version", newJString(Version))
  result = call_605626.call(nil, query_605627, nil, formData_605628, nil)

var postModifyClusterMaintenance* = Call_PostModifyClusterMaintenance_605607(
    name: "postModifyClusterMaintenance", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyClusterMaintenance",
    validator: validate_PostModifyClusterMaintenance_605608, base: "/",
    url: url_PostModifyClusterMaintenance_605609,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetModifyClusterMaintenance_605586 = ref object of OpenApiRestCall_602450
proc url_GetModifyClusterMaintenance_605588(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetModifyClusterMaintenance_605587(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies the maintenance settings of a cluster. For example, you can defer a maintenance window. You can also update or cancel a deferment. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   DeferMaintenanceStartTime: JString
  ##                            : A timestamp indicating the start time for the deferred maintenance window.
  ##   DeferMaintenanceDuration: JInt
  ##                           : An integer indicating the duration of the maintenance window in days. If you specify a duration, you can't specify an end time. The duration must be 45 days or less.
  ##   DeferMaintenanceEndTime: JString
  ##                          : A timestamp indicating end time for the deferred maintenance window. If you specify an end time, you can't specify a duration.
  ##   DeferMaintenanceIdentifier: JString
  ##                             : A unique identifier for the deferred maintenance window.
  ##   DeferMaintenance: JBool
  ##                   : A boolean indicating whether to enable the deferred maintenance window. 
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : A unique identifier for the cluster.
  ##   Version: JString (required)
  section = newJObject()
  var valid_605589 = query.getOrDefault("DeferMaintenanceStartTime")
  valid_605589 = validateParameter(valid_605589, JString, required = false,
                                 default = nil)
  if valid_605589 != nil:
    section.add "DeferMaintenanceStartTime", valid_605589
  var valid_605590 = query.getOrDefault("DeferMaintenanceDuration")
  valid_605590 = validateParameter(valid_605590, JInt, required = false, default = nil)
  if valid_605590 != nil:
    section.add "DeferMaintenanceDuration", valid_605590
  var valid_605591 = query.getOrDefault("DeferMaintenanceEndTime")
  valid_605591 = validateParameter(valid_605591, JString, required = false,
                                 default = nil)
  if valid_605591 != nil:
    section.add "DeferMaintenanceEndTime", valid_605591
  var valid_605592 = query.getOrDefault("DeferMaintenanceIdentifier")
  valid_605592 = validateParameter(valid_605592, JString, required = false,
                                 default = nil)
  if valid_605592 != nil:
    section.add "DeferMaintenanceIdentifier", valid_605592
  var valid_605593 = query.getOrDefault("DeferMaintenance")
  valid_605593 = validateParameter(valid_605593, JBool, required = false, default = nil)
  if valid_605593 != nil:
    section.add "DeferMaintenance", valid_605593
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_605594 = query.getOrDefault("Action")
  valid_605594 = validateParameter(valid_605594, JString, required = true, default = newJString(
      "ModifyClusterMaintenance"))
  if valid_605594 != nil:
    section.add "Action", valid_605594
  var valid_605595 = query.getOrDefault("ClusterIdentifier")
  valid_605595 = validateParameter(valid_605595, JString, required = true,
                                 default = nil)
  if valid_605595 != nil:
    section.add "ClusterIdentifier", valid_605595
  var valid_605596 = query.getOrDefault("Version")
  valid_605596 = validateParameter(valid_605596, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_605596 != nil:
    section.add "Version", valid_605596
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_605597 = header.getOrDefault("X-Amz-Date")
  valid_605597 = validateParameter(valid_605597, JString, required = false,
                                 default = nil)
  if valid_605597 != nil:
    section.add "X-Amz-Date", valid_605597
  var valid_605598 = header.getOrDefault("X-Amz-Security-Token")
  valid_605598 = validateParameter(valid_605598, JString, required = false,
                                 default = nil)
  if valid_605598 != nil:
    section.add "X-Amz-Security-Token", valid_605598
  var valid_605599 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605599 = validateParameter(valid_605599, JString, required = false,
                                 default = nil)
  if valid_605599 != nil:
    section.add "X-Amz-Content-Sha256", valid_605599
  var valid_605600 = header.getOrDefault("X-Amz-Algorithm")
  valid_605600 = validateParameter(valid_605600, JString, required = false,
                                 default = nil)
  if valid_605600 != nil:
    section.add "X-Amz-Algorithm", valid_605600
  var valid_605601 = header.getOrDefault("X-Amz-Signature")
  valid_605601 = validateParameter(valid_605601, JString, required = false,
                                 default = nil)
  if valid_605601 != nil:
    section.add "X-Amz-Signature", valid_605601
  var valid_605602 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605602 = validateParameter(valid_605602, JString, required = false,
                                 default = nil)
  if valid_605602 != nil:
    section.add "X-Amz-SignedHeaders", valid_605602
  var valid_605603 = header.getOrDefault("X-Amz-Credential")
  valid_605603 = validateParameter(valid_605603, JString, required = false,
                                 default = nil)
  if valid_605603 != nil:
    section.add "X-Amz-Credential", valid_605603
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_605604: Call_GetModifyClusterMaintenance_605586; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Modifies the maintenance settings of a cluster. For example, you can defer a maintenance window. You can also update or cancel a deferment. 
  ## 
  let valid = call_605604.validator(path, query, header, formData, body)
  let scheme = call_605604.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605604.url(scheme.get, call_605604.host, call_605604.base,
                         call_605604.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_605604, url, valid)

proc call*(call_605605: Call_GetModifyClusterMaintenance_605586;
          ClusterIdentifier: string; DeferMaintenanceStartTime: string = "";
          DeferMaintenanceDuration: int = 0; DeferMaintenanceEndTime: string = "";
          DeferMaintenanceIdentifier: string = ""; DeferMaintenance: bool = false;
          Action: string = "ModifyClusterMaintenance";
          Version: string = "2012-12-01"): Recallable =
  ## getModifyClusterMaintenance
  ## Modifies the maintenance settings of a cluster. For example, you can defer a maintenance window. You can also update or cancel a deferment. 
  ##   DeferMaintenanceStartTime: string
  ##                            : A timestamp indicating the start time for the deferred maintenance window.
  ##   DeferMaintenanceDuration: int
  ##                           : An integer indicating the duration of the maintenance window in days. If you specify a duration, you can't specify an end time. The duration must be 45 days or less.
  ##   DeferMaintenanceEndTime: string
  ##                          : A timestamp indicating end time for the deferred maintenance window. If you specify an end time, you can't specify a duration.
  ##   DeferMaintenanceIdentifier: string
  ##                             : A unique identifier for the deferred maintenance window.
  ##   DeferMaintenance: bool
  ##                   : A boolean indicating whether to enable the deferred maintenance window. 
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : A unique identifier for the cluster.
  ##   Version: string (required)
  var query_605606 = newJObject()
  add(query_605606, "DeferMaintenanceStartTime",
      newJString(DeferMaintenanceStartTime))
  add(query_605606, "DeferMaintenanceDuration", newJInt(DeferMaintenanceDuration))
  add(query_605606, "DeferMaintenanceEndTime", newJString(DeferMaintenanceEndTime))
  add(query_605606, "DeferMaintenanceIdentifier",
      newJString(DeferMaintenanceIdentifier))
  add(query_605606, "DeferMaintenance", newJBool(DeferMaintenance))
  add(query_605606, "Action", newJString(Action))
  add(query_605606, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_605606, "Version", newJString(Version))
  result = call_605605.call(nil, query_605606, nil, nil, nil)

var getModifyClusterMaintenance* = Call_GetModifyClusterMaintenance_605586(
    name: "getModifyClusterMaintenance", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyClusterMaintenance",
    validator: validate_GetModifyClusterMaintenance_605587, base: "/",
    url: url_GetModifyClusterMaintenance_605588,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostModifyClusterParameterGroup_605646 = ref object of OpenApiRestCall_602450
proc url_PostModifyClusterParameterGroup_605648(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostModifyClusterParameterGroup_605647(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Modifies the parameters of a parameter group.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_605649 = query.getOrDefault("Action")
  valid_605649 = validateParameter(valid_605649, JString, required = true, default = newJString(
      "ModifyClusterParameterGroup"))
  if valid_605649 != nil:
    section.add "Action", valid_605649
  var valid_605650 = query.getOrDefault("Version")
  valid_605650 = validateParameter(valid_605650, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_605650 != nil:
    section.add "Version", valid_605650
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_605651 = header.getOrDefault("X-Amz-Date")
  valid_605651 = validateParameter(valid_605651, JString, required = false,
                                 default = nil)
  if valid_605651 != nil:
    section.add "X-Amz-Date", valid_605651
  var valid_605652 = header.getOrDefault("X-Amz-Security-Token")
  valid_605652 = validateParameter(valid_605652, JString, required = false,
                                 default = nil)
  if valid_605652 != nil:
    section.add "X-Amz-Security-Token", valid_605652
  var valid_605653 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605653 = validateParameter(valid_605653, JString, required = false,
                                 default = nil)
  if valid_605653 != nil:
    section.add "X-Amz-Content-Sha256", valid_605653
  var valid_605654 = header.getOrDefault("X-Amz-Algorithm")
  valid_605654 = validateParameter(valid_605654, JString, required = false,
                                 default = nil)
  if valid_605654 != nil:
    section.add "X-Amz-Algorithm", valid_605654
  var valid_605655 = header.getOrDefault("X-Amz-Signature")
  valid_605655 = validateParameter(valid_605655, JString, required = false,
                                 default = nil)
  if valid_605655 != nil:
    section.add "X-Amz-Signature", valid_605655
  var valid_605656 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605656 = validateParameter(valid_605656, JString, required = false,
                                 default = nil)
  if valid_605656 != nil:
    section.add "X-Amz-SignedHeaders", valid_605656
  var valid_605657 = header.getOrDefault("X-Amz-Credential")
  valid_605657 = validateParameter(valid_605657, JString, required = false,
                                 default = nil)
  if valid_605657 != nil:
    section.add "X-Amz-Credential", valid_605657
  result.add "header", section
  ## parameters in `formData` object:
  ##   ParameterGroupName: JString (required)
  ##                     : The name of the parameter group to be modified.
  ##   Parameters: JArray (required)
  ##             : <p>An array of parameters to be modified. A maximum of 20 parameters can be modified in a single request.</p> <p>For each parameter to be modified, you must supply at least the parameter name and parameter value; other name-value pairs of the parameter are optional.</p> <p>For the workload management (WLM) configuration, you must supply all the name-value pairs in the wlm_json_configuration parameter.</p>
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ParameterGroupName` field"
  var valid_605658 = formData.getOrDefault("ParameterGroupName")
  valid_605658 = validateParameter(valid_605658, JString, required = true,
                                 default = nil)
  if valid_605658 != nil:
    section.add "ParameterGroupName", valid_605658
  var valid_605659 = formData.getOrDefault("Parameters")
  valid_605659 = validateParameter(valid_605659, JArray, required = true, default = nil)
  if valid_605659 != nil:
    section.add "Parameters", valid_605659
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_605660: Call_PostModifyClusterParameterGroup_605646;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Modifies the parameters of a parameter group.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_605660.validator(path, query, header, formData, body)
  let scheme = call_605660.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605660.url(scheme.get, call_605660.host, call_605660.base,
                         call_605660.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_605660, url, valid)

proc call*(call_605661: Call_PostModifyClusterParameterGroup_605646;
          ParameterGroupName: string; Parameters: JsonNode;
          Action: string = "ModifyClusterParameterGroup";
          Version: string = "2012-12-01"): Recallable =
  ## postModifyClusterParameterGroup
  ## <p>Modifies the parameters of a parameter group.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   ParameterGroupName: string (required)
  ##                     : The name of the parameter group to be modified.
  ##   Parameters: JArray (required)
  ##             : <p>An array of parameters to be modified. A maximum of 20 parameters can be modified in a single request.</p> <p>For each parameter to be modified, you must supply at least the parameter name and parameter value; other name-value pairs of the parameter are optional.</p> <p>For the workload management (WLM) configuration, you must supply all the name-value pairs in the wlm_json_configuration parameter.</p>
  ##   Action: string (required)
  ##   Version: string (required)
  var query_605662 = newJObject()
  var formData_605663 = newJObject()
  add(formData_605663, "ParameterGroupName", newJString(ParameterGroupName))
  if Parameters != nil:
    formData_605663.add "Parameters", Parameters
  add(query_605662, "Action", newJString(Action))
  add(query_605662, "Version", newJString(Version))
  result = call_605661.call(nil, query_605662, nil, formData_605663, nil)

var postModifyClusterParameterGroup* = Call_PostModifyClusterParameterGroup_605646(
    name: "postModifyClusterParameterGroup", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyClusterParameterGroup",
    validator: validate_PostModifyClusterParameterGroup_605647, base: "/",
    url: url_PostModifyClusterParameterGroup_605648,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetModifyClusterParameterGroup_605629 = ref object of OpenApiRestCall_602450
proc url_GetModifyClusterParameterGroup_605631(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetModifyClusterParameterGroup_605630(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Modifies the parameters of a parameter group.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ParameterGroupName: JString (required)
  ##                     : The name of the parameter group to be modified.
  ##   Parameters: JArray (required)
  ##             : <p>An array of parameters to be modified. A maximum of 20 parameters can be modified in a single request.</p> <p>For each parameter to be modified, you must supply at least the parameter name and parameter value; other name-value pairs of the parameter are optional.</p> <p>For the workload management (WLM) configuration, you must supply all the name-value pairs in the wlm_json_configuration parameter.</p>
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `ParameterGroupName` field"
  var valid_605632 = query.getOrDefault("ParameterGroupName")
  valid_605632 = validateParameter(valid_605632, JString, required = true,
                                 default = nil)
  if valid_605632 != nil:
    section.add "ParameterGroupName", valid_605632
  var valid_605633 = query.getOrDefault("Parameters")
  valid_605633 = validateParameter(valid_605633, JArray, required = true, default = nil)
  if valid_605633 != nil:
    section.add "Parameters", valid_605633
  var valid_605634 = query.getOrDefault("Action")
  valid_605634 = validateParameter(valid_605634, JString, required = true, default = newJString(
      "ModifyClusterParameterGroup"))
  if valid_605634 != nil:
    section.add "Action", valid_605634
  var valid_605635 = query.getOrDefault("Version")
  valid_605635 = validateParameter(valid_605635, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_605635 != nil:
    section.add "Version", valid_605635
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_605636 = header.getOrDefault("X-Amz-Date")
  valid_605636 = validateParameter(valid_605636, JString, required = false,
                                 default = nil)
  if valid_605636 != nil:
    section.add "X-Amz-Date", valid_605636
  var valid_605637 = header.getOrDefault("X-Amz-Security-Token")
  valid_605637 = validateParameter(valid_605637, JString, required = false,
                                 default = nil)
  if valid_605637 != nil:
    section.add "X-Amz-Security-Token", valid_605637
  var valid_605638 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605638 = validateParameter(valid_605638, JString, required = false,
                                 default = nil)
  if valid_605638 != nil:
    section.add "X-Amz-Content-Sha256", valid_605638
  var valid_605639 = header.getOrDefault("X-Amz-Algorithm")
  valid_605639 = validateParameter(valid_605639, JString, required = false,
                                 default = nil)
  if valid_605639 != nil:
    section.add "X-Amz-Algorithm", valid_605639
  var valid_605640 = header.getOrDefault("X-Amz-Signature")
  valid_605640 = validateParameter(valid_605640, JString, required = false,
                                 default = nil)
  if valid_605640 != nil:
    section.add "X-Amz-Signature", valid_605640
  var valid_605641 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605641 = validateParameter(valid_605641, JString, required = false,
                                 default = nil)
  if valid_605641 != nil:
    section.add "X-Amz-SignedHeaders", valid_605641
  var valid_605642 = header.getOrDefault("X-Amz-Credential")
  valid_605642 = validateParameter(valid_605642, JString, required = false,
                                 default = nil)
  if valid_605642 != nil:
    section.add "X-Amz-Credential", valid_605642
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_605643: Call_GetModifyClusterParameterGroup_605629; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Modifies the parameters of a parameter group.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_605643.validator(path, query, header, formData, body)
  let scheme = call_605643.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605643.url(scheme.get, call_605643.host, call_605643.base,
                         call_605643.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_605643, url, valid)

proc call*(call_605644: Call_GetModifyClusterParameterGroup_605629;
          ParameterGroupName: string; Parameters: JsonNode;
          Action: string = "ModifyClusterParameterGroup";
          Version: string = "2012-12-01"): Recallable =
  ## getModifyClusterParameterGroup
  ## <p>Modifies the parameters of a parameter group.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   ParameterGroupName: string (required)
  ##                     : The name of the parameter group to be modified.
  ##   Parameters: JArray (required)
  ##             : <p>An array of parameters to be modified. A maximum of 20 parameters can be modified in a single request.</p> <p>For each parameter to be modified, you must supply at least the parameter name and parameter value; other name-value pairs of the parameter are optional.</p> <p>For the workload management (WLM) configuration, you must supply all the name-value pairs in the wlm_json_configuration parameter.</p>
  ##   Action: string (required)
  ##   Version: string (required)
  var query_605645 = newJObject()
  add(query_605645, "ParameterGroupName", newJString(ParameterGroupName))
  if Parameters != nil:
    query_605645.add "Parameters", Parameters
  add(query_605645, "Action", newJString(Action))
  add(query_605645, "Version", newJString(Version))
  result = call_605644.call(nil, query_605645, nil, nil, nil)

var getModifyClusterParameterGroup* = Call_GetModifyClusterParameterGroup_605629(
    name: "getModifyClusterParameterGroup", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyClusterParameterGroup",
    validator: validate_GetModifyClusterParameterGroup_605630, base: "/",
    url: url_GetModifyClusterParameterGroup_605631,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostModifyClusterSnapshot_605682 = ref object of OpenApiRestCall_602450
proc url_PostModifyClusterSnapshot_605684(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostModifyClusterSnapshot_605683(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies the settings for a snapshot.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_605685 = query.getOrDefault("Action")
  valid_605685 = validateParameter(valid_605685, JString, required = true,
                                 default = newJString("ModifyClusterSnapshot"))
  if valid_605685 != nil:
    section.add "Action", valid_605685
  var valid_605686 = query.getOrDefault("Version")
  valid_605686 = validateParameter(valid_605686, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_605686 != nil:
    section.add "Version", valid_605686
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_605687 = header.getOrDefault("X-Amz-Date")
  valid_605687 = validateParameter(valid_605687, JString, required = false,
                                 default = nil)
  if valid_605687 != nil:
    section.add "X-Amz-Date", valid_605687
  var valid_605688 = header.getOrDefault("X-Amz-Security-Token")
  valid_605688 = validateParameter(valid_605688, JString, required = false,
                                 default = nil)
  if valid_605688 != nil:
    section.add "X-Amz-Security-Token", valid_605688
  var valid_605689 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605689 = validateParameter(valid_605689, JString, required = false,
                                 default = nil)
  if valid_605689 != nil:
    section.add "X-Amz-Content-Sha256", valid_605689
  var valid_605690 = header.getOrDefault("X-Amz-Algorithm")
  valid_605690 = validateParameter(valid_605690, JString, required = false,
                                 default = nil)
  if valid_605690 != nil:
    section.add "X-Amz-Algorithm", valid_605690
  var valid_605691 = header.getOrDefault("X-Amz-Signature")
  valid_605691 = validateParameter(valid_605691, JString, required = false,
                                 default = nil)
  if valid_605691 != nil:
    section.add "X-Amz-Signature", valid_605691
  var valid_605692 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605692 = validateParameter(valid_605692, JString, required = false,
                                 default = nil)
  if valid_605692 != nil:
    section.add "X-Amz-SignedHeaders", valid_605692
  var valid_605693 = header.getOrDefault("X-Amz-Credential")
  valid_605693 = validateParameter(valid_605693, JString, required = false,
                                 default = nil)
  if valid_605693 != nil:
    section.add "X-Amz-Credential", valid_605693
  result.add "header", section
  ## parameters in `formData` object:
  ##   Force: JBool
  ##        : A Boolean option to override an exception if the retention period has already passed.
  ##   SnapshotIdentifier: JString (required)
  ##                     : The identifier of the snapshot whose setting you want to modify.
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely.</p> <p>If the manual snapshot falls outside of the new retention period, you can specify the force option to immediately delete the snapshot.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  section = newJObject()
  var valid_605694 = formData.getOrDefault("Force")
  valid_605694 = validateParameter(valid_605694, JBool, required = false, default = nil)
  if valid_605694 != nil:
    section.add "Force", valid_605694
  assert formData != nil, "formData argument is necessary due to required `SnapshotIdentifier` field"
  var valid_605695 = formData.getOrDefault("SnapshotIdentifier")
  valid_605695 = validateParameter(valid_605695, JString, required = true,
                                 default = nil)
  if valid_605695 != nil:
    section.add "SnapshotIdentifier", valid_605695
  var valid_605696 = formData.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_605696 = validateParameter(valid_605696, JInt, required = false, default = nil)
  if valid_605696 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_605696
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_605697: Call_PostModifyClusterSnapshot_605682; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Modifies the settings for a snapshot.
  ## 
  let valid = call_605697.validator(path, query, header, formData, body)
  let scheme = call_605697.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605697.url(scheme.get, call_605697.host, call_605697.base,
                         call_605697.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_605697, url, valid)

proc call*(call_605698: Call_PostModifyClusterSnapshot_605682;
          SnapshotIdentifier: string; Force: bool = false;
          Action: string = "ModifyClusterSnapshot";
          ManualSnapshotRetentionPeriod: int = 0; Version: string = "2012-12-01"): Recallable =
  ## postModifyClusterSnapshot
  ## Modifies the settings for a snapshot.
  ##   Force: bool
  ##        : A Boolean option to override an exception if the retention period has already passed.
  ##   Action: string (required)
  ##   SnapshotIdentifier: string (required)
  ##                     : The identifier of the snapshot whose setting you want to modify.
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely.</p> <p>If the manual snapshot falls outside of the new retention period, you can specify the force option to immediately delete the snapshot.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  ##   Version: string (required)
  var query_605699 = newJObject()
  var formData_605700 = newJObject()
  add(formData_605700, "Force", newJBool(Force))
  add(query_605699, "Action", newJString(Action))
  add(formData_605700, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(formData_605700, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  add(query_605699, "Version", newJString(Version))
  result = call_605698.call(nil, query_605699, nil, formData_605700, nil)

var postModifyClusterSnapshot* = Call_PostModifyClusterSnapshot_605682(
    name: "postModifyClusterSnapshot", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyClusterSnapshot",
    validator: validate_PostModifyClusterSnapshot_605683, base: "/",
    url: url_PostModifyClusterSnapshot_605684,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetModifyClusterSnapshot_605664 = ref object of OpenApiRestCall_602450
proc url_GetModifyClusterSnapshot_605666(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetModifyClusterSnapshot_605665(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies the settings for a snapshot.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   SnapshotIdentifier: JString (required)
  ##                     : The identifier of the snapshot whose setting you want to modify.
  ##   Version: JString (required)
  ##   Force: JBool
  ##        : A Boolean option to override an exception if the retention period has already passed.
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely.</p> <p>If the manual snapshot falls outside of the new retention period, you can specify the force option to immediately delete the snapshot.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_605667 = query.getOrDefault("Action")
  valid_605667 = validateParameter(valid_605667, JString, required = true,
                                 default = newJString("ModifyClusterSnapshot"))
  if valid_605667 != nil:
    section.add "Action", valid_605667
  var valid_605668 = query.getOrDefault("SnapshotIdentifier")
  valid_605668 = validateParameter(valid_605668, JString, required = true,
                                 default = nil)
  if valid_605668 != nil:
    section.add "SnapshotIdentifier", valid_605668
  var valid_605669 = query.getOrDefault("Version")
  valid_605669 = validateParameter(valid_605669, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_605669 != nil:
    section.add "Version", valid_605669
  var valid_605670 = query.getOrDefault("Force")
  valid_605670 = validateParameter(valid_605670, JBool, required = false, default = nil)
  if valid_605670 != nil:
    section.add "Force", valid_605670
  var valid_605671 = query.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_605671 = validateParameter(valid_605671, JInt, required = false, default = nil)
  if valid_605671 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_605671
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_605672 = header.getOrDefault("X-Amz-Date")
  valid_605672 = validateParameter(valid_605672, JString, required = false,
                                 default = nil)
  if valid_605672 != nil:
    section.add "X-Amz-Date", valid_605672
  var valid_605673 = header.getOrDefault("X-Amz-Security-Token")
  valid_605673 = validateParameter(valid_605673, JString, required = false,
                                 default = nil)
  if valid_605673 != nil:
    section.add "X-Amz-Security-Token", valid_605673
  var valid_605674 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605674 = validateParameter(valid_605674, JString, required = false,
                                 default = nil)
  if valid_605674 != nil:
    section.add "X-Amz-Content-Sha256", valid_605674
  var valid_605675 = header.getOrDefault("X-Amz-Algorithm")
  valid_605675 = validateParameter(valid_605675, JString, required = false,
                                 default = nil)
  if valid_605675 != nil:
    section.add "X-Amz-Algorithm", valid_605675
  var valid_605676 = header.getOrDefault("X-Amz-Signature")
  valid_605676 = validateParameter(valid_605676, JString, required = false,
                                 default = nil)
  if valid_605676 != nil:
    section.add "X-Amz-Signature", valid_605676
  var valid_605677 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605677 = validateParameter(valid_605677, JString, required = false,
                                 default = nil)
  if valid_605677 != nil:
    section.add "X-Amz-SignedHeaders", valid_605677
  var valid_605678 = header.getOrDefault("X-Amz-Credential")
  valid_605678 = validateParameter(valid_605678, JString, required = false,
                                 default = nil)
  if valid_605678 != nil:
    section.add "X-Amz-Credential", valid_605678
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_605679: Call_GetModifyClusterSnapshot_605664; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Modifies the settings for a snapshot.
  ## 
  let valid = call_605679.validator(path, query, header, formData, body)
  let scheme = call_605679.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605679.url(scheme.get, call_605679.host, call_605679.base,
                         call_605679.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_605679, url, valid)

proc call*(call_605680: Call_GetModifyClusterSnapshot_605664;
          SnapshotIdentifier: string; Action: string = "ModifyClusterSnapshot";
          Version: string = "2012-12-01"; Force: bool = false;
          ManualSnapshotRetentionPeriod: int = 0): Recallable =
  ## getModifyClusterSnapshot
  ## Modifies the settings for a snapshot.
  ##   Action: string (required)
  ##   SnapshotIdentifier: string (required)
  ##                     : The identifier of the snapshot whose setting you want to modify.
  ##   Version: string (required)
  ##   Force: bool
  ##        : A Boolean option to override an exception if the retention period has already passed.
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely.</p> <p>If the manual snapshot falls outside of the new retention period, you can specify the force option to immediately delete the snapshot.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  var query_605681 = newJObject()
  add(query_605681, "Action", newJString(Action))
  add(query_605681, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_605681, "Version", newJString(Version))
  add(query_605681, "Force", newJBool(Force))
  add(query_605681, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  result = call_605680.call(nil, query_605681, nil, nil, nil)

var getModifyClusterSnapshot* = Call_GetModifyClusterSnapshot_605664(
    name: "getModifyClusterSnapshot", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyClusterSnapshot",
    validator: validate_GetModifyClusterSnapshot_605665, base: "/",
    url: url_GetModifyClusterSnapshot_605666, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostModifyClusterSnapshotSchedule_605719 = ref object of OpenApiRestCall_602450
proc url_PostModifyClusterSnapshotSchedule_605721(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostModifyClusterSnapshotSchedule_605720(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies a snapshot schedule for a cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_605722 = query.getOrDefault("Action")
  valid_605722 = validateParameter(valid_605722, JString, required = true, default = newJString(
      "ModifyClusterSnapshotSchedule"))
  if valid_605722 != nil:
    section.add "Action", valid_605722
  var valid_605723 = query.getOrDefault("Version")
  valid_605723 = validateParameter(valid_605723, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_605723 != nil:
    section.add "Version", valid_605723
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_605724 = header.getOrDefault("X-Amz-Date")
  valid_605724 = validateParameter(valid_605724, JString, required = false,
                                 default = nil)
  if valid_605724 != nil:
    section.add "X-Amz-Date", valid_605724
  var valid_605725 = header.getOrDefault("X-Amz-Security-Token")
  valid_605725 = validateParameter(valid_605725, JString, required = false,
                                 default = nil)
  if valid_605725 != nil:
    section.add "X-Amz-Security-Token", valid_605725
  var valid_605726 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605726 = validateParameter(valid_605726, JString, required = false,
                                 default = nil)
  if valid_605726 != nil:
    section.add "X-Amz-Content-Sha256", valid_605726
  var valid_605727 = header.getOrDefault("X-Amz-Algorithm")
  valid_605727 = validateParameter(valid_605727, JString, required = false,
                                 default = nil)
  if valid_605727 != nil:
    section.add "X-Amz-Algorithm", valid_605727
  var valid_605728 = header.getOrDefault("X-Amz-Signature")
  valid_605728 = validateParameter(valid_605728, JString, required = false,
                                 default = nil)
  if valid_605728 != nil:
    section.add "X-Amz-Signature", valid_605728
  var valid_605729 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605729 = validateParameter(valid_605729, JString, required = false,
                                 default = nil)
  if valid_605729 != nil:
    section.add "X-Amz-SignedHeaders", valid_605729
  var valid_605730 = header.getOrDefault("X-Amz-Credential")
  valid_605730 = validateParameter(valid_605730, JString, required = false,
                                 default = nil)
  if valid_605730 != nil:
    section.add "X-Amz-Credential", valid_605730
  result.add "header", section
  ## parameters in `formData` object:
  ##   DisassociateSchedule: JBool
  ##                       : A boolean to indicate whether to remove the assoiciation between the cluster and the schedule.
  ##   ClusterIdentifier: JString (required)
  ##                    : A unique identifier for the cluster whose snapshot schedule you want to modify. 
  ##   ScheduleIdentifier: JString
  ##                     : A unique alphanumeric identifier for the schedule that you want to associate with the cluster.
  section = newJObject()
  var valid_605731 = formData.getOrDefault("DisassociateSchedule")
  valid_605731 = validateParameter(valid_605731, JBool, required = false, default = nil)
  if valid_605731 != nil:
    section.add "DisassociateSchedule", valid_605731
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_605732 = formData.getOrDefault("ClusterIdentifier")
  valid_605732 = validateParameter(valid_605732, JString, required = true,
                                 default = nil)
  if valid_605732 != nil:
    section.add "ClusterIdentifier", valid_605732
  var valid_605733 = formData.getOrDefault("ScheduleIdentifier")
  valid_605733 = validateParameter(valid_605733, JString, required = false,
                                 default = nil)
  if valid_605733 != nil:
    section.add "ScheduleIdentifier", valid_605733
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_605734: Call_PostModifyClusterSnapshotSchedule_605719;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Modifies a snapshot schedule for a cluster.
  ## 
  let valid = call_605734.validator(path, query, header, formData, body)
  let scheme = call_605734.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605734.url(scheme.get, call_605734.host, call_605734.base,
                         call_605734.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_605734, url, valid)

proc call*(call_605735: Call_PostModifyClusterSnapshotSchedule_605719;
          ClusterIdentifier: string; DisassociateSchedule: bool = false;
          Action: string = "ModifyClusterSnapshotSchedule";
          ScheduleIdentifier: string = ""; Version: string = "2012-12-01"): Recallable =
  ## postModifyClusterSnapshotSchedule
  ## Modifies a snapshot schedule for a cluster.
  ##   DisassociateSchedule: bool
  ##                       : A boolean to indicate whether to remove the assoiciation between the cluster and the schedule.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : A unique identifier for the cluster whose snapshot schedule you want to modify. 
  ##   ScheduleIdentifier: string
  ##                     : A unique alphanumeric identifier for the schedule that you want to associate with the cluster.
  ##   Version: string (required)
  var query_605736 = newJObject()
  var formData_605737 = newJObject()
  add(formData_605737, "DisassociateSchedule", newJBool(DisassociateSchedule))
  add(query_605736, "Action", newJString(Action))
  add(formData_605737, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_605737, "ScheduleIdentifier", newJString(ScheduleIdentifier))
  add(query_605736, "Version", newJString(Version))
  result = call_605735.call(nil, query_605736, nil, formData_605737, nil)

var postModifyClusterSnapshotSchedule* = Call_PostModifyClusterSnapshotSchedule_605719(
    name: "postModifyClusterSnapshotSchedule", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=ModifyClusterSnapshotSchedule",
    validator: validate_PostModifyClusterSnapshotSchedule_605720, base: "/",
    url: url_PostModifyClusterSnapshotSchedule_605721,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetModifyClusterSnapshotSchedule_605701 = ref object of OpenApiRestCall_602450
proc url_GetModifyClusterSnapshotSchedule_605703(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetModifyClusterSnapshotSchedule_605702(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies a snapshot schedule for a cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : A unique identifier for the cluster whose snapshot schedule you want to modify. 
  ##   ScheduleIdentifier: JString
  ##                     : A unique alphanumeric identifier for the schedule that you want to associate with the cluster.
  ##   DisassociateSchedule: JBool
  ##                       : A boolean to indicate whether to remove the assoiciation between the cluster and the schedule.
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_605704 = query.getOrDefault("Action")
  valid_605704 = validateParameter(valid_605704, JString, required = true, default = newJString(
      "ModifyClusterSnapshotSchedule"))
  if valid_605704 != nil:
    section.add "Action", valid_605704
  var valid_605705 = query.getOrDefault("ClusterIdentifier")
  valid_605705 = validateParameter(valid_605705, JString, required = true,
                                 default = nil)
  if valid_605705 != nil:
    section.add "ClusterIdentifier", valid_605705
  var valid_605706 = query.getOrDefault("ScheduleIdentifier")
  valid_605706 = validateParameter(valid_605706, JString, required = false,
                                 default = nil)
  if valid_605706 != nil:
    section.add "ScheduleIdentifier", valid_605706
  var valid_605707 = query.getOrDefault("DisassociateSchedule")
  valid_605707 = validateParameter(valid_605707, JBool, required = false, default = nil)
  if valid_605707 != nil:
    section.add "DisassociateSchedule", valid_605707
  var valid_605708 = query.getOrDefault("Version")
  valid_605708 = validateParameter(valid_605708, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_605708 != nil:
    section.add "Version", valid_605708
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_605709 = header.getOrDefault("X-Amz-Date")
  valid_605709 = validateParameter(valid_605709, JString, required = false,
                                 default = nil)
  if valid_605709 != nil:
    section.add "X-Amz-Date", valid_605709
  var valid_605710 = header.getOrDefault("X-Amz-Security-Token")
  valid_605710 = validateParameter(valid_605710, JString, required = false,
                                 default = nil)
  if valid_605710 != nil:
    section.add "X-Amz-Security-Token", valid_605710
  var valid_605711 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605711 = validateParameter(valid_605711, JString, required = false,
                                 default = nil)
  if valid_605711 != nil:
    section.add "X-Amz-Content-Sha256", valid_605711
  var valid_605712 = header.getOrDefault("X-Amz-Algorithm")
  valid_605712 = validateParameter(valid_605712, JString, required = false,
                                 default = nil)
  if valid_605712 != nil:
    section.add "X-Amz-Algorithm", valid_605712
  var valid_605713 = header.getOrDefault("X-Amz-Signature")
  valid_605713 = validateParameter(valid_605713, JString, required = false,
                                 default = nil)
  if valid_605713 != nil:
    section.add "X-Amz-Signature", valid_605713
  var valid_605714 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605714 = validateParameter(valid_605714, JString, required = false,
                                 default = nil)
  if valid_605714 != nil:
    section.add "X-Amz-SignedHeaders", valid_605714
  var valid_605715 = header.getOrDefault("X-Amz-Credential")
  valid_605715 = validateParameter(valid_605715, JString, required = false,
                                 default = nil)
  if valid_605715 != nil:
    section.add "X-Amz-Credential", valid_605715
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_605716: Call_GetModifyClusterSnapshotSchedule_605701;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Modifies a snapshot schedule for a cluster.
  ## 
  let valid = call_605716.validator(path, query, header, formData, body)
  let scheme = call_605716.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605716.url(scheme.get, call_605716.host, call_605716.base,
                         call_605716.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_605716, url, valid)

proc call*(call_605717: Call_GetModifyClusterSnapshotSchedule_605701;
          ClusterIdentifier: string;
          Action: string = "ModifyClusterSnapshotSchedule";
          ScheduleIdentifier: string = ""; DisassociateSchedule: bool = false;
          Version: string = "2012-12-01"): Recallable =
  ## getModifyClusterSnapshotSchedule
  ## Modifies a snapshot schedule for a cluster.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : A unique identifier for the cluster whose snapshot schedule you want to modify. 
  ##   ScheduleIdentifier: string
  ##                     : A unique alphanumeric identifier for the schedule that you want to associate with the cluster.
  ##   DisassociateSchedule: bool
  ##                       : A boolean to indicate whether to remove the assoiciation between the cluster and the schedule.
  ##   Version: string (required)
  var query_605718 = newJObject()
  add(query_605718, "Action", newJString(Action))
  add(query_605718, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_605718, "ScheduleIdentifier", newJString(ScheduleIdentifier))
  add(query_605718, "DisassociateSchedule", newJBool(DisassociateSchedule))
  add(query_605718, "Version", newJString(Version))
  result = call_605717.call(nil, query_605718, nil, nil, nil)

var getModifyClusterSnapshotSchedule* = Call_GetModifyClusterSnapshotSchedule_605701(
    name: "getModifyClusterSnapshotSchedule", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=ModifyClusterSnapshotSchedule",
    validator: validate_GetModifyClusterSnapshotSchedule_605702, base: "/",
    url: url_GetModifyClusterSnapshotSchedule_605703,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostModifyClusterSubnetGroup_605756 = ref object of OpenApiRestCall_602450
proc url_PostModifyClusterSubnetGroup_605758(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostModifyClusterSubnetGroup_605757(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies a cluster subnet group to include the specified list of VPC subnets. The operation replaces the existing list of subnets with the new list of subnets.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_605759 = query.getOrDefault("Action")
  valid_605759 = validateParameter(valid_605759, JString, required = true, default = newJString(
      "ModifyClusterSubnetGroup"))
  if valid_605759 != nil:
    section.add "Action", valid_605759
  var valid_605760 = query.getOrDefault("Version")
  valid_605760 = validateParameter(valid_605760, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_605760 != nil:
    section.add "Version", valid_605760
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_605761 = header.getOrDefault("X-Amz-Date")
  valid_605761 = validateParameter(valid_605761, JString, required = false,
                                 default = nil)
  if valid_605761 != nil:
    section.add "X-Amz-Date", valid_605761
  var valid_605762 = header.getOrDefault("X-Amz-Security-Token")
  valid_605762 = validateParameter(valid_605762, JString, required = false,
                                 default = nil)
  if valid_605762 != nil:
    section.add "X-Amz-Security-Token", valid_605762
  var valid_605763 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605763 = validateParameter(valid_605763, JString, required = false,
                                 default = nil)
  if valid_605763 != nil:
    section.add "X-Amz-Content-Sha256", valid_605763
  var valid_605764 = header.getOrDefault("X-Amz-Algorithm")
  valid_605764 = validateParameter(valid_605764, JString, required = false,
                                 default = nil)
  if valid_605764 != nil:
    section.add "X-Amz-Algorithm", valid_605764
  var valid_605765 = header.getOrDefault("X-Amz-Signature")
  valid_605765 = validateParameter(valid_605765, JString, required = false,
                                 default = nil)
  if valid_605765 != nil:
    section.add "X-Amz-Signature", valid_605765
  var valid_605766 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605766 = validateParameter(valid_605766, JString, required = false,
                                 default = nil)
  if valid_605766 != nil:
    section.add "X-Amz-SignedHeaders", valid_605766
  var valid_605767 = header.getOrDefault("X-Amz-Credential")
  valid_605767 = validateParameter(valid_605767, JString, required = false,
                                 default = nil)
  if valid_605767 != nil:
    section.add "X-Amz-Credential", valid_605767
  result.add "header", section
  ## parameters in `formData` object:
  ##   SubnetIds: JArray (required)
  ##            : An array of VPC subnet IDs. A maximum of 20 subnets can be modified in a single request.
  ##   Description: JString
  ##              : A text description of the subnet group to be modified.
  ##   ClusterSubnetGroupName: JString (required)
  ##                         : The name of the subnet group to be modified.
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `SubnetIds` field"
  var valid_605768 = formData.getOrDefault("SubnetIds")
  valid_605768 = validateParameter(valid_605768, JArray, required = true, default = nil)
  if valid_605768 != nil:
    section.add "SubnetIds", valid_605768
  var valid_605769 = formData.getOrDefault("Description")
  valid_605769 = validateParameter(valid_605769, JString, required = false,
                                 default = nil)
  if valid_605769 != nil:
    section.add "Description", valid_605769
  var valid_605770 = formData.getOrDefault("ClusterSubnetGroupName")
  valid_605770 = validateParameter(valid_605770, JString, required = true,
                                 default = nil)
  if valid_605770 != nil:
    section.add "ClusterSubnetGroupName", valid_605770
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_605771: Call_PostModifyClusterSubnetGroup_605756; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Modifies a cluster subnet group to include the specified list of VPC subnets. The operation replaces the existing list of subnets with the new list of subnets.
  ## 
  let valid = call_605771.validator(path, query, header, formData, body)
  let scheme = call_605771.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605771.url(scheme.get, call_605771.host, call_605771.base,
                         call_605771.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_605771, url, valid)

proc call*(call_605772: Call_PostModifyClusterSubnetGroup_605756;
          SubnetIds: JsonNode; ClusterSubnetGroupName: string;
          Action: string = "ModifyClusterSubnetGroup";
          Version: string = "2012-12-01"; Description: string = ""): Recallable =
  ## postModifyClusterSubnetGroup
  ## Modifies a cluster subnet group to include the specified list of VPC subnets. The operation replaces the existing list of subnets with the new list of subnets.
  ##   SubnetIds: JArray (required)
  ##            : An array of VPC subnet IDs. A maximum of 20 subnets can be modified in a single request.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   Description: string
  ##              : A text description of the subnet group to be modified.
  ##   ClusterSubnetGroupName: string (required)
  ##                         : The name of the subnet group to be modified.
  var query_605773 = newJObject()
  var formData_605774 = newJObject()
  if SubnetIds != nil:
    formData_605774.add "SubnetIds", SubnetIds
  add(query_605773, "Action", newJString(Action))
  add(query_605773, "Version", newJString(Version))
  add(formData_605774, "Description", newJString(Description))
  add(formData_605774, "ClusterSubnetGroupName",
      newJString(ClusterSubnetGroupName))
  result = call_605772.call(nil, query_605773, nil, formData_605774, nil)

var postModifyClusterSubnetGroup* = Call_PostModifyClusterSubnetGroup_605756(
    name: "postModifyClusterSubnetGroup", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyClusterSubnetGroup",
    validator: validate_PostModifyClusterSubnetGroup_605757, base: "/",
    url: url_PostModifyClusterSubnetGroup_605758,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetModifyClusterSubnetGroup_605738 = ref object of OpenApiRestCall_602450
proc url_GetModifyClusterSubnetGroup_605740(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetModifyClusterSubnetGroup_605739(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies a cluster subnet group to include the specified list of VPC subnets. The operation replaces the existing list of subnets with the new list of subnets.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ClusterSubnetGroupName: JString (required)
  ##                         : The name of the subnet group to be modified.
  ##   Description: JString
  ##              : A text description of the subnet group to be modified.
  ##   Action: JString (required)
  ##   SubnetIds: JArray (required)
  ##            : An array of VPC subnet IDs. A maximum of 20 subnets can be modified in a single request.
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `ClusterSubnetGroupName` field"
  var valid_605741 = query.getOrDefault("ClusterSubnetGroupName")
  valid_605741 = validateParameter(valid_605741, JString, required = true,
                                 default = nil)
  if valid_605741 != nil:
    section.add "ClusterSubnetGroupName", valid_605741
  var valid_605742 = query.getOrDefault("Description")
  valid_605742 = validateParameter(valid_605742, JString, required = false,
                                 default = nil)
  if valid_605742 != nil:
    section.add "Description", valid_605742
  var valid_605743 = query.getOrDefault("Action")
  valid_605743 = validateParameter(valid_605743, JString, required = true, default = newJString(
      "ModifyClusterSubnetGroup"))
  if valid_605743 != nil:
    section.add "Action", valid_605743
  var valid_605744 = query.getOrDefault("SubnetIds")
  valid_605744 = validateParameter(valid_605744, JArray, required = true, default = nil)
  if valid_605744 != nil:
    section.add "SubnetIds", valid_605744
  var valid_605745 = query.getOrDefault("Version")
  valid_605745 = validateParameter(valid_605745, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_605745 != nil:
    section.add "Version", valid_605745
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_605746 = header.getOrDefault("X-Amz-Date")
  valid_605746 = validateParameter(valid_605746, JString, required = false,
                                 default = nil)
  if valid_605746 != nil:
    section.add "X-Amz-Date", valid_605746
  var valid_605747 = header.getOrDefault("X-Amz-Security-Token")
  valid_605747 = validateParameter(valid_605747, JString, required = false,
                                 default = nil)
  if valid_605747 != nil:
    section.add "X-Amz-Security-Token", valid_605747
  var valid_605748 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605748 = validateParameter(valid_605748, JString, required = false,
                                 default = nil)
  if valid_605748 != nil:
    section.add "X-Amz-Content-Sha256", valid_605748
  var valid_605749 = header.getOrDefault("X-Amz-Algorithm")
  valid_605749 = validateParameter(valid_605749, JString, required = false,
                                 default = nil)
  if valid_605749 != nil:
    section.add "X-Amz-Algorithm", valid_605749
  var valid_605750 = header.getOrDefault("X-Amz-Signature")
  valid_605750 = validateParameter(valid_605750, JString, required = false,
                                 default = nil)
  if valid_605750 != nil:
    section.add "X-Amz-Signature", valid_605750
  var valid_605751 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605751 = validateParameter(valid_605751, JString, required = false,
                                 default = nil)
  if valid_605751 != nil:
    section.add "X-Amz-SignedHeaders", valid_605751
  var valid_605752 = header.getOrDefault("X-Amz-Credential")
  valid_605752 = validateParameter(valid_605752, JString, required = false,
                                 default = nil)
  if valid_605752 != nil:
    section.add "X-Amz-Credential", valid_605752
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_605753: Call_GetModifyClusterSubnetGroup_605738; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Modifies a cluster subnet group to include the specified list of VPC subnets. The operation replaces the existing list of subnets with the new list of subnets.
  ## 
  let valid = call_605753.validator(path, query, header, formData, body)
  let scheme = call_605753.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605753.url(scheme.get, call_605753.host, call_605753.base,
                         call_605753.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_605753, url, valid)

proc call*(call_605754: Call_GetModifyClusterSubnetGroup_605738;
          ClusterSubnetGroupName: string; SubnetIds: JsonNode;
          Description: string = ""; Action: string = "ModifyClusterSubnetGroup";
          Version: string = "2012-12-01"): Recallable =
  ## getModifyClusterSubnetGroup
  ## Modifies a cluster subnet group to include the specified list of VPC subnets. The operation replaces the existing list of subnets with the new list of subnets.
  ##   ClusterSubnetGroupName: string (required)
  ##                         : The name of the subnet group to be modified.
  ##   Description: string
  ##              : A text description of the subnet group to be modified.
  ##   Action: string (required)
  ##   SubnetIds: JArray (required)
  ##            : An array of VPC subnet IDs. A maximum of 20 subnets can be modified in a single request.
  ##   Version: string (required)
  var query_605755 = newJObject()
  add(query_605755, "ClusterSubnetGroupName", newJString(ClusterSubnetGroupName))
  add(query_605755, "Description", newJString(Description))
  add(query_605755, "Action", newJString(Action))
  if SubnetIds != nil:
    query_605755.add "SubnetIds", SubnetIds
  add(query_605755, "Version", newJString(Version))
  result = call_605754.call(nil, query_605755, nil, nil, nil)

var getModifyClusterSubnetGroup* = Call_GetModifyClusterSubnetGroup_605738(
    name: "getModifyClusterSubnetGroup", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyClusterSubnetGroup",
    validator: validate_GetModifyClusterSubnetGroup_605739, base: "/",
    url: url_GetModifyClusterSubnetGroup_605740,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostModifyEventSubscription_605797 = ref object of OpenApiRestCall_602450
proc url_PostModifyEventSubscription_605799(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostModifyEventSubscription_605798(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies an existing Amazon Redshift event notification subscription.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_605800 = query.getOrDefault("Action")
  valid_605800 = validateParameter(valid_605800, JString, required = true, default = newJString(
      "ModifyEventSubscription"))
  if valid_605800 != nil:
    section.add "Action", valid_605800
  var valid_605801 = query.getOrDefault("Version")
  valid_605801 = validateParameter(valid_605801, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_605801 != nil:
    section.add "Version", valid_605801
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_605802 = header.getOrDefault("X-Amz-Date")
  valid_605802 = validateParameter(valid_605802, JString, required = false,
                                 default = nil)
  if valid_605802 != nil:
    section.add "X-Amz-Date", valid_605802
  var valid_605803 = header.getOrDefault("X-Amz-Security-Token")
  valid_605803 = validateParameter(valid_605803, JString, required = false,
                                 default = nil)
  if valid_605803 != nil:
    section.add "X-Amz-Security-Token", valid_605803
  var valid_605804 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605804 = validateParameter(valid_605804, JString, required = false,
                                 default = nil)
  if valid_605804 != nil:
    section.add "X-Amz-Content-Sha256", valid_605804
  var valid_605805 = header.getOrDefault("X-Amz-Algorithm")
  valid_605805 = validateParameter(valid_605805, JString, required = false,
                                 default = nil)
  if valid_605805 != nil:
    section.add "X-Amz-Algorithm", valid_605805
  var valid_605806 = header.getOrDefault("X-Amz-Signature")
  valid_605806 = validateParameter(valid_605806, JString, required = false,
                                 default = nil)
  if valid_605806 != nil:
    section.add "X-Amz-Signature", valid_605806
  var valid_605807 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605807 = validateParameter(valid_605807, JString, required = false,
                                 default = nil)
  if valid_605807 != nil:
    section.add "X-Amz-SignedHeaders", valid_605807
  var valid_605808 = header.getOrDefault("X-Amz-Credential")
  valid_605808 = validateParameter(valid_605808, JString, required = false,
                                 default = nil)
  if valid_605808 != nil:
    section.add "X-Amz-Credential", valid_605808
  result.add "header", section
  ## parameters in `formData` object:
  ##   Enabled: JBool
  ##          : A Boolean value indicating if the subscription is enabled. <code>true</code> indicates the subscription is enabled 
  ##   EventCategories: JArray
  ##                  : <p>Specifies the Amazon Redshift event categories to be published by the event notification subscription.</p> <p>Values: configuration, management, monitoring, security</p>
  ##   SnsTopicArn: JString
  ##              : The Amazon Resource Name (ARN) of the SNS topic to be used by the event notification subscription.
  ##   Severity: JString
  ##           : <p>Specifies the Amazon Redshift event severity to be published by the event notification subscription.</p> <p>Values: ERROR, INFO</p>
  ##   SourceIds: JArray
  ##            : <p>A list of one or more identifiers of Amazon Redshift source objects. All of the objects must be of the same type as was specified in the source type parameter. The event subscription will return only events generated by the specified objects. If not specified, then events are returned for all objects within the source type specified.</p> <p>Example: my-cluster-1, my-cluster-2</p> <p>Example: my-snapshot-20131010</p>
  ##   SubscriptionName: JString (required)
  ##                   : The name of the modified Amazon Redshift event notification subscription.
  ##   SourceType: JString
  ##             : <p>The type of source that will be generating the events. For example, if you want to be notified of events generated by a cluster, you would set this parameter to cluster. If this value is not specified, events are returned for all Amazon Redshift objects in your AWS account. You must specify a source type in order to specify source IDs.</p> <p>Valid values: cluster, cluster-parameter-group, cluster-security-group, and cluster-snapshot.</p>
  section = newJObject()
  var valid_605809 = formData.getOrDefault("Enabled")
  valid_605809 = validateParameter(valid_605809, JBool, required = false, default = nil)
  if valid_605809 != nil:
    section.add "Enabled", valid_605809
  var valid_605810 = formData.getOrDefault("EventCategories")
  valid_605810 = validateParameter(valid_605810, JArray, required = false,
                                 default = nil)
  if valid_605810 != nil:
    section.add "EventCategories", valid_605810
  var valid_605811 = formData.getOrDefault("SnsTopicArn")
  valid_605811 = validateParameter(valid_605811, JString, required = false,
                                 default = nil)
  if valid_605811 != nil:
    section.add "SnsTopicArn", valid_605811
  var valid_605812 = formData.getOrDefault("Severity")
  valid_605812 = validateParameter(valid_605812, JString, required = false,
                                 default = nil)
  if valid_605812 != nil:
    section.add "Severity", valid_605812
  var valid_605813 = formData.getOrDefault("SourceIds")
  valid_605813 = validateParameter(valid_605813, JArray, required = false,
                                 default = nil)
  if valid_605813 != nil:
    section.add "SourceIds", valid_605813
  assert formData != nil, "formData argument is necessary due to required `SubscriptionName` field"
  var valid_605814 = formData.getOrDefault("SubscriptionName")
  valid_605814 = validateParameter(valid_605814, JString, required = true,
                                 default = nil)
  if valid_605814 != nil:
    section.add "SubscriptionName", valid_605814
  var valid_605815 = formData.getOrDefault("SourceType")
  valid_605815 = validateParameter(valid_605815, JString, required = false,
                                 default = nil)
  if valid_605815 != nil:
    section.add "SourceType", valid_605815
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_605816: Call_PostModifyEventSubscription_605797; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Modifies an existing Amazon Redshift event notification subscription.
  ## 
  let valid = call_605816.validator(path, query, header, formData, body)
  let scheme = call_605816.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605816.url(scheme.get, call_605816.host, call_605816.base,
                         call_605816.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_605816, url, valid)

proc call*(call_605817: Call_PostModifyEventSubscription_605797;
          SubscriptionName: string; Enabled: bool = false;
          EventCategories: JsonNode = nil; SnsTopicArn: string = "";
          Severity: string = ""; SourceIds: JsonNode = nil;
          Action: string = "ModifyEventSubscription";
          Version: string = "2012-12-01"; SourceType: string = ""): Recallable =
  ## postModifyEventSubscription
  ## Modifies an existing Amazon Redshift event notification subscription.
  ##   Enabled: bool
  ##          : A Boolean value indicating if the subscription is enabled. <code>true</code> indicates the subscription is enabled 
  ##   EventCategories: JArray
  ##                  : <p>Specifies the Amazon Redshift event categories to be published by the event notification subscription.</p> <p>Values: configuration, management, monitoring, security</p>
  ##   SnsTopicArn: string
  ##              : The Amazon Resource Name (ARN) of the SNS topic to be used by the event notification subscription.
  ##   Severity: string
  ##           : <p>Specifies the Amazon Redshift event severity to be published by the event notification subscription.</p> <p>Values: ERROR, INFO</p>
  ##   SourceIds: JArray
  ##            : <p>A list of one or more identifiers of Amazon Redshift source objects. All of the objects must be of the same type as was specified in the source type parameter. The event subscription will return only events generated by the specified objects. If not specified, then events are returned for all objects within the source type specified.</p> <p>Example: my-cluster-1, my-cluster-2</p> <p>Example: my-snapshot-20131010</p>
  ##   SubscriptionName: string (required)
  ##                   : The name of the modified Amazon Redshift event notification subscription.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   SourceType: string
  ##             : <p>The type of source that will be generating the events. For example, if you want to be notified of events generated by a cluster, you would set this parameter to cluster. If this value is not specified, events are returned for all Amazon Redshift objects in your AWS account. You must specify a source type in order to specify source IDs.</p> <p>Valid values: cluster, cluster-parameter-group, cluster-security-group, and cluster-snapshot.</p>
  var query_605818 = newJObject()
  var formData_605819 = newJObject()
  add(formData_605819, "Enabled", newJBool(Enabled))
  if EventCategories != nil:
    formData_605819.add "EventCategories", EventCategories
  add(formData_605819, "SnsTopicArn", newJString(SnsTopicArn))
  add(formData_605819, "Severity", newJString(Severity))
  if SourceIds != nil:
    formData_605819.add "SourceIds", SourceIds
  add(formData_605819, "SubscriptionName", newJString(SubscriptionName))
  add(query_605818, "Action", newJString(Action))
  add(query_605818, "Version", newJString(Version))
  add(formData_605819, "SourceType", newJString(SourceType))
  result = call_605817.call(nil, query_605818, nil, formData_605819, nil)

var postModifyEventSubscription* = Call_PostModifyEventSubscription_605797(
    name: "postModifyEventSubscription", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyEventSubscription",
    validator: validate_PostModifyEventSubscription_605798, base: "/",
    url: url_PostModifyEventSubscription_605799,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetModifyEventSubscription_605775 = ref object of OpenApiRestCall_602450
proc url_GetModifyEventSubscription_605777(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetModifyEventSubscription_605776(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies an existing Amazon Redshift event notification subscription.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   SourceType: JString
  ##             : <p>The type of source that will be generating the events. For example, if you want to be notified of events generated by a cluster, you would set this parameter to cluster. If this value is not specified, events are returned for all Amazon Redshift objects in your AWS account. You must specify a source type in order to specify source IDs.</p> <p>Valid values: cluster, cluster-parameter-group, cluster-security-group, and cluster-snapshot.</p>
  ##   SourceIds: JArray
  ##            : <p>A list of one or more identifiers of Amazon Redshift source objects. All of the objects must be of the same type as was specified in the source type parameter. The event subscription will return only events generated by the specified objects. If not specified, then events are returned for all objects within the source type specified.</p> <p>Example: my-cluster-1, my-cluster-2</p> <p>Example: my-snapshot-20131010</p>
  ##   Enabled: JBool
  ##          : A Boolean value indicating if the subscription is enabled. <code>true</code> indicates the subscription is enabled 
  ##   Action: JString (required)
  ##   SnsTopicArn: JString
  ##              : The Amazon Resource Name (ARN) of the SNS topic to be used by the event notification subscription.
  ##   EventCategories: JArray
  ##                  : <p>Specifies the Amazon Redshift event categories to be published by the event notification subscription.</p> <p>Values: configuration, management, monitoring, security</p>
  ##   SubscriptionName: JString (required)
  ##                   : The name of the modified Amazon Redshift event notification subscription.
  ##   Severity: JString
  ##           : <p>Specifies the Amazon Redshift event severity to be published by the event notification subscription.</p> <p>Values: ERROR, INFO</p>
  ##   Version: JString (required)
  section = newJObject()
  var valid_605778 = query.getOrDefault("SourceType")
  valid_605778 = validateParameter(valid_605778, JString, required = false,
                                 default = nil)
  if valid_605778 != nil:
    section.add "SourceType", valid_605778
  var valid_605779 = query.getOrDefault("SourceIds")
  valid_605779 = validateParameter(valid_605779, JArray, required = false,
                                 default = nil)
  if valid_605779 != nil:
    section.add "SourceIds", valid_605779
  var valid_605780 = query.getOrDefault("Enabled")
  valid_605780 = validateParameter(valid_605780, JBool, required = false, default = nil)
  if valid_605780 != nil:
    section.add "Enabled", valid_605780
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_605781 = query.getOrDefault("Action")
  valid_605781 = validateParameter(valid_605781, JString, required = true, default = newJString(
      "ModifyEventSubscription"))
  if valid_605781 != nil:
    section.add "Action", valid_605781
  var valid_605782 = query.getOrDefault("SnsTopicArn")
  valid_605782 = validateParameter(valid_605782, JString, required = false,
                                 default = nil)
  if valid_605782 != nil:
    section.add "SnsTopicArn", valid_605782
  var valid_605783 = query.getOrDefault("EventCategories")
  valid_605783 = validateParameter(valid_605783, JArray, required = false,
                                 default = nil)
  if valid_605783 != nil:
    section.add "EventCategories", valid_605783
  var valid_605784 = query.getOrDefault("SubscriptionName")
  valid_605784 = validateParameter(valid_605784, JString, required = true,
                                 default = nil)
  if valid_605784 != nil:
    section.add "SubscriptionName", valid_605784
  var valid_605785 = query.getOrDefault("Severity")
  valid_605785 = validateParameter(valid_605785, JString, required = false,
                                 default = nil)
  if valid_605785 != nil:
    section.add "Severity", valid_605785
  var valid_605786 = query.getOrDefault("Version")
  valid_605786 = validateParameter(valid_605786, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_605786 != nil:
    section.add "Version", valid_605786
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_605787 = header.getOrDefault("X-Amz-Date")
  valid_605787 = validateParameter(valid_605787, JString, required = false,
                                 default = nil)
  if valid_605787 != nil:
    section.add "X-Amz-Date", valid_605787
  var valid_605788 = header.getOrDefault("X-Amz-Security-Token")
  valid_605788 = validateParameter(valid_605788, JString, required = false,
                                 default = nil)
  if valid_605788 != nil:
    section.add "X-Amz-Security-Token", valid_605788
  var valid_605789 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605789 = validateParameter(valid_605789, JString, required = false,
                                 default = nil)
  if valid_605789 != nil:
    section.add "X-Amz-Content-Sha256", valid_605789
  var valid_605790 = header.getOrDefault("X-Amz-Algorithm")
  valid_605790 = validateParameter(valid_605790, JString, required = false,
                                 default = nil)
  if valid_605790 != nil:
    section.add "X-Amz-Algorithm", valid_605790
  var valid_605791 = header.getOrDefault("X-Amz-Signature")
  valid_605791 = validateParameter(valid_605791, JString, required = false,
                                 default = nil)
  if valid_605791 != nil:
    section.add "X-Amz-Signature", valid_605791
  var valid_605792 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605792 = validateParameter(valid_605792, JString, required = false,
                                 default = nil)
  if valid_605792 != nil:
    section.add "X-Amz-SignedHeaders", valid_605792
  var valid_605793 = header.getOrDefault("X-Amz-Credential")
  valid_605793 = validateParameter(valid_605793, JString, required = false,
                                 default = nil)
  if valid_605793 != nil:
    section.add "X-Amz-Credential", valid_605793
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_605794: Call_GetModifyEventSubscription_605775; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Modifies an existing Amazon Redshift event notification subscription.
  ## 
  let valid = call_605794.validator(path, query, header, formData, body)
  let scheme = call_605794.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605794.url(scheme.get, call_605794.host, call_605794.base,
                         call_605794.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_605794, url, valid)

proc call*(call_605795: Call_GetModifyEventSubscription_605775;
          SubscriptionName: string; SourceType: string = "";
          SourceIds: JsonNode = nil; Enabled: bool = false;
          Action: string = "ModifyEventSubscription"; SnsTopicArn: string = "";
          EventCategories: JsonNode = nil; Severity: string = "";
          Version: string = "2012-12-01"): Recallable =
  ## getModifyEventSubscription
  ## Modifies an existing Amazon Redshift event notification subscription.
  ##   SourceType: string
  ##             : <p>The type of source that will be generating the events. For example, if you want to be notified of events generated by a cluster, you would set this parameter to cluster. If this value is not specified, events are returned for all Amazon Redshift objects in your AWS account. You must specify a source type in order to specify source IDs.</p> <p>Valid values: cluster, cluster-parameter-group, cluster-security-group, and cluster-snapshot.</p>
  ##   SourceIds: JArray
  ##            : <p>A list of one or more identifiers of Amazon Redshift source objects. All of the objects must be of the same type as was specified in the source type parameter. The event subscription will return only events generated by the specified objects. If not specified, then events are returned for all objects within the source type specified.</p> <p>Example: my-cluster-1, my-cluster-2</p> <p>Example: my-snapshot-20131010</p>
  ##   Enabled: bool
  ##          : A Boolean value indicating if the subscription is enabled. <code>true</code> indicates the subscription is enabled 
  ##   Action: string (required)
  ##   SnsTopicArn: string
  ##              : The Amazon Resource Name (ARN) of the SNS topic to be used by the event notification subscription.
  ##   EventCategories: JArray
  ##                  : <p>Specifies the Amazon Redshift event categories to be published by the event notification subscription.</p> <p>Values: configuration, management, monitoring, security</p>
  ##   SubscriptionName: string (required)
  ##                   : The name of the modified Amazon Redshift event notification subscription.
  ##   Severity: string
  ##           : <p>Specifies the Amazon Redshift event severity to be published by the event notification subscription.</p> <p>Values: ERROR, INFO</p>
  ##   Version: string (required)
  var query_605796 = newJObject()
  add(query_605796, "SourceType", newJString(SourceType))
  if SourceIds != nil:
    query_605796.add "SourceIds", SourceIds
  add(query_605796, "Enabled", newJBool(Enabled))
  add(query_605796, "Action", newJString(Action))
  add(query_605796, "SnsTopicArn", newJString(SnsTopicArn))
  if EventCategories != nil:
    query_605796.add "EventCategories", EventCategories
  add(query_605796, "SubscriptionName", newJString(SubscriptionName))
  add(query_605796, "Severity", newJString(Severity))
  add(query_605796, "Version", newJString(Version))
  result = call_605795.call(nil, query_605796, nil, nil, nil)

var getModifyEventSubscription* = Call_GetModifyEventSubscription_605775(
    name: "getModifyEventSubscription", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyEventSubscription",
    validator: validate_GetModifyEventSubscription_605776, base: "/",
    url: url_GetModifyEventSubscription_605777,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostModifySnapshotCopyRetentionPeriod_605838 = ref object of OpenApiRestCall_602450
proc url_PostModifySnapshotCopyRetentionPeriod_605840(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostModifySnapshotCopyRetentionPeriod_605839(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies the number of days to retain snapshots in the destination AWS Region after they are copied from the source AWS Region. By default, this operation only changes the retention period of copied automated snapshots. The retention periods for both new and existing copied automated snapshots are updated with the new retention period. You can set the manual option to change only the retention periods of copied manual snapshots. If you set this option, only newly copied manual snapshots have the new retention period. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_605841 = query.getOrDefault("Action")
  valid_605841 = validateParameter(valid_605841, JString, required = true, default = newJString(
      "ModifySnapshotCopyRetentionPeriod"))
  if valid_605841 != nil:
    section.add "Action", valid_605841
  var valid_605842 = query.getOrDefault("Version")
  valid_605842 = validateParameter(valid_605842, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_605842 != nil:
    section.add "Version", valid_605842
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_605843 = header.getOrDefault("X-Amz-Date")
  valid_605843 = validateParameter(valid_605843, JString, required = false,
                                 default = nil)
  if valid_605843 != nil:
    section.add "X-Amz-Date", valid_605843
  var valid_605844 = header.getOrDefault("X-Amz-Security-Token")
  valid_605844 = validateParameter(valid_605844, JString, required = false,
                                 default = nil)
  if valid_605844 != nil:
    section.add "X-Amz-Security-Token", valid_605844
  var valid_605845 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605845 = validateParameter(valid_605845, JString, required = false,
                                 default = nil)
  if valid_605845 != nil:
    section.add "X-Amz-Content-Sha256", valid_605845
  var valid_605846 = header.getOrDefault("X-Amz-Algorithm")
  valid_605846 = validateParameter(valid_605846, JString, required = false,
                                 default = nil)
  if valid_605846 != nil:
    section.add "X-Amz-Algorithm", valid_605846
  var valid_605847 = header.getOrDefault("X-Amz-Signature")
  valid_605847 = validateParameter(valid_605847, JString, required = false,
                                 default = nil)
  if valid_605847 != nil:
    section.add "X-Amz-Signature", valid_605847
  var valid_605848 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605848 = validateParameter(valid_605848, JString, required = false,
                                 default = nil)
  if valid_605848 != nil:
    section.add "X-Amz-SignedHeaders", valid_605848
  var valid_605849 = header.getOrDefault("X-Amz-Credential")
  valid_605849 = validateParameter(valid_605849, JString, required = false,
                                 default = nil)
  if valid_605849 != nil:
    section.add "X-Amz-Credential", valid_605849
  result.add "header", section
  ## parameters in `formData` object:
  ##   Manual: JBool
  ##         : Indicates whether to apply the snapshot retention period to newly copied manual snapshots instead of automated snapshots.
  ##   RetentionPeriod: JInt (required)
  ##                  : <p>The number of days to retain automated snapshots in the destination AWS Region after they are copied from the source AWS Region.</p> <p>By default, this only changes the retention period of copied automated snapshots. </p> <p>If you decrease the retention period for automated snapshots that are copied to a destination AWS Region, Amazon Redshift deletes any existing automated snapshots that were copied to the destination AWS Region and that fall outside of the new retention period.</p> <p>Constraints: Must be at least 1 and no more than 35 for automated snapshots. </p> <p>If you specify the <code>manual</code> option, only newly copied manual snapshots will have the new retention period. </p> <p>If you specify the value of -1 newly copied manual snapshots are retained indefinitely.</p> <p>Constraints: The number of days must be either -1 or an integer between 1 and 3,653 for manual snapshots.</p>
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of the cluster for which you want to change the retention period for either automated or manual snapshots that are copied to a destination AWS Region.</p> <p>Constraints: Must be the valid name of an existing cluster that has cross-region snapshot copy enabled.</p>
  section = newJObject()
  var valid_605850 = formData.getOrDefault("Manual")
  valid_605850 = validateParameter(valid_605850, JBool, required = false, default = nil)
  if valid_605850 != nil:
    section.add "Manual", valid_605850
  assert formData != nil, "formData argument is necessary due to required `RetentionPeriod` field"
  var valid_605851 = formData.getOrDefault("RetentionPeriod")
  valid_605851 = validateParameter(valid_605851, JInt, required = true, default = nil)
  if valid_605851 != nil:
    section.add "RetentionPeriod", valid_605851
  var valid_605852 = formData.getOrDefault("ClusterIdentifier")
  valid_605852 = validateParameter(valid_605852, JString, required = true,
                                 default = nil)
  if valid_605852 != nil:
    section.add "ClusterIdentifier", valid_605852
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_605853: Call_PostModifySnapshotCopyRetentionPeriod_605838;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Modifies the number of days to retain snapshots in the destination AWS Region after they are copied from the source AWS Region. By default, this operation only changes the retention period of copied automated snapshots. The retention periods for both new and existing copied automated snapshots are updated with the new retention period. You can set the manual option to change only the retention periods of copied manual snapshots. If you set this option, only newly copied manual snapshots have the new retention period. 
  ## 
  let valid = call_605853.validator(path, query, header, formData, body)
  let scheme = call_605853.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605853.url(scheme.get, call_605853.host, call_605853.base,
                         call_605853.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_605853, url, valid)

proc call*(call_605854: Call_PostModifySnapshotCopyRetentionPeriod_605838;
          RetentionPeriod: int; ClusterIdentifier: string; Manual: bool = false;
          Action: string = "ModifySnapshotCopyRetentionPeriod";
          Version: string = "2012-12-01"): Recallable =
  ## postModifySnapshotCopyRetentionPeriod
  ## Modifies the number of days to retain snapshots in the destination AWS Region after they are copied from the source AWS Region. By default, this operation only changes the retention period of copied automated snapshots. The retention periods for both new and existing copied automated snapshots are updated with the new retention period. You can set the manual option to change only the retention periods of copied manual snapshots. If you set this option, only newly copied manual snapshots have the new retention period. 
  ##   Manual: bool
  ##         : Indicates whether to apply the snapshot retention period to newly copied manual snapshots instead of automated snapshots.
  ##   RetentionPeriod: int (required)
  ##                  : <p>The number of days to retain automated snapshots in the destination AWS Region after they are copied from the source AWS Region.</p> <p>By default, this only changes the retention period of copied automated snapshots. </p> <p>If you decrease the retention period for automated snapshots that are copied to a destination AWS Region, Amazon Redshift deletes any existing automated snapshots that were copied to the destination AWS Region and that fall outside of the new retention period.</p> <p>Constraints: Must be at least 1 and no more than 35 for automated snapshots. </p> <p>If you specify the <code>manual</code> option, only newly copied manual snapshots will have the new retention period. </p> <p>If you specify the value of -1 newly copied manual snapshots are retained indefinitely.</p> <p>Constraints: The number of days must be either -1 or an integer between 1 and 3,653 for manual snapshots.</p>
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of the cluster for which you want to change the retention period for either automated or manual snapshots that are copied to a destination AWS Region.</p> <p>Constraints: Must be the valid name of an existing cluster that has cross-region snapshot copy enabled.</p>
  ##   Version: string (required)
  var query_605855 = newJObject()
  var formData_605856 = newJObject()
  add(formData_605856, "Manual", newJBool(Manual))
  add(formData_605856, "RetentionPeriod", newJInt(RetentionPeriod))
  add(query_605855, "Action", newJString(Action))
  add(formData_605856, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_605855, "Version", newJString(Version))
  result = call_605854.call(nil, query_605855, nil, formData_605856, nil)

var postModifySnapshotCopyRetentionPeriod* = Call_PostModifySnapshotCopyRetentionPeriod_605838(
    name: "postModifySnapshotCopyRetentionPeriod", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=ModifySnapshotCopyRetentionPeriod",
    validator: validate_PostModifySnapshotCopyRetentionPeriod_605839, base: "/",
    url: url_PostModifySnapshotCopyRetentionPeriod_605840,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetModifySnapshotCopyRetentionPeriod_605820 = ref object of OpenApiRestCall_602450
proc url_GetModifySnapshotCopyRetentionPeriod_605822(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetModifySnapshotCopyRetentionPeriod_605821(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies the number of days to retain snapshots in the destination AWS Region after they are copied from the source AWS Region. By default, this operation only changes the retention period of copied automated snapshots. The retention periods for both new and existing copied automated snapshots are updated with the new retention period. You can set the manual option to change only the retention periods of copied manual snapshots. If you set this option, only newly copied manual snapshots have the new retention period. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Manual: JBool
  ##         : Indicates whether to apply the snapshot retention period to newly copied manual snapshots instead of automated snapshots.
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of the cluster for which you want to change the retention period for either automated or manual snapshots that are copied to a destination AWS Region.</p> <p>Constraints: Must be the valid name of an existing cluster that has cross-region snapshot copy enabled.</p>
  ##   RetentionPeriod: JInt (required)
  ##                  : <p>The number of days to retain automated snapshots in the destination AWS Region after they are copied from the source AWS Region.</p> <p>By default, this only changes the retention period of copied automated snapshots. </p> <p>If you decrease the retention period for automated snapshots that are copied to a destination AWS Region, Amazon Redshift deletes any existing automated snapshots that were copied to the destination AWS Region and that fall outside of the new retention period.</p> <p>Constraints: Must be at least 1 and no more than 35 for automated snapshots. </p> <p>If you specify the <code>manual</code> option, only newly copied manual snapshots will have the new retention period. </p> <p>If you specify the value of -1 newly copied manual snapshots are retained indefinitely.</p> <p>Constraints: The number of days must be either -1 or an integer between 1 and 3,653 for manual snapshots.</p>
  ##   Version: JString (required)
  section = newJObject()
  var valid_605823 = query.getOrDefault("Manual")
  valid_605823 = validateParameter(valid_605823, JBool, required = false, default = nil)
  if valid_605823 != nil:
    section.add "Manual", valid_605823
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_605824 = query.getOrDefault("Action")
  valid_605824 = validateParameter(valid_605824, JString, required = true, default = newJString(
      "ModifySnapshotCopyRetentionPeriod"))
  if valid_605824 != nil:
    section.add "Action", valid_605824
  var valid_605825 = query.getOrDefault("ClusterIdentifier")
  valid_605825 = validateParameter(valid_605825, JString, required = true,
                                 default = nil)
  if valid_605825 != nil:
    section.add "ClusterIdentifier", valid_605825
  var valid_605826 = query.getOrDefault("RetentionPeriod")
  valid_605826 = validateParameter(valid_605826, JInt, required = true, default = nil)
  if valid_605826 != nil:
    section.add "RetentionPeriod", valid_605826
  var valid_605827 = query.getOrDefault("Version")
  valid_605827 = validateParameter(valid_605827, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_605827 != nil:
    section.add "Version", valid_605827
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_605828 = header.getOrDefault("X-Amz-Date")
  valid_605828 = validateParameter(valid_605828, JString, required = false,
                                 default = nil)
  if valid_605828 != nil:
    section.add "X-Amz-Date", valid_605828
  var valid_605829 = header.getOrDefault("X-Amz-Security-Token")
  valid_605829 = validateParameter(valid_605829, JString, required = false,
                                 default = nil)
  if valid_605829 != nil:
    section.add "X-Amz-Security-Token", valid_605829
  var valid_605830 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605830 = validateParameter(valid_605830, JString, required = false,
                                 default = nil)
  if valid_605830 != nil:
    section.add "X-Amz-Content-Sha256", valid_605830
  var valid_605831 = header.getOrDefault("X-Amz-Algorithm")
  valid_605831 = validateParameter(valid_605831, JString, required = false,
                                 default = nil)
  if valid_605831 != nil:
    section.add "X-Amz-Algorithm", valid_605831
  var valid_605832 = header.getOrDefault("X-Amz-Signature")
  valid_605832 = validateParameter(valid_605832, JString, required = false,
                                 default = nil)
  if valid_605832 != nil:
    section.add "X-Amz-Signature", valid_605832
  var valid_605833 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605833 = validateParameter(valid_605833, JString, required = false,
                                 default = nil)
  if valid_605833 != nil:
    section.add "X-Amz-SignedHeaders", valid_605833
  var valid_605834 = header.getOrDefault("X-Amz-Credential")
  valid_605834 = validateParameter(valid_605834, JString, required = false,
                                 default = nil)
  if valid_605834 != nil:
    section.add "X-Amz-Credential", valid_605834
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_605835: Call_GetModifySnapshotCopyRetentionPeriod_605820;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Modifies the number of days to retain snapshots in the destination AWS Region after they are copied from the source AWS Region. By default, this operation only changes the retention period of copied automated snapshots. The retention periods for both new and existing copied automated snapshots are updated with the new retention period. You can set the manual option to change only the retention periods of copied manual snapshots. If you set this option, only newly copied manual snapshots have the new retention period. 
  ## 
  let valid = call_605835.validator(path, query, header, formData, body)
  let scheme = call_605835.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605835.url(scheme.get, call_605835.host, call_605835.base,
                         call_605835.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_605835, url, valid)

proc call*(call_605836: Call_GetModifySnapshotCopyRetentionPeriod_605820;
          ClusterIdentifier: string; RetentionPeriod: int; Manual: bool = false;
          Action: string = "ModifySnapshotCopyRetentionPeriod";
          Version: string = "2012-12-01"): Recallable =
  ## getModifySnapshotCopyRetentionPeriod
  ## Modifies the number of days to retain snapshots in the destination AWS Region after they are copied from the source AWS Region. By default, this operation only changes the retention period of copied automated snapshots. The retention periods for both new and existing copied automated snapshots are updated with the new retention period. You can set the manual option to change only the retention periods of copied manual snapshots. If you set this option, only newly copied manual snapshots have the new retention period. 
  ##   Manual: bool
  ##         : Indicates whether to apply the snapshot retention period to newly copied manual snapshots instead of automated snapshots.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of the cluster for which you want to change the retention period for either automated or manual snapshots that are copied to a destination AWS Region.</p> <p>Constraints: Must be the valid name of an existing cluster that has cross-region snapshot copy enabled.</p>
  ##   RetentionPeriod: int (required)
  ##                  : <p>The number of days to retain automated snapshots in the destination AWS Region after they are copied from the source AWS Region.</p> <p>By default, this only changes the retention period of copied automated snapshots. </p> <p>If you decrease the retention period for automated snapshots that are copied to a destination AWS Region, Amazon Redshift deletes any existing automated snapshots that were copied to the destination AWS Region and that fall outside of the new retention period.</p> <p>Constraints: Must be at least 1 and no more than 35 for automated snapshots. </p> <p>If you specify the <code>manual</code> option, only newly copied manual snapshots will have the new retention period. </p> <p>If you specify the value of -1 newly copied manual snapshots are retained indefinitely.</p> <p>Constraints: The number of days must be either -1 or an integer between 1 and 3,653 for manual snapshots.</p>
  ##   Version: string (required)
  var query_605837 = newJObject()
  add(query_605837, "Manual", newJBool(Manual))
  add(query_605837, "Action", newJString(Action))
  add(query_605837, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_605837, "RetentionPeriod", newJInt(RetentionPeriod))
  add(query_605837, "Version", newJString(Version))
  result = call_605836.call(nil, query_605837, nil, nil, nil)

var getModifySnapshotCopyRetentionPeriod* = Call_GetModifySnapshotCopyRetentionPeriod_605820(
    name: "getModifySnapshotCopyRetentionPeriod", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=ModifySnapshotCopyRetentionPeriod",
    validator: validate_GetModifySnapshotCopyRetentionPeriod_605821, base: "/",
    url: url_GetModifySnapshotCopyRetentionPeriod_605822,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostModifySnapshotSchedule_605874 = ref object of OpenApiRestCall_602450
proc url_PostModifySnapshotSchedule_605876(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostModifySnapshotSchedule_605875(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies a snapshot schedule. Any schedule associated with a cluster is modified asynchronously.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_605877 = query.getOrDefault("Action")
  valid_605877 = validateParameter(valid_605877, JString, required = true,
                                 default = newJString("ModifySnapshotSchedule"))
  if valid_605877 != nil:
    section.add "Action", valid_605877
  var valid_605878 = query.getOrDefault("Version")
  valid_605878 = validateParameter(valid_605878, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_605878 != nil:
    section.add "Version", valid_605878
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_605879 = header.getOrDefault("X-Amz-Date")
  valid_605879 = validateParameter(valid_605879, JString, required = false,
                                 default = nil)
  if valid_605879 != nil:
    section.add "X-Amz-Date", valid_605879
  var valid_605880 = header.getOrDefault("X-Amz-Security-Token")
  valid_605880 = validateParameter(valid_605880, JString, required = false,
                                 default = nil)
  if valid_605880 != nil:
    section.add "X-Amz-Security-Token", valid_605880
  var valid_605881 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605881 = validateParameter(valid_605881, JString, required = false,
                                 default = nil)
  if valid_605881 != nil:
    section.add "X-Amz-Content-Sha256", valid_605881
  var valid_605882 = header.getOrDefault("X-Amz-Algorithm")
  valid_605882 = validateParameter(valid_605882, JString, required = false,
                                 default = nil)
  if valid_605882 != nil:
    section.add "X-Amz-Algorithm", valid_605882
  var valid_605883 = header.getOrDefault("X-Amz-Signature")
  valid_605883 = validateParameter(valid_605883, JString, required = false,
                                 default = nil)
  if valid_605883 != nil:
    section.add "X-Amz-Signature", valid_605883
  var valid_605884 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605884 = validateParameter(valid_605884, JString, required = false,
                                 default = nil)
  if valid_605884 != nil:
    section.add "X-Amz-SignedHeaders", valid_605884
  var valid_605885 = header.getOrDefault("X-Amz-Credential")
  valid_605885 = validateParameter(valid_605885, JString, required = false,
                                 default = nil)
  if valid_605885 != nil:
    section.add "X-Amz-Credential", valid_605885
  result.add "header", section
  ## parameters in `formData` object:
  ##   ScheduleDefinitions: JArray (required)
  ##                      : An updated list of schedule definitions. A schedule definition is made up of schedule expressions, for example, "cron(30 12 *)" or "rate(12 hours)".
  ##   ScheduleIdentifier: JString (required)
  ##                     : A unique alphanumeric identifier of the schedule to modify.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ScheduleDefinitions` field"
  var valid_605886 = formData.getOrDefault("ScheduleDefinitions")
  valid_605886 = validateParameter(valid_605886, JArray, required = true, default = nil)
  if valid_605886 != nil:
    section.add "ScheduleDefinitions", valid_605886
  var valid_605887 = formData.getOrDefault("ScheduleIdentifier")
  valid_605887 = validateParameter(valid_605887, JString, required = true,
                                 default = nil)
  if valid_605887 != nil:
    section.add "ScheduleIdentifier", valid_605887
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_605888: Call_PostModifySnapshotSchedule_605874; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Modifies a snapshot schedule. Any schedule associated with a cluster is modified asynchronously.
  ## 
  let valid = call_605888.validator(path, query, header, formData, body)
  let scheme = call_605888.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605888.url(scheme.get, call_605888.host, call_605888.base,
                         call_605888.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_605888, url, valid)

proc call*(call_605889: Call_PostModifySnapshotSchedule_605874;
          ScheduleDefinitions: JsonNode; ScheduleIdentifier: string;
          Action: string = "ModifySnapshotSchedule"; Version: string = "2012-12-01"): Recallable =
  ## postModifySnapshotSchedule
  ## Modifies a snapshot schedule. Any schedule associated with a cluster is modified asynchronously.
  ##   ScheduleDefinitions: JArray (required)
  ##                      : An updated list of schedule definitions. A schedule definition is made up of schedule expressions, for example, "cron(30 12 *)" or "rate(12 hours)".
  ##   Action: string (required)
  ##   ScheduleIdentifier: string (required)
  ##                     : A unique alphanumeric identifier of the schedule to modify.
  ##   Version: string (required)
  var query_605890 = newJObject()
  var formData_605891 = newJObject()
  if ScheduleDefinitions != nil:
    formData_605891.add "ScheduleDefinitions", ScheduleDefinitions
  add(query_605890, "Action", newJString(Action))
  add(formData_605891, "ScheduleIdentifier", newJString(ScheduleIdentifier))
  add(query_605890, "Version", newJString(Version))
  result = call_605889.call(nil, query_605890, nil, formData_605891, nil)

var postModifySnapshotSchedule* = Call_PostModifySnapshotSchedule_605874(
    name: "postModifySnapshotSchedule", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=ModifySnapshotSchedule",
    validator: validate_PostModifySnapshotSchedule_605875, base: "/",
    url: url_PostModifySnapshotSchedule_605876,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetModifySnapshotSchedule_605857 = ref object of OpenApiRestCall_602450
proc url_GetModifySnapshotSchedule_605859(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetModifySnapshotSchedule_605858(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies a snapshot schedule. Any schedule associated with a cluster is modified asynchronously.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ScheduleDefinitions: JArray (required)
  ##                      : An updated list of schedule definitions. A schedule definition is made up of schedule expressions, for example, "cron(30 12 *)" or "rate(12 hours)".
  ##   Action: JString (required)
  ##   ScheduleIdentifier: JString (required)
  ##                     : A unique alphanumeric identifier of the schedule to modify.
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `ScheduleDefinitions` field"
  var valid_605860 = query.getOrDefault("ScheduleDefinitions")
  valid_605860 = validateParameter(valid_605860, JArray, required = true, default = nil)
  if valid_605860 != nil:
    section.add "ScheduleDefinitions", valid_605860
  var valid_605861 = query.getOrDefault("Action")
  valid_605861 = validateParameter(valid_605861, JString, required = true,
                                 default = newJString("ModifySnapshotSchedule"))
  if valid_605861 != nil:
    section.add "Action", valid_605861
  var valid_605862 = query.getOrDefault("ScheduleIdentifier")
  valid_605862 = validateParameter(valid_605862, JString, required = true,
                                 default = nil)
  if valid_605862 != nil:
    section.add "ScheduleIdentifier", valid_605862
  var valid_605863 = query.getOrDefault("Version")
  valid_605863 = validateParameter(valid_605863, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_605863 != nil:
    section.add "Version", valid_605863
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_605864 = header.getOrDefault("X-Amz-Date")
  valid_605864 = validateParameter(valid_605864, JString, required = false,
                                 default = nil)
  if valid_605864 != nil:
    section.add "X-Amz-Date", valid_605864
  var valid_605865 = header.getOrDefault("X-Amz-Security-Token")
  valid_605865 = validateParameter(valid_605865, JString, required = false,
                                 default = nil)
  if valid_605865 != nil:
    section.add "X-Amz-Security-Token", valid_605865
  var valid_605866 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605866 = validateParameter(valid_605866, JString, required = false,
                                 default = nil)
  if valid_605866 != nil:
    section.add "X-Amz-Content-Sha256", valid_605866
  var valid_605867 = header.getOrDefault("X-Amz-Algorithm")
  valid_605867 = validateParameter(valid_605867, JString, required = false,
                                 default = nil)
  if valid_605867 != nil:
    section.add "X-Amz-Algorithm", valid_605867
  var valid_605868 = header.getOrDefault("X-Amz-Signature")
  valid_605868 = validateParameter(valid_605868, JString, required = false,
                                 default = nil)
  if valid_605868 != nil:
    section.add "X-Amz-Signature", valid_605868
  var valid_605869 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605869 = validateParameter(valid_605869, JString, required = false,
                                 default = nil)
  if valid_605869 != nil:
    section.add "X-Amz-SignedHeaders", valid_605869
  var valid_605870 = header.getOrDefault("X-Amz-Credential")
  valid_605870 = validateParameter(valid_605870, JString, required = false,
                                 default = nil)
  if valid_605870 != nil:
    section.add "X-Amz-Credential", valid_605870
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_605871: Call_GetModifySnapshotSchedule_605857; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Modifies a snapshot schedule. Any schedule associated with a cluster is modified asynchronously.
  ## 
  let valid = call_605871.validator(path, query, header, formData, body)
  let scheme = call_605871.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605871.url(scheme.get, call_605871.host, call_605871.base,
                         call_605871.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_605871, url, valid)

proc call*(call_605872: Call_GetModifySnapshotSchedule_605857;
          ScheduleDefinitions: JsonNode; ScheduleIdentifier: string;
          Action: string = "ModifySnapshotSchedule"; Version: string = "2012-12-01"): Recallable =
  ## getModifySnapshotSchedule
  ## Modifies a snapshot schedule. Any schedule associated with a cluster is modified asynchronously.
  ##   ScheduleDefinitions: JArray (required)
  ##                      : An updated list of schedule definitions. A schedule definition is made up of schedule expressions, for example, "cron(30 12 *)" or "rate(12 hours)".
  ##   Action: string (required)
  ##   ScheduleIdentifier: string (required)
  ##                     : A unique alphanumeric identifier of the schedule to modify.
  ##   Version: string (required)
  var query_605873 = newJObject()
  if ScheduleDefinitions != nil:
    query_605873.add "ScheduleDefinitions", ScheduleDefinitions
  add(query_605873, "Action", newJString(Action))
  add(query_605873, "ScheduleIdentifier", newJString(ScheduleIdentifier))
  add(query_605873, "Version", newJString(Version))
  result = call_605872.call(nil, query_605873, nil, nil, nil)

var getModifySnapshotSchedule* = Call_GetModifySnapshotSchedule_605857(
    name: "getModifySnapshotSchedule", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=ModifySnapshotSchedule",
    validator: validate_GetModifySnapshotSchedule_605858, base: "/",
    url: url_GetModifySnapshotSchedule_605859,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostPurchaseReservedNodeOffering_605909 = ref object of OpenApiRestCall_602450
proc url_PostPurchaseReservedNodeOffering_605911(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostPurchaseReservedNodeOffering_605910(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Allows you to purchase reserved nodes. Amazon Redshift offers a predefined set of reserved node offerings. You can purchase one or more of the offerings. You can call the <a>DescribeReservedNodeOfferings</a> API to obtain the available reserved node offerings. You can call this API by providing a specific reserved node offering and the number of nodes you want to reserve. </p> <p> For more information about reserved node offerings, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_605912 = query.getOrDefault("Action")
  valid_605912 = validateParameter(valid_605912, JString, required = true, default = newJString(
      "PurchaseReservedNodeOffering"))
  if valid_605912 != nil:
    section.add "Action", valid_605912
  var valid_605913 = query.getOrDefault("Version")
  valid_605913 = validateParameter(valid_605913, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_605913 != nil:
    section.add "Version", valid_605913
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_605914 = header.getOrDefault("X-Amz-Date")
  valid_605914 = validateParameter(valid_605914, JString, required = false,
                                 default = nil)
  if valid_605914 != nil:
    section.add "X-Amz-Date", valid_605914
  var valid_605915 = header.getOrDefault("X-Amz-Security-Token")
  valid_605915 = validateParameter(valid_605915, JString, required = false,
                                 default = nil)
  if valid_605915 != nil:
    section.add "X-Amz-Security-Token", valid_605915
  var valid_605916 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605916 = validateParameter(valid_605916, JString, required = false,
                                 default = nil)
  if valid_605916 != nil:
    section.add "X-Amz-Content-Sha256", valid_605916
  var valid_605917 = header.getOrDefault("X-Amz-Algorithm")
  valid_605917 = validateParameter(valid_605917, JString, required = false,
                                 default = nil)
  if valid_605917 != nil:
    section.add "X-Amz-Algorithm", valid_605917
  var valid_605918 = header.getOrDefault("X-Amz-Signature")
  valid_605918 = validateParameter(valid_605918, JString, required = false,
                                 default = nil)
  if valid_605918 != nil:
    section.add "X-Amz-Signature", valid_605918
  var valid_605919 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605919 = validateParameter(valid_605919, JString, required = false,
                                 default = nil)
  if valid_605919 != nil:
    section.add "X-Amz-SignedHeaders", valid_605919
  var valid_605920 = header.getOrDefault("X-Amz-Credential")
  valid_605920 = validateParameter(valid_605920, JString, required = false,
                                 default = nil)
  if valid_605920 != nil:
    section.add "X-Amz-Credential", valid_605920
  result.add "header", section
  ## parameters in `formData` object:
  ##   ReservedNodeOfferingId: JString (required)
  ##                         : The unique identifier of the reserved node offering you want to purchase.
  ##   NodeCount: JInt
  ##            : <p>The number of reserved nodes that you want to purchase.</p> <p>Default: <code>1</code> </p>
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ReservedNodeOfferingId` field"
  var valid_605921 = formData.getOrDefault("ReservedNodeOfferingId")
  valid_605921 = validateParameter(valid_605921, JString, required = true,
                                 default = nil)
  if valid_605921 != nil:
    section.add "ReservedNodeOfferingId", valid_605921
  var valid_605922 = formData.getOrDefault("NodeCount")
  valid_605922 = validateParameter(valid_605922, JInt, required = false, default = nil)
  if valid_605922 != nil:
    section.add "NodeCount", valid_605922
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_605923: Call_PostPurchaseReservedNodeOffering_605909;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Allows you to purchase reserved nodes. Amazon Redshift offers a predefined set of reserved node offerings. You can purchase one or more of the offerings. You can call the <a>DescribeReservedNodeOfferings</a> API to obtain the available reserved node offerings. You can call this API by providing a specific reserved node offering and the number of nodes you want to reserve. </p> <p> For more information about reserved node offerings, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_605923.validator(path, query, header, formData, body)
  let scheme = call_605923.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605923.url(scheme.get, call_605923.host, call_605923.base,
                         call_605923.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_605923, url, valid)

proc call*(call_605924: Call_PostPurchaseReservedNodeOffering_605909;
          ReservedNodeOfferingId: string; NodeCount: int = 0;
          Action: string = "PurchaseReservedNodeOffering";
          Version: string = "2012-12-01"): Recallable =
  ## postPurchaseReservedNodeOffering
  ## <p>Allows you to purchase reserved nodes. Amazon Redshift offers a predefined set of reserved node offerings. You can purchase one or more of the offerings. You can call the <a>DescribeReservedNodeOfferings</a> API to obtain the available reserved node offerings. You can call this API by providing a specific reserved node offering and the number of nodes you want to reserve. </p> <p> For more information about reserved node offerings, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   ReservedNodeOfferingId: string (required)
  ##                         : The unique identifier of the reserved node offering you want to purchase.
  ##   NodeCount: int
  ##            : <p>The number of reserved nodes that you want to purchase.</p> <p>Default: <code>1</code> </p>
  ##   Action: string (required)
  ##   Version: string (required)
  var query_605925 = newJObject()
  var formData_605926 = newJObject()
  add(formData_605926, "ReservedNodeOfferingId",
      newJString(ReservedNodeOfferingId))
  add(formData_605926, "NodeCount", newJInt(NodeCount))
  add(query_605925, "Action", newJString(Action))
  add(query_605925, "Version", newJString(Version))
  result = call_605924.call(nil, query_605925, nil, formData_605926, nil)

var postPurchaseReservedNodeOffering* = Call_PostPurchaseReservedNodeOffering_605909(
    name: "postPurchaseReservedNodeOffering", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=PurchaseReservedNodeOffering",
    validator: validate_PostPurchaseReservedNodeOffering_605910, base: "/",
    url: url_PostPurchaseReservedNodeOffering_605911,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetPurchaseReservedNodeOffering_605892 = ref object of OpenApiRestCall_602450
proc url_GetPurchaseReservedNodeOffering_605894(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetPurchaseReservedNodeOffering_605893(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Allows you to purchase reserved nodes. Amazon Redshift offers a predefined set of reserved node offerings. You can purchase one or more of the offerings. You can call the <a>DescribeReservedNodeOfferings</a> API to obtain the available reserved node offerings. You can call this API by providing a specific reserved node offering and the number of nodes you want to reserve. </p> <p> For more information about reserved node offerings, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ReservedNodeOfferingId: JString (required)
  ##                         : The unique identifier of the reserved node offering you want to purchase.
  ##   Action: JString (required)
  ##   NodeCount: JInt
  ##            : <p>The number of reserved nodes that you want to purchase.</p> <p>Default: <code>1</code> </p>
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `ReservedNodeOfferingId` field"
  var valid_605895 = query.getOrDefault("ReservedNodeOfferingId")
  valid_605895 = validateParameter(valid_605895, JString, required = true,
                                 default = nil)
  if valid_605895 != nil:
    section.add "ReservedNodeOfferingId", valid_605895
  var valid_605896 = query.getOrDefault("Action")
  valid_605896 = validateParameter(valid_605896, JString, required = true, default = newJString(
      "PurchaseReservedNodeOffering"))
  if valid_605896 != nil:
    section.add "Action", valid_605896
  var valid_605897 = query.getOrDefault("NodeCount")
  valid_605897 = validateParameter(valid_605897, JInt, required = false, default = nil)
  if valid_605897 != nil:
    section.add "NodeCount", valid_605897
  var valid_605898 = query.getOrDefault("Version")
  valid_605898 = validateParameter(valid_605898, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_605898 != nil:
    section.add "Version", valid_605898
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_605899 = header.getOrDefault("X-Amz-Date")
  valid_605899 = validateParameter(valid_605899, JString, required = false,
                                 default = nil)
  if valid_605899 != nil:
    section.add "X-Amz-Date", valid_605899
  var valid_605900 = header.getOrDefault("X-Amz-Security-Token")
  valid_605900 = validateParameter(valid_605900, JString, required = false,
                                 default = nil)
  if valid_605900 != nil:
    section.add "X-Amz-Security-Token", valid_605900
  var valid_605901 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605901 = validateParameter(valid_605901, JString, required = false,
                                 default = nil)
  if valid_605901 != nil:
    section.add "X-Amz-Content-Sha256", valid_605901
  var valid_605902 = header.getOrDefault("X-Amz-Algorithm")
  valid_605902 = validateParameter(valid_605902, JString, required = false,
                                 default = nil)
  if valid_605902 != nil:
    section.add "X-Amz-Algorithm", valid_605902
  var valid_605903 = header.getOrDefault("X-Amz-Signature")
  valid_605903 = validateParameter(valid_605903, JString, required = false,
                                 default = nil)
  if valid_605903 != nil:
    section.add "X-Amz-Signature", valid_605903
  var valid_605904 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605904 = validateParameter(valid_605904, JString, required = false,
                                 default = nil)
  if valid_605904 != nil:
    section.add "X-Amz-SignedHeaders", valid_605904
  var valid_605905 = header.getOrDefault("X-Amz-Credential")
  valid_605905 = validateParameter(valid_605905, JString, required = false,
                                 default = nil)
  if valid_605905 != nil:
    section.add "X-Amz-Credential", valid_605905
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_605906: Call_GetPurchaseReservedNodeOffering_605892;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Allows you to purchase reserved nodes. Amazon Redshift offers a predefined set of reserved node offerings. You can purchase one or more of the offerings. You can call the <a>DescribeReservedNodeOfferings</a> API to obtain the available reserved node offerings. You can call this API by providing a specific reserved node offering and the number of nodes you want to reserve. </p> <p> For more information about reserved node offerings, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_605906.validator(path, query, header, formData, body)
  let scheme = call_605906.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605906.url(scheme.get, call_605906.host, call_605906.base,
                         call_605906.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_605906, url, valid)

proc call*(call_605907: Call_GetPurchaseReservedNodeOffering_605892;
          ReservedNodeOfferingId: string;
          Action: string = "PurchaseReservedNodeOffering"; NodeCount: int = 0;
          Version: string = "2012-12-01"): Recallable =
  ## getPurchaseReservedNodeOffering
  ## <p>Allows you to purchase reserved nodes. Amazon Redshift offers a predefined set of reserved node offerings. You can purchase one or more of the offerings. You can call the <a>DescribeReservedNodeOfferings</a> API to obtain the available reserved node offerings. You can call this API by providing a specific reserved node offering and the number of nodes you want to reserve. </p> <p> For more information about reserved node offerings, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   ReservedNodeOfferingId: string (required)
  ##                         : The unique identifier of the reserved node offering you want to purchase.
  ##   Action: string (required)
  ##   NodeCount: int
  ##            : <p>The number of reserved nodes that you want to purchase.</p> <p>Default: <code>1</code> </p>
  ##   Version: string (required)
  var query_605908 = newJObject()
  add(query_605908, "ReservedNodeOfferingId", newJString(ReservedNodeOfferingId))
  add(query_605908, "Action", newJString(Action))
  add(query_605908, "NodeCount", newJInt(NodeCount))
  add(query_605908, "Version", newJString(Version))
  result = call_605907.call(nil, query_605908, nil, nil, nil)

var getPurchaseReservedNodeOffering* = Call_GetPurchaseReservedNodeOffering_605892(
    name: "getPurchaseReservedNodeOffering", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=PurchaseReservedNodeOffering",
    validator: validate_GetPurchaseReservedNodeOffering_605893, base: "/",
    url: url_GetPurchaseReservedNodeOffering_605894,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostRebootCluster_605943 = ref object of OpenApiRestCall_602450
proc url_PostRebootCluster_605945(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostRebootCluster_605944(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## Reboots a cluster. This action is taken as soon as possible. It results in a momentary outage to the cluster, during which the cluster status is set to <code>rebooting</code>. A cluster event is created when the reboot is completed. Any pending cluster modifications (see <a>ModifyCluster</a>) are applied at this reboot. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_605946 = query.getOrDefault("Action")
  valid_605946 = validateParameter(valid_605946, JString, required = true,
                                 default = newJString("RebootCluster"))
  if valid_605946 != nil:
    section.add "Action", valid_605946
  var valid_605947 = query.getOrDefault("Version")
  valid_605947 = validateParameter(valid_605947, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_605947 != nil:
    section.add "Version", valid_605947
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_605948 = header.getOrDefault("X-Amz-Date")
  valid_605948 = validateParameter(valid_605948, JString, required = false,
                                 default = nil)
  if valid_605948 != nil:
    section.add "X-Amz-Date", valid_605948
  var valid_605949 = header.getOrDefault("X-Amz-Security-Token")
  valid_605949 = validateParameter(valid_605949, JString, required = false,
                                 default = nil)
  if valid_605949 != nil:
    section.add "X-Amz-Security-Token", valid_605949
  var valid_605950 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605950 = validateParameter(valid_605950, JString, required = false,
                                 default = nil)
  if valid_605950 != nil:
    section.add "X-Amz-Content-Sha256", valid_605950
  var valid_605951 = header.getOrDefault("X-Amz-Algorithm")
  valid_605951 = validateParameter(valid_605951, JString, required = false,
                                 default = nil)
  if valid_605951 != nil:
    section.add "X-Amz-Algorithm", valid_605951
  var valid_605952 = header.getOrDefault("X-Amz-Signature")
  valid_605952 = validateParameter(valid_605952, JString, required = false,
                                 default = nil)
  if valid_605952 != nil:
    section.add "X-Amz-Signature", valid_605952
  var valid_605953 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605953 = validateParameter(valid_605953, JString, required = false,
                                 default = nil)
  if valid_605953 != nil:
    section.add "X-Amz-SignedHeaders", valid_605953
  var valid_605954 = header.getOrDefault("X-Amz-Credential")
  valid_605954 = validateParameter(valid_605954, JString, required = false,
                                 default = nil)
  if valid_605954 != nil:
    section.add "X-Amz-Credential", valid_605954
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : The cluster identifier.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_605955 = formData.getOrDefault("ClusterIdentifier")
  valid_605955 = validateParameter(valid_605955, JString, required = true,
                                 default = nil)
  if valid_605955 != nil:
    section.add "ClusterIdentifier", valid_605955
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_605956: Call_PostRebootCluster_605943; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Reboots a cluster. This action is taken as soon as possible. It results in a momentary outage to the cluster, during which the cluster status is set to <code>rebooting</code>. A cluster event is created when the reboot is completed. Any pending cluster modifications (see <a>ModifyCluster</a>) are applied at this reboot. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. 
  ## 
  let valid = call_605956.validator(path, query, header, formData, body)
  let scheme = call_605956.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605956.url(scheme.get, call_605956.host, call_605956.base,
                         call_605956.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_605956, url, valid)

proc call*(call_605957: Call_PostRebootCluster_605943; ClusterIdentifier: string;
          Action: string = "RebootCluster"; Version: string = "2012-12-01"): Recallable =
  ## postRebootCluster
  ## Reboots a cluster. This action is taken as soon as possible. It results in a momentary outage to the cluster, during which the cluster status is set to <code>rebooting</code>. A cluster event is created when the reboot is completed. Any pending cluster modifications (see <a>ModifyCluster</a>) are applied at this reboot. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. 
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : The cluster identifier.
  ##   Version: string (required)
  var query_605958 = newJObject()
  var formData_605959 = newJObject()
  add(query_605958, "Action", newJString(Action))
  add(formData_605959, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_605958, "Version", newJString(Version))
  result = call_605957.call(nil, query_605958, nil, formData_605959, nil)

var postRebootCluster* = Call_PostRebootCluster_605943(name: "postRebootCluster",
    meth: HttpMethod.HttpPost, host: "redshift.amazonaws.com",
    route: "/#Action=RebootCluster", validator: validate_PostRebootCluster_605944,
    base: "/", url: url_PostRebootCluster_605945,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetRebootCluster_605927 = ref object of OpenApiRestCall_602450
proc url_GetRebootCluster_605929(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetRebootCluster_605928(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Reboots a cluster. This action is taken as soon as possible. It results in a momentary outage to the cluster, during which the cluster status is set to <code>rebooting</code>. A cluster event is created when the reboot is completed. Any pending cluster modifications (see <a>ModifyCluster</a>) are applied at this reboot. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : The cluster identifier.
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_605930 = query.getOrDefault("Action")
  valid_605930 = validateParameter(valid_605930, JString, required = true,
                                 default = newJString("RebootCluster"))
  if valid_605930 != nil:
    section.add "Action", valid_605930
  var valid_605931 = query.getOrDefault("ClusterIdentifier")
  valid_605931 = validateParameter(valid_605931, JString, required = true,
                                 default = nil)
  if valid_605931 != nil:
    section.add "ClusterIdentifier", valid_605931
  var valid_605932 = query.getOrDefault("Version")
  valid_605932 = validateParameter(valid_605932, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_605932 != nil:
    section.add "Version", valid_605932
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_605933 = header.getOrDefault("X-Amz-Date")
  valid_605933 = validateParameter(valid_605933, JString, required = false,
                                 default = nil)
  if valid_605933 != nil:
    section.add "X-Amz-Date", valid_605933
  var valid_605934 = header.getOrDefault("X-Amz-Security-Token")
  valid_605934 = validateParameter(valid_605934, JString, required = false,
                                 default = nil)
  if valid_605934 != nil:
    section.add "X-Amz-Security-Token", valid_605934
  var valid_605935 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605935 = validateParameter(valid_605935, JString, required = false,
                                 default = nil)
  if valid_605935 != nil:
    section.add "X-Amz-Content-Sha256", valid_605935
  var valid_605936 = header.getOrDefault("X-Amz-Algorithm")
  valid_605936 = validateParameter(valid_605936, JString, required = false,
                                 default = nil)
  if valid_605936 != nil:
    section.add "X-Amz-Algorithm", valid_605936
  var valid_605937 = header.getOrDefault("X-Amz-Signature")
  valid_605937 = validateParameter(valid_605937, JString, required = false,
                                 default = nil)
  if valid_605937 != nil:
    section.add "X-Amz-Signature", valid_605937
  var valid_605938 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605938 = validateParameter(valid_605938, JString, required = false,
                                 default = nil)
  if valid_605938 != nil:
    section.add "X-Amz-SignedHeaders", valid_605938
  var valid_605939 = header.getOrDefault("X-Amz-Credential")
  valid_605939 = validateParameter(valid_605939, JString, required = false,
                                 default = nil)
  if valid_605939 != nil:
    section.add "X-Amz-Credential", valid_605939
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_605940: Call_GetRebootCluster_605927; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Reboots a cluster. This action is taken as soon as possible. It results in a momentary outage to the cluster, during which the cluster status is set to <code>rebooting</code>. A cluster event is created when the reboot is completed. Any pending cluster modifications (see <a>ModifyCluster</a>) are applied at this reboot. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. 
  ## 
  let valid = call_605940.validator(path, query, header, formData, body)
  let scheme = call_605940.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605940.url(scheme.get, call_605940.host, call_605940.base,
                         call_605940.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_605940, url, valid)

proc call*(call_605941: Call_GetRebootCluster_605927; ClusterIdentifier: string;
          Action: string = "RebootCluster"; Version: string = "2012-12-01"): Recallable =
  ## getRebootCluster
  ## Reboots a cluster. This action is taken as soon as possible. It results in a momentary outage to the cluster, during which the cluster status is set to <code>rebooting</code>. A cluster event is created when the reboot is completed. Any pending cluster modifications (see <a>ModifyCluster</a>) are applied at this reboot. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. 
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : The cluster identifier.
  ##   Version: string (required)
  var query_605942 = newJObject()
  add(query_605942, "Action", newJString(Action))
  add(query_605942, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_605942, "Version", newJString(Version))
  result = call_605941.call(nil, query_605942, nil, nil, nil)

var getRebootCluster* = Call_GetRebootCluster_605927(name: "getRebootCluster",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=RebootCluster", validator: validate_GetRebootCluster_605928,
    base: "/", url: url_GetRebootCluster_605929,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostResetClusterParameterGroup_605978 = ref object of OpenApiRestCall_602450
proc url_PostResetClusterParameterGroup_605980(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostResetClusterParameterGroup_605979(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Sets one or more parameters of the specified parameter group to their default values and sets the source values of the parameters to "engine-default". To reset the entire parameter group specify the <i>ResetAllParameters</i> parameter. For parameter changes to take effect you must reboot any associated clusters. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_605981 = query.getOrDefault("Action")
  valid_605981 = validateParameter(valid_605981, JString, required = true, default = newJString(
      "ResetClusterParameterGroup"))
  if valid_605981 != nil:
    section.add "Action", valid_605981
  var valid_605982 = query.getOrDefault("Version")
  valid_605982 = validateParameter(valid_605982, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_605982 != nil:
    section.add "Version", valid_605982
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_605983 = header.getOrDefault("X-Amz-Date")
  valid_605983 = validateParameter(valid_605983, JString, required = false,
                                 default = nil)
  if valid_605983 != nil:
    section.add "X-Amz-Date", valid_605983
  var valid_605984 = header.getOrDefault("X-Amz-Security-Token")
  valid_605984 = validateParameter(valid_605984, JString, required = false,
                                 default = nil)
  if valid_605984 != nil:
    section.add "X-Amz-Security-Token", valid_605984
  var valid_605985 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605985 = validateParameter(valid_605985, JString, required = false,
                                 default = nil)
  if valid_605985 != nil:
    section.add "X-Amz-Content-Sha256", valid_605985
  var valid_605986 = header.getOrDefault("X-Amz-Algorithm")
  valid_605986 = validateParameter(valid_605986, JString, required = false,
                                 default = nil)
  if valid_605986 != nil:
    section.add "X-Amz-Algorithm", valid_605986
  var valid_605987 = header.getOrDefault("X-Amz-Signature")
  valid_605987 = validateParameter(valid_605987, JString, required = false,
                                 default = nil)
  if valid_605987 != nil:
    section.add "X-Amz-Signature", valid_605987
  var valid_605988 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605988 = validateParameter(valid_605988, JString, required = false,
                                 default = nil)
  if valid_605988 != nil:
    section.add "X-Amz-SignedHeaders", valid_605988
  var valid_605989 = header.getOrDefault("X-Amz-Credential")
  valid_605989 = validateParameter(valid_605989, JString, required = false,
                                 default = nil)
  if valid_605989 != nil:
    section.add "X-Amz-Credential", valid_605989
  result.add "header", section
  ## parameters in `formData` object:
  ##   ParameterGroupName: JString (required)
  ##                     : The name of the cluster parameter group to be reset.
  ##   Parameters: JArray
  ##             : <p>An array of names of parameters to be reset. If <i>ResetAllParameters</i> option is not used, then at least one parameter name must be supplied. </p> <p>Constraints: A maximum of 20 parameters can be reset in a single request.</p>
  ##   ResetAllParameters: JBool
  ##                     : <p>If <code>true</code>, all parameters in the specified parameter group will be reset to their default values. </p> <p>Default: <code>true</code> </p>
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ParameterGroupName` field"
  var valid_605990 = formData.getOrDefault("ParameterGroupName")
  valid_605990 = validateParameter(valid_605990, JString, required = true,
                                 default = nil)
  if valid_605990 != nil:
    section.add "ParameterGroupName", valid_605990
  var valid_605991 = formData.getOrDefault("Parameters")
  valid_605991 = validateParameter(valid_605991, JArray, required = false,
                                 default = nil)
  if valid_605991 != nil:
    section.add "Parameters", valid_605991
  var valid_605992 = formData.getOrDefault("ResetAllParameters")
  valid_605992 = validateParameter(valid_605992, JBool, required = false, default = nil)
  if valid_605992 != nil:
    section.add "ResetAllParameters", valid_605992
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_605993: Call_PostResetClusterParameterGroup_605978; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Sets one or more parameters of the specified parameter group to their default values and sets the source values of the parameters to "engine-default". To reset the entire parameter group specify the <i>ResetAllParameters</i> parameter. For parameter changes to take effect you must reboot any associated clusters. 
  ## 
  let valid = call_605993.validator(path, query, header, formData, body)
  let scheme = call_605993.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605993.url(scheme.get, call_605993.host, call_605993.base,
                         call_605993.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_605993, url, valid)

proc call*(call_605994: Call_PostResetClusterParameterGroup_605978;
          ParameterGroupName: string; Parameters: JsonNode = nil;
          Action: string = "ResetClusterParameterGroup";
          ResetAllParameters: bool = false; Version: string = "2012-12-01"): Recallable =
  ## postResetClusterParameterGroup
  ## Sets one or more parameters of the specified parameter group to their default values and sets the source values of the parameters to "engine-default". To reset the entire parameter group specify the <i>ResetAllParameters</i> parameter. For parameter changes to take effect you must reboot any associated clusters. 
  ##   ParameterGroupName: string (required)
  ##                     : The name of the cluster parameter group to be reset.
  ##   Parameters: JArray
  ##             : <p>An array of names of parameters to be reset. If <i>ResetAllParameters</i> option is not used, then at least one parameter name must be supplied. </p> <p>Constraints: A maximum of 20 parameters can be reset in a single request.</p>
  ##   Action: string (required)
  ##   ResetAllParameters: bool
  ##                     : <p>If <code>true</code>, all parameters in the specified parameter group will be reset to their default values. </p> <p>Default: <code>true</code> </p>
  ##   Version: string (required)
  var query_605995 = newJObject()
  var formData_605996 = newJObject()
  add(formData_605996, "ParameterGroupName", newJString(ParameterGroupName))
  if Parameters != nil:
    formData_605996.add "Parameters", Parameters
  add(query_605995, "Action", newJString(Action))
  add(formData_605996, "ResetAllParameters", newJBool(ResetAllParameters))
  add(query_605995, "Version", newJString(Version))
  result = call_605994.call(nil, query_605995, nil, formData_605996, nil)

var postResetClusterParameterGroup* = Call_PostResetClusterParameterGroup_605978(
    name: "postResetClusterParameterGroup", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=ResetClusterParameterGroup",
    validator: validate_PostResetClusterParameterGroup_605979, base: "/",
    url: url_PostResetClusterParameterGroup_605980,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetResetClusterParameterGroup_605960 = ref object of OpenApiRestCall_602450
proc url_GetResetClusterParameterGroup_605962(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetResetClusterParameterGroup_605961(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Sets one or more parameters of the specified parameter group to their default values and sets the source values of the parameters to "engine-default". To reset the entire parameter group specify the <i>ResetAllParameters</i> parameter. For parameter changes to take effect you must reboot any associated clusters. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ParameterGroupName: JString (required)
  ##                     : The name of the cluster parameter group to be reset.
  ##   Parameters: JArray
  ##             : <p>An array of names of parameters to be reset. If <i>ResetAllParameters</i> option is not used, then at least one parameter name must be supplied. </p> <p>Constraints: A maximum of 20 parameters can be reset in a single request.</p>
  ##   Action: JString (required)
  ##   ResetAllParameters: JBool
  ##                     : <p>If <code>true</code>, all parameters in the specified parameter group will be reset to their default values. </p> <p>Default: <code>true</code> </p>
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `ParameterGroupName` field"
  var valid_605963 = query.getOrDefault("ParameterGroupName")
  valid_605963 = validateParameter(valid_605963, JString, required = true,
                                 default = nil)
  if valid_605963 != nil:
    section.add "ParameterGroupName", valid_605963
  var valid_605964 = query.getOrDefault("Parameters")
  valid_605964 = validateParameter(valid_605964, JArray, required = false,
                                 default = nil)
  if valid_605964 != nil:
    section.add "Parameters", valid_605964
  var valid_605965 = query.getOrDefault("Action")
  valid_605965 = validateParameter(valid_605965, JString, required = true, default = newJString(
      "ResetClusterParameterGroup"))
  if valid_605965 != nil:
    section.add "Action", valid_605965
  var valid_605966 = query.getOrDefault("ResetAllParameters")
  valid_605966 = validateParameter(valid_605966, JBool, required = false, default = nil)
  if valid_605966 != nil:
    section.add "ResetAllParameters", valid_605966
  var valid_605967 = query.getOrDefault("Version")
  valid_605967 = validateParameter(valid_605967, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_605967 != nil:
    section.add "Version", valid_605967
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_605968 = header.getOrDefault("X-Amz-Date")
  valid_605968 = validateParameter(valid_605968, JString, required = false,
                                 default = nil)
  if valid_605968 != nil:
    section.add "X-Amz-Date", valid_605968
  var valid_605969 = header.getOrDefault("X-Amz-Security-Token")
  valid_605969 = validateParameter(valid_605969, JString, required = false,
                                 default = nil)
  if valid_605969 != nil:
    section.add "X-Amz-Security-Token", valid_605969
  var valid_605970 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605970 = validateParameter(valid_605970, JString, required = false,
                                 default = nil)
  if valid_605970 != nil:
    section.add "X-Amz-Content-Sha256", valid_605970
  var valid_605971 = header.getOrDefault("X-Amz-Algorithm")
  valid_605971 = validateParameter(valid_605971, JString, required = false,
                                 default = nil)
  if valid_605971 != nil:
    section.add "X-Amz-Algorithm", valid_605971
  var valid_605972 = header.getOrDefault("X-Amz-Signature")
  valid_605972 = validateParameter(valid_605972, JString, required = false,
                                 default = nil)
  if valid_605972 != nil:
    section.add "X-Amz-Signature", valid_605972
  var valid_605973 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605973 = validateParameter(valid_605973, JString, required = false,
                                 default = nil)
  if valid_605973 != nil:
    section.add "X-Amz-SignedHeaders", valid_605973
  var valid_605974 = header.getOrDefault("X-Amz-Credential")
  valid_605974 = validateParameter(valid_605974, JString, required = false,
                                 default = nil)
  if valid_605974 != nil:
    section.add "X-Amz-Credential", valid_605974
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_605975: Call_GetResetClusterParameterGroup_605960; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Sets one or more parameters of the specified parameter group to their default values and sets the source values of the parameters to "engine-default". To reset the entire parameter group specify the <i>ResetAllParameters</i> parameter. For parameter changes to take effect you must reboot any associated clusters. 
  ## 
  let valid = call_605975.validator(path, query, header, formData, body)
  let scheme = call_605975.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605975.url(scheme.get, call_605975.host, call_605975.base,
                         call_605975.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_605975, url, valid)

proc call*(call_605976: Call_GetResetClusterParameterGroup_605960;
          ParameterGroupName: string; Parameters: JsonNode = nil;
          Action: string = "ResetClusterParameterGroup";
          ResetAllParameters: bool = false; Version: string = "2012-12-01"): Recallable =
  ## getResetClusterParameterGroup
  ## Sets one or more parameters of the specified parameter group to their default values and sets the source values of the parameters to "engine-default". To reset the entire parameter group specify the <i>ResetAllParameters</i> parameter. For parameter changes to take effect you must reboot any associated clusters. 
  ##   ParameterGroupName: string (required)
  ##                     : The name of the cluster parameter group to be reset.
  ##   Parameters: JArray
  ##             : <p>An array of names of parameters to be reset. If <i>ResetAllParameters</i> option is not used, then at least one parameter name must be supplied. </p> <p>Constraints: A maximum of 20 parameters can be reset in a single request.</p>
  ##   Action: string (required)
  ##   ResetAllParameters: bool
  ##                     : <p>If <code>true</code>, all parameters in the specified parameter group will be reset to their default values. </p> <p>Default: <code>true</code> </p>
  ##   Version: string (required)
  var query_605977 = newJObject()
  add(query_605977, "ParameterGroupName", newJString(ParameterGroupName))
  if Parameters != nil:
    query_605977.add "Parameters", Parameters
  add(query_605977, "Action", newJString(Action))
  add(query_605977, "ResetAllParameters", newJBool(ResetAllParameters))
  add(query_605977, "Version", newJString(Version))
  result = call_605976.call(nil, query_605977, nil, nil, nil)

var getResetClusterParameterGroup* = Call_GetResetClusterParameterGroup_605960(
    name: "getResetClusterParameterGroup", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=ResetClusterParameterGroup",
    validator: validate_GetResetClusterParameterGroup_605961, base: "/",
    url: url_GetResetClusterParameterGroup_605962,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostResizeCluster_606017 = ref object of OpenApiRestCall_602450
proc url_PostResizeCluster_606019(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostResizeCluster_606018(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## <p>Changes the size of the cluster. You can change the cluster's type, or change the number or type of nodes. The default behavior is to use the elastic resize method. With an elastic resize, your cluster is available for read and write operations more quickly than with the classic resize method. </p> <p>Elastic resize operations have the following restrictions:</p> <ul> <li> <p>You can only resize clusters of the following types:</p> <ul> <li> <p>dc2.large</p> </li> <li> <p>dc2.8xlarge</p> </li> <li> <p>ds2.xlarge</p> </li> <li> <p>ds2.8xlarge</p> </li> </ul> </li> <li> <p>The type of nodes that you add must match the node type for the cluster.</p> </li> </ul>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_606020 = query.getOrDefault("Action")
  valid_606020 = validateParameter(valid_606020, JString, required = true,
                                 default = newJString("ResizeCluster"))
  if valid_606020 != nil:
    section.add "Action", valid_606020
  var valid_606021 = query.getOrDefault("Version")
  valid_606021 = validateParameter(valid_606021, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_606021 != nil:
    section.add "Version", valid_606021
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_606022 = header.getOrDefault("X-Amz-Date")
  valid_606022 = validateParameter(valid_606022, JString, required = false,
                                 default = nil)
  if valid_606022 != nil:
    section.add "X-Amz-Date", valid_606022
  var valid_606023 = header.getOrDefault("X-Amz-Security-Token")
  valid_606023 = validateParameter(valid_606023, JString, required = false,
                                 default = nil)
  if valid_606023 != nil:
    section.add "X-Amz-Security-Token", valid_606023
  var valid_606024 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_606024 = validateParameter(valid_606024, JString, required = false,
                                 default = nil)
  if valid_606024 != nil:
    section.add "X-Amz-Content-Sha256", valid_606024
  var valid_606025 = header.getOrDefault("X-Amz-Algorithm")
  valid_606025 = validateParameter(valid_606025, JString, required = false,
                                 default = nil)
  if valid_606025 != nil:
    section.add "X-Amz-Algorithm", valid_606025
  var valid_606026 = header.getOrDefault("X-Amz-Signature")
  valid_606026 = validateParameter(valid_606026, JString, required = false,
                                 default = nil)
  if valid_606026 != nil:
    section.add "X-Amz-Signature", valid_606026
  var valid_606027 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_606027 = validateParameter(valid_606027, JString, required = false,
                                 default = nil)
  if valid_606027 != nil:
    section.add "X-Amz-SignedHeaders", valid_606027
  var valid_606028 = header.getOrDefault("X-Amz-Credential")
  valid_606028 = validateParameter(valid_606028, JString, required = false,
                                 default = nil)
  if valid_606028 != nil:
    section.add "X-Amz-Credential", valid_606028
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterType: JString
  ##              : The new cluster type for the specified cluster.
  ##   ClusterIdentifier: JString (required)
  ##                    : The unique identifier for the cluster to resize.
  ##   NumberOfNodes: JInt (required)
  ##                : The new number of nodes for the cluster.
  ##   Classic: JBool
  ##          : A boolean value indicating whether the resize operation is using the classic resize process. If you don't provide this parameter or set the value to <code>false</code>, the resize type is elastic. 
  ##   NodeType: JString
  ##           : The new node type for the nodes you are adding. If not specified, the cluster's current node type is used.
  section = newJObject()
  var valid_606029 = formData.getOrDefault("ClusterType")
  valid_606029 = validateParameter(valid_606029, JString, required = false,
                                 default = nil)
  if valid_606029 != nil:
    section.add "ClusterType", valid_606029
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_606030 = formData.getOrDefault("ClusterIdentifier")
  valid_606030 = validateParameter(valid_606030, JString, required = true,
                                 default = nil)
  if valid_606030 != nil:
    section.add "ClusterIdentifier", valid_606030
  var valid_606031 = formData.getOrDefault("NumberOfNodes")
  valid_606031 = validateParameter(valid_606031, JInt, required = true, default = nil)
  if valid_606031 != nil:
    section.add "NumberOfNodes", valid_606031
  var valid_606032 = formData.getOrDefault("Classic")
  valid_606032 = validateParameter(valid_606032, JBool, required = false, default = nil)
  if valid_606032 != nil:
    section.add "Classic", valid_606032
  var valid_606033 = formData.getOrDefault("NodeType")
  valid_606033 = validateParameter(valid_606033, JString, required = false,
                                 default = nil)
  if valid_606033 != nil:
    section.add "NodeType", valid_606033
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_606034: Call_PostResizeCluster_606017; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Changes the size of the cluster. You can change the cluster's type, or change the number or type of nodes. The default behavior is to use the elastic resize method. With an elastic resize, your cluster is available for read and write operations more quickly than with the classic resize method. </p> <p>Elastic resize operations have the following restrictions:</p> <ul> <li> <p>You can only resize clusters of the following types:</p> <ul> <li> <p>dc2.large</p> </li> <li> <p>dc2.8xlarge</p> </li> <li> <p>ds2.xlarge</p> </li> <li> <p>ds2.8xlarge</p> </li> </ul> </li> <li> <p>The type of nodes that you add must match the node type for the cluster.</p> </li> </ul>
  ## 
  let valid = call_606034.validator(path, query, header, formData, body)
  let scheme = call_606034.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_606034.url(scheme.get, call_606034.host, call_606034.base,
                         call_606034.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_606034, url, valid)

proc call*(call_606035: Call_PostResizeCluster_606017; ClusterIdentifier: string;
          NumberOfNodes: int; ClusterType: string = "";
          Action: string = "ResizeCluster"; Classic: bool = false;
          Version: string = "2012-12-01"; NodeType: string = ""): Recallable =
  ## postResizeCluster
  ## <p>Changes the size of the cluster. You can change the cluster's type, or change the number or type of nodes. The default behavior is to use the elastic resize method. With an elastic resize, your cluster is available for read and write operations more quickly than with the classic resize method. </p> <p>Elastic resize operations have the following restrictions:</p> <ul> <li> <p>You can only resize clusters of the following types:</p> <ul> <li> <p>dc2.large</p> </li> <li> <p>dc2.8xlarge</p> </li> <li> <p>ds2.xlarge</p> </li> <li> <p>ds2.8xlarge</p> </li> </ul> </li> <li> <p>The type of nodes that you add must match the node type for the cluster.</p> </li> </ul>
  ##   ClusterType: string
  ##              : The new cluster type for the specified cluster.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : The unique identifier for the cluster to resize.
  ##   NumberOfNodes: int (required)
  ##                : The new number of nodes for the cluster.
  ##   Classic: bool
  ##          : A boolean value indicating whether the resize operation is using the classic resize process. If you don't provide this parameter or set the value to <code>false</code>, the resize type is elastic. 
  ##   Version: string (required)
  ##   NodeType: string
  ##           : The new node type for the nodes you are adding. If not specified, the cluster's current node type is used.
  var query_606036 = newJObject()
  var formData_606037 = newJObject()
  add(formData_606037, "ClusterType", newJString(ClusterType))
  add(query_606036, "Action", newJString(Action))
  add(formData_606037, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_606037, "NumberOfNodes", newJInt(NumberOfNodes))
  add(formData_606037, "Classic", newJBool(Classic))
  add(query_606036, "Version", newJString(Version))
  add(formData_606037, "NodeType", newJString(NodeType))
  result = call_606035.call(nil, query_606036, nil, formData_606037, nil)

var postResizeCluster* = Call_PostResizeCluster_606017(name: "postResizeCluster",
    meth: HttpMethod.HttpPost, host: "redshift.amazonaws.com",
    route: "/#Action=ResizeCluster", validator: validate_PostResizeCluster_606018,
    base: "/", url: url_PostResizeCluster_606019,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetResizeCluster_605997 = ref object of OpenApiRestCall_602450
proc url_GetResizeCluster_605999(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetResizeCluster_605998(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## <p>Changes the size of the cluster. You can change the cluster's type, or change the number or type of nodes. The default behavior is to use the elastic resize method. With an elastic resize, your cluster is available for read and write operations more quickly than with the classic resize method. </p> <p>Elastic resize operations have the following restrictions:</p> <ul> <li> <p>You can only resize clusters of the following types:</p> <ul> <li> <p>dc2.large</p> </li> <li> <p>dc2.8xlarge</p> </li> <li> <p>ds2.xlarge</p> </li> <li> <p>ds2.8xlarge</p> </li> </ul> </li> <li> <p>The type of nodes that you add must match the node type for the cluster.</p> </li> </ul>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : The unique identifier for the cluster to resize.
  ##   Classic: JBool
  ##          : A boolean value indicating whether the resize operation is using the classic resize process. If you don't provide this parameter or set the value to <code>false</code>, the resize type is elastic. 
  ##   NumberOfNodes: JInt (required)
  ##                : The new number of nodes for the cluster.
  ##   NodeType: JString
  ##           : The new node type for the nodes you are adding. If not specified, the cluster's current node type is used.
  ##   Version: JString (required)
  ##   ClusterType: JString
  ##              : The new cluster type for the specified cluster.
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_606000 = query.getOrDefault("Action")
  valid_606000 = validateParameter(valid_606000, JString, required = true,
                                 default = newJString("ResizeCluster"))
  if valid_606000 != nil:
    section.add "Action", valid_606000
  var valid_606001 = query.getOrDefault("ClusterIdentifier")
  valid_606001 = validateParameter(valid_606001, JString, required = true,
                                 default = nil)
  if valid_606001 != nil:
    section.add "ClusterIdentifier", valid_606001
  var valid_606002 = query.getOrDefault("Classic")
  valid_606002 = validateParameter(valid_606002, JBool, required = false, default = nil)
  if valid_606002 != nil:
    section.add "Classic", valid_606002
  var valid_606003 = query.getOrDefault("NumberOfNodes")
  valid_606003 = validateParameter(valid_606003, JInt, required = true, default = nil)
  if valid_606003 != nil:
    section.add "NumberOfNodes", valid_606003
  var valid_606004 = query.getOrDefault("NodeType")
  valid_606004 = validateParameter(valid_606004, JString, required = false,
                                 default = nil)
  if valid_606004 != nil:
    section.add "NodeType", valid_606004
  var valid_606005 = query.getOrDefault("Version")
  valid_606005 = validateParameter(valid_606005, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_606005 != nil:
    section.add "Version", valid_606005
  var valid_606006 = query.getOrDefault("ClusterType")
  valid_606006 = validateParameter(valid_606006, JString, required = false,
                                 default = nil)
  if valid_606006 != nil:
    section.add "ClusterType", valid_606006
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_606007 = header.getOrDefault("X-Amz-Date")
  valid_606007 = validateParameter(valid_606007, JString, required = false,
                                 default = nil)
  if valid_606007 != nil:
    section.add "X-Amz-Date", valid_606007
  var valid_606008 = header.getOrDefault("X-Amz-Security-Token")
  valid_606008 = validateParameter(valid_606008, JString, required = false,
                                 default = nil)
  if valid_606008 != nil:
    section.add "X-Amz-Security-Token", valid_606008
  var valid_606009 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_606009 = validateParameter(valid_606009, JString, required = false,
                                 default = nil)
  if valid_606009 != nil:
    section.add "X-Amz-Content-Sha256", valid_606009
  var valid_606010 = header.getOrDefault("X-Amz-Algorithm")
  valid_606010 = validateParameter(valid_606010, JString, required = false,
                                 default = nil)
  if valid_606010 != nil:
    section.add "X-Amz-Algorithm", valid_606010
  var valid_606011 = header.getOrDefault("X-Amz-Signature")
  valid_606011 = validateParameter(valid_606011, JString, required = false,
                                 default = nil)
  if valid_606011 != nil:
    section.add "X-Amz-Signature", valid_606011
  var valid_606012 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_606012 = validateParameter(valid_606012, JString, required = false,
                                 default = nil)
  if valid_606012 != nil:
    section.add "X-Amz-SignedHeaders", valid_606012
  var valid_606013 = header.getOrDefault("X-Amz-Credential")
  valid_606013 = validateParameter(valid_606013, JString, required = false,
                                 default = nil)
  if valid_606013 != nil:
    section.add "X-Amz-Credential", valid_606013
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_606014: Call_GetResizeCluster_605997; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Changes the size of the cluster. You can change the cluster's type, or change the number or type of nodes. The default behavior is to use the elastic resize method. With an elastic resize, your cluster is available for read and write operations more quickly than with the classic resize method. </p> <p>Elastic resize operations have the following restrictions:</p> <ul> <li> <p>You can only resize clusters of the following types:</p> <ul> <li> <p>dc2.large</p> </li> <li> <p>dc2.8xlarge</p> </li> <li> <p>ds2.xlarge</p> </li> <li> <p>ds2.8xlarge</p> </li> </ul> </li> <li> <p>The type of nodes that you add must match the node type for the cluster.</p> </li> </ul>
  ## 
  let valid = call_606014.validator(path, query, header, formData, body)
  let scheme = call_606014.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_606014.url(scheme.get, call_606014.host, call_606014.base,
                         call_606014.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_606014, url, valid)

proc call*(call_606015: Call_GetResizeCluster_605997; ClusterIdentifier: string;
          NumberOfNodes: int; Action: string = "ResizeCluster"; Classic: bool = false;
          NodeType: string = ""; Version: string = "2012-12-01";
          ClusterType: string = ""): Recallable =
  ## getResizeCluster
  ## <p>Changes the size of the cluster. You can change the cluster's type, or change the number or type of nodes. The default behavior is to use the elastic resize method. With an elastic resize, your cluster is available for read and write operations more quickly than with the classic resize method. </p> <p>Elastic resize operations have the following restrictions:</p> <ul> <li> <p>You can only resize clusters of the following types:</p> <ul> <li> <p>dc2.large</p> </li> <li> <p>dc2.8xlarge</p> </li> <li> <p>ds2.xlarge</p> </li> <li> <p>ds2.8xlarge</p> </li> </ul> </li> <li> <p>The type of nodes that you add must match the node type for the cluster.</p> </li> </ul>
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : The unique identifier for the cluster to resize.
  ##   Classic: bool
  ##          : A boolean value indicating whether the resize operation is using the classic resize process. If you don't provide this parameter or set the value to <code>false</code>, the resize type is elastic. 
  ##   NumberOfNodes: int (required)
  ##                : The new number of nodes for the cluster.
  ##   NodeType: string
  ##           : The new node type for the nodes you are adding. If not specified, the cluster's current node type is used.
  ##   Version: string (required)
  ##   ClusterType: string
  ##              : The new cluster type for the specified cluster.
  var query_606016 = newJObject()
  add(query_606016, "Action", newJString(Action))
  add(query_606016, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_606016, "Classic", newJBool(Classic))
  add(query_606016, "NumberOfNodes", newJInt(NumberOfNodes))
  add(query_606016, "NodeType", newJString(NodeType))
  add(query_606016, "Version", newJString(Version))
  add(query_606016, "ClusterType", newJString(ClusterType))
  result = call_606015.call(nil, query_606016, nil, nil, nil)

var getResizeCluster* = Call_GetResizeCluster_605997(name: "getResizeCluster",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=ResizeCluster", validator: validate_GetResizeCluster_605998,
    base: "/", url: url_GetResizeCluster_605999,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostRestoreFromClusterSnapshot_606079 = ref object of OpenApiRestCall_602450
proc url_PostRestoreFromClusterSnapshot_606081(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostRestoreFromClusterSnapshot_606080(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a new cluster from a snapshot. By default, Amazon Redshift creates the resulting cluster with the same configuration as the original cluster from which the snapshot was created, except that the new cluster is created with the default cluster security and parameter groups. After Amazon Redshift creates the cluster, you can use the <a>ModifyCluster</a> API to associate a different security group and different parameter group with the restored cluster. If you are using a DS node type, you can also choose to change to another DS node type of the same size during restore.</p> <p>If you restore a cluster into a VPC, you must provide a cluster subnet group where you want the cluster restored.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_606082 = query.getOrDefault("Action")
  valid_606082 = validateParameter(valid_606082, JString, required = true, default = newJString(
      "RestoreFromClusterSnapshot"))
  if valid_606082 != nil:
    section.add "Action", valid_606082
  var valid_606083 = query.getOrDefault("Version")
  valid_606083 = validateParameter(valid_606083, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_606083 != nil:
    section.add "Version", valid_606083
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_606084 = header.getOrDefault("X-Amz-Date")
  valid_606084 = validateParameter(valid_606084, JString, required = false,
                                 default = nil)
  if valid_606084 != nil:
    section.add "X-Amz-Date", valid_606084
  var valid_606085 = header.getOrDefault("X-Amz-Security-Token")
  valid_606085 = validateParameter(valid_606085, JString, required = false,
                                 default = nil)
  if valid_606085 != nil:
    section.add "X-Amz-Security-Token", valid_606085
  var valid_606086 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_606086 = validateParameter(valid_606086, JString, required = false,
                                 default = nil)
  if valid_606086 != nil:
    section.add "X-Amz-Content-Sha256", valid_606086
  var valid_606087 = header.getOrDefault("X-Amz-Algorithm")
  valid_606087 = validateParameter(valid_606087, JString, required = false,
                                 default = nil)
  if valid_606087 != nil:
    section.add "X-Amz-Algorithm", valid_606087
  var valid_606088 = header.getOrDefault("X-Amz-Signature")
  valid_606088 = validateParameter(valid_606088, JString, required = false,
                                 default = nil)
  if valid_606088 != nil:
    section.add "X-Amz-Signature", valid_606088
  var valid_606089 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_606089 = validateParameter(valid_606089, JString, required = false,
                                 default = nil)
  if valid_606089 != nil:
    section.add "X-Amz-SignedHeaders", valid_606089
  var valid_606090 = header.getOrDefault("X-Amz-Credential")
  valid_606090 = validateParameter(valid_606090, JString, required = false,
                                 default = nil)
  if valid_606090 != nil:
    section.add "X-Amz-Credential", valid_606090
  result.add "header", section
  ## parameters in `formData` object:
  ##   PreferredMaintenanceWindow: JString
  ##                             : <p>The weekly time range (in UTC) during which automated cluster maintenance can occur.</p> <p> Format: <code>ddd:hh24:mi-ddd:hh24:mi</code> </p> <p> Default: The value selected for the cluster from which the snapshot was taken. For more information about the time blocks for each region, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-maintenance-windows">Maintenance Windows</a> in Amazon Redshift Cluster Management Guide. </p> <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p> <p>Constraints: Minimum 30-minute window.</p>
  ##   EnhancedVpcRouting: JBool
  ##                     : <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p> <p>Default: false</p>
  ##   Port: JInt
  ##       : <p>The port number on which the cluster accepts connections.</p> <p>Default: The same port as the original cluster.</p> <p>Constraints: Must be between <code>1115</code> and <code>65535</code>.</p>
  ##   VpcSecurityGroupIds: JArray
  ##                      : <p>A list of Virtual Private Cloud (VPC) security groups to be associated with the cluster.</p> <p>Default: The default VPC security group is associated with the cluster.</p> <p>VPC security groups only apply to clusters in VPCs.</p>
  ##   AdditionalInfo: JString
  ##                 : Reserved.
  ##   AvailabilityZone: JString
  ##                   : <p>The Amazon EC2 Availability Zone in which to restore the cluster.</p> <p>Default: A random, system-chosen Availability Zone.</p> <p>Example: <code>us-east-1a</code> </p>
  ##   SnapshotClusterIdentifier: JString
  ##                            : The name of the cluster the source snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.
  ##   ClusterSecurityGroups: JArray
  ##                        : <p>A list of security groups to be associated with this cluster.</p> <p>Default: The default cluster security group for Amazon Redshift.</p> <p>Cluster security groups only apply to clusters outside of VPCs.</p>
  ##   HsmConfigurationIdentifier: JString
  ##                             : Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
  ##   OwnerAccount: JString
  ##               : The AWS customer account used to create or copy the snapshot. Required if you are restoring a snapshot you do not own, optional if you own the snapshot.
  ##   HsmClientCertificateIdentifier: JString
  ##                                 : Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM.
  ##   PubliclyAccessible: JBool
  ##                     : If <code>true</code>, the cluster can be accessed from a public network. 
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The identifier of the cluster that will be created from restoring the snapshot.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul>
  ##   IamRoles: JArray
  ##           : <p>A list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services. You must supply the IAM roles in their Amazon Resource Name (ARN) format. You can supply up to 10 IAM roles in a single request.</p> <p>A cluster can have up to 10 IAM roles associated at any time.</p>
  ##   SnapshotScheduleIdentifier: JString
  ##                             : A unique identifier for the snapshot schedule.
  ##   NumberOfNodes: JInt
  ##                : The number of nodes specified when provisioning the restored cluster.
  ##   ClusterParameterGroupName: JString
  ##                            : <p>The name of the parameter group to be associated with this cluster.</p> <p>Default: The default Amazon Redshift cluster parameter group. For information about the default parameter group, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Working with Amazon Redshift Parameter Groups</a>.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   KmsKeyId: JString
  ##           : The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster that you restore from a shared snapshot.
  ##   SnapshotIdentifier: JString (required)
  ##                     : <p>The name of the snapshot from which to create the new cluster. This parameter isn't case sensitive.</p> <p>Example: <code>my-snapshot-id</code> </p>
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The default number of days to retain a manual snapshot. If the value is -1, the snapshot is retained indefinitely. This setting doesn't change the retention period of existing snapshots.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  ##   ElasticIp: JString
  ##            : The elastic IP (EIP) address for the cluster.
  ##   AllowVersionUpgrade: JBool
  ##                      : <p>If <code>true</code>, major version upgrades can be applied during the maintenance window to the Amazon Redshift engine that is running on the cluster. </p> <p>Default: <code>true</code> </p>
  ##   AutomatedSnapshotRetentionPeriod: JInt
  ##                                   : <p>The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p> <p>Default: The value selected for the cluster from which the snapshot was taken.</p> <p>Constraints: Must be a value from 0 to 35.</p>
  ##   NodeType: JString
  ##           : <p>The node type that the restored cluster will be provisioned with.</p> <p>Default: The node type of the cluster from which the snapshot was taken. You can modify this if you are using any DS node type. In that case, you can choose to restore into another DS node type of the same size. For example, you can restore ds1.8xlarge into ds2.8xlarge, or ds1.xlarge into ds2.xlarge. If you have a DC instance type, you must restore into that same instance type and size. In other words, you can only restore a dc1.large instance type into another dc1.large instance type or dc2.large instance type. You can't restore dc1.8xlarge to dc2.8xlarge. First restore to a dc1.8xlareg cluster, then resize to a dc2.8large cluster. For more information about node types, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-about-clusters-and-nodes"> About Clusters and Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ##   MaintenanceTrackName: JString
  ##                       : The name of the maintenance track for the restored cluster. When you take a snapshot, the snapshot inherits the <code>MaintenanceTrack</code> value from the cluster. The snapshot might be on a different track than the cluster that was the source for the snapshot. For example, suppose that you take a snapshot of a cluster that is on the current track and then change the cluster to be on the trailing track. In this case, the snapshot and the source cluster are on different tracks.
  ##   ClusterSubnetGroupName: JString
  ##                         : <p>The name of the subnet group where you want to cluster restored.</p> <p>A snapshot of cluster in VPC can be restored only in VPC. Therefore, you must provide subnet group name where you want the cluster restored.</p>
  section = newJObject()
  var valid_606091 = formData.getOrDefault("PreferredMaintenanceWindow")
  valid_606091 = validateParameter(valid_606091, JString, required = false,
                                 default = nil)
  if valid_606091 != nil:
    section.add "PreferredMaintenanceWindow", valid_606091
  var valid_606092 = formData.getOrDefault("EnhancedVpcRouting")
  valid_606092 = validateParameter(valid_606092, JBool, required = false, default = nil)
  if valid_606092 != nil:
    section.add "EnhancedVpcRouting", valid_606092
  var valid_606093 = formData.getOrDefault("Port")
  valid_606093 = validateParameter(valid_606093, JInt, required = false, default = nil)
  if valid_606093 != nil:
    section.add "Port", valid_606093
  var valid_606094 = formData.getOrDefault("VpcSecurityGroupIds")
  valid_606094 = validateParameter(valid_606094, JArray, required = false,
                                 default = nil)
  if valid_606094 != nil:
    section.add "VpcSecurityGroupIds", valid_606094
  var valid_606095 = formData.getOrDefault("AdditionalInfo")
  valid_606095 = validateParameter(valid_606095, JString, required = false,
                                 default = nil)
  if valid_606095 != nil:
    section.add "AdditionalInfo", valid_606095
  var valid_606096 = formData.getOrDefault("AvailabilityZone")
  valid_606096 = validateParameter(valid_606096, JString, required = false,
                                 default = nil)
  if valid_606096 != nil:
    section.add "AvailabilityZone", valid_606096
  var valid_606097 = formData.getOrDefault("SnapshotClusterIdentifier")
  valid_606097 = validateParameter(valid_606097, JString, required = false,
                                 default = nil)
  if valid_606097 != nil:
    section.add "SnapshotClusterIdentifier", valid_606097
  var valid_606098 = formData.getOrDefault("ClusterSecurityGroups")
  valid_606098 = validateParameter(valid_606098, JArray, required = false,
                                 default = nil)
  if valid_606098 != nil:
    section.add "ClusterSecurityGroups", valid_606098
  var valid_606099 = formData.getOrDefault("HsmConfigurationIdentifier")
  valid_606099 = validateParameter(valid_606099, JString, required = false,
                                 default = nil)
  if valid_606099 != nil:
    section.add "HsmConfigurationIdentifier", valid_606099
  var valid_606100 = formData.getOrDefault("OwnerAccount")
  valid_606100 = validateParameter(valid_606100, JString, required = false,
                                 default = nil)
  if valid_606100 != nil:
    section.add "OwnerAccount", valid_606100
  var valid_606101 = formData.getOrDefault("HsmClientCertificateIdentifier")
  valid_606101 = validateParameter(valid_606101, JString, required = false,
                                 default = nil)
  if valid_606101 != nil:
    section.add "HsmClientCertificateIdentifier", valid_606101
  var valid_606102 = formData.getOrDefault("PubliclyAccessible")
  valid_606102 = validateParameter(valid_606102, JBool, required = false, default = nil)
  if valid_606102 != nil:
    section.add "PubliclyAccessible", valid_606102
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_606103 = formData.getOrDefault("ClusterIdentifier")
  valid_606103 = validateParameter(valid_606103, JString, required = true,
                                 default = nil)
  if valid_606103 != nil:
    section.add "ClusterIdentifier", valid_606103
  var valid_606104 = formData.getOrDefault("IamRoles")
  valid_606104 = validateParameter(valid_606104, JArray, required = false,
                                 default = nil)
  if valid_606104 != nil:
    section.add "IamRoles", valid_606104
  var valid_606105 = formData.getOrDefault("SnapshotScheduleIdentifier")
  valid_606105 = validateParameter(valid_606105, JString, required = false,
                                 default = nil)
  if valid_606105 != nil:
    section.add "SnapshotScheduleIdentifier", valid_606105
  var valid_606106 = formData.getOrDefault("NumberOfNodes")
  valid_606106 = validateParameter(valid_606106, JInt, required = false, default = nil)
  if valid_606106 != nil:
    section.add "NumberOfNodes", valid_606106
  var valid_606107 = formData.getOrDefault("ClusterParameterGroupName")
  valid_606107 = validateParameter(valid_606107, JString, required = false,
                                 default = nil)
  if valid_606107 != nil:
    section.add "ClusterParameterGroupName", valid_606107
  var valid_606108 = formData.getOrDefault("KmsKeyId")
  valid_606108 = validateParameter(valid_606108, JString, required = false,
                                 default = nil)
  if valid_606108 != nil:
    section.add "KmsKeyId", valid_606108
  var valid_606109 = formData.getOrDefault("SnapshotIdentifier")
  valid_606109 = validateParameter(valid_606109, JString, required = true,
                                 default = nil)
  if valid_606109 != nil:
    section.add "SnapshotIdentifier", valid_606109
  var valid_606110 = formData.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_606110 = validateParameter(valid_606110, JInt, required = false, default = nil)
  if valid_606110 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_606110
  var valid_606111 = formData.getOrDefault("ElasticIp")
  valid_606111 = validateParameter(valid_606111, JString, required = false,
                                 default = nil)
  if valid_606111 != nil:
    section.add "ElasticIp", valid_606111
  var valid_606112 = formData.getOrDefault("AllowVersionUpgrade")
  valid_606112 = validateParameter(valid_606112, JBool, required = false, default = nil)
  if valid_606112 != nil:
    section.add "AllowVersionUpgrade", valid_606112
  var valid_606113 = formData.getOrDefault("AutomatedSnapshotRetentionPeriod")
  valid_606113 = validateParameter(valid_606113, JInt, required = false, default = nil)
  if valid_606113 != nil:
    section.add "AutomatedSnapshotRetentionPeriod", valid_606113
  var valid_606114 = formData.getOrDefault("NodeType")
  valid_606114 = validateParameter(valid_606114, JString, required = false,
                                 default = nil)
  if valid_606114 != nil:
    section.add "NodeType", valid_606114
  var valid_606115 = formData.getOrDefault("MaintenanceTrackName")
  valid_606115 = validateParameter(valid_606115, JString, required = false,
                                 default = nil)
  if valid_606115 != nil:
    section.add "MaintenanceTrackName", valid_606115
  var valid_606116 = formData.getOrDefault("ClusterSubnetGroupName")
  valid_606116 = validateParameter(valid_606116, JString, required = false,
                                 default = nil)
  if valid_606116 != nil:
    section.add "ClusterSubnetGroupName", valid_606116
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_606117: Call_PostRestoreFromClusterSnapshot_606079; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a new cluster from a snapshot. By default, Amazon Redshift creates the resulting cluster with the same configuration as the original cluster from which the snapshot was created, except that the new cluster is created with the default cluster security and parameter groups. After Amazon Redshift creates the cluster, you can use the <a>ModifyCluster</a> API to associate a different security group and different parameter group with the restored cluster. If you are using a DS node type, you can also choose to change to another DS node type of the same size during restore.</p> <p>If you restore a cluster into a VPC, you must provide a cluster subnet group where you want the cluster restored.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_606117.validator(path, query, header, formData, body)
  let scheme = call_606117.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_606117.url(scheme.get, call_606117.host, call_606117.base,
                         call_606117.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_606117, url, valid)

proc call*(call_606118: Call_PostRestoreFromClusterSnapshot_606079;
          ClusterIdentifier: string; SnapshotIdentifier: string;
          PreferredMaintenanceWindow: string = ""; EnhancedVpcRouting: bool = false;
          Port: int = 0; VpcSecurityGroupIds: JsonNode = nil;
          AdditionalInfo: string = ""; AvailabilityZone: string = "";
          SnapshotClusterIdentifier: string = "";
          ClusterSecurityGroups: JsonNode = nil;
          HsmConfigurationIdentifier: string = "";
          Action: string = "RestoreFromClusterSnapshot"; OwnerAccount: string = "";
          HsmClientCertificateIdentifier: string = "";
          PubliclyAccessible: bool = false; IamRoles: JsonNode = nil;
          SnapshotScheduleIdentifier: string = ""; NumberOfNodes: int = 0;
          ClusterParameterGroupName: string = ""; KmsKeyId: string = "";
          ManualSnapshotRetentionPeriod: int = 0; ElasticIp: string = "";
          AllowVersionUpgrade: bool = false;
          AutomatedSnapshotRetentionPeriod: int = 0; Version: string = "2012-12-01";
          NodeType: string = ""; MaintenanceTrackName: string = "";
          ClusterSubnetGroupName: string = ""): Recallable =
  ## postRestoreFromClusterSnapshot
  ## <p>Creates a new cluster from a snapshot. By default, Amazon Redshift creates the resulting cluster with the same configuration as the original cluster from which the snapshot was created, except that the new cluster is created with the default cluster security and parameter groups. After Amazon Redshift creates the cluster, you can use the <a>ModifyCluster</a> API to associate a different security group and different parameter group with the restored cluster. If you are using a DS node type, you can also choose to change to another DS node type of the same size during restore.</p> <p>If you restore a cluster into a VPC, you must provide a cluster subnet group where you want the cluster restored.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   PreferredMaintenanceWindow: string
  ##                             : <p>The weekly time range (in UTC) during which automated cluster maintenance can occur.</p> <p> Format: <code>ddd:hh24:mi-ddd:hh24:mi</code> </p> <p> Default: The value selected for the cluster from which the snapshot was taken. For more information about the time blocks for each region, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-maintenance-windows">Maintenance Windows</a> in Amazon Redshift Cluster Management Guide. </p> <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p> <p>Constraints: Minimum 30-minute window.</p>
  ##   EnhancedVpcRouting: bool
  ##                     : <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p> <p>Default: false</p>
  ##   Port: int
  ##       : <p>The port number on which the cluster accepts connections.</p> <p>Default: The same port as the original cluster.</p> <p>Constraints: Must be between <code>1115</code> and <code>65535</code>.</p>
  ##   VpcSecurityGroupIds: JArray
  ##                      : <p>A list of Virtual Private Cloud (VPC) security groups to be associated with the cluster.</p> <p>Default: The default VPC security group is associated with the cluster.</p> <p>VPC security groups only apply to clusters in VPCs.</p>
  ##   AdditionalInfo: string
  ##                 : Reserved.
  ##   AvailabilityZone: string
  ##                   : <p>The Amazon EC2 Availability Zone in which to restore the cluster.</p> <p>Default: A random, system-chosen Availability Zone.</p> <p>Example: <code>us-east-1a</code> </p>
  ##   SnapshotClusterIdentifier: string
  ##                            : The name of the cluster the source snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.
  ##   ClusterSecurityGroups: JArray
  ##                        : <p>A list of security groups to be associated with this cluster.</p> <p>Default: The default cluster security group for Amazon Redshift.</p> <p>Cluster security groups only apply to clusters outside of VPCs.</p>
  ##   HsmConfigurationIdentifier: string
  ##                             : Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
  ##   Action: string (required)
  ##   OwnerAccount: string
  ##               : The AWS customer account used to create or copy the snapshot. Required if you are restoring a snapshot you do not own, optional if you own the snapshot.
  ##   HsmClientCertificateIdentifier: string
  ##                                 : Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM.
  ##   PubliclyAccessible: bool
  ##                     : If <code>true</code>, the cluster can be accessed from a public network. 
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The identifier of the cluster that will be created from restoring the snapshot.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul>
  ##   IamRoles: JArray
  ##           : <p>A list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services. You must supply the IAM roles in their Amazon Resource Name (ARN) format. You can supply up to 10 IAM roles in a single request.</p> <p>A cluster can have up to 10 IAM roles associated at any time.</p>
  ##   SnapshotScheduleIdentifier: string
  ##                             : A unique identifier for the snapshot schedule.
  ##   NumberOfNodes: int
  ##                : The number of nodes specified when provisioning the restored cluster.
  ##   ClusterParameterGroupName: string
  ##                            : <p>The name of the parameter group to be associated with this cluster.</p> <p>Default: The default Amazon Redshift cluster parameter group. For information about the default parameter group, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Working with Amazon Redshift Parameter Groups</a>.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   KmsKeyId: string
  ##           : The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster that you restore from a shared snapshot.
  ##   SnapshotIdentifier: string (required)
  ##                     : <p>The name of the snapshot from which to create the new cluster. This parameter isn't case sensitive.</p> <p>Example: <code>my-snapshot-id</code> </p>
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The default number of days to retain a manual snapshot. If the value is -1, the snapshot is retained indefinitely. This setting doesn't change the retention period of existing snapshots.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  ##   ElasticIp: string
  ##            : The elastic IP (EIP) address for the cluster.
  ##   AllowVersionUpgrade: bool
  ##                      : <p>If <code>true</code>, major version upgrades can be applied during the maintenance window to the Amazon Redshift engine that is running on the cluster. </p> <p>Default: <code>true</code> </p>
  ##   AutomatedSnapshotRetentionPeriod: int
  ##                                   : <p>The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p> <p>Default: The value selected for the cluster from which the snapshot was taken.</p> <p>Constraints: Must be a value from 0 to 35.</p>
  ##   Version: string (required)
  ##   NodeType: string
  ##           : <p>The node type that the restored cluster will be provisioned with.</p> <p>Default: The node type of the cluster from which the snapshot was taken. You can modify this if you are using any DS node type. In that case, you can choose to restore into another DS node type of the same size. For example, you can restore ds1.8xlarge into ds2.8xlarge, or ds1.xlarge into ds2.xlarge. If you have a DC instance type, you must restore into that same instance type and size. In other words, you can only restore a dc1.large instance type into another dc1.large instance type or dc2.large instance type. You can't restore dc1.8xlarge to dc2.8xlarge. First restore to a dc1.8xlareg cluster, then resize to a dc2.8large cluster. For more information about node types, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-about-clusters-and-nodes"> About Clusters and Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ##   MaintenanceTrackName: string
  ##                       : The name of the maintenance track for the restored cluster. When you take a snapshot, the snapshot inherits the <code>MaintenanceTrack</code> value from the cluster. The snapshot might be on a different track than the cluster that was the source for the snapshot. For example, suppose that you take a snapshot of a cluster that is on the current track and then change the cluster to be on the trailing track. In this case, the snapshot and the source cluster are on different tracks.
  ##   ClusterSubnetGroupName: string
  ##                         : <p>The name of the subnet group where you want to cluster restored.</p> <p>A snapshot of cluster in VPC can be restored only in VPC. Therefore, you must provide subnet group name where you want the cluster restored.</p>
  var query_606119 = newJObject()
  var formData_606120 = newJObject()
  add(formData_606120, "PreferredMaintenanceWindow",
      newJString(PreferredMaintenanceWindow))
  add(formData_606120, "EnhancedVpcRouting", newJBool(EnhancedVpcRouting))
  add(formData_606120, "Port", newJInt(Port))
  if VpcSecurityGroupIds != nil:
    formData_606120.add "VpcSecurityGroupIds", VpcSecurityGroupIds
  add(formData_606120, "AdditionalInfo", newJString(AdditionalInfo))
  add(formData_606120, "AvailabilityZone", newJString(AvailabilityZone))
  add(formData_606120, "SnapshotClusterIdentifier",
      newJString(SnapshotClusterIdentifier))
  if ClusterSecurityGroups != nil:
    formData_606120.add "ClusterSecurityGroups", ClusterSecurityGroups
  add(formData_606120, "HsmConfigurationIdentifier",
      newJString(HsmConfigurationIdentifier))
  add(query_606119, "Action", newJString(Action))
  add(formData_606120, "OwnerAccount", newJString(OwnerAccount))
  add(formData_606120, "HsmClientCertificateIdentifier",
      newJString(HsmClientCertificateIdentifier))
  add(formData_606120, "PubliclyAccessible", newJBool(PubliclyAccessible))
  add(formData_606120, "ClusterIdentifier", newJString(ClusterIdentifier))
  if IamRoles != nil:
    formData_606120.add "IamRoles", IamRoles
  add(formData_606120, "SnapshotScheduleIdentifier",
      newJString(SnapshotScheduleIdentifier))
  add(formData_606120, "NumberOfNodes", newJInt(NumberOfNodes))
  add(formData_606120, "ClusterParameterGroupName",
      newJString(ClusterParameterGroupName))
  add(formData_606120, "KmsKeyId", newJString(KmsKeyId))
  add(formData_606120, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(formData_606120, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  add(formData_606120, "ElasticIp", newJString(ElasticIp))
  add(formData_606120, "AllowVersionUpgrade", newJBool(AllowVersionUpgrade))
  add(formData_606120, "AutomatedSnapshotRetentionPeriod",
      newJInt(AutomatedSnapshotRetentionPeriod))
  add(query_606119, "Version", newJString(Version))
  add(formData_606120, "NodeType", newJString(NodeType))
  add(formData_606120, "MaintenanceTrackName", newJString(MaintenanceTrackName))
  add(formData_606120, "ClusterSubnetGroupName",
      newJString(ClusterSubnetGroupName))
  result = call_606118.call(nil, query_606119, nil, formData_606120, nil)

var postRestoreFromClusterSnapshot* = Call_PostRestoreFromClusterSnapshot_606079(
    name: "postRestoreFromClusterSnapshot", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=RestoreFromClusterSnapshot",
    validator: validate_PostRestoreFromClusterSnapshot_606080, base: "/",
    url: url_PostRestoreFromClusterSnapshot_606081,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetRestoreFromClusterSnapshot_606038 = ref object of OpenApiRestCall_602450
proc url_GetRestoreFromClusterSnapshot_606040(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetRestoreFromClusterSnapshot_606039(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a new cluster from a snapshot. By default, Amazon Redshift creates the resulting cluster with the same configuration as the original cluster from which the snapshot was created, except that the new cluster is created with the default cluster security and parameter groups. After Amazon Redshift creates the cluster, you can use the <a>ModifyCluster</a> API to associate a different security group and different parameter group with the restored cluster. If you are using a DS node type, you can also choose to change to another DS node type of the same size during restore.</p> <p>If you restore a cluster into a VPC, you must provide a cluster subnet group where you want the cluster restored.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ClusterSecurityGroups: JArray
  ##                        : <p>A list of security groups to be associated with this cluster.</p> <p>Default: The default cluster security group for Amazon Redshift.</p> <p>Cluster security groups only apply to clusters outside of VPCs.</p>
  ##   ClusterSubnetGroupName: JString
  ##                         : <p>The name of the subnet group where you want to cluster restored.</p> <p>A snapshot of cluster in VPC can be restored only in VPC. Therefore, you must provide subnet group name where you want the cluster restored.</p>
  ##   HsmClientCertificateIdentifier: JString
  ##                                 : Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM.
  ##   PreferredMaintenanceWindow: JString
  ##                             : <p>The weekly time range (in UTC) during which automated cluster maintenance can occur.</p> <p> Format: <code>ddd:hh24:mi-ddd:hh24:mi</code> </p> <p> Default: The value selected for the cluster from which the snapshot was taken. For more information about the time blocks for each region, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-maintenance-windows">Maintenance Windows</a> in Amazon Redshift Cluster Management Guide. </p> <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p> <p>Constraints: Minimum 30-minute window.</p>
  ##   MaintenanceTrackName: JString
  ##                       : The name of the maintenance track for the restored cluster. When you take a snapshot, the snapshot inherits the <code>MaintenanceTrack</code> value from the cluster. The snapshot might be on a different track than the cluster that was the source for the snapshot. For example, suppose that you take a snapshot of a cluster that is on the current track and then change the cluster to be on the trailing track. In this case, the snapshot and the source cluster are on different tracks.
  ##   IamRoles: JArray
  ##           : <p>A list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services. You must supply the IAM roles in their Amazon Resource Name (ARN) format. You can supply up to 10 IAM roles in a single request.</p> <p>A cluster can have up to 10 IAM roles associated at any time.</p>
  ##   AvailabilityZone: JString
  ##                   : <p>The Amazon EC2 Availability Zone in which to restore the cluster.</p> <p>Default: A random, system-chosen Availability Zone.</p> <p>Example: <code>us-east-1a</code> </p>
  ##   AllowVersionUpgrade: JBool
  ##                      : <p>If <code>true</code>, major version upgrades can be applied during the maintenance window to the Amazon Redshift engine that is running on the cluster. </p> <p>Default: <code>true</code> </p>
  ##   EnhancedVpcRouting: JBool
  ##                     : <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p> <p>Default: false</p>
  ##   VpcSecurityGroupIds: JArray
  ##                      : <p>A list of Virtual Private Cloud (VPC) security groups to be associated with the cluster.</p> <p>Default: The default VPC security group is associated with the cluster.</p> <p>VPC security groups only apply to clusters in VPCs.</p>
  ##   ClusterParameterGroupName: JString
  ##                            : <p>The name of the parameter group to be associated with this cluster.</p> <p>Default: The default Amazon Redshift cluster parameter group. For information about the default parameter group, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Working with Amazon Redshift Parameter Groups</a>.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   HsmConfigurationIdentifier: JString
  ##                             : Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
  ##   SnapshotScheduleIdentifier: JString
  ##                             : A unique identifier for the snapshot schedule.
  ##   AdditionalInfo: JString
  ##                 : Reserved.
  ##   ElasticIp: JString
  ##            : The elastic IP (EIP) address for the cluster.
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The identifier of the cluster that will be created from restoring the snapshot.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul>
  ##   OwnerAccount: JString
  ##               : The AWS customer account used to create or copy the snapshot. Required if you are restoring a snapshot you do not own, optional if you own the snapshot.
  ##   Action: JString (required)
  ##   KmsKeyId: JString
  ##           : The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster that you restore from a shared snapshot.
  ##   PubliclyAccessible: JBool
  ##                     : If <code>true</code>, the cluster can be accessed from a public network. 
  ##   SnapshotClusterIdentifier: JString
  ##                            : The name of the cluster the source snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.
  ##   Port: JInt
  ##       : <p>The port number on which the cluster accepts connections.</p> <p>Default: The same port as the original cluster.</p> <p>Constraints: Must be between <code>1115</code> and <code>65535</code>.</p>
  ##   NumberOfNodes: JInt
  ##                : The number of nodes specified when provisioning the restored cluster.
  ##   SnapshotIdentifier: JString (required)
  ##                     : <p>The name of the snapshot from which to create the new cluster. This parameter isn't case sensitive.</p> <p>Example: <code>my-snapshot-id</code> </p>
  ##   AutomatedSnapshotRetentionPeriod: JInt
  ##                                   : <p>The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p> <p>Default: The value selected for the cluster from which the snapshot was taken.</p> <p>Constraints: Must be a value from 0 to 35.</p>
  ##   NodeType: JString
  ##           : <p>The node type that the restored cluster will be provisioned with.</p> <p>Default: The node type of the cluster from which the snapshot was taken. You can modify this if you are using any DS node type. In that case, you can choose to restore into another DS node type of the same size. For example, you can restore ds1.8xlarge into ds2.8xlarge, or ds1.xlarge into ds2.xlarge. If you have a DC instance type, you must restore into that same instance type and size. In other words, you can only restore a dc1.large instance type into another dc1.large instance type or dc2.large instance type. You can't restore dc1.8xlarge to dc2.8xlarge. First restore to a dc1.8xlareg cluster, then resize to a dc2.8large cluster. For more information about node types, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-about-clusters-and-nodes"> About Clusters and Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ##   Version: JString (required)
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The default number of days to retain a manual snapshot. If the value is -1, the snapshot is retained indefinitely. This setting doesn't change the retention period of existing snapshots.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  section = newJObject()
  var valid_606041 = query.getOrDefault("ClusterSecurityGroups")
  valid_606041 = validateParameter(valid_606041, JArray, required = false,
                                 default = nil)
  if valid_606041 != nil:
    section.add "ClusterSecurityGroups", valid_606041
  var valid_606042 = query.getOrDefault("ClusterSubnetGroupName")
  valid_606042 = validateParameter(valid_606042, JString, required = false,
                                 default = nil)
  if valid_606042 != nil:
    section.add "ClusterSubnetGroupName", valid_606042
  var valid_606043 = query.getOrDefault("HsmClientCertificateIdentifier")
  valid_606043 = validateParameter(valid_606043, JString, required = false,
                                 default = nil)
  if valid_606043 != nil:
    section.add "HsmClientCertificateIdentifier", valid_606043
  var valid_606044 = query.getOrDefault("PreferredMaintenanceWindow")
  valid_606044 = validateParameter(valid_606044, JString, required = false,
                                 default = nil)
  if valid_606044 != nil:
    section.add "PreferredMaintenanceWindow", valid_606044
  var valid_606045 = query.getOrDefault("MaintenanceTrackName")
  valid_606045 = validateParameter(valid_606045, JString, required = false,
                                 default = nil)
  if valid_606045 != nil:
    section.add "MaintenanceTrackName", valid_606045
  var valid_606046 = query.getOrDefault("IamRoles")
  valid_606046 = validateParameter(valid_606046, JArray, required = false,
                                 default = nil)
  if valid_606046 != nil:
    section.add "IamRoles", valid_606046
  var valid_606047 = query.getOrDefault("AvailabilityZone")
  valid_606047 = validateParameter(valid_606047, JString, required = false,
                                 default = nil)
  if valid_606047 != nil:
    section.add "AvailabilityZone", valid_606047
  var valid_606048 = query.getOrDefault("AllowVersionUpgrade")
  valid_606048 = validateParameter(valid_606048, JBool, required = false, default = nil)
  if valid_606048 != nil:
    section.add "AllowVersionUpgrade", valid_606048
  var valid_606049 = query.getOrDefault("EnhancedVpcRouting")
  valid_606049 = validateParameter(valid_606049, JBool, required = false, default = nil)
  if valid_606049 != nil:
    section.add "EnhancedVpcRouting", valid_606049
  var valid_606050 = query.getOrDefault("VpcSecurityGroupIds")
  valid_606050 = validateParameter(valid_606050, JArray, required = false,
                                 default = nil)
  if valid_606050 != nil:
    section.add "VpcSecurityGroupIds", valid_606050
  var valid_606051 = query.getOrDefault("ClusterParameterGroupName")
  valid_606051 = validateParameter(valid_606051, JString, required = false,
                                 default = nil)
  if valid_606051 != nil:
    section.add "ClusterParameterGroupName", valid_606051
  var valid_606052 = query.getOrDefault("HsmConfigurationIdentifier")
  valid_606052 = validateParameter(valid_606052, JString, required = false,
                                 default = nil)
  if valid_606052 != nil:
    section.add "HsmConfigurationIdentifier", valid_606052
  var valid_606053 = query.getOrDefault("SnapshotScheduleIdentifier")
  valid_606053 = validateParameter(valid_606053, JString, required = false,
                                 default = nil)
  if valid_606053 != nil:
    section.add "SnapshotScheduleIdentifier", valid_606053
  var valid_606054 = query.getOrDefault("AdditionalInfo")
  valid_606054 = validateParameter(valid_606054, JString, required = false,
                                 default = nil)
  if valid_606054 != nil:
    section.add "AdditionalInfo", valid_606054
  var valid_606055 = query.getOrDefault("ElasticIp")
  valid_606055 = validateParameter(valid_606055, JString, required = false,
                                 default = nil)
  if valid_606055 != nil:
    section.add "ElasticIp", valid_606055
  assert query != nil,
        "query argument is necessary due to required `ClusterIdentifier` field"
  var valid_606056 = query.getOrDefault("ClusterIdentifier")
  valid_606056 = validateParameter(valid_606056, JString, required = true,
                                 default = nil)
  if valid_606056 != nil:
    section.add "ClusterIdentifier", valid_606056
  var valid_606057 = query.getOrDefault("OwnerAccount")
  valid_606057 = validateParameter(valid_606057, JString, required = false,
                                 default = nil)
  if valid_606057 != nil:
    section.add "OwnerAccount", valid_606057
  var valid_606058 = query.getOrDefault("Action")
  valid_606058 = validateParameter(valid_606058, JString, required = true, default = newJString(
      "RestoreFromClusterSnapshot"))
  if valid_606058 != nil:
    section.add "Action", valid_606058
  var valid_606059 = query.getOrDefault("KmsKeyId")
  valid_606059 = validateParameter(valid_606059, JString, required = false,
                                 default = nil)
  if valid_606059 != nil:
    section.add "KmsKeyId", valid_606059
  var valid_606060 = query.getOrDefault("PubliclyAccessible")
  valid_606060 = validateParameter(valid_606060, JBool, required = false, default = nil)
  if valid_606060 != nil:
    section.add "PubliclyAccessible", valid_606060
  var valid_606061 = query.getOrDefault("SnapshotClusterIdentifier")
  valid_606061 = validateParameter(valid_606061, JString, required = false,
                                 default = nil)
  if valid_606061 != nil:
    section.add "SnapshotClusterIdentifier", valid_606061
  var valid_606062 = query.getOrDefault("Port")
  valid_606062 = validateParameter(valid_606062, JInt, required = false, default = nil)
  if valid_606062 != nil:
    section.add "Port", valid_606062
  var valid_606063 = query.getOrDefault("NumberOfNodes")
  valid_606063 = validateParameter(valid_606063, JInt, required = false, default = nil)
  if valid_606063 != nil:
    section.add "NumberOfNodes", valid_606063
  var valid_606064 = query.getOrDefault("SnapshotIdentifier")
  valid_606064 = validateParameter(valid_606064, JString, required = true,
                                 default = nil)
  if valid_606064 != nil:
    section.add "SnapshotIdentifier", valid_606064
  var valid_606065 = query.getOrDefault("AutomatedSnapshotRetentionPeriod")
  valid_606065 = validateParameter(valid_606065, JInt, required = false, default = nil)
  if valid_606065 != nil:
    section.add "AutomatedSnapshotRetentionPeriod", valid_606065
  var valid_606066 = query.getOrDefault("NodeType")
  valid_606066 = validateParameter(valid_606066, JString, required = false,
                                 default = nil)
  if valid_606066 != nil:
    section.add "NodeType", valid_606066
  var valid_606067 = query.getOrDefault("Version")
  valid_606067 = validateParameter(valid_606067, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_606067 != nil:
    section.add "Version", valid_606067
  var valid_606068 = query.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_606068 = validateParameter(valid_606068, JInt, required = false, default = nil)
  if valid_606068 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_606068
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_606069 = header.getOrDefault("X-Amz-Date")
  valid_606069 = validateParameter(valid_606069, JString, required = false,
                                 default = nil)
  if valid_606069 != nil:
    section.add "X-Amz-Date", valid_606069
  var valid_606070 = header.getOrDefault("X-Amz-Security-Token")
  valid_606070 = validateParameter(valid_606070, JString, required = false,
                                 default = nil)
  if valid_606070 != nil:
    section.add "X-Amz-Security-Token", valid_606070
  var valid_606071 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_606071 = validateParameter(valid_606071, JString, required = false,
                                 default = nil)
  if valid_606071 != nil:
    section.add "X-Amz-Content-Sha256", valid_606071
  var valid_606072 = header.getOrDefault("X-Amz-Algorithm")
  valid_606072 = validateParameter(valid_606072, JString, required = false,
                                 default = nil)
  if valid_606072 != nil:
    section.add "X-Amz-Algorithm", valid_606072
  var valid_606073 = header.getOrDefault("X-Amz-Signature")
  valid_606073 = validateParameter(valid_606073, JString, required = false,
                                 default = nil)
  if valid_606073 != nil:
    section.add "X-Amz-Signature", valid_606073
  var valid_606074 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_606074 = validateParameter(valid_606074, JString, required = false,
                                 default = nil)
  if valid_606074 != nil:
    section.add "X-Amz-SignedHeaders", valid_606074
  var valid_606075 = header.getOrDefault("X-Amz-Credential")
  valid_606075 = validateParameter(valid_606075, JString, required = false,
                                 default = nil)
  if valid_606075 != nil:
    section.add "X-Amz-Credential", valid_606075
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_606076: Call_GetRestoreFromClusterSnapshot_606038; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a new cluster from a snapshot. By default, Amazon Redshift creates the resulting cluster with the same configuration as the original cluster from which the snapshot was created, except that the new cluster is created with the default cluster security and parameter groups. After Amazon Redshift creates the cluster, you can use the <a>ModifyCluster</a> API to associate a different security group and different parameter group with the restored cluster. If you are using a DS node type, you can also choose to change to another DS node type of the same size during restore.</p> <p>If you restore a cluster into a VPC, you must provide a cluster subnet group where you want the cluster restored.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_606076.validator(path, query, header, formData, body)
  let scheme = call_606076.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_606076.url(scheme.get, call_606076.host, call_606076.base,
                         call_606076.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_606076, url, valid)

proc call*(call_606077: Call_GetRestoreFromClusterSnapshot_606038;
          ClusterIdentifier: string; SnapshotIdentifier: string;
          ClusterSecurityGroups: JsonNode = nil;
          ClusterSubnetGroupName: string = "";
          HsmClientCertificateIdentifier: string = "";
          PreferredMaintenanceWindow: string = "";
          MaintenanceTrackName: string = ""; IamRoles: JsonNode = nil;
          AvailabilityZone: string = ""; AllowVersionUpgrade: bool = false;
          EnhancedVpcRouting: bool = false; VpcSecurityGroupIds: JsonNode = nil;
          ClusterParameterGroupName: string = "";
          HsmConfigurationIdentifier: string = "";
          SnapshotScheduleIdentifier: string = ""; AdditionalInfo: string = "";
          ElasticIp: string = ""; OwnerAccount: string = "";
          Action: string = "RestoreFromClusterSnapshot"; KmsKeyId: string = "";
          PubliclyAccessible: bool = false; SnapshotClusterIdentifier: string = "";
          Port: int = 0; NumberOfNodes: int = 0;
          AutomatedSnapshotRetentionPeriod: int = 0; NodeType: string = "";
          Version: string = "2012-12-01"; ManualSnapshotRetentionPeriod: int = 0): Recallable =
  ## getRestoreFromClusterSnapshot
  ## <p>Creates a new cluster from a snapshot. By default, Amazon Redshift creates the resulting cluster with the same configuration as the original cluster from which the snapshot was created, except that the new cluster is created with the default cluster security and parameter groups. After Amazon Redshift creates the cluster, you can use the <a>ModifyCluster</a> API to associate a different security group and different parameter group with the restored cluster. If you are using a DS node type, you can also choose to change to another DS node type of the same size during restore.</p> <p>If you restore a cluster into a VPC, you must provide a cluster subnet group where you want the cluster restored.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   ClusterSecurityGroups: JArray
  ##                        : <p>A list of security groups to be associated with this cluster.</p> <p>Default: The default cluster security group for Amazon Redshift.</p> <p>Cluster security groups only apply to clusters outside of VPCs.</p>
  ##   ClusterSubnetGroupName: string
  ##                         : <p>The name of the subnet group where you want to cluster restored.</p> <p>A snapshot of cluster in VPC can be restored only in VPC. Therefore, you must provide subnet group name where you want the cluster restored.</p>
  ##   HsmClientCertificateIdentifier: string
  ##                                 : Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM.
  ##   PreferredMaintenanceWindow: string
  ##                             : <p>The weekly time range (in UTC) during which automated cluster maintenance can occur.</p> <p> Format: <code>ddd:hh24:mi-ddd:hh24:mi</code> </p> <p> Default: The value selected for the cluster from which the snapshot was taken. For more information about the time blocks for each region, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-maintenance-windows">Maintenance Windows</a> in Amazon Redshift Cluster Management Guide. </p> <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p> <p>Constraints: Minimum 30-minute window.</p>
  ##   MaintenanceTrackName: string
  ##                       : The name of the maintenance track for the restored cluster. When you take a snapshot, the snapshot inherits the <code>MaintenanceTrack</code> value from the cluster. The snapshot might be on a different track than the cluster that was the source for the snapshot. For example, suppose that you take a snapshot of a cluster that is on the current track and then change the cluster to be on the trailing track. In this case, the snapshot and the source cluster are on different tracks.
  ##   IamRoles: JArray
  ##           : <p>A list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services. You must supply the IAM roles in their Amazon Resource Name (ARN) format. You can supply up to 10 IAM roles in a single request.</p> <p>A cluster can have up to 10 IAM roles associated at any time.</p>
  ##   AvailabilityZone: string
  ##                   : <p>The Amazon EC2 Availability Zone in which to restore the cluster.</p> <p>Default: A random, system-chosen Availability Zone.</p> <p>Example: <code>us-east-1a</code> </p>
  ##   AllowVersionUpgrade: bool
  ##                      : <p>If <code>true</code>, major version upgrades can be applied during the maintenance window to the Amazon Redshift engine that is running on the cluster. </p> <p>Default: <code>true</code> </p>
  ##   EnhancedVpcRouting: bool
  ##                     : <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p> <p>Default: false</p>
  ##   VpcSecurityGroupIds: JArray
  ##                      : <p>A list of Virtual Private Cloud (VPC) security groups to be associated with the cluster.</p> <p>Default: The default VPC security group is associated with the cluster.</p> <p>VPC security groups only apply to clusters in VPCs.</p>
  ##   ClusterParameterGroupName: string
  ##                            : <p>The name of the parameter group to be associated with this cluster.</p> <p>Default: The default Amazon Redshift cluster parameter group. For information about the default parameter group, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Working with Amazon Redshift Parameter Groups</a>.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   HsmConfigurationIdentifier: string
  ##                             : Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
  ##   SnapshotScheduleIdentifier: string
  ##                             : A unique identifier for the snapshot schedule.
  ##   AdditionalInfo: string
  ##                 : Reserved.
  ##   ElasticIp: string
  ##            : The elastic IP (EIP) address for the cluster.
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The identifier of the cluster that will be created from restoring the snapshot.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul>
  ##   OwnerAccount: string
  ##               : The AWS customer account used to create or copy the snapshot. Required if you are restoring a snapshot you do not own, optional if you own the snapshot.
  ##   Action: string (required)
  ##   KmsKeyId: string
  ##           : The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster that you restore from a shared snapshot.
  ##   PubliclyAccessible: bool
  ##                     : If <code>true</code>, the cluster can be accessed from a public network. 
  ##   SnapshotClusterIdentifier: string
  ##                            : The name of the cluster the source snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.
  ##   Port: int
  ##       : <p>The port number on which the cluster accepts connections.</p> <p>Default: The same port as the original cluster.</p> <p>Constraints: Must be between <code>1115</code> and <code>65535</code>.</p>
  ##   NumberOfNodes: int
  ##                : The number of nodes specified when provisioning the restored cluster.
  ##   SnapshotIdentifier: string (required)
  ##                     : <p>The name of the snapshot from which to create the new cluster. This parameter isn't case sensitive.</p> <p>Example: <code>my-snapshot-id</code> </p>
  ##   AutomatedSnapshotRetentionPeriod: int
  ##                                   : <p>The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p> <p>Default: The value selected for the cluster from which the snapshot was taken.</p> <p>Constraints: Must be a value from 0 to 35.</p>
  ##   NodeType: string
  ##           : <p>The node type that the restored cluster will be provisioned with.</p> <p>Default: The node type of the cluster from which the snapshot was taken. You can modify this if you are using any DS node type. In that case, you can choose to restore into another DS node type of the same size. For example, you can restore ds1.8xlarge into ds2.8xlarge, or ds1.xlarge into ds2.xlarge. If you have a DC instance type, you must restore into that same instance type and size. In other words, you can only restore a dc1.large instance type into another dc1.large instance type or dc2.large instance type. You can't restore dc1.8xlarge to dc2.8xlarge. First restore to a dc1.8xlareg cluster, then resize to a dc2.8large cluster. For more information about node types, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-about-clusters-and-nodes"> About Clusters and Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ##   Version: string (required)
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The default number of days to retain a manual snapshot. If the value is -1, the snapshot is retained indefinitely. This setting doesn't change the retention period of existing snapshots.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  var query_606078 = newJObject()
  if ClusterSecurityGroups != nil:
    query_606078.add "ClusterSecurityGroups", ClusterSecurityGroups
  add(query_606078, "ClusterSubnetGroupName", newJString(ClusterSubnetGroupName))
  add(query_606078, "HsmClientCertificateIdentifier",
      newJString(HsmClientCertificateIdentifier))
  add(query_606078, "PreferredMaintenanceWindow",
      newJString(PreferredMaintenanceWindow))
  add(query_606078, "MaintenanceTrackName", newJString(MaintenanceTrackName))
  if IamRoles != nil:
    query_606078.add "IamRoles", IamRoles
  add(query_606078, "AvailabilityZone", newJString(AvailabilityZone))
  add(query_606078, "AllowVersionUpgrade", newJBool(AllowVersionUpgrade))
  add(query_606078, "EnhancedVpcRouting", newJBool(EnhancedVpcRouting))
  if VpcSecurityGroupIds != nil:
    query_606078.add "VpcSecurityGroupIds", VpcSecurityGroupIds
  add(query_606078, "ClusterParameterGroupName",
      newJString(ClusterParameterGroupName))
  add(query_606078, "HsmConfigurationIdentifier",
      newJString(HsmConfigurationIdentifier))
  add(query_606078, "SnapshotScheduleIdentifier",
      newJString(SnapshotScheduleIdentifier))
  add(query_606078, "AdditionalInfo", newJString(AdditionalInfo))
  add(query_606078, "ElasticIp", newJString(ElasticIp))
  add(query_606078, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_606078, "OwnerAccount", newJString(OwnerAccount))
  add(query_606078, "Action", newJString(Action))
  add(query_606078, "KmsKeyId", newJString(KmsKeyId))
  add(query_606078, "PubliclyAccessible", newJBool(PubliclyAccessible))
  add(query_606078, "SnapshotClusterIdentifier",
      newJString(SnapshotClusterIdentifier))
  add(query_606078, "Port", newJInt(Port))
  add(query_606078, "NumberOfNodes", newJInt(NumberOfNodes))
  add(query_606078, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_606078, "AutomatedSnapshotRetentionPeriod",
      newJInt(AutomatedSnapshotRetentionPeriod))
  add(query_606078, "NodeType", newJString(NodeType))
  add(query_606078, "Version", newJString(Version))
  add(query_606078, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  result = call_606077.call(nil, query_606078, nil, nil, nil)

var getRestoreFromClusterSnapshot* = Call_GetRestoreFromClusterSnapshot_606038(
    name: "getRestoreFromClusterSnapshot", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=RestoreFromClusterSnapshot",
    validator: validate_GetRestoreFromClusterSnapshot_606039, base: "/",
    url: url_GetRestoreFromClusterSnapshot_606040,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostRestoreTableFromClusterSnapshot_606144 = ref object of OpenApiRestCall_602450
proc url_PostRestoreTableFromClusterSnapshot_606146(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostRestoreTableFromClusterSnapshot_606145(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a new table from a table in an Amazon Redshift cluster snapshot. You must create the new table within the Amazon Redshift cluster that the snapshot was taken from.</p> <p>You cannot use <code>RestoreTableFromClusterSnapshot</code> to restore a table with the same name as an existing table in an Amazon Redshift cluster. That is, you cannot overwrite an existing table in a cluster with a restored table. If you want to replace your original table with a new, restored table, then rename or drop your original table before you call <code>RestoreTableFromClusterSnapshot</code>. When you have renamed your original table, then you can pass the original name of the table as the <code>NewTableName</code> parameter value in the call to <code>RestoreTableFromClusterSnapshot</code>. This way, you can replace the original table with the table created from the snapshot.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_606147 = query.getOrDefault("Action")
  valid_606147 = validateParameter(valid_606147, JString, required = true, default = newJString(
      "RestoreTableFromClusterSnapshot"))
  if valid_606147 != nil:
    section.add "Action", valid_606147
  var valid_606148 = query.getOrDefault("Version")
  valid_606148 = validateParameter(valid_606148, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_606148 != nil:
    section.add "Version", valid_606148
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_606149 = header.getOrDefault("X-Amz-Date")
  valid_606149 = validateParameter(valid_606149, JString, required = false,
                                 default = nil)
  if valid_606149 != nil:
    section.add "X-Amz-Date", valid_606149
  var valid_606150 = header.getOrDefault("X-Amz-Security-Token")
  valid_606150 = validateParameter(valid_606150, JString, required = false,
                                 default = nil)
  if valid_606150 != nil:
    section.add "X-Amz-Security-Token", valid_606150
  var valid_606151 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_606151 = validateParameter(valid_606151, JString, required = false,
                                 default = nil)
  if valid_606151 != nil:
    section.add "X-Amz-Content-Sha256", valid_606151
  var valid_606152 = header.getOrDefault("X-Amz-Algorithm")
  valid_606152 = validateParameter(valid_606152, JString, required = false,
                                 default = nil)
  if valid_606152 != nil:
    section.add "X-Amz-Algorithm", valid_606152
  var valid_606153 = header.getOrDefault("X-Amz-Signature")
  valid_606153 = validateParameter(valid_606153, JString, required = false,
                                 default = nil)
  if valid_606153 != nil:
    section.add "X-Amz-Signature", valid_606153
  var valid_606154 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_606154 = validateParameter(valid_606154, JString, required = false,
                                 default = nil)
  if valid_606154 != nil:
    section.add "X-Amz-SignedHeaders", valid_606154
  var valid_606155 = header.getOrDefault("X-Amz-Credential")
  valid_606155 = validateParameter(valid_606155, JString, required = false,
                                 default = nil)
  if valid_606155 != nil:
    section.add "X-Amz-Credential", valid_606155
  result.add "header", section
  ## parameters in `formData` object:
  ##   SourceSchemaName: JString
  ##                   : The name of the source schema that contains the table to restore from. If you do not specify a <code>SourceSchemaName</code> value, the default is <code>public</code>.
  ##   SourceDatabaseName: JString (required)
  ##                     : The name of the source database that contains the table to restore from.
  ##   SourceTableName: JString (required)
  ##                  : The name of the source table to restore from.
  ##   ClusterIdentifier: JString (required)
  ##                    : The identifier of the Amazon Redshift cluster to restore the table to.
  ##   TargetDatabaseName: JString
  ##                     : The name of the database to restore the table to.
  ##   SnapshotIdentifier: JString (required)
  ##                     : The identifier of the snapshot to restore the table from. This snapshot must have been created from the Amazon Redshift cluster specified by the <code>ClusterIdentifier</code> parameter.
  ##   TargetSchemaName: JString
  ##                   : The name of the schema to restore the table to.
  ##   NewTableName: JString (required)
  ##               : The name of the table to create as a result of the current request.
  section = newJObject()
  var valid_606156 = formData.getOrDefault("SourceSchemaName")
  valid_606156 = validateParameter(valid_606156, JString, required = false,
                                 default = nil)
  if valid_606156 != nil:
    section.add "SourceSchemaName", valid_606156
  assert formData != nil, "formData argument is necessary due to required `SourceDatabaseName` field"
  var valid_606157 = formData.getOrDefault("SourceDatabaseName")
  valid_606157 = validateParameter(valid_606157, JString, required = true,
                                 default = nil)
  if valid_606157 != nil:
    section.add "SourceDatabaseName", valid_606157
  var valid_606158 = formData.getOrDefault("SourceTableName")
  valid_606158 = validateParameter(valid_606158, JString, required = true,
                                 default = nil)
  if valid_606158 != nil:
    section.add "SourceTableName", valid_606158
  var valid_606159 = formData.getOrDefault("ClusterIdentifier")
  valid_606159 = validateParameter(valid_606159, JString, required = true,
                                 default = nil)
  if valid_606159 != nil:
    section.add "ClusterIdentifier", valid_606159
  var valid_606160 = formData.getOrDefault("TargetDatabaseName")
  valid_606160 = validateParameter(valid_606160, JString, required = false,
                                 default = nil)
  if valid_606160 != nil:
    section.add "TargetDatabaseName", valid_606160
  var valid_606161 = formData.getOrDefault("SnapshotIdentifier")
  valid_606161 = validateParameter(valid_606161, JString, required = true,
                                 default = nil)
  if valid_606161 != nil:
    section.add "SnapshotIdentifier", valid_606161
  var valid_606162 = formData.getOrDefault("TargetSchemaName")
  valid_606162 = validateParameter(valid_606162, JString, required = false,
                                 default = nil)
  if valid_606162 != nil:
    section.add "TargetSchemaName", valid_606162
  var valid_606163 = formData.getOrDefault("NewTableName")
  valid_606163 = validateParameter(valid_606163, JString, required = true,
                                 default = nil)
  if valid_606163 != nil:
    section.add "NewTableName", valid_606163
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_606164: Call_PostRestoreTableFromClusterSnapshot_606144;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Creates a new table from a table in an Amazon Redshift cluster snapshot. You must create the new table within the Amazon Redshift cluster that the snapshot was taken from.</p> <p>You cannot use <code>RestoreTableFromClusterSnapshot</code> to restore a table with the same name as an existing table in an Amazon Redshift cluster. That is, you cannot overwrite an existing table in a cluster with a restored table. If you want to replace your original table with a new, restored table, then rename or drop your original table before you call <code>RestoreTableFromClusterSnapshot</code>. When you have renamed your original table, then you can pass the original name of the table as the <code>NewTableName</code> parameter value in the call to <code>RestoreTableFromClusterSnapshot</code>. This way, you can replace the original table with the table created from the snapshot.</p>
  ## 
  let valid = call_606164.validator(path, query, header, formData, body)
  let scheme = call_606164.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_606164.url(scheme.get, call_606164.host, call_606164.base,
                         call_606164.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_606164, url, valid)

proc call*(call_606165: Call_PostRestoreTableFromClusterSnapshot_606144;
          SourceDatabaseName: string; SourceTableName: string;
          ClusterIdentifier: string; SnapshotIdentifier: string;
          NewTableName: string; SourceSchemaName: string = "";
          Action: string = "RestoreTableFromClusterSnapshot";
          TargetDatabaseName: string = ""; TargetSchemaName: string = "";
          Version: string = "2012-12-01"): Recallable =
  ## postRestoreTableFromClusterSnapshot
  ## <p>Creates a new table from a table in an Amazon Redshift cluster snapshot. You must create the new table within the Amazon Redshift cluster that the snapshot was taken from.</p> <p>You cannot use <code>RestoreTableFromClusterSnapshot</code> to restore a table with the same name as an existing table in an Amazon Redshift cluster. That is, you cannot overwrite an existing table in a cluster with a restored table. If you want to replace your original table with a new, restored table, then rename or drop your original table before you call <code>RestoreTableFromClusterSnapshot</code>. When you have renamed your original table, then you can pass the original name of the table as the <code>NewTableName</code> parameter value in the call to <code>RestoreTableFromClusterSnapshot</code>. This way, you can replace the original table with the table created from the snapshot.</p>
  ##   SourceSchemaName: string
  ##                   : The name of the source schema that contains the table to restore from. If you do not specify a <code>SourceSchemaName</code> value, the default is <code>public</code>.
  ##   SourceDatabaseName: string (required)
  ##                     : The name of the source database that contains the table to restore from.
  ##   SourceTableName: string (required)
  ##                  : The name of the source table to restore from.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : The identifier of the Amazon Redshift cluster to restore the table to.
  ##   TargetDatabaseName: string
  ##                     : The name of the database to restore the table to.
  ##   SnapshotIdentifier: string (required)
  ##                     : The identifier of the snapshot to restore the table from. This snapshot must have been created from the Amazon Redshift cluster specified by the <code>ClusterIdentifier</code> parameter.
  ##   TargetSchemaName: string
  ##                   : The name of the schema to restore the table to.
  ##   NewTableName: string (required)
  ##               : The name of the table to create as a result of the current request.
  ##   Version: string (required)
  var query_606166 = newJObject()
  var formData_606167 = newJObject()
  add(formData_606167, "SourceSchemaName", newJString(SourceSchemaName))
  add(formData_606167, "SourceDatabaseName", newJString(SourceDatabaseName))
  add(formData_606167, "SourceTableName", newJString(SourceTableName))
  add(query_606166, "Action", newJString(Action))
  add(formData_606167, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_606167, "TargetDatabaseName", newJString(TargetDatabaseName))
  add(formData_606167, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(formData_606167, "TargetSchemaName", newJString(TargetSchemaName))
  add(formData_606167, "NewTableName", newJString(NewTableName))
  add(query_606166, "Version", newJString(Version))
  result = call_606165.call(nil, query_606166, nil, formData_606167, nil)

var postRestoreTableFromClusterSnapshot* = Call_PostRestoreTableFromClusterSnapshot_606144(
    name: "postRestoreTableFromClusterSnapshot", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=RestoreTableFromClusterSnapshot",
    validator: validate_PostRestoreTableFromClusterSnapshot_606145, base: "/",
    url: url_PostRestoreTableFromClusterSnapshot_606146,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetRestoreTableFromClusterSnapshot_606121 = ref object of OpenApiRestCall_602450
proc url_GetRestoreTableFromClusterSnapshot_606123(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetRestoreTableFromClusterSnapshot_606122(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a new table from a table in an Amazon Redshift cluster snapshot. You must create the new table within the Amazon Redshift cluster that the snapshot was taken from.</p> <p>You cannot use <code>RestoreTableFromClusterSnapshot</code> to restore a table with the same name as an existing table in an Amazon Redshift cluster. That is, you cannot overwrite an existing table in a cluster with a restored table. If you want to replace your original table with a new, restored table, then rename or drop your original table before you call <code>RestoreTableFromClusterSnapshot</code>. When you have renamed your original table, then you can pass the original name of the table as the <code>NewTableName</code> parameter value in the call to <code>RestoreTableFromClusterSnapshot</code>. This way, you can replace the original table with the table created from the snapshot.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   SourceDatabaseName: JString (required)
  ##                     : The name of the source database that contains the table to restore from.
  ##   SourceTableName: JString (required)
  ##                  : The name of the source table to restore from.
  ##   SourceSchemaName: JString
  ##                   : The name of the source schema that contains the table to restore from. If you do not specify a <code>SourceSchemaName</code> value, the default is <code>public</code>.
  ##   ClusterIdentifier: JString (required)
  ##                    : The identifier of the Amazon Redshift cluster to restore the table to.
  ##   Action: JString (required)
  ##   TargetDatabaseName: JString
  ##                     : The name of the database to restore the table to.
  ##   NewTableName: JString (required)
  ##               : The name of the table to create as a result of the current request.
  ##   SnapshotIdentifier: JString (required)
  ##                     : The identifier of the snapshot to restore the table from. This snapshot must have been created from the Amazon Redshift cluster specified by the <code>ClusterIdentifier</code> parameter.
  ##   Version: JString (required)
  ##   TargetSchemaName: JString
  ##                   : The name of the schema to restore the table to.
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `SourceDatabaseName` field"
  var valid_606124 = query.getOrDefault("SourceDatabaseName")
  valid_606124 = validateParameter(valid_606124, JString, required = true,
                                 default = nil)
  if valid_606124 != nil:
    section.add "SourceDatabaseName", valid_606124
  var valid_606125 = query.getOrDefault("SourceTableName")
  valid_606125 = validateParameter(valid_606125, JString, required = true,
                                 default = nil)
  if valid_606125 != nil:
    section.add "SourceTableName", valid_606125
  var valid_606126 = query.getOrDefault("SourceSchemaName")
  valid_606126 = validateParameter(valid_606126, JString, required = false,
                                 default = nil)
  if valid_606126 != nil:
    section.add "SourceSchemaName", valid_606126
  var valid_606127 = query.getOrDefault("ClusterIdentifier")
  valid_606127 = validateParameter(valid_606127, JString, required = true,
                                 default = nil)
  if valid_606127 != nil:
    section.add "ClusterIdentifier", valid_606127
  var valid_606128 = query.getOrDefault("Action")
  valid_606128 = validateParameter(valid_606128, JString, required = true, default = newJString(
      "RestoreTableFromClusterSnapshot"))
  if valid_606128 != nil:
    section.add "Action", valid_606128
  var valid_606129 = query.getOrDefault("TargetDatabaseName")
  valid_606129 = validateParameter(valid_606129, JString, required = false,
                                 default = nil)
  if valid_606129 != nil:
    section.add "TargetDatabaseName", valid_606129
  var valid_606130 = query.getOrDefault("NewTableName")
  valid_606130 = validateParameter(valid_606130, JString, required = true,
                                 default = nil)
  if valid_606130 != nil:
    section.add "NewTableName", valid_606130
  var valid_606131 = query.getOrDefault("SnapshotIdentifier")
  valid_606131 = validateParameter(valid_606131, JString, required = true,
                                 default = nil)
  if valid_606131 != nil:
    section.add "SnapshotIdentifier", valid_606131
  var valid_606132 = query.getOrDefault("Version")
  valid_606132 = validateParameter(valid_606132, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_606132 != nil:
    section.add "Version", valid_606132
  var valid_606133 = query.getOrDefault("TargetSchemaName")
  valid_606133 = validateParameter(valid_606133, JString, required = false,
                                 default = nil)
  if valid_606133 != nil:
    section.add "TargetSchemaName", valid_606133
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_606134 = header.getOrDefault("X-Amz-Date")
  valid_606134 = validateParameter(valid_606134, JString, required = false,
                                 default = nil)
  if valid_606134 != nil:
    section.add "X-Amz-Date", valid_606134
  var valid_606135 = header.getOrDefault("X-Amz-Security-Token")
  valid_606135 = validateParameter(valid_606135, JString, required = false,
                                 default = nil)
  if valid_606135 != nil:
    section.add "X-Amz-Security-Token", valid_606135
  var valid_606136 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_606136 = validateParameter(valid_606136, JString, required = false,
                                 default = nil)
  if valid_606136 != nil:
    section.add "X-Amz-Content-Sha256", valid_606136
  var valid_606137 = header.getOrDefault("X-Amz-Algorithm")
  valid_606137 = validateParameter(valid_606137, JString, required = false,
                                 default = nil)
  if valid_606137 != nil:
    section.add "X-Amz-Algorithm", valid_606137
  var valid_606138 = header.getOrDefault("X-Amz-Signature")
  valid_606138 = validateParameter(valid_606138, JString, required = false,
                                 default = nil)
  if valid_606138 != nil:
    section.add "X-Amz-Signature", valid_606138
  var valid_606139 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_606139 = validateParameter(valid_606139, JString, required = false,
                                 default = nil)
  if valid_606139 != nil:
    section.add "X-Amz-SignedHeaders", valid_606139
  var valid_606140 = header.getOrDefault("X-Amz-Credential")
  valid_606140 = validateParameter(valid_606140, JString, required = false,
                                 default = nil)
  if valid_606140 != nil:
    section.add "X-Amz-Credential", valid_606140
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_606141: Call_GetRestoreTableFromClusterSnapshot_606121;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Creates a new table from a table in an Amazon Redshift cluster snapshot. You must create the new table within the Amazon Redshift cluster that the snapshot was taken from.</p> <p>You cannot use <code>RestoreTableFromClusterSnapshot</code> to restore a table with the same name as an existing table in an Amazon Redshift cluster. That is, you cannot overwrite an existing table in a cluster with a restored table. If you want to replace your original table with a new, restored table, then rename or drop your original table before you call <code>RestoreTableFromClusterSnapshot</code>. When you have renamed your original table, then you can pass the original name of the table as the <code>NewTableName</code> parameter value in the call to <code>RestoreTableFromClusterSnapshot</code>. This way, you can replace the original table with the table created from the snapshot.</p>
  ## 
  let valid = call_606141.validator(path, query, header, formData, body)
  let scheme = call_606141.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_606141.url(scheme.get, call_606141.host, call_606141.base,
                         call_606141.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_606141, url, valid)

proc call*(call_606142: Call_GetRestoreTableFromClusterSnapshot_606121;
          SourceDatabaseName: string; SourceTableName: string;
          ClusterIdentifier: string; NewTableName: string;
          SnapshotIdentifier: string; SourceSchemaName: string = "";
          Action: string = "RestoreTableFromClusterSnapshot";
          TargetDatabaseName: string = ""; Version: string = "2012-12-01";
          TargetSchemaName: string = ""): Recallable =
  ## getRestoreTableFromClusterSnapshot
  ## <p>Creates a new table from a table in an Amazon Redshift cluster snapshot. You must create the new table within the Amazon Redshift cluster that the snapshot was taken from.</p> <p>You cannot use <code>RestoreTableFromClusterSnapshot</code> to restore a table with the same name as an existing table in an Amazon Redshift cluster. That is, you cannot overwrite an existing table in a cluster with a restored table. If you want to replace your original table with a new, restored table, then rename or drop your original table before you call <code>RestoreTableFromClusterSnapshot</code>. When you have renamed your original table, then you can pass the original name of the table as the <code>NewTableName</code> parameter value in the call to <code>RestoreTableFromClusterSnapshot</code>. This way, you can replace the original table with the table created from the snapshot.</p>
  ##   SourceDatabaseName: string (required)
  ##                     : The name of the source database that contains the table to restore from.
  ##   SourceTableName: string (required)
  ##                  : The name of the source table to restore from.
  ##   SourceSchemaName: string
  ##                   : The name of the source schema that contains the table to restore from. If you do not specify a <code>SourceSchemaName</code> value, the default is <code>public</code>.
  ##   ClusterIdentifier: string (required)
  ##                    : The identifier of the Amazon Redshift cluster to restore the table to.
  ##   Action: string (required)
  ##   TargetDatabaseName: string
  ##                     : The name of the database to restore the table to.
  ##   NewTableName: string (required)
  ##               : The name of the table to create as a result of the current request.
  ##   SnapshotIdentifier: string (required)
  ##                     : The identifier of the snapshot to restore the table from. This snapshot must have been created from the Amazon Redshift cluster specified by the <code>ClusterIdentifier</code> parameter.
  ##   Version: string (required)
  ##   TargetSchemaName: string
  ##                   : The name of the schema to restore the table to.
  var query_606143 = newJObject()
  add(query_606143, "SourceDatabaseName", newJString(SourceDatabaseName))
  add(query_606143, "SourceTableName", newJString(SourceTableName))
  add(query_606143, "SourceSchemaName", newJString(SourceSchemaName))
  add(query_606143, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_606143, "Action", newJString(Action))
  add(query_606143, "TargetDatabaseName", newJString(TargetDatabaseName))
  add(query_606143, "NewTableName", newJString(NewTableName))
  add(query_606143, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_606143, "Version", newJString(Version))
  add(query_606143, "TargetSchemaName", newJString(TargetSchemaName))
  result = call_606142.call(nil, query_606143, nil, nil, nil)

var getRestoreTableFromClusterSnapshot* = Call_GetRestoreTableFromClusterSnapshot_606121(
    name: "getRestoreTableFromClusterSnapshot", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=RestoreTableFromClusterSnapshot",
    validator: validate_GetRestoreTableFromClusterSnapshot_606122, base: "/",
    url: url_GetRestoreTableFromClusterSnapshot_606123,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostRevokeClusterSecurityGroupIngress_606187 = ref object of OpenApiRestCall_602450
proc url_PostRevokeClusterSecurityGroupIngress_606189(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostRevokeClusterSecurityGroupIngress_606188(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Revokes an ingress rule in an Amazon Redshift security group for a previously authorized IP range or Amazon EC2 security group. To add an ingress rule, see <a>AuthorizeClusterSecurityGroupIngress</a>. For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_606190 = query.getOrDefault("Action")
  valid_606190 = validateParameter(valid_606190, JString, required = true, default = newJString(
      "RevokeClusterSecurityGroupIngress"))
  if valid_606190 != nil:
    section.add "Action", valid_606190
  var valid_606191 = query.getOrDefault("Version")
  valid_606191 = validateParameter(valid_606191, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_606191 != nil:
    section.add "Version", valid_606191
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_606192 = header.getOrDefault("X-Amz-Date")
  valid_606192 = validateParameter(valid_606192, JString, required = false,
                                 default = nil)
  if valid_606192 != nil:
    section.add "X-Amz-Date", valid_606192
  var valid_606193 = header.getOrDefault("X-Amz-Security-Token")
  valid_606193 = validateParameter(valid_606193, JString, required = false,
                                 default = nil)
  if valid_606193 != nil:
    section.add "X-Amz-Security-Token", valid_606193
  var valid_606194 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_606194 = validateParameter(valid_606194, JString, required = false,
                                 default = nil)
  if valid_606194 != nil:
    section.add "X-Amz-Content-Sha256", valid_606194
  var valid_606195 = header.getOrDefault("X-Amz-Algorithm")
  valid_606195 = validateParameter(valid_606195, JString, required = false,
                                 default = nil)
  if valid_606195 != nil:
    section.add "X-Amz-Algorithm", valid_606195
  var valid_606196 = header.getOrDefault("X-Amz-Signature")
  valid_606196 = validateParameter(valid_606196, JString, required = false,
                                 default = nil)
  if valid_606196 != nil:
    section.add "X-Amz-Signature", valid_606196
  var valid_606197 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_606197 = validateParameter(valid_606197, JString, required = false,
                                 default = nil)
  if valid_606197 != nil:
    section.add "X-Amz-SignedHeaders", valid_606197
  var valid_606198 = header.getOrDefault("X-Amz-Credential")
  valid_606198 = validateParameter(valid_606198, JString, required = false,
                                 default = nil)
  if valid_606198 != nil:
    section.add "X-Amz-Credential", valid_606198
  result.add "header", section
  ## parameters in `formData` object:
  ##   EC2SecurityGroupName: JString
  ##                       : The name of the EC2 Security Group whose access is to be revoked. If <code>EC2SecurityGroupName</code> is specified, <code>EC2SecurityGroupOwnerId</code> must also be provided and <code>CIDRIP</code> cannot be provided. 
  ##   CIDRIP: JString
  ##         : The IP range for which to revoke access. This range must be a valid Classless Inter-Domain Routing (CIDR) block of IP addresses. If <code>CIDRIP</code> is specified, <code>EC2SecurityGroupName</code> and <code>EC2SecurityGroupOwnerId</code> cannot be provided. 
  ##   EC2SecurityGroupOwnerId: JString
  ##                          : <p>The AWS account number of the owner of the security group specified in the <code>EC2SecurityGroupName</code> parameter. The AWS access key ID is not an acceptable value. If <code>EC2SecurityGroupOwnerId</code> is specified, <code>EC2SecurityGroupName</code> must also be provided. and <code>CIDRIP</code> cannot be provided. </p> <p>Example: <code>111122223333</code> </p>
  ##   ClusterSecurityGroupName: JString (required)
  ##                           : The name of the security Group from which to revoke the ingress rule.
  section = newJObject()
  var valid_606199 = formData.getOrDefault("EC2SecurityGroupName")
  valid_606199 = validateParameter(valid_606199, JString, required = false,
                                 default = nil)
  if valid_606199 != nil:
    section.add "EC2SecurityGroupName", valid_606199
  var valid_606200 = formData.getOrDefault("CIDRIP")
  valid_606200 = validateParameter(valid_606200, JString, required = false,
                                 default = nil)
  if valid_606200 != nil:
    section.add "CIDRIP", valid_606200
  var valid_606201 = formData.getOrDefault("EC2SecurityGroupOwnerId")
  valid_606201 = validateParameter(valid_606201, JString, required = false,
                                 default = nil)
  if valid_606201 != nil:
    section.add "EC2SecurityGroupOwnerId", valid_606201
  assert formData != nil, "formData argument is necessary due to required `ClusterSecurityGroupName` field"
  var valid_606202 = formData.getOrDefault("ClusterSecurityGroupName")
  valid_606202 = validateParameter(valid_606202, JString, required = true,
                                 default = nil)
  if valid_606202 != nil:
    section.add "ClusterSecurityGroupName", valid_606202
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_606203: Call_PostRevokeClusterSecurityGroupIngress_606187;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Revokes an ingress rule in an Amazon Redshift security group for a previously authorized IP range or Amazon EC2 security group. To add an ingress rule, see <a>AuthorizeClusterSecurityGroupIngress</a>. For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>. 
  ## 
  let valid = call_606203.validator(path, query, header, formData, body)
  let scheme = call_606203.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_606203.url(scheme.get, call_606203.host, call_606203.base,
                         call_606203.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_606203, url, valid)

proc call*(call_606204: Call_PostRevokeClusterSecurityGroupIngress_606187;
          ClusterSecurityGroupName: string;
          Action: string = "RevokeClusterSecurityGroupIngress";
          EC2SecurityGroupName: string = ""; CIDRIP: string = "";
          Version: string = "2012-12-01"; EC2SecurityGroupOwnerId: string = ""): Recallable =
  ## postRevokeClusterSecurityGroupIngress
  ## Revokes an ingress rule in an Amazon Redshift security group for a previously authorized IP range or Amazon EC2 security group. To add an ingress rule, see <a>AuthorizeClusterSecurityGroupIngress</a>. For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>. 
  ##   Action: string (required)
  ##   EC2SecurityGroupName: string
  ##                       : The name of the EC2 Security Group whose access is to be revoked. If <code>EC2SecurityGroupName</code> is specified, <code>EC2SecurityGroupOwnerId</code> must also be provided and <code>CIDRIP</code> cannot be provided. 
  ##   CIDRIP: string
  ##         : The IP range for which to revoke access. This range must be a valid Classless Inter-Domain Routing (CIDR) block of IP addresses. If <code>CIDRIP</code> is specified, <code>EC2SecurityGroupName</code> and <code>EC2SecurityGroupOwnerId</code> cannot be provided. 
  ##   Version: string (required)
  ##   EC2SecurityGroupOwnerId: string
  ##                          : <p>The AWS account number of the owner of the security group specified in the <code>EC2SecurityGroupName</code> parameter. The AWS access key ID is not an acceptable value. If <code>EC2SecurityGroupOwnerId</code> is specified, <code>EC2SecurityGroupName</code> must also be provided. and <code>CIDRIP</code> cannot be provided. </p> <p>Example: <code>111122223333</code> </p>
  ##   ClusterSecurityGroupName: string (required)
  ##                           : The name of the security Group from which to revoke the ingress rule.
  var query_606205 = newJObject()
  var formData_606206 = newJObject()
  add(query_606205, "Action", newJString(Action))
  add(formData_606206, "EC2SecurityGroupName", newJString(EC2SecurityGroupName))
  add(formData_606206, "CIDRIP", newJString(CIDRIP))
  add(query_606205, "Version", newJString(Version))
  add(formData_606206, "EC2SecurityGroupOwnerId",
      newJString(EC2SecurityGroupOwnerId))
  add(formData_606206, "ClusterSecurityGroupName",
      newJString(ClusterSecurityGroupName))
  result = call_606204.call(nil, query_606205, nil, formData_606206, nil)

var postRevokeClusterSecurityGroupIngress* = Call_PostRevokeClusterSecurityGroupIngress_606187(
    name: "postRevokeClusterSecurityGroupIngress", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=RevokeClusterSecurityGroupIngress",
    validator: validate_PostRevokeClusterSecurityGroupIngress_606188, base: "/",
    url: url_PostRevokeClusterSecurityGroupIngress_606189,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetRevokeClusterSecurityGroupIngress_606168 = ref object of OpenApiRestCall_602450
proc url_GetRevokeClusterSecurityGroupIngress_606170(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetRevokeClusterSecurityGroupIngress_606169(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Revokes an ingress rule in an Amazon Redshift security group for a previously authorized IP range or Amazon EC2 security group. To add an ingress rule, see <a>AuthorizeClusterSecurityGroupIngress</a>. For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ClusterSecurityGroupName: JString (required)
  ##                           : The name of the security Group from which to revoke the ingress rule.
  ##   EC2SecurityGroupOwnerId: JString
  ##                          : <p>The AWS account number of the owner of the security group specified in the <code>EC2SecurityGroupName</code> parameter. The AWS access key ID is not an acceptable value. If <code>EC2SecurityGroupOwnerId</code> is specified, <code>EC2SecurityGroupName</code> must also be provided. and <code>CIDRIP</code> cannot be provided. </p> <p>Example: <code>111122223333</code> </p>
  ##   Action: JString (required)
  ##   CIDRIP: JString
  ##         : The IP range for which to revoke access. This range must be a valid Classless Inter-Domain Routing (CIDR) block of IP addresses. If <code>CIDRIP</code> is specified, <code>EC2SecurityGroupName</code> and <code>EC2SecurityGroupOwnerId</code> cannot be provided. 
  ##   EC2SecurityGroupName: JString
  ##                       : The name of the EC2 Security Group whose access is to be revoked. If <code>EC2SecurityGroupName</code> is specified, <code>EC2SecurityGroupOwnerId</code> must also be provided and <code>CIDRIP</code> cannot be provided. 
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `ClusterSecurityGroupName` field"
  var valid_606171 = query.getOrDefault("ClusterSecurityGroupName")
  valid_606171 = validateParameter(valid_606171, JString, required = true,
                                 default = nil)
  if valid_606171 != nil:
    section.add "ClusterSecurityGroupName", valid_606171
  var valid_606172 = query.getOrDefault("EC2SecurityGroupOwnerId")
  valid_606172 = validateParameter(valid_606172, JString, required = false,
                                 default = nil)
  if valid_606172 != nil:
    section.add "EC2SecurityGroupOwnerId", valid_606172
  var valid_606173 = query.getOrDefault("Action")
  valid_606173 = validateParameter(valid_606173, JString, required = true, default = newJString(
      "RevokeClusterSecurityGroupIngress"))
  if valid_606173 != nil:
    section.add "Action", valid_606173
  var valid_606174 = query.getOrDefault("CIDRIP")
  valid_606174 = validateParameter(valid_606174, JString, required = false,
                                 default = nil)
  if valid_606174 != nil:
    section.add "CIDRIP", valid_606174
  var valid_606175 = query.getOrDefault("EC2SecurityGroupName")
  valid_606175 = validateParameter(valid_606175, JString, required = false,
                                 default = nil)
  if valid_606175 != nil:
    section.add "EC2SecurityGroupName", valid_606175
  var valid_606176 = query.getOrDefault("Version")
  valid_606176 = validateParameter(valid_606176, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_606176 != nil:
    section.add "Version", valid_606176
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_606177 = header.getOrDefault("X-Amz-Date")
  valid_606177 = validateParameter(valid_606177, JString, required = false,
                                 default = nil)
  if valid_606177 != nil:
    section.add "X-Amz-Date", valid_606177
  var valid_606178 = header.getOrDefault("X-Amz-Security-Token")
  valid_606178 = validateParameter(valid_606178, JString, required = false,
                                 default = nil)
  if valid_606178 != nil:
    section.add "X-Amz-Security-Token", valid_606178
  var valid_606179 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_606179 = validateParameter(valid_606179, JString, required = false,
                                 default = nil)
  if valid_606179 != nil:
    section.add "X-Amz-Content-Sha256", valid_606179
  var valid_606180 = header.getOrDefault("X-Amz-Algorithm")
  valid_606180 = validateParameter(valid_606180, JString, required = false,
                                 default = nil)
  if valid_606180 != nil:
    section.add "X-Amz-Algorithm", valid_606180
  var valid_606181 = header.getOrDefault("X-Amz-Signature")
  valid_606181 = validateParameter(valid_606181, JString, required = false,
                                 default = nil)
  if valid_606181 != nil:
    section.add "X-Amz-Signature", valid_606181
  var valid_606182 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_606182 = validateParameter(valid_606182, JString, required = false,
                                 default = nil)
  if valid_606182 != nil:
    section.add "X-Amz-SignedHeaders", valid_606182
  var valid_606183 = header.getOrDefault("X-Amz-Credential")
  valid_606183 = validateParameter(valid_606183, JString, required = false,
                                 default = nil)
  if valid_606183 != nil:
    section.add "X-Amz-Credential", valid_606183
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_606184: Call_GetRevokeClusterSecurityGroupIngress_606168;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Revokes an ingress rule in an Amazon Redshift security group for a previously authorized IP range or Amazon EC2 security group. To add an ingress rule, see <a>AuthorizeClusterSecurityGroupIngress</a>. For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>. 
  ## 
  let valid = call_606184.validator(path, query, header, formData, body)
  let scheme = call_606184.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_606184.url(scheme.get, call_606184.host, call_606184.base,
                         call_606184.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_606184, url, valid)

proc call*(call_606185: Call_GetRevokeClusterSecurityGroupIngress_606168;
          ClusterSecurityGroupName: string; EC2SecurityGroupOwnerId: string = "";
          Action: string = "RevokeClusterSecurityGroupIngress"; CIDRIP: string = "";
          EC2SecurityGroupName: string = ""; Version: string = "2012-12-01"): Recallable =
  ## getRevokeClusterSecurityGroupIngress
  ## Revokes an ingress rule in an Amazon Redshift security group for a previously authorized IP range or Amazon EC2 security group. To add an ingress rule, see <a>AuthorizeClusterSecurityGroupIngress</a>. For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>. 
  ##   ClusterSecurityGroupName: string (required)
  ##                           : The name of the security Group from which to revoke the ingress rule.
  ##   EC2SecurityGroupOwnerId: string
  ##                          : <p>The AWS account number of the owner of the security group specified in the <code>EC2SecurityGroupName</code> parameter. The AWS access key ID is not an acceptable value. If <code>EC2SecurityGroupOwnerId</code> is specified, <code>EC2SecurityGroupName</code> must also be provided. and <code>CIDRIP</code> cannot be provided. </p> <p>Example: <code>111122223333</code> </p>
  ##   Action: string (required)
  ##   CIDRIP: string
  ##         : The IP range for which to revoke access. This range must be a valid Classless Inter-Domain Routing (CIDR) block of IP addresses. If <code>CIDRIP</code> is specified, <code>EC2SecurityGroupName</code> and <code>EC2SecurityGroupOwnerId</code> cannot be provided. 
  ##   EC2SecurityGroupName: string
  ##                       : The name of the EC2 Security Group whose access is to be revoked. If <code>EC2SecurityGroupName</code> is specified, <code>EC2SecurityGroupOwnerId</code> must also be provided and <code>CIDRIP</code> cannot be provided. 
  ##   Version: string (required)
  var query_606186 = newJObject()
  add(query_606186, "ClusterSecurityGroupName",
      newJString(ClusterSecurityGroupName))
  add(query_606186, "EC2SecurityGroupOwnerId", newJString(EC2SecurityGroupOwnerId))
  add(query_606186, "Action", newJString(Action))
  add(query_606186, "CIDRIP", newJString(CIDRIP))
  add(query_606186, "EC2SecurityGroupName", newJString(EC2SecurityGroupName))
  add(query_606186, "Version", newJString(Version))
  result = call_606185.call(nil, query_606186, nil, nil, nil)

var getRevokeClusterSecurityGroupIngress* = Call_GetRevokeClusterSecurityGroupIngress_606168(
    name: "getRevokeClusterSecurityGroupIngress", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=RevokeClusterSecurityGroupIngress",
    validator: validate_GetRevokeClusterSecurityGroupIngress_606169, base: "/",
    url: url_GetRevokeClusterSecurityGroupIngress_606170,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostRevokeSnapshotAccess_606225 = ref object of OpenApiRestCall_602450
proc url_PostRevokeSnapshotAccess_606227(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostRevokeSnapshotAccess_606226(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Removes the ability of the specified AWS customer account to restore the specified snapshot. If the account is currently restoring the snapshot, the restore will run to completion.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_606228 = query.getOrDefault("Action")
  valid_606228 = validateParameter(valid_606228, JString, required = true,
                                 default = newJString("RevokeSnapshotAccess"))
  if valid_606228 != nil:
    section.add "Action", valid_606228
  var valid_606229 = query.getOrDefault("Version")
  valid_606229 = validateParameter(valid_606229, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_606229 != nil:
    section.add "Version", valid_606229
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_606230 = header.getOrDefault("X-Amz-Date")
  valid_606230 = validateParameter(valid_606230, JString, required = false,
                                 default = nil)
  if valid_606230 != nil:
    section.add "X-Amz-Date", valid_606230
  var valid_606231 = header.getOrDefault("X-Amz-Security-Token")
  valid_606231 = validateParameter(valid_606231, JString, required = false,
                                 default = nil)
  if valid_606231 != nil:
    section.add "X-Amz-Security-Token", valid_606231
  var valid_606232 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_606232 = validateParameter(valid_606232, JString, required = false,
                                 default = nil)
  if valid_606232 != nil:
    section.add "X-Amz-Content-Sha256", valid_606232
  var valid_606233 = header.getOrDefault("X-Amz-Algorithm")
  valid_606233 = validateParameter(valid_606233, JString, required = false,
                                 default = nil)
  if valid_606233 != nil:
    section.add "X-Amz-Algorithm", valid_606233
  var valid_606234 = header.getOrDefault("X-Amz-Signature")
  valid_606234 = validateParameter(valid_606234, JString, required = false,
                                 default = nil)
  if valid_606234 != nil:
    section.add "X-Amz-Signature", valid_606234
  var valid_606235 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_606235 = validateParameter(valid_606235, JString, required = false,
                                 default = nil)
  if valid_606235 != nil:
    section.add "X-Amz-SignedHeaders", valid_606235
  var valid_606236 = header.getOrDefault("X-Amz-Credential")
  valid_606236 = validateParameter(valid_606236, JString, required = false,
                                 default = nil)
  if valid_606236 != nil:
    section.add "X-Amz-Credential", valid_606236
  result.add "header", section
  ## parameters in `formData` object:
  ##   AccountWithRestoreAccess: JString (required)
  ##                           : The identifier of the AWS customer account that can no longer restore the specified snapshot.
  ##   SnapshotClusterIdentifier: JString
  ##                            : The identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.
  ##   SnapshotIdentifier: JString (required)
  ##                     : The identifier of the snapshot that the account can no longer access.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `AccountWithRestoreAccess` field"
  var valid_606237 = formData.getOrDefault("AccountWithRestoreAccess")
  valid_606237 = validateParameter(valid_606237, JString, required = true,
                                 default = nil)
  if valid_606237 != nil:
    section.add "AccountWithRestoreAccess", valid_606237
  var valid_606238 = formData.getOrDefault("SnapshotClusterIdentifier")
  valid_606238 = validateParameter(valid_606238, JString, required = false,
                                 default = nil)
  if valid_606238 != nil:
    section.add "SnapshotClusterIdentifier", valid_606238
  var valid_606239 = formData.getOrDefault("SnapshotIdentifier")
  valid_606239 = validateParameter(valid_606239, JString, required = true,
                                 default = nil)
  if valid_606239 != nil:
    section.add "SnapshotIdentifier", valid_606239
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_606240: Call_PostRevokeSnapshotAccess_606225; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Removes the ability of the specified AWS customer account to restore the specified snapshot. If the account is currently restoring the snapshot, the restore will run to completion.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_606240.validator(path, query, header, formData, body)
  let scheme = call_606240.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_606240.url(scheme.get, call_606240.host, call_606240.base,
                         call_606240.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_606240, url, valid)

proc call*(call_606241: Call_PostRevokeSnapshotAccess_606225;
          AccountWithRestoreAccess: string; SnapshotIdentifier: string;
          SnapshotClusterIdentifier: string = "";
          Action: string = "RevokeSnapshotAccess"; Version: string = "2012-12-01"): Recallable =
  ## postRevokeSnapshotAccess
  ## <p>Removes the ability of the specified AWS customer account to restore the specified snapshot. If the account is currently restoring the snapshot, the restore will run to completion.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   AccountWithRestoreAccess: string (required)
  ##                           : The identifier of the AWS customer account that can no longer restore the specified snapshot.
  ##   SnapshotClusterIdentifier: string
  ##                            : The identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.
  ##   Action: string (required)
  ##   SnapshotIdentifier: string (required)
  ##                     : The identifier of the snapshot that the account can no longer access.
  ##   Version: string (required)
  var query_606242 = newJObject()
  var formData_606243 = newJObject()
  add(formData_606243, "AccountWithRestoreAccess",
      newJString(AccountWithRestoreAccess))
  add(formData_606243, "SnapshotClusterIdentifier",
      newJString(SnapshotClusterIdentifier))
  add(query_606242, "Action", newJString(Action))
  add(formData_606243, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_606242, "Version", newJString(Version))
  result = call_606241.call(nil, query_606242, nil, formData_606243, nil)

var postRevokeSnapshotAccess* = Call_PostRevokeSnapshotAccess_606225(
    name: "postRevokeSnapshotAccess", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=RevokeSnapshotAccess",
    validator: validate_PostRevokeSnapshotAccess_606226, base: "/",
    url: url_PostRevokeSnapshotAccess_606227, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetRevokeSnapshotAccess_606207 = ref object of OpenApiRestCall_602450
proc url_GetRevokeSnapshotAccess_606209(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetRevokeSnapshotAccess_606208(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Removes the ability of the specified AWS customer account to restore the specified snapshot. If the account is currently restoring the snapshot, the restore will run to completion.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   AccountWithRestoreAccess: JString (required)
  ##                           : The identifier of the AWS customer account that can no longer restore the specified snapshot.
  ##   Action: JString (required)
  ##   SnapshotClusterIdentifier: JString
  ##                            : The identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.
  ##   SnapshotIdentifier: JString (required)
  ##                     : The identifier of the snapshot that the account can no longer access.
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `AccountWithRestoreAccess` field"
  var valid_606210 = query.getOrDefault("AccountWithRestoreAccess")
  valid_606210 = validateParameter(valid_606210, JString, required = true,
                                 default = nil)
  if valid_606210 != nil:
    section.add "AccountWithRestoreAccess", valid_606210
  var valid_606211 = query.getOrDefault("Action")
  valid_606211 = validateParameter(valid_606211, JString, required = true,
                                 default = newJString("RevokeSnapshotAccess"))
  if valid_606211 != nil:
    section.add "Action", valid_606211
  var valid_606212 = query.getOrDefault("SnapshotClusterIdentifier")
  valid_606212 = validateParameter(valid_606212, JString, required = false,
                                 default = nil)
  if valid_606212 != nil:
    section.add "SnapshotClusterIdentifier", valid_606212
  var valid_606213 = query.getOrDefault("SnapshotIdentifier")
  valid_606213 = validateParameter(valid_606213, JString, required = true,
                                 default = nil)
  if valid_606213 != nil:
    section.add "SnapshotIdentifier", valid_606213
  var valid_606214 = query.getOrDefault("Version")
  valid_606214 = validateParameter(valid_606214, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_606214 != nil:
    section.add "Version", valid_606214
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_606215 = header.getOrDefault("X-Amz-Date")
  valid_606215 = validateParameter(valid_606215, JString, required = false,
                                 default = nil)
  if valid_606215 != nil:
    section.add "X-Amz-Date", valid_606215
  var valid_606216 = header.getOrDefault("X-Amz-Security-Token")
  valid_606216 = validateParameter(valid_606216, JString, required = false,
                                 default = nil)
  if valid_606216 != nil:
    section.add "X-Amz-Security-Token", valid_606216
  var valid_606217 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_606217 = validateParameter(valid_606217, JString, required = false,
                                 default = nil)
  if valid_606217 != nil:
    section.add "X-Amz-Content-Sha256", valid_606217
  var valid_606218 = header.getOrDefault("X-Amz-Algorithm")
  valid_606218 = validateParameter(valid_606218, JString, required = false,
                                 default = nil)
  if valid_606218 != nil:
    section.add "X-Amz-Algorithm", valid_606218
  var valid_606219 = header.getOrDefault("X-Amz-Signature")
  valid_606219 = validateParameter(valid_606219, JString, required = false,
                                 default = nil)
  if valid_606219 != nil:
    section.add "X-Amz-Signature", valid_606219
  var valid_606220 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_606220 = validateParameter(valid_606220, JString, required = false,
                                 default = nil)
  if valid_606220 != nil:
    section.add "X-Amz-SignedHeaders", valid_606220
  var valid_606221 = header.getOrDefault("X-Amz-Credential")
  valid_606221 = validateParameter(valid_606221, JString, required = false,
                                 default = nil)
  if valid_606221 != nil:
    section.add "X-Amz-Credential", valid_606221
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_606222: Call_GetRevokeSnapshotAccess_606207; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Removes the ability of the specified AWS customer account to restore the specified snapshot. If the account is currently restoring the snapshot, the restore will run to completion.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_606222.validator(path, query, header, formData, body)
  let scheme = call_606222.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_606222.url(scheme.get, call_606222.host, call_606222.base,
                         call_606222.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_606222, url, valid)

proc call*(call_606223: Call_GetRevokeSnapshotAccess_606207;
          AccountWithRestoreAccess: string; SnapshotIdentifier: string;
          Action: string = "RevokeSnapshotAccess";
          SnapshotClusterIdentifier: string = ""; Version: string = "2012-12-01"): Recallable =
  ## getRevokeSnapshotAccess
  ## <p>Removes the ability of the specified AWS customer account to restore the specified snapshot. If the account is currently restoring the snapshot, the restore will run to completion.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   AccountWithRestoreAccess: string (required)
  ##                           : The identifier of the AWS customer account that can no longer restore the specified snapshot.
  ##   Action: string (required)
  ##   SnapshotClusterIdentifier: string
  ##                            : The identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.
  ##   SnapshotIdentifier: string (required)
  ##                     : The identifier of the snapshot that the account can no longer access.
  ##   Version: string (required)
  var query_606224 = newJObject()
  add(query_606224, "AccountWithRestoreAccess",
      newJString(AccountWithRestoreAccess))
  add(query_606224, "Action", newJString(Action))
  add(query_606224, "SnapshotClusterIdentifier",
      newJString(SnapshotClusterIdentifier))
  add(query_606224, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_606224, "Version", newJString(Version))
  result = call_606223.call(nil, query_606224, nil, nil, nil)

var getRevokeSnapshotAccess* = Call_GetRevokeSnapshotAccess_606207(
    name: "getRevokeSnapshotAccess", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=RevokeSnapshotAccess",
    validator: validate_GetRevokeSnapshotAccess_606208, base: "/",
    url: url_GetRevokeSnapshotAccess_606209, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostRotateEncryptionKey_606260 = ref object of OpenApiRestCall_602450
proc url_PostRotateEncryptionKey_606262(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostRotateEncryptionKey_606261(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Rotates the encryption keys for a cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_606263 = query.getOrDefault("Action")
  valid_606263 = validateParameter(valid_606263, JString, required = true,
                                 default = newJString("RotateEncryptionKey"))
  if valid_606263 != nil:
    section.add "Action", valid_606263
  var valid_606264 = query.getOrDefault("Version")
  valid_606264 = validateParameter(valid_606264, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_606264 != nil:
    section.add "Version", valid_606264
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_606265 = header.getOrDefault("X-Amz-Date")
  valid_606265 = validateParameter(valid_606265, JString, required = false,
                                 default = nil)
  if valid_606265 != nil:
    section.add "X-Amz-Date", valid_606265
  var valid_606266 = header.getOrDefault("X-Amz-Security-Token")
  valid_606266 = validateParameter(valid_606266, JString, required = false,
                                 default = nil)
  if valid_606266 != nil:
    section.add "X-Amz-Security-Token", valid_606266
  var valid_606267 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_606267 = validateParameter(valid_606267, JString, required = false,
                                 default = nil)
  if valid_606267 != nil:
    section.add "X-Amz-Content-Sha256", valid_606267
  var valid_606268 = header.getOrDefault("X-Amz-Algorithm")
  valid_606268 = validateParameter(valid_606268, JString, required = false,
                                 default = nil)
  if valid_606268 != nil:
    section.add "X-Amz-Algorithm", valid_606268
  var valid_606269 = header.getOrDefault("X-Amz-Signature")
  valid_606269 = validateParameter(valid_606269, JString, required = false,
                                 default = nil)
  if valid_606269 != nil:
    section.add "X-Amz-Signature", valid_606269
  var valid_606270 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_606270 = validateParameter(valid_606270, JString, required = false,
                                 default = nil)
  if valid_606270 != nil:
    section.add "X-Amz-SignedHeaders", valid_606270
  var valid_606271 = header.getOrDefault("X-Amz-Credential")
  valid_606271 = validateParameter(valid_606271, JString, required = false,
                                 default = nil)
  if valid_606271 != nil:
    section.add "X-Amz-Credential", valid_606271
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of the cluster that you want to rotate the encryption keys for.</p> <p>Constraints: Must be the name of valid cluster that has encryption enabled.</p>
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_606272 = formData.getOrDefault("ClusterIdentifier")
  valid_606272 = validateParameter(valid_606272, JString, required = true,
                                 default = nil)
  if valid_606272 != nil:
    section.add "ClusterIdentifier", valid_606272
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_606273: Call_PostRotateEncryptionKey_606260; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Rotates the encryption keys for a cluster.
  ## 
  let valid = call_606273.validator(path, query, header, formData, body)
  let scheme = call_606273.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_606273.url(scheme.get, call_606273.host, call_606273.base,
                         call_606273.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_606273, url, valid)

proc call*(call_606274: Call_PostRotateEncryptionKey_606260;
          ClusterIdentifier: string; Action: string = "RotateEncryptionKey";
          Version: string = "2012-12-01"): Recallable =
  ## postRotateEncryptionKey
  ## Rotates the encryption keys for a cluster.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of the cluster that you want to rotate the encryption keys for.</p> <p>Constraints: Must be the name of valid cluster that has encryption enabled.</p>
  ##   Version: string (required)
  var query_606275 = newJObject()
  var formData_606276 = newJObject()
  add(query_606275, "Action", newJString(Action))
  add(formData_606276, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_606275, "Version", newJString(Version))
  result = call_606274.call(nil, query_606275, nil, formData_606276, nil)

var postRotateEncryptionKey* = Call_PostRotateEncryptionKey_606260(
    name: "postRotateEncryptionKey", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=RotateEncryptionKey",
    validator: validate_PostRotateEncryptionKey_606261, base: "/",
    url: url_PostRotateEncryptionKey_606262, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetRotateEncryptionKey_606244 = ref object of OpenApiRestCall_602450
proc url_GetRotateEncryptionKey_606246(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetRotateEncryptionKey_606245(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Rotates the encryption keys for a cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of the cluster that you want to rotate the encryption keys for.</p> <p>Constraints: Must be the name of valid cluster that has encryption enabled.</p>
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_606247 = query.getOrDefault("Action")
  valid_606247 = validateParameter(valid_606247, JString, required = true,
                                 default = newJString("RotateEncryptionKey"))
  if valid_606247 != nil:
    section.add "Action", valid_606247
  var valid_606248 = query.getOrDefault("ClusterIdentifier")
  valid_606248 = validateParameter(valid_606248, JString, required = true,
                                 default = nil)
  if valid_606248 != nil:
    section.add "ClusterIdentifier", valid_606248
  var valid_606249 = query.getOrDefault("Version")
  valid_606249 = validateParameter(valid_606249, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_606249 != nil:
    section.add "Version", valid_606249
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_606250 = header.getOrDefault("X-Amz-Date")
  valid_606250 = validateParameter(valid_606250, JString, required = false,
                                 default = nil)
  if valid_606250 != nil:
    section.add "X-Amz-Date", valid_606250
  var valid_606251 = header.getOrDefault("X-Amz-Security-Token")
  valid_606251 = validateParameter(valid_606251, JString, required = false,
                                 default = nil)
  if valid_606251 != nil:
    section.add "X-Amz-Security-Token", valid_606251
  var valid_606252 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_606252 = validateParameter(valid_606252, JString, required = false,
                                 default = nil)
  if valid_606252 != nil:
    section.add "X-Amz-Content-Sha256", valid_606252
  var valid_606253 = header.getOrDefault("X-Amz-Algorithm")
  valid_606253 = validateParameter(valid_606253, JString, required = false,
                                 default = nil)
  if valid_606253 != nil:
    section.add "X-Amz-Algorithm", valid_606253
  var valid_606254 = header.getOrDefault("X-Amz-Signature")
  valid_606254 = validateParameter(valid_606254, JString, required = false,
                                 default = nil)
  if valid_606254 != nil:
    section.add "X-Amz-Signature", valid_606254
  var valid_606255 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_606255 = validateParameter(valid_606255, JString, required = false,
                                 default = nil)
  if valid_606255 != nil:
    section.add "X-Amz-SignedHeaders", valid_606255
  var valid_606256 = header.getOrDefault("X-Amz-Credential")
  valid_606256 = validateParameter(valid_606256, JString, required = false,
                                 default = nil)
  if valid_606256 != nil:
    section.add "X-Amz-Credential", valid_606256
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_606257: Call_GetRotateEncryptionKey_606244; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Rotates the encryption keys for a cluster.
  ## 
  let valid = call_606257.validator(path, query, header, formData, body)
  let scheme = call_606257.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_606257.url(scheme.get, call_606257.host, call_606257.base,
                         call_606257.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_606257, url, valid)

proc call*(call_606258: Call_GetRotateEncryptionKey_606244;
          ClusterIdentifier: string; Action: string = "RotateEncryptionKey";
          Version: string = "2012-12-01"): Recallable =
  ## getRotateEncryptionKey
  ## Rotates the encryption keys for a cluster.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of the cluster that you want to rotate the encryption keys for.</p> <p>Constraints: Must be the name of valid cluster that has encryption enabled.</p>
  ##   Version: string (required)
  var query_606259 = newJObject()
  add(query_606259, "Action", newJString(Action))
  add(query_606259, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_606259, "Version", newJString(Version))
  result = call_606258.call(nil, query_606259, nil, nil, nil)

var getRotateEncryptionKey* = Call_GetRotateEncryptionKey_606244(
    name: "getRotateEncryptionKey", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=RotateEncryptionKey",
    validator: validate_GetRotateEncryptionKey_606245, base: "/",
    url: url_GetRotateEncryptionKey_606246, schemes: {Scheme.Https, Scheme.Http})
export
  rest

proc sign(recall: var Recallable; query: JsonNode; algo: SigningAlgo = SHA256) =
  let
    date = makeDateTime()
    access = os.getEnv("AWS_ACCESS_KEY_ID", "")
    secret = os.getEnv("AWS_SECRET_ACCESS_KEY", "")
    region = os.getEnv("AWS_REGION", "")
  assert secret != "", "need secret key in env"
  assert access != "", "need access key in env"
  assert region != "", "need region in env"
  var
    normal: PathNormal
    url = normalizeUrl(recall.url, query, normalize = normal)
    scheme = parseEnum[Scheme](url.scheme)
  assert scheme in awsServers, "unknown scheme `" & $scheme & "`"
  assert region in awsServers[scheme], "unknown region `" & region & "`"
  url.hostname = awsServers[scheme][region]
  case awsServiceName.toLowerAscii
  of "s3":
    normal = PathNormal.S3
  else:
    normal = PathNormal.Default
  recall.headers["Host"] = url.hostname
  recall.headers["X-Amz-Date"] = date
  let
    algo = SHA256
    scope = credentialScope(region = region, service = awsServiceName, date = date)
    request = canonicalRequest(recall.meth, $url, query, recall.headers, recall.body,
                             normalize = normal, digest = algo)
    sts = stringToSign(request.hash(algo), scope, date = date, digest = algo)
    signature = calculateSignature(secret = secret, date = date, region = region,
                                 service = awsServiceName, sts, digest = algo)
  var auth = $algo & " "
  auth &= "Credential=" & access / scope & ", "
  auth &= "SignedHeaders=" & recall.headers.signedHeaders & ", "
  auth &= "Signature=" & signature
  recall.headers["Authorization"] = auth
  recall.headers.del "Host"
  recall.url = $url

method hook(call: OpenApiRestCall; url: Uri; input: JsonNode): Recallable {.base.} =
  let headers = massageHeaders(input.getOrDefault("header"))
  result = newRecallable(call, url, headers, input.getOrDefault("body").getStr)
  result.sign(input.getOrDefault("query"), SHA256)
