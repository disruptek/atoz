
import
  json, options, hashes, uri, strutils, tables, rest, os, uri, strutils, httpcore, sigv4

## auto-generated via openapi macro
## title: Amazon Redshift
## version: 2012-12-01
## termsOfService: https://aws.amazon.com/service-terms/
## license:
##     name: Apache 2.0 License
##     url: http://www.apache.org/licenses/
## 
## <fullname>Amazon Redshift</fullname> <p> <b>Overview</b> </p> <p>This is an interface reference for Amazon Redshift. It contains documentation for one of the programming or command line interfaces you can use to manage Amazon Redshift clusters. Note that Amazon Redshift is asynchronous, which means that some interfaces may require techniques, such as polling or asynchronous callback handlers, to determine when a command has been applied. In this reference, the parameter descriptions indicate whether a change is applied immediately, on the next instance reboot, or during the next maintenance window. For a summary of the Amazon Redshift cluster management interfaces, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/using-aws-sdk.html">Using the Amazon Redshift Management Interfaces</a>.</p> <p>Amazon Redshift manages all the work of setting up, operating, and scaling a data warehouse: provisioning capacity, monitoring and backing up the cluster, and applying patches and upgrades to the Amazon Redshift engine. You can focus on using your data to acquire new insights for your business and customers.</p> <p>If you are a first-time user of Amazon Redshift, we recommend that you begin by reading the <a href="https://docs.aws.amazon.com/redshift/latest/gsg/getting-started.html">Amazon Redshift Getting Started Guide</a>.</p> <p>If you are a database developer, the <a href="https://docs.aws.amazon.com/redshift/latest/dg/welcome.html">Amazon Redshift Database Developer Guide</a> explains how to design, build, query, and maintain the databases that make up your data warehouse. </p>
## 
## Amazon Web Services documentation
## https://docs.aws.amazon.com/redshift/
type
  Scheme {.pure.} = enum
    Https = "https", Http = "http", Wss = "wss", Ws = "ws"
  ValidatorSignature = proc (query: JsonNode = nil; body: JsonNode = nil;
                          header: JsonNode = nil; path: JsonNode = nil;
                          formData: JsonNode = nil): JsonNode
  OpenApiRestCall = ref object of RestCall
    validator*: ValidatorSignature
    route*: string
    base*: string
    host*: string
    schemes*: set[Scheme]
    url*: proc (protocol: Scheme; host: string; base: string; route: string;
              path: JsonNode; query: JsonNode): Uri

  OpenApiRestCall_612642 = ref object of OpenApiRestCall
proc hash(scheme: Scheme): Hash {.used.} =
  result = hash(ord(scheme))

proc clone[T: OpenApiRestCall_612642](t: T): T {.used.} =
  result = T(name: t.name, meth: t.meth, host: t.host, base: t.base, route: t.route,
           schemes: t.schemes, validator: t.validator, url: t.url)

proc pickScheme(t: OpenApiRestCall_612642): Option[Scheme] {.used.} =
  ## select a supported scheme from a set of candidates
  for scheme in Scheme.low ..
      Scheme.high:
    if scheme notin t.schemes:
      continue
    if scheme in [Scheme.Https, Scheme.Wss]:
      when defined(ssl):
        return some(scheme)
      else:
        continue
    return some(scheme)

proc validateParameter(js: JsonNode; kind: JsonNodeKind; required: bool;
                      default: JsonNode = nil): JsonNode =
  ## ensure an input is of the correct json type and yield
  ## a suitable default value when appropriate
  if js ==
      nil:
    if default != nil:
      return validateParameter(default, kind, required = required)
  result = js
  if result ==
      nil:
    assert not required, $kind & " expected; received nil"
    if required:
      result = newJNull()
  else:
    assert js.kind ==
        kind, $kind & " expected; received " &
        $js.kind

type
  KeyVal {.used.} = tuple[key: string, val: string]
  PathTokenKind = enum
    ConstantSegment, VariableSegment
  PathToken = tuple[kind: PathTokenKind, value: string]
proc queryString(query: JsonNode): string {.used.} =
  var qs: seq[KeyVal]
  if query == nil:
    return ""
  for k, v in query.pairs:
    qs.add (key: k, val: v.getStr)
  result = encodeQuery(qs)

proc hydratePath(input: JsonNode; segments: seq[PathToken]): Option[string] {.used.} =
  ## reconstitute a path with constants and variable values taken from json
  var head: string
  if segments.len == 0:
    return some("")
  head = segments[0].value
  case segments[0].kind
  of ConstantSegment:
    discard
  of VariableSegment:
    if head notin input:
      return
    let js = input[head]
    case js.kind
    of JInt, JFloat, JNull, JBool:
      head = $js
    of JString:
      head = js.getStr
    else:
      return
  var remainder = input.hydratePath(segments[1 ..^ 1])
  if remainder.isNone:
    return
  result = some(head & remainder.get)

const
  awsServers = {Scheme.Http: {"ap-northeast-1": "redshift.ap-northeast-1.amazonaws.com", "ap-southeast-1": "redshift.ap-southeast-1.amazonaws.com",
                           "us-west-2": "redshift.us-west-2.amazonaws.com",
                           "eu-west-2": "redshift.eu-west-2.amazonaws.com", "ap-northeast-3": "redshift.ap-northeast-3.amazonaws.com", "eu-central-1": "redshift.eu-central-1.amazonaws.com",
                           "us-east-2": "redshift.us-east-2.amazonaws.com",
                           "us-east-1": "redshift.us-east-1.amazonaws.com", "cn-northwest-1": "redshift.cn-northwest-1.amazonaws.com.cn",
                           "ap-south-1": "redshift.ap-south-1.amazonaws.com",
                           "eu-north-1": "redshift.eu-north-1.amazonaws.com", "ap-northeast-2": "redshift.ap-northeast-2.amazonaws.com",
                           "us-west-1": "redshift.us-west-1.amazonaws.com", "us-gov-east-1": "redshift.us-gov-east-1.amazonaws.com",
                           "eu-west-3": "redshift.eu-west-3.amazonaws.com", "cn-north-1": "redshift.cn-north-1.amazonaws.com.cn",
                           "sa-east-1": "redshift.sa-east-1.amazonaws.com",
                           "eu-west-1": "redshift.eu-west-1.amazonaws.com", "us-gov-west-1": "redshift.us-gov-west-1.amazonaws.com", "ap-southeast-2": "redshift.ap-southeast-2.amazonaws.com", "ca-central-1": "redshift.ca-central-1.amazonaws.com"}.toTable, Scheme.Https: {
      "ap-northeast-1": "redshift.ap-northeast-1.amazonaws.com",
      "ap-southeast-1": "redshift.ap-southeast-1.amazonaws.com",
      "us-west-2": "redshift.us-west-2.amazonaws.com",
      "eu-west-2": "redshift.eu-west-2.amazonaws.com",
      "ap-northeast-3": "redshift.ap-northeast-3.amazonaws.com",
      "eu-central-1": "redshift.eu-central-1.amazonaws.com",
      "us-east-2": "redshift.us-east-2.amazonaws.com",
      "us-east-1": "redshift.us-east-1.amazonaws.com",
      "cn-northwest-1": "redshift.cn-northwest-1.amazonaws.com.cn",
      "ap-south-1": "redshift.ap-south-1.amazonaws.com",
      "eu-north-1": "redshift.eu-north-1.amazonaws.com",
      "ap-northeast-2": "redshift.ap-northeast-2.amazonaws.com",
      "us-west-1": "redshift.us-west-1.amazonaws.com",
      "us-gov-east-1": "redshift.us-gov-east-1.amazonaws.com",
      "eu-west-3": "redshift.eu-west-3.amazonaws.com",
      "cn-north-1": "redshift.cn-north-1.amazonaws.com.cn",
      "sa-east-1": "redshift.sa-east-1.amazonaws.com",
      "eu-west-1": "redshift.eu-west-1.amazonaws.com",
      "us-gov-west-1": "redshift.us-gov-west-1.amazonaws.com",
      "ap-southeast-2": "redshift.ap-southeast-2.amazonaws.com",
      "ca-central-1": "redshift.ca-central-1.amazonaws.com"}.toTable}.toTable
const
  awsServiceName = "redshift"
method atozHook(call: OpenApiRestCall; url: Uri; input: JsonNode): Recallable {.base.}
type
  Call_PostAcceptReservedNodeExchange_613252 = ref object of OpenApiRestCall_612642
proc url_PostAcceptReservedNodeExchange_613254(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostAcceptReservedNodeExchange_613253(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Exchanges a DC1 Reserved Node for a DC2 Reserved Node with no changes to the configuration (term, payment type, or number of nodes) and no additional costs. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_613255 = query.getOrDefault("Action")
  valid_613255 = validateParameter(valid_613255, JString, required = true, default = newJString(
      "AcceptReservedNodeExchange"))
  if valid_613255 != nil:
    section.add "Action", valid_613255
  var valid_613256 = query.getOrDefault("Version")
  valid_613256 = validateParameter(valid_613256, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_613256 != nil:
    section.add "Version", valid_613256
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613257 = header.getOrDefault("X-Amz-Signature")
  valid_613257 = validateParameter(valid_613257, JString, required = false,
                                 default = nil)
  if valid_613257 != nil:
    section.add "X-Amz-Signature", valid_613257
  var valid_613258 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613258 = validateParameter(valid_613258, JString, required = false,
                                 default = nil)
  if valid_613258 != nil:
    section.add "X-Amz-Content-Sha256", valid_613258
  var valid_613259 = header.getOrDefault("X-Amz-Date")
  valid_613259 = validateParameter(valid_613259, JString, required = false,
                                 default = nil)
  if valid_613259 != nil:
    section.add "X-Amz-Date", valid_613259
  var valid_613260 = header.getOrDefault("X-Amz-Credential")
  valid_613260 = validateParameter(valid_613260, JString, required = false,
                                 default = nil)
  if valid_613260 != nil:
    section.add "X-Amz-Credential", valid_613260
  var valid_613261 = header.getOrDefault("X-Amz-Security-Token")
  valid_613261 = validateParameter(valid_613261, JString, required = false,
                                 default = nil)
  if valid_613261 != nil:
    section.add "X-Amz-Security-Token", valid_613261
  var valid_613262 = header.getOrDefault("X-Amz-Algorithm")
  valid_613262 = validateParameter(valid_613262, JString, required = false,
                                 default = nil)
  if valid_613262 != nil:
    section.add "X-Amz-Algorithm", valid_613262
  var valid_613263 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613263 = validateParameter(valid_613263, JString, required = false,
                                 default = nil)
  if valid_613263 != nil:
    section.add "X-Amz-SignedHeaders", valid_613263
  result.add "header", section
  ## parameters in `formData` object:
  ##   ReservedNodeId: JString (required)
  ##                 : A string representing the node identifier of the DC1 Reserved Node to be exchanged.
  ##   TargetReservedNodeOfferingId: JString (required)
  ##                               : The unique identifier of the DC2 Reserved Node offering to be used for the exchange. You can obtain the value for the parameter by calling <a>GetReservedNodeExchangeOfferings</a> 
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `ReservedNodeId` field"
  var valid_613264 = formData.getOrDefault("ReservedNodeId")
  valid_613264 = validateParameter(valid_613264, JString, required = true,
                                 default = nil)
  if valid_613264 != nil:
    section.add "ReservedNodeId", valid_613264
  var valid_613265 = formData.getOrDefault("TargetReservedNodeOfferingId")
  valid_613265 = validateParameter(valid_613265, JString, required = true,
                                 default = nil)
  if valid_613265 != nil:
    section.add "TargetReservedNodeOfferingId", valid_613265
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613266: Call_PostAcceptReservedNodeExchange_613252; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Exchanges a DC1 Reserved Node for a DC2 Reserved Node with no changes to the configuration (term, payment type, or number of nodes) and no additional costs. 
  ## 
  let valid = call_613266.validator(path, query, header, formData, body)
  let scheme = call_613266.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613266.url(scheme.get, call_613266.host, call_613266.base,
                         call_613266.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613266, url, valid)

proc call*(call_613267: Call_PostAcceptReservedNodeExchange_613252;
          ReservedNodeId: string; TargetReservedNodeOfferingId: string;
          Action: string = "AcceptReservedNodeExchange";
          Version: string = "2012-12-01"): Recallable =
  ## postAcceptReservedNodeExchange
  ## Exchanges a DC1 Reserved Node for a DC2 Reserved Node with no changes to the configuration (term, payment type, or number of nodes) and no additional costs. 
  ##   ReservedNodeId: string (required)
  ##                 : A string representing the node identifier of the DC1 Reserved Node to be exchanged.
  ##   TargetReservedNodeOfferingId: string (required)
  ##                               : The unique identifier of the DC2 Reserved Node offering to be used for the exchange. You can obtain the value for the parameter by calling <a>GetReservedNodeExchangeOfferings</a> 
  ##   Action: string (required)
  ##   Version: string (required)
  var query_613268 = newJObject()
  var formData_613269 = newJObject()
  add(formData_613269, "ReservedNodeId", newJString(ReservedNodeId))
  add(formData_613269, "TargetReservedNodeOfferingId",
      newJString(TargetReservedNodeOfferingId))
  add(query_613268, "Action", newJString(Action))
  add(query_613268, "Version", newJString(Version))
  result = call_613267.call(nil, query_613268, nil, formData_613269, nil)

var postAcceptReservedNodeExchange* = Call_PostAcceptReservedNodeExchange_613252(
    name: "postAcceptReservedNodeExchange", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=AcceptReservedNodeExchange",
    validator: validate_PostAcceptReservedNodeExchange_613253, base: "/",
    url: url_PostAcceptReservedNodeExchange_613254,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetAcceptReservedNodeExchange_612980 = ref object of OpenApiRestCall_612642
proc url_GetAcceptReservedNodeExchange_612982(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetAcceptReservedNodeExchange_612981(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Exchanges a DC1 Reserved Node for a DC2 Reserved Node with no changes to the configuration (term, payment type, or number of nodes) and no additional costs. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   ReservedNodeId: JString (required)
  ##                 : A string representing the node identifier of the DC1 Reserved Node to be exchanged.
  ##   Version: JString (required)
  ##   TargetReservedNodeOfferingId: JString (required)
  ##                               : The unique identifier of the DC2 Reserved Node offering to be used for the exchange. You can obtain the value for the parameter by calling <a>GetReservedNodeExchangeOfferings</a> 
  section = newJObject()
  var valid_613107 = query.getOrDefault("Action")
  valid_613107 = validateParameter(valid_613107, JString, required = true, default = newJString(
      "AcceptReservedNodeExchange"))
  if valid_613107 != nil:
    section.add "Action", valid_613107
  var valid_613108 = query.getOrDefault("ReservedNodeId")
  valid_613108 = validateParameter(valid_613108, JString, required = true,
                                 default = nil)
  if valid_613108 != nil:
    section.add "ReservedNodeId", valid_613108
  var valid_613109 = query.getOrDefault("Version")
  valid_613109 = validateParameter(valid_613109, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_613109 != nil:
    section.add "Version", valid_613109
  var valid_613110 = query.getOrDefault("TargetReservedNodeOfferingId")
  valid_613110 = validateParameter(valid_613110, JString, required = true,
                                 default = nil)
  if valid_613110 != nil:
    section.add "TargetReservedNodeOfferingId", valid_613110
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613111 = header.getOrDefault("X-Amz-Signature")
  valid_613111 = validateParameter(valid_613111, JString, required = false,
                                 default = nil)
  if valid_613111 != nil:
    section.add "X-Amz-Signature", valid_613111
  var valid_613112 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613112 = validateParameter(valid_613112, JString, required = false,
                                 default = nil)
  if valid_613112 != nil:
    section.add "X-Amz-Content-Sha256", valid_613112
  var valid_613113 = header.getOrDefault("X-Amz-Date")
  valid_613113 = validateParameter(valid_613113, JString, required = false,
                                 default = nil)
  if valid_613113 != nil:
    section.add "X-Amz-Date", valid_613113
  var valid_613114 = header.getOrDefault("X-Amz-Credential")
  valid_613114 = validateParameter(valid_613114, JString, required = false,
                                 default = nil)
  if valid_613114 != nil:
    section.add "X-Amz-Credential", valid_613114
  var valid_613115 = header.getOrDefault("X-Amz-Security-Token")
  valid_613115 = validateParameter(valid_613115, JString, required = false,
                                 default = nil)
  if valid_613115 != nil:
    section.add "X-Amz-Security-Token", valid_613115
  var valid_613116 = header.getOrDefault("X-Amz-Algorithm")
  valid_613116 = validateParameter(valid_613116, JString, required = false,
                                 default = nil)
  if valid_613116 != nil:
    section.add "X-Amz-Algorithm", valid_613116
  var valid_613117 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613117 = validateParameter(valid_613117, JString, required = false,
                                 default = nil)
  if valid_613117 != nil:
    section.add "X-Amz-SignedHeaders", valid_613117
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613140: Call_GetAcceptReservedNodeExchange_612980; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Exchanges a DC1 Reserved Node for a DC2 Reserved Node with no changes to the configuration (term, payment type, or number of nodes) and no additional costs. 
  ## 
  let valid = call_613140.validator(path, query, header, formData, body)
  let scheme = call_613140.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613140.url(scheme.get, call_613140.host, call_613140.base,
                         call_613140.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613140, url, valid)

proc call*(call_613211: Call_GetAcceptReservedNodeExchange_612980;
          ReservedNodeId: string; TargetReservedNodeOfferingId: string;
          Action: string = "AcceptReservedNodeExchange";
          Version: string = "2012-12-01"): Recallable =
  ## getAcceptReservedNodeExchange
  ## Exchanges a DC1 Reserved Node for a DC2 Reserved Node with no changes to the configuration (term, payment type, or number of nodes) and no additional costs. 
  ##   Action: string (required)
  ##   ReservedNodeId: string (required)
  ##                 : A string representing the node identifier of the DC1 Reserved Node to be exchanged.
  ##   Version: string (required)
  ##   TargetReservedNodeOfferingId: string (required)
  ##                               : The unique identifier of the DC2 Reserved Node offering to be used for the exchange. You can obtain the value for the parameter by calling <a>GetReservedNodeExchangeOfferings</a> 
  var query_613212 = newJObject()
  add(query_613212, "Action", newJString(Action))
  add(query_613212, "ReservedNodeId", newJString(ReservedNodeId))
  add(query_613212, "Version", newJString(Version))
  add(query_613212, "TargetReservedNodeOfferingId",
      newJString(TargetReservedNodeOfferingId))
  result = call_613211.call(nil, query_613212, nil, nil, nil)

var getAcceptReservedNodeExchange* = Call_GetAcceptReservedNodeExchange_612980(
    name: "getAcceptReservedNodeExchange", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=AcceptReservedNodeExchange",
    validator: validate_GetAcceptReservedNodeExchange_612981, base: "/",
    url: url_GetAcceptReservedNodeExchange_612982,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostAuthorizeClusterSecurityGroupIngress_613289 = ref object of OpenApiRestCall_612642
proc url_PostAuthorizeClusterSecurityGroupIngress_613291(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostAuthorizeClusterSecurityGroupIngress_613290(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Adds an inbound (ingress) rule to an Amazon Redshift security group. Depending on whether the application accessing your cluster is running on the Internet or an Amazon EC2 instance, you can authorize inbound access to either a Classless Interdomain Routing (CIDR)/Internet Protocol (IP) range or to an Amazon EC2 security group. You can add as many as 20 ingress rules to an Amazon Redshift security group.</p> <p>If you authorize access to an Amazon EC2 security group, specify <i>EC2SecurityGroupName</i> and <i>EC2SecurityGroupOwnerId</i>. The Amazon EC2 security group and Amazon Redshift cluster must be in the same AWS Region. </p> <p>If you authorize access to a CIDR/IP address range, specify <i>CIDRIP</i>. For an overview of CIDR blocks, see the Wikipedia article on <a href="http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing">Classless Inter-Domain Routing</a>. </p> <p>You must also associate the security group with a cluster so that clients running on these IP addresses or the EC2 instance are authorized to connect to the cluster. For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Working with Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_613292 = query.getOrDefault("Action")
  valid_613292 = validateParameter(valid_613292, JString, required = true, default = newJString(
      "AuthorizeClusterSecurityGroupIngress"))
  if valid_613292 != nil:
    section.add "Action", valid_613292
  var valid_613293 = query.getOrDefault("Version")
  valid_613293 = validateParameter(valid_613293, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_613293 != nil:
    section.add "Version", valid_613293
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613294 = header.getOrDefault("X-Amz-Signature")
  valid_613294 = validateParameter(valid_613294, JString, required = false,
                                 default = nil)
  if valid_613294 != nil:
    section.add "X-Amz-Signature", valid_613294
  var valid_613295 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613295 = validateParameter(valid_613295, JString, required = false,
                                 default = nil)
  if valid_613295 != nil:
    section.add "X-Amz-Content-Sha256", valid_613295
  var valid_613296 = header.getOrDefault("X-Amz-Date")
  valid_613296 = validateParameter(valid_613296, JString, required = false,
                                 default = nil)
  if valid_613296 != nil:
    section.add "X-Amz-Date", valid_613296
  var valid_613297 = header.getOrDefault("X-Amz-Credential")
  valid_613297 = validateParameter(valid_613297, JString, required = false,
                                 default = nil)
  if valid_613297 != nil:
    section.add "X-Amz-Credential", valid_613297
  var valid_613298 = header.getOrDefault("X-Amz-Security-Token")
  valid_613298 = validateParameter(valid_613298, JString, required = false,
                                 default = nil)
  if valid_613298 != nil:
    section.add "X-Amz-Security-Token", valid_613298
  var valid_613299 = header.getOrDefault("X-Amz-Algorithm")
  valid_613299 = validateParameter(valid_613299, JString, required = false,
                                 default = nil)
  if valid_613299 != nil:
    section.add "X-Amz-Algorithm", valid_613299
  var valid_613300 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613300 = validateParameter(valid_613300, JString, required = false,
                                 default = nil)
  if valid_613300 != nil:
    section.add "X-Amz-SignedHeaders", valid_613300
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterSecurityGroupName: JString (required)
  ##                           : The name of the security group to which the ingress rule is added.
  ##   EC2SecurityGroupName: JString
  ##                       : The EC2 security group to be added the Amazon Redshift security group.
  ##   EC2SecurityGroupOwnerId: JString
  ##                          : <p>The AWS account number of the owner of the security group specified by the <i>EC2SecurityGroupName</i> parameter. The AWS Access Key ID is not an acceptable value. </p> <p>Example: <code>111122223333</code> </p>
  ##   CIDRIP: JString
  ##         : The IP range to be added the Amazon Redshift security group.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterSecurityGroupName` field"
  var valid_613301 = formData.getOrDefault("ClusterSecurityGroupName")
  valid_613301 = validateParameter(valid_613301, JString, required = true,
                                 default = nil)
  if valid_613301 != nil:
    section.add "ClusterSecurityGroupName", valid_613301
  var valid_613302 = formData.getOrDefault("EC2SecurityGroupName")
  valid_613302 = validateParameter(valid_613302, JString, required = false,
                                 default = nil)
  if valid_613302 != nil:
    section.add "EC2SecurityGroupName", valid_613302
  var valid_613303 = formData.getOrDefault("EC2SecurityGroupOwnerId")
  valid_613303 = validateParameter(valid_613303, JString, required = false,
                                 default = nil)
  if valid_613303 != nil:
    section.add "EC2SecurityGroupOwnerId", valid_613303
  var valid_613304 = formData.getOrDefault("CIDRIP")
  valid_613304 = validateParameter(valid_613304, JString, required = false,
                                 default = nil)
  if valid_613304 != nil:
    section.add "CIDRIP", valid_613304
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613305: Call_PostAuthorizeClusterSecurityGroupIngress_613289;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Adds an inbound (ingress) rule to an Amazon Redshift security group. Depending on whether the application accessing your cluster is running on the Internet or an Amazon EC2 instance, you can authorize inbound access to either a Classless Interdomain Routing (CIDR)/Internet Protocol (IP) range or to an Amazon EC2 security group. You can add as many as 20 ingress rules to an Amazon Redshift security group.</p> <p>If you authorize access to an Amazon EC2 security group, specify <i>EC2SecurityGroupName</i> and <i>EC2SecurityGroupOwnerId</i>. The Amazon EC2 security group and Amazon Redshift cluster must be in the same AWS Region. </p> <p>If you authorize access to a CIDR/IP address range, specify <i>CIDRIP</i>. For an overview of CIDR blocks, see the Wikipedia article on <a href="http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing">Classless Inter-Domain Routing</a>. </p> <p>You must also associate the security group with a cluster so that clients running on these IP addresses or the EC2 instance are authorized to connect to the cluster. For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Working with Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_613305.validator(path, query, header, formData, body)
  let scheme = call_613305.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613305.url(scheme.get, call_613305.host, call_613305.base,
                         call_613305.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613305, url, valid)

proc call*(call_613306: Call_PostAuthorizeClusterSecurityGroupIngress_613289;
          ClusterSecurityGroupName: string; EC2SecurityGroupName: string = "";
          EC2SecurityGroupOwnerId: string = ""; CIDRIP: string = "";
          Action: string = "AuthorizeClusterSecurityGroupIngress";
          Version: string = "2012-12-01"): Recallable =
  ## postAuthorizeClusterSecurityGroupIngress
  ## <p>Adds an inbound (ingress) rule to an Amazon Redshift security group. Depending on whether the application accessing your cluster is running on the Internet or an Amazon EC2 instance, you can authorize inbound access to either a Classless Interdomain Routing (CIDR)/Internet Protocol (IP) range or to an Amazon EC2 security group. You can add as many as 20 ingress rules to an Amazon Redshift security group.</p> <p>If you authorize access to an Amazon EC2 security group, specify <i>EC2SecurityGroupName</i> and <i>EC2SecurityGroupOwnerId</i>. The Amazon EC2 security group and Amazon Redshift cluster must be in the same AWS Region. </p> <p>If you authorize access to a CIDR/IP address range, specify <i>CIDRIP</i>. For an overview of CIDR blocks, see the Wikipedia article on <a href="http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing">Classless Inter-Domain Routing</a>. </p> <p>You must also associate the security group with a cluster so that clients running on these IP addresses or the EC2 instance are authorized to connect to the cluster. For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Working with Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   ClusterSecurityGroupName: string (required)
  ##                           : The name of the security group to which the ingress rule is added.
  ##   EC2SecurityGroupName: string
  ##                       : The EC2 security group to be added the Amazon Redshift security group.
  ##   EC2SecurityGroupOwnerId: string
  ##                          : <p>The AWS account number of the owner of the security group specified by the <i>EC2SecurityGroupName</i> parameter. The AWS Access Key ID is not an acceptable value. </p> <p>Example: <code>111122223333</code> </p>
  ##   CIDRIP: string
  ##         : The IP range to be added the Amazon Redshift security group.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_613307 = newJObject()
  var formData_613308 = newJObject()
  add(formData_613308, "ClusterSecurityGroupName",
      newJString(ClusterSecurityGroupName))
  add(formData_613308, "EC2SecurityGroupName", newJString(EC2SecurityGroupName))
  add(formData_613308, "EC2SecurityGroupOwnerId",
      newJString(EC2SecurityGroupOwnerId))
  add(formData_613308, "CIDRIP", newJString(CIDRIP))
  add(query_613307, "Action", newJString(Action))
  add(query_613307, "Version", newJString(Version))
  result = call_613306.call(nil, query_613307, nil, formData_613308, nil)

var postAuthorizeClusterSecurityGroupIngress* = Call_PostAuthorizeClusterSecurityGroupIngress_613289(
    name: "postAuthorizeClusterSecurityGroupIngress", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=AuthorizeClusterSecurityGroupIngress",
    validator: validate_PostAuthorizeClusterSecurityGroupIngress_613290,
    base: "/", url: url_PostAuthorizeClusterSecurityGroupIngress_613291,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetAuthorizeClusterSecurityGroupIngress_613270 = ref object of OpenApiRestCall_612642
proc url_GetAuthorizeClusterSecurityGroupIngress_613272(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetAuthorizeClusterSecurityGroupIngress_613271(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Adds an inbound (ingress) rule to an Amazon Redshift security group. Depending on whether the application accessing your cluster is running on the Internet or an Amazon EC2 instance, you can authorize inbound access to either a Classless Interdomain Routing (CIDR)/Internet Protocol (IP) range or to an Amazon EC2 security group. You can add as many as 20 ingress rules to an Amazon Redshift security group.</p> <p>If you authorize access to an Amazon EC2 security group, specify <i>EC2SecurityGroupName</i> and <i>EC2SecurityGroupOwnerId</i>. The Amazon EC2 security group and Amazon Redshift cluster must be in the same AWS Region. </p> <p>If you authorize access to a CIDR/IP address range, specify <i>CIDRIP</i>. For an overview of CIDR blocks, see the Wikipedia article on <a href="http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing">Classless Inter-Domain Routing</a>. </p> <p>You must also associate the security group with a cluster so that clients running on these IP addresses or the EC2 instance are authorized to connect to the cluster. For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Working with Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   EC2SecurityGroupName: JString
  ##                       : The EC2 security group to be added the Amazon Redshift security group.
  ##   EC2SecurityGroupOwnerId: JString
  ##                          : <p>The AWS account number of the owner of the security group specified by the <i>EC2SecurityGroupName</i> parameter. The AWS Access Key ID is not an acceptable value. </p> <p>Example: <code>111122223333</code> </p>
  ##   ClusterSecurityGroupName: JString (required)
  ##                           : The name of the security group to which the ingress rule is added.
  ##   Action: JString (required)
  ##   Version: JString (required)
  ##   CIDRIP: JString
  ##         : The IP range to be added the Amazon Redshift security group.
  section = newJObject()
  var valid_613273 = query.getOrDefault("EC2SecurityGroupName")
  valid_613273 = validateParameter(valid_613273, JString, required = false,
                                 default = nil)
  if valid_613273 != nil:
    section.add "EC2SecurityGroupName", valid_613273
  var valid_613274 = query.getOrDefault("EC2SecurityGroupOwnerId")
  valid_613274 = validateParameter(valid_613274, JString, required = false,
                                 default = nil)
  if valid_613274 != nil:
    section.add "EC2SecurityGroupOwnerId", valid_613274
  assert query != nil, "query argument is necessary due to required `ClusterSecurityGroupName` field"
  var valid_613275 = query.getOrDefault("ClusterSecurityGroupName")
  valid_613275 = validateParameter(valid_613275, JString, required = true,
                                 default = nil)
  if valid_613275 != nil:
    section.add "ClusterSecurityGroupName", valid_613275
  var valid_613276 = query.getOrDefault("Action")
  valid_613276 = validateParameter(valid_613276, JString, required = true, default = newJString(
      "AuthorizeClusterSecurityGroupIngress"))
  if valid_613276 != nil:
    section.add "Action", valid_613276
  var valid_613277 = query.getOrDefault("Version")
  valid_613277 = validateParameter(valid_613277, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_613277 != nil:
    section.add "Version", valid_613277
  var valid_613278 = query.getOrDefault("CIDRIP")
  valid_613278 = validateParameter(valid_613278, JString, required = false,
                                 default = nil)
  if valid_613278 != nil:
    section.add "CIDRIP", valid_613278
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613279 = header.getOrDefault("X-Amz-Signature")
  valid_613279 = validateParameter(valid_613279, JString, required = false,
                                 default = nil)
  if valid_613279 != nil:
    section.add "X-Amz-Signature", valid_613279
  var valid_613280 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613280 = validateParameter(valid_613280, JString, required = false,
                                 default = nil)
  if valid_613280 != nil:
    section.add "X-Amz-Content-Sha256", valid_613280
  var valid_613281 = header.getOrDefault("X-Amz-Date")
  valid_613281 = validateParameter(valid_613281, JString, required = false,
                                 default = nil)
  if valid_613281 != nil:
    section.add "X-Amz-Date", valid_613281
  var valid_613282 = header.getOrDefault("X-Amz-Credential")
  valid_613282 = validateParameter(valid_613282, JString, required = false,
                                 default = nil)
  if valid_613282 != nil:
    section.add "X-Amz-Credential", valid_613282
  var valid_613283 = header.getOrDefault("X-Amz-Security-Token")
  valid_613283 = validateParameter(valid_613283, JString, required = false,
                                 default = nil)
  if valid_613283 != nil:
    section.add "X-Amz-Security-Token", valid_613283
  var valid_613284 = header.getOrDefault("X-Amz-Algorithm")
  valid_613284 = validateParameter(valid_613284, JString, required = false,
                                 default = nil)
  if valid_613284 != nil:
    section.add "X-Amz-Algorithm", valid_613284
  var valid_613285 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613285 = validateParameter(valid_613285, JString, required = false,
                                 default = nil)
  if valid_613285 != nil:
    section.add "X-Amz-SignedHeaders", valid_613285
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613286: Call_GetAuthorizeClusterSecurityGroupIngress_613270;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Adds an inbound (ingress) rule to an Amazon Redshift security group. Depending on whether the application accessing your cluster is running on the Internet or an Amazon EC2 instance, you can authorize inbound access to either a Classless Interdomain Routing (CIDR)/Internet Protocol (IP) range or to an Amazon EC2 security group. You can add as many as 20 ingress rules to an Amazon Redshift security group.</p> <p>If you authorize access to an Amazon EC2 security group, specify <i>EC2SecurityGroupName</i> and <i>EC2SecurityGroupOwnerId</i>. The Amazon EC2 security group and Amazon Redshift cluster must be in the same AWS Region. </p> <p>If you authorize access to a CIDR/IP address range, specify <i>CIDRIP</i>. For an overview of CIDR blocks, see the Wikipedia article on <a href="http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing">Classless Inter-Domain Routing</a>. </p> <p>You must also associate the security group with a cluster so that clients running on these IP addresses or the EC2 instance are authorized to connect to the cluster. For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Working with Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_613286.validator(path, query, header, formData, body)
  let scheme = call_613286.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613286.url(scheme.get, call_613286.host, call_613286.base,
                         call_613286.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613286, url, valid)

proc call*(call_613287: Call_GetAuthorizeClusterSecurityGroupIngress_613270;
          ClusterSecurityGroupName: string; EC2SecurityGroupName: string = "";
          EC2SecurityGroupOwnerId: string = "";
          Action: string = "AuthorizeClusterSecurityGroupIngress";
          Version: string = "2012-12-01"; CIDRIP: string = ""): Recallable =
  ## getAuthorizeClusterSecurityGroupIngress
  ## <p>Adds an inbound (ingress) rule to an Amazon Redshift security group. Depending on whether the application accessing your cluster is running on the Internet or an Amazon EC2 instance, you can authorize inbound access to either a Classless Interdomain Routing (CIDR)/Internet Protocol (IP) range or to an Amazon EC2 security group. You can add as many as 20 ingress rules to an Amazon Redshift security group.</p> <p>If you authorize access to an Amazon EC2 security group, specify <i>EC2SecurityGroupName</i> and <i>EC2SecurityGroupOwnerId</i>. The Amazon EC2 security group and Amazon Redshift cluster must be in the same AWS Region. </p> <p>If you authorize access to a CIDR/IP address range, specify <i>CIDRIP</i>. For an overview of CIDR blocks, see the Wikipedia article on <a href="http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing">Classless Inter-Domain Routing</a>. </p> <p>You must also associate the security group with a cluster so that clients running on these IP addresses or the EC2 instance are authorized to connect to the cluster. For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Working with Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   EC2SecurityGroupName: string
  ##                       : The EC2 security group to be added the Amazon Redshift security group.
  ##   EC2SecurityGroupOwnerId: string
  ##                          : <p>The AWS account number of the owner of the security group specified by the <i>EC2SecurityGroupName</i> parameter. The AWS Access Key ID is not an acceptable value. </p> <p>Example: <code>111122223333</code> </p>
  ##   ClusterSecurityGroupName: string (required)
  ##                           : The name of the security group to which the ingress rule is added.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   CIDRIP: string
  ##         : The IP range to be added the Amazon Redshift security group.
  var query_613288 = newJObject()
  add(query_613288, "EC2SecurityGroupName", newJString(EC2SecurityGroupName))
  add(query_613288, "EC2SecurityGroupOwnerId", newJString(EC2SecurityGroupOwnerId))
  add(query_613288, "ClusterSecurityGroupName",
      newJString(ClusterSecurityGroupName))
  add(query_613288, "Action", newJString(Action))
  add(query_613288, "Version", newJString(Version))
  add(query_613288, "CIDRIP", newJString(CIDRIP))
  result = call_613287.call(nil, query_613288, nil, nil, nil)

var getAuthorizeClusterSecurityGroupIngress* = Call_GetAuthorizeClusterSecurityGroupIngress_613270(
    name: "getAuthorizeClusterSecurityGroupIngress", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=AuthorizeClusterSecurityGroupIngress",
    validator: validate_GetAuthorizeClusterSecurityGroupIngress_613271, base: "/",
    url: url_GetAuthorizeClusterSecurityGroupIngress_613272,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostAuthorizeSnapshotAccess_613327 = ref object of OpenApiRestCall_612642
proc url_PostAuthorizeSnapshotAccess_613329(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostAuthorizeSnapshotAccess_613328(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Authorizes the specified AWS customer account to restore the specified snapshot.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_613330 = query.getOrDefault("Action")
  valid_613330 = validateParameter(valid_613330, JString, required = true, default = newJString(
      "AuthorizeSnapshotAccess"))
  if valid_613330 != nil:
    section.add "Action", valid_613330
  var valid_613331 = query.getOrDefault("Version")
  valid_613331 = validateParameter(valid_613331, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_613331 != nil:
    section.add "Version", valid_613331
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613332 = header.getOrDefault("X-Amz-Signature")
  valid_613332 = validateParameter(valid_613332, JString, required = false,
                                 default = nil)
  if valid_613332 != nil:
    section.add "X-Amz-Signature", valid_613332
  var valid_613333 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613333 = validateParameter(valid_613333, JString, required = false,
                                 default = nil)
  if valid_613333 != nil:
    section.add "X-Amz-Content-Sha256", valid_613333
  var valid_613334 = header.getOrDefault("X-Amz-Date")
  valid_613334 = validateParameter(valid_613334, JString, required = false,
                                 default = nil)
  if valid_613334 != nil:
    section.add "X-Amz-Date", valid_613334
  var valid_613335 = header.getOrDefault("X-Amz-Credential")
  valid_613335 = validateParameter(valid_613335, JString, required = false,
                                 default = nil)
  if valid_613335 != nil:
    section.add "X-Amz-Credential", valid_613335
  var valid_613336 = header.getOrDefault("X-Amz-Security-Token")
  valid_613336 = validateParameter(valid_613336, JString, required = false,
                                 default = nil)
  if valid_613336 != nil:
    section.add "X-Amz-Security-Token", valid_613336
  var valid_613337 = header.getOrDefault("X-Amz-Algorithm")
  valid_613337 = validateParameter(valid_613337, JString, required = false,
                                 default = nil)
  if valid_613337 != nil:
    section.add "X-Amz-Algorithm", valid_613337
  var valid_613338 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613338 = validateParameter(valid_613338, JString, required = false,
                                 default = nil)
  if valid_613338 != nil:
    section.add "X-Amz-SignedHeaders", valid_613338
  result.add "header", section
  ## parameters in `formData` object:
  ##   SnapshotIdentifier: JString (required)
  ##                     : The identifier of the snapshot the account is authorized to restore.
  ##   AccountWithRestoreAccess: JString (required)
  ##                           : <p>The identifier of the AWS customer account authorized to restore the specified snapshot.</p> <p>To share a snapshot with AWS support, specify amazon-redshift-support.</p>
  ##   SnapshotClusterIdentifier: JString
  ##                            : The identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `SnapshotIdentifier` field"
  var valid_613339 = formData.getOrDefault("SnapshotIdentifier")
  valid_613339 = validateParameter(valid_613339, JString, required = true,
                                 default = nil)
  if valid_613339 != nil:
    section.add "SnapshotIdentifier", valid_613339
  var valid_613340 = formData.getOrDefault("AccountWithRestoreAccess")
  valid_613340 = validateParameter(valid_613340, JString, required = true,
                                 default = nil)
  if valid_613340 != nil:
    section.add "AccountWithRestoreAccess", valid_613340
  var valid_613341 = formData.getOrDefault("SnapshotClusterIdentifier")
  valid_613341 = validateParameter(valid_613341, JString, required = false,
                                 default = nil)
  if valid_613341 != nil:
    section.add "SnapshotClusterIdentifier", valid_613341
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613342: Call_PostAuthorizeSnapshotAccess_613327; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Authorizes the specified AWS customer account to restore the specified snapshot.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_613342.validator(path, query, header, formData, body)
  let scheme = call_613342.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613342.url(scheme.get, call_613342.host, call_613342.base,
                         call_613342.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613342, url, valid)

proc call*(call_613343: Call_PostAuthorizeSnapshotAccess_613327;
          SnapshotIdentifier: string; AccountWithRestoreAccess: string;
          Action: string = "AuthorizeSnapshotAccess";
          SnapshotClusterIdentifier: string = ""; Version: string = "2012-12-01"): Recallable =
  ## postAuthorizeSnapshotAccess
  ## <p>Authorizes the specified AWS customer account to restore the specified snapshot.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   SnapshotIdentifier: string (required)
  ##                     : The identifier of the snapshot the account is authorized to restore.
  ##   Action: string (required)
  ##   AccountWithRestoreAccess: string (required)
  ##                           : <p>The identifier of the AWS customer account authorized to restore the specified snapshot.</p> <p>To share a snapshot with AWS support, specify amazon-redshift-support.</p>
  ##   SnapshotClusterIdentifier: string
  ##                            : The identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.
  ##   Version: string (required)
  var query_613344 = newJObject()
  var formData_613345 = newJObject()
  add(formData_613345, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_613344, "Action", newJString(Action))
  add(formData_613345, "AccountWithRestoreAccess",
      newJString(AccountWithRestoreAccess))
  add(formData_613345, "SnapshotClusterIdentifier",
      newJString(SnapshotClusterIdentifier))
  add(query_613344, "Version", newJString(Version))
  result = call_613343.call(nil, query_613344, nil, formData_613345, nil)

var postAuthorizeSnapshotAccess* = Call_PostAuthorizeSnapshotAccess_613327(
    name: "postAuthorizeSnapshotAccess", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=AuthorizeSnapshotAccess",
    validator: validate_PostAuthorizeSnapshotAccess_613328, base: "/",
    url: url_PostAuthorizeSnapshotAccess_613329,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetAuthorizeSnapshotAccess_613309 = ref object of OpenApiRestCall_612642
proc url_GetAuthorizeSnapshotAccess_613311(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetAuthorizeSnapshotAccess_613310(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Authorizes the specified AWS customer account to restore the specified snapshot.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   SnapshotIdentifier: JString (required)
  ##                     : The identifier of the snapshot the account is authorized to restore.
  ##   SnapshotClusterIdentifier: JString
  ##                            : The identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.
  ##   Action: JString (required)
  ##   Version: JString (required)
  ##   AccountWithRestoreAccess: JString (required)
  ##                           : <p>The identifier of the AWS customer account authorized to restore the specified snapshot.</p> <p>To share a snapshot with AWS support, specify amazon-redshift-support.</p>
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `SnapshotIdentifier` field"
  var valid_613312 = query.getOrDefault("SnapshotIdentifier")
  valid_613312 = validateParameter(valid_613312, JString, required = true,
                                 default = nil)
  if valid_613312 != nil:
    section.add "SnapshotIdentifier", valid_613312
  var valid_613313 = query.getOrDefault("SnapshotClusterIdentifier")
  valid_613313 = validateParameter(valid_613313, JString, required = false,
                                 default = nil)
  if valid_613313 != nil:
    section.add "SnapshotClusterIdentifier", valid_613313
  var valid_613314 = query.getOrDefault("Action")
  valid_613314 = validateParameter(valid_613314, JString, required = true, default = newJString(
      "AuthorizeSnapshotAccess"))
  if valid_613314 != nil:
    section.add "Action", valid_613314
  var valid_613315 = query.getOrDefault("Version")
  valid_613315 = validateParameter(valid_613315, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_613315 != nil:
    section.add "Version", valid_613315
  var valid_613316 = query.getOrDefault("AccountWithRestoreAccess")
  valid_613316 = validateParameter(valid_613316, JString, required = true,
                                 default = nil)
  if valid_613316 != nil:
    section.add "AccountWithRestoreAccess", valid_613316
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613317 = header.getOrDefault("X-Amz-Signature")
  valid_613317 = validateParameter(valid_613317, JString, required = false,
                                 default = nil)
  if valid_613317 != nil:
    section.add "X-Amz-Signature", valid_613317
  var valid_613318 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613318 = validateParameter(valid_613318, JString, required = false,
                                 default = nil)
  if valid_613318 != nil:
    section.add "X-Amz-Content-Sha256", valid_613318
  var valid_613319 = header.getOrDefault("X-Amz-Date")
  valid_613319 = validateParameter(valid_613319, JString, required = false,
                                 default = nil)
  if valid_613319 != nil:
    section.add "X-Amz-Date", valid_613319
  var valid_613320 = header.getOrDefault("X-Amz-Credential")
  valid_613320 = validateParameter(valid_613320, JString, required = false,
                                 default = nil)
  if valid_613320 != nil:
    section.add "X-Amz-Credential", valid_613320
  var valid_613321 = header.getOrDefault("X-Amz-Security-Token")
  valid_613321 = validateParameter(valid_613321, JString, required = false,
                                 default = nil)
  if valid_613321 != nil:
    section.add "X-Amz-Security-Token", valid_613321
  var valid_613322 = header.getOrDefault("X-Amz-Algorithm")
  valid_613322 = validateParameter(valid_613322, JString, required = false,
                                 default = nil)
  if valid_613322 != nil:
    section.add "X-Amz-Algorithm", valid_613322
  var valid_613323 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613323 = validateParameter(valid_613323, JString, required = false,
                                 default = nil)
  if valid_613323 != nil:
    section.add "X-Amz-SignedHeaders", valid_613323
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613324: Call_GetAuthorizeSnapshotAccess_613309; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Authorizes the specified AWS customer account to restore the specified snapshot.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_613324.validator(path, query, header, formData, body)
  let scheme = call_613324.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613324.url(scheme.get, call_613324.host, call_613324.base,
                         call_613324.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613324, url, valid)

proc call*(call_613325: Call_GetAuthorizeSnapshotAccess_613309;
          SnapshotIdentifier: string; AccountWithRestoreAccess: string;
          SnapshotClusterIdentifier: string = "";
          Action: string = "AuthorizeSnapshotAccess"; Version: string = "2012-12-01"): Recallable =
  ## getAuthorizeSnapshotAccess
  ## <p>Authorizes the specified AWS customer account to restore the specified snapshot.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   SnapshotIdentifier: string (required)
  ##                     : The identifier of the snapshot the account is authorized to restore.
  ##   SnapshotClusterIdentifier: string
  ##                            : The identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   AccountWithRestoreAccess: string (required)
  ##                           : <p>The identifier of the AWS customer account authorized to restore the specified snapshot.</p> <p>To share a snapshot with AWS support, specify amazon-redshift-support.</p>
  var query_613326 = newJObject()
  add(query_613326, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_613326, "SnapshotClusterIdentifier",
      newJString(SnapshotClusterIdentifier))
  add(query_613326, "Action", newJString(Action))
  add(query_613326, "Version", newJString(Version))
  add(query_613326, "AccountWithRestoreAccess",
      newJString(AccountWithRestoreAccess))
  result = call_613325.call(nil, query_613326, nil, nil, nil)

var getAuthorizeSnapshotAccess* = Call_GetAuthorizeSnapshotAccess_613309(
    name: "getAuthorizeSnapshotAccess", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=AuthorizeSnapshotAccess",
    validator: validate_GetAuthorizeSnapshotAccess_613310, base: "/",
    url: url_GetAuthorizeSnapshotAccess_613311,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostBatchDeleteClusterSnapshots_613362 = ref object of OpenApiRestCall_612642
proc url_PostBatchDeleteClusterSnapshots_613364(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostBatchDeleteClusterSnapshots_613363(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a set of cluster snapshots.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_613365 = query.getOrDefault("Action")
  valid_613365 = validateParameter(valid_613365, JString, required = true, default = newJString(
      "BatchDeleteClusterSnapshots"))
  if valid_613365 != nil:
    section.add "Action", valid_613365
  var valid_613366 = query.getOrDefault("Version")
  valid_613366 = validateParameter(valid_613366, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_613366 != nil:
    section.add "Version", valid_613366
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613367 = header.getOrDefault("X-Amz-Signature")
  valid_613367 = validateParameter(valid_613367, JString, required = false,
                                 default = nil)
  if valid_613367 != nil:
    section.add "X-Amz-Signature", valid_613367
  var valid_613368 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613368 = validateParameter(valid_613368, JString, required = false,
                                 default = nil)
  if valid_613368 != nil:
    section.add "X-Amz-Content-Sha256", valid_613368
  var valid_613369 = header.getOrDefault("X-Amz-Date")
  valid_613369 = validateParameter(valid_613369, JString, required = false,
                                 default = nil)
  if valid_613369 != nil:
    section.add "X-Amz-Date", valid_613369
  var valid_613370 = header.getOrDefault("X-Amz-Credential")
  valid_613370 = validateParameter(valid_613370, JString, required = false,
                                 default = nil)
  if valid_613370 != nil:
    section.add "X-Amz-Credential", valid_613370
  var valid_613371 = header.getOrDefault("X-Amz-Security-Token")
  valid_613371 = validateParameter(valid_613371, JString, required = false,
                                 default = nil)
  if valid_613371 != nil:
    section.add "X-Amz-Security-Token", valid_613371
  var valid_613372 = header.getOrDefault("X-Amz-Algorithm")
  valid_613372 = validateParameter(valid_613372, JString, required = false,
                                 default = nil)
  if valid_613372 != nil:
    section.add "X-Amz-Algorithm", valid_613372
  var valid_613373 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613373 = validateParameter(valid_613373, JString, required = false,
                                 default = nil)
  if valid_613373 != nil:
    section.add "X-Amz-SignedHeaders", valid_613373
  result.add "header", section
  ## parameters in `formData` object:
  ##   Identifiers: JArray (required)
  ##              : A list of identifiers for the snapshots that you want to delete.
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `Identifiers` field"
  var valid_613374 = formData.getOrDefault("Identifiers")
  valid_613374 = validateParameter(valid_613374, JArray, required = true, default = nil)
  if valid_613374 != nil:
    section.add "Identifiers", valid_613374
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613375: Call_PostBatchDeleteClusterSnapshots_613362;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Deletes a set of cluster snapshots.
  ## 
  let valid = call_613375.validator(path, query, header, formData, body)
  let scheme = call_613375.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613375.url(scheme.get, call_613375.host, call_613375.base,
                         call_613375.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613375, url, valid)

proc call*(call_613376: Call_PostBatchDeleteClusterSnapshots_613362;
          Identifiers: JsonNode; Action: string = "BatchDeleteClusterSnapshots";
          Version: string = "2012-12-01"): Recallable =
  ## postBatchDeleteClusterSnapshots
  ## Deletes a set of cluster snapshots.
  ##   Identifiers: JArray (required)
  ##              : A list of identifiers for the snapshots that you want to delete.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_613377 = newJObject()
  var formData_613378 = newJObject()
  if Identifiers != nil:
    formData_613378.add "Identifiers", Identifiers
  add(query_613377, "Action", newJString(Action))
  add(query_613377, "Version", newJString(Version))
  result = call_613376.call(nil, query_613377, nil, formData_613378, nil)

var postBatchDeleteClusterSnapshots* = Call_PostBatchDeleteClusterSnapshots_613362(
    name: "postBatchDeleteClusterSnapshots", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=BatchDeleteClusterSnapshots",
    validator: validate_PostBatchDeleteClusterSnapshots_613363, base: "/",
    url: url_PostBatchDeleteClusterSnapshots_613364,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetBatchDeleteClusterSnapshots_613346 = ref object of OpenApiRestCall_612642
proc url_GetBatchDeleteClusterSnapshots_613348(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetBatchDeleteClusterSnapshots_613347(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a set of cluster snapshots.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Identifiers: JArray (required)
  ##              : A list of identifiers for the snapshots that you want to delete.
  ##   Version: JString (required)
  section = newJObject()
  var valid_613349 = query.getOrDefault("Action")
  valid_613349 = validateParameter(valid_613349, JString, required = true, default = newJString(
      "BatchDeleteClusterSnapshots"))
  if valid_613349 != nil:
    section.add "Action", valid_613349
  var valid_613350 = query.getOrDefault("Identifiers")
  valid_613350 = validateParameter(valid_613350, JArray, required = true, default = nil)
  if valid_613350 != nil:
    section.add "Identifiers", valid_613350
  var valid_613351 = query.getOrDefault("Version")
  valid_613351 = validateParameter(valid_613351, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_613351 != nil:
    section.add "Version", valid_613351
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613352 = header.getOrDefault("X-Amz-Signature")
  valid_613352 = validateParameter(valid_613352, JString, required = false,
                                 default = nil)
  if valid_613352 != nil:
    section.add "X-Amz-Signature", valid_613352
  var valid_613353 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613353 = validateParameter(valid_613353, JString, required = false,
                                 default = nil)
  if valid_613353 != nil:
    section.add "X-Amz-Content-Sha256", valid_613353
  var valid_613354 = header.getOrDefault("X-Amz-Date")
  valid_613354 = validateParameter(valid_613354, JString, required = false,
                                 default = nil)
  if valid_613354 != nil:
    section.add "X-Amz-Date", valid_613354
  var valid_613355 = header.getOrDefault("X-Amz-Credential")
  valid_613355 = validateParameter(valid_613355, JString, required = false,
                                 default = nil)
  if valid_613355 != nil:
    section.add "X-Amz-Credential", valid_613355
  var valid_613356 = header.getOrDefault("X-Amz-Security-Token")
  valid_613356 = validateParameter(valid_613356, JString, required = false,
                                 default = nil)
  if valid_613356 != nil:
    section.add "X-Amz-Security-Token", valid_613356
  var valid_613357 = header.getOrDefault("X-Amz-Algorithm")
  valid_613357 = validateParameter(valid_613357, JString, required = false,
                                 default = nil)
  if valid_613357 != nil:
    section.add "X-Amz-Algorithm", valid_613357
  var valid_613358 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613358 = validateParameter(valid_613358, JString, required = false,
                                 default = nil)
  if valid_613358 != nil:
    section.add "X-Amz-SignedHeaders", valid_613358
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613359: Call_GetBatchDeleteClusterSnapshots_613346; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a set of cluster snapshots.
  ## 
  let valid = call_613359.validator(path, query, header, formData, body)
  let scheme = call_613359.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613359.url(scheme.get, call_613359.host, call_613359.base,
                         call_613359.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613359, url, valid)

proc call*(call_613360: Call_GetBatchDeleteClusterSnapshots_613346;
          Identifiers: JsonNode; Action: string = "BatchDeleteClusterSnapshots";
          Version: string = "2012-12-01"): Recallable =
  ## getBatchDeleteClusterSnapshots
  ## Deletes a set of cluster snapshots.
  ##   Action: string (required)
  ##   Identifiers: JArray (required)
  ##              : A list of identifiers for the snapshots that you want to delete.
  ##   Version: string (required)
  var query_613361 = newJObject()
  add(query_613361, "Action", newJString(Action))
  if Identifiers != nil:
    query_613361.add "Identifiers", Identifiers
  add(query_613361, "Version", newJString(Version))
  result = call_613360.call(nil, query_613361, nil, nil, nil)

var getBatchDeleteClusterSnapshots* = Call_GetBatchDeleteClusterSnapshots_613346(
    name: "getBatchDeleteClusterSnapshots", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=BatchDeleteClusterSnapshots",
    validator: validate_GetBatchDeleteClusterSnapshots_613347, base: "/",
    url: url_GetBatchDeleteClusterSnapshots_613348,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostBatchModifyClusterSnapshots_613397 = ref object of OpenApiRestCall_612642
proc url_PostBatchModifyClusterSnapshots_613399(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostBatchModifyClusterSnapshots_613398(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies the settings for a set of cluster snapshots.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_613400 = query.getOrDefault("Action")
  valid_613400 = validateParameter(valid_613400, JString, required = true, default = newJString(
      "BatchModifyClusterSnapshots"))
  if valid_613400 != nil:
    section.add "Action", valid_613400
  var valid_613401 = query.getOrDefault("Version")
  valid_613401 = validateParameter(valid_613401, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_613401 != nil:
    section.add "Version", valid_613401
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613402 = header.getOrDefault("X-Amz-Signature")
  valid_613402 = validateParameter(valid_613402, JString, required = false,
                                 default = nil)
  if valid_613402 != nil:
    section.add "X-Amz-Signature", valid_613402
  var valid_613403 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613403 = validateParameter(valid_613403, JString, required = false,
                                 default = nil)
  if valid_613403 != nil:
    section.add "X-Amz-Content-Sha256", valid_613403
  var valid_613404 = header.getOrDefault("X-Amz-Date")
  valid_613404 = validateParameter(valid_613404, JString, required = false,
                                 default = nil)
  if valid_613404 != nil:
    section.add "X-Amz-Date", valid_613404
  var valid_613405 = header.getOrDefault("X-Amz-Credential")
  valid_613405 = validateParameter(valid_613405, JString, required = false,
                                 default = nil)
  if valid_613405 != nil:
    section.add "X-Amz-Credential", valid_613405
  var valid_613406 = header.getOrDefault("X-Amz-Security-Token")
  valid_613406 = validateParameter(valid_613406, JString, required = false,
                                 default = nil)
  if valid_613406 != nil:
    section.add "X-Amz-Security-Token", valid_613406
  var valid_613407 = header.getOrDefault("X-Amz-Algorithm")
  valid_613407 = validateParameter(valid_613407, JString, required = false,
                                 default = nil)
  if valid_613407 != nil:
    section.add "X-Amz-Algorithm", valid_613407
  var valid_613408 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613408 = validateParameter(valid_613408, JString, required = false,
                                 default = nil)
  if valid_613408 != nil:
    section.add "X-Amz-SignedHeaders", valid_613408
  result.add "header", section
  ## parameters in `formData` object:
  ##   Force: JBool
  ##        : A boolean value indicating whether to override an exception if the retention period has passed. 
  ##   SnapshotIdentifierList: JArray (required)
  ##                         : A list of snapshot identifiers you want to modify.
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The number of days that a manual snapshot is retained. If you specify the value -1, the manual snapshot is retained indefinitely.</p> <p>The number must be either -1 or an integer between 1 and 3,653.</p> <p>If you decrease the manual snapshot retention period from its current value, existing manual snapshots that fall outside of the new retention period will return an error. If you want to suppress the errors and delete the snapshots, use the force option. </p>
  section = newJObject()
  var valid_613409 = formData.getOrDefault("Force")
  valid_613409 = validateParameter(valid_613409, JBool, required = false, default = nil)
  if valid_613409 != nil:
    section.add "Force", valid_613409
  assert formData != nil, "formData argument is necessary due to required `SnapshotIdentifierList` field"
  var valid_613410 = formData.getOrDefault("SnapshotIdentifierList")
  valid_613410 = validateParameter(valid_613410, JArray, required = true, default = nil)
  if valid_613410 != nil:
    section.add "SnapshotIdentifierList", valid_613410
  var valid_613411 = formData.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_613411 = validateParameter(valid_613411, JInt, required = false, default = nil)
  if valid_613411 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_613411
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613412: Call_PostBatchModifyClusterSnapshots_613397;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Modifies the settings for a set of cluster snapshots.
  ## 
  let valid = call_613412.validator(path, query, header, formData, body)
  let scheme = call_613412.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613412.url(scheme.get, call_613412.host, call_613412.base,
                         call_613412.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613412, url, valid)

proc call*(call_613413: Call_PostBatchModifyClusterSnapshots_613397;
          SnapshotIdentifierList: JsonNode; Force: bool = false;
          Action: string = "BatchModifyClusterSnapshots";
          Version: string = "2012-12-01"; ManualSnapshotRetentionPeriod: int = 0): Recallable =
  ## postBatchModifyClusterSnapshots
  ## Modifies the settings for a set of cluster snapshots.
  ##   Force: bool
  ##        : A boolean value indicating whether to override an exception if the retention period has passed. 
  ##   SnapshotIdentifierList: JArray (required)
  ##                         : A list of snapshot identifiers you want to modify.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The number of days that a manual snapshot is retained. If you specify the value -1, the manual snapshot is retained indefinitely.</p> <p>The number must be either -1 or an integer between 1 and 3,653.</p> <p>If you decrease the manual snapshot retention period from its current value, existing manual snapshots that fall outside of the new retention period will return an error. If you want to suppress the errors and delete the snapshots, use the force option. </p>
  var query_613414 = newJObject()
  var formData_613415 = newJObject()
  add(formData_613415, "Force", newJBool(Force))
  if SnapshotIdentifierList != nil:
    formData_613415.add "SnapshotIdentifierList", SnapshotIdentifierList
  add(query_613414, "Action", newJString(Action))
  add(query_613414, "Version", newJString(Version))
  add(formData_613415, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  result = call_613413.call(nil, query_613414, nil, formData_613415, nil)

var postBatchModifyClusterSnapshots* = Call_PostBatchModifyClusterSnapshots_613397(
    name: "postBatchModifyClusterSnapshots", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=BatchModifyClusterSnapshots",
    validator: validate_PostBatchModifyClusterSnapshots_613398, base: "/",
    url: url_PostBatchModifyClusterSnapshots_613399,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetBatchModifyClusterSnapshots_613379 = ref object of OpenApiRestCall_612642
proc url_GetBatchModifyClusterSnapshots_613381(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetBatchModifyClusterSnapshots_613380(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies the settings for a set of cluster snapshots.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The number of days that a manual snapshot is retained. If you specify the value -1, the manual snapshot is retained indefinitely.</p> <p>The number must be either -1 or an integer between 1 and 3,653.</p> <p>If you decrease the manual snapshot retention period from its current value, existing manual snapshots that fall outside of the new retention period will return an error. If you want to suppress the errors and delete the snapshots, use the force option. </p>
  ##   Force: JBool
  ##        : A boolean value indicating whether to override an exception if the retention period has passed. 
  ##   Action: JString (required)
  ##   SnapshotIdentifierList: JArray (required)
  ##                         : A list of snapshot identifiers you want to modify.
  ##   Version: JString (required)
  section = newJObject()
  var valid_613382 = query.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_613382 = validateParameter(valid_613382, JInt, required = false, default = nil)
  if valid_613382 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_613382
  var valid_613383 = query.getOrDefault("Force")
  valid_613383 = validateParameter(valid_613383, JBool, required = false, default = nil)
  if valid_613383 != nil:
    section.add "Force", valid_613383
  var valid_613384 = query.getOrDefault("Action")
  valid_613384 = validateParameter(valid_613384, JString, required = true, default = newJString(
      "BatchModifyClusterSnapshots"))
  if valid_613384 != nil:
    section.add "Action", valid_613384
  var valid_613385 = query.getOrDefault("SnapshotIdentifierList")
  valid_613385 = validateParameter(valid_613385, JArray, required = true, default = nil)
  if valid_613385 != nil:
    section.add "SnapshotIdentifierList", valid_613385
  var valid_613386 = query.getOrDefault("Version")
  valid_613386 = validateParameter(valid_613386, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_613386 != nil:
    section.add "Version", valid_613386
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613387 = header.getOrDefault("X-Amz-Signature")
  valid_613387 = validateParameter(valid_613387, JString, required = false,
                                 default = nil)
  if valid_613387 != nil:
    section.add "X-Amz-Signature", valid_613387
  var valid_613388 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613388 = validateParameter(valid_613388, JString, required = false,
                                 default = nil)
  if valid_613388 != nil:
    section.add "X-Amz-Content-Sha256", valid_613388
  var valid_613389 = header.getOrDefault("X-Amz-Date")
  valid_613389 = validateParameter(valid_613389, JString, required = false,
                                 default = nil)
  if valid_613389 != nil:
    section.add "X-Amz-Date", valid_613389
  var valid_613390 = header.getOrDefault("X-Amz-Credential")
  valid_613390 = validateParameter(valid_613390, JString, required = false,
                                 default = nil)
  if valid_613390 != nil:
    section.add "X-Amz-Credential", valid_613390
  var valid_613391 = header.getOrDefault("X-Amz-Security-Token")
  valid_613391 = validateParameter(valid_613391, JString, required = false,
                                 default = nil)
  if valid_613391 != nil:
    section.add "X-Amz-Security-Token", valid_613391
  var valid_613392 = header.getOrDefault("X-Amz-Algorithm")
  valid_613392 = validateParameter(valid_613392, JString, required = false,
                                 default = nil)
  if valid_613392 != nil:
    section.add "X-Amz-Algorithm", valid_613392
  var valid_613393 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613393 = validateParameter(valid_613393, JString, required = false,
                                 default = nil)
  if valid_613393 != nil:
    section.add "X-Amz-SignedHeaders", valid_613393
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613394: Call_GetBatchModifyClusterSnapshots_613379; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Modifies the settings for a set of cluster snapshots.
  ## 
  let valid = call_613394.validator(path, query, header, formData, body)
  let scheme = call_613394.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613394.url(scheme.get, call_613394.host, call_613394.base,
                         call_613394.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613394, url, valid)

proc call*(call_613395: Call_GetBatchModifyClusterSnapshots_613379;
          SnapshotIdentifierList: JsonNode;
          ManualSnapshotRetentionPeriod: int = 0; Force: bool = false;
          Action: string = "BatchModifyClusterSnapshots";
          Version: string = "2012-12-01"): Recallable =
  ## getBatchModifyClusterSnapshots
  ## Modifies the settings for a set of cluster snapshots.
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The number of days that a manual snapshot is retained. If you specify the value -1, the manual snapshot is retained indefinitely.</p> <p>The number must be either -1 or an integer between 1 and 3,653.</p> <p>If you decrease the manual snapshot retention period from its current value, existing manual snapshots that fall outside of the new retention period will return an error. If you want to suppress the errors and delete the snapshots, use the force option. </p>
  ##   Force: bool
  ##        : A boolean value indicating whether to override an exception if the retention period has passed. 
  ##   Action: string (required)
  ##   SnapshotIdentifierList: JArray (required)
  ##                         : A list of snapshot identifiers you want to modify.
  ##   Version: string (required)
  var query_613396 = newJObject()
  add(query_613396, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  add(query_613396, "Force", newJBool(Force))
  add(query_613396, "Action", newJString(Action))
  if SnapshotIdentifierList != nil:
    query_613396.add "SnapshotIdentifierList", SnapshotIdentifierList
  add(query_613396, "Version", newJString(Version))
  result = call_613395.call(nil, query_613396, nil, nil, nil)

var getBatchModifyClusterSnapshots* = Call_GetBatchModifyClusterSnapshots_613379(
    name: "getBatchModifyClusterSnapshots", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=BatchModifyClusterSnapshots",
    validator: validate_GetBatchModifyClusterSnapshots_613380, base: "/",
    url: url_GetBatchModifyClusterSnapshots_613381,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCancelResize_613432 = ref object of OpenApiRestCall_612642
proc url_PostCancelResize_613434(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostCancelResize_613433(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Cancels a resize operation for a cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_613435 = query.getOrDefault("Action")
  valid_613435 = validateParameter(valid_613435, JString, required = true,
                                 default = newJString("CancelResize"))
  if valid_613435 != nil:
    section.add "Action", valid_613435
  var valid_613436 = query.getOrDefault("Version")
  valid_613436 = validateParameter(valid_613436, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_613436 != nil:
    section.add "Version", valid_613436
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613437 = header.getOrDefault("X-Amz-Signature")
  valid_613437 = validateParameter(valid_613437, JString, required = false,
                                 default = nil)
  if valid_613437 != nil:
    section.add "X-Amz-Signature", valid_613437
  var valid_613438 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613438 = validateParameter(valid_613438, JString, required = false,
                                 default = nil)
  if valid_613438 != nil:
    section.add "X-Amz-Content-Sha256", valid_613438
  var valid_613439 = header.getOrDefault("X-Amz-Date")
  valid_613439 = validateParameter(valid_613439, JString, required = false,
                                 default = nil)
  if valid_613439 != nil:
    section.add "X-Amz-Date", valid_613439
  var valid_613440 = header.getOrDefault("X-Amz-Credential")
  valid_613440 = validateParameter(valid_613440, JString, required = false,
                                 default = nil)
  if valid_613440 != nil:
    section.add "X-Amz-Credential", valid_613440
  var valid_613441 = header.getOrDefault("X-Amz-Security-Token")
  valid_613441 = validateParameter(valid_613441, JString, required = false,
                                 default = nil)
  if valid_613441 != nil:
    section.add "X-Amz-Security-Token", valid_613441
  var valid_613442 = header.getOrDefault("X-Amz-Algorithm")
  valid_613442 = validateParameter(valid_613442, JString, required = false,
                                 default = nil)
  if valid_613442 != nil:
    section.add "X-Amz-Algorithm", valid_613442
  var valid_613443 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613443 = validateParameter(valid_613443, JString, required = false,
                                 default = nil)
  if valid_613443 != nil:
    section.add "X-Amz-SignedHeaders", valid_613443
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : The unique identifier for the cluster that you want to cancel a resize operation for.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_613444 = formData.getOrDefault("ClusterIdentifier")
  valid_613444 = validateParameter(valid_613444, JString, required = true,
                                 default = nil)
  if valid_613444 != nil:
    section.add "ClusterIdentifier", valid_613444
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613445: Call_PostCancelResize_613432; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Cancels a resize operation for a cluster.
  ## 
  let valid = call_613445.validator(path, query, header, formData, body)
  let scheme = call_613445.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613445.url(scheme.get, call_613445.host, call_613445.base,
                         call_613445.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613445, url, valid)

proc call*(call_613446: Call_PostCancelResize_613432; ClusterIdentifier: string;
          Action: string = "CancelResize"; Version: string = "2012-12-01"): Recallable =
  ## postCancelResize
  ## Cancels a resize operation for a cluster.
  ##   ClusterIdentifier: string (required)
  ##                    : The unique identifier for the cluster that you want to cancel a resize operation for.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_613447 = newJObject()
  var formData_613448 = newJObject()
  add(formData_613448, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_613447, "Action", newJString(Action))
  add(query_613447, "Version", newJString(Version))
  result = call_613446.call(nil, query_613447, nil, formData_613448, nil)

var postCancelResize* = Call_PostCancelResize_613432(name: "postCancelResize",
    meth: HttpMethod.HttpPost, host: "redshift.amazonaws.com",
    route: "/#Action=CancelResize", validator: validate_PostCancelResize_613433,
    base: "/", url: url_PostCancelResize_613434,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCancelResize_613416 = ref object of OpenApiRestCall_612642
proc url_GetCancelResize_613418(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetCancelResize_613417(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Cancels a resize operation for a cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : The unique identifier for the cluster that you want to cancel a resize operation for.
  ##   Version: JString (required)
  section = newJObject()
  var valid_613419 = query.getOrDefault("Action")
  valid_613419 = validateParameter(valid_613419, JString, required = true,
                                 default = newJString("CancelResize"))
  if valid_613419 != nil:
    section.add "Action", valid_613419
  var valid_613420 = query.getOrDefault("ClusterIdentifier")
  valid_613420 = validateParameter(valid_613420, JString, required = true,
                                 default = nil)
  if valid_613420 != nil:
    section.add "ClusterIdentifier", valid_613420
  var valid_613421 = query.getOrDefault("Version")
  valid_613421 = validateParameter(valid_613421, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_613421 != nil:
    section.add "Version", valid_613421
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613422 = header.getOrDefault("X-Amz-Signature")
  valid_613422 = validateParameter(valid_613422, JString, required = false,
                                 default = nil)
  if valid_613422 != nil:
    section.add "X-Amz-Signature", valid_613422
  var valid_613423 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613423 = validateParameter(valid_613423, JString, required = false,
                                 default = nil)
  if valid_613423 != nil:
    section.add "X-Amz-Content-Sha256", valid_613423
  var valid_613424 = header.getOrDefault("X-Amz-Date")
  valid_613424 = validateParameter(valid_613424, JString, required = false,
                                 default = nil)
  if valid_613424 != nil:
    section.add "X-Amz-Date", valid_613424
  var valid_613425 = header.getOrDefault("X-Amz-Credential")
  valid_613425 = validateParameter(valid_613425, JString, required = false,
                                 default = nil)
  if valid_613425 != nil:
    section.add "X-Amz-Credential", valid_613425
  var valid_613426 = header.getOrDefault("X-Amz-Security-Token")
  valid_613426 = validateParameter(valid_613426, JString, required = false,
                                 default = nil)
  if valid_613426 != nil:
    section.add "X-Amz-Security-Token", valid_613426
  var valid_613427 = header.getOrDefault("X-Amz-Algorithm")
  valid_613427 = validateParameter(valid_613427, JString, required = false,
                                 default = nil)
  if valid_613427 != nil:
    section.add "X-Amz-Algorithm", valid_613427
  var valid_613428 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613428 = validateParameter(valid_613428, JString, required = false,
                                 default = nil)
  if valid_613428 != nil:
    section.add "X-Amz-SignedHeaders", valid_613428
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613429: Call_GetCancelResize_613416; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Cancels a resize operation for a cluster.
  ## 
  let valid = call_613429.validator(path, query, header, formData, body)
  let scheme = call_613429.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613429.url(scheme.get, call_613429.host, call_613429.base,
                         call_613429.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613429, url, valid)

proc call*(call_613430: Call_GetCancelResize_613416; ClusterIdentifier: string;
          Action: string = "CancelResize"; Version: string = "2012-12-01"): Recallable =
  ## getCancelResize
  ## Cancels a resize operation for a cluster.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : The unique identifier for the cluster that you want to cancel a resize operation for.
  ##   Version: string (required)
  var query_613431 = newJObject()
  add(query_613431, "Action", newJString(Action))
  add(query_613431, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_613431, "Version", newJString(Version))
  result = call_613430.call(nil, query_613431, nil, nil, nil)

var getCancelResize* = Call_GetCancelResize_613416(name: "getCancelResize",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=CancelResize", validator: validate_GetCancelResize_613417,
    base: "/", url: url_GetCancelResize_613418, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCopyClusterSnapshot_613468 = ref object of OpenApiRestCall_612642
proc url_PostCopyClusterSnapshot_613470(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostCopyClusterSnapshot_613469(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Copies the specified automated cluster snapshot to a new manual cluster snapshot. The source must be an automated snapshot and it must be in the available state.</p> <p>When you delete a cluster, Amazon Redshift deletes any automated snapshots of the cluster. Also, when the retention period of the snapshot expires, Amazon Redshift automatically deletes it. If you want to keep an automated snapshot for a longer period, you can make a manual copy of the snapshot. Manual snapshots are retained until you delete them.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_613471 = query.getOrDefault("Action")
  valid_613471 = validateParameter(valid_613471, JString, required = true,
                                 default = newJString("CopyClusterSnapshot"))
  if valid_613471 != nil:
    section.add "Action", valid_613471
  var valid_613472 = query.getOrDefault("Version")
  valid_613472 = validateParameter(valid_613472, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_613472 != nil:
    section.add "Version", valid_613472
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613473 = header.getOrDefault("X-Amz-Signature")
  valid_613473 = validateParameter(valid_613473, JString, required = false,
                                 default = nil)
  if valid_613473 != nil:
    section.add "X-Amz-Signature", valid_613473
  var valid_613474 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613474 = validateParameter(valid_613474, JString, required = false,
                                 default = nil)
  if valid_613474 != nil:
    section.add "X-Amz-Content-Sha256", valid_613474
  var valid_613475 = header.getOrDefault("X-Amz-Date")
  valid_613475 = validateParameter(valid_613475, JString, required = false,
                                 default = nil)
  if valid_613475 != nil:
    section.add "X-Amz-Date", valid_613475
  var valid_613476 = header.getOrDefault("X-Amz-Credential")
  valid_613476 = validateParameter(valid_613476, JString, required = false,
                                 default = nil)
  if valid_613476 != nil:
    section.add "X-Amz-Credential", valid_613476
  var valid_613477 = header.getOrDefault("X-Amz-Security-Token")
  valid_613477 = validateParameter(valid_613477, JString, required = false,
                                 default = nil)
  if valid_613477 != nil:
    section.add "X-Amz-Security-Token", valid_613477
  var valid_613478 = header.getOrDefault("X-Amz-Algorithm")
  valid_613478 = validateParameter(valid_613478, JString, required = false,
                                 default = nil)
  if valid_613478 != nil:
    section.add "X-Amz-Algorithm", valid_613478
  var valid_613479 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613479 = validateParameter(valid_613479, JString, required = false,
                                 default = nil)
  if valid_613479 != nil:
    section.add "X-Amz-SignedHeaders", valid_613479
  result.add "header", section
  ## parameters in `formData` object:
  ##   SourceSnapshotIdentifier: JString (required)
  ##                           : <p>The identifier for the source snapshot.</p> <p>Constraints:</p> <ul> <li> <p>Must be the identifier for a valid automated snapshot whose state is <code>available</code>.</p> </li> </ul>
  ##   SourceSnapshotClusterIdentifier: JString
  ##                                  : <p>The identifier of the cluster the source snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.</p> <p>Constraints:</p> <ul> <li> <p>Must be the identifier for a valid cluster.</p> </li> </ul>
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. </p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  ##   TargetSnapshotIdentifier: JString (required)
  ##                           : <p>The identifier given to the new manual snapshot.</p> <p>Constraints:</p> <ul> <li> <p>Cannot be null, empty, or blank.</p> </li> <li> <p>Must contain from 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for the AWS account that is making the request.</p> </li> </ul>
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `SourceSnapshotIdentifier` field"
  var valid_613480 = formData.getOrDefault("SourceSnapshotIdentifier")
  valid_613480 = validateParameter(valid_613480, JString, required = true,
                                 default = nil)
  if valid_613480 != nil:
    section.add "SourceSnapshotIdentifier", valid_613480
  var valid_613481 = formData.getOrDefault("SourceSnapshotClusterIdentifier")
  valid_613481 = validateParameter(valid_613481, JString, required = false,
                                 default = nil)
  if valid_613481 != nil:
    section.add "SourceSnapshotClusterIdentifier", valid_613481
  var valid_613482 = formData.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_613482 = validateParameter(valid_613482, JInt, required = false, default = nil)
  if valid_613482 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_613482
  var valid_613483 = formData.getOrDefault("TargetSnapshotIdentifier")
  valid_613483 = validateParameter(valid_613483, JString, required = true,
                                 default = nil)
  if valid_613483 != nil:
    section.add "TargetSnapshotIdentifier", valid_613483
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613484: Call_PostCopyClusterSnapshot_613468; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Copies the specified automated cluster snapshot to a new manual cluster snapshot. The source must be an automated snapshot and it must be in the available state.</p> <p>When you delete a cluster, Amazon Redshift deletes any automated snapshots of the cluster. Also, when the retention period of the snapshot expires, Amazon Redshift automatically deletes it. If you want to keep an automated snapshot for a longer period, you can make a manual copy of the snapshot. Manual snapshots are retained until you delete them.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_613484.validator(path, query, header, formData, body)
  let scheme = call_613484.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613484.url(scheme.get, call_613484.host, call_613484.base,
                         call_613484.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613484, url, valid)

proc call*(call_613485: Call_PostCopyClusterSnapshot_613468;
          SourceSnapshotIdentifier: string; TargetSnapshotIdentifier: string;
          SourceSnapshotClusterIdentifier: string = "";
          Action: string = "CopyClusterSnapshot"; Version: string = "2012-12-01";
          ManualSnapshotRetentionPeriod: int = 0): Recallable =
  ## postCopyClusterSnapshot
  ## <p>Copies the specified automated cluster snapshot to a new manual cluster snapshot. The source must be an automated snapshot and it must be in the available state.</p> <p>When you delete a cluster, Amazon Redshift deletes any automated snapshots of the cluster. Also, when the retention period of the snapshot expires, Amazon Redshift automatically deletes it. If you want to keep an automated snapshot for a longer period, you can make a manual copy of the snapshot. Manual snapshots are retained until you delete them.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   SourceSnapshotIdentifier: string (required)
  ##                           : <p>The identifier for the source snapshot.</p> <p>Constraints:</p> <ul> <li> <p>Must be the identifier for a valid automated snapshot whose state is <code>available</code>.</p> </li> </ul>
  ##   SourceSnapshotClusterIdentifier: string
  ##                                  : <p>The identifier of the cluster the source snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.</p> <p>Constraints:</p> <ul> <li> <p>Must be the identifier for a valid cluster.</p> </li> </ul>
  ##   Action: string (required)
  ##   Version: string (required)
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. </p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  ##   TargetSnapshotIdentifier: string (required)
  ##                           : <p>The identifier given to the new manual snapshot.</p> <p>Constraints:</p> <ul> <li> <p>Cannot be null, empty, or blank.</p> </li> <li> <p>Must contain from 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for the AWS account that is making the request.</p> </li> </ul>
  var query_613486 = newJObject()
  var formData_613487 = newJObject()
  add(formData_613487, "SourceSnapshotIdentifier",
      newJString(SourceSnapshotIdentifier))
  add(formData_613487, "SourceSnapshotClusterIdentifier",
      newJString(SourceSnapshotClusterIdentifier))
  add(query_613486, "Action", newJString(Action))
  add(query_613486, "Version", newJString(Version))
  add(formData_613487, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  add(formData_613487, "TargetSnapshotIdentifier",
      newJString(TargetSnapshotIdentifier))
  result = call_613485.call(nil, query_613486, nil, formData_613487, nil)

var postCopyClusterSnapshot* = Call_PostCopyClusterSnapshot_613468(
    name: "postCopyClusterSnapshot", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=CopyClusterSnapshot",
    validator: validate_PostCopyClusterSnapshot_613469, base: "/",
    url: url_PostCopyClusterSnapshot_613470, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCopyClusterSnapshot_613449 = ref object of OpenApiRestCall_612642
proc url_GetCopyClusterSnapshot_613451(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetCopyClusterSnapshot_613450(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Copies the specified automated cluster snapshot to a new manual cluster snapshot. The source must be an automated snapshot and it must be in the available state.</p> <p>When you delete a cluster, Amazon Redshift deletes any automated snapshots of the cluster. Also, when the retention period of the snapshot expires, Amazon Redshift automatically deletes it. If you want to keep an automated snapshot for a longer period, you can make a manual copy of the snapshot. Manual snapshots are retained until you delete them.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. </p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  ##   SourceSnapshotIdentifier: JString (required)
  ##                           : <p>The identifier for the source snapshot.</p> <p>Constraints:</p> <ul> <li> <p>Must be the identifier for a valid automated snapshot whose state is <code>available</code>.</p> </li> </ul>
  ##   TargetSnapshotIdentifier: JString (required)
  ##                           : <p>The identifier given to the new manual snapshot.</p> <p>Constraints:</p> <ul> <li> <p>Cannot be null, empty, or blank.</p> </li> <li> <p>Must contain from 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for the AWS account that is making the request.</p> </li> </ul>
  ##   Action: JString (required)
  ##   Version: JString (required)
  ##   SourceSnapshotClusterIdentifier: JString
  ##                                  : <p>The identifier of the cluster the source snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.</p> <p>Constraints:</p> <ul> <li> <p>Must be the identifier for a valid cluster.</p> </li> </ul>
  section = newJObject()
  var valid_613452 = query.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_613452 = validateParameter(valid_613452, JInt, required = false, default = nil)
  if valid_613452 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_613452
  assert query != nil, "query argument is necessary due to required `SourceSnapshotIdentifier` field"
  var valid_613453 = query.getOrDefault("SourceSnapshotIdentifier")
  valid_613453 = validateParameter(valid_613453, JString, required = true,
                                 default = nil)
  if valid_613453 != nil:
    section.add "SourceSnapshotIdentifier", valid_613453
  var valid_613454 = query.getOrDefault("TargetSnapshotIdentifier")
  valid_613454 = validateParameter(valid_613454, JString, required = true,
                                 default = nil)
  if valid_613454 != nil:
    section.add "TargetSnapshotIdentifier", valid_613454
  var valid_613455 = query.getOrDefault("Action")
  valid_613455 = validateParameter(valid_613455, JString, required = true,
                                 default = newJString("CopyClusterSnapshot"))
  if valid_613455 != nil:
    section.add "Action", valid_613455
  var valid_613456 = query.getOrDefault("Version")
  valid_613456 = validateParameter(valid_613456, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_613456 != nil:
    section.add "Version", valid_613456
  var valid_613457 = query.getOrDefault("SourceSnapshotClusterIdentifier")
  valid_613457 = validateParameter(valid_613457, JString, required = false,
                                 default = nil)
  if valid_613457 != nil:
    section.add "SourceSnapshotClusterIdentifier", valid_613457
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613458 = header.getOrDefault("X-Amz-Signature")
  valid_613458 = validateParameter(valid_613458, JString, required = false,
                                 default = nil)
  if valid_613458 != nil:
    section.add "X-Amz-Signature", valid_613458
  var valid_613459 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613459 = validateParameter(valid_613459, JString, required = false,
                                 default = nil)
  if valid_613459 != nil:
    section.add "X-Amz-Content-Sha256", valid_613459
  var valid_613460 = header.getOrDefault("X-Amz-Date")
  valid_613460 = validateParameter(valid_613460, JString, required = false,
                                 default = nil)
  if valid_613460 != nil:
    section.add "X-Amz-Date", valid_613460
  var valid_613461 = header.getOrDefault("X-Amz-Credential")
  valid_613461 = validateParameter(valid_613461, JString, required = false,
                                 default = nil)
  if valid_613461 != nil:
    section.add "X-Amz-Credential", valid_613461
  var valid_613462 = header.getOrDefault("X-Amz-Security-Token")
  valid_613462 = validateParameter(valid_613462, JString, required = false,
                                 default = nil)
  if valid_613462 != nil:
    section.add "X-Amz-Security-Token", valid_613462
  var valid_613463 = header.getOrDefault("X-Amz-Algorithm")
  valid_613463 = validateParameter(valid_613463, JString, required = false,
                                 default = nil)
  if valid_613463 != nil:
    section.add "X-Amz-Algorithm", valid_613463
  var valid_613464 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613464 = validateParameter(valid_613464, JString, required = false,
                                 default = nil)
  if valid_613464 != nil:
    section.add "X-Amz-SignedHeaders", valid_613464
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613465: Call_GetCopyClusterSnapshot_613449; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Copies the specified automated cluster snapshot to a new manual cluster snapshot. The source must be an automated snapshot and it must be in the available state.</p> <p>When you delete a cluster, Amazon Redshift deletes any automated snapshots of the cluster. Also, when the retention period of the snapshot expires, Amazon Redshift automatically deletes it. If you want to keep an automated snapshot for a longer period, you can make a manual copy of the snapshot. Manual snapshots are retained until you delete them.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_613465.validator(path, query, header, formData, body)
  let scheme = call_613465.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613465.url(scheme.get, call_613465.host, call_613465.base,
                         call_613465.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613465, url, valid)

proc call*(call_613466: Call_GetCopyClusterSnapshot_613449;
          SourceSnapshotIdentifier: string; TargetSnapshotIdentifier: string;
          ManualSnapshotRetentionPeriod: int = 0;
          Action: string = "CopyClusterSnapshot"; Version: string = "2012-12-01";
          SourceSnapshotClusterIdentifier: string = ""): Recallable =
  ## getCopyClusterSnapshot
  ## <p>Copies the specified automated cluster snapshot to a new manual cluster snapshot. The source must be an automated snapshot and it must be in the available state.</p> <p>When you delete a cluster, Amazon Redshift deletes any automated snapshots of the cluster. Also, when the retention period of the snapshot expires, Amazon Redshift automatically deletes it. If you want to keep an automated snapshot for a longer period, you can make a manual copy of the snapshot. Manual snapshots are retained until you delete them.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. </p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  ##   SourceSnapshotIdentifier: string (required)
  ##                           : <p>The identifier for the source snapshot.</p> <p>Constraints:</p> <ul> <li> <p>Must be the identifier for a valid automated snapshot whose state is <code>available</code>.</p> </li> </ul>
  ##   TargetSnapshotIdentifier: string (required)
  ##                           : <p>The identifier given to the new manual snapshot.</p> <p>Constraints:</p> <ul> <li> <p>Cannot be null, empty, or blank.</p> </li> <li> <p>Must contain from 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for the AWS account that is making the request.</p> </li> </ul>
  ##   Action: string (required)
  ##   Version: string (required)
  ##   SourceSnapshotClusterIdentifier: string
  ##                                  : <p>The identifier of the cluster the source snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.</p> <p>Constraints:</p> <ul> <li> <p>Must be the identifier for a valid cluster.</p> </li> </ul>
  var query_613467 = newJObject()
  add(query_613467, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  add(query_613467, "SourceSnapshotIdentifier",
      newJString(SourceSnapshotIdentifier))
  add(query_613467, "TargetSnapshotIdentifier",
      newJString(TargetSnapshotIdentifier))
  add(query_613467, "Action", newJString(Action))
  add(query_613467, "Version", newJString(Version))
  add(query_613467, "SourceSnapshotClusterIdentifier",
      newJString(SourceSnapshotClusterIdentifier))
  result = call_613466.call(nil, query_613467, nil, nil, nil)

var getCopyClusterSnapshot* = Call_GetCopyClusterSnapshot_613449(
    name: "getCopyClusterSnapshot", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=CopyClusterSnapshot",
    validator: validate_GetCopyClusterSnapshot_613450, base: "/",
    url: url_GetCopyClusterSnapshot_613451, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCreateCluster_613533 = ref object of OpenApiRestCall_612642
proc url_PostCreateCluster_613535(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostCreateCluster_613534(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## <p>Creates a new cluster with the specified parameters.</p> <p>To create a cluster in Virtual Private Cloud (VPC), you must provide a cluster subnet group name. The cluster subnet group identifies the subnets of your VPC that Amazon Redshift uses when creating the cluster. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_613536 = query.getOrDefault("Action")
  valid_613536 = validateParameter(valid_613536, JString, required = true,
                                 default = newJString("CreateCluster"))
  if valid_613536 != nil:
    section.add "Action", valid_613536
  var valid_613537 = query.getOrDefault("Version")
  valid_613537 = validateParameter(valid_613537, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_613537 != nil:
    section.add "Version", valid_613537
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613538 = header.getOrDefault("X-Amz-Signature")
  valid_613538 = validateParameter(valid_613538, JString, required = false,
                                 default = nil)
  if valid_613538 != nil:
    section.add "X-Amz-Signature", valid_613538
  var valid_613539 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613539 = validateParameter(valid_613539, JString, required = false,
                                 default = nil)
  if valid_613539 != nil:
    section.add "X-Amz-Content-Sha256", valid_613539
  var valid_613540 = header.getOrDefault("X-Amz-Date")
  valid_613540 = validateParameter(valid_613540, JString, required = false,
                                 default = nil)
  if valid_613540 != nil:
    section.add "X-Amz-Date", valid_613540
  var valid_613541 = header.getOrDefault("X-Amz-Credential")
  valid_613541 = validateParameter(valid_613541, JString, required = false,
                                 default = nil)
  if valid_613541 != nil:
    section.add "X-Amz-Credential", valid_613541
  var valid_613542 = header.getOrDefault("X-Amz-Security-Token")
  valid_613542 = validateParameter(valid_613542, JString, required = false,
                                 default = nil)
  if valid_613542 != nil:
    section.add "X-Amz-Security-Token", valid_613542
  var valid_613543 = header.getOrDefault("X-Amz-Algorithm")
  valid_613543 = validateParameter(valid_613543, JString, required = false,
                                 default = nil)
  if valid_613543 != nil:
    section.add "X-Amz-Algorithm", valid_613543
  var valid_613544 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613544 = validateParameter(valid_613544, JString, required = false,
                                 default = nil)
  if valid_613544 != nil:
    section.add "X-Amz-SignedHeaders", valid_613544
  result.add "header", section
  ## parameters in `formData` object:
  ##   PreferredMaintenanceWindow: JString
  ##                             : <p>The weekly time range (in UTC) during which automated cluster maintenance can occur.</p> <p> Format: <code>ddd:hh24:mi-ddd:hh24:mi</code> </p> <p> Default: A 30-minute window selected at random from an 8-hour block of time per region, occurring on a random day of the week. For more information about the time blocks for each region, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-maintenance-windows">Maintenance Windows</a> in Amazon Redshift Cluster Management Guide.</p> <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p> <p>Constraints: Minimum 30-minute window.</p>
  ##   Port: JInt
  ##       : <p>The port number on which the cluster accepts incoming connections.</p> <p>The cluster is accessible only via the JDBC and ODBC connection strings. Part of the connection string requires the port on which the cluster will listen for incoming connections.</p> <p>Default: <code>5439</code> </p> <p>Valid Values: <code>1150-65535</code> </p>
  ##   NodeType: JString (required)
  ##           : <p>The node type to be provisioned for the cluster. For information about node types, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#how-many-nodes"> Working with Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p> <p>Valid Values: <code>ds2.xlarge</code> | <code>ds2.8xlarge</code> | <code>dc1.large</code> | <code>dc1.8xlarge</code> | <code>dc2.large</code> | <code>dc2.8xlarge</code> | <code>ra3.16xlarge</code> </p>
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>A unique identifier for the cluster. You use this identifier to refer to the cluster for any subsequent cluster operations such as deleting or modifying. The identifier also appears in the Amazon Redshift console.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul> <p>Example: <code>myexamplecluster</code> </p>
  ##   MasterUserPassword: JString (required)
  ##                     : <p>The password associated with the master user account for the cluster that is being created.</p> <p>Constraints:</p> <ul> <li> <p>Must be between 8 and 64 characters in length.</p> </li> <li> <p>Must contain at least one uppercase letter.</p> </li> <li> <p>Must contain at least one lowercase letter.</p> </li> <li> <p>Must contain one number.</p> </li> <li> <p>Can be any printable ASCII character (ASCII code 33 to 126) except ' (single quote), " (double quote), \, /, @, or space.</p> </li> </ul>
  ##   MaintenanceTrackName: JString
  ##                       : An optional parameter for the name of the maintenance track for the cluster. If you don't provide a maintenance track name, the cluster is assigned to the <code>current</code> track.
  ##   MasterUsername: JString (required)
  ##                 : <p>The user name associated with the master user account for the cluster that is being created.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 - 128 alphanumeric characters. The user name can't be <code>PUBLIC</code>.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide. </p> </li> </ul>
  ##   ClusterSecurityGroups: JArray
  ##                        : <p>A list of security groups to be associated with this cluster.</p> <p>Default: The default cluster security group for Amazon Redshift.</p>
  ##   IamRoles: JArray
  ##           : <p>A list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services. You must supply the IAM roles in their Amazon Resource Name (ARN) format. You can supply up to 10 IAM roles in a single request.</p> <p>A cluster can have up to 10 IAM roles associated with it at any time.</p>
  ##   VpcSecurityGroupIds: JArray
  ##                      : <p>A list of Virtual Private Cloud (VPC) security groups to be associated with the cluster.</p> <p>Default: The default VPC security group is associated with the cluster.</p>
  ##   AutomatedSnapshotRetentionPeriod: JInt
  ##                                   : <p>The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p> <p>Default: <code>1</code> </p> <p>Constraints: Must be a value from 0 to 35.</p>
  ##   AvailabilityZone: JString
  ##                   : <p>The EC2 Availability Zone (AZ) in which you want Amazon Redshift to provision the cluster. For example, if you have several EC2 instances running in a specific Availability Zone, then you might want the cluster to be provisioned in the same zone in order to decrease network latency.</p> <p>Default: A random, system-chosen Availability Zone in the region that is specified by the endpoint.</p> <p>Example: <code>us-east-2d</code> </p> <p>Constraint: The specified Availability Zone must be in the same region as the current endpoint.</p>
  ##   NumberOfNodes: JInt
  ##                : <p>The number of compute nodes in the cluster. This parameter is required when the <b>ClusterType</b> parameter is specified as <code>multi-node</code>. </p> <p>For information about determining how many nodes you need, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#how-many-nodes"> Working with Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p> <p>If you don't specify this parameter, you get a single-node cluster. When requesting a multi-node cluster, you must specify the number of nodes that you want in the cluster.</p> <p>Default: <code>1</code> </p> <p>Constraints: Value must be at least 1 and no more than 100.</p>
  ##   KmsKeyId: JString
  ##           : The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster.
  ##   EnhancedVpcRouting: JBool
  ##                     : <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p> <p>Default: false</p>
  ##   ClusterSubnetGroupName: JString
  ##                         : <p>The name of a cluster subnet group to be associated with this cluster.</p> <p>If this parameter is not provided the resulting cluster will be deployed outside virtual private cloud (VPC).</p>
  ##   AllowVersionUpgrade: JBool
  ##                      : <p>If <code>true</code>, major version upgrades can be applied during the maintenance window to the Amazon Redshift engine that is running on the cluster.</p> <p>When a new major version of the Amazon Redshift engine is released, you can request that the service automatically apply upgrades during the maintenance window to the Amazon Redshift engine that is running on your cluster.</p> <p>Default: <code>true</code> </p>
  ##   DBName: JString
  ##         : <p>The name of the first database to be created when the cluster is created.</p> <p>To create additional databases after the cluster is created, connect to the cluster with a SQL client and use SQL commands to create a database. For more information, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/t_creating_database.html">Create a Database</a> in the Amazon Redshift Database Developer Guide. </p> <p>Default: <code>dev</code> </p> <p>Constraints:</p> <ul> <li> <p>Must contain 1 to 64 alphanumeric characters.</p> </li> <li> <p>Must contain only lowercase letters.</p> </li> <li> <p>Cannot be a word that is reserved by the service. A list of reserved words can be found in <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide. </p> </li> </ul>
  ##   PubliclyAccessible: JBool
  ##                     : If <code>true</code>, the cluster can be accessed from a public network. 
  ##   ClusterParameterGroupName: JString
  ##                            : <p>The name of the parameter group to be associated with this cluster.</p> <p>Default: The default Amazon Redshift cluster parameter group. For information about the default parameter group, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Working with Amazon Redshift Parameter Groups</a> </p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   ClusterVersion: JString
  ##                 : <p>The version of the Amazon Redshift engine software that you want to deploy on the cluster.</p> <p>The version selected runs on all the nodes in the cluster.</p> <p>Constraints: Only version 1.0 is currently available.</p> <p>Example: <code>1.0</code> </p>
  ##   ClusterType: JString
  ##              : <p>The type of the cluster. When cluster type is specified as</p> <ul> <li> <p> <code>single-node</code>, the <b>NumberOfNodes</b> parameter is not required.</p> </li> <li> <p> <code>multi-node</code>, the <b>NumberOfNodes</b> parameter is required.</p> </li> </ul> <p>Valid Values: <code>multi-node</code> | <code>single-node</code> </p> <p>Default: <code>multi-node</code> </p>
  ##   Encrypted: JBool
  ##            : <p>If <code>true</code>, the data in the cluster is encrypted at rest. </p> <p>Default: false</p>
  ##   HsmClientCertificateIdentifier: JString
  ##                                 : Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM.
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   AdditionalInfo: JString
  ##                 : Reserved.
  ##   SnapshotScheduleIdentifier: JString
  ##                             : A unique identifier for the snapshot schedule.
  ##   ElasticIp: JString
  ##            : <p>The Elastic IP (EIP) address for the cluster.</p> <p>Constraints: The cluster must be provisioned in EC2-VPC and publicly-accessible through an Internet gateway. For more information about provisioning clusters in EC2-VPC, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#cluster-platforms">Supported Platforms to Launch Your Cluster</a> in the Amazon Redshift Cluster Management Guide.</p>
  ##   HsmConfigurationIdentifier: JString
  ##                             : Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The default number of days to retain a manual snapshot. If the value is -1, the snapshot is retained indefinitely. This setting doesn't change the retention period of existing snapshots.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  section = newJObject()
  var valid_613545 = formData.getOrDefault("PreferredMaintenanceWindow")
  valid_613545 = validateParameter(valid_613545, JString, required = false,
                                 default = nil)
  if valid_613545 != nil:
    section.add "PreferredMaintenanceWindow", valid_613545
  var valid_613546 = formData.getOrDefault("Port")
  valid_613546 = validateParameter(valid_613546, JInt, required = false, default = nil)
  if valid_613546 != nil:
    section.add "Port", valid_613546
  assert formData != nil,
        "formData argument is necessary due to required `NodeType` field"
  var valid_613547 = formData.getOrDefault("NodeType")
  valid_613547 = validateParameter(valid_613547, JString, required = true,
                                 default = nil)
  if valid_613547 != nil:
    section.add "NodeType", valid_613547
  var valid_613548 = formData.getOrDefault("ClusterIdentifier")
  valid_613548 = validateParameter(valid_613548, JString, required = true,
                                 default = nil)
  if valid_613548 != nil:
    section.add "ClusterIdentifier", valid_613548
  var valid_613549 = formData.getOrDefault("MasterUserPassword")
  valid_613549 = validateParameter(valid_613549, JString, required = true,
                                 default = nil)
  if valid_613549 != nil:
    section.add "MasterUserPassword", valid_613549
  var valid_613550 = formData.getOrDefault("MaintenanceTrackName")
  valid_613550 = validateParameter(valid_613550, JString, required = false,
                                 default = nil)
  if valid_613550 != nil:
    section.add "MaintenanceTrackName", valid_613550
  var valid_613551 = formData.getOrDefault("MasterUsername")
  valid_613551 = validateParameter(valid_613551, JString, required = true,
                                 default = nil)
  if valid_613551 != nil:
    section.add "MasterUsername", valid_613551
  var valid_613552 = formData.getOrDefault("ClusterSecurityGroups")
  valid_613552 = validateParameter(valid_613552, JArray, required = false,
                                 default = nil)
  if valid_613552 != nil:
    section.add "ClusterSecurityGroups", valid_613552
  var valid_613553 = formData.getOrDefault("IamRoles")
  valid_613553 = validateParameter(valid_613553, JArray, required = false,
                                 default = nil)
  if valid_613553 != nil:
    section.add "IamRoles", valid_613553
  var valid_613554 = formData.getOrDefault("VpcSecurityGroupIds")
  valid_613554 = validateParameter(valid_613554, JArray, required = false,
                                 default = nil)
  if valid_613554 != nil:
    section.add "VpcSecurityGroupIds", valid_613554
  var valid_613555 = formData.getOrDefault("AutomatedSnapshotRetentionPeriod")
  valid_613555 = validateParameter(valid_613555, JInt, required = false, default = nil)
  if valid_613555 != nil:
    section.add "AutomatedSnapshotRetentionPeriod", valid_613555
  var valid_613556 = formData.getOrDefault("AvailabilityZone")
  valid_613556 = validateParameter(valid_613556, JString, required = false,
                                 default = nil)
  if valid_613556 != nil:
    section.add "AvailabilityZone", valid_613556
  var valid_613557 = formData.getOrDefault("NumberOfNodes")
  valid_613557 = validateParameter(valid_613557, JInt, required = false, default = nil)
  if valid_613557 != nil:
    section.add "NumberOfNodes", valid_613557
  var valid_613558 = formData.getOrDefault("KmsKeyId")
  valid_613558 = validateParameter(valid_613558, JString, required = false,
                                 default = nil)
  if valid_613558 != nil:
    section.add "KmsKeyId", valid_613558
  var valid_613559 = formData.getOrDefault("EnhancedVpcRouting")
  valid_613559 = validateParameter(valid_613559, JBool, required = false, default = nil)
  if valid_613559 != nil:
    section.add "EnhancedVpcRouting", valid_613559
  var valid_613560 = formData.getOrDefault("ClusterSubnetGroupName")
  valid_613560 = validateParameter(valid_613560, JString, required = false,
                                 default = nil)
  if valid_613560 != nil:
    section.add "ClusterSubnetGroupName", valid_613560
  var valid_613561 = formData.getOrDefault("AllowVersionUpgrade")
  valid_613561 = validateParameter(valid_613561, JBool, required = false, default = nil)
  if valid_613561 != nil:
    section.add "AllowVersionUpgrade", valid_613561
  var valid_613562 = formData.getOrDefault("DBName")
  valid_613562 = validateParameter(valid_613562, JString, required = false,
                                 default = nil)
  if valid_613562 != nil:
    section.add "DBName", valid_613562
  var valid_613563 = formData.getOrDefault("PubliclyAccessible")
  valid_613563 = validateParameter(valid_613563, JBool, required = false, default = nil)
  if valid_613563 != nil:
    section.add "PubliclyAccessible", valid_613563
  var valid_613564 = formData.getOrDefault("ClusterParameterGroupName")
  valid_613564 = validateParameter(valid_613564, JString, required = false,
                                 default = nil)
  if valid_613564 != nil:
    section.add "ClusterParameterGroupName", valid_613564
  var valid_613565 = formData.getOrDefault("ClusterVersion")
  valid_613565 = validateParameter(valid_613565, JString, required = false,
                                 default = nil)
  if valid_613565 != nil:
    section.add "ClusterVersion", valid_613565
  var valid_613566 = formData.getOrDefault("ClusterType")
  valid_613566 = validateParameter(valid_613566, JString, required = false,
                                 default = nil)
  if valid_613566 != nil:
    section.add "ClusterType", valid_613566
  var valid_613567 = formData.getOrDefault("Encrypted")
  valid_613567 = validateParameter(valid_613567, JBool, required = false, default = nil)
  if valid_613567 != nil:
    section.add "Encrypted", valid_613567
  var valid_613568 = formData.getOrDefault("HsmClientCertificateIdentifier")
  valid_613568 = validateParameter(valid_613568, JString, required = false,
                                 default = nil)
  if valid_613568 != nil:
    section.add "HsmClientCertificateIdentifier", valid_613568
  var valid_613569 = formData.getOrDefault("Tags")
  valid_613569 = validateParameter(valid_613569, JArray, required = false,
                                 default = nil)
  if valid_613569 != nil:
    section.add "Tags", valid_613569
  var valid_613570 = formData.getOrDefault("AdditionalInfo")
  valid_613570 = validateParameter(valid_613570, JString, required = false,
                                 default = nil)
  if valid_613570 != nil:
    section.add "AdditionalInfo", valid_613570
  var valid_613571 = formData.getOrDefault("SnapshotScheduleIdentifier")
  valid_613571 = validateParameter(valid_613571, JString, required = false,
                                 default = nil)
  if valid_613571 != nil:
    section.add "SnapshotScheduleIdentifier", valid_613571
  var valid_613572 = formData.getOrDefault("ElasticIp")
  valid_613572 = validateParameter(valid_613572, JString, required = false,
                                 default = nil)
  if valid_613572 != nil:
    section.add "ElasticIp", valid_613572
  var valid_613573 = formData.getOrDefault("HsmConfigurationIdentifier")
  valid_613573 = validateParameter(valid_613573, JString, required = false,
                                 default = nil)
  if valid_613573 != nil:
    section.add "HsmConfigurationIdentifier", valid_613573
  var valid_613574 = formData.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_613574 = validateParameter(valid_613574, JInt, required = false, default = nil)
  if valid_613574 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_613574
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613575: Call_PostCreateCluster_613533; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a new cluster with the specified parameters.</p> <p>To create a cluster in Virtual Private Cloud (VPC), you must provide a cluster subnet group name. The cluster subnet group identifies the subnets of your VPC that Amazon Redshift uses when creating the cluster. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_613575.validator(path, query, header, formData, body)
  let scheme = call_613575.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613575.url(scheme.get, call_613575.host, call_613575.base,
                         call_613575.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613575, url, valid)

proc call*(call_613576: Call_PostCreateCluster_613533; NodeType: string;
          ClusterIdentifier: string; MasterUserPassword: string;
          MasterUsername: string; PreferredMaintenanceWindow: string = "";
          Port: int = 0; MaintenanceTrackName: string = "";
          ClusterSecurityGroups: JsonNode = nil; IamRoles: JsonNode = nil;
          VpcSecurityGroupIds: JsonNode = nil;
          AutomatedSnapshotRetentionPeriod: int = 0; AvailabilityZone: string = "";
          NumberOfNodes: int = 0; KmsKeyId: string = "";
          EnhancedVpcRouting: bool = false; ClusterSubnetGroupName: string = "";
          AllowVersionUpgrade: bool = false; DBName: string = "";
          PubliclyAccessible: bool = false; Action: string = "CreateCluster";
          ClusterParameterGroupName: string = ""; ClusterVersion: string = "";
          ClusterType: string = ""; Encrypted: bool = false;
          HsmClientCertificateIdentifier: string = ""; Tags: JsonNode = nil;
          AdditionalInfo: string = ""; SnapshotScheduleIdentifier: string = "";
          Version: string = "2012-12-01"; ElasticIp: string = "";
          HsmConfigurationIdentifier: string = "";
          ManualSnapshotRetentionPeriod: int = 0): Recallable =
  ## postCreateCluster
  ## <p>Creates a new cluster with the specified parameters.</p> <p>To create a cluster in Virtual Private Cloud (VPC), you must provide a cluster subnet group name. The cluster subnet group identifies the subnets of your VPC that Amazon Redshift uses when creating the cluster. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   PreferredMaintenanceWindow: string
  ##                             : <p>The weekly time range (in UTC) during which automated cluster maintenance can occur.</p> <p> Format: <code>ddd:hh24:mi-ddd:hh24:mi</code> </p> <p> Default: A 30-minute window selected at random from an 8-hour block of time per region, occurring on a random day of the week. For more information about the time blocks for each region, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-maintenance-windows">Maintenance Windows</a> in Amazon Redshift Cluster Management Guide.</p> <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p> <p>Constraints: Minimum 30-minute window.</p>
  ##   Port: int
  ##       : <p>The port number on which the cluster accepts incoming connections.</p> <p>The cluster is accessible only via the JDBC and ODBC connection strings. Part of the connection string requires the port on which the cluster will listen for incoming connections.</p> <p>Default: <code>5439</code> </p> <p>Valid Values: <code>1150-65535</code> </p>
  ##   NodeType: string (required)
  ##           : <p>The node type to be provisioned for the cluster. For information about node types, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#how-many-nodes"> Working with Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p> <p>Valid Values: <code>ds2.xlarge</code> | <code>ds2.8xlarge</code> | <code>dc1.large</code> | <code>dc1.8xlarge</code> | <code>dc2.large</code> | <code>dc2.8xlarge</code> | <code>ra3.16xlarge</code> </p>
  ##   ClusterIdentifier: string (required)
  ##                    : <p>A unique identifier for the cluster. You use this identifier to refer to the cluster for any subsequent cluster operations such as deleting or modifying. The identifier also appears in the Amazon Redshift console.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul> <p>Example: <code>myexamplecluster</code> </p>
  ##   MasterUserPassword: string (required)
  ##                     : <p>The password associated with the master user account for the cluster that is being created.</p> <p>Constraints:</p> <ul> <li> <p>Must be between 8 and 64 characters in length.</p> </li> <li> <p>Must contain at least one uppercase letter.</p> </li> <li> <p>Must contain at least one lowercase letter.</p> </li> <li> <p>Must contain one number.</p> </li> <li> <p>Can be any printable ASCII character (ASCII code 33 to 126) except ' (single quote), " (double quote), \, /, @, or space.</p> </li> </ul>
  ##   MaintenanceTrackName: string
  ##                       : An optional parameter for the name of the maintenance track for the cluster. If you don't provide a maintenance track name, the cluster is assigned to the <code>current</code> track.
  ##   MasterUsername: string (required)
  ##                 : <p>The user name associated with the master user account for the cluster that is being created.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 - 128 alphanumeric characters. The user name can't be <code>PUBLIC</code>.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide. </p> </li> </ul>
  ##   ClusterSecurityGroups: JArray
  ##                        : <p>A list of security groups to be associated with this cluster.</p> <p>Default: The default cluster security group for Amazon Redshift.</p>
  ##   IamRoles: JArray
  ##           : <p>A list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services. You must supply the IAM roles in their Amazon Resource Name (ARN) format. You can supply up to 10 IAM roles in a single request.</p> <p>A cluster can have up to 10 IAM roles associated with it at any time.</p>
  ##   VpcSecurityGroupIds: JArray
  ##                      : <p>A list of Virtual Private Cloud (VPC) security groups to be associated with the cluster.</p> <p>Default: The default VPC security group is associated with the cluster.</p>
  ##   AutomatedSnapshotRetentionPeriod: int
  ##                                   : <p>The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p> <p>Default: <code>1</code> </p> <p>Constraints: Must be a value from 0 to 35.</p>
  ##   AvailabilityZone: string
  ##                   : <p>The EC2 Availability Zone (AZ) in which you want Amazon Redshift to provision the cluster. For example, if you have several EC2 instances running in a specific Availability Zone, then you might want the cluster to be provisioned in the same zone in order to decrease network latency.</p> <p>Default: A random, system-chosen Availability Zone in the region that is specified by the endpoint.</p> <p>Example: <code>us-east-2d</code> </p> <p>Constraint: The specified Availability Zone must be in the same region as the current endpoint.</p>
  ##   NumberOfNodes: int
  ##                : <p>The number of compute nodes in the cluster. This parameter is required when the <b>ClusterType</b> parameter is specified as <code>multi-node</code>. </p> <p>For information about determining how many nodes you need, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#how-many-nodes"> Working with Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p> <p>If you don't specify this parameter, you get a single-node cluster. When requesting a multi-node cluster, you must specify the number of nodes that you want in the cluster.</p> <p>Default: <code>1</code> </p> <p>Constraints: Value must be at least 1 and no more than 100.</p>
  ##   KmsKeyId: string
  ##           : The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster.
  ##   EnhancedVpcRouting: bool
  ##                     : <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p> <p>Default: false</p>
  ##   ClusterSubnetGroupName: string
  ##                         : <p>The name of a cluster subnet group to be associated with this cluster.</p> <p>If this parameter is not provided the resulting cluster will be deployed outside virtual private cloud (VPC).</p>
  ##   AllowVersionUpgrade: bool
  ##                      : <p>If <code>true</code>, major version upgrades can be applied during the maintenance window to the Amazon Redshift engine that is running on the cluster.</p> <p>When a new major version of the Amazon Redshift engine is released, you can request that the service automatically apply upgrades during the maintenance window to the Amazon Redshift engine that is running on your cluster.</p> <p>Default: <code>true</code> </p>
  ##   DBName: string
  ##         : <p>The name of the first database to be created when the cluster is created.</p> <p>To create additional databases after the cluster is created, connect to the cluster with a SQL client and use SQL commands to create a database. For more information, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/t_creating_database.html">Create a Database</a> in the Amazon Redshift Database Developer Guide. </p> <p>Default: <code>dev</code> </p> <p>Constraints:</p> <ul> <li> <p>Must contain 1 to 64 alphanumeric characters.</p> </li> <li> <p>Must contain only lowercase letters.</p> </li> <li> <p>Cannot be a word that is reserved by the service. A list of reserved words can be found in <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide. </p> </li> </ul>
  ##   PubliclyAccessible: bool
  ##                     : If <code>true</code>, the cluster can be accessed from a public network. 
  ##   Action: string (required)
  ##   ClusterParameterGroupName: string
  ##                            : <p>The name of the parameter group to be associated with this cluster.</p> <p>Default: The default Amazon Redshift cluster parameter group. For information about the default parameter group, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Working with Amazon Redshift Parameter Groups</a> </p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   ClusterVersion: string
  ##                 : <p>The version of the Amazon Redshift engine software that you want to deploy on the cluster.</p> <p>The version selected runs on all the nodes in the cluster.</p> <p>Constraints: Only version 1.0 is currently available.</p> <p>Example: <code>1.0</code> </p>
  ##   ClusterType: string
  ##              : <p>The type of the cluster. When cluster type is specified as</p> <ul> <li> <p> <code>single-node</code>, the <b>NumberOfNodes</b> parameter is not required.</p> </li> <li> <p> <code>multi-node</code>, the <b>NumberOfNodes</b> parameter is required.</p> </li> </ul> <p>Valid Values: <code>multi-node</code> | <code>single-node</code> </p> <p>Default: <code>multi-node</code> </p>
  ##   Encrypted: bool
  ##            : <p>If <code>true</code>, the data in the cluster is encrypted at rest. </p> <p>Default: false</p>
  ##   HsmClientCertificateIdentifier: string
  ##                                 : Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM.
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   AdditionalInfo: string
  ##                 : Reserved.
  ##   SnapshotScheduleIdentifier: string
  ##                             : A unique identifier for the snapshot schedule.
  ##   Version: string (required)
  ##   ElasticIp: string
  ##            : <p>The Elastic IP (EIP) address for the cluster.</p> <p>Constraints: The cluster must be provisioned in EC2-VPC and publicly-accessible through an Internet gateway. For more information about provisioning clusters in EC2-VPC, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#cluster-platforms">Supported Platforms to Launch Your Cluster</a> in the Amazon Redshift Cluster Management Guide.</p>
  ##   HsmConfigurationIdentifier: string
  ##                             : Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The default number of days to retain a manual snapshot. If the value is -1, the snapshot is retained indefinitely. This setting doesn't change the retention period of existing snapshots.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  var query_613577 = newJObject()
  var formData_613578 = newJObject()
  add(formData_613578, "PreferredMaintenanceWindow",
      newJString(PreferredMaintenanceWindow))
  add(formData_613578, "Port", newJInt(Port))
  add(formData_613578, "NodeType", newJString(NodeType))
  add(formData_613578, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_613578, "MasterUserPassword", newJString(MasterUserPassword))
  add(formData_613578, "MaintenanceTrackName", newJString(MaintenanceTrackName))
  add(formData_613578, "MasterUsername", newJString(MasterUsername))
  if ClusterSecurityGroups != nil:
    formData_613578.add "ClusterSecurityGroups", ClusterSecurityGroups
  if IamRoles != nil:
    formData_613578.add "IamRoles", IamRoles
  if VpcSecurityGroupIds != nil:
    formData_613578.add "VpcSecurityGroupIds", VpcSecurityGroupIds
  add(formData_613578, "AutomatedSnapshotRetentionPeriod",
      newJInt(AutomatedSnapshotRetentionPeriod))
  add(formData_613578, "AvailabilityZone", newJString(AvailabilityZone))
  add(formData_613578, "NumberOfNodes", newJInt(NumberOfNodes))
  add(formData_613578, "KmsKeyId", newJString(KmsKeyId))
  add(formData_613578, "EnhancedVpcRouting", newJBool(EnhancedVpcRouting))
  add(formData_613578, "ClusterSubnetGroupName",
      newJString(ClusterSubnetGroupName))
  add(formData_613578, "AllowVersionUpgrade", newJBool(AllowVersionUpgrade))
  add(formData_613578, "DBName", newJString(DBName))
  add(formData_613578, "PubliclyAccessible", newJBool(PubliclyAccessible))
  add(query_613577, "Action", newJString(Action))
  add(formData_613578, "ClusterParameterGroupName",
      newJString(ClusterParameterGroupName))
  add(formData_613578, "ClusterVersion", newJString(ClusterVersion))
  add(formData_613578, "ClusterType", newJString(ClusterType))
  add(formData_613578, "Encrypted", newJBool(Encrypted))
  add(formData_613578, "HsmClientCertificateIdentifier",
      newJString(HsmClientCertificateIdentifier))
  if Tags != nil:
    formData_613578.add "Tags", Tags
  add(formData_613578, "AdditionalInfo", newJString(AdditionalInfo))
  add(formData_613578, "SnapshotScheduleIdentifier",
      newJString(SnapshotScheduleIdentifier))
  add(query_613577, "Version", newJString(Version))
  add(formData_613578, "ElasticIp", newJString(ElasticIp))
  add(formData_613578, "HsmConfigurationIdentifier",
      newJString(HsmConfigurationIdentifier))
  add(formData_613578, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  result = call_613576.call(nil, query_613577, nil, formData_613578, nil)

var postCreateCluster* = Call_PostCreateCluster_613533(name: "postCreateCluster",
    meth: HttpMethod.HttpPost, host: "redshift.amazonaws.com",
    route: "/#Action=CreateCluster", validator: validate_PostCreateCluster_613534,
    base: "/", url: url_PostCreateCluster_613535,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCreateCluster_613488 = ref object of OpenApiRestCall_612642
proc url_GetCreateCluster_613490(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetCreateCluster_613489(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## <p>Creates a new cluster with the specified parameters.</p> <p>To create a cluster in Virtual Private Cloud (VPC), you must provide a cluster subnet group name. The cluster subnet group identifies the subnets of your VPC that Amazon Redshift uses when creating the cluster. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ClusterSubnetGroupName: JString
  ##                         : <p>The name of a cluster subnet group to be associated with this cluster.</p> <p>If this parameter is not provided the resulting cluster will be deployed outside virtual private cloud (VPC).</p>
  ##   MaintenanceTrackName: JString
  ##                       : An optional parameter for the name of the maintenance track for the cluster. If you don't provide a maintenance track name, the cluster is assigned to the <code>current</code> track.
  ##   DBName: JString
  ##         : <p>The name of the first database to be created when the cluster is created.</p> <p>To create additional databases after the cluster is created, connect to the cluster with a SQL client and use SQL commands to create a database. For more information, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/t_creating_database.html">Create a Database</a> in the Amazon Redshift Database Developer Guide. </p> <p>Default: <code>dev</code> </p> <p>Constraints:</p> <ul> <li> <p>Must contain 1 to 64 alphanumeric characters.</p> </li> <li> <p>Must contain only lowercase letters.</p> </li> <li> <p>Cannot be a word that is reserved by the service. A list of reserved words can be found in <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide. </p> </li> </ul>
  ##   Encrypted: JBool
  ##            : <p>If <code>true</code>, the data in the cluster is encrypted at rest. </p> <p>Default: false</p>
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The default number of days to retain a manual snapshot. If the value is -1, the snapshot is retained indefinitely. This setting doesn't change the retention period of existing snapshots.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  ##   HsmClientCertificateIdentifier: JString
  ##                                 : Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM.
  ##   ClusterSecurityGroups: JArray
  ##                        : <p>A list of security groups to be associated with this cluster.</p> <p>Default: The default cluster security group for Amazon Redshift.</p>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   KmsKeyId: JString
  ##           : The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster.
  ##   ClusterParameterGroupName: JString
  ##                            : <p>The name of the parameter group to be associated with this cluster.</p> <p>Default: The default Amazon Redshift cluster parameter group. For information about the default parameter group, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Working with Amazon Redshift Parameter Groups</a> </p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   NodeType: JString (required)
  ##           : <p>The node type to be provisioned for the cluster. For information about node types, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#how-many-nodes"> Working with Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p> <p>Valid Values: <code>ds2.xlarge</code> | <code>ds2.8xlarge</code> | <code>dc1.large</code> | <code>dc1.8xlarge</code> | <code>dc2.large</code> | <code>dc2.8xlarge</code> | <code>ra3.16xlarge</code> </p>
  ##   ClusterVersion: JString
  ##                 : <p>The version of the Amazon Redshift engine software that you want to deploy on the cluster.</p> <p>The version selected runs on all the nodes in the cluster.</p> <p>Constraints: Only version 1.0 is currently available.</p> <p>Example: <code>1.0</code> </p>
  ##   IamRoles: JArray
  ##           : <p>A list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services. You must supply the IAM roles in their Amazon Resource Name (ARN) format. You can supply up to 10 IAM roles in a single request.</p> <p>A cluster can have up to 10 IAM roles associated with it at any time.</p>
  ##   SnapshotScheduleIdentifier: JString
  ##                             : A unique identifier for the snapshot schedule.
  ##   ClusterType: JString
  ##              : <p>The type of the cluster. When cluster type is specified as</p> <ul> <li> <p> <code>single-node</code>, the <b>NumberOfNodes</b> parameter is not required.</p> </li> <li> <p> <code>multi-node</code>, the <b>NumberOfNodes</b> parameter is required.</p> </li> </ul> <p>Valid Values: <code>multi-node</code> | <code>single-node</code> </p> <p>Default: <code>multi-node</code> </p>
  ##   NumberOfNodes: JInt
  ##                : <p>The number of compute nodes in the cluster. This parameter is required when the <b>ClusterType</b> parameter is specified as <code>multi-node</code>. </p> <p>For information about determining how many nodes you need, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#how-many-nodes"> Working with Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p> <p>If you don't specify this parameter, you get a single-node cluster. When requesting a multi-node cluster, you must specify the number of nodes that you want in the cluster.</p> <p>Default: <code>1</code> </p> <p>Constraints: Value must be at least 1 and no more than 100.</p>
  ##   MasterUsername: JString (required)
  ##                 : <p>The user name associated with the master user account for the cluster that is being created.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 - 128 alphanumeric characters. The user name can't be <code>PUBLIC</code>.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide. </p> </li> </ul>
  ##   AdditionalInfo: JString
  ##                 : Reserved.
  ##   AllowVersionUpgrade: JBool
  ##                      : <p>If <code>true</code>, major version upgrades can be applied during the maintenance window to the Amazon Redshift engine that is running on the cluster.</p> <p>When a new major version of the Amazon Redshift engine is released, you can request that the service automatically apply upgrades during the maintenance window to the Amazon Redshift engine that is running on your cluster.</p> <p>Default: <code>true</code> </p>
  ##   ElasticIp: JString
  ##            : <p>The Elastic IP (EIP) address for the cluster.</p> <p>Constraints: The cluster must be provisioned in EC2-VPC and publicly-accessible through an Internet gateway. For more information about provisioning clusters in EC2-VPC, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#cluster-platforms">Supported Platforms to Launch Your Cluster</a> in the Amazon Redshift Cluster Management Guide.</p>
  ##   AutomatedSnapshotRetentionPeriod: JInt
  ##                                   : <p>The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p> <p>Default: <code>1</code> </p> <p>Constraints: Must be a value from 0 to 35.</p>
  ##   EnhancedVpcRouting: JBool
  ##                     : <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p> <p>Default: false</p>
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>A unique identifier for the cluster. You use this identifier to refer to the cluster for any subsequent cluster operations such as deleting or modifying. The identifier also appears in the Amazon Redshift console.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul> <p>Example: <code>myexamplecluster</code> </p>
  ##   Port: JInt
  ##       : <p>The port number on which the cluster accepts incoming connections.</p> <p>The cluster is accessible only via the JDBC and ODBC connection strings. Part of the connection string requires the port on which the cluster will listen for incoming connections.</p> <p>Default: <code>5439</code> </p> <p>Valid Values: <code>1150-65535</code> </p>
  ##   VpcSecurityGroupIds: JArray
  ##                      : <p>A list of Virtual Private Cloud (VPC) security groups to be associated with the cluster.</p> <p>Default: The default VPC security group is associated with the cluster.</p>
  ##   MasterUserPassword: JString (required)
  ##                     : <p>The password associated with the master user account for the cluster that is being created.</p> <p>Constraints:</p> <ul> <li> <p>Must be between 8 and 64 characters in length.</p> </li> <li> <p>Must contain at least one uppercase letter.</p> </li> <li> <p>Must contain at least one lowercase letter.</p> </li> <li> <p>Must contain one number.</p> </li> <li> <p>Can be any printable ASCII character (ASCII code 33 to 126) except ' (single quote), " (double quote), \, /, @, or space.</p> </li> </ul>
  ##   AvailabilityZone: JString
  ##                   : <p>The EC2 Availability Zone (AZ) in which you want Amazon Redshift to provision the cluster. For example, if you have several EC2 instances running in a specific Availability Zone, then you might want the cluster to be provisioned in the same zone in order to decrease network latency.</p> <p>Default: A random, system-chosen Availability Zone in the region that is specified by the endpoint.</p> <p>Example: <code>us-east-2d</code> </p> <p>Constraint: The specified Availability Zone must be in the same region as the current endpoint.</p>
  ##   HsmConfigurationIdentifier: JString
  ##                             : Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
  ##   Version: JString (required)
  ##   PreferredMaintenanceWindow: JString
  ##                             : <p>The weekly time range (in UTC) during which automated cluster maintenance can occur.</p> <p> Format: <code>ddd:hh24:mi-ddd:hh24:mi</code> </p> <p> Default: A 30-minute window selected at random from an 8-hour block of time per region, occurring on a random day of the week. For more information about the time blocks for each region, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-maintenance-windows">Maintenance Windows</a> in Amazon Redshift Cluster Management Guide.</p> <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p> <p>Constraints: Minimum 30-minute window.</p>
  ##   PubliclyAccessible: JBool
  ##                     : If <code>true</code>, the cluster can be accessed from a public network. 
  section = newJObject()
  var valid_613491 = query.getOrDefault("ClusterSubnetGroupName")
  valid_613491 = validateParameter(valid_613491, JString, required = false,
                                 default = nil)
  if valid_613491 != nil:
    section.add "ClusterSubnetGroupName", valid_613491
  var valid_613492 = query.getOrDefault("MaintenanceTrackName")
  valid_613492 = validateParameter(valid_613492, JString, required = false,
                                 default = nil)
  if valid_613492 != nil:
    section.add "MaintenanceTrackName", valid_613492
  var valid_613493 = query.getOrDefault("DBName")
  valid_613493 = validateParameter(valid_613493, JString, required = false,
                                 default = nil)
  if valid_613493 != nil:
    section.add "DBName", valid_613493
  var valid_613494 = query.getOrDefault("Encrypted")
  valid_613494 = validateParameter(valid_613494, JBool, required = false, default = nil)
  if valid_613494 != nil:
    section.add "Encrypted", valid_613494
  var valid_613495 = query.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_613495 = validateParameter(valid_613495, JInt, required = false, default = nil)
  if valid_613495 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_613495
  var valid_613496 = query.getOrDefault("HsmClientCertificateIdentifier")
  valid_613496 = validateParameter(valid_613496, JString, required = false,
                                 default = nil)
  if valid_613496 != nil:
    section.add "HsmClientCertificateIdentifier", valid_613496
  var valid_613497 = query.getOrDefault("ClusterSecurityGroups")
  valid_613497 = validateParameter(valid_613497, JArray, required = false,
                                 default = nil)
  if valid_613497 != nil:
    section.add "ClusterSecurityGroups", valid_613497
  var valid_613498 = query.getOrDefault("Tags")
  valid_613498 = validateParameter(valid_613498, JArray, required = false,
                                 default = nil)
  if valid_613498 != nil:
    section.add "Tags", valid_613498
  var valid_613499 = query.getOrDefault("KmsKeyId")
  valid_613499 = validateParameter(valid_613499, JString, required = false,
                                 default = nil)
  if valid_613499 != nil:
    section.add "KmsKeyId", valid_613499
  var valid_613500 = query.getOrDefault("ClusterParameterGroupName")
  valid_613500 = validateParameter(valid_613500, JString, required = false,
                                 default = nil)
  if valid_613500 != nil:
    section.add "ClusterParameterGroupName", valid_613500
  assert query != nil,
        "query argument is necessary due to required `NodeType` field"
  var valid_613501 = query.getOrDefault("NodeType")
  valid_613501 = validateParameter(valid_613501, JString, required = true,
                                 default = nil)
  if valid_613501 != nil:
    section.add "NodeType", valid_613501
  var valid_613502 = query.getOrDefault("ClusterVersion")
  valid_613502 = validateParameter(valid_613502, JString, required = false,
                                 default = nil)
  if valid_613502 != nil:
    section.add "ClusterVersion", valid_613502
  var valid_613503 = query.getOrDefault("IamRoles")
  valid_613503 = validateParameter(valid_613503, JArray, required = false,
                                 default = nil)
  if valid_613503 != nil:
    section.add "IamRoles", valid_613503
  var valid_613504 = query.getOrDefault("SnapshotScheduleIdentifier")
  valid_613504 = validateParameter(valid_613504, JString, required = false,
                                 default = nil)
  if valid_613504 != nil:
    section.add "SnapshotScheduleIdentifier", valid_613504
  var valid_613505 = query.getOrDefault("ClusterType")
  valid_613505 = validateParameter(valid_613505, JString, required = false,
                                 default = nil)
  if valid_613505 != nil:
    section.add "ClusterType", valid_613505
  var valid_613506 = query.getOrDefault("NumberOfNodes")
  valid_613506 = validateParameter(valid_613506, JInt, required = false, default = nil)
  if valid_613506 != nil:
    section.add "NumberOfNodes", valid_613506
  var valid_613507 = query.getOrDefault("MasterUsername")
  valid_613507 = validateParameter(valid_613507, JString, required = true,
                                 default = nil)
  if valid_613507 != nil:
    section.add "MasterUsername", valid_613507
  var valid_613508 = query.getOrDefault("AdditionalInfo")
  valid_613508 = validateParameter(valid_613508, JString, required = false,
                                 default = nil)
  if valid_613508 != nil:
    section.add "AdditionalInfo", valid_613508
  var valid_613509 = query.getOrDefault("AllowVersionUpgrade")
  valid_613509 = validateParameter(valid_613509, JBool, required = false, default = nil)
  if valid_613509 != nil:
    section.add "AllowVersionUpgrade", valid_613509
  var valid_613510 = query.getOrDefault("ElasticIp")
  valid_613510 = validateParameter(valid_613510, JString, required = false,
                                 default = nil)
  if valid_613510 != nil:
    section.add "ElasticIp", valid_613510
  var valid_613511 = query.getOrDefault("AutomatedSnapshotRetentionPeriod")
  valid_613511 = validateParameter(valid_613511, JInt, required = false, default = nil)
  if valid_613511 != nil:
    section.add "AutomatedSnapshotRetentionPeriod", valid_613511
  var valid_613512 = query.getOrDefault("EnhancedVpcRouting")
  valid_613512 = validateParameter(valid_613512, JBool, required = false, default = nil)
  if valid_613512 != nil:
    section.add "EnhancedVpcRouting", valid_613512
  var valid_613513 = query.getOrDefault("Action")
  valid_613513 = validateParameter(valid_613513, JString, required = true,
                                 default = newJString("CreateCluster"))
  if valid_613513 != nil:
    section.add "Action", valid_613513
  var valid_613514 = query.getOrDefault("ClusterIdentifier")
  valid_613514 = validateParameter(valid_613514, JString, required = true,
                                 default = nil)
  if valid_613514 != nil:
    section.add "ClusterIdentifier", valid_613514
  var valid_613515 = query.getOrDefault("Port")
  valid_613515 = validateParameter(valid_613515, JInt, required = false, default = nil)
  if valid_613515 != nil:
    section.add "Port", valid_613515
  var valid_613516 = query.getOrDefault("VpcSecurityGroupIds")
  valid_613516 = validateParameter(valid_613516, JArray, required = false,
                                 default = nil)
  if valid_613516 != nil:
    section.add "VpcSecurityGroupIds", valid_613516
  var valid_613517 = query.getOrDefault("MasterUserPassword")
  valid_613517 = validateParameter(valid_613517, JString, required = true,
                                 default = nil)
  if valid_613517 != nil:
    section.add "MasterUserPassword", valid_613517
  var valid_613518 = query.getOrDefault("AvailabilityZone")
  valid_613518 = validateParameter(valid_613518, JString, required = false,
                                 default = nil)
  if valid_613518 != nil:
    section.add "AvailabilityZone", valid_613518
  var valid_613519 = query.getOrDefault("HsmConfigurationIdentifier")
  valid_613519 = validateParameter(valid_613519, JString, required = false,
                                 default = nil)
  if valid_613519 != nil:
    section.add "HsmConfigurationIdentifier", valid_613519
  var valid_613520 = query.getOrDefault("Version")
  valid_613520 = validateParameter(valid_613520, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_613520 != nil:
    section.add "Version", valid_613520
  var valid_613521 = query.getOrDefault("PreferredMaintenanceWindow")
  valid_613521 = validateParameter(valid_613521, JString, required = false,
                                 default = nil)
  if valid_613521 != nil:
    section.add "PreferredMaintenanceWindow", valid_613521
  var valid_613522 = query.getOrDefault("PubliclyAccessible")
  valid_613522 = validateParameter(valid_613522, JBool, required = false, default = nil)
  if valid_613522 != nil:
    section.add "PubliclyAccessible", valid_613522
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613523 = header.getOrDefault("X-Amz-Signature")
  valid_613523 = validateParameter(valid_613523, JString, required = false,
                                 default = nil)
  if valid_613523 != nil:
    section.add "X-Amz-Signature", valid_613523
  var valid_613524 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613524 = validateParameter(valid_613524, JString, required = false,
                                 default = nil)
  if valid_613524 != nil:
    section.add "X-Amz-Content-Sha256", valid_613524
  var valid_613525 = header.getOrDefault("X-Amz-Date")
  valid_613525 = validateParameter(valid_613525, JString, required = false,
                                 default = nil)
  if valid_613525 != nil:
    section.add "X-Amz-Date", valid_613525
  var valid_613526 = header.getOrDefault("X-Amz-Credential")
  valid_613526 = validateParameter(valid_613526, JString, required = false,
                                 default = nil)
  if valid_613526 != nil:
    section.add "X-Amz-Credential", valid_613526
  var valid_613527 = header.getOrDefault("X-Amz-Security-Token")
  valid_613527 = validateParameter(valid_613527, JString, required = false,
                                 default = nil)
  if valid_613527 != nil:
    section.add "X-Amz-Security-Token", valid_613527
  var valid_613528 = header.getOrDefault("X-Amz-Algorithm")
  valid_613528 = validateParameter(valid_613528, JString, required = false,
                                 default = nil)
  if valid_613528 != nil:
    section.add "X-Amz-Algorithm", valid_613528
  var valid_613529 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613529 = validateParameter(valid_613529, JString, required = false,
                                 default = nil)
  if valid_613529 != nil:
    section.add "X-Amz-SignedHeaders", valid_613529
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613530: Call_GetCreateCluster_613488; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a new cluster with the specified parameters.</p> <p>To create a cluster in Virtual Private Cloud (VPC), you must provide a cluster subnet group name. The cluster subnet group identifies the subnets of your VPC that Amazon Redshift uses when creating the cluster. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_613530.validator(path, query, header, formData, body)
  let scheme = call_613530.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613530.url(scheme.get, call_613530.host, call_613530.base,
                         call_613530.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613530, url, valid)

proc call*(call_613531: Call_GetCreateCluster_613488; NodeType: string;
          MasterUsername: string; ClusterIdentifier: string;
          MasterUserPassword: string; ClusterSubnetGroupName: string = "";
          MaintenanceTrackName: string = ""; DBName: string = "";
          Encrypted: bool = false; ManualSnapshotRetentionPeriod: int = 0;
          HsmClientCertificateIdentifier: string = "";
          ClusterSecurityGroups: JsonNode = nil; Tags: JsonNode = nil;
          KmsKeyId: string = ""; ClusterParameterGroupName: string = "";
          ClusterVersion: string = ""; IamRoles: JsonNode = nil;
          SnapshotScheduleIdentifier: string = ""; ClusterType: string = "";
          NumberOfNodes: int = 0; AdditionalInfo: string = "";
          AllowVersionUpgrade: bool = false; ElasticIp: string = "";
          AutomatedSnapshotRetentionPeriod: int = 0;
          EnhancedVpcRouting: bool = false; Action: string = "CreateCluster";
          Port: int = 0; VpcSecurityGroupIds: JsonNode = nil;
          AvailabilityZone: string = ""; HsmConfigurationIdentifier: string = "";
          Version: string = "2012-12-01"; PreferredMaintenanceWindow: string = "";
          PubliclyAccessible: bool = false): Recallable =
  ## getCreateCluster
  ## <p>Creates a new cluster with the specified parameters.</p> <p>To create a cluster in Virtual Private Cloud (VPC), you must provide a cluster subnet group name. The cluster subnet group identifies the subnets of your VPC that Amazon Redshift uses when creating the cluster. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   ClusterSubnetGroupName: string
  ##                         : <p>The name of a cluster subnet group to be associated with this cluster.</p> <p>If this parameter is not provided the resulting cluster will be deployed outside virtual private cloud (VPC).</p>
  ##   MaintenanceTrackName: string
  ##                       : An optional parameter for the name of the maintenance track for the cluster. If you don't provide a maintenance track name, the cluster is assigned to the <code>current</code> track.
  ##   DBName: string
  ##         : <p>The name of the first database to be created when the cluster is created.</p> <p>To create additional databases after the cluster is created, connect to the cluster with a SQL client and use SQL commands to create a database. For more information, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/t_creating_database.html">Create a Database</a> in the Amazon Redshift Database Developer Guide. </p> <p>Default: <code>dev</code> </p> <p>Constraints:</p> <ul> <li> <p>Must contain 1 to 64 alphanumeric characters.</p> </li> <li> <p>Must contain only lowercase letters.</p> </li> <li> <p>Cannot be a word that is reserved by the service. A list of reserved words can be found in <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide. </p> </li> </ul>
  ##   Encrypted: bool
  ##            : <p>If <code>true</code>, the data in the cluster is encrypted at rest. </p> <p>Default: false</p>
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The default number of days to retain a manual snapshot. If the value is -1, the snapshot is retained indefinitely. This setting doesn't change the retention period of existing snapshots.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  ##   HsmClientCertificateIdentifier: string
  ##                                 : Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM.
  ##   ClusterSecurityGroups: JArray
  ##                        : <p>A list of security groups to be associated with this cluster.</p> <p>Default: The default cluster security group for Amazon Redshift.</p>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   KmsKeyId: string
  ##           : The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster.
  ##   ClusterParameterGroupName: string
  ##                            : <p>The name of the parameter group to be associated with this cluster.</p> <p>Default: The default Amazon Redshift cluster parameter group. For information about the default parameter group, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Working with Amazon Redshift Parameter Groups</a> </p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   NodeType: string (required)
  ##           : <p>The node type to be provisioned for the cluster. For information about node types, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#how-many-nodes"> Working with Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p> <p>Valid Values: <code>ds2.xlarge</code> | <code>ds2.8xlarge</code> | <code>dc1.large</code> | <code>dc1.8xlarge</code> | <code>dc2.large</code> | <code>dc2.8xlarge</code> | <code>ra3.16xlarge</code> </p>
  ##   ClusterVersion: string
  ##                 : <p>The version of the Amazon Redshift engine software that you want to deploy on the cluster.</p> <p>The version selected runs on all the nodes in the cluster.</p> <p>Constraints: Only version 1.0 is currently available.</p> <p>Example: <code>1.0</code> </p>
  ##   IamRoles: JArray
  ##           : <p>A list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services. You must supply the IAM roles in their Amazon Resource Name (ARN) format. You can supply up to 10 IAM roles in a single request.</p> <p>A cluster can have up to 10 IAM roles associated with it at any time.</p>
  ##   SnapshotScheduleIdentifier: string
  ##                             : A unique identifier for the snapshot schedule.
  ##   ClusterType: string
  ##              : <p>The type of the cluster. When cluster type is specified as</p> <ul> <li> <p> <code>single-node</code>, the <b>NumberOfNodes</b> parameter is not required.</p> </li> <li> <p> <code>multi-node</code>, the <b>NumberOfNodes</b> parameter is required.</p> </li> </ul> <p>Valid Values: <code>multi-node</code> | <code>single-node</code> </p> <p>Default: <code>multi-node</code> </p>
  ##   NumberOfNodes: int
  ##                : <p>The number of compute nodes in the cluster. This parameter is required when the <b>ClusterType</b> parameter is specified as <code>multi-node</code>. </p> <p>For information about determining how many nodes you need, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#how-many-nodes"> Working with Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p> <p>If you don't specify this parameter, you get a single-node cluster. When requesting a multi-node cluster, you must specify the number of nodes that you want in the cluster.</p> <p>Default: <code>1</code> </p> <p>Constraints: Value must be at least 1 and no more than 100.</p>
  ##   MasterUsername: string (required)
  ##                 : <p>The user name associated with the master user account for the cluster that is being created.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 - 128 alphanumeric characters. The user name can't be <code>PUBLIC</code>.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide. </p> </li> </ul>
  ##   AdditionalInfo: string
  ##                 : Reserved.
  ##   AllowVersionUpgrade: bool
  ##                      : <p>If <code>true</code>, major version upgrades can be applied during the maintenance window to the Amazon Redshift engine that is running on the cluster.</p> <p>When a new major version of the Amazon Redshift engine is released, you can request that the service automatically apply upgrades during the maintenance window to the Amazon Redshift engine that is running on your cluster.</p> <p>Default: <code>true</code> </p>
  ##   ElasticIp: string
  ##            : <p>The Elastic IP (EIP) address for the cluster.</p> <p>Constraints: The cluster must be provisioned in EC2-VPC and publicly-accessible through an Internet gateway. For more information about provisioning clusters in EC2-VPC, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#cluster-platforms">Supported Platforms to Launch Your Cluster</a> in the Amazon Redshift Cluster Management Guide.</p>
  ##   AutomatedSnapshotRetentionPeriod: int
  ##                                   : <p>The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p> <p>Default: <code>1</code> </p> <p>Constraints: Must be a value from 0 to 35.</p>
  ##   EnhancedVpcRouting: bool
  ##                     : <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p> <p>Default: false</p>
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>A unique identifier for the cluster. You use this identifier to refer to the cluster for any subsequent cluster operations such as deleting or modifying. The identifier also appears in the Amazon Redshift console.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul> <p>Example: <code>myexamplecluster</code> </p>
  ##   Port: int
  ##       : <p>The port number on which the cluster accepts incoming connections.</p> <p>The cluster is accessible only via the JDBC and ODBC connection strings. Part of the connection string requires the port on which the cluster will listen for incoming connections.</p> <p>Default: <code>5439</code> </p> <p>Valid Values: <code>1150-65535</code> </p>
  ##   VpcSecurityGroupIds: JArray
  ##                      : <p>A list of Virtual Private Cloud (VPC) security groups to be associated with the cluster.</p> <p>Default: The default VPC security group is associated with the cluster.</p>
  ##   MasterUserPassword: string (required)
  ##                     : <p>The password associated with the master user account for the cluster that is being created.</p> <p>Constraints:</p> <ul> <li> <p>Must be between 8 and 64 characters in length.</p> </li> <li> <p>Must contain at least one uppercase letter.</p> </li> <li> <p>Must contain at least one lowercase letter.</p> </li> <li> <p>Must contain one number.</p> </li> <li> <p>Can be any printable ASCII character (ASCII code 33 to 126) except ' (single quote), " (double quote), \, /, @, or space.</p> </li> </ul>
  ##   AvailabilityZone: string
  ##                   : <p>The EC2 Availability Zone (AZ) in which you want Amazon Redshift to provision the cluster. For example, if you have several EC2 instances running in a specific Availability Zone, then you might want the cluster to be provisioned in the same zone in order to decrease network latency.</p> <p>Default: A random, system-chosen Availability Zone in the region that is specified by the endpoint.</p> <p>Example: <code>us-east-2d</code> </p> <p>Constraint: The specified Availability Zone must be in the same region as the current endpoint.</p>
  ##   HsmConfigurationIdentifier: string
  ##                             : Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
  ##   Version: string (required)
  ##   PreferredMaintenanceWindow: string
  ##                             : <p>The weekly time range (in UTC) during which automated cluster maintenance can occur.</p> <p> Format: <code>ddd:hh24:mi-ddd:hh24:mi</code> </p> <p> Default: A 30-minute window selected at random from an 8-hour block of time per region, occurring on a random day of the week. For more information about the time blocks for each region, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-maintenance-windows">Maintenance Windows</a> in Amazon Redshift Cluster Management Guide.</p> <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p> <p>Constraints: Minimum 30-minute window.</p>
  ##   PubliclyAccessible: bool
  ##                     : If <code>true</code>, the cluster can be accessed from a public network. 
  var query_613532 = newJObject()
  add(query_613532, "ClusterSubnetGroupName", newJString(ClusterSubnetGroupName))
  add(query_613532, "MaintenanceTrackName", newJString(MaintenanceTrackName))
  add(query_613532, "DBName", newJString(DBName))
  add(query_613532, "Encrypted", newJBool(Encrypted))
  add(query_613532, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  add(query_613532, "HsmClientCertificateIdentifier",
      newJString(HsmClientCertificateIdentifier))
  if ClusterSecurityGroups != nil:
    query_613532.add "ClusterSecurityGroups", ClusterSecurityGroups
  if Tags != nil:
    query_613532.add "Tags", Tags
  add(query_613532, "KmsKeyId", newJString(KmsKeyId))
  add(query_613532, "ClusterParameterGroupName",
      newJString(ClusterParameterGroupName))
  add(query_613532, "NodeType", newJString(NodeType))
  add(query_613532, "ClusterVersion", newJString(ClusterVersion))
  if IamRoles != nil:
    query_613532.add "IamRoles", IamRoles
  add(query_613532, "SnapshotScheduleIdentifier",
      newJString(SnapshotScheduleIdentifier))
  add(query_613532, "ClusterType", newJString(ClusterType))
  add(query_613532, "NumberOfNodes", newJInt(NumberOfNodes))
  add(query_613532, "MasterUsername", newJString(MasterUsername))
  add(query_613532, "AdditionalInfo", newJString(AdditionalInfo))
  add(query_613532, "AllowVersionUpgrade", newJBool(AllowVersionUpgrade))
  add(query_613532, "ElasticIp", newJString(ElasticIp))
  add(query_613532, "AutomatedSnapshotRetentionPeriod",
      newJInt(AutomatedSnapshotRetentionPeriod))
  add(query_613532, "EnhancedVpcRouting", newJBool(EnhancedVpcRouting))
  add(query_613532, "Action", newJString(Action))
  add(query_613532, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_613532, "Port", newJInt(Port))
  if VpcSecurityGroupIds != nil:
    query_613532.add "VpcSecurityGroupIds", VpcSecurityGroupIds
  add(query_613532, "MasterUserPassword", newJString(MasterUserPassword))
  add(query_613532, "AvailabilityZone", newJString(AvailabilityZone))
  add(query_613532, "HsmConfigurationIdentifier",
      newJString(HsmConfigurationIdentifier))
  add(query_613532, "Version", newJString(Version))
  add(query_613532, "PreferredMaintenanceWindow",
      newJString(PreferredMaintenanceWindow))
  add(query_613532, "PubliclyAccessible", newJBool(PubliclyAccessible))
  result = call_613531.call(nil, query_613532, nil, nil, nil)

var getCreateCluster* = Call_GetCreateCluster_613488(name: "getCreateCluster",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=CreateCluster", validator: validate_GetCreateCluster_613489,
    base: "/", url: url_GetCreateCluster_613490,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCreateClusterParameterGroup_613598 = ref object of OpenApiRestCall_612642
proc url_PostCreateClusterParameterGroup_613600(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostCreateClusterParameterGroup_613599(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates an Amazon Redshift parameter group.</p> <p>Creating parameter groups is independent of creating clusters. You can associate a cluster with a parameter group when you create the cluster. You can also associate an existing cluster with a parameter group after the cluster is created by using <a>ModifyCluster</a>. </p> <p>Parameters in the parameter group define specific behavior that applies to the databases you create on the cluster. For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_613601 = query.getOrDefault("Action")
  valid_613601 = validateParameter(valid_613601, JString, required = true, default = newJString(
      "CreateClusterParameterGroup"))
  if valid_613601 != nil:
    section.add "Action", valid_613601
  var valid_613602 = query.getOrDefault("Version")
  valid_613602 = validateParameter(valid_613602, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_613602 != nil:
    section.add "Version", valid_613602
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613603 = header.getOrDefault("X-Amz-Signature")
  valid_613603 = validateParameter(valid_613603, JString, required = false,
                                 default = nil)
  if valid_613603 != nil:
    section.add "X-Amz-Signature", valid_613603
  var valid_613604 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613604 = validateParameter(valid_613604, JString, required = false,
                                 default = nil)
  if valid_613604 != nil:
    section.add "X-Amz-Content-Sha256", valid_613604
  var valid_613605 = header.getOrDefault("X-Amz-Date")
  valid_613605 = validateParameter(valid_613605, JString, required = false,
                                 default = nil)
  if valid_613605 != nil:
    section.add "X-Amz-Date", valid_613605
  var valid_613606 = header.getOrDefault("X-Amz-Credential")
  valid_613606 = validateParameter(valid_613606, JString, required = false,
                                 default = nil)
  if valid_613606 != nil:
    section.add "X-Amz-Credential", valid_613606
  var valid_613607 = header.getOrDefault("X-Amz-Security-Token")
  valid_613607 = validateParameter(valid_613607, JString, required = false,
                                 default = nil)
  if valid_613607 != nil:
    section.add "X-Amz-Security-Token", valid_613607
  var valid_613608 = header.getOrDefault("X-Amz-Algorithm")
  valid_613608 = validateParameter(valid_613608, JString, required = false,
                                 default = nil)
  if valid_613608 != nil:
    section.add "X-Amz-Algorithm", valid_613608
  var valid_613609 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613609 = validateParameter(valid_613609, JString, required = false,
                                 default = nil)
  if valid_613609 != nil:
    section.add "X-Amz-SignedHeaders", valid_613609
  result.add "header", section
  ## parameters in `formData` object:
  ##   Description: JString (required)
  ##              : A description of the parameter group.
  ##   ParameterGroupFamily: JString (required)
  ##                       : <p>The Amazon Redshift engine version to which the cluster parameter group applies. The cluster engine version determines the set of parameters.</p> <p>To get a list of valid parameter group family names, you can call <a>DescribeClusterParameterGroups</a>. By default, Amazon Redshift returns a list of all the parameter groups that are owned by your AWS account, including the default parameter groups for each Amazon Redshift engine version. The parameter group family names associated with the default parameter groups provide you the valid values. For example, a valid family name is "redshift-1.0". </p>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   ParameterGroupName: JString (required)
  ##                     : <p>The name of the cluster parameter group.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique withing your AWS account.</p> </li> </ul> <note> <p>This value is stored as a lower-case string.</p> </note>
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `Description` field"
  var valid_613610 = formData.getOrDefault("Description")
  valid_613610 = validateParameter(valid_613610, JString, required = true,
                                 default = nil)
  if valid_613610 != nil:
    section.add "Description", valid_613610
  var valid_613611 = formData.getOrDefault("ParameterGroupFamily")
  valid_613611 = validateParameter(valid_613611, JString, required = true,
                                 default = nil)
  if valid_613611 != nil:
    section.add "ParameterGroupFamily", valid_613611
  var valid_613612 = formData.getOrDefault("Tags")
  valid_613612 = validateParameter(valid_613612, JArray, required = false,
                                 default = nil)
  if valid_613612 != nil:
    section.add "Tags", valid_613612
  var valid_613613 = formData.getOrDefault("ParameterGroupName")
  valid_613613 = validateParameter(valid_613613, JString, required = true,
                                 default = nil)
  if valid_613613 != nil:
    section.add "ParameterGroupName", valid_613613
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613614: Call_PostCreateClusterParameterGroup_613598;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Creates an Amazon Redshift parameter group.</p> <p>Creating parameter groups is independent of creating clusters. You can associate a cluster with a parameter group when you create the cluster. You can also associate an existing cluster with a parameter group after the cluster is created by using <a>ModifyCluster</a>. </p> <p>Parameters in the parameter group define specific behavior that applies to the databases you create on the cluster. For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_613614.validator(path, query, header, formData, body)
  let scheme = call_613614.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613614.url(scheme.get, call_613614.host, call_613614.base,
                         call_613614.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613614, url, valid)

proc call*(call_613615: Call_PostCreateClusterParameterGroup_613598;
          Description: string; ParameterGroupFamily: string;
          ParameterGroupName: string;
          Action: string = "CreateClusterParameterGroup"; Tags: JsonNode = nil;
          Version: string = "2012-12-01"): Recallable =
  ## postCreateClusterParameterGroup
  ## <p>Creates an Amazon Redshift parameter group.</p> <p>Creating parameter groups is independent of creating clusters. You can associate a cluster with a parameter group when you create the cluster. You can also associate an existing cluster with a parameter group after the cluster is created by using <a>ModifyCluster</a>. </p> <p>Parameters in the parameter group define specific behavior that applies to the databases you create on the cluster. For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   Description: string (required)
  ##              : A description of the parameter group.
  ##   ParameterGroupFamily: string (required)
  ##                       : <p>The Amazon Redshift engine version to which the cluster parameter group applies. The cluster engine version determines the set of parameters.</p> <p>To get a list of valid parameter group family names, you can call <a>DescribeClusterParameterGroups</a>. By default, Amazon Redshift returns a list of all the parameter groups that are owned by your AWS account, including the default parameter groups for each Amazon Redshift engine version. The parameter group family names associated with the default parameter groups provide you the valid values. For example, a valid family name is "redshift-1.0". </p>
  ##   Action: string (required)
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   ParameterGroupName: string (required)
  ##                     : <p>The name of the cluster parameter group.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique withing your AWS account.</p> </li> </ul> <note> <p>This value is stored as a lower-case string.</p> </note>
  ##   Version: string (required)
  var query_613616 = newJObject()
  var formData_613617 = newJObject()
  add(formData_613617, "Description", newJString(Description))
  add(formData_613617, "ParameterGroupFamily", newJString(ParameterGroupFamily))
  add(query_613616, "Action", newJString(Action))
  if Tags != nil:
    formData_613617.add "Tags", Tags
  add(formData_613617, "ParameterGroupName", newJString(ParameterGroupName))
  add(query_613616, "Version", newJString(Version))
  result = call_613615.call(nil, query_613616, nil, formData_613617, nil)

var postCreateClusterParameterGroup* = Call_PostCreateClusterParameterGroup_613598(
    name: "postCreateClusterParameterGroup", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=CreateClusterParameterGroup",
    validator: validate_PostCreateClusterParameterGroup_613599, base: "/",
    url: url_PostCreateClusterParameterGroup_613600,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCreateClusterParameterGroup_613579 = ref object of OpenApiRestCall_612642
proc url_GetCreateClusterParameterGroup_613581(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetCreateClusterParameterGroup_613580(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates an Amazon Redshift parameter group.</p> <p>Creating parameter groups is independent of creating clusters. You can associate a cluster with a parameter group when you create the cluster. You can also associate an existing cluster with a parameter group after the cluster is created by using <a>ModifyCluster</a>. </p> <p>Parameters in the parameter group define specific behavior that applies to the databases you create on the cluster. For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   ParameterGroupFamily: JString (required)
  ##                       : <p>The Amazon Redshift engine version to which the cluster parameter group applies. The cluster engine version determines the set of parameters.</p> <p>To get a list of valid parameter group family names, you can call <a>DescribeClusterParameterGroups</a>. By default, Amazon Redshift returns a list of all the parameter groups that are owned by your AWS account, including the default parameter groups for each Amazon Redshift engine version. The parameter group family names associated with the default parameter groups provide you the valid values. For example, a valid family name is "redshift-1.0". </p>
  ##   Action: JString (required)
  ##   Description: JString (required)
  ##              : A description of the parameter group.
  ##   ParameterGroupName: JString (required)
  ##                     : <p>The name of the cluster parameter group.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique withing your AWS account.</p> </li> </ul> <note> <p>This value is stored as a lower-case string.</p> </note>
  ##   Version: JString (required)
  section = newJObject()
  var valid_613582 = query.getOrDefault("Tags")
  valid_613582 = validateParameter(valid_613582, JArray, required = false,
                                 default = nil)
  if valid_613582 != nil:
    section.add "Tags", valid_613582
  assert query != nil, "query argument is necessary due to required `ParameterGroupFamily` field"
  var valid_613583 = query.getOrDefault("ParameterGroupFamily")
  valid_613583 = validateParameter(valid_613583, JString, required = true,
                                 default = nil)
  if valid_613583 != nil:
    section.add "ParameterGroupFamily", valid_613583
  var valid_613584 = query.getOrDefault("Action")
  valid_613584 = validateParameter(valid_613584, JString, required = true, default = newJString(
      "CreateClusterParameterGroup"))
  if valid_613584 != nil:
    section.add "Action", valid_613584
  var valid_613585 = query.getOrDefault("Description")
  valid_613585 = validateParameter(valid_613585, JString, required = true,
                                 default = nil)
  if valid_613585 != nil:
    section.add "Description", valid_613585
  var valid_613586 = query.getOrDefault("ParameterGroupName")
  valid_613586 = validateParameter(valid_613586, JString, required = true,
                                 default = nil)
  if valid_613586 != nil:
    section.add "ParameterGroupName", valid_613586
  var valid_613587 = query.getOrDefault("Version")
  valid_613587 = validateParameter(valid_613587, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_613587 != nil:
    section.add "Version", valid_613587
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613588 = header.getOrDefault("X-Amz-Signature")
  valid_613588 = validateParameter(valid_613588, JString, required = false,
                                 default = nil)
  if valid_613588 != nil:
    section.add "X-Amz-Signature", valid_613588
  var valid_613589 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613589 = validateParameter(valid_613589, JString, required = false,
                                 default = nil)
  if valid_613589 != nil:
    section.add "X-Amz-Content-Sha256", valid_613589
  var valid_613590 = header.getOrDefault("X-Amz-Date")
  valid_613590 = validateParameter(valid_613590, JString, required = false,
                                 default = nil)
  if valid_613590 != nil:
    section.add "X-Amz-Date", valid_613590
  var valid_613591 = header.getOrDefault("X-Amz-Credential")
  valid_613591 = validateParameter(valid_613591, JString, required = false,
                                 default = nil)
  if valid_613591 != nil:
    section.add "X-Amz-Credential", valid_613591
  var valid_613592 = header.getOrDefault("X-Amz-Security-Token")
  valid_613592 = validateParameter(valid_613592, JString, required = false,
                                 default = nil)
  if valid_613592 != nil:
    section.add "X-Amz-Security-Token", valid_613592
  var valid_613593 = header.getOrDefault("X-Amz-Algorithm")
  valid_613593 = validateParameter(valid_613593, JString, required = false,
                                 default = nil)
  if valid_613593 != nil:
    section.add "X-Amz-Algorithm", valid_613593
  var valid_613594 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613594 = validateParameter(valid_613594, JString, required = false,
                                 default = nil)
  if valid_613594 != nil:
    section.add "X-Amz-SignedHeaders", valid_613594
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613595: Call_GetCreateClusterParameterGroup_613579; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates an Amazon Redshift parameter group.</p> <p>Creating parameter groups is independent of creating clusters. You can associate a cluster with a parameter group when you create the cluster. You can also associate an existing cluster with a parameter group after the cluster is created by using <a>ModifyCluster</a>. </p> <p>Parameters in the parameter group define specific behavior that applies to the databases you create on the cluster. For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_613595.validator(path, query, header, formData, body)
  let scheme = call_613595.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613595.url(scheme.get, call_613595.host, call_613595.base,
                         call_613595.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613595, url, valid)

proc call*(call_613596: Call_GetCreateClusterParameterGroup_613579;
          ParameterGroupFamily: string; Description: string;
          ParameterGroupName: string; Tags: JsonNode = nil;
          Action: string = "CreateClusterParameterGroup";
          Version: string = "2012-12-01"): Recallable =
  ## getCreateClusterParameterGroup
  ## <p>Creates an Amazon Redshift parameter group.</p> <p>Creating parameter groups is independent of creating clusters. You can associate a cluster with a parameter group when you create the cluster. You can also associate an existing cluster with a parameter group after the cluster is created by using <a>ModifyCluster</a>. </p> <p>Parameters in the parameter group define specific behavior that applies to the databases you create on the cluster. For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   ParameterGroupFamily: string (required)
  ##                       : <p>The Amazon Redshift engine version to which the cluster parameter group applies. The cluster engine version determines the set of parameters.</p> <p>To get a list of valid parameter group family names, you can call <a>DescribeClusterParameterGroups</a>. By default, Amazon Redshift returns a list of all the parameter groups that are owned by your AWS account, including the default parameter groups for each Amazon Redshift engine version. The parameter group family names associated with the default parameter groups provide you the valid values. For example, a valid family name is "redshift-1.0". </p>
  ##   Action: string (required)
  ##   Description: string (required)
  ##              : A description of the parameter group.
  ##   ParameterGroupName: string (required)
  ##                     : <p>The name of the cluster parameter group.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique withing your AWS account.</p> </li> </ul> <note> <p>This value is stored as a lower-case string.</p> </note>
  ##   Version: string (required)
  var query_613597 = newJObject()
  if Tags != nil:
    query_613597.add "Tags", Tags
  add(query_613597, "ParameterGroupFamily", newJString(ParameterGroupFamily))
  add(query_613597, "Action", newJString(Action))
  add(query_613597, "Description", newJString(Description))
  add(query_613597, "ParameterGroupName", newJString(ParameterGroupName))
  add(query_613597, "Version", newJString(Version))
  result = call_613596.call(nil, query_613597, nil, nil, nil)

var getCreateClusterParameterGroup* = Call_GetCreateClusterParameterGroup_613579(
    name: "getCreateClusterParameterGroup", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=CreateClusterParameterGroup",
    validator: validate_GetCreateClusterParameterGroup_613580, base: "/",
    url: url_GetCreateClusterParameterGroup_613581,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCreateClusterSecurityGroup_613636 = ref object of OpenApiRestCall_612642
proc url_PostCreateClusterSecurityGroup_613638(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostCreateClusterSecurityGroup_613637(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a new Amazon Redshift security group. You use security groups to control access to non-VPC clusters.</p> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_613639 = query.getOrDefault("Action")
  valid_613639 = validateParameter(valid_613639, JString, required = true, default = newJString(
      "CreateClusterSecurityGroup"))
  if valid_613639 != nil:
    section.add "Action", valid_613639
  var valid_613640 = query.getOrDefault("Version")
  valid_613640 = validateParameter(valid_613640, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_613640 != nil:
    section.add "Version", valid_613640
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613641 = header.getOrDefault("X-Amz-Signature")
  valid_613641 = validateParameter(valid_613641, JString, required = false,
                                 default = nil)
  if valid_613641 != nil:
    section.add "X-Amz-Signature", valid_613641
  var valid_613642 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613642 = validateParameter(valid_613642, JString, required = false,
                                 default = nil)
  if valid_613642 != nil:
    section.add "X-Amz-Content-Sha256", valid_613642
  var valid_613643 = header.getOrDefault("X-Amz-Date")
  valid_613643 = validateParameter(valid_613643, JString, required = false,
                                 default = nil)
  if valid_613643 != nil:
    section.add "X-Amz-Date", valid_613643
  var valid_613644 = header.getOrDefault("X-Amz-Credential")
  valid_613644 = validateParameter(valid_613644, JString, required = false,
                                 default = nil)
  if valid_613644 != nil:
    section.add "X-Amz-Credential", valid_613644
  var valid_613645 = header.getOrDefault("X-Amz-Security-Token")
  valid_613645 = validateParameter(valid_613645, JString, required = false,
                                 default = nil)
  if valid_613645 != nil:
    section.add "X-Amz-Security-Token", valid_613645
  var valid_613646 = header.getOrDefault("X-Amz-Algorithm")
  valid_613646 = validateParameter(valid_613646, JString, required = false,
                                 default = nil)
  if valid_613646 != nil:
    section.add "X-Amz-Algorithm", valid_613646
  var valid_613647 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613647 = validateParameter(valid_613647, JString, required = false,
                                 default = nil)
  if valid_613647 != nil:
    section.add "X-Amz-SignedHeaders", valid_613647
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterSecurityGroupName: JString (required)
  ##                           : <p>The name for the security group. Amazon Redshift stores the value as a lowercase string.</p> <p>Constraints:</p> <ul> <li> <p>Must contain no more than 255 alphanumeric characters or hyphens.</p> </li> <li> <p>Must not be "Default".</p> </li> <li> <p>Must be unique for all security groups that are created by your AWS account.</p> </li> </ul> <p>Example: <code>examplesecuritygroup</code> </p>
  ##   Description: JString (required)
  ##              : A description for the security group.
  ##   Tags: JArray
  ##       : A list of tag instances.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterSecurityGroupName` field"
  var valid_613648 = formData.getOrDefault("ClusterSecurityGroupName")
  valid_613648 = validateParameter(valid_613648, JString, required = true,
                                 default = nil)
  if valid_613648 != nil:
    section.add "ClusterSecurityGroupName", valid_613648
  var valid_613649 = formData.getOrDefault("Description")
  valid_613649 = validateParameter(valid_613649, JString, required = true,
                                 default = nil)
  if valid_613649 != nil:
    section.add "Description", valid_613649
  var valid_613650 = formData.getOrDefault("Tags")
  valid_613650 = validateParameter(valid_613650, JArray, required = false,
                                 default = nil)
  if valid_613650 != nil:
    section.add "Tags", valid_613650
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613651: Call_PostCreateClusterSecurityGroup_613636; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a new Amazon Redshift security group. You use security groups to control access to non-VPC clusters.</p> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_613651.validator(path, query, header, formData, body)
  let scheme = call_613651.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613651.url(scheme.get, call_613651.host, call_613651.base,
                         call_613651.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613651, url, valid)

proc call*(call_613652: Call_PostCreateClusterSecurityGroup_613636;
          ClusterSecurityGroupName: string; Description: string;
          Action: string = "CreateClusterSecurityGroup"; Tags: JsonNode = nil;
          Version: string = "2012-12-01"): Recallable =
  ## postCreateClusterSecurityGroup
  ## <p>Creates a new Amazon Redshift security group. You use security groups to control access to non-VPC clusters.</p> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   ClusterSecurityGroupName: string (required)
  ##                           : <p>The name for the security group. Amazon Redshift stores the value as a lowercase string.</p> <p>Constraints:</p> <ul> <li> <p>Must contain no more than 255 alphanumeric characters or hyphens.</p> </li> <li> <p>Must not be "Default".</p> </li> <li> <p>Must be unique for all security groups that are created by your AWS account.</p> </li> </ul> <p>Example: <code>examplesecuritygroup</code> </p>
  ##   Description: string (required)
  ##              : A description for the security group.
  ##   Action: string (required)
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Version: string (required)
  var query_613653 = newJObject()
  var formData_613654 = newJObject()
  add(formData_613654, "ClusterSecurityGroupName",
      newJString(ClusterSecurityGroupName))
  add(formData_613654, "Description", newJString(Description))
  add(query_613653, "Action", newJString(Action))
  if Tags != nil:
    formData_613654.add "Tags", Tags
  add(query_613653, "Version", newJString(Version))
  result = call_613652.call(nil, query_613653, nil, formData_613654, nil)

var postCreateClusterSecurityGroup* = Call_PostCreateClusterSecurityGroup_613636(
    name: "postCreateClusterSecurityGroup", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=CreateClusterSecurityGroup",
    validator: validate_PostCreateClusterSecurityGroup_613637, base: "/",
    url: url_PostCreateClusterSecurityGroup_613638,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCreateClusterSecurityGroup_613618 = ref object of OpenApiRestCall_612642
proc url_GetCreateClusterSecurityGroup_613620(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetCreateClusterSecurityGroup_613619(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a new Amazon Redshift security group. You use security groups to control access to non-VPC clusters.</p> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   ClusterSecurityGroupName: JString (required)
  ##                           : <p>The name for the security group. Amazon Redshift stores the value as a lowercase string.</p> <p>Constraints:</p> <ul> <li> <p>Must contain no more than 255 alphanumeric characters or hyphens.</p> </li> <li> <p>Must not be "Default".</p> </li> <li> <p>Must be unique for all security groups that are created by your AWS account.</p> </li> </ul> <p>Example: <code>examplesecuritygroup</code> </p>
  ##   Action: JString (required)
  ##   Description: JString (required)
  ##              : A description for the security group.
  ##   Version: JString (required)
  section = newJObject()
  var valid_613621 = query.getOrDefault("Tags")
  valid_613621 = validateParameter(valid_613621, JArray, required = false,
                                 default = nil)
  if valid_613621 != nil:
    section.add "Tags", valid_613621
  assert query != nil, "query argument is necessary due to required `ClusterSecurityGroupName` field"
  var valid_613622 = query.getOrDefault("ClusterSecurityGroupName")
  valid_613622 = validateParameter(valid_613622, JString, required = true,
                                 default = nil)
  if valid_613622 != nil:
    section.add "ClusterSecurityGroupName", valid_613622
  var valid_613623 = query.getOrDefault("Action")
  valid_613623 = validateParameter(valid_613623, JString, required = true, default = newJString(
      "CreateClusterSecurityGroup"))
  if valid_613623 != nil:
    section.add "Action", valid_613623
  var valid_613624 = query.getOrDefault("Description")
  valid_613624 = validateParameter(valid_613624, JString, required = true,
                                 default = nil)
  if valid_613624 != nil:
    section.add "Description", valid_613624
  var valid_613625 = query.getOrDefault("Version")
  valid_613625 = validateParameter(valid_613625, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_613625 != nil:
    section.add "Version", valid_613625
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613626 = header.getOrDefault("X-Amz-Signature")
  valid_613626 = validateParameter(valid_613626, JString, required = false,
                                 default = nil)
  if valid_613626 != nil:
    section.add "X-Amz-Signature", valid_613626
  var valid_613627 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613627 = validateParameter(valid_613627, JString, required = false,
                                 default = nil)
  if valid_613627 != nil:
    section.add "X-Amz-Content-Sha256", valid_613627
  var valid_613628 = header.getOrDefault("X-Amz-Date")
  valid_613628 = validateParameter(valid_613628, JString, required = false,
                                 default = nil)
  if valid_613628 != nil:
    section.add "X-Amz-Date", valid_613628
  var valid_613629 = header.getOrDefault("X-Amz-Credential")
  valid_613629 = validateParameter(valid_613629, JString, required = false,
                                 default = nil)
  if valid_613629 != nil:
    section.add "X-Amz-Credential", valid_613629
  var valid_613630 = header.getOrDefault("X-Amz-Security-Token")
  valid_613630 = validateParameter(valid_613630, JString, required = false,
                                 default = nil)
  if valid_613630 != nil:
    section.add "X-Amz-Security-Token", valid_613630
  var valid_613631 = header.getOrDefault("X-Amz-Algorithm")
  valid_613631 = validateParameter(valid_613631, JString, required = false,
                                 default = nil)
  if valid_613631 != nil:
    section.add "X-Amz-Algorithm", valid_613631
  var valid_613632 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613632 = validateParameter(valid_613632, JString, required = false,
                                 default = nil)
  if valid_613632 != nil:
    section.add "X-Amz-SignedHeaders", valid_613632
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613633: Call_GetCreateClusterSecurityGroup_613618; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a new Amazon Redshift security group. You use security groups to control access to non-VPC clusters.</p> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_613633.validator(path, query, header, formData, body)
  let scheme = call_613633.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613633.url(scheme.get, call_613633.host, call_613633.base,
                         call_613633.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613633, url, valid)

proc call*(call_613634: Call_GetCreateClusterSecurityGroup_613618;
          ClusterSecurityGroupName: string; Description: string;
          Tags: JsonNode = nil; Action: string = "CreateClusterSecurityGroup";
          Version: string = "2012-12-01"): Recallable =
  ## getCreateClusterSecurityGroup
  ## <p>Creates a new Amazon Redshift security group. You use security groups to control access to non-VPC clusters.</p> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   ClusterSecurityGroupName: string (required)
  ##                           : <p>The name for the security group. Amazon Redshift stores the value as a lowercase string.</p> <p>Constraints:</p> <ul> <li> <p>Must contain no more than 255 alphanumeric characters or hyphens.</p> </li> <li> <p>Must not be "Default".</p> </li> <li> <p>Must be unique for all security groups that are created by your AWS account.</p> </li> </ul> <p>Example: <code>examplesecuritygroup</code> </p>
  ##   Action: string (required)
  ##   Description: string (required)
  ##              : A description for the security group.
  ##   Version: string (required)
  var query_613635 = newJObject()
  if Tags != nil:
    query_613635.add "Tags", Tags
  add(query_613635, "ClusterSecurityGroupName",
      newJString(ClusterSecurityGroupName))
  add(query_613635, "Action", newJString(Action))
  add(query_613635, "Description", newJString(Description))
  add(query_613635, "Version", newJString(Version))
  result = call_613634.call(nil, query_613635, nil, nil, nil)

var getCreateClusterSecurityGroup* = Call_GetCreateClusterSecurityGroup_613618(
    name: "getCreateClusterSecurityGroup", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=CreateClusterSecurityGroup",
    validator: validate_GetCreateClusterSecurityGroup_613619, base: "/",
    url: url_GetCreateClusterSecurityGroup_613620,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCreateClusterSnapshot_613674 = ref object of OpenApiRestCall_612642
proc url_PostCreateClusterSnapshot_613676(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostCreateClusterSnapshot_613675(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a manual snapshot of the specified cluster. The cluster must be in the <code>available</code> state. </p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_613677 = query.getOrDefault("Action")
  valid_613677 = validateParameter(valid_613677, JString, required = true,
                                 default = newJString("CreateClusterSnapshot"))
  if valid_613677 != nil:
    section.add "Action", valid_613677
  var valid_613678 = query.getOrDefault("Version")
  valid_613678 = validateParameter(valid_613678, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_613678 != nil:
    section.add "Version", valid_613678
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613679 = header.getOrDefault("X-Amz-Signature")
  valid_613679 = validateParameter(valid_613679, JString, required = false,
                                 default = nil)
  if valid_613679 != nil:
    section.add "X-Amz-Signature", valid_613679
  var valid_613680 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613680 = validateParameter(valid_613680, JString, required = false,
                                 default = nil)
  if valid_613680 != nil:
    section.add "X-Amz-Content-Sha256", valid_613680
  var valid_613681 = header.getOrDefault("X-Amz-Date")
  valid_613681 = validateParameter(valid_613681, JString, required = false,
                                 default = nil)
  if valid_613681 != nil:
    section.add "X-Amz-Date", valid_613681
  var valid_613682 = header.getOrDefault("X-Amz-Credential")
  valid_613682 = validateParameter(valid_613682, JString, required = false,
                                 default = nil)
  if valid_613682 != nil:
    section.add "X-Amz-Credential", valid_613682
  var valid_613683 = header.getOrDefault("X-Amz-Security-Token")
  valid_613683 = validateParameter(valid_613683, JString, required = false,
                                 default = nil)
  if valid_613683 != nil:
    section.add "X-Amz-Security-Token", valid_613683
  var valid_613684 = header.getOrDefault("X-Amz-Algorithm")
  valid_613684 = validateParameter(valid_613684, JString, required = false,
                                 default = nil)
  if valid_613684 != nil:
    section.add "X-Amz-Algorithm", valid_613684
  var valid_613685 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613685 = validateParameter(valid_613685, JString, required = false,
                                 default = nil)
  if valid_613685 != nil:
    section.add "X-Amz-SignedHeaders", valid_613685
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : The cluster identifier for which you want a snapshot.
  ##   SnapshotIdentifier: JString (required)
  ##                     : <p>A unique identifier for the snapshot that you are requesting. This identifier must be unique for all snapshots within the AWS account.</p> <p>Constraints:</p> <ul> <li> <p>Cannot be null, empty, or blank</p> </li> <li> <p>Must contain from 1 to 255 alphanumeric characters or hyphens</p> </li> <li> <p>First character must be a letter</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens</p> </li> </ul> <p>Example: <code>my-snapshot-id</code> </p>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. </p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_613686 = formData.getOrDefault("ClusterIdentifier")
  valid_613686 = validateParameter(valid_613686, JString, required = true,
                                 default = nil)
  if valid_613686 != nil:
    section.add "ClusterIdentifier", valid_613686
  var valid_613687 = formData.getOrDefault("SnapshotIdentifier")
  valid_613687 = validateParameter(valid_613687, JString, required = true,
                                 default = nil)
  if valid_613687 != nil:
    section.add "SnapshotIdentifier", valid_613687
  var valid_613688 = formData.getOrDefault("Tags")
  valid_613688 = validateParameter(valid_613688, JArray, required = false,
                                 default = nil)
  if valid_613688 != nil:
    section.add "Tags", valid_613688
  var valid_613689 = formData.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_613689 = validateParameter(valid_613689, JInt, required = false, default = nil)
  if valid_613689 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_613689
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613690: Call_PostCreateClusterSnapshot_613674; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a manual snapshot of the specified cluster. The cluster must be in the <code>available</code> state. </p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_613690.validator(path, query, header, formData, body)
  let scheme = call_613690.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613690.url(scheme.get, call_613690.host, call_613690.base,
                         call_613690.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613690, url, valid)

proc call*(call_613691: Call_PostCreateClusterSnapshot_613674;
          ClusterIdentifier: string; SnapshotIdentifier: string;
          Action: string = "CreateClusterSnapshot"; Tags: JsonNode = nil;
          Version: string = "2012-12-01"; ManualSnapshotRetentionPeriod: int = 0): Recallable =
  ## postCreateClusterSnapshot
  ## <p>Creates a manual snapshot of the specified cluster. The cluster must be in the <code>available</code> state. </p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   ClusterIdentifier: string (required)
  ##                    : The cluster identifier for which you want a snapshot.
  ##   SnapshotIdentifier: string (required)
  ##                     : <p>A unique identifier for the snapshot that you are requesting. This identifier must be unique for all snapshots within the AWS account.</p> <p>Constraints:</p> <ul> <li> <p>Cannot be null, empty, or blank</p> </li> <li> <p>Must contain from 1 to 255 alphanumeric characters or hyphens</p> </li> <li> <p>First character must be a letter</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens</p> </li> </ul> <p>Example: <code>my-snapshot-id</code> </p>
  ##   Action: string (required)
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Version: string (required)
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. </p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  var query_613692 = newJObject()
  var formData_613693 = newJObject()
  add(formData_613693, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_613693, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_613692, "Action", newJString(Action))
  if Tags != nil:
    formData_613693.add "Tags", Tags
  add(query_613692, "Version", newJString(Version))
  add(formData_613693, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  result = call_613691.call(nil, query_613692, nil, formData_613693, nil)

var postCreateClusterSnapshot* = Call_PostCreateClusterSnapshot_613674(
    name: "postCreateClusterSnapshot", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=CreateClusterSnapshot",
    validator: validate_PostCreateClusterSnapshot_613675, base: "/",
    url: url_PostCreateClusterSnapshot_613676,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCreateClusterSnapshot_613655 = ref object of OpenApiRestCall_612642
proc url_GetCreateClusterSnapshot_613657(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetCreateClusterSnapshot_613656(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a manual snapshot of the specified cluster. The cluster must be in the <code>available</code> state. </p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   SnapshotIdentifier: JString (required)
  ##                     : <p>A unique identifier for the snapshot that you are requesting. This identifier must be unique for all snapshots within the AWS account.</p> <p>Constraints:</p> <ul> <li> <p>Cannot be null, empty, or blank</p> </li> <li> <p>Must contain from 1 to 255 alphanumeric characters or hyphens</p> </li> <li> <p>First character must be a letter</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens</p> </li> </ul> <p>Example: <code>my-snapshot-id</code> </p>
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. </p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : The cluster identifier for which you want a snapshot.
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `SnapshotIdentifier` field"
  var valid_613658 = query.getOrDefault("SnapshotIdentifier")
  valid_613658 = validateParameter(valid_613658, JString, required = true,
                                 default = nil)
  if valid_613658 != nil:
    section.add "SnapshotIdentifier", valid_613658
  var valid_613659 = query.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_613659 = validateParameter(valid_613659, JInt, required = false, default = nil)
  if valid_613659 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_613659
  var valid_613660 = query.getOrDefault("Tags")
  valid_613660 = validateParameter(valid_613660, JArray, required = false,
                                 default = nil)
  if valid_613660 != nil:
    section.add "Tags", valid_613660
  var valid_613661 = query.getOrDefault("Action")
  valid_613661 = validateParameter(valid_613661, JString, required = true,
                                 default = newJString("CreateClusterSnapshot"))
  if valid_613661 != nil:
    section.add "Action", valid_613661
  var valid_613662 = query.getOrDefault("ClusterIdentifier")
  valid_613662 = validateParameter(valid_613662, JString, required = true,
                                 default = nil)
  if valid_613662 != nil:
    section.add "ClusterIdentifier", valid_613662
  var valid_613663 = query.getOrDefault("Version")
  valid_613663 = validateParameter(valid_613663, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_613663 != nil:
    section.add "Version", valid_613663
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613664 = header.getOrDefault("X-Amz-Signature")
  valid_613664 = validateParameter(valid_613664, JString, required = false,
                                 default = nil)
  if valid_613664 != nil:
    section.add "X-Amz-Signature", valid_613664
  var valid_613665 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613665 = validateParameter(valid_613665, JString, required = false,
                                 default = nil)
  if valid_613665 != nil:
    section.add "X-Amz-Content-Sha256", valid_613665
  var valid_613666 = header.getOrDefault("X-Amz-Date")
  valid_613666 = validateParameter(valid_613666, JString, required = false,
                                 default = nil)
  if valid_613666 != nil:
    section.add "X-Amz-Date", valid_613666
  var valid_613667 = header.getOrDefault("X-Amz-Credential")
  valid_613667 = validateParameter(valid_613667, JString, required = false,
                                 default = nil)
  if valid_613667 != nil:
    section.add "X-Amz-Credential", valid_613667
  var valid_613668 = header.getOrDefault("X-Amz-Security-Token")
  valid_613668 = validateParameter(valid_613668, JString, required = false,
                                 default = nil)
  if valid_613668 != nil:
    section.add "X-Amz-Security-Token", valid_613668
  var valid_613669 = header.getOrDefault("X-Amz-Algorithm")
  valid_613669 = validateParameter(valid_613669, JString, required = false,
                                 default = nil)
  if valid_613669 != nil:
    section.add "X-Amz-Algorithm", valid_613669
  var valid_613670 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613670 = validateParameter(valid_613670, JString, required = false,
                                 default = nil)
  if valid_613670 != nil:
    section.add "X-Amz-SignedHeaders", valid_613670
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613671: Call_GetCreateClusterSnapshot_613655; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a manual snapshot of the specified cluster. The cluster must be in the <code>available</code> state. </p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_613671.validator(path, query, header, formData, body)
  let scheme = call_613671.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613671.url(scheme.get, call_613671.host, call_613671.base,
                         call_613671.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613671, url, valid)

proc call*(call_613672: Call_GetCreateClusterSnapshot_613655;
          SnapshotIdentifier: string; ClusterIdentifier: string;
          ManualSnapshotRetentionPeriod: int = 0; Tags: JsonNode = nil;
          Action: string = "CreateClusterSnapshot"; Version: string = "2012-12-01"): Recallable =
  ## getCreateClusterSnapshot
  ## <p>Creates a manual snapshot of the specified cluster. The cluster must be in the <code>available</code> state. </p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   SnapshotIdentifier: string (required)
  ##                     : <p>A unique identifier for the snapshot that you are requesting. This identifier must be unique for all snapshots within the AWS account.</p> <p>Constraints:</p> <ul> <li> <p>Cannot be null, empty, or blank</p> </li> <li> <p>Must contain from 1 to 255 alphanumeric characters or hyphens</p> </li> <li> <p>First character must be a letter</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens</p> </li> </ul> <p>Example: <code>my-snapshot-id</code> </p>
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. </p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : The cluster identifier for which you want a snapshot.
  ##   Version: string (required)
  var query_613673 = newJObject()
  add(query_613673, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_613673, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  if Tags != nil:
    query_613673.add "Tags", Tags
  add(query_613673, "Action", newJString(Action))
  add(query_613673, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_613673, "Version", newJString(Version))
  result = call_613672.call(nil, query_613673, nil, nil, nil)

var getCreateClusterSnapshot* = Call_GetCreateClusterSnapshot_613655(
    name: "getCreateClusterSnapshot", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=CreateClusterSnapshot",
    validator: validate_GetCreateClusterSnapshot_613656, base: "/",
    url: url_GetCreateClusterSnapshot_613657, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCreateClusterSubnetGroup_613713 = ref object of OpenApiRestCall_612642
proc url_PostCreateClusterSubnetGroup_613715(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostCreateClusterSubnetGroup_613714(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a new Amazon Redshift subnet group. You must provide a list of one or more subnets in your existing Amazon Virtual Private Cloud (Amazon VPC) when creating Amazon Redshift subnet group.</p> <p> For information about subnet groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-cluster-subnet-groups.html">Amazon Redshift Cluster Subnet Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_613716 = query.getOrDefault("Action")
  valid_613716 = validateParameter(valid_613716, JString, required = true, default = newJString(
      "CreateClusterSubnetGroup"))
  if valid_613716 != nil:
    section.add "Action", valid_613716
  var valid_613717 = query.getOrDefault("Version")
  valid_613717 = validateParameter(valid_613717, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_613717 != nil:
    section.add "Version", valid_613717
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613718 = header.getOrDefault("X-Amz-Signature")
  valid_613718 = validateParameter(valid_613718, JString, required = false,
                                 default = nil)
  if valid_613718 != nil:
    section.add "X-Amz-Signature", valid_613718
  var valid_613719 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613719 = validateParameter(valid_613719, JString, required = false,
                                 default = nil)
  if valid_613719 != nil:
    section.add "X-Amz-Content-Sha256", valid_613719
  var valid_613720 = header.getOrDefault("X-Amz-Date")
  valid_613720 = validateParameter(valid_613720, JString, required = false,
                                 default = nil)
  if valid_613720 != nil:
    section.add "X-Amz-Date", valid_613720
  var valid_613721 = header.getOrDefault("X-Amz-Credential")
  valid_613721 = validateParameter(valid_613721, JString, required = false,
                                 default = nil)
  if valid_613721 != nil:
    section.add "X-Amz-Credential", valid_613721
  var valid_613722 = header.getOrDefault("X-Amz-Security-Token")
  valid_613722 = validateParameter(valid_613722, JString, required = false,
                                 default = nil)
  if valid_613722 != nil:
    section.add "X-Amz-Security-Token", valid_613722
  var valid_613723 = header.getOrDefault("X-Amz-Algorithm")
  valid_613723 = validateParameter(valid_613723, JString, required = false,
                                 default = nil)
  if valid_613723 != nil:
    section.add "X-Amz-Algorithm", valid_613723
  var valid_613724 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613724 = validateParameter(valid_613724, JString, required = false,
                                 default = nil)
  if valid_613724 != nil:
    section.add "X-Amz-SignedHeaders", valid_613724
  result.add "header", section
  ## parameters in `formData` object:
  ##   Description: JString (required)
  ##              : A description for the subnet group.
  ##   ClusterSubnetGroupName: JString (required)
  ##                         : <p>The name for the subnet group. Amazon Redshift stores the value as a lowercase string.</p> <p>Constraints:</p> <ul> <li> <p>Must contain no more than 255 alphanumeric characters or hyphens.</p> </li> <li> <p>Must not be "Default".</p> </li> <li> <p>Must be unique for all subnet groups that are created by your AWS account.</p> </li> </ul> <p>Example: <code>examplesubnetgroup</code> </p>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   SubnetIds: JArray (required)
  ##            : An array of VPC subnet IDs. A maximum of 20 subnets can be modified in a single request.
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `Description` field"
  var valid_613725 = formData.getOrDefault("Description")
  valid_613725 = validateParameter(valid_613725, JString, required = true,
                                 default = nil)
  if valid_613725 != nil:
    section.add "Description", valid_613725
  var valid_613726 = formData.getOrDefault("ClusterSubnetGroupName")
  valid_613726 = validateParameter(valid_613726, JString, required = true,
                                 default = nil)
  if valid_613726 != nil:
    section.add "ClusterSubnetGroupName", valid_613726
  var valid_613727 = formData.getOrDefault("Tags")
  valid_613727 = validateParameter(valid_613727, JArray, required = false,
                                 default = nil)
  if valid_613727 != nil:
    section.add "Tags", valid_613727
  var valid_613728 = formData.getOrDefault("SubnetIds")
  valid_613728 = validateParameter(valid_613728, JArray, required = true, default = nil)
  if valid_613728 != nil:
    section.add "SubnetIds", valid_613728
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613729: Call_PostCreateClusterSubnetGroup_613713; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a new Amazon Redshift subnet group. You must provide a list of one or more subnets in your existing Amazon Virtual Private Cloud (Amazon VPC) when creating Amazon Redshift subnet group.</p> <p> For information about subnet groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-cluster-subnet-groups.html">Amazon Redshift Cluster Subnet Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_613729.validator(path, query, header, formData, body)
  let scheme = call_613729.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613729.url(scheme.get, call_613729.host, call_613729.base,
                         call_613729.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613729, url, valid)

proc call*(call_613730: Call_PostCreateClusterSubnetGroup_613713;
          Description: string; ClusterSubnetGroupName: string; SubnetIds: JsonNode;
          Action: string = "CreateClusterSubnetGroup"; Tags: JsonNode = nil;
          Version: string = "2012-12-01"): Recallable =
  ## postCreateClusterSubnetGroup
  ## <p>Creates a new Amazon Redshift subnet group. You must provide a list of one or more subnets in your existing Amazon Virtual Private Cloud (Amazon VPC) when creating Amazon Redshift subnet group.</p> <p> For information about subnet groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-cluster-subnet-groups.html">Amazon Redshift Cluster Subnet Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   Description: string (required)
  ##              : A description for the subnet group.
  ##   ClusterSubnetGroupName: string (required)
  ##                         : <p>The name for the subnet group. Amazon Redshift stores the value as a lowercase string.</p> <p>Constraints:</p> <ul> <li> <p>Must contain no more than 255 alphanumeric characters or hyphens.</p> </li> <li> <p>Must not be "Default".</p> </li> <li> <p>Must be unique for all subnet groups that are created by your AWS account.</p> </li> </ul> <p>Example: <code>examplesubnetgroup</code> </p>
  ##   Action: string (required)
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Version: string (required)
  ##   SubnetIds: JArray (required)
  ##            : An array of VPC subnet IDs. A maximum of 20 subnets can be modified in a single request.
  var query_613731 = newJObject()
  var formData_613732 = newJObject()
  add(formData_613732, "Description", newJString(Description))
  add(formData_613732, "ClusterSubnetGroupName",
      newJString(ClusterSubnetGroupName))
  add(query_613731, "Action", newJString(Action))
  if Tags != nil:
    formData_613732.add "Tags", Tags
  add(query_613731, "Version", newJString(Version))
  if SubnetIds != nil:
    formData_613732.add "SubnetIds", SubnetIds
  result = call_613730.call(nil, query_613731, nil, formData_613732, nil)

var postCreateClusterSubnetGroup* = Call_PostCreateClusterSubnetGroup_613713(
    name: "postCreateClusterSubnetGroup", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=CreateClusterSubnetGroup",
    validator: validate_PostCreateClusterSubnetGroup_613714, base: "/",
    url: url_PostCreateClusterSubnetGroup_613715,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCreateClusterSubnetGroup_613694 = ref object of OpenApiRestCall_612642
proc url_GetCreateClusterSubnetGroup_613696(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetCreateClusterSubnetGroup_613695(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a new Amazon Redshift subnet group. You must provide a list of one or more subnets in your existing Amazon Virtual Private Cloud (Amazon VPC) when creating Amazon Redshift subnet group.</p> <p> For information about subnet groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-cluster-subnet-groups.html">Amazon Redshift Cluster Subnet Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ClusterSubnetGroupName: JString (required)
  ##                         : <p>The name for the subnet group. Amazon Redshift stores the value as a lowercase string.</p> <p>Constraints:</p> <ul> <li> <p>Must contain no more than 255 alphanumeric characters or hyphens.</p> </li> <li> <p>Must not be "Default".</p> </li> <li> <p>Must be unique for all subnet groups that are created by your AWS account.</p> </li> </ul> <p>Example: <code>examplesubnetgroup</code> </p>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   SubnetIds: JArray (required)
  ##            : An array of VPC subnet IDs. A maximum of 20 subnets can be modified in a single request.
  ##   Action: JString (required)
  ##   Description: JString (required)
  ##              : A description for the subnet group.
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `ClusterSubnetGroupName` field"
  var valid_613697 = query.getOrDefault("ClusterSubnetGroupName")
  valid_613697 = validateParameter(valid_613697, JString, required = true,
                                 default = nil)
  if valid_613697 != nil:
    section.add "ClusterSubnetGroupName", valid_613697
  var valid_613698 = query.getOrDefault("Tags")
  valid_613698 = validateParameter(valid_613698, JArray, required = false,
                                 default = nil)
  if valid_613698 != nil:
    section.add "Tags", valid_613698
  var valid_613699 = query.getOrDefault("SubnetIds")
  valid_613699 = validateParameter(valid_613699, JArray, required = true, default = nil)
  if valid_613699 != nil:
    section.add "SubnetIds", valid_613699
  var valid_613700 = query.getOrDefault("Action")
  valid_613700 = validateParameter(valid_613700, JString, required = true, default = newJString(
      "CreateClusterSubnetGroup"))
  if valid_613700 != nil:
    section.add "Action", valid_613700
  var valid_613701 = query.getOrDefault("Description")
  valid_613701 = validateParameter(valid_613701, JString, required = true,
                                 default = nil)
  if valid_613701 != nil:
    section.add "Description", valid_613701
  var valid_613702 = query.getOrDefault("Version")
  valid_613702 = validateParameter(valid_613702, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_613702 != nil:
    section.add "Version", valid_613702
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613703 = header.getOrDefault("X-Amz-Signature")
  valid_613703 = validateParameter(valid_613703, JString, required = false,
                                 default = nil)
  if valid_613703 != nil:
    section.add "X-Amz-Signature", valid_613703
  var valid_613704 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613704 = validateParameter(valid_613704, JString, required = false,
                                 default = nil)
  if valid_613704 != nil:
    section.add "X-Amz-Content-Sha256", valid_613704
  var valid_613705 = header.getOrDefault("X-Amz-Date")
  valid_613705 = validateParameter(valid_613705, JString, required = false,
                                 default = nil)
  if valid_613705 != nil:
    section.add "X-Amz-Date", valid_613705
  var valid_613706 = header.getOrDefault("X-Amz-Credential")
  valid_613706 = validateParameter(valid_613706, JString, required = false,
                                 default = nil)
  if valid_613706 != nil:
    section.add "X-Amz-Credential", valid_613706
  var valid_613707 = header.getOrDefault("X-Amz-Security-Token")
  valid_613707 = validateParameter(valid_613707, JString, required = false,
                                 default = nil)
  if valid_613707 != nil:
    section.add "X-Amz-Security-Token", valid_613707
  var valid_613708 = header.getOrDefault("X-Amz-Algorithm")
  valid_613708 = validateParameter(valid_613708, JString, required = false,
                                 default = nil)
  if valid_613708 != nil:
    section.add "X-Amz-Algorithm", valid_613708
  var valid_613709 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613709 = validateParameter(valid_613709, JString, required = false,
                                 default = nil)
  if valid_613709 != nil:
    section.add "X-Amz-SignedHeaders", valid_613709
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613710: Call_GetCreateClusterSubnetGroup_613694; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a new Amazon Redshift subnet group. You must provide a list of one or more subnets in your existing Amazon Virtual Private Cloud (Amazon VPC) when creating Amazon Redshift subnet group.</p> <p> For information about subnet groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-cluster-subnet-groups.html">Amazon Redshift Cluster Subnet Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_613710.validator(path, query, header, formData, body)
  let scheme = call_613710.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613710.url(scheme.get, call_613710.host, call_613710.base,
                         call_613710.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613710, url, valid)

proc call*(call_613711: Call_GetCreateClusterSubnetGroup_613694;
          ClusterSubnetGroupName: string; SubnetIds: JsonNode; Description: string;
          Tags: JsonNode = nil; Action: string = "CreateClusterSubnetGroup";
          Version: string = "2012-12-01"): Recallable =
  ## getCreateClusterSubnetGroup
  ## <p>Creates a new Amazon Redshift subnet group. You must provide a list of one or more subnets in your existing Amazon Virtual Private Cloud (Amazon VPC) when creating Amazon Redshift subnet group.</p> <p> For information about subnet groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-cluster-subnet-groups.html">Amazon Redshift Cluster Subnet Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   ClusterSubnetGroupName: string (required)
  ##                         : <p>The name for the subnet group. Amazon Redshift stores the value as a lowercase string.</p> <p>Constraints:</p> <ul> <li> <p>Must contain no more than 255 alphanumeric characters or hyphens.</p> </li> <li> <p>Must not be "Default".</p> </li> <li> <p>Must be unique for all subnet groups that are created by your AWS account.</p> </li> </ul> <p>Example: <code>examplesubnetgroup</code> </p>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   SubnetIds: JArray (required)
  ##            : An array of VPC subnet IDs. A maximum of 20 subnets can be modified in a single request.
  ##   Action: string (required)
  ##   Description: string (required)
  ##              : A description for the subnet group.
  ##   Version: string (required)
  var query_613712 = newJObject()
  add(query_613712, "ClusterSubnetGroupName", newJString(ClusterSubnetGroupName))
  if Tags != nil:
    query_613712.add "Tags", Tags
  if SubnetIds != nil:
    query_613712.add "SubnetIds", SubnetIds
  add(query_613712, "Action", newJString(Action))
  add(query_613712, "Description", newJString(Description))
  add(query_613712, "Version", newJString(Version))
  result = call_613711.call(nil, query_613712, nil, nil, nil)

var getCreateClusterSubnetGroup* = Call_GetCreateClusterSubnetGroup_613694(
    name: "getCreateClusterSubnetGroup", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=CreateClusterSubnetGroup",
    validator: validate_GetCreateClusterSubnetGroup_613695, base: "/",
    url: url_GetCreateClusterSubnetGroup_613696,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCreateEventSubscription_613756 = ref object of OpenApiRestCall_612642
proc url_PostCreateEventSubscription_613758(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostCreateEventSubscription_613757(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates an Amazon Redshift event notification subscription. This action requires an ARN (Amazon Resource Name) of an Amazon SNS topic created by either the Amazon Redshift console, the Amazon SNS console, or the Amazon SNS API. To obtain an ARN with Amazon SNS, you must create a topic in Amazon SNS and subscribe to the topic. The ARN is displayed in the SNS console.</p> <p>You can specify the source type, and lists of Amazon Redshift source IDs, event categories, and event severities. Notifications will be sent for all events you want that match those criteria. For example, you can specify source type = cluster, source ID = my-cluster-1 and mycluster2, event categories = Availability, Backup, and severity = ERROR. The subscription will only send notifications for those ERROR events in the Availability and Backup categories for the specified clusters.</p> <p>If you specify both the source type and source IDs, such as source type = cluster and source identifier = my-cluster-1, notifications will be sent for all the cluster events for my-cluster-1. If you specify a source type but do not specify a source identifier, you will receive notice of the events for the objects of that type in your AWS account. If you do not specify either the SourceType nor the SourceIdentifier, you will be notified of events generated from all Amazon Redshift sources belonging to your AWS account. You must specify a source type if you specify a source ID.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_613759 = query.getOrDefault("Action")
  valid_613759 = validateParameter(valid_613759, JString, required = true, default = newJString(
      "CreateEventSubscription"))
  if valid_613759 != nil:
    section.add "Action", valid_613759
  var valid_613760 = query.getOrDefault("Version")
  valid_613760 = validateParameter(valid_613760, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_613760 != nil:
    section.add "Version", valid_613760
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613761 = header.getOrDefault("X-Amz-Signature")
  valid_613761 = validateParameter(valid_613761, JString, required = false,
                                 default = nil)
  if valid_613761 != nil:
    section.add "X-Amz-Signature", valid_613761
  var valid_613762 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613762 = validateParameter(valid_613762, JString, required = false,
                                 default = nil)
  if valid_613762 != nil:
    section.add "X-Amz-Content-Sha256", valid_613762
  var valid_613763 = header.getOrDefault("X-Amz-Date")
  valid_613763 = validateParameter(valid_613763, JString, required = false,
                                 default = nil)
  if valid_613763 != nil:
    section.add "X-Amz-Date", valid_613763
  var valid_613764 = header.getOrDefault("X-Amz-Credential")
  valid_613764 = validateParameter(valid_613764, JString, required = false,
                                 default = nil)
  if valid_613764 != nil:
    section.add "X-Amz-Credential", valid_613764
  var valid_613765 = header.getOrDefault("X-Amz-Security-Token")
  valid_613765 = validateParameter(valid_613765, JString, required = false,
                                 default = nil)
  if valid_613765 != nil:
    section.add "X-Amz-Security-Token", valid_613765
  var valid_613766 = header.getOrDefault("X-Amz-Algorithm")
  valid_613766 = validateParameter(valid_613766, JString, required = false,
                                 default = nil)
  if valid_613766 != nil:
    section.add "X-Amz-Algorithm", valid_613766
  var valid_613767 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613767 = validateParameter(valid_613767, JString, required = false,
                                 default = nil)
  if valid_613767 != nil:
    section.add "X-Amz-SignedHeaders", valid_613767
  result.add "header", section
  ## parameters in `formData` object:
  ##   SourceIds: JArray
  ##            : <p>A list of one or more identifiers of Amazon Redshift source objects. All of the objects must be of the same type as was specified in the source type parameter. The event subscription will return only events generated by the specified objects. If not specified, then events are returned for all objects within the source type specified.</p> <p>Example: my-cluster-1, my-cluster-2</p> <p>Example: my-snapshot-20131010</p>
  ##   SnsTopicArn: JString (required)
  ##              : The Amazon Resource Name (ARN) of the Amazon SNS topic used to transmit the event notifications. The ARN is created by Amazon SNS when you create a topic and subscribe to it.
  ##   Enabled: JBool
  ##          : A boolean value; set to <code>true</code> to activate the subscription, and set to <code>false</code> to create the subscription but not activate it. 
  ##   SubscriptionName: JString (required)
  ##                   : <p>The name of the event subscription to be created.</p> <p>Constraints:</p> <ul> <li> <p>Cannot be null, empty, or blank.</p> </li> <li> <p>Must contain from 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   SourceType: JString
  ##             : <p>The type of source that will be generating the events. For example, if you want to be notified of events generated by a cluster, you would set this parameter to cluster. If this value is not specified, events are returned for all Amazon Redshift objects in your AWS account. You must specify a source type in order to specify source IDs.</p> <p>Valid values: cluster, cluster-parameter-group, cluster-security-group, cluster-snapshot, and scheduled-action.</p>
  ##   Severity: JString
  ##           : <p>Specifies the Amazon Redshift event severity to be published by the event notification subscription.</p> <p>Values: ERROR, INFO</p>
  ##   EventCategories: JArray
  ##                  : <p>Specifies the Amazon Redshift event categories to be published by the event notification subscription.</p> <p>Values: configuration, management, monitoring, security</p>
  ##   Tags: JArray
  ##       : A list of tag instances.
  section = newJObject()
  var valid_613768 = formData.getOrDefault("SourceIds")
  valid_613768 = validateParameter(valid_613768, JArray, required = false,
                                 default = nil)
  if valid_613768 != nil:
    section.add "SourceIds", valid_613768
  assert formData != nil,
        "formData argument is necessary due to required `SnsTopicArn` field"
  var valid_613769 = formData.getOrDefault("SnsTopicArn")
  valid_613769 = validateParameter(valid_613769, JString, required = true,
                                 default = nil)
  if valid_613769 != nil:
    section.add "SnsTopicArn", valid_613769
  var valid_613770 = formData.getOrDefault("Enabled")
  valid_613770 = validateParameter(valid_613770, JBool, required = false, default = nil)
  if valid_613770 != nil:
    section.add "Enabled", valid_613770
  var valid_613771 = formData.getOrDefault("SubscriptionName")
  valid_613771 = validateParameter(valid_613771, JString, required = true,
                                 default = nil)
  if valid_613771 != nil:
    section.add "SubscriptionName", valid_613771
  var valid_613772 = formData.getOrDefault("SourceType")
  valid_613772 = validateParameter(valid_613772, JString, required = false,
                                 default = nil)
  if valid_613772 != nil:
    section.add "SourceType", valid_613772
  var valid_613773 = formData.getOrDefault("Severity")
  valid_613773 = validateParameter(valid_613773, JString, required = false,
                                 default = nil)
  if valid_613773 != nil:
    section.add "Severity", valid_613773
  var valid_613774 = formData.getOrDefault("EventCategories")
  valid_613774 = validateParameter(valid_613774, JArray, required = false,
                                 default = nil)
  if valid_613774 != nil:
    section.add "EventCategories", valid_613774
  var valid_613775 = formData.getOrDefault("Tags")
  valid_613775 = validateParameter(valid_613775, JArray, required = false,
                                 default = nil)
  if valid_613775 != nil:
    section.add "Tags", valid_613775
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613776: Call_PostCreateEventSubscription_613756; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates an Amazon Redshift event notification subscription. This action requires an ARN (Amazon Resource Name) of an Amazon SNS topic created by either the Amazon Redshift console, the Amazon SNS console, or the Amazon SNS API. To obtain an ARN with Amazon SNS, you must create a topic in Amazon SNS and subscribe to the topic. The ARN is displayed in the SNS console.</p> <p>You can specify the source type, and lists of Amazon Redshift source IDs, event categories, and event severities. Notifications will be sent for all events you want that match those criteria. For example, you can specify source type = cluster, source ID = my-cluster-1 and mycluster2, event categories = Availability, Backup, and severity = ERROR. The subscription will only send notifications for those ERROR events in the Availability and Backup categories for the specified clusters.</p> <p>If you specify both the source type and source IDs, such as source type = cluster and source identifier = my-cluster-1, notifications will be sent for all the cluster events for my-cluster-1. If you specify a source type but do not specify a source identifier, you will receive notice of the events for the objects of that type in your AWS account. If you do not specify either the SourceType nor the SourceIdentifier, you will be notified of events generated from all Amazon Redshift sources belonging to your AWS account. You must specify a source type if you specify a source ID.</p>
  ## 
  let valid = call_613776.validator(path, query, header, formData, body)
  let scheme = call_613776.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613776.url(scheme.get, call_613776.host, call_613776.base,
                         call_613776.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613776, url, valid)

proc call*(call_613777: Call_PostCreateEventSubscription_613756;
          SnsTopicArn: string; SubscriptionName: string; SourceIds: JsonNode = nil;
          Enabled: bool = false; SourceType: string = ""; Severity: string = "";
          EventCategories: JsonNode = nil;
          Action: string = "CreateEventSubscription"; Tags: JsonNode = nil;
          Version: string = "2012-12-01"): Recallable =
  ## postCreateEventSubscription
  ## <p>Creates an Amazon Redshift event notification subscription. This action requires an ARN (Amazon Resource Name) of an Amazon SNS topic created by either the Amazon Redshift console, the Amazon SNS console, or the Amazon SNS API. To obtain an ARN with Amazon SNS, you must create a topic in Amazon SNS and subscribe to the topic. The ARN is displayed in the SNS console.</p> <p>You can specify the source type, and lists of Amazon Redshift source IDs, event categories, and event severities. Notifications will be sent for all events you want that match those criteria. For example, you can specify source type = cluster, source ID = my-cluster-1 and mycluster2, event categories = Availability, Backup, and severity = ERROR. The subscription will only send notifications for those ERROR events in the Availability and Backup categories for the specified clusters.</p> <p>If you specify both the source type and source IDs, such as source type = cluster and source identifier = my-cluster-1, notifications will be sent for all the cluster events for my-cluster-1. If you specify a source type but do not specify a source identifier, you will receive notice of the events for the objects of that type in your AWS account. If you do not specify either the SourceType nor the SourceIdentifier, you will be notified of events generated from all Amazon Redshift sources belonging to your AWS account. You must specify a source type if you specify a source ID.</p>
  ##   SourceIds: JArray
  ##            : <p>A list of one or more identifiers of Amazon Redshift source objects. All of the objects must be of the same type as was specified in the source type parameter. The event subscription will return only events generated by the specified objects. If not specified, then events are returned for all objects within the source type specified.</p> <p>Example: my-cluster-1, my-cluster-2</p> <p>Example: my-snapshot-20131010</p>
  ##   SnsTopicArn: string (required)
  ##              : The Amazon Resource Name (ARN) of the Amazon SNS topic used to transmit the event notifications. The ARN is created by Amazon SNS when you create a topic and subscribe to it.
  ##   Enabled: bool
  ##          : A boolean value; set to <code>true</code> to activate the subscription, and set to <code>false</code> to create the subscription but not activate it. 
  ##   SubscriptionName: string (required)
  ##                   : <p>The name of the event subscription to be created.</p> <p>Constraints:</p> <ul> <li> <p>Cannot be null, empty, or blank.</p> </li> <li> <p>Must contain from 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   SourceType: string
  ##             : <p>The type of source that will be generating the events. For example, if you want to be notified of events generated by a cluster, you would set this parameter to cluster. If this value is not specified, events are returned for all Amazon Redshift objects in your AWS account. You must specify a source type in order to specify source IDs.</p> <p>Valid values: cluster, cluster-parameter-group, cluster-security-group, cluster-snapshot, and scheduled-action.</p>
  ##   Severity: string
  ##           : <p>Specifies the Amazon Redshift event severity to be published by the event notification subscription.</p> <p>Values: ERROR, INFO</p>
  ##   EventCategories: JArray
  ##                  : <p>Specifies the Amazon Redshift event categories to be published by the event notification subscription.</p> <p>Values: configuration, management, monitoring, security</p>
  ##   Action: string (required)
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Version: string (required)
  var query_613778 = newJObject()
  var formData_613779 = newJObject()
  if SourceIds != nil:
    formData_613779.add "SourceIds", SourceIds
  add(formData_613779, "SnsTopicArn", newJString(SnsTopicArn))
  add(formData_613779, "Enabled", newJBool(Enabled))
  add(formData_613779, "SubscriptionName", newJString(SubscriptionName))
  add(formData_613779, "SourceType", newJString(SourceType))
  add(formData_613779, "Severity", newJString(Severity))
  if EventCategories != nil:
    formData_613779.add "EventCategories", EventCategories
  add(query_613778, "Action", newJString(Action))
  if Tags != nil:
    formData_613779.add "Tags", Tags
  add(query_613778, "Version", newJString(Version))
  result = call_613777.call(nil, query_613778, nil, formData_613779, nil)

var postCreateEventSubscription* = Call_PostCreateEventSubscription_613756(
    name: "postCreateEventSubscription", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=CreateEventSubscription",
    validator: validate_PostCreateEventSubscription_613757, base: "/",
    url: url_PostCreateEventSubscription_613758,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCreateEventSubscription_613733 = ref object of OpenApiRestCall_612642
proc url_GetCreateEventSubscription_613735(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetCreateEventSubscription_613734(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates an Amazon Redshift event notification subscription. This action requires an ARN (Amazon Resource Name) of an Amazon SNS topic created by either the Amazon Redshift console, the Amazon SNS console, or the Amazon SNS API. To obtain an ARN with Amazon SNS, you must create a topic in Amazon SNS and subscribe to the topic. The ARN is displayed in the SNS console.</p> <p>You can specify the source type, and lists of Amazon Redshift source IDs, event categories, and event severities. Notifications will be sent for all events you want that match those criteria. For example, you can specify source type = cluster, source ID = my-cluster-1 and mycluster2, event categories = Availability, Backup, and severity = ERROR. The subscription will only send notifications for those ERROR events in the Availability and Backup categories for the specified clusters.</p> <p>If you specify both the source type and source IDs, such as source type = cluster and source identifier = my-cluster-1, notifications will be sent for all the cluster events for my-cluster-1. If you specify a source type but do not specify a source identifier, you will receive notice of the events for the objects of that type in your AWS account. If you do not specify either the SourceType nor the SourceIdentifier, you will be notified of events generated from all Amazon Redshift sources belonging to your AWS account. You must specify a source type if you specify a source ID.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   SourceType: JString
  ##             : <p>The type of source that will be generating the events. For example, if you want to be notified of events generated by a cluster, you would set this parameter to cluster. If this value is not specified, events are returned for all Amazon Redshift objects in your AWS account. You must specify a source type in order to specify source IDs.</p> <p>Valid values: cluster, cluster-parameter-group, cluster-security-group, cluster-snapshot, and scheduled-action.</p>
  ##   Enabled: JBool
  ##          : A boolean value; set to <code>true</code> to activate the subscription, and set to <code>false</code> to create the subscription but not activate it. 
  ##   Severity: JString
  ##           : <p>Specifies the Amazon Redshift event severity to be published by the event notification subscription.</p> <p>Values: ERROR, INFO</p>
  ##   SubscriptionName: JString (required)
  ##                   : <p>The name of the event subscription to be created.</p> <p>Constraints:</p> <ul> <li> <p>Cannot be null, empty, or blank.</p> </li> <li> <p>Must contain from 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   EventCategories: JArray
  ##                  : <p>Specifies the Amazon Redshift event categories to be published by the event notification subscription.</p> <p>Values: configuration, management, monitoring, security</p>
  ##   SourceIds: JArray
  ##            : <p>A list of one or more identifiers of Amazon Redshift source objects. All of the objects must be of the same type as was specified in the source type parameter. The event subscription will return only events generated by the specified objects. If not specified, then events are returned for all objects within the source type specified.</p> <p>Example: my-cluster-1, my-cluster-2</p> <p>Example: my-snapshot-20131010</p>
  ##   Action: JString (required)
  ##   SnsTopicArn: JString (required)
  ##              : The Amazon Resource Name (ARN) of the Amazon SNS topic used to transmit the event notifications. The ARN is created by Amazon SNS when you create a topic and subscribe to it.
  ##   Version: JString (required)
  section = newJObject()
  var valid_613736 = query.getOrDefault("Tags")
  valid_613736 = validateParameter(valid_613736, JArray, required = false,
                                 default = nil)
  if valid_613736 != nil:
    section.add "Tags", valid_613736
  var valid_613737 = query.getOrDefault("SourceType")
  valid_613737 = validateParameter(valid_613737, JString, required = false,
                                 default = nil)
  if valid_613737 != nil:
    section.add "SourceType", valid_613737
  var valid_613738 = query.getOrDefault("Enabled")
  valid_613738 = validateParameter(valid_613738, JBool, required = false, default = nil)
  if valid_613738 != nil:
    section.add "Enabled", valid_613738
  var valid_613739 = query.getOrDefault("Severity")
  valid_613739 = validateParameter(valid_613739, JString, required = false,
                                 default = nil)
  if valid_613739 != nil:
    section.add "Severity", valid_613739
  assert query != nil,
        "query argument is necessary due to required `SubscriptionName` field"
  var valid_613740 = query.getOrDefault("SubscriptionName")
  valid_613740 = validateParameter(valid_613740, JString, required = true,
                                 default = nil)
  if valid_613740 != nil:
    section.add "SubscriptionName", valid_613740
  var valid_613741 = query.getOrDefault("EventCategories")
  valid_613741 = validateParameter(valid_613741, JArray, required = false,
                                 default = nil)
  if valid_613741 != nil:
    section.add "EventCategories", valid_613741
  var valid_613742 = query.getOrDefault("SourceIds")
  valid_613742 = validateParameter(valid_613742, JArray, required = false,
                                 default = nil)
  if valid_613742 != nil:
    section.add "SourceIds", valid_613742
  var valid_613743 = query.getOrDefault("Action")
  valid_613743 = validateParameter(valid_613743, JString, required = true, default = newJString(
      "CreateEventSubscription"))
  if valid_613743 != nil:
    section.add "Action", valid_613743
  var valid_613744 = query.getOrDefault("SnsTopicArn")
  valid_613744 = validateParameter(valid_613744, JString, required = true,
                                 default = nil)
  if valid_613744 != nil:
    section.add "SnsTopicArn", valid_613744
  var valid_613745 = query.getOrDefault("Version")
  valid_613745 = validateParameter(valid_613745, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_613745 != nil:
    section.add "Version", valid_613745
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613746 = header.getOrDefault("X-Amz-Signature")
  valid_613746 = validateParameter(valid_613746, JString, required = false,
                                 default = nil)
  if valid_613746 != nil:
    section.add "X-Amz-Signature", valid_613746
  var valid_613747 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613747 = validateParameter(valid_613747, JString, required = false,
                                 default = nil)
  if valid_613747 != nil:
    section.add "X-Amz-Content-Sha256", valid_613747
  var valid_613748 = header.getOrDefault("X-Amz-Date")
  valid_613748 = validateParameter(valid_613748, JString, required = false,
                                 default = nil)
  if valid_613748 != nil:
    section.add "X-Amz-Date", valid_613748
  var valid_613749 = header.getOrDefault("X-Amz-Credential")
  valid_613749 = validateParameter(valid_613749, JString, required = false,
                                 default = nil)
  if valid_613749 != nil:
    section.add "X-Amz-Credential", valid_613749
  var valid_613750 = header.getOrDefault("X-Amz-Security-Token")
  valid_613750 = validateParameter(valid_613750, JString, required = false,
                                 default = nil)
  if valid_613750 != nil:
    section.add "X-Amz-Security-Token", valid_613750
  var valid_613751 = header.getOrDefault("X-Amz-Algorithm")
  valid_613751 = validateParameter(valid_613751, JString, required = false,
                                 default = nil)
  if valid_613751 != nil:
    section.add "X-Amz-Algorithm", valid_613751
  var valid_613752 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613752 = validateParameter(valid_613752, JString, required = false,
                                 default = nil)
  if valid_613752 != nil:
    section.add "X-Amz-SignedHeaders", valid_613752
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613753: Call_GetCreateEventSubscription_613733; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates an Amazon Redshift event notification subscription. This action requires an ARN (Amazon Resource Name) of an Amazon SNS topic created by either the Amazon Redshift console, the Amazon SNS console, or the Amazon SNS API. To obtain an ARN with Amazon SNS, you must create a topic in Amazon SNS and subscribe to the topic. The ARN is displayed in the SNS console.</p> <p>You can specify the source type, and lists of Amazon Redshift source IDs, event categories, and event severities. Notifications will be sent for all events you want that match those criteria. For example, you can specify source type = cluster, source ID = my-cluster-1 and mycluster2, event categories = Availability, Backup, and severity = ERROR. The subscription will only send notifications for those ERROR events in the Availability and Backup categories for the specified clusters.</p> <p>If you specify both the source type and source IDs, such as source type = cluster and source identifier = my-cluster-1, notifications will be sent for all the cluster events for my-cluster-1. If you specify a source type but do not specify a source identifier, you will receive notice of the events for the objects of that type in your AWS account. If you do not specify either the SourceType nor the SourceIdentifier, you will be notified of events generated from all Amazon Redshift sources belonging to your AWS account. You must specify a source type if you specify a source ID.</p>
  ## 
  let valid = call_613753.validator(path, query, header, formData, body)
  let scheme = call_613753.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613753.url(scheme.get, call_613753.host, call_613753.base,
                         call_613753.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613753, url, valid)

proc call*(call_613754: Call_GetCreateEventSubscription_613733;
          SubscriptionName: string; SnsTopicArn: string; Tags: JsonNode = nil;
          SourceType: string = ""; Enabled: bool = false; Severity: string = "";
          EventCategories: JsonNode = nil; SourceIds: JsonNode = nil;
          Action: string = "CreateEventSubscription"; Version: string = "2012-12-01"): Recallable =
  ## getCreateEventSubscription
  ## <p>Creates an Amazon Redshift event notification subscription. This action requires an ARN (Amazon Resource Name) of an Amazon SNS topic created by either the Amazon Redshift console, the Amazon SNS console, or the Amazon SNS API. To obtain an ARN with Amazon SNS, you must create a topic in Amazon SNS and subscribe to the topic. The ARN is displayed in the SNS console.</p> <p>You can specify the source type, and lists of Amazon Redshift source IDs, event categories, and event severities. Notifications will be sent for all events you want that match those criteria. For example, you can specify source type = cluster, source ID = my-cluster-1 and mycluster2, event categories = Availability, Backup, and severity = ERROR. The subscription will only send notifications for those ERROR events in the Availability and Backup categories for the specified clusters.</p> <p>If you specify both the source type and source IDs, such as source type = cluster and source identifier = my-cluster-1, notifications will be sent for all the cluster events for my-cluster-1. If you specify a source type but do not specify a source identifier, you will receive notice of the events for the objects of that type in your AWS account. If you do not specify either the SourceType nor the SourceIdentifier, you will be notified of events generated from all Amazon Redshift sources belonging to your AWS account. You must specify a source type if you specify a source ID.</p>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   SourceType: string
  ##             : <p>The type of source that will be generating the events. For example, if you want to be notified of events generated by a cluster, you would set this parameter to cluster. If this value is not specified, events are returned for all Amazon Redshift objects in your AWS account. You must specify a source type in order to specify source IDs.</p> <p>Valid values: cluster, cluster-parameter-group, cluster-security-group, cluster-snapshot, and scheduled-action.</p>
  ##   Enabled: bool
  ##          : A boolean value; set to <code>true</code> to activate the subscription, and set to <code>false</code> to create the subscription but not activate it. 
  ##   Severity: string
  ##           : <p>Specifies the Amazon Redshift event severity to be published by the event notification subscription.</p> <p>Values: ERROR, INFO</p>
  ##   SubscriptionName: string (required)
  ##                   : <p>The name of the event subscription to be created.</p> <p>Constraints:</p> <ul> <li> <p>Cannot be null, empty, or blank.</p> </li> <li> <p>Must contain from 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   EventCategories: JArray
  ##                  : <p>Specifies the Amazon Redshift event categories to be published by the event notification subscription.</p> <p>Values: configuration, management, monitoring, security</p>
  ##   SourceIds: JArray
  ##            : <p>A list of one or more identifiers of Amazon Redshift source objects. All of the objects must be of the same type as was specified in the source type parameter. The event subscription will return only events generated by the specified objects. If not specified, then events are returned for all objects within the source type specified.</p> <p>Example: my-cluster-1, my-cluster-2</p> <p>Example: my-snapshot-20131010</p>
  ##   Action: string (required)
  ##   SnsTopicArn: string (required)
  ##              : The Amazon Resource Name (ARN) of the Amazon SNS topic used to transmit the event notifications. The ARN is created by Amazon SNS when you create a topic and subscribe to it.
  ##   Version: string (required)
  var query_613755 = newJObject()
  if Tags != nil:
    query_613755.add "Tags", Tags
  add(query_613755, "SourceType", newJString(SourceType))
  add(query_613755, "Enabled", newJBool(Enabled))
  add(query_613755, "Severity", newJString(Severity))
  add(query_613755, "SubscriptionName", newJString(SubscriptionName))
  if EventCategories != nil:
    query_613755.add "EventCategories", EventCategories
  if SourceIds != nil:
    query_613755.add "SourceIds", SourceIds
  add(query_613755, "Action", newJString(Action))
  add(query_613755, "SnsTopicArn", newJString(SnsTopicArn))
  add(query_613755, "Version", newJString(Version))
  result = call_613754.call(nil, query_613755, nil, nil, nil)

var getCreateEventSubscription* = Call_GetCreateEventSubscription_613733(
    name: "getCreateEventSubscription", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=CreateEventSubscription",
    validator: validate_GetCreateEventSubscription_613734, base: "/",
    url: url_GetCreateEventSubscription_613735,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCreateHsmClientCertificate_613797 = ref object of OpenApiRestCall_612642
proc url_PostCreateHsmClientCertificate_613799(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostCreateHsmClientCertificate_613798(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates an HSM client certificate that an Amazon Redshift cluster will use to connect to the client's HSM in order to store and retrieve the keys used to encrypt the cluster databases.</p> <p>The command returns a public key, which you must store in the HSM. In addition to creating the HSM certificate, you must create an Amazon Redshift HSM configuration that provides a cluster the information needed to store and use encryption keys in the HSM. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a> in the Amazon Redshift Cluster Management Guide.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_613800 = query.getOrDefault("Action")
  valid_613800 = validateParameter(valid_613800, JString, required = true, default = newJString(
      "CreateHsmClientCertificate"))
  if valid_613800 != nil:
    section.add "Action", valid_613800
  var valid_613801 = query.getOrDefault("Version")
  valid_613801 = validateParameter(valid_613801, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_613801 != nil:
    section.add "Version", valid_613801
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613802 = header.getOrDefault("X-Amz-Signature")
  valid_613802 = validateParameter(valid_613802, JString, required = false,
                                 default = nil)
  if valid_613802 != nil:
    section.add "X-Amz-Signature", valid_613802
  var valid_613803 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613803 = validateParameter(valid_613803, JString, required = false,
                                 default = nil)
  if valid_613803 != nil:
    section.add "X-Amz-Content-Sha256", valid_613803
  var valid_613804 = header.getOrDefault("X-Amz-Date")
  valid_613804 = validateParameter(valid_613804, JString, required = false,
                                 default = nil)
  if valid_613804 != nil:
    section.add "X-Amz-Date", valid_613804
  var valid_613805 = header.getOrDefault("X-Amz-Credential")
  valid_613805 = validateParameter(valid_613805, JString, required = false,
                                 default = nil)
  if valid_613805 != nil:
    section.add "X-Amz-Credential", valid_613805
  var valid_613806 = header.getOrDefault("X-Amz-Security-Token")
  valid_613806 = validateParameter(valid_613806, JString, required = false,
                                 default = nil)
  if valid_613806 != nil:
    section.add "X-Amz-Security-Token", valid_613806
  var valid_613807 = header.getOrDefault("X-Amz-Algorithm")
  valid_613807 = validateParameter(valid_613807, JString, required = false,
                                 default = nil)
  if valid_613807 != nil:
    section.add "X-Amz-Algorithm", valid_613807
  var valid_613808 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613808 = validateParameter(valid_613808, JString, required = false,
                                 default = nil)
  if valid_613808 != nil:
    section.add "X-Amz-SignedHeaders", valid_613808
  result.add "header", section
  ## parameters in `formData` object:
  ##   HsmClientCertificateIdentifier: JString (required)
  ##                                 : The identifier to be assigned to the new HSM client certificate that the cluster will use to connect to the HSM to use the database encryption keys.
  ##   Tags: JArray
  ##       : A list of tag instances.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `HsmClientCertificateIdentifier` field"
  var valid_613809 = formData.getOrDefault("HsmClientCertificateIdentifier")
  valid_613809 = validateParameter(valid_613809, JString, required = true,
                                 default = nil)
  if valid_613809 != nil:
    section.add "HsmClientCertificateIdentifier", valid_613809
  var valid_613810 = formData.getOrDefault("Tags")
  valid_613810 = validateParameter(valid_613810, JArray, required = false,
                                 default = nil)
  if valid_613810 != nil:
    section.add "Tags", valid_613810
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613811: Call_PostCreateHsmClientCertificate_613797; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates an HSM client certificate that an Amazon Redshift cluster will use to connect to the client's HSM in order to store and retrieve the keys used to encrypt the cluster databases.</p> <p>The command returns a public key, which you must store in the HSM. In addition to creating the HSM certificate, you must create an Amazon Redshift HSM configuration that provides a cluster the information needed to store and use encryption keys in the HSM. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a> in the Amazon Redshift Cluster Management Guide.</p>
  ## 
  let valid = call_613811.validator(path, query, header, formData, body)
  let scheme = call_613811.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613811.url(scheme.get, call_613811.host, call_613811.base,
                         call_613811.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613811, url, valid)

proc call*(call_613812: Call_PostCreateHsmClientCertificate_613797;
          HsmClientCertificateIdentifier: string;
          Action: string = "CreateHsmClientCertificate"; Tags: JsonNode = nil;
          Version: string = "2012-12-01"): Recallable =
  ## postCreateHsmClientCertificate
  ## <p>Creates an HSM client certificate that an Amazon Redshift cluster will use to connect to the client's HSM in order to store and retrieve the keys used to encrypt the cluster databases.</p> <p>The command returns a public key, which you must store in the HSM. In addition to creating the HSM certificate, you must create an Amazon Redshift HSM configuration that provides a cluster the information needed to store and use encryption keys in the HSM. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a> in the Amazon Redshift Cluster Management Guide.</p>
  ##   Action: string (required)
  ##   HsmClientCertificateIdentifier: string (required)
  ##                                 : The identifier to be assigned to the new HSM client certificate that the cluster will use to connect to the HSM to use the database encryption keys.
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Version: string (required)
  var query_613813 = newJObject()
  var formData_613814 = newJObject()
  add(query_613813, "Action", newJString(Action))
  add(formData_613814, "HsmClientCertificateIdentifier",
      newJString(HsmClientCertificateIdentifier))
  if Tags != nil:
    formData_613814.add "Tags", Tags
  add(query_613813, "Version", newJString(Version))
  result = call_613812.call(nil, query_613813, nil, formData_613814, nil)

var postCreateHsmClientCertificate* = Call_PostCreateHsmClientCertificate_613797(
    name: "postCreateHsmClientCertificate", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=CreateHsmClientCertificate",
    validator: validate_PostCreateHsmClientCertificate_613798, base: "/",
    url: url_PostCreateHsmClientCertificate_613799,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCreateHsmClientCertificate_613780 = ref object of OpenApiRestCall_612642
proc url_GetCreateHsmClientCertificate_613782(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetCreateHsmClientCertificate_613781(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates an HSM client certificate that an Amazon Redshift cluster will use to connect to the client's HSM in order to store and retrieve the keys used to encrypt the cluster databases.</p> <p>The command returns a public key, which you must store in the HSM. In addition to creating the HSM certificate, you must create an Amazon Redshift HSM configuration that provides a cluster the information needed to store and use encryption keys in the HSM. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a> in the Amazon Redshift Cluster Management Guide.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   HsmClientCertificateIdentifier: JString (required)
  ##                                 : The identifier to be assigned to the new HSM client certificate that the cluster will use to connect to the HSM to use the database encryption keys.
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `HsmClientCertificateIdentifier` field"
  var valid_613783 = query.getOrDefault("HsmClientCertificateIdentifier")
  valid_613783 = validateParameter(valid_613783, JString, required = true,
                                 default = nil)
  if valid_613783 != nil:
    section.add "HsmClientCertificateIdentifier", valid_613783
  var valid_613784 = query.getOrDefault("Tags")
  valid_613784 = validateParameter(valid_613784, JArray, required = false,
                                 default = nil)
  if valid_613784 != nil:
    section.add "Tags", valid_613784
  var valid_613785 = query.getOrDefault("Action")
  valid_613785 = validateParameter(valid_613785, JString, required = true, default = newJString(
      "CreateHsmClientCertificate"))
  if valid_613785 != nil:
    section.add "Action", valid_613785
  var valid_613786 = query.getOrDefault("Version")
  valid_613786 = validateParameter(valid_613786, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_613786 != nil:
    section.add "Version", valid_613786
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613787 = header.getOrDefault("X-Amz-Signature")
  valid_613787 = validateParameter(valid_613787, JString, required = false,
                                 default = nil)
  if valid_613787 != nil:
    section.add "X-Amz-Signature", valid_613787
  var valid_613788 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613788 = validateParameter(valid_613788, JString, required = false,
                                 default = nil)
  if valid_613788 != nil:
    section.add "X-Amz-Content-Sha256", valid_613788
  var valid_613789 = header.getOrDefault("X-Amz-Date")
  valid_613789 = validateParameter(valid_613789, JString, required = false,
                                 default = nil)
  if valid_613789 != nil:
    section.add "X-Amz-Date", valid_613789
  var valid_613790 = header.getOrDefault("X-Amz-Credential")
  valid_613790 = validateParameter(valid_613790, JString, required = false,
                                 default = nil)
  if valid_613790 != nil:
    section.add "X-Amz-Credential", valid_613790
  var valid_613791 = header.getOrDefault("X-Amz-Security-Token")
  valid_613791 = validateParameter(valid_613791, JString, required = false,
                                 default = nil)
  if valid_613791 != nil:
    section.add "X-Amz-Security-Token", valid_613791
  var valid_613792 = header.getOrDefault("X-Amz-Algorithm")
  valid_613792 = validateParameter(valid_613792, JString, required = false,
                                 default = nil)
  if valid_613792 != nil:
    section.add "X-Amz-Algorithm", valid_613792
  var valid_613793 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613793 = validateParameter(valid_613793, JString, required = false,
                                 default = nil)
  if valid_613793 != nil:
    section.add "X-Amz-SignedHeaders", valid_613793
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613794: Call_GetCreateHsmClientCertificate_613780; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates an HSM client certificate that an Amazon Redshift cluster will use to connect to the client's HSM in order to store and retrieve the keys used to encrypt the cluster databases.</p> <p>The command returns a public key, which you must store in the HSM. In addition to creating the HSM certificate, you must create an Amazon Redshift HSM configuration that provides a cluster the information needed to store and use encryption keys in the HSM. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a> in the Amazon Redshift Cluster Management Guide.</p>
  ## 
  let valid = call_613794.validator(path, query, header, formData, body)
  let scheme = call_613794.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613794.url(scheme.get, call_613794.host, call_613794.base,
                         call_613794.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613794, url, valid)

proc call*(call_613795: Call_GetCreateHsmClientCertificate_613780;
          HsmClientCertificateIdentifier: string; Tags: JsonNode = nil;
          Action: string = "CreateHsmClientCertificate";
          Version: string = "2012-12-01"): Recallable =
  ## getCreateHsmClientCertificate
  ## <p>Creates an HSM client certificate that an Amazon Redshift cluster will use to connect to the client's HSM in order to store and retrieve the keys used to encrypt the cluster databases.</p> <p>The command returns a public key, which you must store in the HSM. In addition to creating the HSM certificate, you must create an Amazon Redshift HSM configuration that provides a cluster the information needed to store and use encryption keys in the HSM. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a> in the Amazon Redshift Cluster Management Guide.</p>
  ##   HsmClientCertificateIdentifier: string (required)
  ##                                 : The identifier to be assigned to the new HSM client certificate that the cluster will use to connect to the HSM to use the database encryption keys.
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_613796 = newJObject()
  add(query_613796, "HsmClientCertificateIdentifier",
      newJString(HsmClientCertificateIdentifier))
  if Tags != nil:
    query_613796.add "Tags", Tags
  add(query_613796, "Action", newJString(Action))
  add(query_613796, "Version", newJString(Version))
  result = call_613795.call(nil, query_613796, nil, nil, nil)

var getCreateHsmClientCertificate* = Call_GetCreateHsmClientCertificate_613780(
    name: "getCreateHsmClientCertificate", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=CreateHsmClientCertificate",
    validator: validate_GetCreateHsmClientCertificate_613781, base: "/",
    url: url_GetCreateHsmClientCertificate_613782,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCreateHsmConfiguration_613837 = ref object of OpenApiRestCall_612642
proc url_PostCreateHsmConfiguration_613839(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostCreateHsmConfiguration_613838(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates an HSM configuration that contains the information required by an Amazon Redshift cluster to store and use database encryption keys in a Hardware Security Module (HSM). After creating the HSM configuration, you can specify it as a parameter when creating a cluster. The cluster will then store its encryption keys in the HSM.</p> <p>In addition to creating an HSM configuration, you must also create an HSM client certificate. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a> in the Amazon Redshift Cluster Management Guide.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_613840 = query.getOrDefault("Action")
  valid_613840 = validateParameter(valid_613840, JString, required = true,
                                 default = newJString("CreateHsmConfiguration"))
  if valid_613840 != nil:
    section.add "Action", valid_613840
  var valid_613841 = query.getOrDefault("Version")
  valid_613841 = validateParameter(valid_613841, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_613841 != nil:
    section.add "Version", valid_613841
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613842 = header.getOrDefault("X-Amz-Signature")
  valid_613842 = validateParameter(valid_613842, JString, required = false,
                                 default = nil)
  if valid_613842 != nil:
    section.add "X-Amz-Signature", valid_613842
  var valid_613843 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613843 = validateParameter(valid_613843, JString, required = false,
                                 default = nil)
  if valid_613843 != nil:
    section.add "X-Amz-Content-Sha256", valid_613843
  var valid_613844 = header.getOrDefault("X-Amz-Date")
  valid_613844 = validateParameter(valid_613844, JString, required = false,
                                 default = nil)
  if valid_613844 != nil:
    section.add "X-Amz-Date", valid_613844
  var valid_613845 = header.getOrDefault("X-Amz-Credential")
  valid_613845 = validateParameter(valid_613845, JString, required = false,
                                 default = nil)
  if valid_613845 != nil:
    section.add "X-Amz-Credential", valid_613845
  var valid_613846 = header.getOrDefault("X-Amz-Security-Token")
  valid_613846 = validateParameter(valid_613846, JString, required = false,
                                 default = nil)
  if valid_613846 != nil:
    section.add "X-Amz-Security-Token", valid_613846
  var valid_613847 = header.getOrDefault("X-Amz-Algorithm")
  valid_613847 = validateParameter(valid_613847, JString, required = false,
                                 default = nil)
  if valid_613847 != nil:
    section.add "X-Amz-Algorithm", valid_613847
  var valid_613848 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613848 = validateParameter(valid_613848, JString, required = false,
                                 default = nil)
  if valid_613848 != nil:
    section.add "X-Amz-SignedHeaders", valid_613848
  result.add "header", section
  ## parameters in `formData` object:
  ##   Description: JString (required)
  ##              : A text description of the HSM configuration to be created.
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   HsmPartitionPassword: JString (required)
  ##                       : The password required to access the HSM partition.
  ##   HsmPartitionName: JString (required)
  ##                   : The name of the partition in the HSM where the Amazon Redshift clusters will store their database encryption keys.
  ##   HsmServerPublicCertificate: JString (required)
  ##                             : The HSMs public certificate file. When using Cloud HSM, the file name is server.pem.
  ##   HsmConfigurationIdentifier: JString (required)
  ##                             : The identifier to be assigned to the new Amazon Redshift HSM configuration.
  ##   HsmIpAddress: JString (required)
  ##               : The IP address that the Amazon Redshift cluster must use to access the HSM.
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `Description` field"
  var valid_613849 = formData.getOrDefault("Description")
  valid_613849 = validateParameter(valid_613849, JString, required = true,
                                 default = nil)
  if valid_613849 != nil:
    section.add "Description", valid_613849
  var valid_613850 = formData.getOrDefault("Tags")
  valid_613850 = validateParameter(valid_613850, JArray, required = false,
                                 default = nil)
  if valid_613850 != nil:
    section.add "Tags", valid_613850
  var valid_613851 = formData.getOrDefault("HsmPartitionPassword")
  valid_613851 = validateParameter(valid_613851, JString, required = true,
                                 default = nil)
  if valid_613851 != nil:
    section.add "HsmPartitionPassword", valid_613851
  var valid_613852 = formData.getOrDefault("HsmPartitionName")
  valid_613852 = validateParameter(valid_613852, JString, required = true,
                                 default = nil)
  if valid_613852 != nil:
    section.add "HsmPartitionName", valid_613852
  var valid_613853 = formData.getOrDefault("HsmServerPublicCertificate")
  valid_613853 = validateParameter(valid_613853, JString, required = true,
                                 default = nil)
  if valid_613853 != nil:
    section.add "HsmServerPublicCertificate", valid_613853
  var valid_613854 = formData.getOrDefault("HsmConfigurationIdentifier")
  valid_613854 = validateParameter(valid_613854, JString, required = true,
                                 default = nil)
  if valid_613854 != nil:
    section.add "HsmConfigurationIdentifier", valid_613854
  var valid_613855 = formData.getOrDefault("HsmIpAddress")
  valid_613855 = validateParameter(valid_613855, JString, required = true,
                                 default = nil)
  if valid_613855 != nil:
    section.add "HsmIpAddress", valid_613855
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613856: Call_PostCreateHsmConfiguration_613837; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates an HSM configuration that contains the information required by an Amazon Redshift cluster to store and use database encryption keys in a Hardware Security Module (HSM). After creating the HSM configuration, you can specify it as a parameter when creating a cluster. The cluster will then store its encryption keys in the HSM.</p> <p>In addition to creating an HSM configuration, you must also create an HSM client certificate. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a> in the Amazon Redshift Cluster Management Guide.</p>
  ## 
  let valid = call_613856.validator(path, query, header, formData, body)
  let scheme = call_613856.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613856.url(scheme.get, call_613856.host, call_613856.base,
                         call_613856.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613856, url, valid)

proc call*(call_613857: Call_PostCreateHsmConfiguration_613837;
          Description: string; HsmPartitionPassword: string;
          HsmPartitionName: string; HsmServerPublicCertificate: string;
          HsmConfigurationIdentifier: string; HsmIpAddress: string;
          Action: string = "CreateHsmConfiguration"; Tags: JsonNode = nil;
          Version: string = "2012-12-01"): Recallable =
  ## postCreateHsmConfiguration
  ## <p>Creates an HSM configuration that contains the information required by an Amazon Redshift cluster to store and use database encryption keys in a Hardware Security Module (HSM). After creating the HSM configuration, you can specify it as a parameter when creating a cluster. The cluster will then store its encryption keys in the HSM.</p> <p>In addition to creating an HSM configuration, you must also create an HSM client certificate. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a> in the Amazon Redshift Cluster Management Guide.</p>
  ##   Description: string (required)
  ##              : A text description of the HSM configuration to be created.
  ##   Action: string (required)
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   HsmPartitionPassword: string (required)
  ##                       : The password required to access the HSM partition.
  ##   Version: string (required)
  ##   HsmPartitionName: string (required)
  ##                   : The name of the partition in the HSM where the Amazon Redshift clusters will store their database encryption keys.
  ##   HsmServerPublicCertificate: string (required)
  ##                             : The HSMs public certificate file. When using Cloud HSM, the file name is server.pem.
  ##   HsmConfigurationIdentifier: string (required)
  ##                             : The identifier to be assigned to the new Amazon Redshift HSM configuration.
  ##   HsmIpAddress: string (required)
  ##               : The IP address that the Amazon Redshift cluster must use to access the HSM.
  var query_613858 = newJObject()
  var formData_613859 = newJObject()
  add(formData_613859, "Description", newJString(Description))
  add(query_613858, "Action", newJString(Action))
  if Tags != nil:
    formData_613859.add "Tags", Tags
  add(formData_613859, "HsmPartitionPassword", newJString(HsmPartitionPassword))
  add(query_613858, "Version", newJString(Version))
  add(formData_613859, "HsmPartitionName", newJString(HsmPartitionName))
  add(formData_613859, "HsmServerPublicCertificate",
      newJString(HsmServerPublicCertificate))
  add(formData_613859, "HsmConfigurationIdentifier",
      newJString(HsmConfigurationIdentifier))
  add(formData_613859, "HsmIpAddress", newJString(HsmIpAddress))
  result = call_613857.call(nil, query_613858, nil, formData_613859, nil)

var postCreateHsmConfiguration* = Call_PostCreateHsmConfiguration_613837(
    name: "postCreateHsmConfiguration", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=CreateHsmConfiguration",
    validator: validate_PostCreateHsmConfiguration_613838, base: "/",
    url: url_PostCreateHsmConfiguration_613839,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCreateHsmConfiguration_613815 = ref object of OpenApiRestCall_612642
proc url_GetCreateHsmConfiguration_613817(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetCreateHsmConfiguration_613816(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates an HSM configuration that contains the information required by an Amazon Redshift cluster to store and use database encryption keys in a Hardware Security Module (HSM). After creating the HSM configuration, you can specify it as a parameter when creating a cluster. The cluster will then store its encryption keys in the HSM.</p> <p>In addition to creating an HSM configuration, you must also create an HSM client certificate. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a> in the Amazon Redshift Cluster Management Guide.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   HsmIpAddress: JString (required)
  ##               : The IP address that the Amazon Redshift cluster must use to access the HSM.
  ##   HsmPartitionPassword: JString (required)
  ##                       : The password required to access the HSM partition.
  ##   HsmServerPublicCertificate: JString (required)
  ##                             : The HSMs public certificate file. When using Cloud HSM, the file name is server.pem.
  ##   HsmPartitionName: JString (required)
  ##                   : The name of the partition in the HSM where the Amazon Redshift clusters will store their database encryption keys.
  ##   Action: JString (required)
  ##   Description: JString (required)
  ##              : A text description of the HSM configuration to be created.
  ##   HsmConfigurationIdentifier: JString (required)
  ##                             : The identifier to be assigned to the new Amazon Redshift HSM configuration.
  ##   Version: JString (required)
  section = newJObject()
  var valid_613818 = query.getOrDefault("Tags")
  valid_613818 = validateParameter(valid_613818, JArray, required = false,
                                 default = nil)
  if valid_613818 != nil:
    section.add "Tags", valid_613818
  assert query != nil,
        "query argument is necessary due to required `HsmIpAddress` field"
  var valid_613819 = query.getOrDefault("HsmIpAddress")
  valid_613819 = validateParameter(valid_613819, JString, required = true,
                                 default = nil)
  if valid_613819 != nil:
    section.add "HsmIpAddress", valid_613819
  var valid_613820 = query.getOrDefault("HsmPartitionPassword")
  valid_613820 = validateParameter(valid_613820, JString, required = true,
                                 default = nil)
  if valid_613820 != nil:
    section.add "HsmPartitionPassword", valid_613820
  var valid_613821 = query.getOrDefault("HsmServerPublicCertificate")
  valid_613821 = validateParameter(valid_613821, JString, required = true,
                                 default = nil)
  if valid_613821 != nil:
    section.add "HsmServerPublicCertificate", valid_613821
  var valid_613822 = query.getOrDefault("HsmPartitionName")
  valid_613822 = validateParameter(valid_613822, JString, required = true,
                                 default = nil)
  if valid_613822 != nil:
    section.add "HsmPartitionName", valid_613822
  var valid_613823 = query.getOrDefault("Action")
  valid_613823 = validateParameter(valid_613823, JString, required = true,
                                 default = newJString("CreateHsmConfiguration"))
  if valid_613823 != nil:
    section.add "Action", valid_613823
  var valid_613824 = query.getOrDefault("Description")
  valid_613824 = validateParameter(valid_613824, JString, required = true,
                                 default = nil)
  if valid_613824 != nil:
    section.add "Description", valid_613824
  var valid_613825 = query.getOrDefault("HsmConfigurationIdentifier")
  valid_613825 = validateParameter(valid_613825, JString, required = true,
                                 default = nil)
  if valid_613825 != nil:
    section.add "HsmConfigurationIdentifier", valid_613825
  var valid_613826 = query.getOrDefault("Version")
  valid_613826 = validateParameter(valid_613826, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_613826 != nil:
    section.add "Version", valid_613826
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613827 = header.getOrDefault("X-Amz-Signature")
  valid_613827 = validateParameter(valid_613827, JString, required = false,
                                 default = nil)
  if valid_613827 != nil:
    section.add "X-Amz-Signature", valid_613827
  var valid_613828 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613828 = validateParameter(valid_613828, JString, required = false,
                                 default = nil)
  if valid_613828 != nil:
    section.add "X-Amz-Content-Sha256", valid_613828
  var valid_613829 = header.getOrDefault("X-Amz-Date")
  valid_613829 = validateParameter(valid_613829, JString, required = false,
                                 default = nil)
  if valid_613829 != nil:
    section.add "X-Amz-Date", valid_613829
  var valid_613830 = header.getOrDefault("X-Amz-Credential")
  valid_613830 = validateParameter(valid_613830, JString, required = false,
                                 default = nil)
  if valid_613830 != nil:
    section.add "X-Amz-Credential", valid_613830
  var valid_613831 = header.getOrDefault("X-Amz-Security-Token")
  valid_613831 = validateParameter(valid_613831, JString, required = false,
                                 default = nil)
  if valid_613831 != nil:
    section.add "X-Amz-Security-Token", valid_613831
  var valid_613832 = header.getOrDefault("X-Amz-Algorithm")
  valid_613832 = validateParameter(valid_613832, JString, required = false,
                                 default = nil)
  if valid_613832 != nil:
    section.add "X-Amz-Algorithm", valid_613832
  var valid_613833 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613833 = validateParameter(valid_613833, JString, required = false,
                                 default = nil)
  if valid_613833 != nil:
    section.add "X-Amz-SignedHeaders", valid_613833
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613834: Call_GetCreateHsmConfiguration_613815; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates an HSM configuration that contains the information required by an Amazon Redshift cluster to store and use database encryption keys in a Hardware Security Module (HSM). After creating the HSM configuration, you can specify it as a parameter when creating a cluster. The cluster will then store its encryption keys in the HSM.</p> <p>In addition to creating an HSM configuration, you must also create an HSM client certificate. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a> in the Amazon Redshift Cluster Management Guide.</p>
  ## 
  let valid = call_613834.validator(path, query, header, formData, body)
  let scheme = call_613834.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613834.url(scheme.get, call_613834.host, call_613834.base,
                         call_613834.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613834, url, valid)

proc call*(call_613835: Call_GetCreateHsmConfiguration_613815;
          HsmIpAddress: string; HsmPartitionPassword: string;
          HsmServerPublicCertificate: string; HsmPartitionName: string;
          Description: string; HsmConfigurationIdentifier: string;
          Tags: JsonNode = nil; Action: string = "CreateHsmConfiguration";
          Version: string = "2012-12-01"): Recallable =
  ## getCreateHsmConfiguration
  ## <p>Creates an HSM configuration that contains the information required by an Amazon Redshift cluster to store and use database encryption keys in a Hardware Security Module (HSM). After creating the HSM configuration, you can specify it as a parameter when creating a cluster. The cluster will then store its encryption keys in the HSM.</p> <p>In addition to creating an HSM configuration, you must also create an HSM client certificate. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a> in the Amazon Redshift Cluster Management Guide.</p>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   HsmIpAddress: string (required)
  ##               : The IP address that the Amazon Redshift cluster must use to access the HSM.
  ##   HsmPartitionPassword: string (required)
  ##                       : The password required to access the HSM partition.
  ##   HsmServerPublicCertificate: string (required)
  ##                             : The HSMs public certificate file. When using Cloud HSM, the file name is server.pem.
  ##   HsmPartitionName: string (required)
  ##                   : The name of the partition in the HSM where the Amazon Redshift clusters will store their database encryption keys.
  ##   Action: string (required)
  ##   Description: string (required)
  ##              : A text description of the HSM configuration to be created.
  ##   HsmConfigurationIdentifier: string (required)
  ##                             : The identifier to be assigned to the new Amazon Redshift HSM configuration.
  ##   Version: string (required)
  var query_613836 = newJObject()
  if Tags != nil:
    query_613836.add "Tags", Tags
  add(query_613836, "HsmIpAddress", newJString(HsmIpAddress))
  add(query_613836, "HsmPartitionPassword", newJString(HsmPartitionPassword))
  add(query_613836, "HsmServerPublicCertificate",
      newJString(HsmServerPublicCertificate))
  add(query_613836, "HsmPartitionName", newJString(HsmPartitionName))
  add(query_613836, "Action", newJString(Action))
  add(query_613836, "Description", newJString(Description))
  add(query_613836, "HsmConfigurationIdentifier",
      newJString(HsmConfigurationIdentifier))
  add(query_613836, "Version", newJString(Version))
  result = call_613835.call(nil, query_613836, nil, nil, nil)

var getCreateHsmConfiguration* = Call_GetCreateHsmConfiguration_613815(
    name: "getCreateHsmConfiguration", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=CreateHsmConfiguration",
    validator: validate_GetCreateHsmConfiguration_613816, base: "/",
    url: url_GetCreateHsmConfiguration_613817,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCreateScheduledAction_613883 = ref object of OpenApiRestCall_612642
proc url_PostCreateScheduledAction_613885(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostCreateScheduledAction_613884(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Creates a scheduled action. A scheduled action contains a schedule and an Amazon Redshift API action. For example, you can create a schedule of when to run the <code>ResizeCluster</code> API operation. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_613886 = query.getOrDefault("Action")
  valid_613886 = validateParameter(valid_613886, JString, required = true,
                                 default = newJString("CreateScheduledAction"))
  if valid_613886 != nil:
    section.add "Action", valid_613886
  var valid_613887 = query.getOrDefault("Version")
  valid_613887 = validateParameter(valid_613887, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_613887 != nil:
    section.add "Version", valid_613887
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613888 = header.getOrDefault("X-Amz-Signature")
  valid_613888 = validateParameter(valid_613888, JString, required = false,
                                 default = nil)
  if valid_613888 != nil:
    section.add "X-Amz-Signature", valid_613888
  var valid_613889 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613889 = validateParameter(valid_613889, JString, required = false,
                                 default = nil)
  if valid_613889 != nil:
    section.add "X-Amz-Content-Sha256", valid_613889
  var valid_613890 = header.getOrDefault("X-Amz-Date")
  valid_613890 = validateParameter(valid_613890, JString, required = false,
                                 default = nil)
  if valid_613890 != nil:
    section.add "X-Amz-Date", valid_613890
  var valid_613891 = header.getOrDefault("X-Amz-Credential")
  valid_613891 = validateParameter(valid_613891, JString, required = false,
                                 default = nil)
  if valid_613891 != nil:
    section.add "X-Amz-Credential", valid_613891
  var valid_613892 = header.getOrDefault("X-Amz-Security-Token")
  valid_613892 = validateParameter(valid_613892, JString, required = false,
                                 default = nil)
  if valid_613892 != nil:
    section.add "X-Amz-Security-Token", valid_613892
  var valid_613893 = header.getOrDefault("X-Amz-Algorithm")
  valid_613893 = validateParameter(valid_613893, JString, required = false,
                                 default = nil)
  if valid_613893 != nil:
    section.add "X-Amz-Algorithm", valid_613893
  var valid_613894 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613894 = validateParameter(valid_613894, JString, required = false,
                                 default = nil)
  if valid_613894 != nil:
    section.add "X-Amz-SignedHeaders", valid_613894
  result.add "header", section
  ## parameters in `formData` object:
  ##   Enable: JBool
  ##         : If true, the schedule is enabled. If false, the scheduled action does not trigger. For more information about <code>state</code> of the scheduled action, see <a>ScheduledAction</a>. 
  ##   TargetAction.ResizeCluster: JString
  ##                             : The action type that specifies an Amazon Redshift API operation that is supported by the Amazon Redshift scheduler. 
  ## An action that runs a <code>ResizeCluster</code> API operation. 
  ##   ScheduledActionName: JString (required)
  ##                      : The name of the scheduled action. The name must be unique within an account. For more information about this parameter, see <a>ScheduledAction</a>. 
  ##   ScheduledActionDescription: JString
  ##                             : The description of the scheduled action. 
  ##   Schedule: JString (required)
  ##           : The schedule in <code>at( )</code> or <code>cron( )</code> format. For more information about this parameter, see <a>ScheduledAction</a>.
  ##   EndTime: JString
  ##          : The end time in UTC of the scheduled action. After this time, the scheduled action does not trigger. For more information about this parameter, see <a>ScheduledAction</a>. 
  ##   StartTime: JString
  ##            : The start time in UTC of the scheduled action. Before this time, the scheduled action does not trigger. For more information about this parameter, see <a>ScheduledAction</a>.
  ##   IamRole: JString (required)
  ##          : The IAM role to assume to run the target action. For more information about this parameter, see <a>ScheduledAction</a>. 
  section = newJObject()
  var valid_613895 = formData.getOrDefault("Enable")
  valid_613895 = validateParameter(valid_613895, JBool, required = false, default = nil)
  if valid_613895 != nil:
    section.add "Enable", valid_613895
  var valid_613896 = formData.getOrDefault("TargetAction.ResizeCluster")
  valid_613896 = validateParameter(valid_613896, JString, required = false,
                                 default = nil)
  if valid_613896 != nil:
    section.add "TargetAction.ResizeCluster", valid_613896
  assert formData != nil, "formData argument is necessary due to required `ScheduledActionName` field"
  var valid_613897 = formData.getOrDefault("ScheduledActionName")
  valid_613897 = validateParameter(valid_613897, JString, required = true,
                                 default = nil)
  if valid_613897 != nil:
    section.add "ScheduledActionName", valid_613897
  var valid_613898 = formData.getOrDefault("ScheduledActionDescription")
  valid_613898 = validateParameter(valid_613898, JString, required = false,
                                 default = nil)
  if valid_613898 != nil:
    section.add "ScheduledActionDescription", valid_613898
  var valid_613899 = formData.getOrDefault("Schedule")
  valid_613899 = validateParameter(valid_613899, JString, required = true,
                                 default = nil)
  if valid_613899 != nil:
    section.add "Schedule", valid_613899
  var valid_613900 = formData.getOrDefault("EndTime")
  valid_613900 = validateParameter(valid_613900, JString, required = false,
                                 default = nil)
  if valid_613900 != nil:
    section.add "EndTime", valid_613900
  var valid_613901 = formData.getOrDefault("StartTime")
  valid_613901 = validateParameter(valid_613901, JString, required = false,
                                 default = nil)
  if valid_613901 != nil:
    section.add "StartTime", valid_613901
  var valid_613902 = formData.getOrDefault("IamRole")
  valid_613902 = validateParameter(valid_613902, JString, required = true,
                                 default = nil)
  if valid_613902 != nil:
    section.add "IamRole", valid_613902
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613903: Call_PostCreateScheduledAction_613883; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a scheduled action. A scheduled action contains a schedule and an Amazon Redshift API action. For example, you can create a schedule of when to run the <code>ResizeCluster</code> API operation. 
  ## 
  let valid = call_613903.validator(path, query, header, formData, body)
  let scheme = call_613903.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613903.url(scheme.get, call_613903.host, call_613903.base,
                         call_613903.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613903, url, valid)

proc call*(call_613904: Call_PostCreateScheduledAction_613883;
          ScheduledActionName: string; Schedule: string; IamRole: string;
          Enable: bool = false; TargetActionResizeCluster: string = "";
          ScheduledActionDescription: string = ""; EndTime: string = "";
          StartTime: string = ""; Action: string = "CreateScheduledAction";
          Version: string = "2012-12-01"): Recallable =
  ## postCreateScheduledAction
  ## Creates a scheduled action. A scheduled action contains a schedule and an Amazon Redshift API action. For example, you can create a schedule of when to run the <code>ResizeCluster</code> API operation. 
  ##   Enable: bool
  ##         : If true, the schedule is enabled. If false, the scheduled action does not trigger. For more information about <code>state</code> of the scheduled action, see <a>ScheduledAction</a>. 
  ##   TargetActionResizeCluster: string
  ##                            : The action type that specifies an Amazon Redshift API operation that is supported by the Amazon Redshift scheduler. 
  ## An action that runs a <code>ResizeCluster</code> API operation. 
  ##   ScheduledActionName: string (required)
  ##                      : The name of the scheduled action. The name must be unique within an account. For more information about this parameter, see <a>ScheduledAction</a>. 
  ##   ScheduledActionDescription: string
  ##                             : The description of the scheduled action. 
  ##   Schedule: string (required)
  ##           : The schedule in <code>at( )</code> or <code>cron( )</code> format. For more information about this parameter, see <a>ScheduledAction</a>.
  ##   EndTime: string
  ##          : The end time in UTC of the scheduled action. After this time, the scheduled action does not trigger. For more information about this parameter, see <a>ScheduledAction</a>. 
  ##   StartTime: string
  ##            : The start time in UTC of the scheduled action. Before this time, the scheduled action does not trigger. For more information about this parameter, see <a>ScheduledAction</a>.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   IamRole: string (required)
  ##          : The IAM role to assume to run the target action. For more information about this parameter, see <a>ScheduledAction</a>. 
  var query_613905 = newJObject()
  var formData_613906 = newJObject()
  add(formData_613906, "Enable", newJBool(Enable))
  add(formData_613906, "TargetAction.ResizeCluster",
      newJString(TargetActionResizeCluster))
  add(formData_613906, "ScheduledActionName", newJString(ScheduledActionName))
  add(formData_613906, "ScheduledActionDescription",
      newJString(ScheduledActionDescription))
  add(formData_613906, "Schedule", newJString(Schedule))
  add(formData_613906, "EndTime", newJString(EndTime))
  add(formData_613906, "StartTime", newJString(StartTime))
  add(query_613905, "Action", newJString(Action))
  add(query_613905, "Version", newJString(Version))
  add(formData_613906, "IamRole", newJString(IamRole))
  result = call_613904.call(nil, query_613905, nil, formData_613906, nil)

var postCreateScheduledAction* = Call_PostCreateScheduledAction_613883(
    name: "postCreateScheduledAction", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=CreateScheduledAction",
    validator: validate_PostCreateScheduledAction_613884, base: "/",
    url: url_PostCreateScheduledAction_613885,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCreateScheduledAction_613860 = ref object of OpenApiRestCall_612642
proc url_GetCreateScheduledAction_613862(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetCreateScheduledAction_613861(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Creates a scheduled action. A scheduled action contains a schedule and an Amazon Redshift API action. For example, you can create a schedule of when to run the <code>ResizeCluster</code> API operation. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Schedule: JString (required)
  ##           : The schedule in <code>at( )</code> or <code>cron( )</code> format. For more information about this parameter, see <a>ScheduledAction</a>.
  ##   Enable: JBool
  ##         : If true, the schedule is enabled. If false, the scheduled action does not trigger. For more information about <code>state</code> of the scheduled action, see <a>ScheduledAction</a>. 
  ##   ScheduledActionName: JString (required)
  ##                      : The name of the scheduled action. The name must be unique within an account. For more information about this parameter, see <a>ScheduledAction</a>. 
  ##   IamRole: JString (required)
  ##          : The IAM role to assume to run the target action. For more information about this parameter, see <a>ScheduledAction</a>. 
  ##   TargetAction.ResizeCluster: JString
  ##                             : The action type that specifies an Amazon Redshift API operation that is supported by the Amazon Redshift scheduler. 
  ## An action that runs a <code>ResizeCluster</code> API operation. 
  ##   ScheduledActionDescription: JString
  ##                             : The description of the scheduled action. 
  ##   Action: JString (required)
  ##   StartTime: JString
  ##            : The start time in UTC of the scheduled action. Before this time, the scheduled action does not trigger. For more information about this parameter, see <a>ScheduledAction</a>.
  ##   EndTime: JString
  ##          : The end time in UTC of the scheduled action. After this time, the scheduled action does not trigger. For more information about this parameter, see <a>ScheduledAction</a>. 
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `Schedule` field"
  var valid_613863 = query.getOrDefault("Schedule")
  valid_613863 = validateParameter(valid_613863, JString, required = true,
                                 default = nil)
  if valid_613863 != nil:
    section.add "Schedule", valid_613863
  var valid_613864 = query.getOrDefault("Enable")
  valid_613864 = validateParameter(valid_613864, JBool, required = false, default = nil)
  if valid_613864 != nil:
    section.add "Enable", valid_613864
  var valid_613865 = query.getOrDefault("ScheduledActionName")
  valid_613865 = validateParameter(valid_613865, JString, required = true,
                                 default = nil)
  if valid_613865 != nil:
    section.add "ScheduledActionName", valid_613865
  var valid_613866 = query.getOrDefault("IamRole")
  valid_613866 = validateParameter(valid_613866, JString, required = true,
                                 default = nil)
  if valid_613866 != nil:
    section.add "IamRole", valid_613866
  var valid_613867 = query.getOrDefault("TargetAction.ResizeCluster")
  valid_613867 = validateParameter(valid_613867, JString, required = false,
                                 default = nil)
  if valid_613867 != nil:
    section.add "TargetAction.ResizeCluster", valid_613867
  var valid_613868 = query.getOrDefault("ScheduledActionDescription")
  valid_613868 = validateParameter(valid_613868, JString, required = false,
                                 default = nil)
  if valid_613868 != nil:
    section.add "ScheduledActionDescription", valid_613868
  var valid_613869 = query.getOrDefault("Action")
  valid_613869 = validateParameter(valid_613869, JString, required = true,
                                 default = newJString("CreateScheduledAction"))
  if valid_613869 != nil:
    section.add "Action", valid_613869
  var valid_613870 = query.getOrDefault("StartTime")
  valid_613870 = validateParameter(valid_613870, JString, required = false,
                                 default = nil)
  if valid_613870 != nil:
    section.add "StartTime", valid_613870
  var valid_613871 = query.getOrDefault("EndTime")
  valid_613871 = validateParameter(valid_613871, JString, required = false,
                                 default = nil)
  if valid_613871 != nil:
    section.add "EndTime", valid_613871
  var valid_613872 = query.getOrDefault("Version")
  valid_613872 = validateParameter(valid_613872, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_613872 != nil:
    section.add "Version", valid_613872
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613873 = header.getOrDefault("X-Amz-Signature")
  valid_613873 = validateParameter(valid_613873, JString, required = false,
                                 default = nil)
  if valid_613873 != nil:
    section.add "X-Amz-Signature", valid_613873
  var valid_613874 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613874 = validateParameter(valid_613874, JString, required = false,
                                 default = nil)
  if valid_613874 != nil:
    section.add "X-Amz-Content-Sha256", valid_613874
  var valid_613875 = header.getOrDefault("X-Amz-Date")
  valid_613875 = validateParameter(valid_613875, JString, required = false,
                                 default = nil)
  if valid_613875 != nil:
    section.add "X-Amz-Date", valid_613875
  var valid_613876 = header.getOrDefault("X-Amz-Credential")
  valid_613876 = validateParameter(valid_613876, JString, required = false,
                                 default = nil)
  if valid_613876 != nil:
    section.add "X-Amz-Credential", valid_613876
  var valid_613877 = header.getOrDefault("X-Amz-Security-Token")
  valid_613877 = validateParameter(valid_613877, JString, required = false,
                                 default = nil)
  if valid_613877 != nil:
    section.add "X-Amz-Security-Token", valid_613877
  var valid_613878 = header.getOrDefault("X-Amz-Algorithm")
  valid_613878 = validateParameter(valid_613878, JString, required = false,
                                 default = nil)
  if valid_613878 != nil:
    section.add "X-Amz-Algorithm", valid_613878
  var valid_613879 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613879 = validateParameter(valid_613879, JString, required = false,
                                 default = nil)
  if valid_613879 != nil:
    section.add "X-Amz-SignedHeaders", valid_613879
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613880: Call_GetCreateScheduledAction_613860; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a scheduled action. A scheduled action contains a schedule and an Amazon Redshift API action. For example, you can create a schedule of when to run the <code>ResizeCluster</code> API operation. 
  ## 
  let valid = call_613880.validator(path, query, header, formData, body)
  let scheme = call_613880.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613880.url(scheme.get, call_613880.host, call_613880.base,
                         call_613880.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613880, url, valid)

proc call*(call_613881: Call_GetCreateScheduledAction_613860; Schedule: string;
          ScheduledActionName: string; IamRole: string; Enable: bool = false;
          TargetActionResizeCluster: string = "";
          ScheduledActionDescription: string = "";
          Action: string = "CreateScheduledAction"; StartTime: string = "";
          EndTime: string = ""; Version: string = "2012-12-01"): Recallable =
  ## getCreateScheduledAction
  ## Creates a scheduled action. A scheduled action contains a schedule and an Amazon Redshift API action. For example, you can create a schedule of when to run the <code>ResizeCluster</code> API operation. 
  ##   Schedule: string (required)
  ##           : The schedule in <code>at( )</code> or <code>cron( )</code> format. For more information about this parameter, see <a>ScheduledAction</a>.
  ##   Enable: bool
  ##         : If true, the schedule is enabled. If false, the scheduled action does not trigger. For more information about <code>state</code> of the scheduled action, see <a>ScheduledAction</a>. 
  ##   ScheduledActionName: string (required)
  ##                      : The name of the scheduled action. The name must be unique within an account. For more information about this parameter, see <a>ScheduledAction</a>. 
  ##   IamRole: string (required)
  ##          : The IAM role to assume to run the target action. For more information about this parameter, see <a>ScheduledAction</a>. 
  ##   TargetActionResizeCluster: string
  ##                            : The action type that specifies an Amazon Redshift API operation that is supported by the Amazon Redshift scheduler. 
  ## An action that runs a <code>ResizeCluster</code> API operation. 
  ##   ScheduledActionDescription: string
  ##                             : The description of the scheduled action. 
  ##   Action: string (required)
  ##   StartTime: string
  ##            : The start time in UTC of the scheduled action. Before this time, the scheduled action does not trigger. For more information about this parameter, see <a>ScheduledAction</a>.
  ##   EndTime: string
  ##          : The end time in UTC of the scheduled action. After this time, the scheduled action does not trigger. For more information about this parameter, see <a>ScheduledAction</a>. 
  ##   Version: string (required)
  var query_613882 = newJObject()
  add(query_613882, "Schedule", newJString(Schedule))
  add(query_613882, "Enable", newJBool(Enable))
  add(query_613882, "ScheduledActionName", newJString(ScheduledActionName))
  add(query_613882, "IamRole", newJString(IamRole))
  add(query_613882, "TargetAction.ResizeCluster",
      newJString(TargetActionResizeCluster))
  add(query_613882, "ScheduledActionDescription",
      newJString(ScheduledActionDescription))
  add(query_613882, "Action", newJString(Action))
  add(query_613882, "StartTime", newJString(StartTime))
  add(query_613882, "EndTime", newJString(EndTime))
  add(query_613882, "Version", newJString(Version))
  result = call_613881.call(nil, query_613882, nil, nil, nil)

var getCreateScheduledAction* = Call_GetCreateScheduledAction_613860(
    name: "getCreateScheduledAction", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=CreateScheduledAction",
    validator: validate_GetCreateScheduledAction_613861, base: "/",
    url: url_GetCreateScheduledAction_613862, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCreateSnapshotCopyGrant_613925 = ref object of OpenApiRestCall_612642
proc url_PostCreateSnapshotCopyGrant_613927(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostCreateSnapshotCopyGrant_613926(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a snapshot copy grant that permits Amazon Redshift to use a customer master key (CMK) from AWS Key Management Service (AWS KMS) to encrypt copied snapshots in a destination region.</p> <p> For more information about managing snapshot copy grants, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_613928 = query.getOrDefault("Action")
  valid_613928 = validateParameter(valid_613928, JString, required = true, default = newJString(
      "CreateSnapshotCopyGrant"))
  if valid_613928 != nil:
    section.add "Action", valid_613928
  var valid_613929 = query.getOrDefault("Version")
  valid_613929 = validateParameter(valid_613929, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_613929 != nil:
    section.add "Version", valid_613929
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613930 = header.getOrDefault("X-Amz-Signature")
  valid_613930 = validateParameter(valid_613930, JString, required = false,
                                 default = nil)
  if valid_613930 != nil:
    section.add "X-Amz-Signature", valid_613930
  var valid_613931 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613931 = validateParameter(valid_613931, JString, required = false,
                                 default = nil)
  if valid_613931 != nil:
    section.add "X-Amz-Content-Sha256", valid_613931
  var valid_613932 = header.getOrDefault("X-Amz-Date")
  valid_613932 = validateParameter(valid_613932, JString, required = false,
                                 default = nil)
  if valid_613932 != nil:
    section.add "X-Amz-Date", valid_613932
  var valid_613933 = header.getOrDefault("X-Amz-Credential")
  valid_613933 = validateParameter(valid_613933, JString, required = false,
                                 default = nil)
  if valid_613933 != nil:
    section.add "X-Amz-Credential", valid_613933
  var valid_613934 = header.getOrDefault("X-Amz-Security-Token")
  valid_613934 = validateParameter(valid_613934, JString, required = false,
                                 default = nil)
  if valid_613934 != nil:
    section.add "X-Amz-Security-Token", valid_613934
  var valid_613935 = header.getOrDefault("X-Amz-Algorithm")
  valid_613935 = validateParameter(valid_613935, JString, required = false,
                                 default = nil)
  if valid_613935 != nil:
    section.add "X-Amz-Algorithm", valid_613935
  var valid_613936 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613936 = validateParameter(valid_613936, JString, required = false,
                                 default = nil)
  if valid_613936 != nil:
    section.add "X-Amz-SignedHeaders", valid_613936
  result.add "header", section
  ## parameters in `formData` object:
  ##   KmsKeyId: JString
  ##           : The unique identifier of the customer master key (CMK) to which to grant Amazon Redshift permission. If no key is specified, the default key is used.
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   SnapshotCopyGrantName: JString (required)
  ##                        : <p>The name of the snapshot copy grant. This name must be unique in the region for the AWS account.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul>
  section = newJObject()
  var valid_613937 = formData.getOrDefault("KmsKeyId")
  valid_613937 = validateParameter(valid_613937, JString, required = false,
                                 default = nil)
  if valid_613937 != nil:
    section.add "KmsKeyId", valid_613937
  var valid_613938 = formData.getOrDefault("Tags")
  valid_613938 = validateParameter(valid_613938, JArray, required = false,
                                 default = nil)
  if valid_613938 != nil:
    section.add "Tags", valid_613938
  assert formData != nil, "formData argument is necessary due to required `SnapshotCopyGrantName` field"
  var valid_613939 = formData.getOrDefault("SnapshotCopyGrantName")
  valid_613939 = validateParameter(valid_613939, JString, required = true,
                                 default = nil)
  if valid_613939 != nil:
    section.add "SnapshotCopyGrantName", valid_613939
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613940: Call_PostCreateSnapshotCopyGrant_613925; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a snapshot copy grant that permits Amazon Redshift to use a customer master key (CMK) from AWS Key Management Service (AWS KMS) to encrypt copied snapshots in a destination region.</p> <p> For more information about managing snapshot copy grants, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ## 
  let valid = call_613940.validator(path, query, header, formData, body)
  let scheme = call_613940.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613940.url(scheme.get, call_613940.host, call_613940.base,
                         call_613940.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613940, url, valid)

proc call*(call_613941: Call_PostCreateSnapshotCopyGrant_613925;
          SnapshotCopyGrantName: string; KmsKeyId: string = "";
          Action: string = "CreateSnapshotCopyGrant"; Tags: JsonNode = nil;
          Version: string = "2012-12-01"): Recallable =
  ## postCreateSnapshotCopyGrant
  ## <p>Creates a snapshot copy grant that permits Amazon Redshift to use a customer master key (CMK) from AWS Key Management Service (AWS KMS) to encrypt copied snapshots in a destination region.</p> <p> For more information about managing snapshot copy grants, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ##   KmsKeyId: string
  ##           : The unique identifier of the customer master key (CMK) to which to grant Amazon Redshift permission. If no key is specified, the default key is used.
  ##   Action: string (required)
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   SnapshotCopyGrantName: string (required)
  ##                        : <p>The name of the snapshot copy grant. This name must be unique in the region for the AWS account.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul>
  ##   Version: string (required)
  var query_613942 = newJObject()
  var formData_613943 = newJObject()
  add(formData_613943, "KmsKeyId", newJString(KmsKeyId))
  add(query_613942, "Action", newJString(Action))
  if Tags != nil:
    formData_613943.add "Tags", Tags
  add(formData_613943, "SnapshotCopyGrantName", newJString(SnapshotCopyGrantName))
  add(query_613942, "Version", newJString(Version))
  result = call_613941.call(nil, query_613942, nil, formData_613943, nil)

var postCreateSnapshotCopyGrant* = Call_PostCreateSnapshotCopyGrant_613925(
    name: "postCreateSnapshotCopyGrant", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=CreateSnapshotCopyGrant",
    validator: validate_PostCreateSnapshotCopyGrant_613926, base: "/",
    url: url_PostCreateSnapshotCopyGrant_613927,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCreateSnapshotCopyGrant_613907 = ref object of OpenApiRestCall_612642
proc url_GetCreateSnapshotCopyGrant_613909(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetCreateSnapshotCopyGrant_613908(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a snapshot copy grant that permits Amazon Redshift to use a customer master key (CMK) from AWS Key Management Service (AWS KMS) to encrypt copied snapshots in a destination region.</p> <p> For more information about managing snapshot copy grants, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   KmsKeyId: JString
  ##           : The unique identifier of the customer master key (CMK) to which to grant Amazon Redshift permission. If no key is specified, the default key is used.
  ##   Action: JString (required)
  ##   Version: JString (required)
  ##   SnapshotCopyGrantName: JString (required)
  ##                        : <p>The name of the snapshot copy grant. This name must be unique in the region for the AWS account.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul>
  section = newJObject()
  var valid_613910 = query.getOrDefault("Tags")
  valid_613910 = validateParameter(valid_613910, JArray, required = false,
                                 default = nil)
  if valid_613910 != nil:
    section.add "Tags", valid_613910
  var valid_613911 = query.getOrDefault("KmsKeyId")
  valid_613911 = validateParameter(valid_613911, JString, required = false,
                                 default = nil)
  if valid_613911 != nil:
    section.add "KmsKeyId", valid_613911
  var valid_613912 = query.getOrDefault("Action")
  valid_613912 = validateParameter(valid_613912, JString, required = true, default = newJString(
      "CreateSnapshotCopyGrant"))
  if valid_613912 != nil:
    section.add "Action", valid_613912
  var valid_613913 = query.getOrDefault("Version")
  valid_613913 = validateParameter(valid_613913, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_613913 != nil:
    section.add "Version", valid_613913
  var valid_613914 = query.getOrDefault("SnapshotCopyGrantName")
  valid_613914 = validateParameter(valid_613914, JString, required = true,
                                 default = nil)
  if valid_613914 != nil:
    section.add "SnapshotCopyGrantName", valid_613914
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613915 = header.getOrDefault("X-Amz-Signature")
  valid_613915 = validateParameter(valid_613915, JString, required = false,
                                 default = nil)
  if valid_613915 != nil:
    section.add "X-Amz-Signature", valid_613915
  var valid_613916 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613916 = validateParameter(valid_613916, JString, required = false,
                                 default = nil)
  if valid_613916 != nil:
    section.add "X-Amz-Content-Sha256", valid_613916
  var valid_613917 = header.getOrDefault("X-Amz-Date")
  valid_613917 = validateParameter(valid_613917, JString, required = false,
                                 default = nil)
  if valid_613917 != nil:
    section.add "X-Amz-Date", valid_613917
  var valid_613918 = header.getOrDefault("X-Amz-Credential")
  valid_613918 = validateParameter(valid_613918, JString, required = false,
                                 default = nil)
  if valid_613918 != nil:
    section.add "X-Amz-Credential", valid_613918
  var valid_613919 = header.getOrDefault("X-Amz-Security-Token")
  valid_613919 = validateParameter(valid_613919, JString, required = false,
                                 default = nil)
  if valid_613919 != nil:
    section.add "X-Amz-Security-Token", valid_613919
  var valid_613920 = header.getOrDefault("X-Amz-Algorithm")
  valid_613920 = validateParameter(valid_613920, JString, required = false,
                                 default = nil)
  if valid_613920 != nil:
    section.add "X-Amz-Algorithm", valid_613920
  var valid_613921 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613921 = validateParameter(valid_613921, JString, required = false,
                                 default = nil)
  if valid_613921 != nil:
    section.add "X-Amz-SignedHeaders", valid_613921
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613922: Call_GetCreateSnapshotCopyGrant_613907; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a snapshot copy grant that permits Amazon Redshift to use a customer master key (CMK) from AWS Key Management Service (AWS KMS) to encrypt copied snapshots in a destination region.</p> <p> For more information about managing snapshot copy grants, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ## 
  let valid = call_613922.validator(path, query, header, formData, body)
  let scheme = call_613922.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613922.url(scheme.get, call_613922.host, call_613922.base,
                         call_613922.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613922, url, valid)

proc call*(call_613923: Call_GetCreateSnapshotCopyGrant_613907;
          SnapshotCopyGrantName: string; Tags: JsonNode = nil; KmsKeyId: string = "";
          Action: string = "CreateSnapshotCopyGrant"; Version: string = "2012-12-01"): Recallable =
  ## getCreateSnapshotCopyGrant
  ## <p>Creates a snapshot copy grant that permits Amazon Redshift to use a customer master key (CMK) from AWS Key Management Service (AWS KMS) to encrypt copied snapshots in a destination region.</p> <p> For more information about managing snapshot copy grants, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   KmsKeyId: string
  ##           : The unique identifier of the customer master key (CMK) to which to grant Amazon Redshift permission. If no key is specified, the default key is used.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   SnapshotCopyGrantName: string (required)
  ##                        : <p>The name of the snapshot copy grant. This name must be unique in the region for the AWS account.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul>
  var query_613924 = newJObject()
  if Tags != nil:
    query_613924.add "Tags", Tags
  add(query_613924, "KmsKeyId", newJString(KmsKeyId))
  add(query_613924, "Action", newJString(Action))
  add(query_613924, "Version", newJString(Version))
  add(query_613924, "SnapshotCopyGrantName", newJString(SnapshotCopyGrantName))
  result = call_613923.call(nil, query_613924, nil, nil, nil)

var getCreateSnapshotCopyGrant* = Call_GetCreateSnapshotCopyGrant_613907(
    name: "getCreateSnapshotCopyGrant", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=CreateSnapshotCopyGrant",
    validator: validate_GetCreateSnapshotCopyGrant_613908, base: "/",
    url: url_GetCreateSnapshotCopyGrant_613909,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCreateSnapshotSchedule_613965 = ref object of OpenApiRestCall_612642
proc url_PostCreateSnapshotSchedule_613967(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostCreateSnapshotSchedule_613966(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Creates a snapshot schedule with the rate of every 12 hours.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_613968 = query.getOrDefault("Action")
  valid_613968 = validateParameter(valid_613968, JString, required = true,
                                 default = newJString("CreateSnapshotSchedule"))
  if valid_613968 != nil:
    section.add "Action", valid_613968
  var valid_613969 = query.getOrDefault("Version")
  valid_613969 = validateParameter(valid_613969, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_613969 != nil:
    section.add "Version", valid_613969
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613970 = header.getOrDefault("X-Amz-Signature")
  valid_613970 = validateParameter(valid_613970, JString, required = false,
                                 default = nil)
  if valid_613970 != nil:
    section.add "X-Amz-Signature", valid_613970
  var valid_613971 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613971 = validateParameter(valid_613971, JString, required = false,
                                 default = nil)
  if valid_613971 != nil:
    section.add "X-Amz-Content-Sha256", valid_613971
  var valid_613972 = header.getOrDefault("X-Amz-Date")
  valid_613972 = validateParameter(valid_613972, JString, required = false,
                                 default = nil)
  if valid_613972 != nil:
    section.add "X-Amz-Date", valid_613972
  var valid_613973 = header.getOrDefault("X-Amz-Credential")
  valid_613973 = validateParameter(valid_613973, JString, required = false,
                                 default = nil)
  if valid_613973 != nil:
    section.add "X-Amz-Credential", valid_613973
  var valid_613974 = header.getOrDefault("X-Amz-Security-Token")
  valid_613974 = validateParameter(valid_613974, JString, required = false,
                                 default = nil)
  if valid_613974 != nil:
    section.add "X-Amz-Security-Token", valid_613974
  var valid_613975 = header.getOrDefault("X-Amz-Algorithm")
  valid_613975 = validateParameter(valid_613975, JString, required = false,
                                 default = nil)
  if valid_613975 != nil:
    section.add "X-Amz-Algorithm", valid_613975
  var valid_613976 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613976 = validateParameter(valid_613976, JString, required = false,
                                 default = nil)
  if valid_613976 != nil:
    section.add "X-Amz-SignedHeaders", valid_613976
  result.add "header", section
  ## parameters in `formData` object:
  ##   ScheduleDefinitions: JArray
  ##                      : The definition of the snapshot schedule. The definition is made up of schedule expressions, for example "cron(30 12 *)" or "rate(12 hours)". 
  ##   ScheduleDescription: JString
  ##                      : The description of the snapshot schedule.
  ##   DryRun: JBool
  ##         : <p/>
  ##   NextInvocations: JInt
  ##                  : <p/>
  ##   Tags: JArray
  ##       : An optional set of tags you can use to search for the schedule.
  ##   ScheduleIdentifier: JString
  ##                     : A unique identifier for a snapshot schedule. Only alphanumeric characters are allowed for the identifier.
  section = newJObject()
  var valid_613977 = formData.getOrDefault("ScheduleDefinitions")
  valid_613977 = validateParameter(valid_613977, JArray, required = false,
                                 default = nil)
  if valid_613977 != nil:
    section.add "ScheduleDefinitions", valid_613977
  var valid_613978 = formData.getOrDefault("ScheduleDescription")
  valid_613978 = validateParameter(valid_613978, JString, required = false,
                                 default = nil)
  if valid_613978 != nil:
    section.add "ScheduleDescription", valid_613978
  var valid_613979 = formData.getOrDefault("DryRun")
  valid_613979 = validateParameter(valid_613979, JBool, required = false, default = nil)
  if valid_613979 != nil:
    section.add "DryRun", valid_613979
  var valid_613980 = formData.getOrDefault("NextInvocations")
  valid_613980 = validateParameter(valid_613980, JInt, required = false, default = nil)
  if valid_613980 != nil:
    section.add "NextInvocations", valid_613980
  var valid_613981 = formData.getOrDefault("Tags")
  valid_613981 = validateParameter(valid_613981, JArray, required = false,
                                 default = nil)
  if valid_613981 != nil:
    section.add "Tags", valid_613981
  var valid_613982 = formData.getOrDefault("ScheduleIdentifier")
  valid_613982 = validateParameter(valid_613982, JString, required = false,
                                 default = nil)
  if valid_613982 != nil:
    section.add "ScheduleIdentifier", valid_613982
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613983: Call_PostCreateSnapshotSchedule_613965; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a snapshot schedule with the rate of every 12 hours.
  ## 
  let valid = call_613983.validator(path, query, header, formData, body)
  let scheme = call_613983.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613983.url(scheme.get, call_613983.host, call_613983.base,
                         call_613983.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613983, url, valid)

proc call*(call_613984: Call_PostCreateSnapshotSchedule_613965;
          ScheduleDefinitions: JsonNode = nil; ScheduleDescription: string = "";
          DryRun: bool = false; NextInvocations: int = 0;
          Action: string = "CreateSnapshotSchedule"; Tags: JsonNode = nil;
          ScheduleIdentifier: string = ""; Version: string = "2012-12-01"): Recallable =
  ## postCreateSnapshotSchedule
  ## Creates a snapshot schedule with the rate of every 12 hours.
  ##   ScheduleDefinitions: JArray
  ##                      : The definition of the snapshot schedule. The definition is made up of schedule expressions, for example "cron(30 12 *)" or "rate(12 hours)". 
  ##   ScheduleDescription: string
  ##                      : The description of the snapshot schedule.
  ##   DryRun: bool
  ##         : <p/>
  ##   NextInvocations: int
  ##                  : <p/>
  ##   Action: string (required)
  ##   Tags: JArray
  ##       : An optional set of tags you can use to search for the schedule.
  ##   ScheduleIdentifier: string
  ##                     : A unique identifier for a snapshot schedule. Only alphanumeric characters are allowed for the identifier.
  ##   Version: string (required)
  var query_613985 = newJObject()
  var formData_613986 = newJObject()
  if ScheduleDefinitions != nil:
    formData_613986.add "ScheduleDefinitions", ScheduleDefinitions
  add(formData_613986, "ScheduleDescription", newJString(ScheduleDescription))
  add(formData_613986, "DryRun", newJBool(DryRun))
  add(formData_613986, "NextInvocations", newJInt(NextInvocations))
  add(query_613985, "Action", newJString(Action))
  if Tags != nil:
    formData_613986.add "Tags", Tags
  add(formData_613986, "ScheduleIdentifier", newJString(ScheduleIdentifier))
  add(query_613985, "Version", newJString(Version))
  result = call_613984.call(nil, query_613985, nil, formData_613986, nil)

var postCreateSnapshotSchedule* = Call_PostCreateSnapshotSchedule_613965(
    name: "postCreateSnapshotSchedule", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=CreateSnapshotSchedule",
    validator: validate_PostCreateSnapshotSchedule_613966, base: "/",
    url: url_PostCreateSnapshotSchedule_613967,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCreateSnapshotSchedule_613944 = ref object of OpenApiRestCall_612642
proc url_GetCreateSnapshotSchedule_613946(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetCreateSnapshotSchedule_613945(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Creates a snapshot schedule with the rate of every 12 hours.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Tags: JArray
  ##       : An optional set of tags you can use to search for the schedule.
  ##   ScheduleIdentifier: JString
  ##                     : A unique identifier for a snapshot schedule. Only alphanumeric characters are allowed for the identifier.
  ##   DryRun: JBool
  ##         : <p/>
  ##   NextInvocations: JInt
  ##                  : <p/>
  ##   ScheduleDefinitions: JArray
  ##                      : The definition of the snapshot schedule. The definition is made up of schedule expressions, for example "cron(30 12 *)" or "rate(12 hours)". 
  ##   ScheduleDescription: JString
  ##                      : The description of the snapshot schedule.
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_613947 = query.getOrDefault("Tags")
  valid_613947 = validateParameter(valid_613947, JArray, required = false,
                                 default = nil)
  if valid_613947 != nil:
    section.add "Tags", valid_613947
  var valid_613948 = query.getOrDefault("ScheduleIdentifier")
  valid_613948 = validateParameter(valid_613948, JString, required = false,
                                 default = nil)
  if valid_613948 != nil:
    section.add "ScheduleIdentifier", valid_613948
  var valid_613949 = query.getOrDefault("DryRun")
  valid_613949 = validateParameter(valid_613949, JBool, required = false, default = nil)
  if valid_613949 != nil:
    section.add "DryRun", valid_613949
  var valid_613950 = query.getOrDefault("NextInvocations")
  valid_613950 = validateParameter(valid_613950, JInt, required = false, default = nil)
  if valid_613950 != nil:
    section.add "NextInvocations", valid_613950
  var valid_613951 = query.getOrDefault("ScheduleDefinitions")
  valid_613951 = validateParameter(valid_613951, JArray, required = false,
                                 default = nil)
  if valid_613951 != nil:
    section.add "ScheduleDefinitions", valid_613951
  var valid_613952 = query.getOrDefault("ScheduleDescription")
  valid_613952 = validateParameter(valid_613952, JString, required = false,
                                 default = nil)
  if valid_613952 != nil:
    section.add "ScheduleDescription", valid_613952
  var valid_613953 = query.getOrDefault("Action")
  valid_613953 = validateParameter(valid_613953, JString, required = true,
                                 default = newJString("CreateSnapshotSchedule"))
  if valid_613953 != nil:
    section.add "Action", valid_613953
  var valid_613954 = query.getOrDefault("Version")
  valid_613954 = validateParameter(valid_613954, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_613954 != nil:
    section.add "Version", valid_613954
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613955 = header.getOrDefault("X-Amz-Signature")
  valid_613955 = validateParameter(valid_613955, JString, required = false,
                                 default = nil)
  if valid_613955 != nil:
    section.add "X-Amz-Signature", valid_613955
  var valid_613956 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613956 = validateParameter(valid_613956, JString, required = false,
                                 default = nil)
  if valid_613956 != nil:
    section.add "X-Amz-Content-Sha256", valid_613956
  var valid_613957 = header.getOrDefault("X-Amz-Date")
  valid_613957 = validateParameter(valid_613957, JString, required = false,
                                 default = nil)
  if valid_613957 != nil:
    section.add "X-Amz-Date", valid_613957
  var valid_613958 = header.getOrDefault("X-Amz-Credential")
  valid_613958 = validateParameter(valid_613958, JString, required = false,
                                 default = nil)
  if valid_613958 != nil:
    section.add "X-Amz-Credential", valid_613958
  var valid_613959 = header.getOrDefault("X-Amz-Security-Token")
  valid_613959 = validateParameter(valid_613959, JString, required = false,
                                 default = nil)
  if valid_613959 != nil:
    section.add "X-Amz-Security-Token", valid_613959
  var valid_613960 = header.getOrDefault("X-Amz-Algorithm")
  valid_613960 = validateParameter(valid_613960, JString, required = false,
                                 default = nil)
  if valid_613960 != nil:
    section.add "X-Amz-Algorithm", valid_613960
  var valid_613961 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613961 = validateParameter(valid_613961, JString, required = false,
                                 default = nil)
  if valid_613961 != nil:
    section.add "X-Amz-SignedHeaders", valid_613961
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613962: Call_GetCreateSnapshotSchedule_613944; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a snapshot schedule with the rate of every 12 hours.
  ## 
  let valid = call_613962.validator(path, query, header, formData, body)
  let scheme = call_613962.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613962.url(scheme.get, call_613962.host, call_613962.base,
                         call_613962.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613962, url, valid)

proc call*(call_613963: Call_GetCreateSnapshotSchedule_613944;
          Tags: JsonNode = nil; ScheduleIdentifier: string = ""; DryRun: bool = false;
          NextInvocations: int = 0; ScheduleDefinitions: JsonNode = nil;
          ScheduleDescription: string = "";
          Action: string = "CreateSnapshotSchedule"; Version: string = "2012-12-01"): Recallable =
  ## getCreateSnapshotSchedule
  ## Creates a snapshot schedule with the rate of every 12 hours.
  ##   Tags: JArray
  ##       : An optional set of tags you can use to search for the schedule.
  ##   ScheduleIdentifier: string
  ##                     : A unique identifier for a snapshot schedule. Only alphanumeric characters are allowed for the identifier.
  ##   DryRun: bool
  ##         : <p/>
  ##   NextInvocations: int
  ##                  : <p/>
  ##   ScheduleDefinitions: JArray
  ##                      : The definition of the snapshot schedule. The definition is made up of schedule expressions, for example "cron(30 12 *)" or "rate(12 hours)". 
  ##   ScheduleDescription: string
  ##                      : The description of the snapshot schedule.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_613964 = newJObject()
  if Tags != nil:
    query_613964.add "Tags", Tags
  add(query_613964, "ScheduleIdentifier", newJString(ScheduleIdentifier))
  add(query_613964, "DryRun", newJBool(DryRun))
  add(query_613964, "NextInvocations", newJInt(NextInvocations))
  if ScheduleDefinitions != nil:
    query_613964.add "ScheduleDefinitions", ScheduleDefinitions
  add(query_613964, "ScheduleDescription", newJString(ScheduleDescription))
  add(query_613964, "Action", newJString(Action))
  add(query_613964, "Version", newJString(Version))
  result = call_613963.call(nil, query_613964, nil, nil, nil)

var getCreateSnapshotSchedule* = Call_GetCreateSnapshotSchedule_613944(
    name: "getCreateSnapshotSchedule", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=CreateSnapshotSchedule",
    validator: validate_GetCreateSnapshotSchedule_613945, base: "/",
    url: url_GetCreateSnapshotSchedule_613946,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCreateTags_614004 = ref object of OpenApiRestCall_612642
proc url_PostCreateTags_614006(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostCreateTags_614005(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode): JsonNode =
  ## <p>Adds tags to a cluster.</p> <p>A resource can have up to 50 tags. If you try to create more than 50 tags for a resource, you will receive an error and the attempt will fail.</p> <p>If you specify a key that already exists for the resource, the value for that key will be updated with the new value.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_614007 = query.getOrDefault("Action")
  valid_614007 = validateParameter(valid_614007, JString, required = true,
                                 default = newJString("CreateTags"))
  if valid_614007 != nil:
    section.add "Action", valid_614007
  var valid_614008 = query.getOrDefault("Version")
  valid_614008 = validateParameter(valid_614008, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_614008 != nil:
    section.add "Version", valid_614008
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614009 = header.getOrDefault("X-Amz-Signature")
  valid_614009 = validateParameter(valid_614009, JString, required = false,
                                 default = nil)
  if valid_614009 != nil:
    section.add "X-Amz-Signature", valid_614009
  var valid_614010 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614010 = validateParameter(valid_614010, JString, required = false,
                                 default = nil)
  if valid_614010 != nil:
    section.add "X-Amz-Content-Sha256", valid_614010
  var valid_614011 = header.getOrDefault("X-Amz-Date")
  valid_614011 = validateParameter(valid_614011, JString, required = false,
                                 default = nil)
  if valid_614011 != nil:
    section.add "X-Amz-Date", valid_614011
  var valid_614012 = header.getOrDefault("X-Amz-Credential")
  valid_614012 = validateParameter(valid_614012, JString, required = false,
                                 default = nil)
  if valid_614012 != nil:
    section.add "X-Amz-Credential", valid_614012
  var valid_614013 = header.getOrDefault("X-Amz-Security-Token")
  valid_614013 = validateParameter(valid_614013, JString, required = false,
                                 default = nil)
  if valid_614013 != nil:
    section.add "X-Amz-Security-Token", valid_614013
  var valid_614014 = header.getOrDefault("X-Amz-Algorithm")
  valid_614014 = validateParameter(valid_614014, JString, required = false,
                                 default = nil)
  if valid_614014 != nil:
    section.add "X-Amz-Algorithm", valid_614014
  var valid_614015 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614015 = validateParameter(valid_614015, JString, required = false,
                                 default = nil)
  if valid_614015 != nil:
    section.add "X-Amz-SignedHeaders", valid_614015
  result.add "header", section
  ## parameters in `formData` object:
  ##   Tags: JArray (required)
  ##       : One or more name/value pairs to add as tags to the specified resource. Each tag name is passed in with the parameter <code>Key</code> and the corresponding value is passed in with the parameter <code>Value</code>. The <code>Key</code> and <code>Value</code> parameters are separated by a comma (,). Separate multiple tags with a space. For example, <code>--tags "Key"="owner","Value"="admin" "Key"="environment","Value"="test" "Key"="version","Value"="1.0"</code>. 
  ##   ResourceName: JString (required)
  ##               : The Amazon Resource Name (ARN) to which you want to add the tag or tags. For example, <code>arn:aws:redshift:us-east-2:123456789:cluster:t1</code>. 
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `Tags` field"
  var valid_614016 = formData.getOrDefault("Tags")
  valid_614016 = validateParameter(valid_614016, JArray, required = true, default = nil)
  if valid_614016 != nil:
    section.add "Tags", valid_614016
  var valid_614017 = formData.getOrDefault("ResourceName")
  valid_614017 = validateParameter(valid_614017, JString, required = true,
                                 default = nil)
  if valid_614017 != nil:
    section.add "ResourceName", valid_614017
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614018: Call_PostCreateTags_614004; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Adds tags to a cluster.</p> <p>A resource can have up to 50 tags. If you try to create more than 50 tags for a resource, you will receive an error and the attempt will fail.</p> <p>If you specify a key that already exists for the resource, the value for that key will be updated with the new value.</p>
  ## 
  let valid = call_614018.validator(path, query, header, formData, body)
  let scheme = call_614018.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614018.url(scheme.get, call_614018.host, call_614018.base,
                         call_614018.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614018, url, valid)

proc call*(call_614019: Call_PostCreateTags_614004; Tags: JsonNode;
          ResourceName: string; Action: string = "CreateTags";
          Version: string = "2012-12-01"): Recallable =
  ## postCreateTags
  ## <p>Adds tags to a cluster.</p> <p>A resource can have up to 50 tags. If you try to create more than 50 tags for a resource, you will receive an error and the attempt will fail.</p> <p>If you specify a key that already exists for the resource, the value for that key will be updated with the new value.</p>
  ##   Action: string (required)
  ##   Tags: JArray (required)
  ##       : One or more name/value pairs to add as tags to the specified resource. Each tag name is passed in with the parameter <code>Key</code> and the corresponding value is passed in with the parameter <code>Value</code>. The <code>Key</code> and <code>Value</code> parameters are separated by a comma (,). Separate multiple tags with a space. For example, <code>--tags "Key"="owner","Value"="admin" "Key"="environment","Value"="test" "Key"="version","Value"="1.0"</code>. 
  ##   Version: string (required)
  ##   ResourceName: string (required)
  ##               : The Amazon Resource Name (ARN) to which you want to add the tag or tags. For example, <code>arn:aws:redshift:us-east-2:123456789:cluster:t1</code>. 
  var query_614020 = newJObject()
  var formData_614021 = newJObject()
  add(query_614020, "Action", newJString(Action))
  if Tags != nil:
    formData_614021.add "Tags", Tags
  add(query_614020, "Version", newJString(Version))
  add(formData_614021, "ResourceName", newJString(ResourceName))
  result = call_614019.call(nil, query_614020, nil, formData_614021, nil)

var postCreateTags* = Call_PostCreateTags_614004(name: "postCreateTags",
    meth: HttpMethod.HttpPost, host: "redshift.amazonaws.com",
    route: "/#Action=CreateTags", validator: validate_PostCreateTags_614005,
    base: "/", url: url_PostCreateTags_614006, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCreateTags_613987 = ref object of OpenApiRestCall_612642
proc url_GetCreateTags_613989(protocol: Scheme; host: string; base: string;
                             route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetCreateTags_613988(path: JsonNode; query: JsonNode; header: JsonNode;
                                  formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Adds tags to a cluster.</p> <p>A resource can have up to 50 tags. If you try to create more than 50 tags for a resource, you will receive an error and the attempt will fail.</p> <p>If you specify a key that already exists for the resource, the value for that key will be updated with the new value.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Tags: JArray (required)
  ##       : One or more name/value pairs to add as tags to the specified resource. Each tag name is passed in with the parameter <code>Key</code> and the corresponding value is passed in with the parameter <code>Value</code>. The <code>Key</code> and <code>Value</code> parameters are separated by a comma (,). Separate multiple tags with a space. For example, <code>--tags "Key"="owner","Value"="admin" "Key"="environment","Value"="test" "Key"="version","Value"="1.0"</code>. 
  ##   ResourceName: JString (required)
  ##               : The Amazon Resource Name (ARN) to which you want to add the tag or tags. For example, <code>arn:aws:redshift:us-east-2:123456789:cluster:t1</code>. 
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Tags` field"
  var valid_613990 = query.getOrDefault("Tags")
  valid_613990 = validateParameter(valid_613990, JArray, required = true, default = nil)
  if valid_613990 != nil:
    section.add "Tags", valid_613990
  var valid_613991 = query.getOrDefault("ResourceName")
  valid_613991 = validateParameter(valid_613991, JString, required = true,
                                 default = nil)
  if valid_613991 != nil:
    section.add "ResourceName", valid_613991
  var valid_613992 = query.getOrDefault("Action")
  valid_613992 = validateParameter(valid_613992, JString, required = true,
                                 default = newJString("CreateTags"))
  if valid_613992 != nil:
    section.add "Action", valid_613992
  var valid_613993 = query.getOrDefault("Version")
  valid_613993 = validateParameter(valid_613993, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_613993 != nil:
    section.add "Version", valid_613993
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613994 = header.getOrDefault("X-Amz-Signature")
  valid_613994 = validateParameter(valid_613994, JString, required = false,
                                 default = nil)
  if valid_613994 != nil:
    section.add "X-Amz-Signature", valid_613994
  var valid_613995 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613995 = validateParameter(valid_613995, JString, required = false,
                                 default = nil)
  if valid_613995 != nil:
    section.add "X-Amz-Content-Sha256", valid_613995
  var valid_613996 = header.getOrDefault("X-Amz-Date")
  valid_613996 = validateParameter(valid_613996, JString, required = false,
                                 default = nil)
  if valid_613996 != nil:
    section.add "X-Amz-Date", valid_613996
  var valid_613997 = header.getOrDefault("X-Amz-Credential")
  valid_613997 = validateParameter(valid_613997, JString, required = false,
                                 default = nil)
  if valid_613997 != nil:
    section.add "X-Amz-Credential", valid_613997
  var valid_613998 = header.getOrDefault("X-Amz-Security-Token")
  valid_613998 = validateParameter(valid_613998, JString, required = false,
                                 default = nil)
  if valid_613998 != nil:
    section.add "X-Amz-Security-Token", valid_613998
  var valid_613999 = header.getOrDefault("X-Amz-Algorithm")
  valid_613999 = validateParameter(valid_613999, JString, required = false,
                                 default = nil)
  if valid_613999 != nil:
    section.add "X-Amz-Algorithm", valid_613999
  var valid_614000 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614000 = validateParameter(valid_614000, JString, required = false,
                                 default = nil)
  if valid_614000 != nil:
    section.add "X-Amz-SignedHeaders", valid_614000
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614001: Call_GetCreateTags_613987; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Adds tags to a cluster.</p> <p>A resource can have up to 50 tags. If you try to create more than 50 tags for a resource, you will receive an error and the attempt will fail.</p> <p>If you specify a key that already exists for the resource, the value for that key will be updated with the new value.</p>
  ## 
  let valid = call_614001.validator(path, query, header, formData, body)
  let scheme = call_614001.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614001.url(scheme.get, call_614001.host, call_614001.base,
                         call_614001.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614001, url, valid)

proc call*(call_614002: Call_GetCreateTags_613987; Tags: JsonNode;
          ResourceName: string; Action: string = "CreateTags";
          Version: string = "2012-12-01"): Recallable =
  ## getCreateTags
  ## <p>Adds tags to a cluster.</p> <p>A resource can have up to 50 tags. If you try to create more than 50 tags for a resource, you will receive an error and the attempt will fail.</p> <p>If you specify a key that already exists for the resource, the value for that key will be updated with the new value.</p>
  ##   Tags: JArray (required)
  ##       : One or more name/value pairs to add as tags to the specified resource. Each tag name is passed in with the parameter <code>Key</code> and the corresponding value is passed in with the parameter <code>Value</code>. The <code>Key</code> and <code>Value</code> parameters are separated by a comma (,). Separate multiple tags with a space. For example, <code>--tags "Key"="owner","Value"="admin" "Key"="environment","Value"="test" "Key"="version","Value"="1.0"</code>. 
  ##   ResourceName: string (required)
  ##               : The Amazon Resource Name (ARN) to which you want to add the tag or tags. For example, <code>arn:aws:redshift:us-east-2:123456789:cluster:t1</code>. 
  ##   Action: string (required)
  ##   Version: string (required)
  var query_614003 = newJObject()
  if Tags != nil:
    query_614003.add "Tags", Tags
  add(query_614003, "ResourceName", newJString(ResourceName))
  add(query_614003, "Action", newJString(Action))
  add(query_614003, "Version", newJString(Version))
  result = call_614002.call(nil, query_614003, nil, nil, nil)

var getCreateTags* = Call_GetCreateTags_613987(name: "getCreateTags",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=CreateTags", validator: validate_GetCreateTags_613988,
    base: "/", url: url_GetCreateTags_613989, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDeleteCluster_614041 = ref object of OpenApiRestCall_612642
proc url_PostDeleteCluster_614043(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDeleteCluster_614042(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## <p>Deletes a previously provisioned cluster without its final snapshot being created. A successful response from the web service indicates that the request was received correctly. Use <a>DescribeClusters</a> to monitor the status of the deletion. The delete operation cannot be canceled or reverted once submitted. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you want to shut down the cluster and retain it for future use, set <i>SkipFinalClusterSnapshot</i> to <code>false</code> and specify a name for <i>FinalClusterSnapshotIdentifier</i>. You can later restore this snapshot to resume using the cluster. If a final cluster snapshot is requested, the status of the cluster will be "final-snapshot" while the snapshot is being taken, then it's "deleting" once Amazon Redshift begins deleting the cluster. </p> <p> For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_614044 = query.getOrDefault("Action")
  valid_614044 = validateParameter(valid_614044, JString, required = true,
                                 default = newJString("DeleteCluster"))
  if valid_614044 != nil:
    section.add "Action", valid_614044
  var valid_614045 = query.getOrDefault("Version")
  valid_614045 = validateParameter(valid_614045, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_614045 != nil:
    section.add "Version", valid_614045
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614046 = header.getOrDefault("X-Amz-Signature")
  valid_614046 = validateParameter(valid_614046, JString, required = false,
                                 default = nil)
  if valid_614046 != nil:
    section.add "X-Amz-Signature", valid_614046
  var valid_614047 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614047 = validateParameter(valid_614047, JString, required = false,
                                 default = nil)
  if valid_614047 != nil:
    section.add "X-Amz-Content-Sha256", valid_614047
  var valid_614048 = header.getOrDefault("X-Amz-Date")
  valid_614048 = validateParameter(valid_614048, JString, required = false,
                                 default = nil)
  if valid_614048 != nil:
    section.add "X-Amz-Date", valid_614048
  var valid_614049 = header.getOrDefault("X-Amz-Credential")
  valid_614049 = validateParameter(valid_614049, JString, required = false,
                                 default = nil)
  if valid_614049 != nil:
    section.add "X-Amz-Credential", valid_614049
  var valid_614050 = header.getOrDefault("X-Amz-Security-Token")
  valid_614050 = validateParameter(valid_614050, JString, required = false,
                                 default = nil)
  if valid_614050 != nil:
    section.add "X-Amz-Security-Token", valid_614050
  var valid_614051 = header.getOrDefault("X-Amz-Algorithm")
  valid_614051 = validateParameter(valid_614051, JString, required = false,
                                 default = nil)
  if valid_614051 != nil:
    section.add "X-Amz-Algorithm", valid_614051
  var valid_614052 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614052 = validateParameter(valid_614052, JString, required = false,
                                 default = nil)
  if valid_614052 != nil:
    section.add "X-Amz-SignedHeaders", valid_614052
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The identifier of the cluster to be deleted.</p> <p>Constraints:</p> <ul> <li> <p>Must contain lowercase characters.</p> </li> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   FinalClusterSnapshotIdentifier: JString
  ##                                 : <p>The identifier of the final snapshot that is to be created immediately before deleting the cluster. If this parameter is provided, <i>SkipFinalClusterSnapshot</i> must be <code>false</code>. </p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   FinalClusterSnapshotRetentionPeriod: JInt
  ##                                      : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  ##   SkipFinalClusterSnapshot: JBool
  ##                           : <p>Determines whether a final snapshot of the cluster is created before Amazon Redshift deletes the cluster. If <code>true</code>, a final cluster snapshot is not created. If <code>false</code>, a final cluster snapshot is created before the cluster is deleted. </p> <note> <p>The <i>FinalClusterSnapshotIdentifier</i> parameter must be specified if <i>SkipFinalClusterSnapshot</i> is <code>false</code>.</p> </note> <p>Default: <code>false</code> </p>
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_614053 = formData.getOrDefault("ClusterIdentifier")
  valid_614053 = validateParameter(valid_614053, JString, required = true,
                                 default = nil)
  if valid_614053 != nil:
    section.add "ClusterIdentifier", valid_614053
  var valid_614054 = formData.getOrDefault("FinalClusterSnapshotIdentifier")
  valid_614054 = validateParameter(valid_614054, JString, required = false,
                                 default = nil)
  if valid_614054 != nil:
    section.add "FinalClusterSnapshotIdentifier", valid_614054
  var valid_614055 = formData.getOrDefault("FinalClusterSnapshotRetentionPeriod")
  valid_614055 = validateParameter(valid_614055, JInt, required = false, default = nil)
  if valid_614055 != nil:
    section.add "FinalClusterSnapshotRetentionPeriod", valid_614055
  var valid_614056 = formData.getOrDefault("SkipFinalClusterSnapshot")
  valid_614056 = validateParameter(valid_614056, JBool, required = false, default = nil)
  if valid_614056 != nil:
    section.add "SkipFinalClusterSnapshot", valid_614056
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614057: Call_PostDeleteCluster_614041; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Deletes a previously provisioned cluster without its final snapshot being created. A successful response from the web service indicates that the request was received correctly. Use <a>DescribeClusters</a> to monitor the status of the deletion. The delete operation cannot be canceled or reverted once submitted. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you want to shut down the cluster and retain it for future use, set <i>SkipFinalClusterSnapshot</i> to <code>false</code> and specify a name for <i>FinalClusterSnapshotIdentifier</i>. You can later restore this snapshot to resume using the cluster. If a final cluster snapshot is requested, the status of the cluster will be "final-snapshot" while the snapshot is being taken, then it's "deleting" once Amazon Redshift begins deleting the cluster. </p> <p> For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_614057.validator(path, query, header, formData, body)
  let scheme = call_614057.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614057.url(scheme.get, call_614057.host, call_614057.base,
                         call_614057.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614057, url, valid)

proc call*(call_614058: Call_PostDeleteCluster_614041; ClusterIdentifier: string;
          FinalClusterSnapshotIdentifier: string = "";
          Action: string = "DeleteCluster";
          FinalClusterSnapshotRetentionPeriod: int = 0;
          Version: string = "2012-12-01"; SkipFinalClusterSnapshot: bool = false): Recallable =
  ## postDeleteCluster
  ## <p>Deletes a previously provisioned cluster without its final snapshot being created. A successful response from the web service indicates that the request was received correctly. Use <a>DescribeClusters</a> to monitor the status of the deletion. The delete operation cannot be canceled or reverted once submitted. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you want to shut down the cluster and retain it for future use, set <i>SkipFinalClusterSnapshot</i> to <code>false</code> and specify a name for <i>FinalClusterSnapshotIdentifier</i>. You can later restore this snapshot to resume using the cluster. If a final cluster snapshot is requested, the status of the cluster will be "final-snapshot" while the snapshot is being taken, then it's "deleting" once Amazon Redshift begins deleting the cluster. </p> <p> For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The identifier of the cluster to be deleted.</p> <p>Constraints:</p> <ul> <li> <p>Must contain lowercase characters.</p> </li> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   FinalClusterSnapshotIdentifier: string
  ##                                 : <p>The identifier of the final snapshot that is to be created immediately before deleting the cluster. If this parameter is provided, <i>SkipFinalClusterSnapshot</i> must be <code>false</code>. </p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   Action: string (required)
  ##   FinalClusterSnapshotRetentionPeriod: int
  ##                                      : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  ##   Version: string (required)
  ##   SkipFinalClusterSnapshot: bool
  ##                           : <p>Determines whether a final snapshot of the cluster is created before Amazon Redshift deletes the cluster. If <code>true</code>, a final cluster snapshot is not created. If <code>false</code>, a final cluster snapshot is created before the cluster is deleted. </p> <note> <p>The <i>FinalClusterSnapshotIdentifier</i> parameter must be specified if <i>SkipFinalClusterSnapshot</i> is <code>false</code>.</p> </note> <p>Default: <code>false</code> </p>
  var query_614059 = newJObject()
  var formData_614060 = newJObject()
  add(formData_614060, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_614060, "FinalClusterSnapshotIdentifier",
      newJString(FinalClusterSnapshotIdentifier))
  add(query_614059, "Action", newJString(Action))
  add(formData_614060, "FinalClusterSnapshotRetentionPeriod",
      newJInt(FinalClusterSnapshotRetentionPeriod))
  add(query_614059, "Version", newJString(Version))
  add(formData_614060, "SkipFinalClusterSnapshot",
      newJBool(SkipFinalClusterSnapshot))
  result = call_614058.call(nil, query_614059, nil, formData_614060, nil)

var postDeleteCluster* = Call_PostDeleteCluster_614041(name: "postDeleteCluster",
    meth: HttpMethod.HttpPost, host: "redshift.amazonaws.com",
    route: "/#Action=DeleteCluster", validator: validate_PostDeleteCluster_614042,
    base: "/", url: url_PostDeleteCluster_614043,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeleteCluster_614022 = ref object of OpenApiRestCall_612642
proc url_GetDeleteCluster_614024(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDeleteCluster_614023(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## <p>Deletes a previously provisioned cluster without its final snapshot being created. A successful response from the web service indicates that the request was received correctly. Use <a>DescribeClusters</a> to monitor the status of the deletion. The delete operation cannot be canceled or reverted once submitted. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you want to shut down the cluster and retain it for future use, set <i>SkipFinalClusterSnapshot</i> to <code>false</code> and specify a name for <i>FinalClusterSnapshotIdentifier</i>. You can later restore this snapshot to resume using the cluster. If a final cluster snapshot is requested, the status of the cluster will be "final-snapshot" while the snapshot is being taken, then it's "deleting" once Amazon Redshift begins deleting the cluster. </p> <p> For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   SkipFinalClusterSnapshot: JBool
  ##                           : <p>Determines whether a final snapshot of the cluster is created before Amazon Redshift deletes the cluster. If <code>true</code>, a final cluster snapshot is not created. If <code>false</code>, a final cluster snapshot is created before the cluster is deleted. </p> <note> <p>The <i>FinalClusterSnapshotIdentifier</i> parameter must be specified if <i>SkipFinalClusterSnapshot</i> is <code>false</code>.</p> </note> <p>Default: <code>false</code> </p>
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The identifier of the cluster to be deleted.</p> <p>Constraints:</p> <ul> <li> <p>Must contain lowercase characters.</p> </li> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   Version: JString (required)
  ##   FinalClusterSnapshotIdentifier: JString
  ##                                 : <p>The identifier of the final snapshot that is to be created immediately before deleting the cluster. If this parameter is provided, <i>SkipFinalClusterSnapshot</i> must be <code>false</code>. </p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   FinalClusterSnapshotRetentionPeriod: JInt
  ##                                      : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  section = newJObject()
  var valid_614025 = query.getOrDefault("Action")
  valid_614025 = validateParameter(valid_614025, JString, required = true,
                                 default = newJString("DeleteCluster"))
  if valid_614025 != nil:
    section.add "Action", valid_614025
  var valid_614026 = query.getOrDefault("SkipFinalClusterSnapshot")
  valid_614026 = validateParameter(valid_614026, JBool, required = false, default = nil)
  if valid_614026 != nil:
    section.add "SkipFinalClusterSnapshot", valid_614026
  var valid_614027 = query.getOrDefault("ClusterIdentifier")
  valid_614027 = validateParameter(valid_614027, JString, required = true,
                                 default = nil)
  if valid_614027 != nil:
    section.add "ClusterIdentifier", valid_614027
  var valid_614028 = query.getOrDefault("Version")
  valid_614028 = validateParameter(valid_614028, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_614028 != nil:
    section.add "Version", valid_614028
  var valid_614029 = query.getOrDefault("FinalClusterSnapshotIdentifier")
  valid_614029 = validateParameter(valid_614029, JString, required = false,
                                 default = nil)
  if valid_614029 != nil:
    section.add "FinalClusterSnapshotIdentifier", valid_614029
  var valid_614030 = query.getOrDefault("FinalClusterSnapshotRetentionPeriod")
  valid_614030 = validateParameter(valid_614030, JInt, required = false, default = nil)
  if valid_614030 != nil:
    section.add "FinalClusterSnapshotRetentionPeriod", valid_614030
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614031 = header.getOrDefault("X-Amz-Signature")
  valid_614031 = validateParameter(valid_614031, JString, required = false,
                                 default = nil)
  if valid_614031 != nil:
    section.add "X-Amz-Signature", valid_614031
  var valid_614032 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614032 = validateParameter(valid_614032, JString, required = false,
                                 default = nil)
  if valid_614032 != nil:
    section.add "X-Amz-Content-Sha256", valid_614032
  var valid_614033 = header.getOrDefault("X-Amz-Date")
  valid_614033 = validateParameter(valid_614033, JString, required = false,
                                 default = nil)
  if valid_614033 != nil:
    section.add "X-Amz-Date", valid_614033
  var valid_614034 = header.getOrDefault("X-Amz-Credential")
  valid_614034 = validateParameter(valid_614034, JString, required = false,
                                 default = nil)
  if valid_614034 != nil:
    section.add "X-Amz-Credential", valid_614034
  var valid_614035 = header.getOrDefault("X-Amz-Security-Token")
  valid_614035 = validateParameter(valid_614035, JString, required = false,
                                 default = nil)
  if valid_614035 != nil:
    section.add "X-Amz-Security-Token", valid_614035
  var valid_614036 = header.getOrDefault("X-Amz-Algorithm")
  valid_614036 = validateParameter(valid_614036, JString, required = false,
                                 default = nil)
  if valid_614036 != nil:
    section.add "X-Amz-Algorithm", valid_614036
  var valid_614037 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614037 = validateParameter(valid_614037, JString, required = false,
                                 default = nil)
  if valid_614037 != nil:
    section.add "X-Amz-SignedHeaders", valid_614037
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614038: Call_GetDeleteCluster_614022; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Deletes a previously provisioned cluster without its final snapshot being created. A successful response from the web service indicates that the request was received correctly. Use <a>DescribeClusters</a> to monitor the status of the deletion. The delete operation cannot be canceled or reverted once submitted. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you want to shut down the cluster and retain it for future use, set <i>SkipFinalClusterSnapshot</i> to <code>false</code> and specify a name for <i>FinalClusterSnapshotIdentifier</i>. You can later restore this snapshot to resume using the cluster. If a final cluster snapshot is requested, the status of the cluster will be "final-snapshot" while the snapshot is being taken, then it's "deleting" once Amazon Redshift begins deleting the cluster. </p> <p> For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_614038.validator(path, query, header, formData, body)
  let scheme = call_614038.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614038.url(scheme.get, call_614038.host, call_614038.base,
                         call_614038.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614038, url, valid)

proc call*(call_614039: Call_GetDeleteCluster_614022; ClusterIdentifier: string;
          Action: string = "DeleteCluster"; SkipFinalClusterSnapshot: bool = false;
          Version: string = "2012-12-01";
          FinalClusterSnapshotIdentifier: string = "";
          FinalClusterSnapshotRetentionPeriod: int = 0): Recallable =
  ## getDeleteCluster
  ## <p>Deletes a previously provisioned cluster without its final snapshot being created. A successful response from the web service indicates that the request was received correctly. Use <a>DescribeClusters</a> to monitor the status of the deletion. The delete operation cannot be canceled or reverted once submitted. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you want to shut down the cluster and retain it for future use, set <i>SkipFinalClusterSnapshot</i> to <code>false</code> and specify a name for <i>FinalClusterSnapshotIdentifier</i>. You can later restore this snapshot to resume using the cluster. If a final cluster snapshot is requested, the status of the cluster will be "final-snapshot" while the snapshot is being taken, then it's "deleting" once Amazon Redshift begins deleting the cluster. </p> <p> For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   Action: string (required)
  ##   SkipFinalClusterSnapshot: bool
  ##                           : <p>Determines whether a final snapshot of the cluster is created before Amazon Redshift deletes the cluster. If <code>true</code>, a final cluster snapshot is not created. If <code>false</code>, a final cluster snapshot is created before the cluster is deleted. </p> <note> <p>The <i>FinalClusterSnapshotIdentifier</i> parameter must be specified if <i>SkipFinalClusterSnapshot</i> is <code>false</code>.</p> </note> <p>Default: <code>false</code> </p>
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The identifier of the cluster to be deleted.</p> <p>Constraints:</p> <ul> <li> <p>Must contain lowercase characters.</p> </li> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   Version: string (required)
  ##   FinalClusterSnapshotIdentifier: string
  ##                                 : <p>The identifier of the final snapshot that is to be created immediately before deleting the cluster. If this parameter is provided, <i>SkipFinalClusterSnapshot</i> must be <code>false</code>. </p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   FinalClusterSnapshotRetentionPeriod: int
  ##                                      : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  var query_614040 = newJObject()
  add(query_614040, "Action", newJString(Action))
  add(query_614040, "SkipFinalClusterSnapshot", newJBool(SkipFinalClusterSnapshot))
  add(query_614040, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_614040, "Version", newJString(Version))
  add(query_614040, "FinalClusterSnapshotIdentifier",
      newJString(FinalClusterSnapshotIdentifier))
  add(query_614040, "FinalClusterSnapshotRetentionPeriod",
      newJInt(FinalClusterSnapshotRetentionPeriod))
  result = call_614039.call(nil, query_614040, nil, nil, nil)

var getDeleteCluster* = Call_GetDeleteCluster_614022(name: "getDeleteCluster",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=DeleteCluster", validator: validate_GetDeleteCluster_614023,
    base: "/", url: url_GetDeleteCluster_614024,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDeleteClusterParameterGroup_614077 = ref object of OpenApiRestCall_612642
proc url_PostDeleteClusterParameterGroup_614079(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDeleteClusterParameterGroup_614078(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Deletes a specified Amazon Redshift parameter group.</p> <note> <p>You cannot delete a parameter group if it is associated with a cluster.</p> </note>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_614080 = query.getOrDefault("Action")
  valid_614080 = validateParameter(valid_614080, JString, required = true, default = newJString(
      "DeleteClusterParameterGroup"))
  if valid_614080 != nil:
    section.add "Action", valid_614080
  var valid_614081 = query.getOrDefault("Version")
  valid_614081 = validateParameter(valid_614081, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_614081 != nil:
    section.add "Version", valid_614081
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614082 = header.getOrDefault("X-Amz-Signature")
  valid_614082 = validateParameter(valid_614082, JString, required = false,
                                 default = nil)
  if valid_614082 != nil:
    section.add "X-Amz-Signature", valid_614082
  var valid_614083 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614083 = validateParameter(valid_614083, JString, required = false,
                                 default = nil)
  if valid_614083 != nil:
    section.add "X-Amz-Content-Sha256", valid_614083
  var valid_614084 = header.getOrDefault("X-Amz-Date")
  valid_614084 = validateParameter(valid_614084, JString, required = false,
                                 default = nil)
  if valid_614084 != nil:
    section.add "X-Amz-Date", valid_614084
  var valid_614085 = header.getOrDefault("X-Amz-Credential")
  valid_614085 = validateParameter(valid_614085, JString, required = false,
                                 default = nil)
  if valid_614085 != nil:
    section.add "X-Amz-Credential", valid_614085
  var valid_614086 = header.getOrDefault("X-Amz-Security-Token")
  valid_614086 = validateParameter(valid_614086, JString, required = false,
                                 default = nil)
  if valid_614086 != nil:
    section.add "X-Amz-Security-Token", valid_614086
  var valid_614087 = header.getOrDefault("X-Amz-Algorithm")
  valid_614087 = validateParameter(valid_614087, JString, required = false,
                                 default = nil)
  if valid_614087 != nil:
    section.add "X-Amz-Algorithm", valid_614087
  var valid_614088 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614088 = validateParameter(valid_614088, JString, required = false,
                                 default = nil)
  if valid_614088 != nil:
    section.add "X-Amz-SignedHeaders", valid_614088
  result.add "header", section
  ## parameters in `formData` object:
  ##   ParameterGroupName: JString (required)
  ##                     : <p>The name of the parameter group to be deleted.</p> <p>Constraints:</p> <ul> <li> <p>Must be the name of an existing cluster parameter group.</p> </li> <li> <p>Cannot delete a default cluster parameter group.</p> </li> </ul>
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ParameterGroupName` field"
  var valid_614089 = formData.getOrDefault("ParameterGroupName")
  valid_614089 = validateParameter(valid_614089, JString, required = true,
                                 default = nil)
  if valid_614089 != nil:
    section.add "ParameterGroupName", valid_614089
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614090: Call_PostDeleteClusterParameterGroup_614077;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Deletes a specified Amazon Redshift parameter group.</p> <note> <p>You cannot delete a parameter group if it is associated with a cluster.</p> </note>
  ## 
  let valid = call_614090.validator(path, query, header, formData, body)
  let scheme = call_614090.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614090.url(scheme.get, call_614090.host, call_614090.base,
                         call_614090.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614090, url, valid)

proc call*(call_614091: Call_PostDeleteClusterParameterGroup_614077;
          ParameterGroupName: string;
          Action: string = "DeleteClusterParameterGroup";
          Version: string = "2012-12-01"): Recallable =
  ## postDeleteClusterParameterGroup
  ## <p>Deletes a specified Amazon Redshift parameter group.</p> <note> <p>You cannot delete a parameter group if it is associated with a cluster.</p> </note>
  ##   Action: string (required)
  ##   ParameterGroupName: string (required)
  ##                     : <p>The name of the parameter group to be deleted.</p> <p>Constraints:</p> <ul> <li> <p>Must be the name of an existing cluster parameter group.</p> </li> <li> <p>Cannot delete a default cluster parameter group.</p> </li> </ul>
  ##   Version: string (required)
  var query_614092 = newJObject()
  var formData_614093 = newJObject()
  add(query_614092, "Action", newJString(Action))
  add(formData_614093, "ParameterGroupName", newJString(ParameterGroupName))
  add(query_614092, "Version", newJString(Version))
  result = call_614091.call(nil, query_614092, nil, formData_614093, nil)

var postDeleteClusterParameterGroup* = Call_PostDeleteClusterParameterGroup_614077(
    name: "postDeleteClusterParameterGroup", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteClusterParameterGroup",
    validator: validate_PostDeleteClusterParameterGroup_614078, base: "/",
    url: url_PostDeleteClusterParameterGroup_614079,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeleteClusterParameterGroup_614061 = ref object of OpenApiRestCall_612642
proc url_GetDeleteClusterParameterGroup_614063(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDeleteClusterParameterGroup_614062(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Deletes a specified Amazon Redshift parameter group.</p> <note> <p>You cannot delete a parameter group if it is associated with a cluster.</p> </note>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   ParameterGroupName: JString (required)
  ##                     : <p>The name of the parameter group to be deleted.</p> <p>Constraints:</p> <ul> <li> <p>Must be the name of an existing cluster parameter group.</p> </li> <li> <p>Cannot delete a default cluster parameter group.</p> </li> </ul>
  ##   Version: JString (required)
  section = newJObject()
  var valid_614064 = query.getOrDefault("Action")
  valid_614064 = validateParameter(valid_614064, JString, required = true, default = newJString(
      "DeleteClusterParameterGroup"))
  if valid_614064 != nil:
    section.add "Action", valid_614064
  var valid_614065 = query.getOrDefault("ParameterGroupName")
  valid_614065 = validateParameter(valid_614065, JString, required = true,
                                 default = nil)
  if valid_614065 != nil:
    section.add "ParameterGroupName", valid_614065
  var valid_614066 = query.getOrDefault("Version")
  valid_614066 = validateParameter(valid_614066, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_614066 != nil:
    section.add "Version", valid_614066
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614067 = header.getOrDefault("X-Amz-Signature")
  valid_614067 = validateParameter(valid_614067, JString, required = false,
                                 default = nil)
  if valid_614067 != nil:
    section.add "X-Amz-Signature", valid_614067
  var valid_614068 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614068 = validateParameter(valid_614068, JString, required = false,
                                 default = nil)
  if valid_614068 != nil:
    section.add "X-Amz-Content-Sha256", valid_614068
  var valid_614069 = header.getOrDefault("X-Amz-Date")
  valid_614069 = validateParameter(valid_614069, JString, required = false,
                                 default = nil)
  if valid_614069 != nil:
    section.add "X-Amz-Date", valid_614069
  var valid_614070 = header.getOrDefault("X-Amz-Credential")
  valid_614070 = validateParameter(valid_614070, JString, required = false,
                                 default = nil)
  if valid_614070 != nil:
    section.add "X-Amz-Credential", valid_614070
  var valid_614071 = header.getOrDefault("X-Amz-Security-Token")
  valid_614071 = validateParameter(valid_614071, JString, required = false,
                                 default = nil)
  if valid_614071 != nil:
    section.add "X-Amz-Security-Token", valid_614071
  var valid_614072 = header.getOrDefault("X-Amz-Algorithm")
  valid_614072 = validateParameter(valid_614072, JString, required = false,
                                 default = nil)
  if valid_614072 != nil:
    section.add "X-Amz-Algorithm", valid_614072
  var valid_614073 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614073 = validateParameter(valid_614073, JString, required = false,
                                 default = nil)
  if valid_614073 != nil:
    section.add "X-Amz-SignedHeaders", valid_614073
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614074: Call_GetDeleteClusterParameterGroup_614061; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Deletes a specified Amazon Redshift parameter group.</p> <note> <p>You cannot delete a parameter group if it is associated with a cluster.</p> </note>
  ## 
  let valid = call_614074.validator(path, query, header, formData, body)
  let scheme = call_614074.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614074.url(scheme.get, call_614074.host, call_614074.base,
                         call_614074.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614074, url, valid)

proc call*(call_614075: Call_GetDeleteClusterParameterGroup_614061;
          ParameterGroupName: string;
          Action: string = "DeleteClusterParameterGroup";
          Version: string = "2012-12-01"): Recallable =
  ## getDeleteClusterParameterGroup
  ## <p>Deletes a specified Amazon Redshift parameter group.</p> <note> <p>You cannot delete a parameter group if it is associated with a cluster.</p> </note>
  ##   Action: string (required)
  ##   ParameterGroupName: string (required)
  ##                     : <p>The name of the parameter group to be deleted.</p> <p>Constraints:</p> <ul> <li> <p>Must be the name of an existing cluster parameter group.</p> </li> <li> <p>Cannot delete a default cluster parameter group.</p> </li> </ul>
  ##   Version: string (required)
  var query_614076 = newJObject()
  add(query_614076, "Action", newJString(Action))
  add(query_614076, "ParameterGroupName", newJString(ParameterGroupName))
  add(query_614076, "Version", newJString(Version))
  result = call_614075.call(nil, query_614076, nil, nil, nil)

var getDeleteClusterParameterGroup* = Call_GetDeleteClusterParameterGroup_614061(
    name: "getDeleteClusterParameterGroup", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteClusterParameterGroup",
    validator: validate_GetDeleteClusterParameterGroup_614062, base: "/",
    url: url_GetDeleteClusterParameterGroup_614063,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDeleteClusterSecurityGroup_614110 = ref object of OpenApiRestCall_612642
proc url_PostDeleteClusterSecurityGroup_614112(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDeleteClusterSecurityGroup_614111(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Deletes an Amazon Redshift security group.</p> <note> <p>You cannot delete a security group that is associated with any clusters. You cannot delete the default security group.</p> </note> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_614113 = query.getOrDefault("Action")
  valid_614113 = validateParameter(valid_614113, JString, required = true, default = newJString(
      "DeleteClusterSecurityGroup"))
  if valid_614113 != nil:
    section.add "Action", valid_614113
  var valid_614114 = query.getOrDefault("Version")
  valid_614114 = validateParameter(valid_614114, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_614114 != nil:
    section.add "Version", valid_614114
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614115 = header.getOrDefault("X-Amz-Signature")
  valid_614115 = validateParameter(valid_614115, JString, required = false,
                                 default = nil)
  if valid_614115 != nil:
    section.add "X-Amz-Signature", valid_614115
  var valid_614116 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614116 = validateParameter(valid_614116, JString, required = false,
                                 default = nil)
  if valid_614116 != nil:
    section.add "X-Amz-Content-Sha256", valid_614116
  var valid_614117 = header.getOrDefault("X-Amz-Date")
  valid_614117 = validateParameter(valid_614117, JString, required = false,
                                 default = nil)
  if valid_614117 != nil:
    section.add "X-Amz-Date", valid_614117
  var valid_614118 = header.getOrDefault("X-Amz-Credential")
  valid_614118 = validateParameter(valid_614118, JString, required = false,
                                 default = nil)
  if valid_614118 != nil:
    section.add "X-Amz-Credential", valid_614118
  var valid_614119 = header.getOrDefault("X-Amz-Security-Token")
  valid_614119 = validateParameter(valid_614119, JString, required = false,
                                 default = nil)
  if valid_614119 != nil:
    section.add "X-Amz-Security-Token", valid_614119
  var valid_614120 = header.getOrDefault("X-Amz-Algorithm")
  valid_614120 = validateParameter(valid_614120, JString, required = false,
                                 default = nil)
  if valid_614120 != nil:
    section.add "X-Amz-Algorithm", valid_614120
  var valid_614121 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614121 = validateParameter(valid_614121, JString, required = false,
                                 default = nil)
  if valid_614121 != nil:
    section.add "X-Amz-SignedHeaders", valid_614121
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterSecurityGroupName: JString (required)
  ##                           : The name of the cluster security group to be deleted.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterSecurityGroupName` field"
  var valid_614122 = formData.getOrDefault("ClusterSecurityGroupName")
  valid_614122 = validateParameter(valid_614122, JString, required = true,
                                 default = nil)
  if valid_614122 != nil:
    section.add "ClusterSecurityGroupName", valid_614122
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614123: Call_PostDeleteClusterSecurityGroup_614110; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Deletes an Amazon Redshift security group.</p> <note> <p>You cannot delete a security group that is associated with any clusters. You cannot delete the default security group.</p> </note> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_614123.validator(path, query, header, formData, body)
  let scheme = call_614123.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614123.url(scheme.get, call_614123.host, call_614123.base,
                         call_614123.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614123, url, valid)

proc call*(call_614124: Call_PostDeleteClusterSecurityGroup_614110;
          ClusterSecurityGroupName: string;
          Action: string = "DeleteClusterSecurityGroup";
          Version: string = "2012-12-01"): Recallable =
  ## postDeleteClusterSecurityGroup
  ## <p>Deletes an Amazon Redshift security group.</p> <note> <p>You cannot delete a security group that is associated with any clusters. You cannot delete the default security group.</p> </note> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   ClusterSecurityGroupName: string (required)
  ##                           : The name of the cluster security group to be deleted.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_614125 = newJObject()
  var formData_614126 = newJObject()
  add(formData_614126, "ClusterSecurityGroupName",
      newJString(ClusterSecurityGroupName))
  add(query_614125, "Action", newJString(Action))
  add(query_614125, "Version", newJString(Version))
  result = call_614124.call(nil, query_614125, nil, formData_614126, nil)

var postDeleteClusterSecurityGroup* = Call_PostDeleteClusterSecurityGroup_614110(
    name: "postDeleteClusterSecurityGroup", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteClusterSecurityGroup",
    validator: validate_PostDeleteClusterSecurityGroup_614111, base: "/",
    url: url_PostDeleteClusterSecurityGroup_614112,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeleteClusterSecurityGroup_614094 = ref object of OpenApiRestCall_612642
proc url_GetDeleteClusterSecurityGroup_614096(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDeleteClusterSecurityGroup_614095(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Deletes an Amazon Redshift security group.</p> <note> <p>You cannot delete a security group that is associated with any clusters. You cannot delete the default security group.</p> </note> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ClusterSecurityGroupName: JString (required)
  ##                           : The name of the cluster security group to be deleted.
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `ClusterSecurityGroupName` field"
  var valid_614097 = query.getOrDefault("ClusterSecurityGroupName")
  valid_614097 = validateParameter(valid_614097, JString, required = true,
                                 default = nil)
  if valid_614097 != nil:
    section.add "ClusterSecurityGroupName", valid_614097
  var valid_614098 = query.getOrDefault("Action")
  valid_614098 = validateParameter(valid_614098, JString, required = true, default = newJString(
      "DeleteClusterSecurityGroup"))
  if valid_614098 != nil:
    section.add "Action", valid_614098
  var valid_614099 = query.getOrDefault("Version")
  valid_614099 = validateParameter(valid_614099, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_614099 != nil:
    section.add "Version", valid_614099
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614100 = header.getOrDefault("X-Amz-Signature")
  valid_614100 = validateParameter(valid_614100, JString, required = false,
                                 default = nil)
  if valid_614100 != nil:
    section.add "X-Amz-Signature", valid_614100
  var valid_614101 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614101 = validateParameter(valid_614101, JString, required = false,
                                 default = nil)
  if valid_614101 != nil:
    section.add "X-Amz-Content-Sha256", valid_614101
  var valid_614102 = header.getOrDefault("X-Amz-Date")
  valid_614102 = validateParameter(valid_614102, JString, required = false,
                                 default = nil)
  if valid_614102 != nil:
    section.add "X-Amz-Date", valid_614102
  var valid_614103 = header.getOrDefault("X-Amz-Credential")
  valid_614103 = validateParameter(valid_614103, JString, required = false,
                                 default = nil)
  if valid_614103 != nil:
    section.add "X-Amz-Credential", valid_614103
  var valid_614104 = header.getOrDefault("X-Amz-Security-Token")
  valid_614104 = validateParameter(valid_614104, JString, required = false,
                                 default = nil)
  if valid_614104 != nil:
    section.add "X-Amz-Security-Token", valid_614104
  var valid_614105 = header.getOrDefault("X-Amz-Algorithm")
  valid_614105 = validateParameter(valid_614105, JString, required = false,
                                 default = nil)
  if valid_614105 != nil:
    section.add "X-Amz-Algorithm", valid_614105
  var valid_614106 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614106 = validateParameter(valid_614106, JString, required = false,
                                 default = nil)
  if valid_614106 != nil:
    section.add "X-Amz-SignedHeaders", valid_614106
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614107: Call_GetDeleteClusterSecurityGroup_614094; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Deletes an Amazon Redshift security group.</p> <note> <p>You cannot delete a security group that is associated with any clusters. You cannot delete the default security group.</p> </note> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_614107.validator(path, query, header, formData, body)
  let scheme = call_614107.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614107.url(scheme.get, call_614107.host, call_614107.base,
                         call_614107.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614107, url, valid)

proc call*(call_614108: Call_GetDeleteClusterSecurityGroup_614094;
          ClusterSecurityGroupName: string;
          Action: string = "DeleteClusterSecurityGroup";
          Version: string = "2012-12-01"): Recallable =
  ## getDeleteClusterSecurityGroup
  ## <p>Deletes an Amazon Redshift security group.</p> <note> <p>You cannot delete a security group that is associated with any clusters. You cannot delete the default security group.</p> </note> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   ClusterSecurityGroupName: string (required)
  ##                           : The name of the cluster security group to be deleted.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_614109 = newJObject()
  add(query_614109, "ClusterSecurityGroupName",
      newJString(ClusterSecurityGroupName))
  add(query_614109, "Action", newJString(Action))
  add(query_614109, "Version", newJString(Version))
  result = call_614108.call(nil, query_614109, nil, nil, nil)

var getDeleteClusterSecurityGroup* = Call_GetDeleteClusterSecurityGroup_614094(
    name: "getDeleteClusterSecurityGroup", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteClusterSecurityGroup",
    validator: validate_GetDeleteClusterSecurityGroup_614095, base: "/",
    url: url_GetDeleteClusterSecurityGroup_614096,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDeleteClusterSnapshot_614144 = ref object of OpenApiRestCall_612642
proc url_PostDeleteClusterSnapshot_614146(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDeleteClusterSnapshot_614145(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Deletes the specified manual snapshot. The snapshot must be in the <code>available</code> state, with no other users authorized to access the snapshot. </p> <p>Unlike automated snapshots, manual snapshots are retained even after you delete your cluster. Amazon Redshift does not delete your manual snapshots. You must delete manual snapshot explicitly to avoid getting charged. If other accounts are authorized to access the snapshot, you must revoke all of the authorizations before you can delete the snapshot.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_614147 = query.getOrDefault("Action")
  valid_614147 = validateParameter(valid_614147, JString, required = true,
                                 default = newJString("DeleteClusterSnapshot"))
  if valid_614147 != nil:
    section.add "Action", valid_614147
  var valid_614148 = query.getOrDefault("Version")
  valid_614148 = validateParameter(valid_614148, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_614148 != nil:
    section.add "Version", valid_614148
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614149 = header.getOrDefault("X-Amz-Signature")
  valid_614149 = validateParameter(valid_614149, JString, required = false,
                                 default = nil)
  if valid_614149 != nil:
    section.add "X-Amz-Signature", valid_614149
  var valid_614150 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614150 = validateParameter(valid_614150, JString, required = false,
                                 default = nil)
  if valid_614150 != nil:
    section.add "X-Amz-Content-Sha256", valid_614150
  var valid_614151 = header.getOrDefault("X-Amz-Date")
  valid_614151 = validateParameter(valid_614151, JString, required = false,
                                 default = nil)
  if valid_614151 != nil:
    section.add "X-Amz-Date", valid_614151
  var valid_614152 = header.getOrDefault("X-Amz-Credential")
  valid_614152 = validateParameter(valid_614152, JString, required = false,
                                 default = nil)
  if valid_614152 != nil:
    section.add "X-Amz-Credential", valid_614152
  var valid_614153 = header.getOrDefault("X-Amz-Security-Token")
  valid_614153 = validateParameter(valid_614153, JString, required = false,
                                 default = nil)
  if valid_614153 != nil:
    section.add "X-Amz-Security-Token", valid_614153
  var valid_614154 = header.getOrDefault("X-Amz-Algorithm")
  valid_614154 = validateParameter(valid_614154, JString, required = false,
                                 default = nil)
  if valid_614154 != nil:
    section.add "X-Amz-Algorithm", valid_614154
  var valid_614155 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614155 = validateParameter(valid_614155, JString, required = false,
                                 default = nil)
  if valid_614155 != nil:
    section.add "X-Amz-SignedHeaders", valid_614155
  result.add "header", section
  ## parameters in `formData` object:
  ##   SnapshotIdentifier: JString (required)
  ##                     : <p>The unique identifier of the manual snapshot to be deleted.</p> <p>Constraints: Must be the name of an existing snapshot that is in the <code>available</code>, <code>failed</code>, or <code>cancelled</code> state.</p>
  ##   SnapshotClusterIdentifier: JString
  ##                            : <p>The unique identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.</p> <p>Constraints: Must be the name of valid cluster.</p>
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `SnapshotIdentifier` field"
  var valid_614156 = formData.getOrDefault("SnapshotIdentifier")
  valid_614156 = validateParameter(valid_614156, JString, required = true,
                                 default = nil)
  if valid_614156 != nil:
    section.add "SnapshotIdentifier", valid_614156
  var valid_614157 = formData.getOrDefault("SnapshotClusterIdentifier")
  valid_614157 = validateParameter(valid_614157, JString, required = false,
                                 default = nil)
  if valid_614157 != nil:
    section.add "SnapshotClusterIdentifier", valid_614157
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614158: Call_PostDeleteClusterSnapshot_614144; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Deletes the specified manual snapshot. The snapshot must be in the <code>available</code> state, with no other users authorized to access the snapshot. </p> <p>Unlike automated snapshots, manual snapshots are retained even after you delete your cluster. Amazon Redshift does not delete your manual snapshots. You must delete manual snapshot explicitly to avoid getting charged. If other accounts are authorized to access the snapshot, you must revoke all of the authorizations before you can delete the snapshot.</p>
  ## 
  let valid = call_614158.validator(path, query, header, formData, body)
  let scheme = call_614158.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614158.url(scheme.get, call_614158.host, call_614158.base,
                         call_614158.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614158, url, valid)

proc call*(call_614159: Call_PostDeleteClusterSnapshot_614144;
          SnapshotIdentifier: string; Action: string = "DeleteClusterSnapshot";
          SnapshotClusterIdentifier: string = ""; Version: string = "2012-12-01"): Recallable =
  ## postDeleteClusterSnapshot
  ## <p>Deletes the specified manual snapshot. The snapshot must be in the <code>available</code> state, with no other users authorized to access the snapshot. </p> <p>Unlike automated snapshots, manual snapshots are retained even after you delete your cluster. Amazon Redshift does not delete your manual snapshots. You must delete manual snapshot explicitly to avoid getting charged. If other accounts are authorized to access the snapshot, you must revoke all of the authorizations before you can delete the snapshot.</p>
  ##   SnapshotIdentifier: string (required)
  ##                     : <p>The unique identifier of the manual snapshot to be deleted.</p> <p>Constraints: Must be the name of an existing snapshot that is in the <code>available</code>, <code>failed</code>, or <code>cancelled</code> state.</p>
  ##   Action: string (required)
  ##   SnapshotClusterIdentifier: string
  ##                            : <p>The unique identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.</p> <p>Constraints: Must be the name of valid cluster.</p>
  ##   Version: string (required)
  var query_614160 = newJObject()
  var formData_614161 = newJObject()
  add(formData_614161, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_614160, "Action", newJString(Action))
  add(formData_614161, "SnapshotClusterIdentifier",
      newJString(SnapshotClusterIdentifier))
  add(query_614160, "Version", newJString(Version))
  result = call_614159.call(nil, query_614160, nil, formData_614161, nil)

var postDeleteClusterSnapshot* = Call_PostDeleteClusterSnapshot_614144(
    name: "postDeleteClusterSnapshot", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteClusterSnapshot",
    validator: validate_PostDeleteClusterSnapshot_614145, base: "/",
    url: url_PostDeleteClusterSnapshot_614146,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeleteClusterSnapshot_614127 = ref object of OpenApiRestCall_612642
proc url_GetDeleteClusterSnapshot_614129(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDeleteClusterSnapshot_614128(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Deletes the specified manual snapshot. The snapshot must be in the <code>available</code> state, with no other users authorized to access the snapshot. </p> <p>Unlike automated snapshots, manual snapshots are retained even after you delete your cluster. Amazon Redshift does not delete your manual snapshots. You must delete manual snapshot explicitly to avoid getting charged. If other accounts are authorized to access the snapshot, you must revoke all of the authorizations before you can delete the snapshot.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   SnapshotIdentifier: JString (required)
  ##                     : <p>The unique identifier of the manual snapshot to be deleted.</p> <p>Constraints: Must be the name of an existing snapshot that is in the <code>available</code>, <code>failed</code>, or <code>cancelled</code> state.</p>
  ##   SnapshotClusterIdentifier: JString
  ##                            : <p>The unique identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.</p> <p>Constraints: Must be the name of valid cluster.</p>
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `SnapshotIdentifier` field"
  var valid_614130 = query.getOrDefault("SnapshotIdentifier")
  valid_614130 = validateParameter(valid_614130, JString, required = true,
                                 default = nil)
  if valid_614130 != nil:
    section.add "SnapshotIdentifier", valid_614130
  var valid_614131 = query.getOrDefault("SnapshotClusterIdentifier")
  valid_614131 = validateParameter(valid_614131, JString, required = false,
                                 default = nil)
  if valid_614131 != nil:
    section.add "SnapshotClusterIdentifier", valid_614131
  var valid_614132 = query.getOrDefault("Action")
  valid_614132 = validateParameter(valid_614132, JString, required = true,
                                 default = newJString("DeleteClusterSnapshot"))
  if valid_614132 != nil:
    section.add "Action", valid_614132
  var valid_614133 = query.getOrDefault("Version")
  valid_614133 = validateParameter(valid_614133, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_614133 != nil:
    section.add "Version", valid_614133
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614134 = header.getOrDefault("X-Amz-Signature")
  valid_614134 = validateParameter(valid_614134, JString, required = false,
                                 default = nil)
  if valid_614134 != nil:
    section.add "X-Amz-Signature", valid_614134
  var valid_614135 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614135 = validateParameter(valid_614135, JString, required = false,
                                 default = nil)
  if valid_614135 != nil:
    section.add "X-Amz-Content-Sha256", valid_614135
  var valid_614136 = header.getOrDefault("X-Amz-Date")
  valid_614136 = validateParameter(valid_614136, JString, required = false,
                                 default = nil)
  if valid_614136 != nil:
    section.add "X-Amz-Date", valid_614136
  var valid_614137 = header.getOrDefault("X-Amz-Credential")
  valid_614137 = validateParameter(valid_614137, JString, required = false,
                                 default = nil)
  if valid_614137 != nil:
    section.add "X-Amz-Credential", valid_614137
  var valid_614138 = header.getOrDefault("X-Amz-Security-Token")
  valid_614138 = validateParameter(valid_614138, JString, required = false,
                                 default = nil)
  if valid_614138 != nil:
    section.add "X-Amz-Security-Token", valid_614138
  var valid_614139 = header.getOrDefault("X-Amz-Algorithm")
  valid_614139 = validateParameter(valid_614139, JString, required = false,
                                 default = nil)
  if valid_614139 != nil:
    section.add "X-Amz-Algorithm", valid_614139
  var valid_614140 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614140 = validateParameter(valid_614140, JString, required = false,
                                 default = nil)
  if valid_614140 != nil:
    section.add "X-Amz-SignedHeaders", valid_614140
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614141: Call_GetDeleteClusterSnapshot_614127; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Deletes the specified manual snapshot. The snapshot must be in the <code>available</code> state, with no other users authorized to access the snapshot. </p> <p>Unlike automated snapshots, manual snapshots are retained even after you delete your cluster. Amazon Redshift does not delete your manual snapshots. You must delete manual snapshot explicitly to avoid getting charged. If other accounts are authorized to access the snapshot, you must revoke all of the authorizations before you can delete the snapshot.</p>
  ## 
  let valid = call_614141.validator(path, query, header, formData, body)
  let scheme = call_614141.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614141.url(scheme.get, call_614141.host, call_614141.base,
                         call_614141.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614141, url, valid)

proc call*(call_614142: Call_GetDeleteClusterSnapshot_614127;
          SnapshotIdentifier: string; SnapshotClusterIdentifier: string = "";
          Action: string = "DeleteClusterSnapshot"; Version: string = "2012-12-01"): Recallable =
  ## getDeleteClusterSnapshot
  ## <p>Deletes the specified manual snapshot. The snapshot must be in the <code>available</code> state, with no other users authorized to access the snapshot. </p> <p>Unlike automated snapshots, manual snapshots are retained even after you delete your cluster. Amazon Redshift does not delete your manual snapshots. You must delete manual snapshot explicitly to avoid getting charged. If other accounts are authorized to access the snapshot, you must revoke all of the authorizations before you can delete the snapshot.</p>
  ##   SnapshotIdentifier: string (required)
  ##                     : <p>The unique identifier of the manual snapshot to be deleted.</p> <p>Constraints: Must be the name of an existing snapshot that is in the <code>available</code>, <code>failed</code>, or <code>cancelled</code> state.</p>
  ##   SnapshotClusterIdentifier: string
  ##                            : <p>The unique identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.</p> <p>Constraints: Must be the name of valid cluster.</p>
  ##   Action: string (required)
  ##   Version: string (required)
  var query_614143 = newJObject()
  add(query_614143, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_614143, "SnapshotClusterIdentifier",
      newJString(SnapshotClusterIdentifier))
  add(query_614143, "Action", newJString(Action))
  add(query_614143, "Version", newJString(Version))
  result = call_614142.call(nil, query_614143, nil, nil, nil)

var getDeleteClusterSnapshot* = Call_GetDeleteClusterSnapshot_614127(
    name: "getDeleteClusterSnapshot", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteClusterSnapshot",
    validator: validate_GetDeleteClusterSnapshot_614128, base: "/",
    url: url_GetDeleteClusterSnapshot_614129, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDeleteClusterSubnetGroup_614178 = ref object of OpenApiRestCall_612642
proc url_PostDeleteClusterSubnetGroup_614180(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDeleteClusterSubnetGroup_614179(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes the specified cluster subnet group.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_614181 = query.getOrDefault("Action")
  valid_614181 = validateParameter(valid_614181, JString, required = true, default = newJString(
      "DeleteClusterSubnetGroup"))
  if valid_614181 != nil:
    section.add "Action", valid_614181
  var valid_614182 = query.getOrDefault("Version")
  valid_614182 = validateParameter(valid_614182, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_614182 != nil:
    section.add "Version", valid_614182
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614183 = header.getOrDefault("X-Amz-Signature")
  valid_614183 = validateParameter(valid_614183, JString, required = false,
                                 default = nil)
  if valid_614183 != nil:
    section.add "X-Amz-Signature", valid_614183
  var valid_614184 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614184 = validateParameter(valid_614184, JString, required = false,
                                 default = nil)
  if valid_614184 != nil:
    section.add "X-Amz-Content-Sha256", valid_614184
  var valid_614185 = header.getOrDefault("X-Amz-Date")
  valid_614185 = validateParameter(valid_614185, JString, required = false,
                                 default = nil)
  if valid_614185 != nil:
    section.add "X-Amz-Date", valid_614185
  var valid_614186 = header.getOrDefault("X-Amz-Credential")
  valid_614186 = validateParameter(valid_614186, JString, required = false,
                                 default = nil)
  if valid_614186 != nil:
    section.add "X-Amz-Credential", valid_614186
  var valid_614187 = header.getOrDefault("X-Amz-Security-Token")
  valid_614187 = validateParameter(valid_614187, JString, required = false,
                                 default = nil)
  if valid_614187 != nil:
    section.add "X-Amz-Security-Token", valid_614187
  var valid_614188 = header.getOrDefault("X-Amz-Algorithm")
  valid_614188 = validateParameter(valid_614188, JString, required = false,
                                 default = nil)
  if valid_614188 != nil:
    section.add "X-Amz-Algorithm", valid_614188
  var valid_614189 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614189 = validateParameter(valid_614189, JString, required = false,
                                 default = nil)
  if valid_614189 != nil:
    section.add "X-Amz-SignedHeaders", valid_614189
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterSubnetGroupName: JString (required)
  ##                         : The name of the cluster subnet group name to be deleted.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterSubnetGroupName` field"
  var valid_614190 = formData.getOrDefault("ClusterSubnetGroupName")
  valid_614190 = validateParameter(valid_614190, JString, required = true,
                                 default = nil)
  if valid_614190 != nil:
    section.add "ClusterSubnetGroupName", valid_614190
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614191: Call_PostDeleteClusterSubnetGroup_614178; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes the specified cluster subnet group.
  ## 
  let valid = call_614191.validator(path, query, header, formData, body)
  let scheme = call_614191.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614191.url(scheme.get, call_614191.host, call_614191.base,
                         call_614191.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614191, url, valid)

proc call*(call_614192: Call_PostDeleteClusterSubnetGroup_614178;
          ClusterSubnetGroupName: string;
          Action: string = "DeleteClusterSubnetGroup";
          Version: string = "2012-12-01"): Recallable =
  ## postDeleteClusterSubnetGroup
  ## Deletes the specified cluster subnet group.
  ##   ClusterSubnetGroupName: string (required)
  ##                         : The name of the cluster subnet group name to be deleted.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_614193 = newJObject()
  var formData_614194 = newJObject()
  add(formData_614194, "ClusterSubnetGroupName",
      newJString(ClusterSubnetGroupName))
  add(query_614193, "Action", newJString(Action))
  add(query_614193, "Version", newJString(Version))
  result = call_614192.call(nil, query_614193, nil, formData_614194, nil)

var postDeleteClusterSubnetGroup* = Call_PostDeleteClusterSubnetGroup_614178(
    name: "postDeleteClusterSubnetGroup", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteClusterSubnetGroup",
    validator: validate_PostDeleteClusterSubnetGroup_614179, base: "/",
    url: url_PostDeleteClusterSubnetGroup_614180,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeleteClusterSubnetGroup_614162 = ref object of OpenApiRestCall_612642
proc url_GetDeleteClusterSubnetGroup_614164(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDeleteClusterSubnetGroup_614163(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes the specified cluster subnet group.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ClusterSubnetGroupName: JString (required)
  ##                         : The name of the cluster subnet group name to be deleted.
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `ClusterSubnetGroupName` field"
  var valid_614165 = query.getOrDefault("ClusterSubnetGroupName")
  valid_614165 = validateParameter(valid_614165, JString, required = true,
                                 default = nil)
  if valid_614165 != nil:
    section.add "ClusterSubnetGroupName", valid_614165
  var valid_614166 = query.getOrDefault("Action")
  valid_614166 = validateParameter(valid_614166, JString, required = true, default = newJString(
      "DeleteClusterSubnetGroup"))
  if valid_614166 != nil:
    section.add "Action", valid_614166
  var valid_614167 = query.getOrDefault("Version")
  valid_614167 = validateParameter(valid_614167, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_614167 != nil:
    section.add "Version", valid_614167
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614168 = header.getOrDefault("X-Amz-Signature")
  valid_614168 = validateParameter(valid_614168, JString, required = false,
                                 default = nil)
  if valid_614168 != nil:
    section.add "X-Amz-Signature", valid_614168
  var valid_614169 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614169 = validateParameter(valid_614169, JString, required = false,
                                 default = nil)
  if valid_614169 != nil:
    section.add "X-Amz-Content-Sha256", valid_614169
  var valid_614170 = header.getOrDefault("X-Amz-Date")
  valid_614170 = validateParameter(valid_614170, JString, required = false,
                                 default = nil)
  if valid_614170 != nil:
    section.add "X-Amz-Date", valid_614170
  var valid_614171 = header.getOrDefault("X-Amz-Credential")
  valid_614171 = validateParameter(valid_614171, JString, required = false,
                                 default = nil)
  if valid_614171 != nil:
    section.add "X-Amz-Credential", valid_614171
  var valid_614172 = header.getOrDefault("X-Amz-Security-Token")
  valid_614172 = validateParameter(valid_614172, JString, required = false,
                                 default = nil)
  if valid_614172 != nil:
    section.add "X-Amz-Security-Token", valid_614172
  var valid_614173 = header.getOrDefault("X-Amz-Algorithm")
  valid_614173 = validateParameter(valid_614173, JString, required = false,
                                 default = nil)
  if valid_614173 != nil:
    section.add "X-Amz-Algorithm", valid_614173
  var valid_614174 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614174 = validateParameter(valid_614174, JString, required = false,
                                 default = nil)
  if valid_614174 != nil:
    section.add "X-Amz-SignedHeaders", valid_614174
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614175: Call_GetDeleteClusterSubnetGroup_614162; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes the specified cluster subnet group.
  ## 
  let valid = call_614175.validator(path, query, header, formData, body)
  let scheme = call_614175.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614175.url(scheme.get, call_614175.host, call_614175.base,
                         call_614175.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614175, url, valid)

proc call*(call_614176: Call_GetDeleteClusterSubnetGroup_614162;
          ClusterSubnetGroupName: string;
          Action: string = "DeleteClusterSubnetGroup";
          Version: string = "2012-12-01"): Recallable =
  ## getDeleteClusterSubnetGroup
  ## Deletes the specified cluster subnet group.
  ##   ClusterSubnetGroupName: string (required)
  ##                         : The name of the cluster subnet group name to be deleted.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_614177 = newJObject()
  add(query_614177, "ClusterSubnetGroupName", newJString(ClusterSubnetGroupName))
  add(query_614177, "Action", newJString(Action))
  add(query_614177, "Version", newJString(Version))
  result = call_614176.call(nil, query_614177, nil, nil, nil)

var getDeleteClusterSubnetGroup* = Call_GetDeleteClusterSubnetGroup_614162(
    name: "getDeleteClusterSubnetGroup", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteClusterSubnetGroup",
    validator: validate_GetDeleteClusterSubnetGroup_614163, base: "/",
    url: url_GetDeleteClusterSubnetGroup_614164,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDeleteEventSubscription_614211 = ref object of OpenApiRestCall_612642
proc url_PostDeleteEventSubscription_614213(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDeleteEventSubscription_614212(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes an Amazon Redshift event notification subscription.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_614214 = query.getOrDefault("Action")
  valid_614214 = validateParameter(valid_614214, JString, required = true, default = newJString(
      "DeleteEventSubscription"))
  if valid_614214 != nil:
    section.add "Action", valid_614214
  var valid_614215 = query.getOrDefault("Version")
  valid_614215 = validateParameter(valid_614215, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_614215 != nil:
    section.add "Version", valid_614215
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614216 = header.getOrDefault("X-Amz-Signature")
  valid_614216 = validateParameter(valid_614216, JString, required = false,
                                 default = nil)
  if valid_614216 != nil:
    section.add "X-Amz-Signature", valid_614216
  var valid_614217 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614217 = validateParameter(valid_614217, JString, required = false,
                                 default = nil)
  if valid_614217 != nil:
    section.add "X-Amz-Content-Sha256", valid_614217
  var valid_614218 = header.getOrDefault("X-Amz-Date")
  valid_614218 = validateParameter(valid_614218, JString, required = false,
                                 default = nil)
  if valid_614218 != nil:
    section.add "X-Amz-Date", valid_614218
  var valid_614219 = header.getOrDefault("X-Amz-Credential")
  valid_614219 = validateParameter(valid_614219, JString, required = false,
                                 default = nil)
  if valid_614219 != nil:
    section.add "X-Amz-Credential", valid_614219
  var valid_614220 = header.getOrDefault("X-Amz-Security-Token")
  valid_614220 = validateParameter(valid_614220, JString, required = false,
                                 default = nil)
  if valid_614220 != nil:
    section.add "X-Amz-Security-Token", valid_614220
  var valid_614221 = header.getOrDefault("X-Amz-Algorithm")
  valid_614221 = validateParameter(valid_614221, JString, required = false,
                                 default = nil)
  if valid_614221 != nil:
    section.add "X-Amz-Algorithm", valid_614221
  var valid_614222 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614222 = validateParameter(valid_614222, JString, required = false,
                                 default = nil)
  if valid_614222 != nil:
    section.add "X-Amz-SignedHeaders", valid_614222
  result.add "header", section
  ## parameters in `formData` object:
  ##   SubscriptionName: JString (required)
  ##                   : The name of the Amazon Redshift event notification subscription to be deleted.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `SubscriptionName` field"
  var valid_614223 = formData.getOrDefault("SubscriptionName")
  valid_614223 = validateParameter(valid_614223, JString, required = true,
                                 default = nil)
  if valid_614223 != nil:
    section.add "SubscriptionName", valid_614223
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614224: Call_PostDeleteEventSubscription_614211; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes an Amazon Redshift event notification subscription.
  ## 
  let valid = call_614224.validator(path, query, header, formData, body)
  let scheme = call_614224.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614224.url(scheme.get, call_614224.host, call_614224.base,
                         call_614224.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614224, url, valid)

proc call*(call_614225: Call_PostDeleteEventSubscription_614211;
          SubscriptionName: string; Action: string = "DeleteEventSubscription";
          Version: string = "2012-12-01"): Recallable =
  ## postDeleteEventSubscription
  ## Deletes an Amazon Redshift event notification subscription.
  ##   SubscriptionName: string (required)
  ##                   : The name of the Amazon Redshift event notification subscription to be deleted.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_614226 = newJObject()
  var formData_614227 = newJObject()
  add(formData_614227, "SubscriptionName", newJString(SubscriptionName))
  add(query_614226, "Action", newJString(Action))
  add(query_614226, "Version", newJString(Version))
  result = call_614225.call(nil, query_614226, nil, formData_614227, nil)

var postDeleteEventSubscription* = Call_PostDeleteEventSubscription_614211(
    name: "postDeleteEventSubscription", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteEventSubscription",
    validator: validate_PostDeleteEventSubscription_614212, base: "/",
    url: url_PostDeleteEventSubscription_614213,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeleteEventSubscription_614195 = ref object of OpenApiRestCall_612642
proc url_GetDeleteEventSubscription_614197(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDeleteEventSubscription_614196(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes an Amazon Redshift event notification subscription.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   SubscriptionName: JString (required)
  ##                   : The name of the Amazon Redshift event notification subscription to be deleted.
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `SubscriptionName` field"
  var valid_614198 = query.getOrDefault("SubscriptionName")
  valid_614198 = validateParameter(valid_614198, JString, required = true,
                                 default = nil)
  if valid_614198 != nil:
    section.add "SubscriptionName", valid_614198
  var valid_614199 = query.getOrDefault("Action")
  valid_614199 = validateParameter(valid_614199, JString, required = true, default = newJString(
      "DeleteEventSubscription"))
  if valid_614199 != nil:
    section.add "Action", valid_614199
  var valid_614200 = query.getOrDefault("Version")
  valid_614200 = validateParameter(valid_614200, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_614200 != nil:
    section.add "Version", valid_614200
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614201 = header.getOrDefault("X-Amz-Signature")
  valid_614201 = validateParameter(valid_614201, JString, required = false,
                                 default = nil)
  if valid_614201 != nil:
    section.add "X-Amz-Signature", valid_614201
  var valid_614202 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614202 = validateParameter(valid_614202, JString, required = false,
                                 default = nil)
  if valid_614202 != nil:
    section.add "X-Amz-Content-Sha256", valid_614202
  var valid_614203 = header.getOrDefault("X-Amz-Date")
  valid_614203 = validateParameter(valid_614203, JString, required = false,
                                 default = nil)
  if valid_614203 != nil:
    section.add "X-Amz-Date", valid_614203
  var valid_614204 = header.getOrDefault("X-Amz-Credential")
  valid_614204 = validateParameter(valid_614204, JString, required = false,
                                 default = nil)
  if valid_614204 != nil:
    section.add "X-Amz-Credential", valid_614204
  var valid_614205 = header.getOrDefault("X-Amz-Security-Token")
  valid_614205 = validateParameter(valid_614205, JString, required = false,
                                 default = nil)
  if valid_614205 != nil:
    section.add "X-Amz-Security-Token", valid_614205
  var valid_614206 = header.getOrDefault("X-Amz-Algorithm")
  valid_614206 = validateParameter(valid_614206, JString, required = false,
                                 default = nil)
  if valid_614206 != nil:
    section.add "X-Amz-Algorithm", valid_614206
  var valid_614207 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614207 = validateParameter(valid_614207, JString, required = false,
                                 default = nil)
  if valid_614207 != nil:
    section.add "X-Amz-SignedHeaders", valid_614207
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614208: Call_GetDeleteEventSubscription_614195; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes an Amazon Redshift event notification subscription.
  ## 
  let valid = call_614208.validator(path, query, header, formData, body)
  let scheme = call_614208.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614208.url(scheme.get, call_614208.host, call_614208.base,
                         call_614208.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614208, url, valid)

proc call*(call_614209: Call_GetDeleteEventSubscription_614195;
          SubscriptionName: string; Action: string = "DeleteEventSubscription";
          Version: string = "2012-12-01"): Recallable =
  ## getDeleteEventSubscription
  ## Deletes an Amazon Redshift event notification subscription.
  ##   SubscriptionName: string (required)
  ##                   : The name of the Amazon Redshift event notification subscription to be deleted.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_614210 = newJObject()
  add(query_614210, "SubscriptionName", newJString(SubscriptionName))
  add(query_614210, "Action", newJString(Action))
  add(query_614210, "Version", newJString(Version))
  result = call_614209.call(nil, query_614210, nil, nil, nil)

var getDeleteEventSubscription* = Call_GetDeleteEventSubscription_614195(
    name: "getDeleteEventSubscription", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteEventSubscription",
    validator: validate_GetDeleteEventSubscription_614196, base: "/",
    url: url_GetDeleteEventSubscription_614197,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDeleteHsmClientCertificate_614244 = ref object of OpenApiRestCall_612642
proc url_PostDeleteHsmClientCertificate_614246(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDeleteHsmClientCertificate_614245(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes the specified HSM client certificate.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_614247 = query.getOrDefault("Action")
  valid_614247 = validateParameter(valid_614247, JString, required = true, default = newJString(
      "DeleteHsmClientCertificate"))
  if valid_614247 != nil:
    section.add "Action", valid_614247
  var valid_614248 = query.getOrDefault("Version")
  valid_614248 = validateParameter(valid_614248, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_614248 != nil:
    section.add "Version", valid_614248
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614249 = header.getOrDefault("X-Amz-Signature")
  valid_614249 = validateParameter(valid_614249, JString, required = false,
                                 default = nil)
  if valid_614249 != nil:
    section.add "X-Amz-Signature", valid_614249
  var valid_614250 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614250 = validateParameter(valid_614250, JString, required = false,
                                 default = nil)
  if valid_614250 != nil:
    section.add "X-Amz-Content-Sha256", valid_614250
  var valid_614251 = header.getOrDefault("X-Amz-Date")
  valid_614251 = validateParameter(valid_614251, JString, required = false,
                                 default = nil)
  if valid_614251 != nil:
    section.add "X-Amz-Date", valid_614251
  var valid_614252 = header.getOrDefault("X-Amz-Credential")
  valid_614252 = validateParameter(valid_614252, JString, required = false,
                                 default = nil)
  if valid_614252 != nil:
    section.add "X-Amz-Credential", valid_614252
  var valid_614253 = header.getOrDefault("X-Amz-Security-Token")
  valid_614253 = validateParameter(valid_614253, JString, required = false,
                                 default = nil)
  if valid_614253 != nil:
    section.add "X-Amz-Security-Token", valid_614253
  var valid_614254 = header.getOrDefault("X-Amz-Algorithm")
  valid_614254 = validateParameter(valid_614254, JString, required = false,
                                 default = nil)
  if valid_614254 != nil:
    section.add "X-Amz-Algorithm", valid_614254
  var valid_614255 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614255 = validateParameter(valid_614255, JString, required = false,
                                 default = nil)
  if valid_614255 != nil:
    section.add "X-Amz-SignedHeaders", valid_614255
  result.add "header", section
  ## parameters in `formData` object:
  ##   HsmClientCertificateIdentifier: JString (required)
  ##                                 : The identifier of the HSM client certificate to be deleted.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `HsmClientCertificateIdentifier` field"
  var valid_614256 = formData.getOrDefault("HsmClientCertificateIdentifier")
  valid_614256 = validateParameter(valid_614256, JString, required = true,
                                 default = nil)
  if valid_614256 != nil:
    section.add "HsmClientCertificateIdentifier", valid_614256
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614257: Call_PostDeleteHsmClientCertificate_614244; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes the specified HSM client certificate.
  ## 
  let valid = call_614257.validator(path, query, header, formData, body)
  let scheme = call_614257.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614257.url(scheme.get, call_614257.host, call_614257.base,
                         call_614257.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614257, url, valid)

proc call*(call_614258: Call_PostDeleteHsmClientCertificate_614244;
          HsmClientCertificateIdentifier: string;
          Action: string = "DeleteHsmClientCertificate";
          Version: string = "2012-12-01"): Recallable =
  ## postDeleteHsmClientCertificate
  ## Deletes the specified HSM client certificate.
  ##   Action: string (required)
  ##   HsmClientCertificateIdentifier: string (required)
  ##                                 : The identifier of the HSM client certificate to be deleted.
  ##   Version: string (required)
  var query_614259 = newJObject()
  var formData_614260 = newJObject()
  add(query_614259, "Action", newJString(Action))
  add(formData_614260, "HsmClientCertificateIdentifier",
      newJString(HsmClientCertificateIdentifier))
  add(query_614259, "Version", newJString(Version))
  result = call_614258.call(nil, query_614259, nil, formData_614260, nil)

var postDeleteHsmClientCertificate* = Call_PostDeleteHsmClientCertificate_614244(
    name: "postDeleteHsmClientCertificate", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteHsmClientCertificate",
    validator: validate_PostDeleteHsmClientCertificate_614245, base: "/",
    url: url_PostDeleteHsmClientCertificate_614246,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeleteHsmClientCertificate_614228 = ref object of OpenApiRestCall_612642
proc url_GetDeleteHsmClientCertificate_614230(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDeleteHsmClientCertificate_614229(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes the specified HSM client certificate.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   HsmClientCertificateIdentifier: JString (required)
  ##                                 : The identifier of the HSM client certificate to be deleted.
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `HsmClientCertificateIdentifier` field"
  var valid_614231 = query.getOrDefault("HsmClientCertificateIdentifier")
  valid_614231 = validateParameter(valid_614231, JString, required = true,
                                 default = nil)
  if valid_614231 != nil:
    section.add "HsmClientCertificateIdentifier", valid_614231
  var valid_614232 = query.getOrDefault("Action")
  valid_614232 = validateParameter(valid_614232, JString, required = true, default = newJString(
      "DeleteHsmClientCertificate"))
  if valid_614232 != nil:
    section.add "Action", valid_614232
  var valid_614233 = query.getOrDefault("Version")
  valid_614233 = validateParameter(valid_614233, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_614233 != nil:
    section.add "Version", valid_614233
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614234 = header.getOrDefault("X-Amz-Signature")
  valid_614234 = validateParameter(valid_614234, JString, required = false,
                                 default = nil)
  if valid_614234 != nil:
    section.add "X-Amz-Signature", valid_614234
  var valid_614235 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614235 = validateParameter(valid_614235, JString, required = false,
                                 default = nil)
  if valid_614235 != nil:
    section.add "X-Amz-Content-Sha256", valid_614235
  var valid_614236 = header.getOrDefault("X-Amz-Date")
  valid_614236 = validateParameter(valid_614236, JString, required = false,
                                 default = nil)
  if valid_614236 != nil:
    section.add "X-Amz-Date", valid_614236
  var valid_614237 = header.getOrDefault("X-Amz-Credential")
  valid_614237 = validateParameter(valid_614237, JString, required = false,
                                 default = nil)
  if valid_614237 != nil:
    section.add "X-Amz-Credential", valid_614237
  var valid_614238 = header.getOrDefault("X-Amz-Security-Token")
  valid_614238 = validateParameter(valid_614238, JString, required = false,
                                 default = nil)
  if valid_614238 != nil:
    section.add "X-Amz-Security-Token", valid_614238
  var valid_614239 = header.getOrDefault("X-Amz-Algorithm")
  valid_614239 = validateParameter(valid_614239, JString, required = false,
                                 default = nil)
  if valid_614239 != nil:
    section.add "X-Amz-Algorithm", valid_614239
  var valid_614240 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614240 = validateParameter(valid_614240, JString, required = false,
                                 default = nil)
  if valid_614240 != nil:
    section.add "X-Amz-SignedHeaders", valid_614240
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614241: Call_GetDeleteHsmClientCertificate_614228; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes the specified HSM client certificate.
  ## 
  let valid = call_614241.validator(path, query, header, formData, body)
  let scheme = call_614241.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614241.url(scheme.get, call_614241.host, call_614241.base,
                         call_614241.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614241, url, valid)

proc call*(call_614242: Call_GetDeleteHsmClientCertificate_614228;
          HsmClientCertificateIdentifier: string;
          Action: string = "DeleteHsmClientCertificate";
          Version: string = "2012-12-01"): Recallable =
  ## getDeleteHsmClientCertificate
  ## Deletes the specified HSM client certificate.
  ##   HsmClientCertificateIdentifier: string (required)
  ##                                 : The identifier of the HSM client certificate to be deleted.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_614243 = newJObject()
  add(query_614243, "HsmClientCertificateIdentifier",
      newJString(HsmClientCertificateIdentifier))
  add(query_614243, "Action", newJString(Action))
  add(query_614243, "Version", newJString(Version))
  result = call_614242.call(nil, query_614243, nil, nil, nil)

var getDeleteHsmClientCertificate* = Call_GetDeleteHsmClientCertificate_614228(
    name: "getDeleteHsmClientCertificate", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteHsmClientCertificate",
    validator: validate_GetDeleteHsmClientCertificate_614229, base: "/",
    url: url_GetDeleteHsmClientCertificate_614230,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDeleteHsmConfiguration_614277 = ref object of OpenApiRestCall_612642
proc url_PostDeleteHsmConfiguration_614279(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDeleteHsmConfiguration_614278(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes the specified Amazon Redshift HSM configuration.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_614280 = query.getOrDefault("Action")
  valid_614280 = validateParameter(valid_614280, JString, required = true,
                                 default = newJString("DeleteHsmConfiguration"))
  if valid_614280 != nil:
    section.add "Action", valid_614280
  var valid_614281 = query.getOrDefault("Version")
  valid_614281 = validateParameter(valid_614281, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_614281 != nil:
    section.add "Version", valid_614281
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614282 = header.getOrDefault("X-Amz-Signature")
  valid_614282 = validateParameter(valid_614282, JString, required = false,
                                 default = nil)
  if valid_614282 != nil:
    section.add "X-Amz-Signature", valid_614282
  var valid_614283 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614283 = validateParameter(valid_614283, JString, required = false,
                                 default = nil)
  if valid_614283 != nil:
    section.add "X-Amz-Content-Sha256", valid_614283
  var valid_614284 = header.getOrDefault("X-Amz-Date")
  valid_614284 = validateParameter(valid_614284, JString, required = false,
                                 default = nil)
  if valid_614284 != nil:
    section.add "X-Amz-Date", valid_614284
  var valid_614285 = header.getOrDefault("X-Amz-Credential")
  valid_614285 = validateParameter(valid_614285, JString, required = false,
                                 default = nil)
  if valid_614285 != nil:
    section.add "X-Amz-Credential", valid_614285
  var valid_614286 = header.getOrDefault("X-Amz-Security-Token")
  valid_614286 = validateParameter(valid_614286, JString, required = false,
                                 default = nil)
  if valid_614286 != nil:
    section.add "X-Amz-Security-Token", valid_614286
  var valid_614287 = header.getOrDefault("X-Amz-Algorithm")
  valid_614287 = validateParameter(valid_614287, JString, required = false,
                                 default = nil)
  if valid_614287 != nil:
    section.add "X-Amz-Algorithm", valid_614287
  var valid_614288 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614288 = validateParameter(valid_614288, JString, required = false,
                                 default = nil)
  if valid_614288 != nil:
    section.add "X-Amz-SignedHeaders", valid_614288
  result.add "header", section
  ## parameters in `formData` object:
  ##   HsmConfigurationIdentifier: JString (required)
  ##                             : The identifier of the Amazon Redshift HSM configuration to be deleted.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `HsmConfigurationIdentifier` field"
  var valid_614289 = formData.getOrDefault("HsmConfigurationIdentifier")
  valid_614289 = validateParameter(valid_614289, JString, required = true,
                                 default = nil)
  if valid_614289 != nil:
    section.add "HsmConfigurationIdentifier", valid_614289
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614290: Call_PostDeleteHsmConfiguration_614277; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes the specified Amazon Redshift HSM configuration.
  ## 
  let valid = call_614290.validator(path, query, header, formData, body)
  let scheme = call_614290.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614290.url(scheme.get, call_614290.host, call_614290.base,
                         call_614290.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614290, url, valid)

proc call*(call_614291: Call_PostDeleteHsmConfiguration_614277;
          HsmConfigurationIdentifier: string;
          Action: string = "DeleteHsmConfiguration"; Version: string = "2012-12-01"): Recallable =
  ## postDeleteHsmConfiguration
  ## Deletes the specified Amazon Redshift HSM configuration.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   HsmConfigurationIdentifier: string (required)
  ##                             : The identifier of the Amazon Redshift HSM configuration to be deleted.
  var query_614292 = newJObject()
  var formData_614293 = newJObject()
  add(query_614292, "Action", newJString(Action))
  add(query_614292, "Version", newJString(Version))
  add(formData_614293, "HsmConfigurationIdentifier",
      newJString(HsmConfigurationIdentifier))
  result = call_614291.call(nil, query_614292, nil, formData_614293, nil)

var postDeleteHsmConfiguration* = Call_PostDeleteHsmConfiguration_614277(
    name: "postDeleteHsmConfiguration", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteHsmConfiguration",
    validator: validate_PostDeleteHsmConfiguration_614278, base: "/",
    url: url_PostDeleteHsmConfiguration_614279,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeleteHsmConfiguration_614261 = ref object of OpenApiRestCall_612642
proc url_GetDeleteHsmConfiguration_614263(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDeleteHsmConfiguration_614262(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes the specified Amazon Redshift HSM configuration.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   HsmConfigurationIdentifier: JString (required)
  ##                             : The identifier of the Amazon Redshift HSM configuration to be deleted.
  ##   Version: JString (required)
  section = newJObject()
  var valid_614264 = query.getOrDefault("Action")
  valid_614264 = validateParameter(valid_614264, JString, required = true,
                                 default = newJString("DeleteHsmConfiguration"))
  if valid_614264 != nil:
    section.add "Action", valid_614264
  var valid_614265 = query.getOrDefault("HsmConfigurationIdentifier")
  valid_614265 = validateParameter(valid_614265, JString, required = true,
                                 default = nil)
  if valid_614265 != nil:
    section.add "HsmConfigurationIdentifier", valid_614265
  var valid_614266 = query.getOrDefault("Version")
  valid_614266 = validateParameter(valid_614266, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_614266 != nil:
    section.add "Version", valid_614266
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614267 = header.getOrDefault("X-Amz-Signature")
  valid_614267 = validateParameter(valid_614267, JString, required = false,
                                 default = nil)
  if valid_614267 != nil:
    section.add "X-Amz-Signature", valid_614267
  var valid_614268 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614268 = validateParameter(valid_614268, JString, required = false,
                                 default = nil)
  if valid_614268 != nil:
    section.add "X-Amz-Content-Sha256", valid_614268
  var valid_614269 = header.getOrDefault("X-Amz-Date")
  valid_614269 = validateParameter(valid_614269, JString, required = false,
                                 default = nil)
  if valid_614269 != nil:
    section.add "X-Amz-Date", valid_614269
  var valid_614270 = header.getOrDefault("X-Amz-Credential")
  valid_614270 = validateParameter(valid_614270, JString, required = false,
                                 default = nil)
  if valid_614270 != nil:
    section.add "X-Amz-Credential", valid_614270
  var valid_614271 = header.getOrDefault("X-Amz-Security-Token")
  valid_614271 = validateParameter(valid_614271, JString, required = false,
                                 default = nil)
  if valid_614271 != nil:
    section.add "X-Amz-Security-Token", valid_614271
  var valid_614272 = header.getOrDefault("X-Amz-Algorithm")
  valid_614272 = validateParameter(valid_614272, JString, required = false,
                                 default = nil)
  if valid_614272 != nil:
    section.add "X-Amz-Algorithm", valid_614272
  var valid_614273 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614273 = validateParameter(valid_614273, JString, required = false,
                                 default = nil)
  if valid_614273 != nil:
    section.add "X-Amz-SignedHeaders", valid_614273
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614274: Call_GetDeleteHsmConfiguration_614261; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes the specified Amazon Redshift HSM configuration.
  ## 
  let valid = call_614274.validator(path, query, header, formData, body)
  let scheme = call_614274.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614274.url(scheme.get, call_614274.host, call_614274.base,
                         call_614274.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614274, url, valid)

proc call*(call_614275: Call_GetDeleteHsmConfiguration_614261;
          HsmConfigurationIdentifier: string;
          Action: string = "DeleteHsmConfiguration"; Version: string = "2012-12-01"): Recallable =
  ## getDeleteHsmConfiguration
  ## Deletes the specified Amazon Redshift HSM configuration.
  ##   Action: string (required)
  ##   HsmConfigurationIdentifier: string (required)
  ##                             : The identifier of the Amazon Redshift HSM configuration to be deleted.
  ##   Version: string (required)
  var query_614276 = newJObject()
  add(query_614276, "Action", newJString(Action))
  add(query_614276, "HsmConfigurationIdentifier",
      newJString(HsmConfigurationIdentifier))
  add(query_614276, "Version", newJString(Version))
  result = call_614275.call(nil, query_614276, nil, nil, nil)

var getDeleteHsmConfiguration* = Call_GetDeleteHsmConfiguration_614261(
    name: "getDeleteHsmConfiguration", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteHsmConfiguration",
    validator: validate_GetDeleteHsmConfiguration_614262, base: "/",
    url: url_GetDeleteHsmConfiguration_614263,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDeleteScheduledAction_614310 = ref object of OpenApiRestCall_612642
proc url_PostDeleteScheduledAction_614312(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDeleteScheduledAction_614311(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a scheduled action. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_614313 = query.getOrDefault("Action")
  valid_614313 = validateParameter(valid_614313, JString, required = true,
                                 default = newJString("DeleteScheduledAction"))
  if valid_614313 != nil:
    section.add "Action", valid_614313
  var valid_614314 = query.getOrDefault("Version")
  valid_614314 = validateParameter(valid_614314, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_614314 != nil:
    section.add "Version", valid_614314
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614315 = header.getOrDefault("X-Amz-Signature")
  valid_614315 = validateParameter(valid_614315, JString, required = false,
                                 default = nil)
  if valid_614315 != nil:
    section.add "X-Amz-Signature", valid_614315
  var valid_614316 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614316 = validateParameter(valid_614316, JString, required = false,
                                 default = nil)
  if valid_614316 != nil:
    section.add "X-Amz-Content-Sha256", valid_614316
  var valid_614317 = header.getOrDefault("X-Amz-Date")
  valid_614317 = validateParameter(valid_614317, JString, required = false,
                                 default = nil)
  if valid_614317 != nil:
    section.add "X-Amz-Date", valid_614317
  var valid_614318 = header.getOrDefault("X-Amz-Credential")
  valid_614318 = validateParameter(valid_614318, JString, required = false,
                                 default = nil)
  if valid_614318 != nil:
    section.add "X-Amz-Credential", valid_614318
  var valid_614319 = header.getOrDefault("X-Amz-Security-Token")
  valid_614319 = validateParameter(valid_614319, JString, required = false,
                                 default = nil)
  if valid_614319 != nil:
    section.add "X-Amz-Security-Token", valid_614319
  var valid_614320 = header.getOrDefault("X-Amz-Algorithm")
  valid_614320 = validateParameter(valid_614320, JString, required = false,
                                 default = nil)
  if valid_614320 != nil:
    section.add "X-Amz-Algorithm", valid_614320
  var valid_614321 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614321 = validateParameter(valid_614321, JString, required = false,
                                 default = nil)
  if valid_614321 != nil:
    section.add "X-Amz-SignedHeaders", valid_614321
  result.add "header", section
  ## parameters in `formData` object:
  ##   ScheduledActionName: JString (required)
  ##                      : The name of the scheduled action to delete. 
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ScheduledActionName` field"
  var valid_614322 = formData.getOrDefault("ScheduledActionName")
  valid_614322 = validateParameter(valid_614322, JString, required = true,
                                 default = nil)
  if valid_614322 != nil:
    section.add "ScheduledActionName", valid_614322
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614323: Call_PostDeleteScheduledAction_614310; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a scheduled action. 
  ## 
  let valid = call_614323.validator(path, query, header, formData, body)
  let scheme = call_614323.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614323.url(scheme.get, call_614323.host, call_614323.base,
                         call_614323.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614323, url, valid)

proc call*(call_614324: Call_PostDeleteScheduledAction_614310;
          ScheduledActionName: string; Action: string = "DeleteScheduledAction";
          Version: string = "2012-12-01"): Recallable =
  ## postDeleteScheduledAction
  ## Deletes a scheduled action. 
  ##   ScheduledActionName: string (required)
  ##                      : The name of the scheduled action to delete. 
  ##   Action: string (required)
  ##   Version: string (required)
  var query_614325 = newJObject()
  var formData_614326 = newJObject()
  add(formData_614326, "ScheduledActionName", newJString(ScheduledActionName))
  add(query_614325, "Action", newJString(Action))
  add(query_614325, "Version", newJString(Version))
  result = call_614324.call(nil, query_614325, nil, formData_614326, nil)

var postDeleteScheduledAction* = Call_PostDeleteScheduledAction_614310(
    name: "postDeleteScheduledAction", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteScheduledAction",
    validator: validate_PostDeleteScheduledAction_614311, base: "/",
    url: url_PostDeleteScheduledAction_614312,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeleteScheduledAction_614294 = ref object of OpenApiRestCall_612642
proc url_GetDeleteScheduledAction_614296(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDeleteScheduledAction_614295(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a scheduled action. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ScheduledActionName: JString (required)
  ##                      : The name of the scheduled action to delete. 
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `ScheduledActionName` field"
  var valid_614297 = query.getOrDefault("ScheduledActionName")
  valid_614297 = validateParameter(valid_614297, JString, required = true,
                                 default = nil)
  if valid_614297 != nil:
    section.add "ScheduledActionName", valid_614297
  var valid_614298 = query.getOrDefault("Action")
  valid_614298 = validateParameter(valid_614298, JString, required = true,
                                 default = newJString("DeleteScheduledAction"))
  if valid_614298 != nil:
    section.add "Action", valid_614298
  var valid_614299 = query.getOrDefault("Version")
  valid_614299 = validateParameter(valid_614299, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_614299 != nil:
    section.add "Version", valid_614299
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614300 = header.getOrDefault("X-Amz-Signature")
  valid_614300 = validateParameter(valid_614300, JString, required = false,
                                 default = nil)
  if valid_614300 != nil:
    section.add "X-Amz-Signature", valid_614300
  var valid_614301 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614301 = validateParameter(valid_614301, JString, required = false,
                                 default = nil)
  if valid_614301 != nil:
    section.add "X-Amz-Content-Sha256", valid_614301
  var valid_614302 = header.getOrDefault("X-Amz-Date")
  valid_614302 = validateParameter(valid_614302, JString, required = false,
                                 default = nil)
  if valid_614302 != nil:
    section.add "X-Amz-Date", valid_614302
  var valid_614303 = header.getOrDefault("X-Amz-Credential")
  valid_614303 = validateParameter(valid_614303, JString, required = false,
                                 default = nil)
  if valid_614303 != nil:
    section.add "X-Amz-Credential", valid_614303
  var valid_614304 = header.getOrDefault("X-Amz-Security-Token")
  valid_614304 = validateParameter(valid_614304, JString, required = false,
                                 default = nil)
  if valid_614304 != nil:
    section.add "X-Amz-Security-Token", valid_614304
  var valid_614305 = header.getOrDefault("X-Amz-Algorithm")
  valid_614305 = validateParameter(valid_614305, JString, required = false,
                                 default = nil)
  if valid_614305 != nil:
    section.add "X-Amz-Algorithm", valid_614305
  var valid_614306 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614306 = validateParameter(valid_614306, JString, required = false,
                                 default = nil)
  if valid_614306 != nil:
    section.add "X-Amz-SignedHeaders", valid_614306
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614307: Call_GetDeleteScheduledAction_614294; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a scheduled action. 
  ## 
  let valid = call_614307.validator(path, query, header, formData, body)
  let scheme = call_614307.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614307.url(scheme.get, call_614307.host, call_614307.base,
                         call_614307.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614307, url, valid)

proc call*(call_614308: Call_GetDeleteScheduledAction_614294;
          ScheduledActionName: string; Action: string = "DeleteScheduledAction";
          Version: string = "2012-12-01"): Recallable =
  ## getDeleteScheduledAction
  ## Deletes a scheduled action. 
  ##   ScheduledActionName: string (required)
  ##                      : The name of the scheduled action to delete. 
  ##   Action: string (required)
  ##   Version: string (required)
  var query_614309 = newJObject()
  add(query_614309, "ScheduledActionName", newJString(ScheduledActionName))
  add(query_614309, "Action", newJString(Action))
  add(query_614309, "Version", newJString(Version))
  result = call_614308.call(nil, query_614309, nil, nil, nil)

var getDeleteScheduledAction* = Call_GetDeleteScheduledAction_614294(
    name: "getDeleteScheduledAction", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteScheduledAction",
    validator: validate_GetDeleteScheduledAction_614295, base: "/",
    url: url_GetDeleteScheduledAction_614296, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDeleteSnapshotCopyGrant_614343 = ref object of OpenApiRestCall_612642
proc url_PostDeleteSnapshotCopyGrant_614345(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDeleteSnapshotCopyGrant_614344(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes the specified snapshot copy grant.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_614346 = query.getOrDefault("Action")
  valid_614346 = validateParameter(valid_614346, JString, required = true, default = newJString(
      "DeleteSnapshotCopyGrant"))
  if valid_614346 != nil:
    section.add "Action", valid_614346
  var valid_614347 = query.getOrDefault("Version")
  valid_614347 = validateParameter(valid_614347, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_614347 != nil:
    section.add "Version", valid_614347
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614348 = header.getOrDefault("X-Amz-Signature")
  valid_614348 = validateParameter(valid_614348, JString, required = false,
                                 default = nil)
  if valid_614348 != nil:
    section.add "X-Amz-Signature", valid_614348
  var valid_614349 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614349 = validateParameter(valid_614349, JString, required = false,
                                 default = nil)
  if valid_614349 != nil:
    section.add "X-Amz-Content-Sha256", valid_614349
  var valid_614350 = header.getOrDefault("X-Amz-Date")
  valid_614350 = validateParameter(valid_614350, JString, required = false,
                                 default = nil)
  if valid_614350 != nil:
    section.add "X-Amz-Date", valid_614350
  var valid_614351 = header.getOrDefault("X-Amz-Credential")
  valid_614351 = validateParameter(valid_614351, JString, required = false,
                                 default = nil)
  if valid_614351 != nil:
    section.add "X-Amz-Credential", valid_614351
  var valid_614352 = header.getOrDefault("X-Amz-Security-Token")
  valid_614352 = validateParameter(valid_614352, JString, required = false,
                                 default = nil)
  if valid_614352 != nil:
    section.add "X-Amz-Security-Token", valid_614352
  var valid_614353 = header.getOrDefault("X-Amz-Algorithm")
  valid_614353 = validateParameter(valid_614353, JString, required = false,
                                 default = nil)
  if valid_614353 != nil:
    section.add "X-Amz-Algorithm", valid_614353
  var valid_614354 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614354 = validateParameter(valid_614354, JString, required = false,
                                 default = nil)
  if valid_614354 != nil:
    section.add "X-Amz-SignedHeaders", valid_614354
  result.add "header", section
  ## parameters in `formData` object:
  ##   SnapshotCopyGrantName: JString (required)
  ##                        : The name of the snapshot copy grant to delete.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `SnapshotCopyGrantName` field"
  var valid_614355 = formData.getOrDefault("SnapshotCopyGrantName")
  valid_614355 = validateParameter(valid_614355, JString, required = true,
                                 default = nil)
  if valid_614355 != nil:
    section.add "SnapshotCopyGrantName", valid_614355
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614356: Call_PostDeleteSnapshotCopyGrant_614343; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes the specified snapshot copy grant.
  ## 
  let valid = call_614356.validator(path, query, header, formData, body)
  let scheme = call_614356.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614356.url(scheme.get, call_614356.host, call_614356.base,
                         call_614356.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614356, url, valid)

proc call*(call_614357: Call_PostDeleteSnapshotCopyGrant_614343;
          SnapshotCopyGrantName: string;
          Action: string = "DeleteSnapshotCopyGrant"; Version: string = "2012-12-01"): Recallable =
  ## postDeleteSnapshotCopyGrant
  ## Deletes the specified snapshot copy grant.
  ##   Action: string (required)
  ##   SnapshotCopyGrantName: string (required)
  ##                        : The name of the snapshot copy grant to delete.
  ##   Version: string (required)
  var query_614358 = newJObject()
  var formData_614359 = newJObject()
  add(query_614358, "Action", newJString(Action))
  add(formData_614359, "SnapshotCopyGrantName", newJString(SnapshotCopyGrantName))
  add(query_614358, "Version", newJString(Version))
  result = call_614357.call(nil, query_614358, nil, formData_614359, nil)

var postDeleteSnapshotCopyGrant* = Call_PostDeleteSnapshotCopyGrant_614343(
    name: "postDeleteSnapshotCopyGrant", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteSnapshotCopyGrant",
    validator: validate_PostDeleteSnapshotCopyGrant_614344, base: "/",
    url: url_PostDeleteSnapshotCopyGrant_614345,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeleteSnapshotCopyGrant_614327 = ref object of OpenApiRestCall_612642
proc url_GetDeleteSnapshotCopyGrant_614329(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDeleteSnapshotCopyGrant_614328(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes the specified snapshot copy grant.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  ##   SnapshotCopyGrantName: JString (required)
  ##                        : The name of the snapshot copy grant to delete.
  section = newJObject()
  var valid_614330 = query.getOrDefault("Action")
  valid_614330 = validateParameter(valid_614330, JString, required = true, default = newJString(
      "DeleteSnapshotCopyGrant"))
  if valid_614330 != nil:
    section.add "Action", valid_614330
  var valid_614331 = query.getOrDefault("Version")
  valid_614331 = validateParameter(valid_614331, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_614331 != nil:
    section.add "Version", valid_614331
  var valid_614332 = query.getOrDefault("SnapshotCopyGrantName")
  valid_614332 = validateParameter(valid_614332, JString, required = true,
                                 default = nil)
  if valid_614332 != nil:
    section.add "SnapshotCopyGrantName", valid_614332
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614333 = header.getOrDefault("X-Amz-Signature")
  valid_614333 = validateParameter(valid_614333, JString, required = false,
                                 default = nil)
  if valid_614333 != nil:
    section.add "X-Amz-Signature", valid_614333
  var valid_614334 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614334 = validateParameter(valid_614334, JString, required = false,
                                 default = nil)
  if valid_614334 != nil:
    section.add "X-Amz-Content-Sha256", valid_614334
  var valid_614335 = header.getOrDefault("X-Amz-Date")
  valid_614335 = validateParameter(valid_614335, JString, required = false,
                                 default = nil)
  if valid_614335 != nil:
    section.add "X-Amz-Date", valid_614335
  var valid_614336 = header.getOrDefault("X-Amz-Credential")
  valid_614336 = validateParameter(valid_614336, JString, required = false,
                                 default = nil)
  if valid_614336 != nil:
    section.add "X-Amz-Credential", valid_614336
  var valid_614337 = header.getOrDefault("X-Amz-Security-Token")
  valid_614337 = validateParameter(valid_614337, JString, required = false,
                                 default = nil)
  if valid_614337 != nil:
    section.add "X-Amz-Security-Token", valid_614337
  var valid_614338 = header.getOrDefault("X-Amz-Algorithm")
  valid_614338 = validateParameter(valid_614338, JString, required = false,
                                 default = nil)
  if valid_614338 != nil:
    section.add "X-Amz-Algorithm", valid_614338
  var valid_614339 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614339 = validateParameter(valid_614339, JString, required = false,
                                 default = nil)
  if valid_614339 != nil:
    section.add "X-Amz-SignedHeaders", valid_614339
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614340: Call_GetDeleteSnapshotCopyGrant_614327; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes the specified snapshot copy grant.
  ## 
  let valid = call_614340.validator(path, query, header, formData, body)
  let scheme = call_614340.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614340.url(scheme.get, call_614340.host, call_614340.base,
                         call_614340.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614340, url, valid)

proc call*(call_614341: Call_GetDeleteSnapshotCopyGrant_614327;
          SnapshotCopyGrantName: string;
          Action: string = "DeleteSnapshotCopyGrant"; Version: string = "2012-12-01"): Recallable =
  ## getDeleteSnapshotCopyGrant
  ## Deletes the specified snapshot copy grant.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   SnapshotCopyGrantName: string (required)
  ##                        : The name of the snapshot copy grant to delete.
  var query_614342 = newJObject()
  add(query_614342, "Action", newJString(Action))
  add(query_614342, "Version", newJString(Version))
  add(query_614342, "SnapshotCopyGrantName", newJString(SnapshotCopyGrantName))
  result = call_614341.call(nil, query_614342, nil, nil, nil)

var getDeleteSnapshotCopyGrant* = Call_GetDeleteSnapshotCopyGrant_614327(
    name: "getDeleteSnapshotCopyGrant", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteSnapshotCopyGrant",
    validator: validate_GetDeleteSnapshotCopyGrant_614328, base: "/",
    url: url_GetDeleteSnapshotCopyGrant_614329,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDeleteSnapshotSchedule_614376 = ref object of OpenApiRestCall_612642
proc url_PostDeleteSnapshotSchedule_614378(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDeleteSnapshotSchedule_614377(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a snapshot schedule.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_614379 = query.getOrDefault("Action")
  valid_614379 = validateParameter(valid_614379, JString, required = true,
                                 default = newJString("DeleteSnapshotSchedule"))
  if valid_614379 != nil:
    section.add "Action", valid_614379
  var valid_614380 = query.getOrDefault("Version")
  valid_614380 = validateParameter(valid_614380, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_614380 != nil:
    section.add "Version", valid_614380
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614381 = header.getOrDefault("X-Amz-Signature")
  valid_614381 = validateParameter(valid_614381, JString, required = false,
                                 default = nil)
  if valid_614381 != nil:
    section.add "X-Amz-Signature", valid_614381
  var valid_614382 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614382 = validateParameter(valid_614382, JString, required = false,
                                 default = nil)
  if valid_614382 != nil:
    section.add "X-Amz-Content-Sha256", valid_614382
  var valid_614383 = header.getOrDefault("X-Amz-Date")
  valid_614383 = validateParameter(valid_614383, JString, required = false,
                                 default = nil)
  if valid_614383 != nil:
    section.add "X-Amz-Date", valid_614383
  var valid_614384 = header.getOrDefault("X-Amz-Credential")
  valid_614384 = validateParameter(valid_614384, JString, required = false,
                                 default = nil)
  if valid_614384 != nil:
    section.add "X-Amz-Credential", valid_614384
  var valid_614385 = header.getOrDefault("X-Amz-Security-Token")
  valid_614385 = validateParameter(valid_614385, JString, required = false,
                                 default = nil)
  if valid_614385 != nil:
    section.add "X-Amz-Security-Token", valid_614385
  var valid_614386 = header.getOrDefault("X-Amz-Algorithm")
  valid_614386 = validateParameter(valid_614386, JString, required = false,
                                 default = nil)
  if valid_614386 != nil:
    section.add "X-Amz-Algorithm", valid_614386
  var valid_614387 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614387 = validateParameter(valid_614387, JString, required = false,
                                 default = nil)
  if valid_614387 != nil:
    section.add "X-Amz-SignedHeaders", valid_614387
  result.add "header", section
  ## parameters in `formData` object:
  ##   ScheduleIdentifier: JString (required)
  ##                     : A unique identifier of the snapshot schedule to delete.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ScheduleIdentifier` field"
  var valid_614388 = formData.getOrDefault("ScheduleIdentifier")
  valid_614388 = validateParameter(valid_614388, JString, required = true,
                                 default = nil)
  if valid_614388 != nil:
    section.add "ScheduleIdentifier", valid_614388
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614389: Call_PostDeleteSnapshotSchedule_614376; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a snapshot schedule.
  ## 
  let valid = call_614389.validator(path, query, header, formData, body)
  let scheme = call_614389.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614389.url(scheme.get, call_614389.host, call_614389.base,
                         call_614389.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614389, url, valid)

proc call*(call_614390: Call_PostDeleteSnapshotSchedule_614376;
          ScheduleIdentifier: string; Action: string = "DeleteSnapshotSchedule";
          Version: string = "2012-12-01"): Recallable =
  ## postDeleteSnapshotSchedule
  ## Deletes a snapshot schedule.
  ##   Action: string (required)
  ##   ScheduleIdentifier: string (required)
  ##                     : A unique identifier of the snapshot schedule to delete.
  ##   Version: string (required)
  var query_614391 = newJObject()
  var formData_614392 = newJObject()
  add(query_614391, "Action", newJString(Action))
  add(formData_614392, "ScheduleIdentifier", newJString(ScheduleIdentifier))
  add(query_614391, "Version", newJString(Version))
  result = call_614390.call(nil, query_614391, nil, formData_614392, nil)

var postDeleteSnapshotSchedule* = Call_PostDeleteSnapshotSchedule_614376(
    name: "postDeleteSnapshotSchedule", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteSnapshotSchedule",
    validator: validate_PostDeleteSnapshotSchedule_614377, base: "/",
    url: url_PostDeleteSnapshotSchedule_614378,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeleteSnapshotSchedule_614360 = ref object of OpenApiRestCall_612642
proc url_GetDeleteSnapshotSchedule_614362(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDeleteSnapshotSchedule_614361(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a snapshot schedule.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ScheduleIdentifier: JString (required)
  ##                     : A unique identifier of the snapshot schedule to delete.
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `ScheduleIdentifier` field"
  var valid_614363 = query.getOrDefault("ScheduleIdentifier")
  valid_614363 = validateParameter(valid_614363, JString, required = true,
                                 default = nil)
  if valid_614363 != nil:
    section.add "ScheduleIdentifier", valid_614363
  var valid_614364 = query.getOrDefault("Action")
  valid_614364 = validateParameter(valid_614364, JString, required = true,
                                 default = newJString("DeleteSnapshotSchedule"))
  if valid_614364 != nil:
    section.add "Action", valid_614364
  var valid_614365 = query.getOrDefault("Version")
  valid_614365 = validateParameter(valid_614365, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_614365 != nil:
    section.add "Version", valid_614365
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614366 = header.getOrDefault("X-Amz-Signature")
  valid_614366 = validateParameter(valid_614366, JString, required = false,
                                 default = nil)
  if valid_614366 != nil:
    section.add "X-Amz-Signature", valid_614366
  var valid_614367 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614367 = validateParameter(valid_614367, JString, required = false,
                                 default = nil)
  if valid_614367 != nil:
    section.add "X-Amz-Content-Sha256", valid_614367
  var valid_614368 = header.getOrDefault("X-Amz-Date")
  valid_614368 = validateParameter(valid_614368, JString, required = false,
                                 default = nil)
  if valid_614368 != nil:
    section.add "X-Amz-Date", valid_614368
  var valid_614369 = header.getOrDefault("X-Amz-Credential")
  valid_614369 = validateParameter(valid_614369, JString, required = false,
                                 default = nil)
  if valid_614369 != nil:
    section.add "X-Amz-Credential", valid_614369
  var valid_614370 = header.getOrDefault("X-Amz-Security-Token")
  valid_614370 = validateParameter(valid_614370, JString, required = false,
                                 default = nil)
  if valid_614370 != nil:
    section.add "X-Amz-Security-Token", valid_614370
  var valid_614371 = header.getOrDefault("X-Amz-Algorithm")
  valid_614371 = validateParameter(valid_614371, JString, required = false,
                                 default = nil)
  if valid_614371 != nil:
    section.add "X-Amz-Algorithm", valid_614371
  var valid_614372 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614372 = validateParameter(valid_614372, JString, required = false,
                                 default = nil)
  if valid_614372 != nil:
    section.add "X-Amz-SignedHeaders", valid_614372
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614373: Call_GetDeleteSnapshotSchedule_614360; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a snapshot schedule.
  ## 
  let valid = call_614373.validator(path, query, header, formData, body)
  let scheme = call_614373.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614373.url(scheme.get, call_614373.host, call_614373.base,
                         call_614373.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614373, url, valid)

proc call*(call_614374: Call_GetDeleteSnapshotSchedule_614360;
          ScheduleIdentifier: string; Action: string = "DeleteSnapshotSchedule";
          Version: string = "2012-12-01"): Recallable =
  ## getDeleteSnapshotSchedule
  ## Deletes a snapshot schedule.
  ##   ScheduleIdentifier: string (required)
  ##                     : A unique identifier of the snapshot schedule to delete.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_614375 = newJObject()
  add(query_614375, "ScheduleIdentifier", newJString(ScheduleIdentifier))
  add(query_614375, "Action", newJString(Action))
  add(query_614375, "Version", newJString(Version))
  result = call_614374.call(nil, query_614375, nil, nil, nil)

var getDeleteSnapshotSchedule* = Call_GetDeleteSnapshotSchedule_614360(
    name: "getDeleteSnapshotSchedule", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteSnapshotSchedule",
    validator: validate_GetDeleteSnapshotSchedule_614361, base: "/",
    url: url_GetDeleteSnapshotSchedule_614362,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDeleteTags_614410 = ref object of OpenApiRestCall_612642
proc url_PostDeleteTags_614412(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDeleteTags_614411(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode): JsonNode =
  ## Deletes tags from a resource. You must provide the ARN of the resource from which you want to delete the tag or tags.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_614413 = query.getOrDefault("Action")
  valid_614413 = validateParameter(valid_614413, JString, required = true,
                                 default = newJString("DeleteTags"))
  if valid_614413 != nil:
    section.add "Action", valid_614413
  var valid_614414 = query.getOrDefault("Version")
  valid_614414 = validateParameter(valid_614414, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_614414 != nil:
    section.add "Version", valid_614414
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614415 = header.getOrDefault("X-Amz-Signature")
  valid_614415 = validateParameter(valid_614415, JString, required = false,
                                 default = nil)
  if valid_614415 != nil:
    section.add "X-Amz-Signature", valid_614415
  var valid_614416 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614416 = validateParameter(valid_614416, JString, required = false,
                                 default = nil)
  if valid_614416 != nil:
    section.add "X-Amz-Content-Sha256", valid_614416
  var valid_614417 = header.getOrDefault("X-Amz-Date")
  valid_614417 = validateParameter(valid_614417, JString, required = false,
                                 default = nil)
  if valid_614417 != nil:
    section.add "X-Amz-Date", valid_614417
  var valid_614418 = header.getOrDefault("X-Amz-Credential")
  valid_614418 = validateParameter(valid_614418, JString, required = false,
                                 default = nil)
  if valid_614418 != nil:
    section.add "X-Amz-Credential", valid_614418
  var valid_614419 = header.getOrDefault("X-Amz-Security-Token")
  valid_614419 = validateParameter(valid_614419, JString, required = false,
                                 default = nil)
  if valid_614419 != nil:
    section.add "X-Amz-Security-Token", valid_614419
  var valid_614420 = header.getOrDefault("X-Amz-Algorithm")
  valid_614420 = validateParameter(valid_614420, JString, required = false,
                                 default = nil)
  if valid_614420 != nil:
    section.add "X-Amz-Algorithm", valid_614420
  var valid_614421 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614421 = validateParameter(valid_614421, JString, required = false,
                                 default = nil)
  if valid_614421 != nil:
    section.add "X-Amz-SignedHeaders", valid_614421
  result.add "header", section
  ## parameters in `formData` object:
  ##   TagKeys: JArray (required)
  ##          : The tag key that you want to delete.
  ##   ResourceName: JString (required)
  ##               : The Amazon Resource Name (ARN) from which you want to remove the tag or tags. For example, <code>arn:aws:redshift:us-east-2:123456789:cluster:t1</code>. 
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `TagKeys` field"
  var valid_614422 = formData.getOrDefault("TagKeys")
  valid_614422 = validateParameter(valid_614422, JArray, required = true, default = nil)
  if valid_614422 != nil:
    section.add "TagKeys", valid_614422
  var valid_614423 = formData.getOrDefault("ResourceName")
  valid_614423 = validateParameter(valid_614423, JString, required = true,
                                 default = nil)
  if valid_614423 != nil:
    section.add "ResourceName", valid_614423
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614424: Call_PostDeleteTags_614410; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes tags from a resource. You must provide the ARN of the resource from which you want to delete the tag or tags.
  ## 
  let valid = call_614424.validator(path, query, header, formData, body)
  let scheme = call_614424.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614424.url(scheme.get, call_614424.host, call_614424.base,
                         call_614424.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614424, url, valid)

proc call*(call_614425: Call_PostDeleteTags_614410; TagKeys: JsonNode;
          ResourceName: string; Action: string = "DeleteTags";
          Version: string = "2012-12-01"): Recallable =
  ## postDeleteTags
  ## Deletes tags from a resource. You must provide the ARN of the resource from which you want to delete the tag or tags.
  ##   TagKeys: JArray (required)
  ##          : The tag key that you want to delete.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   ResourceName: string (required)
  ##               : The Amazon Resource Name (ARN) from which you want to remove the tag or tags. For example, <code>arn:aws:redshift:us-east-2:123456789:cluster:t1</code>. 
  var query_614426 = newJObject()
  var formData_614427 = newJObject()
  if TagKeys != nil:
    formData_614427.add "TagKeys", TagKeys
  add(query_614426, "Action", newJString(Action))
  add(query_614426, "Version", newJString(Version))
  add(formData_614427, "ResourceName", newJString(ResourceName))
  result = call_614425.call(nil, query_614426, nil, formData_614427, nil)

var postDeleteTags* = Call_PostDeleteTags_614410(name: "postDeleteTags",
    meth: HttpMethod.HttpPost, host: "redshift.amazonaws.com",
    route: "/#Action=DeleteTags", validator: validate_PostDeleteTags_614411,
    base: "/", url: url_PostDeleteTags_614412, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeleteTags_614393 = ref object of OpenApiRestCall_612642
proc url_GetDeleteTags_614395(protocol: Scheme; host: string; base: string;
                             route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDeleteTags_614394(path: JsonNode; query: JsonNode; header: JsonNode;
                                  formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes tags from a resource. You must provide the ARN of the resource from which you want to delete the tag or tags.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ResourceName: JString (required)
  ##               : The Amazon Resource Name (ARN) from which you want to remove the tag or tags. For example, <code>arn:aws:redshift:us-east-2:123456789:cluster:t1</code>. 
  ##   TagKeys: JArray (required)
  ##          : The tag key that you want to delete.
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `ResourceName` field"
  var valid_614396 = query.getOrDefault("ResourceName")
  valid_614396 = validateParameter(valid_614396, JString, required = true,
                                 default = nil)
  if valid_614396 != nil:
    section.add "ResourceName", valid_614396
  var valid_614397 = query.getOrDefault("TagKeys")
  valid_614397 = validateParameter(valid_614397, JArray, required = true, default = nil)
  if valid_614397 != nil:
    section.add "TagKeys", valid_614397
  var valid_614398 = query.getOrDefault("Action")
  valid_614398 = validateParameter(valid_614398, JString, required = true,
                                 default = newJString("DeleteTags"))
  if valid_614398 != nil:
    section.add "Action", valid_614398
  var valid_614399 = query.getOrDefault("Version")
  valid_614399 = validateParameter(valid_614399, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_614399 != nil:
    section.add "Version", valid_614399
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614400 = header.getOrDefault("X-Amz-Signature")
  valid_614400 = validateParameter(valid_614400, JString, required = false,
                                 default = nil)
  if valid_614400 != nil:
    section.add "X-Amz-Signature", valid_614400
  var valid_614401 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614401 = validateParameter(valid_614401, JString, required = false,
                                 default = nil)
  if valid_614401 != nil:
    section.add "X-Amz-Content-Sha256", valid_614401
  var valid_614402 = header.getOrDefault("X-Amz-Date")
  valid_614402 = validateParameter(valid_614402, JString, required = false,
                                 default = nil)
  if valid_614402 != nil:
    section.add "X-Amz-Date", valid_614402
  var valid_614403 = header.getOrDefault("X-Amz-Credential")
  valid_614403 = validateParameter(valid_614403, JString, required = false,
                                 default = nil)
  if valid_614403 != nil:
    section.add "X-Amz-Credential", valid_614403
  var valid_614404 = header.getOrDefault("X-Amz-Security-Token")
  valid_614404 = validateParameter(valid_614404, JString, required = false,
                                 default = nil)
  if valid_614404 != nil:
    section.add "X-Amz-Security-Token", valid_614404
  var valid_614405 = header.getOrDefault("X-Amz-Algorithm")
  valid_614405 = validateParameter(valid_614405, JString, required = false,
                                 default = nil)
  if valid_614405 != nil:
    section.add "X-Amz-Algorithm", valid_614405
  var valid_614406 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614406 = validateParameter(valid_614406, JString, required = false,
                                 default = nil)
  if valid_614406 != nil:
    section.add "X-Amz-SignedHeaders", valid_614406
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614407: Call_GetDeleteTags_614393; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes tags from a resource. You must provide the ARN of the resource from which you want to delete the tag or tags.
  ## 
  let valid = call_614407.validator(path, query, header, formData, body)
  let scheme = call_614407.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614407.url(scheme.get, call_614407.host, call_614407.base,
                         call_614407.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614407, url, valid)

proc call*(call_614408: Call_GetDeleteTags_614393; ResourceName: string;
          TagKeys: JsonNode; Action: string = "DeleteTags";
          Version: string = "2012-12-01"): Recallable =
  ## getDeleteTags
  ## Deletes tags from a resource. You must provide the ARN of the resource from which you want to delete the tag or tags.
  ##   ResourceName: string (required)
  ##               : The Amazon Resource Name (ARN) from which you want to remove the tag or tags. For example, <code>arn:aws:redshift:us-east-2:123456789:cluster:t1</code>. 
  ##   TagKeys: JArray (required)
  ##          : The tag key that you want to delete.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_614409 = newJObject()
  add(query_614409, "ResourceName", newJString(ResourceName))
  if TagKeys != nil:
    query_614409.add "TagKeys", TagKeys
  add(query_614409, "Action", newJString(Action))
  add(query_614409, "Version", newJString(Version))
  result = call_614408.call(nil, query_614409, nil, nil, nil)

var getDeleteTags* = Call_GetDeleteTags_614393(name: "getDeleteTags",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=DeleteTags", validator: validate_GetDeleteTags_614394,
    base: "/", url: url_GetDeleteTags_614395, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeAccountAttributes_614444 = ref object of OpenApiRestCall_612642
proc url_PostDescribeAccountAttributes_614446(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeAccountAttributes_614445(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns a list of attributes attached to an account
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_614447 = query.getOrDefault("Action")
  valid_614447 = validateParameter(valid_614447, JString, required = true, default = newJString(
      "DescribeAccountAttributes"))
  if valid_614447 != nil:
    section.add "Action", valid_614447
  var valid_614448 = query.getOrDefault("Version")
  valid_614448 = validateParameter(valid_614448, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_614448 != nil:
    section.add "Version", valid_614448
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614449 = header.getOrDefault("X-Amz-Signature")
  valid_614449 = validateParameter(valid_614449, JString, required = false,
                                 default = nil)
  if valid_614449 != nil:
    section.add "X-Amz-Signature", valid_614449
  var valid_614450 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614450 = validateParameter(valid_614450, JString, required = false,
                                 default = nil)
  if valid_614450 != nil:
    section.add "X-Amz-Content-Sha256", valid_614450
  var valid_614451 = header.getOrDefault("X-Amz-Date")
  valid_614451 = validateParameter(valid_614451, JString, required = false,
                                 default = nil)
  if valid_614451 != nil:
    section.add "X-Amz-Date", valid_614451
  var valid_614452 = header.getOrDefault("X-Amz-Credential")
  valid_614452 = validateParameter(valid_614452, JString, required = false,
                                 default = nil)
  if valid_614452 != nil:
    section.add "X-Amz-Credential", valid_614452
  var valid_614453 = header.getOrDefault("X-Amz-Security-Token")
  valid_614453 = validateParameter(valid_614453, JString, required = false,
                                 default = nil)
  if valid_614453 != nil:
    section.add "X-Amz-Security-Token", valid_614453
  var valid_614454 = header.getOrDefault("X-Amz-Algorithm")
  valid_614454 = validateParameter(valid_614454, JString, required = false,
                                 default = nil)
  if valid_614454 != nil:
    section.add "X-Amz-Algorithm", valid_614454
  var valid_614455 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614455 = validateParameter(valid_614455, JString, required = false,
                                 default = nil)
  if valid_614455 != nil:
    section.add "X-Amz-SignedHeaders", valid_614455
  result.add "header", section
  ## parameters in `formData` object:
  ##   AttributeNames: JArray
  ##                 : A list of attribute names.
  section = newJObject()
  var valid_614456 = formData.getOrDefault("AttributeNames")
  valid_614456 = validateParameter(valid_614456, JArray, required = false,
                                 default = nil)
  if valid_614456 != nil:
    section.add "AttributeNames", valid_614456
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614457: Call_PostDescribeAccountAttributes_614444; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns a list of attributes attached to an account
  ## 
  let valid = call_614457.validator(path, query, header, formData, body)
  let scheme = call_614457.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614457.url(scheme.get, call_614457.host, call_614457.base,
                         call_614457.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614457, url, valid)

proc call*(call_614458: Call_PostDescribeAccountAttributes_614444;
          AttributeNames: JsonNode = nil;
          Action: string = "DescribeAccountAttributes";
          Version: string = "2012-12-01"): Recallable =
  ## postDescribeAccountAttributes
  ## Returns a list of attributes attached to an account
  ##   AttributeNames: JArray
  ##                 : A list of attribute names.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_614459 = newJObject()
  var formData_614460 = newJObject()
  if AttributeNames != nil:
    formData_614460.add "AttributeNames", AttributeNames
  add(query_614459, "Action", newJString(Action))
  add(query_614459, "Version", newJString(Version))
  result = call_614458.call(nil, query_614459, nil, formData_614460, nil)

var postDescribeAccountAttributes* = Call_PostDescribeAccountAttributes_614444(
    name: "postDescribeAccountAttributes", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeAccountAttributes",
    validator: validate_PostDescribeAccountAttributes_614445, base: "/",
    url: url_PostDescribeAccountAttributes_614446,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeAccountAttributes_614428 = ref object of OpenApiRestCall_612642
proc url_GetDescribeAccountAttributes_614430(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeAccountAttributes_614429(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns a list of attributes attached to an account
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   AttributeNames: JArray
  ##                 : A list of attribute names.
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_614431 = query.getOrDefault("AttributeNames")
  valid_614431 = validateParameter(valid_614431, JArray, required = false,
                                 default = nil)
  if valid_614431 != nil:
    section.add "AttributeNames", valid_614431
  var valid_614432 = query.getOrDefault("Action")
  valid_614432 = validateParameter(valid_614432, JString, required = true, default = newJString(
      "DescribeAccountAttributes"))
  if valid_614432 != nil:
    section.add "Action", valid_614432
  var valid_614433 = query.getOrDefault("Version")
  valid_614433 = validateParameter(valid_614433, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_614433 != nil:
    section.add "Version", valid_614433
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614434 = header.getOrDefault("X-Amz-Signature")
  valid_614434 = validateParameter(valid_614434, JString, required = false,
                                 default = nil)
  if valid_614434 != nil:
    section.add "X-Amz-Signature", valid_614434
  var valid_614435 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614435 = validateParameter(valid_614435, JString, required = false,
                                 default = nil)
  if valid_614435 != nil:
    section.add "X-Amz-Content-Sha256", valid_614435
  var valid_614436 = header.getOrDefault("X-Amz-Date")
  valid_614436 = validateParameter(valid_614436, JString, required = false,
                                 default = nil)
  if valid_614436 != nil:
    section.add "X-Amz-Date", valid_614436
  var valid_614437 = header.getOrDefault("X-Amz-Credential")
  valid_614437 = validateParameter(valid_614437, JString, required = false,
                                 default = nil)
  if valid_614437 != nil:
    section.add "X-Amz-Credential", valid_614437
  var valid_614438 = header.getOrDefault("X-Amz-Security-Token")
  valid_614438 = validateParameter(valid_614438, JString, required = false,
                                 default = nil)
  if valid_614438 != nil:
    section.add "X-Amz-Security-Token", valid_614438
  var valid_614439 = header.getOrDefault("X-Amz-Algorithm")
  valid_614439 = validateParameter(valid_614439, JString, required = false,
                                 default = nil)
  if valid_614439 != nil:
    section.add "X-Amz-Algorithm", valid_614439
  var valid_614440 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614440 = validateParameter(valid_614440, JString, required = false,
                                 default = nil)
  if valid_614440 != nil:
    section.add "X-Amz-SignedHeaders", valid_614440
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614441: Call_GetDescribeAccountAttributes_614428; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns a list of attributes attached to an account
  ## 
  let valid = call_614441.validator(path, query, header, formData, body)
  let scheme = call_614441.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614441.url(scheme.get, call_614441.host, call_614441.base,
                         call_614441.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614441, url, valid)

proc call*(call_614442: Call_GetDescribeAccountAttributes_614428;
          AttributeNames: JsonNode = nil;
          Action: string = "DescribeAccountAttributes";
          Version: string = "2012-12-01"): Recallable =
  ## getDescribeAccountAttributes
  ## Returns a list of attributes attached to an account
  ##   AttributeNames: JArray
  ##                 : A list of attribute names.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_614443 = newJObject()
  if AttributeNames != nil:
    query_614443.add "AttributeNames", AttributeNames
  add(query_614443, "Action", newJString(Action))
  add(query_614443, "Version", newJString(Version))
  result = call_614442.call(nil, query_614443, nil, nil, nil)

var getDescribeAccountAttributes* = Call_GetDescribeAccountAttributes_614428(
    name: "getDescribeAccountAttributes", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeAccountAttributes",
    validator: validate_GetDescribeAccountAttributes_614429, base: "/",
    url: url_GetDescribeAccountAttributes_614430,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeClusterDbRevisions_614479 = ref object of OpenApiRestCall_612642
proc url_PostDescribeClusterDbRevisions_614481(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeClusterDbRevisions_614480(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns an array of <code>ClusterDbRevision</code> objects.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_614482 = query.getOrDefault("Action")
  valid_614482 = validateParameter(valid_614482, JString, required = true, default = newJString(
      "DescribeClusterDbRevisions"))
  if valid_614482 != nil:
    section.add "Action", valid_614482
  var valid_614483 = query.getOrDefault("Version")
  valid_614483 = validateParameter(valid_614483, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_614483 != nil:
    section.add "Version", valid_614483
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614484 = header.getOrDefault("X-Amz-Signature")
  valid_614484 = validateParameter(valid_614484, JString, required = false,
                                 default = nil)
  if valid_614484 != nil:
    section.add "X-Amz-Signature", valid_614484
  var valid_614485 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614485 = validateParameter(valid_614485, JString, required = false,
                                 default = nil)
  if valid_614485 != nil:
    section.add "X-Amz-Content-Sha256", valid_614485
  var valid_614486 = header.getOrDefault("X-Amz-Date")
  valid_614486 = validateParameter(valid_614486, JString, required = false,
                                 default = nil)
  if valid_614486 != nil:
    section.add "X-Amz-Date", valid_614486
  var valid_614487 = header.getOrDefault("X-Amz-Credential")
  valid_614487 = validateParameter(valid_614487, JString, required = false,
                                 default = nil)
  if valid_614487 != nil:
    section.add "X-Amz-Credential", valid_614487
  var valid_614488 = header.getOrDefault("X-Amz-Security-Token")
  valid_614488 = validateParameter(valid_614488, JString, required = false,
                                 default = nil)
  if valid_614488 != nil:
    section.add "X-Amz-Security-Token", valid_614488
  var valid_614489 = header.getOrDefault("X-Amz-Algorithm")
  valid_614489 = validateParameter(valid_614489, JString, required = false,
                                 default = nil)
  if valid_614489 != nil:
    section.add "X-Amz-Algorithm", valid_614489
  var valid_614490 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614490 = validateParameter(valid_614490, JString, required = false,
                                 default = nil)
  if valid_614490 != nil:
    section.add "X-Amz-SignedHeaders", valid_614490
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString
  ##                    : A unique identifier for a cluster whose <code>ClusterDbRevisions</code> you are requesting. This parameter is case sensitive. All clusters defined for an account are returned by default.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified MaxRecords value, a value is returned in the <code>marker</code> field of the response. You can retrieve the next set of response records by providing the returned <code>marker</code> value in the <code>marker</code> parameter and retrying the request. </p> <p>Default: 100</p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: JString
  ##         : <p>An optional parameter that specifies the starting point for returning a set of response records. When the results of a <code>DescribeClusterDbRevisions</code> request exceed the value specified in <code>MaxRecords</code>, Amazon Redshift returns a value in the <code>marker</code> field of the response. You can retrieve the next set of response records by providing the returned <code>marker</code> value in the <code>marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <code>ClusterIdentifier</code> parameter, or the <code>marker</code> parameter, but not both.</p>
  section = newJObject()
  var valid_614491 = formData.getOrDefault("ClusterIdentifier")
  valid_614491 = validateParameter(valid_614491, JString, required = false,
                                 default = nil)
  if valid_614491 != nil:
    section.add "ClusterIdentifier", valid_614491
  var valid_614492 = formData.getOrDefault("MaxRecords")
  valid_614492 = validateParameter(valid_614492, JInt, required = false, default = nil)
  if valid_614492 != nil:
    section.add "MaxRecords", valid_614492
  var valid_614493 = formData.getOrDefault("Marker")
  valid_614493 = validateParameter(valid_614493, JString, required = false,
                                 default = nil)
  if valid_614493 != nil:
    section.add "Marker", valid_614493
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614494: Call_PostDescribeClusterDbRevisions_614479; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns an array of <code>ClusterDbRevision</code> objects.
  ## 
  let valid = call_614494.validator(path, query, header, formData, body)
  let scheme = call_614494.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614494.url(scheme.get, call_614494.host, call_614494.base,
                         call_614494.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614494, url, valid)

proc call*(call_614495: Call_PostDescribeClusterDbRevisions_614479;
          ClusterIdentifier: string = ""; MaxRecords: int = 0; Marker: string = "";
          Action: string = "DescribeClusterDbRevisions";
          Version: string = "2012-12-01"): Recallable =
  ## postDescribeClusterDbRevisions
  ## Returns an array of <code>ClusterDbRevision</code> objects.
  ##   ClusterIdentifier: string
  ##                    : A unique identifier for a cluster whose <code>ClusterDbRevisions</code> you are requesting. This parameter is case sensitive. All clusters defined for an account are returned by default.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified MaxRecords value, a value is returned in the <code>marker</code> field of the response. You can retrieve the next set of response records by providing the returned <code>marker</code> value in the <code>marker</code> parameter and retrying the request. </p> <p>Default: 100</p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: string
  ##         : <p>An optional parameter that specifies the starting point for returning a set of response records. When the results of a <code>DescribeClusterDbRevisions</code> request exceed the value specified in <code>MaxRecords</code>, Amazon Redshift returns a value in the <code>marker</code> field of the response. You can retrieve the next set of response records by providing the returned <code>marker</code> value in the <code>marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <code>ClusterIdentifier</code> parameter, or the <code>marker</code> parameter, but not both.</p>
  ##   Action: string (required)
  ##   Version: string (required)
  var query_614496 = newJObject()
  var formData_614497 = newJObject()
  add(formData_614497, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_614497, "MaxRecords", newJInt(MaxRecords))
  add(formData_614497, "Marker", newJString(Marker))
  add(query_614496, "Action", newJString(Action))
  add(query_614496, "Version", newJString(Version))
  result = call_614495.call(nil, query_614496, nil, formData_614497, nil)

var postDescribeClusterDbRevisions* = Call_PostDescribeClusterDbRevisions_614479(
    name: "postDescribeClusterDbRevisions", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusterDbRevisions",
    validator: validate_PostDescribeClusterDbRevisions_614480, base: "/",
    url: url_PostDescribeClusterDbRevisions_614481,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeClusterDbRevisions_614461 = ref object of OpenApiRestCall_612642
proc url_GetDescribeClusterDbRevisions_614463(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeClusterDbRevisions_614462(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns an array of <code>ClusterDbRevision</code> objects.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Marker: JString
  ##         : <p>An optional parameter that specifies the starting point for returning a set of response records. When the results of a <code>DescribeClusterDbRevisions</code> request exceed the value specified in <code>MaxRecords</code>, Amazon Redshift returns a value in the <code>marker</code> field of the response. You can retrieve the next set of response records by providing the returned <code>marker</code> value in the <code>marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <code>ClusterIdentifier</code> parameter, or the <code>marker</code> parameter, but not both.</p>
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString
  ##                    : A unique identifier for a cluster whose <code>ClusterDbRevisions</code> you are requesting. This parameter is case sensitive. All clusters defined for an account are returned by default.
  ##   Version: JString (required)
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified MaxRecords value, a value is returned in the <code>marker</code> field of the response. You can retrieve the next set of response records by providing the returned <code>marker</code> value in the <code>marker</code> parameter and retrying the request. </p> <p>Default: 100</p> <p>Constraints: minimum 20, maximum 100.</p>
  section = newJObject()
  var valid_614464 = query.getOrDefault("Marker")
  valid_614464 = validateParameter(valid_614464, JString, required = false,
                                 default = nil)
  if valid_614464 != nil:
    section.add "Marker", valid_614464
  var valid_614465 = query.getOrDefault("Action")
  valid_614465 = validateParameter(valid_614465, JString, required = true, default = newJString(
      "DescribeClusterDbRevisions"))
  if valid_614465 != nil:
    section.add "Action", valid_614465
  var valid_614466 = query.getOrDefault("ClusterIdentifier")
  valid_614466 = validateParameter(valid_614466, JString, required = false,
                                 default = nil)
  if valid_614466 != nil:
    section.add "ClusterIdentifier", valid_614466
  var valid_614467 = query.getOrDefault("Version")
  valid_614467 = validateParameter(valid_614467, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_614467 != nil:
    section.add "Version", valid_614467
  var valid_614468 = query.getOrDefault("MaxRecords")
  valid_614468 = validateParameter(valid_614468, JInt, required = false, default = nil)
  if valid_614468 != nil:
    section.add "MaxRecords", valid_614468
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614469 = header.getOrDefault("X-Amz-Signature")
  valid_614469 = validateParameter(valid_614469, JString, required = false,
                                 default = nil)
  if valid_614469 != nil:
    section.add "X-Amz-Signature", valid_614469
  var valid_614470 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614470 = validateParameter(valid_614470, JString, required = false,
                                 default = nil)
  if valid_614470 != nil:
    section.add "X-Amz-Content-Sha256", valid_614470
  var valid_614471 = header.getOrDefault("X-Amz-Date")
  valid_614471 = validateParameter(valid_614471, JString, required = false,
                                 default = nil)
  if valid_614471 != nil:
    section.add "X-Amz-Date", valid_614471
  var valid_614472 = header.getOrDefault("X-Amz-Credential")
  valid_614472 = validateParameter(valid_614472, JString, required = false,
                                 default = nil)
  if valid_614472 != nil:
    section.add "X-Amz-Credential", valid_614472
  var valid_614473 = header.getOrDefault("X-Amz-Security-Token")
  valid_614473 = validateParameter(valid_614473, JString, required = false,
                                 default = nil)
  if valid_614473 != nil:
    section.add "X-Amz-Security-Token", valid_614473
  var valid_614474 = header.getOrDefault("X-Amz-Algorithm")
  valid_614474 = validateParameter(valid_614474, JString, required = false,
                                 default = nil)
  if valid_614474 != nil:
    section.add "X-Amz-Algorithm", valid_614474
  var valid_614475 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614475 = validateParameter(valid_614475, JString, required = false,
                                 default = nil)
  if valid_614475 != nil:
    section.add "X-Amz-SignedHeaders", valid_614475
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614476: Call_GetDescribeClusterDbRevisions_614461; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns an array of <code>ClusterDbRevision</code> objects.
  ## 
  let valid = call_614476.validator(path, query, header, formData, body)
  let scheme = call_614476.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614476.url(scheme.get, call_614476.host, call_614476.base,
                         call_614476.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614476, url, valid)

proc call*(call_614477: Call_GetDescribeClusterDbRevisions_614461;
          Marker: string = ""; Action: string = "DescribeClusterDbRevisions";
          ClusterIdentifier: string = ""; Version: string = "2012-12-01";
          MaxRecords: int = 0): Recallable =
  ## getDescribeClusterDbRevisions
  ## Returns an array of <code>ClusterDbRevision</code> objects.
  ##   Marker: string
  ##         : <p>An optional parameter that specifies the starting point for returning a set of response records. When the results of a <code>DescribeClusterDbRevisions</code> request exceed the value specified in <code>MaxRecords</code>, Amazon Redshift returns a value in the <code>marker</code> field of the response. You can retrieve the next set of response records by providing the returned <code>marker</code> value in the <code>marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <code>ClusterIdentifier</code> parameter, or the <code>marker</code> parameter, but not both.</p>
  ##   Action: string (required)
  ##   ClusterIdentifier: string
  ##                    : A unique identifier for a cluster whose <code>ClusterDbRevisions</code> you are requesting. This parameter is case sensitive. All clusters defined for an account are returned by default.
  ##   Version: string (required)
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified MaxRecords value, a value is returned in the <code>marker</code> field of the response. You can retrieve the next set of response records by providing the returned <code>marker</code> value in the <code>marker</code> parameter and retrying the request. </p> <p>Default: 100</p> <p>Constraints: minimum 20, maximum 100.</p>
  var query_614478 = newJObject()
  add(query_614478, "Marker", newJString(Marker))
  add(query_614478, "Action", newJString(Action))
  add(query_614478, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_614478, "Version", newJString(Version))
  add(query_614478, "MaxRecords", newJInt(MaxRecords))
  result = call_614477.call(nil, query_614478, nil, nil, nil)

var getDescribeClusterDbRevisions* = Call_GetDescribeClusterDbRevisions_614461(
    name: "getDescribeClusterDbRevisions", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusterDbRevisions",
    validator: validate_GetDescribeClusterDbRevisions_614462, base: "/",
    url: url_GetDescribeClusterDbRevisions_614463,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeClusterParameterGroups_614518 = ref object of OpenApiRestCall_612642
proc url_PostDescribeClusterParameterGroups_614520(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeClusterParameterGroups_614519(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns a list of Amazon Redshift parameter groups, including parameter groups you created and the default parameter group. For each parameter group, the response includes the parameter group name, description, and parameter group family name. You can optionally specify a name to retrieve the description of a specific parameter group.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all parameter groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all parameter groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, parameter groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_614521 = query.getOrDefault("Action")
  valid_614521 = validateParameter(valid_614521, JString, required = true, default = newJString(
      "DescribeClusterParameterGroups"))
  if valid_614521 != nil:
    section.add "Action", valid_614521
  var valid_614522 = query.getOrDefault("Version")
  valid_614522 = validateParameter(valid_614522, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_614522 != nil:
    section.add "Version", valid_614522
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614523 = header.getOrDefault("X-Amz-Signature")
  valid_614523 = validateParameter(valid_614523, JString, required = false,
                                 default = nil)
  if valid_614523 != nil:
    section.add "X-Amz-Signature", valid_614523
  var valid_614524 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614524 = validateParameter(valid_614524, JString, required = false,
                                 default = nil)
  if valid_614524 != nil:
    section.add "X-Amz-Content-Sha256", valid_614524
  var valid_614525 = header.getOrDefault("X-Amz-Date")
  valid_614525 = validateParameter(valid_614525, JString, required = false,
                                 default = nil)
  if valid_614525 != nil:
    section.add "X-Amz-Date", valid_614525
  var valid_614526 = header.getOrDefault("X-Amz-Credential")
  valid_614526 = validateParameter(valid_614526, JString, required = false,
                                 default = nil)
  if valid_614526 != nil:
    section.add "X-Amz-Credential", valid_614526
  var valid_614527 = header.getOrDefault("X-Amz-Security-Token")
  valid_614527 = validateParameter(valid_614527, JString, required = false,
                                 default = nil)
  if valid_614527 != nil:
    section.add "X-Amz-Security-Token", valid_614527
  var valid_614528 = header.getOrDefault("X-Amz-Algorithm")
  valid_614528 = validateParameter(valid_614528, JString, required = false,
                                 default = nil)
  if valid_614528 != nil:
    section.add "X-Amz-Algorithm", valid_614528
  var valid_614529 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614529 = validateParameter(valid_614529, JString, required = false,
                                 default = nil)
  if valid_614529 != nil:
    section.add "X-Amz-SignedHeaders", valid_614529
  result.add "header", section
  ## parameters in `formData` object:
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster parameter groups that are associated with the specified key or keys. For example, suppose that you have parameter groups that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the parameter groups that have either or both of these tag keys associated with them.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterParameterGroups</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster parameter groups that are associated with the specified tag value or values. For example, suppose that you have parameter groups that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the parameter groups that have either or both of these tag values associated with them.
  ##   ParameterGroupName: JString
  ##                     : The name of a specific parameter group for which to return details. By default, details about all parameter groups and the default parameter group are returned.
  section = newJObject()
  var valid_614530 = formData.getOrDefault("TagKeys")
  valid_614530 = validateParameter(valid_614530, JArray, required = false,
                                 default = nil)
  if valid_614530 != nil:
    section.add "TagKeys", valid_614530
  var valid_614531 = formData.getOrDefault("MaxRecords")
  valid_614531 = validateParameter(valid_614531, JInt, required = false, default = nil)
  if valid_614531 != nil:
    section.add "MaxRecords", valid_614531
  var valid_614532 = formData.getOrDefault("Marker")
  valid_614532 = validateParameter(valid_614532, JString, required = false,
                                 default = nil)
  if valid_614532 != nil:
    section.add "Marker", valid_614532
  var valid_614533 = formData.getOrDefault("TagValues")
  valid_614533 = validateParameter(valid_614533, JArray, required = false,
                                 default = nil)
  if valid_614533 != nil:
    section.add "TagValues", valid_614533
  var valid_614534 = formData.getOrDefault("ParameterGroupName")
  valid_614534 = validateParameter(valid_614534, JString, required = false,
                                 default = nil)
  if valid_614534 != nil:
    section.add "ParameterGroupName", valid_614534
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614535: Call_PostDescribeClusterParameterGroups_614518;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Returns a list of Amazon Redshift parameter groups, including parameter groups you created and the default parameter group. For each parameter group, the response includes the parameter group name, description, and parameter group family name. You can optionally specify a name to retrieve the description of a specific parameter group.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all parameter groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all parameter groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, parameter groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_614535.validator(path, query, header, formData, body)
  let scheme = call_614535.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614535.url(scheme.get, call_614535.host, call_614535.base,
                         call_614535.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614535, url, valid)

proc call*(call_614536: Call_PostDescribeClusterParameterGroups_614518;
          TagKeys: JsonNode = nil; MaxRecords: int = 0; Marker: string = "";
          TagValues: JsonNode = nil;
          Action: string = "DescribeClusterParameterGroups";
          ParameterGroupName: string = ""; Version: string = "2012-12-01"): Recallable =
  ## postDescribeClusterParameterGroups
  ## <p>Returns a list of Amazon Redshift parameter groups, including parameter groups you created and the default parameter group. For each parameter group, the response includes the parameter group name, description, and parameter group family name. You can optionally specify a name to retrieve the description of a specific parameter group.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all parameter groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all parameter groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, parameter groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster parameter groups that are associated with the specified key or keys. For example, suppose that you have parameter groups that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the parameter groups that have either or both of these tag keys associated with them.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterParameterGroups</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster parameter groups that are associated with the specified tag value or values. For example, suppose that you have parameter groups that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the parameter groups that have either or both of these tag values associated with them.
  ##   Action: string (required)
  ##   ParameterGroupName: string
  ##                     : The name of a specific parameter group for which to return details. By default, details about all parameter groups and the default parameter group are returned.
  ##   Version: string (required)
  var query_614537 = newJObject()
  var formData_614538 = newJObject()
  if TagKeys != nil:
    formData_614538.add "TagKeys", TagKeys
  add(formData_614538, "MaxRecords", newJInt(MaxRecords))
  add(formData_614538, "Marker", newJString(Marker))
  if TagValues != nil:
    formData_614538.add "TagValues", TagValues
  add(query_614537, "Action", newJString(Action))
  add(formData_614538, "ParameterGroupName", newJString(ParameterGroupName))
  add(query_614537, "Version", newJString(Version))
  result = call_614536.call(nil, query_614537, nil, formData_614538, nil)

var postDescribeClusterParameterGroups* = Call_PostDescribeClusterParameterGroups_614518(
    name: "postDescribeClusterParameterGroups", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeClusterParameterGroups",
    validator: validate_PostDescribeClusterParameterGroups_614519, base: "/",
    url: url_PostDescribeClusterParameterGroups_614520,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeClusterParameterGroups_614498 = ref object of OpenApiRestCall_612642
proc url_GetDescribeClusterParameterGroups_614500(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeClusterParameterGroups_614499(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns a list of Amazon Redshift parameter groups, including parameter groups you created and the default parameter group. For each parameter group, the response includes the parameter group name, description, and parameter group family name. You can optionally specify a name to retrieve the description of a specific parameter group.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all parameter groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all parameter groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, parameter groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterParameterGroups</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster parameter groups that are associated with the specified key or keys. For example, suppose that you have parameter groups that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the parameter groups that have either or both of these tag keys associated with them.
  ##   Action: JString (required)
  ##   ParameterGroupName: JString
  ##                     : The name of a specific parameter group for which to return details. By default, details about all parameter groups and the default parameter group are returned.
  ##   Version: JString (required)
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster parameter groups that are associated with the specified tag value or values. For example, suppose that you have parameter groups that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the parameter groups that have either or both of these tag values associated with them.
  section = newJObject()
  var valid_614501 = query.getOrDefault("Marker")
  valid_614501 = validateParameter(valid_614501, JString, required = false,
                                 default = nil)
  if valid_614501 != nil:
    section.add "Marker", valid_614501
  var valid_614502 = query.getOrDefault("TagKeys")
  valid_614502 = validateParameter(valid_614502, JArray, required = false,
                                 default = nil)
  if valid_614502 != nil:
    section.add "TagKeys", valid_614502
  var valid_614503 = query.getOrDefault("Action")
  valid_614503 = validateParameter(valid_614503, JString, required = true, default = newJString(
      "DescribeClusterParameterGroups"))
  if valid_614503 != nil:
    section.add "Action", valid_614503
  var valid_614504 = query.getOrDefault("ParameterGroupName")
  valid_614504 = validateParameter(valid_614504, JString, required = false,
                                 default = nil)
  if valid_614504 != nil:
    section.add "ParameterGroupName", valid_614504
  var valid_614505 = query.getOrDefault("Version")
  valid_614505 = validateParameter(valid_614505, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_614505 != nil:
    section.add "Version", valid_614505
  var valid_614506 = query.getOrDefault("MaxRecords")
  valid_614506 = validateParameter(valid_614506, JInt, required = false, default = nil)
  if valid_614506 != nil:
    section.add "MaxRecords", valid_614506
  var valid_614507 = query.getOrDefault("TagValues")
  valid_614507 = validateParameter(valid_614507, JArray, required = false,
                                 default = nil)
  if valid_614507 != nil:
    section.add "TagValues", valid_614507
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614508 = header.getOrDefault("X-Amz-Signature")
  valid_614508 = validateParameter(valid_614508, JString, required = false,
                                 default = nil)
  if valid_614508 != nil:
    section.add "X-Amz-Signature", valid_614508
  var valid_614509 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614509 = validateParameter(valid_614509, JString, required = false,
                                 default = nil)
  if valid_614509 != nil:
    section.add "X-Amz-Content-Sha256", valid_614509
  var valid_614510 = header.getOrDefault("X-Amz-Date")
  valid_614510 = validateParameter(valid_614510, JString, required = false,
                                 default = nil)
  if valid_614510 != nil:
    section.add "X-Amz-Date", valid_614510
  var valid_614511 = header.getOrDefault("X-Amz-Credential")
  valid_614511 = validateParameter(valid_614511, JString, required = false,
                                 default = nil)
  if valid_614511 != nil:
    section.add "X-Amz-Credential", valid_614511
  var valid_614512 = header.getOrDefault("X-Amz-Security-Token")
  valid_614512 = validateParameter(valid_614512, JString, required = false,
                                 default = nil)
  if valid_614512 != nil:
    section.add "X-Amz-Security-Token", valid_614512
  var valid_614513 = header.getOrDefault("X-Amz-Algorithm")
  valid_614513 = validateParameter(valid_614513, JString, required = false,
                                 default = nil)
  if valid_614513 != nil:
    section.add "X-Amz-Algorithm", valid_614513
  var valid_614514 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614514 = validateParameter(valid_614514, JString, required = false,
                                 default = nil)
  if valid_614514 != nil:
    section.add "X-Amz-SignedHeaders", valid_614514
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614515: Call_GetDescribeClusterParameterGroups_614498;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Returns a list of Amazon Redshift parameter groups, including parameter groups you created and the default parameter group. For each parameter group, the response includes the parameter group name, description, and parameter group family name. You can optionally specify a name to retrieve the description of a specific parameter group.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all parameter groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all parameter groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, parameter groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_614515.validator(path, query, header, formData, body)
  let scheme = call_614515.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614515.url(scheme.get, call_614515.host, call_614515.base,
                         call_614515.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614515, url, valid)

proc call*(call_614516: Call_GetDescribeClusterParameterGroups_614498;
          Marker: string = ""; TagKeys: JsonNode = nil;
          Action: string = "DescribeClusterParameterGroups";
          ParameterGroupName: string = ""; Version: string = "2012-12-01";
          MaxRecords: int = 0; TagValues: JsonNode = nil): Recallable =
  ## getDescribeClusterParameterGroups
  ## <p>Returns a list of Amazon Redshift parameter groups, including parameter groups you created and the default parameter group. For each parameter group, the response includes the parameter group name, description, and parameter group family name. You can optionally specify a name to retrieve the description of a specific parameter group.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all parameter groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all parameter groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, parameter groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterParameterGroups</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster parameter groups that are associated with the specified key or keys. For example, suppose that you have parameter groups that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the parameter groups that have either or both of these tag keys associated with them.
  ##   Action: string (required)
  ##   ParameterGroupName: string
  ##                     : The name of a specific parameter group for which to return details. By default, details about all parameter groups and the default parameter group are returned.
  ##   Version: string (required)
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster parameter groups that are associated with the specified tag value or values. For example, suppose that you have parameter groups that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the parameter groups that have either or both of these tag values associated with them.
  var query_614517 = newJObject()
  add(query_614517, "Marker", newJString(Marker))
  if TagKeys != nil:
    query_614517.add "TagKeys", TagKeys
  add(query_614517, "Action", newJString(Action))
  add(query_614517, "ParameterGroupName", newJString(ParameterGroupName))
  add(query_614517, "Version", newJString(Version))
  add(query_614517, "MaxRecords", newJInt(MaxRecords))
  if TagValues != nil:
    query_614517.add "TagValues", TagValues
  result = call_614516.call(nil, query_614517, nil, nil, nil)

var getDescribeClusterParameterGroups* = Call_GetDescribeClusterParameterGroups_614498(
    name: "getDescribeClusterParameterGroups", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeClusterParameterGroups",
    validator: validate_GetDescribeClusterParameterGroups_614499, base: "/",
    url: url_GetDescribeClusterParameterGroups_614500,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeClusterParameters_614558 = ref object of OpenApiRestCall_612642
proc url_PostDescribeClusterParameters_614560(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeClusterParameters_614559(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns a detailed list of parameters contained within the specified Amazon Redshift parameter group. For each parameter the response includes information such as parameter name, description, data type, value, whether the parameter value is modifiable, and so on.</p> <p>You can specify <i>source</i> filter to retrieve parameters of only specific type. For example, to retrieve parameters that were modified by a user action such as from <a>ModifyClusterParameterGroup</a>, you can specify <i>source</i> equal to <i>user</i>.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_614561 = query.getOrDefault("Action")
  valid_614561 = validateParameter(valid_614561, JString, required = true, default = newJString(
      "DescribeClusterParameters"))
  if valid_614561 != nil:
    section.add "Action", valid_614561
  var valid_614562 = query.getOrDefault("Version")
  valid_614562 = validateParameter(valid_614562, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_614562 != nil:
    section.add "Version", valid_614562
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614563 = header.getOrDefault("X-Amz-Signature")
  valid_614563 = validateParameter(valid_614563, JString, required = false,
                                 default = nil)
  if valid_614563 != nil:
    section.add "X-Amz-Signature", valid_614563
  var valid_614564 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614564 = validateParameter(valid_614564, JString, required = false,
                                 default = nil)
  if valid_614564 != nil:
    section.add "X-Amz-Content-Sha256", valid_614564
  var valid_614565 = header.getOrDefault("X-Amz-Date")
  valid_614565 = validateParameter(valid_614565, JString, required = false,
                                 default = nil)
  if valid_614565 != nil:
    section.add "X-Amz-Date", valid_614565
  var valid_614566 = header.getOrDefault("X-Amz-Credential")
  valid_614566 = validateParameter(valid_614566, JString, required = false,
                                 default = nil)
  if valid_614566 != nil:
    section.add "X-Amz-Credential", valid_614566
  var valid_614567 = header.getOrDefault("X-Amz-Security-Token")
  valid_614567 = validateParameter(valid_614567, JString, required = false,
                                 default = nil)
  if valid_614567 != nil:
    section.add "X-Amz-Security-Token", valid_614567
  var valid_614568 = header.getOrDefault("X-Amz-Algorithm")
  valid_614568 = validateParameter(valid_614568, JString, required = false,
                                 default = nil)
  if valid_614568 != nil:
    section.add "X-Amz-Algorithm", valid_614568
  var valid_614569 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614569 = validateParameter(valid_614569, JString, required = false,
                                 default = nil)
  if valid_614569 != nil:
    section.add "X-Amz-SignedHeaders", valid_614569
  result.add "header", section
  ## parameters in `formData` object:
  ##   Source: JString
  ##         : <p>The parameter types to return. Specify <code>user</code> to show parameters that are different form the default. Similarly, specify <code>engine-default</code> to show parameters that are the same as the default parameter group. </p> <p>Default: All parameter types returned.</p> <p>Valid Values: <code>user</code> | <code>engine-default</code> </p>
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterParameters</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   ParameterGroupName: JString (required)
  ##                     : The name of a cluster parameter group for which to return details.
  section = newJObject()
  var valid_614570 = formData.getOrDefault("Source")
  valid_614570 = validateParameter(valid_614570, JString, required = false,
                                 default = nil)
  if valid_614570 != nil:
    section.add "Source", valid_614570
  var valid_614571 = formData.getOrDefault("MaxRecords")
  valid_614571 = validateParameter(valid_614571, JInt, required = false, default = nil)
  if valid_614571 != nil:
    section.add "MaxRecords", valid_614571
  var valid_614572 = formData.getOrDefault("Marker")
  valid_614572 = validateParameter(valid_614572, JString, required = false,
                                 default = nil)
  if valid_614572 != nil:
    section.add "Marker", valid_614572
  assert formData != nil, "formData argument is necessary due to required `ParameterGroupName` field"
  var valid_614573 = formData.getOrDefault("ParameterGroupName")
  valid_614573 = validateParameter(valid_614573, JString, required = true,
                                 default = nil)
  if valid_614573 != nil:
    section.add "ParameterGroupName", valid_614573
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614574: Call_PostDescribeClusterParameters_614558; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns a detailed list of parameters contained within the specified Amazon Redshift parameter group. For each parameter the response includes information such as parameter name, description, data type, value, whether the parameter value is modifiable, and so on.</p> <p>You can specify <i>source</i> filter to retrieve parameters of only specific type. For example, to retrieve parameters that were modified by a user action such as from <a>ModifyClusterParameterGroup</a>, you can specify <i>source</i> equal to <i>user</i>.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_614574.validator(path, query, header, formData, body)
  let scheme = call_614574.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614574.url(scheme.get, call_614574.host, call_614574.base,
                         call_614574.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614574, url, valid)

proc call*(call_614575: Call_PostDescribeClusterParameters_614558;
          ParameterGroupName: string; Source: string = ""; MaxRecords: int = 0;
          Marker: string = ""; Action: string = "DescribeClusterParameters";
          Version: string = "2012-12-01"): Recallable =
  ## postDescribeClusterParameters
  ## <p>Returns a detailed list of parameters contained within the specified Amazon Redshift parameter group. For each parameter the response includes information such as parameter name, description, data type, value, whether the parameter value is modifiable, and so on.</p> <p>You can specify <i>source</i> filter to retrieve parameters of only specific type. For example, to retrieve parameters that were modified by a user action such as from <a>ModifyClusterParameterGroup</a>, you can specify <i>source</i> equal to <i>user</i>.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   Source: string
  ##         : <p>The parameter types to return. Specify <code>user</code> to show parameters that are different form the default. Similarly, specify <code>engine-default</code> to show parameters that are the same as the default parameter group. </p> <p>Default: All parameter types returned.</p> <p>Valid Values: <code>user</code> | <code>engine-default</code> </p>
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterParameters</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Action: string (required)
  ##   ParameterGroupName: string (required)
  ##                     : The name of a cluster parameter group for which to return details.
  ##   Version: string (required)
  var query_614576 = newJObject()
  var formData_614577 = newJObject()
  add(formData_614577, "Source", newJString(Source))
  add(formData_614577, "MaxRecords", newJInt(MaxRecords))
  add(formData_614577, "Marker", newJString(Marker))
  add(query_614576, "Action", newJString(Action))
  add(formData_614577, "ParameterGroupName", newJString(ParameterGroupName))
  add(query_614576, "Version", newJString(Version))
  result = call_614575.call(nil, query_614576, nil, formData_614577, nil)

var postDescribeClusterParameters* = Call_PostDescribeClusterParameters_614558(
    name: "postDescribeClusterParameters", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusterParameters",
    validator: validate_PostDescribeClusterParameters_614559, base: "/",
    url: url_PostDescribeClusterParameters_614560,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeClusterParameters_614539 = ref object of OpenApiRestCall_612642
proc url_GetDescribeClusterParameters_614541(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeClusterParameters_614540(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns a detailed list of parameters contained within the specified Amazon Redshift parameter group. For each parameter the response includes information such as parameter name, description, data type, value, whether the parameter value is modifiable, and so on.</p> <p>You can specify <i>source</i> filter to retrieve parameters of only specific type. For example, to retrieve parameters that were modified by a user action such as from <a>ModifyClusterParameterGroup</a>, you can specify <i>source</i> equal to <i>user</i>.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterParameters</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Source: JString
  ##         : <p>The parameter types to return. Specify <code>user</code> to show parameters that are different form the default. Similarly, specify <code>engine-default</code> to show parameters that are the same as the default parameter group. </p> <p>Default: All parameter types returned.</p> <p>Valid Values: <code>user</code> | <code>engine-default</code> </p>
  ##   Action: JString (required)
  ##   ParameterGroupName: JString (required)
  ##                     : The name of a cluster parameter group for which to return details.
  ##   Version: JString (required)
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  section = newJObject()
  var valid_614542 = query.getOrDefault("Marker")
  valid_614542 = validateParameter(valid_614542, JString, required = false,
                                 default = nil)
  if valid_614542 != nil:
    section.add "Marker", valid_614542
  var valid_614543 = query.getOrDefault("Source")
  valid_614543 = validateParameter(valid_614543, JString, required = false,
                                 default = nil)
  if valid_614543 != nil:
    section.add "Source", valid_614543
  var valid_614544 = query.getOrDefault("Action")
  valid_614544 = validateParameter(valid_614544, JString, required = true, default = newJString(
      "DescribeClusterParameters"))
  if valid_614544 != nil:
    section.add "Action", valid_614544
  var valid_614545 = query.getOrDefault("ParameterGroupName")
  valid_614545 = validateParameter(valid_614545, JString, required = true,
                                 default = nil)
  if valid_614545 != nil:
    section.add "ParameterGroupName", valid_614545
  var valid_614546 = query.getOrDefault("Version")
  valid_614546 = validateParameter(valid_614546, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_614546 != nil:
    section.add "Version", valid_614546
  var valid_614547 = query.getOrDefault("MaxRecords")
  valid_614547 = validateParameter(valid_614547, JInt, required = false, default = nil)
  if valid_614547 != nil:
    section.add "MaxRecords", valid_614547
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614548 = header.getOrDefault("X-Amz-Signature")
  valid_614548 = validateParameter(valid_614548, JString, required = false,
                                 default = nil)
  if valid_614548 != nil:
    section.add "X-Amz-Signature", valid_614548
  var valid_614549 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614549 = validateParameter(valid_614549, JString, required = false,
                                 default = nil)
  if valid_614549 != nil:
    section.add "X-Amz-Content-Sha256", valid_614549
  var valid_614550 = header.getOrDefault("X-Amz-Date")
  valid_614550 = validateParameter(valid_614550, JString, required = false,
                                 default = nil)
  if valid_614550 != nil:
    section.add "X-Amz-Date", valid_614550
  var valid_614551 = header.getOrDefault("X-Amz-Credential")
  valid_614551 = validateParameter(valid_614551, JString, required = false,
                                 default = nil)
  if valid_614551 != nil:
    section.add "X-Amz-Credential", valid_614551
  var valid_614552 = header.getOrDefault("X-Amz-Security-Token")
  valid_614552 = validateParameter(valid_614552, JString, required = false,
                                 default = nil)
  if valid_614552 != nil:
    section.add "X-Amz-Security-Token", valid_614552
  var valid_614553 = header.getOrDefault("X-Amz-Algorithm")
  valid_614553 = validateParameter(valid_614553, JString, required = false,
                                 default = nil)
  if valid_614553 != nil:
    section.add "X-Amz-Algorithm", valid_614553
  var valid_614554 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614554 = validateParameter(valid_614554, JString, required = false,
                                 default = nil)
  if valid_614554 != nil:
    section.add "X-Amz-SignedHeaders", valid_614554
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614555: Call_GetDescribeClusterParameters_614539; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns a detailed list of parameters contained within the specified Amazon Redshift parameter group. For each parameter the response includes information such as parameter name, description, data type, value, whether the parameter value is modifiable, and so on.</p> <p>You can specify <i>source</i> filter to retrieve parameters of only specific type. For example, to retrieve parameters that were modified by a user action such as from <a>ModifyClusterParameterGroup</a>, you can specify <i>source</i> equal to <i>user</i>.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_614555.validator(path, query, header, formData, body)
  let scheme = call_614555.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614555.url(scheme.get, call_614555.host, call_614555.base,
                         call_614555.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614555, url, valid)

proc call*(call_614556: Call_GetDescribeClusterParameters_614539;
          ParameterGroupName: string; Marker: string = ""; Source: string = "";
          Action: string = "DescribeClusterParameters";
          Version: string = "2012-12-01"; MaxRecords: int = 0): Recallable =
  ## getDescribeClusterParameters
  ## <p>Returns a detailed list of parameters contained within the specified Amazon Redshift parameter group. For each parameter the response includes information such as parameter name, description, data type, value, whether the parameter value is modifiable, and so on.</p> <p>You can specify <i>source</i> filter to retrieve parameters of only specific type. For example, to retrieve parameters that were modified by a user action such as from <a>ModifyClusterParameterGroup</a>, you can specify <i>source</i> equal to <i>user</i>.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterParameters</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Source: string
  ##         : <p>The parameter types to return. Specify <code>user</code> to show parameters that are different form the default. Similarly, specify <code>engine-default</code> to show parameters that are the same as the default parameter group. </p> <p>Default: All parameter types returned.</p> <p>Valid Values: <code>user</code> | <code>engine-default</code> </p>
  ##   Action: string (required)
  ##   ParameterGroupName: string (required)
  ##                     : The name of a cluster parameter group for which to return details.
  ##   Version: string (required)
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  var query_614557 = newJObject()
  add(query_614557, "Marker", newJString(Marker))
  add(query_614557, "Source", newJString(Source))
  add(query_614557, "Action", newJString(Action))
  add(query_614557, "ParameterGroupName", newJString(ParameterGroupName))
  add(query_614557, "Version", newJString(Version))
  add(query_614557, "MaxRecords", newJInt(MaxRecords))
  result = call_614556.call(nil, query_614557, nil, nil, nil)

var getDescribeClusterParameters* = Call_GetDescribeClusterParameters_614539(
    name: "getDescribeClusterParameters", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusterParameters",
    validator: validate_GetDescribeClusterParameters_614540, base: "/",
    url: url_GetDescribeClusterParameters_614541,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeClusterSecurityGroups_614598 = ref object of OpenApiRestCall_612642
proc url_PostDescribeClusterSecurityGroups_614600(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeClusterSecurityGroups_614599(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns information about Amazon Redshift security groups. If the name of a security group is specified, the response will contain only information about only that security group.</p> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all security groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all security groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, security groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_614601 = query.getOrDefault("Action")
  valid_614601 = validateParameter(valid_614601, JString, required = true, default = newJString(
      "DescribeClusterSecurityGroups"))
  if valid_614601 != nil:
    section.add "Action", valid_614601
  var valid_614602 = query.getOrDefault("Version")
  valid_614602 = validateParameter(valid_614602, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_614602 != nil:
    section.add "Version", valid_614602
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614603 = header.getOrDefault("X-Amz-Signature")
  valid_614603 = validateParameter(valid_614603, JString, required = false,
                                 default = nil)
  if valid_614603 != nil:
    section.add "X-Amz-Signature", valid_614603
  var valid_614604 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614604 = validateParameter(valid_614604, JString, required = false,
                                 default = nil)
  if valid_614604 != nil:
    section.add "X-Amz-Content-Sha256", valid_614604
  var valid_614605 = header.getOrDefault("X-Amz-Date")
  valid_614605 = validateParameter(valid_614605, JString, required = false,
                                 default = nil)
  if valid_614605 != nil:
    section.add "X-Amz-Date", valid_614605
  var valid_614606 = header.getOrDefault("X-Amz-Credential")
  valid_614606 = validateParameter(valid_614606, JString, required = false,
                                 default = nil)
  if valid_614606 != nil:
    section.add "X-Amz-Credential", valid_614606
  var valid_614607 = header.getOrDefault("X-Amz-Security-Token")
  valid_614607 = validateParameter(valid_614607, JString, required = false,
                                 default = nil)
  if valid_614607 != nil:
    section.add "X-Amz-Security-Token", valid_614607
  var valid_614608 = header.getOrDefault("X-Amz-Algorithm")
  valid_614608 = validateParameter(valid_614608, JString, required = false,
                                 default = nil)
  if valid_614608 != nil:
    section.add "X-Amz-Algorithm", valid_614608
  var valid_614609 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614609 = validateParameter(valid_614609, JString, required = false,
                                 default = nil)
  if valid_614609 != nil:
    section.add "X-Amz-SignedHeaders", valid_614609
  result.add "header", section
  ## parameters in `formData` object:
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster security groups that are associated with the specified key or keys. For example, suppose that you have security groups that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the security groups that have either or both of these tag keys associated with them.
  ##   ClusterSecurityGroupName: JString
  ##                           : <p>The name of a cluster security group for which you are requesting details. You can specify either the <b>Marker</b> parameter or a <b>ClusterSecurityGroupName</b> parameter, but not both. </p> <p> Example: <code>securitygroup1</code> </p>
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: JString
  ##         : <p>An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterSecurityGroups</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <b>ClusterSecurityGroupName</b> parameter or the <b>Marker</b> parameter, but not both. </p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster security groups that are associated with the specified tag value or values. For example, suppose that you have security groups that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the security groups that have either or both of these tag values associated with them.
  section = newJObject()
  var valid_614610 = formData.getOrDefault("TagKeys")
  valid_614610 = validateParameter(valid_614610, JArray, required = false,
                                 default = nil)
  if valid_614610 != nil:
    section.add "TagKeys", valid_614610
  var valid_614611 = formData.getOrDefault("ClusterSecurityGroupName")
  valid_614611 = validateParameter(valid_614611, JString, required = false,
                                 default = nil)
  if valid_614611 != nil:
    section.add "ClusterSecurityGroupName", valid_614611
  var valid_614612 = formData.getOrDefault("MaxRecords")
  valid_614612 = validateParameter(valid_614612, JInt, required = false, default = nil)
  if valid_614612 != nil:
    section.add "MaxRecords", valid_614612
  var valid_614613 = formData.getOrDefault("Marker")
  valid_614613 = validateParameter(valid_614613, JString, required = false,
                                 default = nil)
  if valid_614613 != nil:
    section.add "Marker", valid_614613
  var valid_614614 = formData.getOrDefault("TagValues")
  valid_614614 = validateParameter(valid_614614, JArray, required = false,
                                 default = nil)
  if valid_614614 != nil:
    section.add "TagValues", valid_614614
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614615: Call_PostDescribeClusterSecurityGroups_614598;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Returns information about Amazon Redshift security groups. If the name of a security group is specified, the response will contain only information about only that security group.</p> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all security groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all security groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, security groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_614615.validator(path, query, header, formData, body)
  let scheme = call_614615.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614615.url(scheme.get, call_614615.host, call_614615.base,
                         call_614615.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614615, url, valid)

proc call*(call_614616: Call_PostDescribeClusterSecurityGroups_614598;
          TagKeys: JsonNode = nil; ClusterSecurityGroupName: string = "";
          MaxRecords: int = 0; Marker: string = ""; TagValues: JsonNode = nil;
          Action: string = "DescribeClusterSecurityGroups";
          Version: string = "2012-12-01"): Recallable =
  ## postDescribeClusterSecurityGroups
  ## <p>Returns information about Amazon Redshift security groups. If the name of a security group is specified, the response will contain only information about only that security group.</p> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all security groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all security groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, security groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster security groups that are associated with the specified key or keys. For example, suppose that you have security groups that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the security groups that have either or both of these tag keys associated with them.
  ##   ClusterSecurityGroupName: string
  ##                           : <p>The name of a cluster security group for which you are requesting details. You can specify either the <b>Marker</b> parameter or a <b>ClusterSecurityGroupName</b> parameter, but not both. </p> <p> Example: <code>securitygroup1</code> </p>
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: string
  ##         : <p>An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterSecurityGroups</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <b>ClusterSecurityGroupName</b> parameter or the <b>Marker</b> parameter, but not both. </p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster security groups that are associated with the specified tag value or values. For example, suppose that you have security groups that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the security groups that have either or both of these tag values associated with them.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_614617 = newJObject()
  var formData_614618 = newJObject()
  if TagKeys != nil:
    formData_614618.add "TagKeys", TagKeys
  add(formData_614618, "ClusterSecurityGroupName",
      newJString(ClusterSecurityGroupName))
  add(formData_614618, "MaxRecords", newJInt(MaxRecords))
  add(formData_614618, "Marker", newJString(Marker))
  if TagValues != nil:
    formData_614618.add "TagValues", TagValues
  add(query_614617, "Action", newJString(Action))
  add(query_614617, "Version", newJString(Version))
  result = call_614616.call(nil, query_614617, nil, formData_614618, nil)

var postDescribeClusterSecurityGroups* = Call_PostDescribeClusterSecurityGroups_614598(
    name: "postDescribeClusterSecurityGroups", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeClusterSecurityGroups",
    validator: validate_PostDescribeClusterSecurityGroups_614599, base: "/",
    url: url_PostDescribeClusterSecurityGroups_614600,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeClusterSecurityGroups_614578 = ref object of OpenApiRestCall_612642
proc url_GetDescribeClusterSecurityGroups_614580(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeClusterSecurityGroups_614579(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns information about Amazon Redshift security groups. If the name of a security group is specified, the response will contain only information about only that security group.</p> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all security groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all security groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, security groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Marker: JString
  ##         : <p>An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterSecurityGroups</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <b>ClusterSecurityGroupName</b> parameter or the <b>Marker</b> parameter, but not both. </p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster security groups that are associated with the specified key or keys. For example, suppose that you have security groups that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the security groups that have either or both of these tag keys associated with them.
  ##   ClusterSecurityGroupName: JString
  ##                           : <p>The name of a cluster security group for which you are requesting details. You can specify either the <b>Marker</b> parameter or a <b>ClusterSecurityGroupName</b> parameter, but not both. </p> <p> Example: <code>securitygroup1</code> </p>
  ##   Action: JString (required)
  ##   Version: JString (required)
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster security groups that are associated with the specified tag value or values. For example, suppose that you have security groups that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the security groups that have either or both of these tag values associated with them.
  section = newJObject()
  var valid_614581 = query.getOrDefault("Marker")
  valid_614581 = validateParameter(valid_614581, JString, required = false,
                                 default = nil)
  if valid_614581 != nil:
    section.add "Marker", valid_614581
  var valid_614582 = query.getOrDefault("TagKeys")
  valid_614582 = validateParameter(valid_614582, JArray, required = false,
                                 default = nil)
  if valid_614582 != nil:
    section.add "TagKeys", valid_614582
  var valid_614583 = query.getOrDefault("ClusterSecurityGroupName")
  valid_614583 = validateParameter(valid_614583, JString, required = false,
                                 default = nil)
  if valid_614583 != nil:
    section.add "ClusterSecurityGroupName", valid_614583
  var valid_614584 = query.getOrDefault("Action")
  valid_614584 = validateParameter(valid_614584, JString, required = true, default = newJString(
      "DescribeClusterSecurityGroups"))
  if valid_614584 != nil:
    section.add "Action", valid_614584
  var valid_614585 = query.getOrDefault("Version")
  valid_614585 = validateParameter(valid_614585, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_614585 != nil:
    section.add "Version", valid_614585
  var valid_614586 = query.getOrDefault("MaxRecords")
  valid_614586 = validateParameter(valid_614586, JInt, required = false, default = nil)
  if valid_614586 != nil:
    section.add "MaxRecords", valid_614586
  var valid_614587 = query.getOrDefault("TagValues")
  valid_614587 = validateParameter(valid_614587, JArray, required = false,
                                 default = nil)
  if valid_614587 != nil:
    section.add "TagValues", valid_614587
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614588 = header.getOrDefault("X-Amz-Signature")
  valid_614588 = validateParameter(valid_614588, JString, required = false,
                                 default = nil)
  if valid_614588 != nil:
    section.add "X-Amz-Signature", valid_614588
  var valid_614589 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614589 = validateParameter(valid_614589, JString, required = false,
                                 default = nil)
  if valid_614589 != nil:
    section.add "X-Amz-Content-Sha256", valid_614589
  var valid_614590 = header.getOrDefault("X-Amz-Date")
  valid_614590 = validateParameter(valid_614590, JString, required = false,
                                 default = nil)
  if valid_614590 != nil:
    section.add "X-Amz-Date", valid_614590
  var valid_614591 = header.getOrDefault("X-Amz-Credential")
  valid_614591 = validateParameter(valid_614591, JString, required = false,
                                 default = nil)
  if valid_614591 != nil:
    section.add "X-Amz-Credential", valid_614591
  var valid_614592 = header.getOrDefault("X-Amz-Security-Token")
  valid_614592 = validateParameter(valid_614592, JString, required = false,
                                 default = nil)
  if valid_614592 != nil:
    section.add "X-Amz-Security-Token", valid_614592
  var valid_614593 = header.getOrDefault("X-Amz-Algorithm")
  valid_614593 = validateParameter(valid_614593, JString, required = false,
                                 default = nil)
  if valid_614593 != nil:
    section.add "X-Amz-Algorithm", valid_614593
  var valid_614594 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614594 = validateParameter(valid_614594, JString, required = false,
                                 default = nil)
  if valid_614594 != nil:
    section.add "X-Amz-SignedHeaders", valid_614594
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614595: Call_GetDescribeClusterSecurityGroups_614578;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Returns information about Amazon Redshift security groups. If the name of a security group is specified, the response will contain only information about only that security group.</p> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all security groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all security groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, security groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_614595.validator(path, query, header, formData, body)
  let scheme = call_614595.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614595.url(scheme.get, call_614595.host, call_614595.base,
                         call_614595.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614595, url, valid)

proc call*(call_614596: Call_GetDescribeClusterSecurityGroups_614578;
          Marker: string = ""; TagKeys: JsonNode = nil;
          ClusterSecurityGroupName: string = "";
          Action: string = "DescribeClusterSecurityGroups";
          Version: string = "2012-12-01"; MaxRecords: int = 0; TagValues: JsonNode = nil): Recallable =
  ## getDescribeClusterSecurityGroups
  ## <p>Returns information about Amazon Redshift security groups. If the name of a security group is specified, the response will contain only information about only that security group.</p> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all security groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all security groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, security groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   Marker: string
  ##         : <p>An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterSecurityGroups</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <b>ClusterSecurityGroupName</b> parameter or the <b>Marker</b> parameter, but not both. </p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster security groups that are associated with the specified key or keys. For example, suppose that you have security groups that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the security groups that have either or both of these tag keys associated with them.
  ##   ClusterSecurityGroupName: string
  ##                           : <p>The name of a cluster security group for which you are requesting details. You can specify either the <b>Marker</b> parameter or a <b>ClusterSecurityGroupName</b> parameter, but not both. </p> <p> Example: <code>securitygroup1</code> </p>
  ##   Action: string (required)
  ##   Version: string (required)
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster security groups that are associated with the specified tag value or values. For example, suppose that you have security groups that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the security groups that have either or both of these tag values associated with them.
  var query_614597 = newJObject()
  add(query_614597, "Marker", newJString(Marker))
  if TagKeys != nil:
    query_614597.add "TagKeys", TagKeys
  add(query_614597, "ClusterSecurityGroupName",
      newJString(ClusterSecurityGroupName))
  add(query_614597, "Action", newJString(Action))
  add(query_614597, "Version", newJString(Version))
  add(query_614597, "MaxRecords", newJInt(MaxRecords))
  if TagValues != nil:
    query_614597.add "TagValues", TagValues
  result = call_614596.call(nil, query_614597, nil, nil, nil)

var getDescribeClusterSecurityGroups* = Call_GetDescribeClusterSecurityGroups_614578(
    name: "getDescribeClusterSecurityGroups", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeClusterSecurityGroups",
    validator: validate_GetDescribeClusterSecurityGroups_614579, base: "/",
    url: url_GetDescribeClusterSecurityGroups_614580,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeClusterSnapshots_614646 = ref object of OpenApiRestCall_612642
proc url_PostDescribeClusterSnapshots_614648(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeClusterSnapshots_614647(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns one or more snapshot objects, which contain metadata about your cluster snapshots. By default, this operation returns information about all snapshots of all clusters that are owned by you AWS customer account. No information is returned for snapshots owned by inactive AWS customer accounts.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all snapshots that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all snapshots that have any combination of those values are returned. Only snapshots that you own are returned in the response; shared snapshots are not returned with the tag key and tag value request parameters.</p> <p>If both tag keys and values are omitted from the request, snapshots are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_614649 = query.getOrDefault("Action")
  valid_614649 = validateParameter(valid_614649, JString, required = true, default = newJString(
      "DescribeClusterSnapshots"))
  if valid_614649 != nil:
    section.add "Action", valid_614649
  var valid_614650 = query.getOrDefault("Version")
  valid_614650 = validateParameter(valid_614650, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_614650 != nil:
    section.add "Version", valid_614650
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614651 = header.getOrDefault("X-Amz-Signature")
  valid_614651 = validateParameter(valid_614651, JString, required = false,
                                 default = nil)
  if valid_614651 != nil:
    section.add "X-Amz-Signature", valid_614651
  var valid_614652 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614652 = validateParameter(valid_614652, JString, required = false,
                                 default = nil)
  if valid_614652 != nil:
    section.add "X-Amz-Content-Sha256", valid_614652
  var valid_614653 = header.getOrDefault("X-Amz-Date")
  valid_614653 = validateParameter(valid_614653, JString, required = false,
                                 default = nil)
  if valid_614653 != nil:
    section.add "X-Amz-Date", valid_614653
  var valid_614654 = header.getOrDefault("X-Amz-Credential")
  valid_614654 = validateParameter(valid_614654, JString, required = false,
                                 default = nil)
  if valid_614654 != nil:
    section.add "X-Amz-Credential", valid_614654
  var valid_614655 = header.getOrDefault("X-Amz-Security-Token")
  valid_614655 = validateParameter(valid_614655, JString, required = false,
                                 default = nil)
  if valid_614655 != nil:
    section.add "X-Amz-Security-Token", valid_614655
  var valid_614656 = header.getOrDefault("X-Amz-Algorithm")
  valid_614656 = validateParameter(valid_614656, JString, required = false,
                                 default = nil)
  if valid_614656 != nil:
    section.add "X-Amz-Algorithm", valid_614656
  var valid_614657 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614657 = validateParameter(valid_614657, JString, required = false,
                                 default = nil)
  if valid_614657 != nil:
    section.add "X-Amz-SignedHeaders", valid_614657
  result.add "header", section
  ## parameters in `formData` object:
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster snapshots that are associated with the specified key or keys. For example, suppose that you have snapshots that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the snapshots that have either or both of these tag keys associated with them.
  ##   ClusterIdentifier: JString
  ##                    : The identifier of the cluster which generated the requested snapshots.
  ##   SnapshotType: JString
  ##               : <p>The type of snapshots for which you are requesting information. By default, snapshots of all types are returned.</p> <p>Valid Values: <code>automated</code> | <code>manual</code> </p>
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   OwnerAccount: JString
  ##               : The AWS customer account used to create or copy the snapshot. Use this field to filter the results to snapshots owned by a particular account. To describe snapshots you own, either specify your AWS customer account, or do not specify the parameter.
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterSnapshots</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   ClusterExists: JBool
  ##                : <p>A value that indicates whether to return snapshots only for an existing cluster. You can perform table-level restore only by using a snapshot of an existing cluster, that is, a cluster that has not been deleted. Values for this parameter work as follows: </p> <ul> <li> <p>If <code>ClusterExists</code> is set to <code>true</code>, <code>ClusterIdentifier</code> is required.</p> </li> <li> <p>If <code>ClusterExists</code> is set to <code>false</code> and <code>ClusterIdentifier</code> isn't specified, all snapshots associated with deleted clusters (orphaned snapshots) are returned. </p> </li> <li> <p>If <code>ClusterExists</code> is set to <code>false</code> and <code>ClusterIdentifier</code> is specified for a deleted cluster, snapshots associated with that cluster are returned.</p> </li> <li> <p>If <code>ClusterExists</code> is set to <code>false</code> and <code>ClusterIdentifier</code> is specified for an existing cluster, no snapshots are returned. </p> </li> </ul>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster snapshots that are associated with the specified tag value or values. For example, suppose that you have snapshots that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the snapshots that have either or both of these tag values associated with them.
  ##   EndTime: JString
  ##          : <p>A time value that requests only snapshots created at or before the specified time. The time value is specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2012-07-16T18:00:00Z</code> </p>
  ##   StartTime: JString
  ##            : <p>A value that requests only snapshots created at or after the specified time. The time value is specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2012-07-16T18:00:00Z</code> </p>
  ##   SnapshotIdentifier: JString
  ##                     : The snapshot identifier of the snapshot about which to return information.
  ##   SortingEntities: JArray
  ##                  : <p/>
  section = newJObject()
  var valid_614658 = formData.getOrDefault("TagKeys")
  valid_614658 = validateParameter(valid_614658, JArray, required = false,
                                 default = nil)
  if valid_614658 != nil:
    section.add "TagKeys", valid_614658
  var valid_614659 = formData.getOrDefault("ClusterIdentifier")
  valid_614659 = validateParameter(valid_614659, JString, required = false,
                                 default = nil)
  if valid_614659 != nil:
    section.add "ClusterIdentifier", valid_614659
  var valid_614660 = formData.getOrDefault("SnapshotType")
  valid_614660 = validateParameter(valid_614660, JString, required = false,
                                 default = nil)
  if valid_614660 != nil:
    section.add "SnapshotType", valid_614660
  var valid_614661 = formData.getOrDefault("MaxRecords")
  valid_614661 = validateParameter(valid_614661, JInt, required = false, default = nil)
  if valid_614661 != nil:
    section.add "MaxRecords", valid_614661
  var valid_614662 = formData.getOrDefault("OwnerAccount")
  valid_614662 = validateParameter(valid_614662, JString, required = false,
                                 default = nil)
  if valid_614662 != nil:
    section.add "OwnerAccount", valid_614662
  var valid_614663 = formData.getOrDefault("Marker")
  valid_614663 = validateParameter(valid_614663, JString, required = false,
                                 default = nil)
  if valid_614663 != nil:
    section.add "Marker", valid_614663
  var valid_614664 = formData.getOrDefault("ClusterExists")
  valid_614664 = validateParameter(valid_614664, JBool, required = false, default = nil)
  if valid_614664 != nil:
    section.add "ClusterExists", valid_614664
  var valid_614665 = formData.getOrDefault("TagValues")
  valid_614665 = validateParameter(valid_614665, JArray, required = false,
                                 default = nil)
  if valid_614665 != nil:
    section.add "TagValues", valid_614665
  var valid_614666 = formData.getOrDefault("EndTime")
  valid_614666 = validateParameter(valid_614666, JString, required = false,
                                 default = nil)
  if valid_614666 != nil:
    section.add "EndTime", valid_614666
  var valid_614667 = formData.getOrDefault("StartTime")
  valid_614667 = validateParameter(valid_614667, JString, required = false,
                                 default = nil)
  if valid_614667 != nil:
    section.add "StartTime", valid_614667
  var valid_614668 = formData.getOrDefault("SnapshotIdentifier")
  valid_614668 = validateParameter(valid_614668, JString, required = false,
                                 default = nil)
  if valid_614668 != nil:
    section.add "SnapshotIdentifier", valid_614668
  var valid_614669 = formData.getOrDefault("SortingEntities")
  valid_614669 = validateParameter(valid_614669, JArray, required = false,
                                 default = nil)
  if valid_614669 != nil:
    section.add "SortingEntities", valid_614669
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614670: Call_PostDescribeClusterSnapshots_614646; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns one or more snapshot objects, which contain metadata about your cluster snapshots. By default, this operation returns information about all snapshots of all clusters that are owned by you AWS customer account. No information is returned for snapshots owned by inactive AWS customer accounts.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all snapshots that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all snapshots that have any combination of those values are returned. Only snapshots that you own are returned in the response; shared snapshots are not returned with the tag key and tag value request parameters.</p> <p>If both tag keys and values are omitted from the request, snapshots are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_614670.validator(path, query, header, formData, body)
  let scheme = call_614670.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614670.url(scheme.get, call_614670.host, call_614670.base,
                         call_614670.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614670, url, valid)

proc call*(call_614671: Call_PostDescribeClusterSnapshots_614646;
          TagKeys: JsonNode = nil; ClusterIdentifier: string = "";
          SnapshotType: string = ""; MaxRecords: int = 0; OwnerAccount: string = "";
          Marker: string = ""; ClusterExists: bool = false; TagValues: JsonNode = nil;
          EndTime: string = ""; StartTime: string = ""; SnapshotIdentifier: string = "";
          Action: string = "DescribeClusterSnapshots";
          SortingEntities: JsonNode = nil; Version: string = "2012-12-01"): Recallable =
  ## postDescribeClusterSnapshots
  ## <p>Returns one or more snapshot objects, which contain metadata about your cluster snapshots. By default, this operation returns information about all snapshots of all clusters that are owned by you AWS customer account. No information is returned for snapshots owned by inactive AWS customer accounts.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all snapshots that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all snapshots that have any combination of those values are returned. Only snapshots that you own are returned in the response; shared snapshots are not returned with the tag key and tag value request parameters.</p> <p>If both tag keys and values are omitted from the request, snapshots are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster snapshots that are associated with the specified key or keys. For example, suppose that you have snapshots that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the snapshots that have either or both of these tag keys associated with them.
  ##   ClusterIdentifier: string
  ##                    : The identifier of the cluster which generated the requested snapshots.
  ##   SnapshotType: string
  ##               : <p>The type of snapshots for which you are requesting information. By default, snapshots of all types are returned.</p> <p>Valid Values: <code>automated</code> | <code>manual</code> </p>
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   OwnerAccount: string
  ##               : The AWS customer account used to create or copy the snapshot. Use this field to filter the results to snapshots owned by a particular account. To describe snapshots you own, either specify your AWS customer account, or do not specify the parameter.
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterSnapshots</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   ClusterExists: bool
  ##                : <p>A value that indicates whether to return snapshots only for an existing cluster. You can perform table-level restore only by using a snapshot of an existing cluster, that is, a cluster that has not been deleted. Values for this parameter work as follows: </p> <ul> <li> <p>If <code>ClusterExists</code> is set to <code>true</code>, <code>ClusterIdentifier</code> is required.</p> </li> <li> <p>If <code>ClusterExists</code> is set to <code>false</code> and <code>ClusterIdentifier</code> isn't specified, all snapshots associated with deleted clusters (orphaned snapshots) are returned. </p> </li> <li> <p>If <code>ClusterExists</code> is set to <code>false</code> and <code>ClusterIdentifier</code> is specified for a deleted cluster, snapshots associated with that cluster are returned.</p> </li> <li> <p>If <code>ClusterExists</code> is set to <code>false</code> and <code>ClusterIdentifier</code> is specified for an existing cluster, no snapshots are returned. </p> </li> </ul>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster snapshots that are associated with the specified tag value or values. For example, suppose that you have snapshots that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the snapshots that have either or both of these tag values associated with them.
  ##   EndTime: string
  ##          : <p>A time value that requests only snapshots created at or before the specified time. The time value is specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2012-07-16T18:00:00Z</code> </p>
  ##   StartTime: string
  ##            : <p>A value that requests only snapshots created at or after the specified time. The time value is specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2012-07-16T18:00:00Z</code> </p>
  ##   SnapshotIdentifier: string
  ##                     : The snapshot identifier of the snapshot about which to return information.
  ##   Action: string (required)
  ##   SortingEntities: JArray
  ##                  : <p/>
  ##   Version: string (required)
  var query_614672 = newJObject()
  var formData_614673 = newJObject()
  if TagKeys != nil:
    formData_614673.add "TagKeys", TagKeys
  add(formData_614673, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_614673, "SnapshotType", newJString(SnapshotType))
  add(formData_614673, "MaxRecords", newJInt(MaxRecords))
  add(formData_614673, "OwnerAccount", newJString(OwnerAccount))
  add(formData_614673, "Marker", newJString(Marker))
  add(formData_614673, "ClusterExists", newJBool(ClusterExists))
  if TagValues != nil:
    formData_614673.add "TagValues", TagValues
  add(formData_614673, "EndTime", newJString(EndTime))
  add(formData_614673, "StartTime", newJString(StartTime))
  add(formData_614673, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_614672, "Action", newJString(Action))
  if SortingEntities != nil:
    formData_614673.add "SortingEntities", SortingEntities
  add(query_614672, "Version", newJString(Version))
  result = call_614671.call(nil, query_614672, nil, formData_614673, nil)

var postDescribeClusterSnapshots* = Call_PostDescribeClusterSnapshots_614646(
    name: "postDescribeClusterSnapshots", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusterSnapshots",
    validator: validate_PostDescribeClusterSnapshots_614647, base: "/",
    url: url_PostDescribeClusterSnapshots_614648,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeClusterSnapshots_614619 = ref object of OpenApiRestCall_612642
proc url_GetDescribeClusterSnapshots_614621(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeClusterSnapshots_614620(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns one or more snapshot objects, which contain metadata about your cluster snapshots. By default, this operation returns information about all snapshots of all clusters that are owned by you AWS customer account. No information is returned for snapshots owned by inactive AWS customer accounts.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all snapshots that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all snapshots that have any combination of those values are returned. Only snapshots that you own are returned in the response; shared snapshots are not returned with the tag key and tag value request parameters.</p> <p>If both tag keys and values are omitted from the request, snapshots are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterSnapshots</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   SortingEntities: JArray
  ##                  : <p/>
  ##   SnapshotIdentifier: JString
  ##                     : The snapshot identifier of the snapshot about which to return information.
  ##   ClusterExists: JBool
  ##                : <p>A value that indicates whether to return snapshots only for an existing cluster. You can perform table-level restore only by using a snapshot of an existing cluster, that is, a cluster that has not been deleted. Values for this parameter work as follows: </p> <ul> <li> <p>If <code>ClusterExists</code> is set to <code>true</code>, <code>ClusterIdentifier</code> is required.</p> </li> <li> <p>If <code>ClusterExists</code> is set to <code>false</code> and <code>ClusterIdentifier</code> isn't specified, all snapshots associated with deleted clusters (orphaned snapshots) are returned. </p> </li> <li> <p>If <code>ClusterExists</code> is set to <code>false</code> and <code>ClusterIdentifier</code> is specified for a deleted cluster, snapshots associated with that cluster are returned.</p> </li> <li> <p>If <code>ClusterExists</code> is set to <code>false</code> and <code>ClusterIdentifier</code> is specified for an existing cluster, no snapshots are returned. </p> </li> </ul>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster snapshots that are associated with the specified key or keys. For example, suppose that you have snapshots that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the snapshots that have either or both of these tag keys associated with them.
  ##   SnapshotType: JString
  ##               : <p>The type of snapshots for which you are requesting information. By default, snapshots of all types are returned.</p> <p>Valid Values: <code>automated</code> | <code>manual</code> </p>
  ##   Action: JString (required)
  ##   StartTime: JString
  ##            : <p>A value that requests only snapshots created at or after the specified time. The time value is specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2012-07-16T18:00:00Z</code> </p>
  ##   ClusterIdentifier: JString
  ##                    : The identifier of the cluster which generated the requested snapshots.
  ##   EndTime: JString
  ##          : <p>A time value that requests only snapshots created at or before the specified time. The time value is specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2012-07-16T18:00:00Z</code> </p>
  ##   OwnerAccount: JString
  ##               : The AWS customer account used to create or copy the snapshot. Use this field to filter the results to snapshots owned by a particular account. To describe snapshots you own, either specify your AWS customer account, or do not specify the parameter.
  ##   Version: JString (required)
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster snapshots that are associated with the specified tag value or values. For example, suppose that you have snapshots that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the snapshots that have either or both of these tag values associated with them.
  section = newJObject()
  var valid_614622 = query.getOrDefault("Marker")
  valid_614622 = validateParameter(valid_614622, JString, required = false,
                                 default = nil)
  if valid_614622 != nil:
    section.add "Marker", valid_614622
  var valid_614623 = query.getOrDefault("SortingEntities")
  valid_614623 = validateParameter(valid_614623, JArray, required = false,
                                 default = nil)
  if valid_614623 != nil:
    section.add "SortingEntities", valid_614623
  var valid_614624 = query.getOrDefault("SnapshotIdentifier")
  valid_614624 = validateParameter(valid_614624, JString, required = false,
                                 default = nil)
  if valid_614624 != nil:
    section.add "SnapshotIdentifier", valid_614624
  var valid_614625 = query.getOrDefault("ClusterExists")
  valid_614625 = validateParameter(valid_614625, JBool, required = false, default = nil)
  if valid_614625 != nil:
    section.add "ClusterExists", valid_614625
  var valid_614626 = query.getOrDefault("TagKeys")
  valid_614626 = validateParameter(valid_614626, JArray, required = false,
                                 default = nil)
  if valid_614626 != nil:
    section.add "TagKeys", valid_614626
  var valid_614627 = query.getOrDefault("SnapshotType")
  valid_614627 = validateParameter(valid_614627, JString, required = false,
                                 default = nil)
  if valid_614627 != nil:
    section.add "SnapshotType", valid_614627
  var valid_614628 = query.getOrDefault("Action")
  valid_614628 = validateParameter(valid_614628, JString, required = true, default = newJString(
      "DescribeClusterSnapshots"))
  if valid_614628 != nil:
    section.add "Action", valid_614628
  var valid_614629 = query.getOrDefault("StartTime")
  valid_614629 = validateParameter(valid_614629, JString, required = false,
                                 default = nil)
  if valid_614629 != nil:
    section.add "StartTime", valid_614629
  var valid_614630 = query.getOrDefault("ClusterIdentifier")
  valid_614630 = validateParameter(valid_614630, JString, required = false,
                                 default = nil)
  if valid_614630 != nil:
    section.add "ClusterIdentifier", valid_614630
  var valid_614631 = query.getOrDefault("EndTime")
  valid_614631 = validateParameter(valid_614631, JString, required = false,
                                 default = nil)
  if valid_614631 != nil:
    section.add "EndTime", valid_614631
  var valid_614632 = query.getOrDefault("OwnerAccount")
  valid_614632 = validateParameter(valid_614632, JString, required = false,
                                 default = nil)
  if valid_614632 != nil:
    section.add "OwnerAccount", valid_614632
  var valid_614633 = query.getOrDefault("Version")
  valid_614633 = validateParameter(valid_614633, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_614633 != nil:
    section.add "Version", valid_614633
  var valid_614634 = query.getOrDefault("MaxRecords")
  valid_614634 = validateParameter(valid_614634, JInt, required = false, default = nil)
  if valid_614634 != nil:
    section.add "MaxRecords", valid_614634
  var valid_614635 = query.getOrDefault("TagValues")
  valid_614635 = validateParameter(valid_614635, JArray, required = false,
                                 default = nil)
  if valid_614635 != nil:
    section.add "TagValues", valid_614635
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614636 = header.getOrDefault("X-Amz-Signature")
  valid_614636 = validateParameter(valid_614636, JString, required = false,
                                 default = nil)
  if valid_614636 != nil:
    section.add "X-Amz-Signature", valid_614636
  var valid_614637 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614637 = validateParameter(valid_614637, JString, required = false,
                                 default = nil)
  if valid_614637 != nil:
    section.add "X-Amz-Content-Sha256", valid_614637
  var valid_614638 = header.getOrDefault("X-Amz-Date")
  valid_614638 = validateParameter(valid_614638, JString, required = false,
                                 default = nil)
  if valid_614638 != nil:
    section.add "X-Amz-Date", valid_614638
  var valid_614639 = header.getOrDefault("X-Amz-Credential")
  valid_614639 = validateParameter(valid_614639, JString, required = false,
                                 default = nil)
  if valid_614639 != nil:
    section.add "X-Amz-Credential", valid_614639
  var valid_614640 = header.getOrDefault("X-Amz-Security-Token")
  valid_614640 = validateParameter(valid_614640, JString, required = false,
                                 default = nil)
  if valid_614640 != nil:
    section.add "X-Amz-Security-Token", valid_614640
  var valid_614641 = header.getOrDefault("X-Amz-Algorithm")
  valid_614641 = validateParameter(valid_614641, JString, required = false,
                                 default = nil)
  if valid_614641 != nil:
    section.add "X-Amz-Algorithm", valid_614641
  var valid_614642 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614642 = validateParameter(valid_614642, JString, required = false,
                                 default = nil)
  if valid_614642 != nil:
    section.add "X-Amz-SignedHeaders", valid_614642
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614643: Call_GetDescribeClusterSnapshots_614619; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns one or more snapshot objects, which contain metadata about your cluster snapshots. By default, this operation returns information about all snapshots of all clusters that are owned by you AWS customer account. No information is returned for snapshots owned by inactive AWS customer accounts.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all snapshots that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all snapshots that have any combination of those values are returned. Only snapshots that you own are returned in the response; shared snapshots are not returned with the tag key and tag value request parameters.</p> <p>If both tag keys and values are omitted from the request, snapshots are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_614643.validator(path, query, header, formData, body)
  let scheme = call_614643.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614643.url(scheme.get, call_614643.host, call_614643.base,
                         call_614643.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614643, url, valid)

proc call*(call_614644: Call_GetDescribeClusterSnapshots_614619;
          Marker: string = ""; SortingEntities: JsonNode = nil;
          SnapshotIdentifier: string = ""; ClusterExists: bool = false;
          TagKeys: JsonNode = nil; SnapshotType: string = "";
          Action: string = "DescribeClusterSnapshots"; StartTime: string = "";
          ClusterIdentifier: string = ""; EndTime: string = "";
          OwnerAccount: string = ""; Version: string = "2012-12-01";
          MaxRecords: int = 0; TagValues: JsonNode = nil): Recallable =
  ## getDescribeClusterSnapshots
  ## <p>Returns one or more snapshot objects, which contain metadata about your cluster snapshots. By default, this operation returns information about all snapshots of all clusters that are owned by you AWS customer account. No information is returned for snapshots owned by inactive AWS customer accounts.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all snapshots that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all snapshots that have any combination of those values are returned. Only snapshots that you own are returned in the response; shared snapshots are not returned with the tag key and tag value request parameters.</p> <p>If both tag keys and values are omitted from the request, snapshots are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterSnapshots</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   SortingEntities: JArray
  ##                  : <p/>
  ##   SnapshotIdentifier: string
  ##                     : The snapshot identifier of the snapshot about which to return information.
  ##   ClusterExists: bool
  ##                : <p>A value that indicates whether to return snapshots only for an existing cluster. You can perform table-level restore only by using a snapshot of an existing cluster, that is, a cluster that has not been deleted. Values for this parameter work as follows: </p> <ul> <li> <p>If <code>ClusterExists</code> is set to <code>true</code>, <code>ClusterIdentifier</code> is required.</p> </li> <li> <p>If <code>ClusterExists</code> is set to <code>false</code> and <code>ClusterIdentifier</code> isn't specified, all snapshots associated with deleted clusters (orphaned snapshots) are returned. </p> </li> <li> <p>If <code>ClusterExists</code> is set to <code>false</code> and <code>ClusterIdentifier</code> is specified for a deleted cluster, snapshots associated with that cluster are returned.</p> </li> <li> <p>If <code>ClusterExists</code> is set to <code>false</code> and <code>ClusterIdentifier</code> is specified for an existing cluster, no snapshots are returned. </p> </li> </ul>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster snapshots that are associated with the specified key or keys. For example, suppose that you have snapshots that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the snapshots that have either or both of these tag keys associated with them.
  ##   SnapshotType: string
  ##               : <p>The type of snapshots for which you are requesting information. By default, snapshots of all types are returned.</p> <p>Valid Values: <code>automated</code> | <code>manual</code> </p>
  ##   Action: string (required)
  ##   StartTime: string
  ##            : <p>A value that requests only snapshots created at or after the specified time. The time value is specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2012-07-16T18:00:00Z</code> </p>
  ##   ClusterIdentifier: string
  ##                    : The identifier of the cluster which generated the requested snapshots.
  ##   EndTime: string
  ##          : <p>A time value that requests only snapshots created at or before the specified time. The time value is specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2012-07-16T18:00:00Z</code> </p>
  ##   OwnerAccount: string
  ##               : The AWS customer account used to create or copy the snapshot. Use this field to filter the results to snapshots owned by a particular account. To describe snapshots you own, either specify your AWS customer account, or do not specify the parameter.
  ##   Version: string (required)
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster snapshots that are associated with the specified tag value or values. For example, suppose that you have snapshots that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the snapshots that have either or both of these tag values associated with them.
  var query_614645 = newJObject()
  add(query_614645, "Marker", newJString(Marker))
  if SortingEntities != nil:
    query_614645.add "SortingEntities", SortingEntities
  add(query_614645, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_614645, "ClusterExists", newJBool(ClusterExists))
  if TagKeys != nil:
    query_614645.add "TagKeys", TagKeys
  add(query_614645, "SnapshotType", newJString(SnapshotType))
  add(query_614645, "Action", newJString(Action))
  add(query_614645, "StartTime", newJString(StartTime))
  add(query_614645, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_614645, "EndTime", newJString(EndTime))
  add(query_614645, "OwnerAccount", newJString(OwnerAccount))
  add(query_614645, "Version", newJString(Version))
  add(query_614645, "MaxRecords", newJInt(MaxRecords))
  if TagValues != nil:
    query_614645.add "TagValues", TagValues
  result = call_614644.call(nil, query_614645, nil, nil, nil)

var getDescribeClusterSnapshots* = Call_GetDescribeClusterSnapshots_614619(
    name: "getDescribeClusterSnapshots", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusterSnapshots",
    validator: validate_GetDescribeClusterSnapshots_614620, base: "/",
    url: url_GetDescribeClusterSnapshots_614621,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeClusterSubnetGroups_614694 = ref object of OpenApiRestCall_612642
proc url_PostDescribeClusterSubnetGroups_614696(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeClusterSubnetGroups_614695(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns one or more cluster subnet group objects, which contain metadata about your cluster subnet groups. By default, this operation returns information about all cluster subnet groups that are defined in you AWS account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all subnet groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all subnet groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, subnet groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_614697 = query.getOrDefault("Action")
  valid_614697 = validateParameter(valid_614697, JString, required = true, default = newJString(
      "DescribeClusterSubnetGroups"))
  if valid_614697 != nil:
    section.add "Action", valid_614697
  var valid_614698 = query.getOrDefault("Version")
  valid_614698 = validateParameter(valid_614698, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_614698 != nil:
    section.add "Version", valid_614698
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614699 = header.getOrDefault("X-Amz-Signature")
  valid_614699 = validateParameter(valid_614699, JString, required = false,
                                 default = nil)
  if valid_614699 != nil:
    section.add "X-Amz-Signature", valid_614699
  var valid_614700 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614700 = validateParameter(valid_614700, JString, required = false,
                                 default = nil)
  if valid_614700 != nil:
    section.add "X-Amz-Content-Sha256", valid_614700
  var valid_614701 = header.getOrDefault("X-Amz-Date")
  valid_614701 = validateParameter(valid_614701, JString, required = false,
                                 default = nil)
  if valid_614701 != nil:
    section.add "X-Amz-Date", valid_614701
  var valid_614702 = header.getOrDefault("X-Amz-Credential")
  valid_614702 = validateParameter(valid_614702, JString, required = false,
                                 default = nil)
  if valid_614702 != nil:
    section.add "X-Amz-Credential", valid_614702
  var valid_614703 = header.getOrDefault("X-Amz-Security-Token")
  valid_614703 = validateParameter(valid_614703, JString, required = false,
                                 default = nil)
  if valid_614703 != nil:
    section.add "X-Amz-Security-Token", valid_614703
  var valid_614704 = header.getOrDefault("X-Amz-Algorithm")
  valid_614704 = validateParameter(valid_614704, JString, required = false,
                                 default = nil)
  if valid_614704 != nil:
    section.add "X-Amz-Algorithm", valid_614704
  var valid_614705 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614705 = validateParameter(valid_614705, JString, required = false,
                                 default = nil)
  if valid_614705 != nil:
    section.add "X-Amz-SignedHeaders", valid_614705
  result.add "header", section
  ## parameters in `formData` object:
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster subnet groups that are associated with the specified key or keys. For example, suppose that you have subnet groups that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the subnet groups that have either or both of these tag keys associated with them.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterSubnetGroups</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   ClusterSubnetGroupName: JString
  ##                         : The name of the cluster subnet group for which information is requested.
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster subnet groups that are associated with the specified tag value or values. For example, suppose that you have subnet groups that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the subnet groups that have either or both of these tag values associated with them.
  section = newJObject()
  var valid_614706 = formData.getOrDefault("TagKeys")
  valid_614706 = validateParameter(valid_614706, JArray, required = false,
                                 default = nil)
  if valid_614706 != nil:
    section.add "TagKeys", valid_614706
  var valid_614707 = formData.getOrDefault("MaxRecords")
  valid_614707 = validateParameter(valid_614707, JInt, required = false, default = nil)
  if valid_614707 != nil:
    section.add "MaxRecords", valid_614707
  var valid_614708 = formData.getOrDefault("Marker")
  valid_614708 = validateParameter(valid_614708, JString, required = false,
                                 default = nil)
  if valid_614708 != nil:
    section.add "Marker", valid_614708
  var valid_614709 = formData.getOrDefault("ClusterSubnetGroupName")
  valid_614709 = validateParameter(valid_614709, JString, required = false,
                                 default = nil)
  if valid_614709 != nil:
    section.add "ClusterSubnetGroupName", valid_614709
  var valid_614710 = formData.getOrDefault("TagValues")
  valid_614710 = validateParameter(valid_614710, JArray, required = false,
                                 default = nil)
  if valid_614710 != nil:
    section.add "TagValues", valid_614710
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614711: Call_PostDescribeClusterSubnetGroups_614694;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Returns one or more cluster subnet group objects, which contain metadata about your cluster subnet groups. By default, this operation returns information about all cluster subnet groups that are defined in you AWS account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all subnet groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all subnet groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, subnet groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_614711.validator(path, query, header, formData, body)
  let scheme = call_614711.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614711.url(scheme.get, call_614711.host, call_614711.base,
                         call_614711.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614711, url, valid)

proc call*(call_614712: Call_PostDescribeClusterSubnetGroups_614694;
          TagKeys: JsonNode = nil; MaxRecords: int = 0; Marker: string = "";
          ClusterSubnetGroupName: string = ""; TagValues: JsonNode = nil;
          Action: string = "DescribeClusterSubnetGroups";
          Version: string = "2012-12-01"): Recallable =
  ## postDescribeClusterSubnetGroups
  ## <p>Returns one or more cluster subnet group objects, which contain metadata about your cluster subnet groups. By default, this operation returns information about all cluster subnet groups that are defined in you AWS account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all subnet groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all subnet groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, subnet groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster subnet groups that are associated with the specified key or keys. For example, suppose that you have subnet groups that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the subnet groups that have either or both of these tag keys associated with them.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterSubnetGroups</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   ClusterSubnetGroupName: string
  ##                         : The name of the cluster subnet group for which information is requested.
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster subnet groups that are associated with the specified tag value or values. For example, suppose that you have subnet groups that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the subnet groups that have either or both of these tag values associated with them.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_614713 = newJObject()
  var formData_614714 = newJObject()
  if TagKeys != nil:
    formData_614714.add "TagKeys", TagKeys
  add(formData_614714, "MaxRecords", newJInt(MaxRecords))
  add(formData_614714, "Marker", newJString(Marker))
  add(formData_614714, "ClusterSubnetGroupName",
      newJString(ClusterSubnetGroupName))
  if TagValues != nil:
    formData_614714.add "TagValues", TagValues
  add(query_614713, "Action", newJString(Action))
  add(query_614713, "Version", newJString(Version))
  result = call_614712.call(nil, query_614713, nil, formData_614714, nil)

var postDescribeClusterSubnetGroups* = Call_PostDescribeClusterSubnetGroups_614694(
    name: "postDescribeClusterSubnetGroups", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusterSubnetGroups",
    validator: validate_PostDescribeClusterSubnetGroups_614695, base: "/",
    url: url_PostDescribeClusterSubnetGroups_614696,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeClusterSubnetGroups_614674 = ref object of OpenApiRestCall_612642
proc url_GetDescribeClusterSubnetGroups_614676(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeClusterSubnetGroups_614675(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns one or more cluster subnet group objects, which contain metadata about your cluster subnet groups. By default, this operation returns information about all cluster subnet groups that are defined in you AWS account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all subnet groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all subnet groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, subnet groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ClusterSubnetGroupName: JString
  ##                         : The name of the cluster subnet group for which information is requested.
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterSubnetGroups</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster subnet groups that are associated with the specified key or keys. For example, suppose that you have subnet groups that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the subnet groups that have either or both of these tag keys associated with them.
  ##   Action: JString (required)
  ##   Version: JString (required)
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster subnet groups that are associated with the specified tag value or values. For example, suppose that you have subnet groups that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the subnet groups that have either or both of these tag values associated with them.
  section = newJObject()
  var valid_614677 = query.getOrDefault("ClusterSubnetGroupName")
  valid_614677 = validateParameter(valid_614677, JString, required = false,
                                 default = nil)
  if valid_614677 != nil:
    section.add "ClusterSubnetGroupName", valid_614677
  var valid_614678 = query.getOrDefault("Marker")
  valid_614678 = validateParameter(valid_614678, JString, required = false,
                                 default = nil)
  if valid_614678 != nil:
    section.add "Marker", valid_614678
  var valid_614679 = query.getOrDefault("TagKeys")
  valid_614679 = validateParameter(valid_614679, JArray, required = false,
                                 default = nil)
  if valid_614679 != nil:
    section.add "TagKeys", valid_614679
  var valid_614680 = query.getOrDefault("Action")
  valid_614680 = validateParameter(valid_614680, JString, required = true, default = newJString(
      "DescribeClusterSubnetGroups"))
  if valid_614680 != nil:
    section.add "Action", valid_614680
  var valid_614681 = query.getOrDefault("Version")
  valid_614681 = validateParameter(valid_614681, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_614681 != nil:
    section.add "Version", valid_614681
  var valid_614682 = query.getOrDefault("MaxRecords")
  valid_614682 = validateParameter(valid_614682, JInt, required = false, default = nil)
  if valid_614682 != nil:
    section.add "MaxRecords", valid_614682
  var valid_614683 = query.getOrDefault("TagValues")
  valid_614683 = validateParameter(valid_614683, JArray, required = false,
                                 default = nil)
  if valid_614683 != nil:
    section.add "TagValues", valid_614683
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614684 = header.getOrDefault("X-Amz-Signature")
  valid_614684 = validateParameter(valid_614684, JString, required = false,
                                 default = nil)
  if valid_614684 != nil:
    section.add "X-Amz-Signature", valid_614684
  var valid_614685 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614685 = validateParameter(valid_614685, JString, required = false,
                                 default = nil)
  if valid_614685 != nil:
    section.add "X-Amz-Content-Sha256", valid_614685
  var valid_614686 = header.getOrDefault("X-Amz-Date")
  valid_614686 = validateParameter(valid_614686, JString, required = false,
                                 default = nil)
  if valid_614686 != nil:
    section.add "X-Amz-Date", valid_614686
  var valid_614687 = header.getOrDefault("X-Amz-Credential")
  valid_614687 = validateParameter(valid_614687, JString, required = false,
                                 default = nil)
  if valid_614687 != nil:
    section.add "X-Amz-Credential", valid_614687
  var valid_614688 = header.getOrDefault("X-Amz-Security-Token")
  valid_614688 = validateParameter(valid_614688, JString, required = false,
                                 default = nil)
  if valid_614688 != nil:
    section.add "X-Amz-Security-Token", valid_614688
  var valid_614689 = header.getOrDefault("X-Amz-Algorithm")
  valid_614689 = validateParameter(valid_614689, JString, required = false,
                                 default = nil)
  if valid_614689 != nil:
    section.add "X-Amz-Algorithm", valid_614689
  var valid_614690 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614690 = validateParameter(valid_614690, JString, required = false,
                                 default = nil)
  if valid_614690 != nil:
    section.add "X-Amz-SignedHeaders", valid_614690
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614691: Call_GetDescribeClusterSubnetGroups_614674; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns one or more cluster subnet group objects, which contain metadata about your cluster subnet groups. By default, this operation returns information about all cluster subnet groups that are defined in you AWS account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all subnet groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all subnet groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, subnet groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_614691.validator(path, query, header, formData, body)
  let scheme = call_614691.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614691.url(scheme.get, call_614691.host, call_614691.base,
                         call_614691.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614691, url, valid)

proc call*(call_614692: Call_GetDescribeClusterSubnetGroups_614674;
          ClusterSubnetGroupName: string = ""; Marker: string = "";
          TagKeys: JsonNode = nil; Action: string = "DescribeClusterSubnetGroups";
          Version: string = "2012-12-01"; MaxRecords: int = 0; TagValues: JsonNode = nil): Recallable =
  ## getDescribeClusterSubnetGroups
  ## <p>Returns one or more cluster subnet group objects, which contain metadata about your cluster subnet groups. By default, this operation returns information about all cluster subnet groups that are defined in you AWS account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all subnet groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all subnet groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, subnet groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   ClusterSubnetGroupName: string
  ##                         : The name of the cluster subnet group for which information is requested.
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterSubnetGroups</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster subnet groups that are associated with the specified key or keys. For example, suppose that you have subnet groups that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the subnet groups that have either or both of these tag keys associated with them.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster subnet groups that are associated with the specified tag value or values. For example, suppose that you have subnet groups that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the subnet groups that have either or both of these tag values associated with them.
  var query_614693 = newJObject()
  add(query_614693, "ClusterSubnetGroupName", newJString(ClusterSubnetGroupName))
  add(query_614693, "Marker", newJString(Marker))
  if TagKeys != nil:
    query_614693.add "TagKeys", TagKeys
  add(query_614693, "Action", newJString(Action))
  add(query_614693, "Version", newJString(Version))
  add(query_614693, "MaxRecords", newJInt(MaxRecords))
  if TagValues != nil:
    query_614693.add "TagValues", TagValues
  result = call_614692.call(nil, query_614693, nil, nil, nil)

var getDescribeClusterSubnetGroups* = Call_GetDescribeClusterSubnetGroups_614674(
    name: "getDescribeClusterSubnetGroups", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusterSubnetGroups",
    validator: validate_GetDescribeClusterSubnetGroups_614675, base: "/",
    url: url_GetDescribeClusterSubnetGroups_614676,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeClusterTracks_614733 = ref object of OpenApiRestCall_612642
proc url_PostDescribeClusterTracks_614735(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeClusterTracks_614734(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns a list of all the available maintenance tracks.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_614736 = query.getOrDefault("Action")
  valid_614736 = validateParameter(valid_614736, JString, required = true,
                                 default = newJString("DescribeClusterTracks"))
  if valid_614736 != nil:
    section.add "Action", valid_614736
  var valid_614737 = query.getOrDefault("Version")
  valid_614737 = validateParameter(valid_614737, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_614737 != nil:
    section.add "Version", valid_614737
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614738 = header.getOrDefault("X-Amz-Signature")
  valid_614738 = validateParameter(valid_614738, JString, required = false,
                                 default = nil)
  if valid_614738 != nil:
    section.add "X-Amz-Signature", valid_614738
  var valid_614739 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614739 = validateParameter(valid_614739, JString, required = false,
                                 default = nil)
  if valid_614739 != nil:
    section.add "X-Amz-Content-Sha256", valid_614739
  var valid_614740 = header.getOrDefault("X-Amz-Date")
  valid_614740 = validateParameter(valid_614740, JString, required = false,
                                 default = nil)
  if valid_614740 != nil:
    section.add "X-Amz-Date", valid_614740
  var valid_614741 = header.getOrDefault("X-Amz-Credential")
  valid_614741 = validateParameter(valid_614741, JString, required = false,
                                 default = nil)
  if valid_614741 != nil:
    section.add "X-Amz-Credential", valid_614741
  var valid_614742 = header.getOrDefault("X-Amz-Security-Token")
  valid_614742 = validateParameter(valid_614742, JString, required = false,
                                 default = nil)
  if valid_614742 != nil:
    section.add "X-Amz-Security-Token", valid_614742
  var valid_614743 = header.getOrDefault("X-Amz-Algorithm")
  valid_614743 = validateParameter(valid_614743, JString, required = false,
                                 default = nil)
  if valid_614743 != nil:
    section.add "X-Amz-Algorithm", valid_614743
  var valid_614744 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614744 = validateParameter(valid_614744, JString, required = false,
                                 default = nil)
  if valid_614744 != nil:
    section.add "X-Amz-SignedHeaders", valid_614744
  result.add "header", section
  ## parameters in `formData` object:
  ##   MaintenanceTrackName: JString
  ##                       : The name of the maintenance track. 
  ##   MaxRecords: JInt
  ##             : An integer value for the maximum number of maintenance tracks to return.
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <code>DescribeClusterTracks</code> request exceed the value specified in <code>MaxRecords</code>, Amazon Redshift returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  section = newJObject()
  var valid_614745 = formData.getOrDefault("MaintenanceTrackName")
  valid_614745 = validateParameter(valid_614745, JString, required = false,
                                 default = nil)
  if valid_614745 != nil:
    section.add "MaintenanceTrackName", valid_614745
  var valid_614746 = formData.getOrDefault("MaxRecords")
  valid_614746 = validateParameter(valid_614746, JInt, required = false, default = nil)
  if valid_614746 != nil:
    section.add "MaxRecords", valid_614746
  var valid_614747 = formData.getOrDefault("Marker")
  valid_614747 = validateParameter(valid_614747, JString, required = false,
                                 default = nil)
  if valid_614747 != nil:
    section.add "Marker", valid_614747
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614748: Call_PostDescribeClusterTracks_614733; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns a list of all the available maintenance tracks.
  ## 
  let valid = call_614748.validator(path, query, header, formData, body)
  let scheme = call_614748.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614748.url(scheme.get, call_614748.host, call_614748.base,
                         call_614748.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614748, url, valid)

proc call*(call_614749: Call_PostDescribeClusterTracks_614733;
          MaintenanceTrackName: string = ""; MaxRecords: int = 0; Marker: string = "";
          Action: string = "DescribeClusterTracks"; Version: string = "2012-12-01"): Recallable =
  ## postDescribeClusterTracks
  ## Returns a list of all the available maintenance tracks.
  ##   MaintenanceTrackName: string
  ##                       : The name of the maintenance track. 
  ##   MaxRecords: int
  ##             : An integer value for the maximum number of maintenance tracks to return.
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <code>DescribeClusterTracks</code> request exceed the value specified in <code>MaxRecords</code>, Amazon Redshift returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Action: string (required)
  ##   Version: string (required)
  var query_614750 = newJObject()
  var formData_614751 = newJObject()
  add(formData_614751, "MaintenanceTrackName", newJString(MaintenanceTrackName))
  add(formData_614751, "MaxRecords", newJInt(MaxRecords))
  add(formData_614751, "Marker", newJString(Marker))
  add(query_614750, "Action", newJString(Action))
  add(query_614750, "Version", newJString(Version))
  result = call_614749.call(nil, query_614750, nil, formData_614751, nil)

var postDescribeClusterTracks* = Call_PostDescribeClusterTracks_614733(
    name: "postDescribeClusterTracks", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusterTracks",
    validator: validate_PostDescribeClusterTracks_614734, base: "/",
    url: url_PostDescribeClusterTracks_614735,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeClusterTracks_614715 = ref object of OpenApiRestCall_612642
proc url_GetDescribeClusterTracks_614717(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeClusterTracks_614716(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns a list of all the available maintenance tracks.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <code>DescribeClusterTracks</code> request exceed the value specified in <code>MaxRecords</code>, Amazon Redshift returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   MaintenanceTrackName: JString
  ##                       : The name of the maintenance track. 
  ##   Action: JString (required)
  ##   Version: JString (required)
  ##   MaxRecords: JInt
  ##             : An integer value for the maximum number of maintenance tracks to return.
  section = newJObject()
  var valid_614718 = query.getOrDefault("Marker")
  valid_614718 = validateParameter(valid_614718, JString, required = false,
                                 default = nil)
  if valid_614718 != nil:
    section.add "Marker", valid_614718
  var valid_614719 = query.getOrDefault("MaintenanceTrackName")
  valid_614719 = validateParameter(valid_614719, JString, required = false,
                                 default = nil)
  if valid_614719 != nil:
    section.add "MaintenanceTrackName", valid_614719
  var valid_614720 = query.getOrDefault("Action")
  valid_614720 = validateParameter(valid_614720, JString, required = true,
                                 default = newJString("DescribeClusterTracks"))
  if valid_614720 != nil:
    section.add "Action", valid_614720
  var valid_614721 = query.getOrDefault("Version")
  valid_614721 = validateParameter(valid_614721, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_614721 != nil:
    section.add "Version", valid_614721
  var valid_614722 = query.getOrDefault("MaxRecords")
  valid_614722 = validateParameter(valid_614722, JInt, required = false, default = nil)
  if valid_614722 != nil:
    section.add "MaxRecords", valid_614722
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614723 = header.getOrDefault("X-Amz-Signature")
  valid_614723 = validateParameter(valid_614723, JString, required = false,
                                 default = nil)
  if valid_614723 != nil:
    section.add "X-Amz-Signature", valid_614723
  var valid_614724 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614724 = validateParameter(valid_614724, JString, required = false,
                                 default = nil)
  if valid_614724 != nil:
    section.add "X-Amz-Content-Sha256", valid_614724
  var valid_614725 = header.getOrDefault("X-Amz-Date")
  valid_614725 = validateParameter(valid_614725, JString, required = false,
                                 default = nil)
  if valid_614725 != nil:
    section.add "X-Amz-Date", valid_614725
  var valid_614726 = header.getOrDefault("X-Amz-Credential")
  valid_614726 = validateParameter(valid_614726, JString, required = false,
                                 default = nil)
  if valid_614726 != nil:
    section.add "X-Amz-Credential", valid_614726
  var valid_614727 = header.getOrDefault("X-Amz-Security-Token")
  valid_614727 = validateParameter(valid_614727, JString, required = false,
                                 default = nil)
  if valid_614727 != nil:
    section.add "X-Amz-Security-Token", valid_614727
  var valid_614728 = header.getOrDefault("X-Amz-Algorithm")
  valid_614728 = validateParameter(valid_614728, JString, required = false,
                                 default = nil)
  if valid_614728 != nil:
    section.add "X-Amz-Algorithm", valid_614728
  var valid_614729 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614729 = validateParameter(valid_614729, JString, required = false,
                                 default = nil)
  if valid_614729 != nil:
    section.add "X-Amz-SignedHeaders", valid_614729
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614730: Call_GetDescribeClusterTracks_614715; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns a list of all the available maintenance tracks.
  ## 
  let valid = call_614730.validator(path, query, header, formData, body)
  let scheme = call_614730.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614730.url(scheme.get, call_614730.host, call_614730.base,
                         call_614730.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614730, url, valid)

proc call*(call_614731: Call_GetDescribeClusterTracks_614715; Marker: string = "";
          MaintenanceTrackName: string = "";
          Action: string = "DescribeClusterTracks"; Version: string = "2012-12-01";
          MaxRecords: int = 0): Recallable =
  ## getDescribeClusterTracks
  ## Returns a list of all the available maintenance tracks.
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <code>DescribeClusterTracks</code> request exceed the value specified in <code>MaxRecords</code>, Amazon Redshift returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   MaintenanceTrackName: string
  ##                       : The name of the maintenance track. 
  ##   Action: string (required)
  ##   Version: string (required)
  ##   MaxRecords: int
  ##             : An integer value for the maximum number of maintenance tracks to return.
  var query_614732 = newJObject()
  add(query_614732, "Marker", newJString(Marker))
  add(query_614732, "MaintenanceTrackName", newJString(MaintenanceTrackName))
  add(query_614732, "Action", newJString(Action))
  add(query_614732, "Version", newJString(Version))
  add(query_614732, "MaxRecords", newJInt(MaxRecords))
  result = call_614731.call(nil, query_614732, nil, nil, nil)

var getDescribeClusterTracks* = Call_GetDescribeClusterTracks_614715(
    name: "getDescribeClusterTracks", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusterTracks",
    validator: validate_GetDescribeClusterTracks_614716, base: "/",
    url: url_GetDescribeClusterTracks_614717, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeClusterVersions_614771 = ref object of OpenApiRestCall_612642
proc url_PostDescribeClusterVersions_614773(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeClusterVersions_614772(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns descriptions of the available Amazon Redshift cluster versions. You can call this operation even before creating any clusters to learn more about the Amazon Redshift versions. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_614774 = query.getOrDefault("Action")
  valid_614774 = validateParameter(valid_614774, JString, required = true, default = newJString(
      "DescribeClusterVersions"))
  if valid_614774 != nil:
    section.add "Action", valid_614774
  var valid_614775 = query.getOrDefault("Version")
  valid_614775 = validateParameter(valid_614775, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_614775 != nil:
    section.add "Version", valid_614775
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614776 = header.getOrDefault("X-Amz-Signature")
  valid_614776 = validateParameter(valid_614776, JString, required = false,
                                 default = nil)
  if valid_614776 != nil:
    section.add "X-Amz-Signature", valid_614776
  var valid_614777 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614777 = validateParameter(valid_614777, JString, required = false,
                                 default = nil)
  if valid_614777 != nil:
    section.add "X-Amz-Content-Sha256", valid_614777
  var valid_614778 = header.getOrDefault("X-Amz-Date")
  valid_614778 = validateParameter(valid_614778, JString, required = false,
                                 default = nil)
  if valid_614778 != nil:
    section.add "X-Amz-Date", valid_614778
  var valid_614779 = header.getOrDefault("X-Amz-Credential")
  valid_614779 = validateParameter(valid_614779, JString, required = false,
                                 default = nil)
  if valid_614779 != nil:
    section.add "X-Amz-Credential", valid_614779
  var valid_614780 = header.getOrDefault("X-Amz-Security-Token")
  valid_614780 = validateParameter(valid_614780, JString, required = false,
                                 default = nil)
  if valid_614780 != nil:
    section.add "X-Amz-Security-Token", valid_614780
  var valid_614781 = header.getOrDefault("X-Amz-Algorithm")
  valid_614781 = validateParameter(valid_614781, JString, required = false,
                                 default = nil)
  if valid_614781 != nil:
    section.add "X-Amz-Algorithm", valid_614781
  var valid_614782 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614782 = validateParameter(valid_614782, JString, required = false,
                                 default = nil)
  if valid_614782 != nil:
    section.add "X-Amz-SignedHeaders", valid_614782
  result.add "header", section
  ## parameters in `formData` object:
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   ClusterParameterGroupFamily: JString
  ##                              : <p>The name of a specific cluster parameter group family to return details for.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters</p> </li> <li> <p>First character must be a letter</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens</p> </li> </ul>
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterVersions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   ClusterVersion: JString
  ##                 : <p>The specific cluster version to return.</p> <p>Example: <code>1.0</code> </p>
  section = newJObject()
  var valid_614783 = formData.getOrDefault("MaxRecords")
  valid_614783 = validateParameter(valid_614783, JInt, required = false, default = nil)
  if valid_614783 != nil:
    section.add "MaxRecords", valid_614783
  var valid_614784 = formData.getOrDefault("ClusterParameterGroupFamily")
  valid_614784 = validateParameter(valid_614784, JString, required = false,
                                 default = nil)
  if valid_614784 != nil:
    section.add "ClusterParameterGroupFamily", valid_614784
  var valid_614785 = formData.getOrDefault("Marker")
  valid_614785 = validateParameter(valid_614785, JString, required = false,
                                 default = nil)
  if valid_614785 != nil:
    section.add "Marker", valid_614785
  var valid_614786 = formData.getOrDefault("ClusterVersion")
  valid_614786 = validateParameter(valid_614786, JString, required = false,
                                 default = nil)
  if valid_614786 != nil:
    section.add "ClusterVersion", valid_614786
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614787: Call_PostDescribeClusterVersions_614771; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns descriptions of the available Amazon Redshift cluster versions. You can call this operation even before creating any clusters to learn more about the Amazon Redshift versions. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.
  ## 
  let valid = call_614787.validator(path, query, header, formData, body)
  let scheme = call_614787.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614787.url(scheme.get, call_614787.host, call_614787.base,
                         call_614787.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614787, url, valid)

proc call*(call_614788: Call_PostDescribeClusterVersions_614771;
          MaxRecords: int = 0; ClusterParameterGroupFamily: string = "";
          Marker: string = ""; Action: string = "DescribeClusterVersions";
          ClusterVersion: string = ""; Version: string = "2012-12-01"): Recallable =
  ## postDescribeClusterVersions
  ## Returns descriptions of the available Amazon Redshift cluster versions. You can call this operation even before creating any clusters to learn more about the Amazon Redshift versions. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   ClusterParameterGroupFamily: string
  ##                              : <p>The name of a specific cluster parameter group family to return details for.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters</p> </li> <li> <p>First character must be a letter</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens</p> </li> </ul>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterVersions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Action: string (required)
  ##   ClusterVersion: string
  ##                 : <p>The specific cluster version to return.</p> <p>Example: <code>1.0</code> </p>
  ##   Version: string (required)
  var query_614789 = newJObject()
  var formData_614790 = newJObject()
  add(formData_614790, "MaxRecords", newJInt(MaxRecords))
  add(formData_614790, "ClusterParameterGroupFamily",
      newJString(ClusterParameterGroupFamily))
  add(formData_614790, "Marker", newJString(Marker))
  add(query_614789, "Action", newJString(Action))
  add(formData_614790, "ClusterVersion", newJString(ClusterVersion))
  add(query_614789, "Version", newJString(Version))
  result = call_614788.call(nil, query_614789, nil, formData_614790, nil)

var postDescribeClusterVersions* = Call_PostDescribeClusterVersions_614771(
    name: "postDescribeClusterVersions", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusterVersions",
    validator: validate_PostDescribeClusterVersions_614772, base: "/",
    url: url_PostDescribeClusterVersions_614773,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeClusterVersions_614752 = ref object of OpenApiRestCall_612642
proc url_GetDescribeClusterVersions_614754(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeClusterVersions_614753(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns descriptions of the available Amazon Redshift cluster versions. You can call this operation even before creating any clusters to learn more about the Amazon Redshift versions. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterVersions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   ClusterParameterGroupFamily: JString
  ##                              : <p>The name of a specific cluster parameter group family to return details for.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters</p> </li> <li> <p>First character must be a letter</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens</p> </li> </ul>
  ##   ClusterVersion: JString
  ##                 : <p>The specific cluster version to return.</p> <p>Example: <code>1.0</code> </p>
  ##   Action: JString (required)
  ##   Version: JString (required)
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  section = newJObject()
  var valid_614755 = query.getOrDefault("Marker")
  valid_614755 = validateParameter(valid_614755, JString, required = false,
                                 default = nil)
  if valid_614755 != nil:
    section.add "Marker", valid_614755
  var valid_614756 = query.getOrDefault("ClusterParameterGroupFamily")
  valid_614756 = validateParameter(valid_614756, JString, required = false,
                                 default = nil)
  if valid_614756 != nil:
    section.add "ClusterParameterGroupFamily", valid_614756
  var valid_614757 = query.getOrDefault("ClusterVersion")
  valid_614757 = validateParameter(valid_614757, JString, required = false,
                                 default = nil)
  if valid_614757 != nil:
    section.add "ClusterVersion", valid_614757
  var valid_614758 = query.getOrDefault("Action")
  valid_614758 = validateParameter(valid_614758, JString, required = true, default = newJString(
      "DescribeClusterVersions"))
  if valid_614758 != nil:
    section.add "Action", valid_614758
  var valid_614759 = query.getOrDefault("Version")
  valid_614759 = validateParameter(valid_614759, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_614759 != nil:
    section.add "Version", valid_614759
  var valid_614760 = query.getOrDefault("MaxRecords")
  valid_614760 = validateParameter(valid_614760, JInt, required = false, default = nil)
  if valid_614760 != nil:
    section.add "MaxRecords", valid_614760
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614761 = header.getOrDefault("X-Amz-Signature")
  valid_614761 = validateParameter(valid_614761, JString, required = false,
                                 default = nil)
  if valid_614761 != nil:
    section.add "X-Amz-Signature", valid_614761
  var valid_614762 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614762 = validateParameter(valid_614762, JString, required = false,
                                 default = nil)
  if valid_614762 != nil:
    section.add "X-Amz-Content-Sha256", valid_614762
  var valid_614763 = header.getOrDefault("X-Amz-Date")
  valid_614763 = validateParameter(valid_614763, JString, required = false,
                                 default = nil)
  if valid_614763 != nil:
    section.add "X-Amz-Date", valid_614763
  var valid_614764 = header.getOrDefault("X-Amz-Credential")
  valid_614764 = validateParameter(valid_614764, JString, required = false,
                                 default = nil)
  if valid_614764 != nil:
    section.add "X-Amz-Credential", valid_614764
  var valid_614765 = header.getOrDefault("X-Amz-Security-Token")
  valid_614765 = validateParameter(valid_614765, JString, required = false,
                                 default = nil)
  if valid_614765 != nil:
    section.add "X-Amz-Security-Token", valid_614765
  var valid_614766 = header.getOrDefault("X-Amz-Algorithm")
  valid_614766 = validateParameter(valid_614766, JString, required = false,
                                 default = nil)
  if valid_614766 != nil:
    section.add "X-Amz-Algorithm", valid_614766
  var valid_614767 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614767 = validateParameter(valid_614767, JString, required = false,
                                 default = nil)
  if valid_614767 != nil:
    section.add "X-Amz-SignedHeaders", valid_614767
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614768: Call_GetDescribeClusterVersions_614752; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns descriptions of the available Amazon Redshift cluster versions. You can call this operation even before creating any clusters to learn more about the Amazon Redshift versions. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.
  ## 
  let valid = call_614768.validator(path, query, header, formData, body)
  let scheme = call_614768.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614768.url(scheme.get, call_614768.host, call_614768.base,
                         call_614768.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614768, url, valid)

proc call*(call_614769: Call_GetDescribeClusterVersions_614752;
          Marker: string = ""; ClusterParameterGroupFamily: string = "";
          ClusterVersion: string = ""; Action: string = "DescribeClusterVersions";
          Version: string = "2012-12-01"; MaxRecords: int = 0): Recallable =
  ## getDescribeClusterVersions
  ## Returns descriptions of the available Amazon Redshift cluster versions. You can call this operation even before creating any clusters to learn more about the Amazon Redshift versions. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterVersions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   ClusterParameterGroupFamily: string
  ##                              : <p>The name of a specific cluster parameter group family to return details for.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters</p> </li> <li> <p>First character must be a letter</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens</p> </li> </ul>
  ##   ClusterVersion: string
  ##                 : <p>The specific cluster version to return.</p> <p>Example: <code>1.0</code> </p>
  ##   Action: string (required)
  ##   Version: string (required)
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  var query_614770 = newJObject()
  add(query_614770, "Marker", newJString(Marker))
  add(query_614770, "ClusterParameterGroupFamily",
      newJString(ClusterParameterGroupFamily))
  add(query_614770, "ClusterVersion", newJString(ClusterVersion))
  add(query_614770, "Action", newJString(Action))
  add(query_614770, "Version", newJString(Version))
  add(query_614770, "MaxRecords", newJInt(MaxRecords))
  result = call_614769.call(nil, query_614770, nil, nil, nil)

var getDescribeClusterVersions* = Call_GetDescribeClusterVersions_614752(
    name: "getDescribeClusterVersions", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusterVersions",
    validator: validate_GetDescribeClusterVersions_614753, base: "/",
    url: url_GetDescribeClusterVersions_614754,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeClusters_614811 = ref object of OpenApiRestCall_612642
proc url_PostDescribeClusters_614813(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeClusters_614812(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns properties of provisioned clusters including general cluster properties, cluster database properties, maintenance and backup properties, and security and access properties. This operation supports pagination. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all clusters that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all clusters that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, clusters are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_614814 = query.getOrDefault("Action")
  valid_614814 = validateParameter(valid_614814, JString, required = true,
                                 default = newJString("DescribeClusters"))
  if valid_614814 != nil:
    section.add "Action", valid_614814
  var valid_614815 = query.getOrDefault("Version")
  valid_614815 = validateParameter(valid_614815, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_614815 != nil:
    section.add "Version", valid_614815
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614816 = header.getOrDefault("X-Amz-Signature")
  valid_614816 = validateParameter(valid_614816, JString, required = false,
                                 default = nil)
  if valid_614816 != nil:
    section.add "X-Amz-Signature", valid_614816
  var valid_614817 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614817 = validateParameter(valid_614817, JString, required = false,
                                 default = nil)
  if valid_614817 != nil:
    section.add "X-Amz-Content-Sha256", valid_614817
  var valid_614818 = header.getOrDefault("X-Amz-Date")
  valid_614818 = validateParameter(valid_614818, JString, required = false,
                                 default = nil)
  if valid_614818 != nil:
    section.add "X-Amz-Date", valid_614818
  var valid_614819 = header.getOrDefault("X-Amz-Credential")
  valid_614819 = validateParameter(valid_614819, JString, required = false,
                                 default = nil)
  if valid_614819 != nil:
    section.add "X-Amz-Credential", valid_614819
  var valid_614820 = header.getOrDefault("X-Amz-Security-Token")
  valid_614820 = validateParameter(valid_614820, JString, required = false,
                                 default = nil)
  if valid_614820 != nil:
    section.add "X-Amz-Security-Token", valid_614820
  var valid_614821 = header.getOrDefault("X-Amz-Algorithm")
  valid_614821 = validateParameter(valid_614821, JString, required = false,
                                 default = nil)
  if valid_614821 != nil:
    section.add "X-Amz-Algorithm", valid_614821
  var valid_614822 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614822 = validateParameter(valid_614822, JString, required = false,
                                 default = nil)
  if valid_614822 != nil:
    section.add "X-Amz-SignedHeaders", valid_614822
  result.add "header", section
  ## parameters in `formData` object:
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching clusters that are associated with the specified key or keys. For example, suppose that you have clusters that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the clusters that have either or both of these tag keys associated with them.
  ##   ClusterIdentifier: JString
  ##                    : <p>The unique identifier of a cluster whose properties you are requesting. This parameter is case sensitive.</p> <p>The default is that all clusters defined for an account are returned.</p>
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: JString
  ##         : <p>An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusters</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <b>ClusterIdentifier</b> parameter or the <b>Marker</b> parameter, but not both. </p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching clusters that are associated with the specified tag value or values. For example, suppose that you have clusters that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the clusters that have either or both of these tag values associated with them.
  section = newJObject()
  var valid_614823 = formData.getOrDefault("TagKeys")
  valid_614823 = validateParameter(valid_614823, JArray, required = false,
                                 default = nil)
  if valid_614823 != nil:
    section.add "TagKeys", valid_614823
  var valid_614824 = formData.getOrDefault("ClusterIdentifier")
  valid_614824 = validateParameter(valid_614824, JString, required = false,
                                 default = nil)
  if valid_614824 != nil:
    section.add "ClusterIdentifier", valid_614824
  var valid_614825 = formData.getOrDefault("MaxRecords")
  valid_614825 = validateParameter(valid_614825, JInt, required = false, default = nil)
  if valid_614825 != nil:
    section.add "MaxRecords", valid_614825
  var valid_614826 = formData.getOrDefault("Marker")
  valid_614826 = validateParameter(valid_614826, JString, required = false,
                                 default = nil)
  if valid_614826 != nil:
    section.add "Marker", valid_614826
  var valid_614827 = formData.getOrDefault("TagValues")
  valid_614827 = validateParameter(valid_614827, JArray, required = false,
                                 default = nil)
  if valid_614827 != nil:
    section.add "TagValues", valid_614827
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614828: Call_PostDescribeClusters_614811; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns properties of provisioned clusters including general cluster properties, cluster database properties, maintenance and backup properties, and security and access properties. This operation supports pagination. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all clusters that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all clusters that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, clusters are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_614828.validator(path, query, header, formData, body)
  let scheme = call_614828.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614828.url(scheme.get, call_614828.host, call_614828.base,
                         call_614828.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614828, url, valid)

proc call*(call_614829: Call_PostDescribeClusters_614811; TagKeys: JsonNode = nil;
          ClusterIdentifier: string = ""; MaxRecords: int = 0; Marker: string = "";
          TagValues: JsonNode = nil; Action: string = "DescribeClusters";
          Version: string = "2012-12-01"): Recallable =
  ## postDescribeClusters
  ## <p>Returns properties of provisioned clusters including general cluster properties, cluster database properties, maintenance and backup properties, and security and access properties. This operation supports pagination. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all clusters that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all clusters that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, clusters are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching clusters that are associated with the specified key or keys. For example, suppose that you have clusters that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the clusters that have either or both of these tag keys associated with them.
  ##   ClusterIdentifier: string
  ##                    : <p>The unique identifier of a cluster whose properties you are requesting. This parameter is case sensitive.</p> <p>The default is that all clusters defined for an account are returned.</p>
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: string
  ##         : <p>An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusters</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <b>ClusterIdentifier</b> parameter or the <b>Marker</b> parameter, but not both. </p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching clusters that are associated with the specified tag value or values. For example, suppose that you have clusters that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the clusters that have either or both of these tag values associated with them.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_614830 = newJObject()
  var formData_614831 = newJObject()
  if TagKeys != nil:
    formData_614831.add "TagKeys", TagKeys
  add(formData_614831, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_614831, "MaxRecords", newJInt(MaxRecords))
  add(formData_614831, "Marker", newJString(Marker))
  if TagValues != nil:
    formData_614831.add "TagValues", TagValues
  add(query_614830, "Action", newJString(Action))
  add(query_614830, "Version", newJString(Version))
  result = call_614829.call(nil, query_614830, nil, formData_614831, nil)

var postDescribeClusters* = Call_PostDescribeClusters_614811(
    name: "postDescribeClusters", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusters",
    validator: validate_PostDescribeClusters_614812, base: "/",
    url: url_PostDescribeClusters_614813, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeClusters_614791 = ref object of OpenApiRestCall_612642
proc url_GetDescribeClusters_614793(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeClusters_614792(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## <p>Returns properties of provisioned clusters including general cluster properties, cluster database properties, maintenance and backup properties, and security and access properties. This operation supports pagination. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all clusters that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all clusters that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, clusters are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Marker: JString
  ##         : <p>An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusters</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <b>ClusterIdentifier</b> parameter or the <b>Marker</b> parameter, but not both. </p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching clusters that are associated with the specified key or keys. For example, suppose that you have clusters that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the clusters that have either or both of these tag keys associated with them.
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString
  ##                    : <p>The unique identifier of a cluster whose properties you are requesting. This parameter is case sensitive.</p> <p>The default is that all clusters defined for an account are returned.</p>
  ##   Version: JString (required)
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching clusters that are associated with the specified tag value or values. For example, suppose that you have clusters that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the clusters that have either or both of these tag values associated with them.
  section = newJObject()
  var valid_614794 = query.getOrDefault("Marker")
  valid_614794 = validateParameter(valid_614794, JString, required = false,
                                 default = nil)
  if valid_614794 != nil:
    section.add "Marker", valid_614794
  var valid_614795 = query.getOrDefault("TagKeys")
  valid_614795 = validateParameter(valid_614795, JArray, required = false,
                                 default = nil)
  if valid_614795 != nil:
    section.add "TagKeys", valid_614795
  var valid_614796 = query.getOrDefault("Action")
  valid_614796 = validateParameter(valid_614796, JString, required = true,
                                 default = newJString("DescribeClusters"))
  if valid_614796 != nil:
    section.add "Action", valid_614796
  var valid_614797 = query.getOrDefault("ClusterIdentifier")
  valid_614797 = validateParameter(valid_614797, JString, required = false,
                                 default = nil)
  if valid_614797 != nil:
    section.add "ClusterIdentifier", valid_614797
  var valid_614798 = query.getOrDefault("Version")
  valid_614798 = validateParameter(valid_614798, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_614798 != nil:
    section.add "Version", valid_614798
  var valid_614799 = query.getOrDefault("MaxRecords")
  valid_614799 = validateParameter(valid_614799, JInt, required = false, default = nil)
  if valid_614799 != nil:
    section.add "MaxRecords", valid_614799
  var valid_614800 = query.getOrDefault("TagValues")
  valid_614800 = validateParameter(valid_614800, JArray, required = false,
                                 default = nil)
  if valid_614800 != nil:
    section.add "TagValues", valid_614800
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614801 = header.getOrDefault("X-Amz-Signature")
  valid_614801 = validateParameter(valid_614801, JString, required = false,
                                 default = nil)
  if valid_614801 != nil:
    section.add "X-Amz-Signature", valid_614801
  var valid_614802 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614802 = validateParameter(valid_614802, JString, required = false,
                                 default = nil)
  if valid_614802 != nil:
    section.add "X-Amz-Content-Sha256", valid_614802
  var valid_614803 = header.getOrDefault("X-Amz-Date")
  valid_614803 = validateParameter(valid_614803, JString, required = false,
                                 default = nil)
  if valid_614803 != nil:
    section.add "X-Amz-Date", valid_614803
  var valid_614804 = header.getOrDefault("X-Amz-Credential")
  valid_614804 = validateParameter(valid_614804, JString, required = false,
                                 default = nil)
  if valid_614804 != nil:
    section.add "X-Amz-Credential", valid_614804
  var valid_614805 = header.getOrDefault("X-Amz-Security-Token")
  valid_614805 = validateParameter(valid_614805, JString, required = false,
                                 default = nil)
  if valid_614805 != nil:
    section.add "X-Amz-Security-Token", valid_614805
  var valid_614806 = header.getOrDefault("X-Amz-Algorithm")
  valid_614806 = validateParameter(valid_614806, JString, required = false,
                                 default = nil)
  if valid_614806 != nil:
    section.add "X-Amz-Algorithm", valid_614806
  var valid_614807 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614807 = validateParameter(valid_614807, JString, required = false,
                                 default = nil)
  if valid_614807 != nil:
    section.add "X-Amz-SignedHeaders", valid_614807
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614808: Call_GetDescribeClusters_614791; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns properties of provisioned clusters including general cluster properties, cluster database properties, maintenance and backup properties, and security and access properties. This operation supports pagination. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all clusters that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all clusters that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, clusters are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_614808.validator(path, query, header, formData, body)
  let scheme = call_614808.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614808.url(scheme.get, call_614808.host, call_614808.base,
                         call_614808.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614808, url, valid)

proc call*(call_614809: Call_GetDescribeClusters_614791; Marker: string = "";
          TagKeys: JsonNode = nil; Action: string = "DescribeClusters";
          ClusterIdentifier: string = ""; Version: string = "2012-12-01";
          MaxRecords: int = 0; TagValues: JsonNode = nil): Recallable =
  ## getDescribeClusters
  ## <p>Returns properties of provisioned clusters including general cluster properties, cluster database properties, maintenance and backup properties, and security and access properties. This operation supports pagination. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all clusters that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all clusters that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, clusters are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   Marker: string
  ##         : <p>An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusters</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <b>ClusterIdentifier</b> parameter or the <b>Marker</b> parameter, but not both. </p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching clusters that are associated with the specified key or keys. For example, suppose that you have clusters that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the clusters that have either or both of these tag keys associated with them.
  ##   Action: string (required)
  ##   ClusterIdentifier: string
  ##                    : <p>The unique identifier of a cluster whose properties you are requesting. This parameter is case sensitive.</p> <p>The default is that all clusters defined for an account are returned.</p>
  ##   Version: string (required)
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching clusters that are associated with the specified tag value or values. For example, suppose that you have clusters that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the clusters that have either or both of these tag values associated with them.
  var query_614810 = newJObject()
  add(query_614810, "Marker", newJString(Marker))
  if TagKeys != nil:
    query_614810.add "TagKeys", TagKeys
  add(query_614810, "Action", newJString(Action))
  add(query_614810, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_614810, "Version", newJString(Version))
  add(query_614810, "MaxRecords", newJInt(MaxRecords))
  if TagValues != nil:
    query_614810.add "TagValues", TagValues
  result = call_614809.call(nil, query_614810, nil, nil, nil)

var getDescribeClusters* = Call_GetDescribeClusters_614791(
    name: "getDescribeClusters", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusters",
    validator: validate_GetDescribeClusters_614792, base: "/",
    url: url_GetDescribeClusters_614793, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeDefaultClusterParameters_614850 = ref object of OpenApiRestCall_612642
proc url_PostDescribeDefaultClusterParameters_614852(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeDefaultClusterParameters_614851(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns a list of parameter settings for the specified parameter group family.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_614853 = query.getOrDefault("Action")
  valid_614853 = validateParameter(valid_614853, JString, required = true, default = newJString(
      "DescribeDefaultClusterParameters"))
  if valid_614853 != nil:
    section.add "Action", valid_614853
  var valid_614854 = query.getOrDefault("Version")
  valid_614854 = validateParameter(valid_614854, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_614854 != nil:
    section.add "Version", valid_614854
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614855 = header.getOrDefault("X-Amz-Signature")
  valid_614855 = validateParameter(valid_614855, JString, required = false,
                                 default = nil)
  if valid_614855 != nil:
    section.add "X-Amz-Signature", valid_614855
  var valid_614856 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614856 = validateParameter(valid_614856, JString, required = false,
                                 default = nil)
  if valid_614856 != nil:
    section.add "X-Amz-Content-Sha256", valid_614856
  var valid_614857 = header.getOrDefault("X-Amz-Date")
  valid_614857 = validateParameter(valid_614857, JString, required = false,
                                 default = nil)
  if valid_614857 != nil:
    section.add "X-Amz-Date", valid_614857
  var valid_614858 = header.getOrDefault("X-Amz-Credential")
  valid_614858 = validateParameter(valid_614858, JString, required = false,
                                 default = nil)
  if valid_614858 != nil:
    section.add "X-Amz-Credential", valid_614858
  var valid_614859 = header.getOrDefault("X-Amz-Security-Token")
  valid_614859 = validateParameter(valid_614859, JString, required = false,
                                 default = nil)
  if valid_614859 != nil:
    section.add "X-Amz-Security-Token", valid_614859
  var valid_614860 = header.getOrDefault("X-Amz-Algorithm")
  valid_614860 = validateParameter(valid_614860, JString, required = false,
                                 default = nil)
  if valid_614860 != nil:
    section.add "X-Amz-Algorithm", valid_614860
  var valid_614861 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614861 = validateParameter(valid_614861, JString, required = false,
                                 default = nil)
  if valid_614861 != nil:
    section.add "X-Amz-SignedHeaders", valid_614861
  result.add "header", section
  ## parameters in `formData` object:
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeDefaultClusterParameters</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   ParameterGroupFamily: JString (required)
  ##                       : The name of the cluster parameter group family.
  section = newJObject()
  var valid_614862 = formData.getOrDefault("MaxRecords")
  valid_614862 = validateParameter(valid_614862, JInt, required = false, default = nil)
  if valid_614862 != nil:
    section.add "MaxRecords", valid_614862
  var valid_614863 = formData.getOrDefault("Marker")
  valid_614863 = validateParameter(valid_614863, JString, required = false,
                                 default = nil)
  if valid_614863 != nil:
    section.add "Marker", valid_614863
  assert formData != nil, "formData argument is necessary due to required `ParameterGroupFamily` field"
  var valid_614864 = formData.getOrDefault("ParameterGroupFamily")
  valid_614864 = validateParameter(valid_614864, JString, required = true,
                                 default = nil)
  if valid_614864 != nil:
    section.add "ParameterGroupFamily", valid_614864
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614865: Call_PostDescribeDefaultClusterParameters_614850;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Returns a list of parameter settings for the specified parameter group family.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_614865.validator(path, query, header, formData, body)
  let scheme = call_614865.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614865.url(scheme.get, call_614865.host, call_614865.base,
                         call_614865.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614865, url, valid)

proc call*(call_614866: Call_PostDescribeDefaultClusterParameters_614850;
          ParameterGroupFamily: string; MaxRecords: int = 0; Marker: string = "";
          Action: string = "DescribeDefaultClusterParameters";
          Version: string = "2012-12-01"): Recallable =
  ## postDescribeDefaultClusterParameters
  ## <p>Returns a list of parameter settings for the specified parameter group family.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeDefaultClusterParameters</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   ParameterGroupFamily: string (required)
  ##                       : The name of the cluster parameter group family.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_614867 = newJObject()
  var formData_614868 = newJObject()
  add(formData_614868, "MaxRecords", newJInt(MaxRecords))
  add(formData_614868, "Marker", newJString(Marker))
  add(formData_614868, "ParameterGroupFamily", newJString(ParameterGroupFamily))
  add(query_614867, "Action", newJString(Action))
  add(query_614867, "Version", newJString(Version))
  result = call_614866.call(nil, query_614867, nil, formData_614868, nil)

var postDescribeDefaultClusterParameters* = Call_PostDescribeDefaultClusterParameters_614850(
    name: "postDescribeDefaultClusterParameters", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeDefaultClusterParameters",
    validator: validate_PostDescribeDefaultClusterParameters_614851, base: "/",
    url: url_PostDescribeDefaultClusterParameters_614852,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeDefaultClusterParameters_614832 = ref object of OpenApiRestCall_612642
proc url_GetDescribeDefaultClusterParameters_614834(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeDefaultClusterParameters_614833(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns a list of parameter settings for the specified parameter group family.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeDefaultClusterParameters</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   ParameterGroupFamily: JString (required)
  ##                       : The name of the cluster parameter group family.
  ##   Action: JString (required)
  ##   Version: JString (required)
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  section = newJObject()
  var valid_614835 = query.getOrDefault("Marker")
  valid_614835 = validateParameter(valid_614835, JString, required = false,
                                 default = nil)
  if valid_614835 != nil:
    section.add "Marker", valid_614835
  assert query != nil, "query argument is necessary due to required `ParameterGroupFamily` field"
  var valid_614836 = query.getOrDefault("ParameterGroupFamily")
  valid_614836 = validateParameter(valid_614836, JString, required = true,
                                 default = nil)
  if valid_614836 != nil:
    section.add "ParameterGroupFamily", valid_614836
  var valid_614837 = query.getOrDefault("Action")
  valid_614837 = validateParameter(valid_614837, JString, required = true, default = newJString(
      "DescribeDefaultClusterParameters"))
  if valid_614837 != nil:
    section.add "Action", valid_614837
  var valid_614838 = query.getOrDefault("Version")
  valid_614838 = validateParameter(valid_614838, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_614838 != nil:
    section.add "Version", valid_614838
  var valid_614839 = query.getOrDefault("MaxRecords")
  valid_614839 = validateParameter(valid_614839, JInt, required = false, default = nil)
  if valid_614839 != nil:
    section.add "MaxRecords", valid_614839
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614840 = header.getOrDefault("X-Amz-Signature")
  valid_614840 = validateParameter(valid_614840, JString, required = false,
                                 default = nil)
  if valid_614840 != nil:
    section.add "X-Amz-Signature", valid_614840
  var valid_614841 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614841 = validateParameter(valid_614841, JString, required = false,
                                 default = nil)
  if valid_614841 != nil:
    section.add "X-Amz-Content-Sha256", valid_614841
  var valid_614842 = header.getOrDefault("X-Amz-Date")
  valid_614842 = validateParameter(valid_614842, JString, required = false,
                                 default = nil)
  if valid_614842 != nil:
    section.add "X-Amz-Date", valid_614842
  var valid_614843 = header.getOrDefault("X-Amz-Credential")
  valid_614843 = validateParameter(valid_614843, JString, required = false,
                                 default = nil)
  if valid_614843 != nil:
    section.add "X-Amz-Credential", valid_614843
  var valid_614844 = header.getOrDefault("X-Amz-Security-Token")
  valid_614844 = validateParameter(valid_614844, JString, required = false,
                                 default = nil)
  if valid_614844 != nil:
    section.add "X-Amz-Security-Token", valid_614844
  var valid_614845 = header.getOrDefault("X-Amz-Algorithm")
  valid_614845 = validateParameter(valid_614845, JString, required = false,
                                 default = nil)
  if valid_614845 != nil:
    section.add "X-Amz-Algorithm", valid_614845
  var valid_614846 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614846 = validateParameter(valid_614846, JString, required = false,
                                 default = nil)
  if valid_614846 != nil:
    section.add "X-Amz-SignedHeaders", valid_614846
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614847: Call_GetDescribeDefaultClusterParameters_614832;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Returns a list of parameter settings for the specified parameter group family.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_614847.validator(path, query, header, formData, body)
  let scheme = call_614847.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614847.url(scheme.get, call_614847.host, call_614847.base,
                         call_614847.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614847, url, valid)

proc call*(call_614848: Call_GetDescribeDefaultClusterParameters_614832;
          ParameterGroupFamily: string; Marker: string = "";
          Action: string = "DescribeDefaultClusterParameters";
          Version: string = "2012-12-01"; MaxRecords: int = 0): Recallable =
  ## getDescribeDefaultClusterParameters
  ## <p>Returns a list of parameter settings for the specified parameter group family.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeDefaultClusterParameters</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   ParameterGroupFamily: string (required)
  ##                       : The name of the cluster parameter group family.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  var query_614849 = newJObject()
  add(query_614849, "Marker", newJString(Marker))
  add(query_614849, "ParameterGroupFamily", newJString(ParameterGroupFamily))
  add(query_614849, "Action", newJString(Action))
  add(query_614849, "Version", newJString(Version))
  add(query_614849, "MaxRecords", newJInt(MaxRecords))
  result = call_614848.call(nil, query_614849, nil, nil, nil)

var getDescribeDefaultClusterParameters* = Call_GetDescribeDefaultClusterParameters_614832(
    name: "getDescribeDefaultClusterParameters", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeDefaultClusterParameters",
    validator: validate_GetDescribeDefaultClusterParameters_614833, base: "/",
    url: url_GetDescribeDefaultClusterParameters_614834,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeEventCategories_614885 = ref object of OpenApiRestCall_612642
proc url_PostDescribeEventCategories_614887(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeEventCategories_614886(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Displays a list of event categories for all event source types, or for a specified source type. For a list of the event categories and source types, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-event-notifications.html">Amazon Redshift Event Notifications</a>.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_614888 = query.getOrDefault("Action")
  valid_614888 = validateParameter(valid_614888, JString, required = true, default = newJString(
      "DescribeEventCategories"))
  if valid_614888 != nil:
    section.add "Action", valid_614888
  var valid_614889 = query.getOrDefault("Version")
  valid_614889 = validateParameter(valid_614889, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_614889 != nil:
    section.add "Version", valid_614889
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614890 = header.getOrDefault("X-Amz-Signature")
  valid_614890 = validateParameter(valid_614890, JString, required = false,
                                 default = nil)
  if valid_614890 != nil:
    section.add "X-Amz-Signature", valid_614890
  var valid_614891 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614891 = validateParameter(valid_614891, JString, required = false,
                                 default = nil)
  if valid_614891 != nil:
    section.add "X-Amz-Content-Sha256", valid_614891
  var valid_614892 = header.getOrDefault("X-Amz-Date")
  valid_614892 = validateParameter(valid_614892, JString, required = false,
                                 default = nil)
  if valid_614892 != nil:
    section.add "X-Amz-Date", valid_614892
  var valid_614893 = header.getOrDefault("X-Amz-Credential")
  valid_614893 = validateParameter(valid_614893, JString, required = false,
                                 default = nil)
  if valid_614893 != nil:
    section.add "X-Amz-Credential", valid_614893
  var valid_614894 = header.getOrDefault("X-Amz-Security-Token")
  valid_614894 = validateParameter(valid_614894, JString, required = false,
                                 default = nil)
  if valid_614894 != nil:
    section.add "X-Amz-Security-Token", valid_614894
  var valid_614895 = header.getOrDefault("X-Amz-Algorithm")
  valid_614895 = validateParameter(valid_614895, JString, required = false,
                                 default = nil)
  if valid_614895 != nil:
    section.add "X-Amz-Algorithm", valid_614895
  var valid_614896 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614896 = validateParameter(valid_614896, JString, required = false,
                                 default = nil)
  if valid_614896 != nil:
    section.add "X-Amz-SignedHeaders", valid_614896
  result.add "header", section
  ## parameters in `formData` object:
  ##   SourceType: JString
  ##             : <p>The source type, such as cluster or parameter group, to which the described event categories apply.</p> <p>Valid values: cluster, cluster-snapshot, cluster-parameter-group, cluster-security-group, and scheduled-action.</p>
  section = newJObject()
  var valid_614897 = formData.getOrDefault("SourceType")
  valid_614897 = validateParameter(valid_614897, JString, required = false,
                                 default = nil)
  if valid_614897 != nil:
    section.add "SourceType", valid_614897
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614898: Call_PostDescribeEventCategories_614885; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Displays a list of event categories for all event source types, or for a specified source type. For a list of the event categories and source types, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-event-notifications.html">Amazon Redshift Event Notifications</a>.
  ## 
  let valid = call_614898.validator(path, query, header, formData, body)
  let scheme = call_614898.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614898.url(scheme.get, call_614898.host, call_614898.base,
                         call_614898.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614898, url, valid)

proc call*(call_614899: Call_PostDescribeEventCategories_614885;
          SourceType: string = ""; Action: string = "DescribeEventCategories";
          Version: string = "2012-12-01"): Recallable =
  ## postDescribeEventCategories
  ## Displays a list of event categories for all event source types, or for a specified source type. For a list of the event categories and source types, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-event-notifications.html">Amazon Redshift Event Notifications</a>.
  ##   SourceType: string
  ##             : <p>The source type, such as cluster or parameter group, to which the described event categories apply.</p> <p>Valid values: cluster, cluster-snapshot, cluster-parameter-group, cluster-security-group, and scheduled-action.</p>
  ##   Action: string (required)
  ##   Version: string (required)
  var query_614900 = newJObject()
  var formData_614901 = newJObject()
  add(formData_614901, "SourceType", newJString(SourceType))
  add(query_614900, "Action", newJString(Action))
  add(query_614900, "Version", newJString(Version))
  result = call_614899.call(nil, query_614900, nil, formData_614901, nil)

var postDescribeEventCategories* = Call_PostDescribeEventCategories_614885(
    name: "postDescribeEventCategories", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeEventCategories",
    validator: validate_PostDescribeEventCategories_614886, base: "/",
    url: url_PostDescribeEventCategories_614887,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeEventCategories_614869 = ref object of OpenApiRestCall_612642
proc url_GetDescribeEventCategories_614871(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeEventCategories_614870(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Displays a list of event categories for all event source types, or for a specified source type. For a list of the event categories and source types, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-event-notifications.html">Amazon Redshift Event Notifications</a>.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   SourceType: JString
  ##             : <p>The source type, such as cluster or parameter group, to which the described event categories apply.</p> <p>Valid values: cluster, cluster-snapshot, cluster-parameter-group, cluster-security-group, and scheduled-action.</p>
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_614872 = query.getOrDefault("SourceType")
  valid_614872 = validateParameter(valid_614872, JString, required = false,
                                 default = nil)
  if valid_614872 != nil:
    section.add "SourceType", valid_614872
  var valid_614873 = query.getOrDefault("Action")
  valid_614873 = validateParameter(valid_614873, JString, required = true, default = newJString(
      "DescribeEventCategories"))
  if valid_614873 != nil:
    section.add "Action", valid_614873
  var valid_614874 = query.getOrDefault("Version")
  valid_614874 = validateParameter(valid_614874, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_614874 != nil:
    section.add "Version", valid_614874
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614875 = header.getOrDefault("X-Amz-Signature")
  valid_614875 = validateParameter(valid_614875, JString, required = false,
                                 default = nil)
  if valid_614875 != nil:
    section.add "X-Amz-Signature", valid_614875
  var valid_614876 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614876 = validateParameter(valid_614876, JString, required = false,
                                 default = nil)
  if valid_614876 != nil:
    section.add "X-Amz-Content-Sha256", valid_614876
  var valid_614877 = header.getOrDefault("X-Amz-Date")
  valid_614877 = validateParameter(valid_614877, JString, required = false,
                                 default = nil)
  if valid_614877 != nil:
    section.add "X-Amz-Date", valid_614877
  var valid_614878 = header.getOrDefault("X-Amz-Credential")
  valid_614878 = validateParameter(valid_614878, JString, required = false,
                                 default = nil)
  if valid_614878 != nil:
    section.add "X-Amz-Credential", valid_614878
  var valid_614879 = header.getOrDefault("X-Amz-Security-Token")
  valid_614879 = validateParameter(valid_614879, JString, required = false,
                                 default = nil)
  if valid_614879 != nil:
    section.add "X-Amz-Security-Token", valid_614879
  var valid_614880 = header.getOrDefault("X-Amz-Algorithm")
  valid_614880 = validateParameter(valid_614880, JString, required = false,
                                 default = nil)
  if valid_614880 != nil:
    section.add "X-Amz-Algorithm", valid_614880
  var valid_614881 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614881 = validateParameter(valid_614881, JString, required = false,
                                 default = nil)
  if valid_614881 != nil:
    section.add "X-Amz-SignedHeaders", valid_614881
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614882: Call_GetDescribeEventCategories_614869; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Displays a list of event categories for all event source types, or for a specified source type. For a list of the event categories and source types, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-event-notifications.html">Amazon Redshift Event Notifications</a>.
  ## 
  let valid = call_614882.validator(path, query, header, formData, body)
  let scheme = call_614882.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614882.url(scheme.get, call_614882.host, call_614882.base,
                         call_614882.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614882, url, valid)

proc call*(call_614883: Call_GetDescribeEventCategories_614869;
          SourceType: string = ""; Action: string = "DescribeEventCategories";
          Version: string = "2012-12-01"): Recallable =
  ## getDescribeEventCategories
  ## Displays a list of event categories for all event source types, or for a specified source type. For a list of the event categories and source types, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-event-notifications.html">Amazon Redshift Event Notifications</a>.
  ##   SourceType: string
  ##             : <p>The source type, such as cluster or parameter group, to which the described event categories apply.</p> <p>Valid values: cluster, cluster-snapshot, cluster-parameter-group, cluster-security-group, and scheduled-action.</p>
  ##   Action: string (required)
  ##   Version: string (required)
  var query_614884 = newJObject()
  add(query_614884, "SourceType", newJString(SourceType))
  add(query_614884, "Action", newJString(Action))
  add(query_614884, "Version", newJString(Version))
  result = call_614883.call(nil, query_614884, nil, nil, nil)

var getDescribeEventCategories* = Call_GetDescribeEventCategories_614869(
    name: "getDescribeEventCategories", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeEventCategories",
    validator: validate_GetDescribeEventCategories_614870, base: "/",
    url: url_GetDescribeEventCategories_614871,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeEventSubscriptions_614922 = ref object of OpenApiRestCall_612642
proc url_PostDescribeEventSubscriptions_614924(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeEventSubscriptions_614923(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Lists descriptions of all the Amazon Redshift event notification subscriptions for a customer account. If you specify a subscription name, lists the description for that subscription.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all event notification subscriptions that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all subscriptions that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, subscriptions are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_614925 = query.getOrDefault("Action")
  valid_614925 = validateParameter(valid_614925, JString, required = true, default = newJString(
      "DescribeEventSubscriptions"))
  if valid_614925 != nil:
    section.add "Action", valid_614925
  var valid_614926 = query.getOrDefault("Version")
  valid_614926 = validateParameter(valid_614926, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_614926 != nil:
    section.add "Version", valid_614926
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614927 = header.getOrDefault("X-Amz-Signature")
  valid_614927 = validateParameter(valid_614927, JString, required = false,
                                 default = nil)
  if valid_614927 != nil:
    section.add "X-Amz-Signature", valid_614927
  var valid_614928 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614928 = validateParameter(valid_614928, JString, required = false,
                                 default = nil)
  if valid_614928 != nil:
    section.add "X-Amz-Content-Sha256", valid_614928
  var valid_614929 = header.getOrDefault("X-Amz-Date")
  valid_614929 = validateParameter(valid_614929, JString, required = false,
                                 default = nil)
  if valid_614929 != nil:
    section.add "X-Amz-Date", valid_614929
  var valid_614930 = header.getOrDefault("X-Amz-Credential")
  valid_614930 = validateParameter(valid_614930, JString, required = false,
                                 default = nil)
  if valid_614930 != nil:
    section.add "X-Amz-Credential", valid_614930
  var valid_614931 = header.getOrDefault("X-Amz-Security-Token")
  valid_614931 = validateParameter(valid_614931, JString, required = false,
                                 default = nil)
  if valid_614931 != nil:
    section.add "X-Amz-Security-Token", valid_614931
  var valid_614932 = header.getOrDefault("X-Amz-Algorithm")
  valid_614932 = validateParameter(valid_614932, JString, required = false,
                                 default = nil)
  if valid_614932 != nil:
    section.add "X-Amz-Algorithm", valid_614932
  var valid_614933 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614933 = validateParameter(valid_614933, JString, required = false,
                                 default = nil)
  if valid_614933 != nil:
    section.add "X-Amz-SignedHeaders", valid_614933
  result.add "header", section
  ## parameters in `formData` object:
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching event notification subscriptions that are associated with the specified key or keys. For example, suppose that you have subscriptions that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the subscriptions that have either or both of these tag keys associated with them.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a DescribeEventSubscriptions request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   SubscriptionName: JString
  ##                   : The name of the Amazon Redshift event notification subscription to be described.
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching event notification subscriptions that are associated with the specified tag value or values. For example, suppose that you have subscriptions that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the subscriptions that have either or both of these tag values associated with them.
  section = newJObject()
  var valid_614934 = formData.getOrDefault("TagKeys")
  valid_614934 = validateParameter(valid_614934, JArray, required = false,
                                 default = nil)
  if valid_614934 != nil:
    section.add "TagKeys", valid_614934
  var valid_614935 = formData.getOrDefault("MaxRecords")
  valid_614935 = validateParameter(valid_614935, JInt, required = false, default = nil)
  if valid_614935 != nil:
    section.add "MaxRecords", valid_614935
  var valid_614936 = formData.getOrDefault("Marker")
  valid_614936 = validateParameter(valid_614936, JString, required = false,
                                 default = nil)
  if valid_614936 != nil:
    section.add "Marker", valid_614936
  var valid_614937 = formData.getOrDefault("SubscriptionName")
  valid_614937 = validateParameter(valid_614937, JString, required = false,
                                 default = nil)
  if valid_614937 != nil:
    section.add "SubscriptionName", valid_614937
  var valid_614938 = formData.getOrDefault("TagValues")
  valid_614938 = validateParameter(valid_614938, JArray, required = false,
                                 default = nil)
  if valid_614938 != nil:
    section.add "TagValues", valid_614938
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614939: Call_PostDescribeEventSubscriptions_614922; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Lists descriptions of all the Amazon Redshift event notification subscriptions for a customer account. If you specify a subscription name, lists the description for that subscription.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all event notification subscriptions that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all subscriptions that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, subscriptions are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_614939.validator(path, query, header, formData, body)
  let scheme = call_614939.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614939.url(scheme.get, call_614939.host, call_614939.base,
                         call_614939.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614939, url, valid)

proc call*(call_614940: Call_PostDescribeEventSubscriptions_614922;
          TagKeys: JsonNode = nil; MaxRecords: int = 0; Marker: string = "";
          SubscriptionName: string = ""; TagValues: JsonNode = nil;
          Action: string = "DescribeEventSubscriptions";
          Version: string = "2012-12-01"): Recallable =
  ## postDescribeEventSubscriptions
  ## <p>Lists descriptions of all the Amazon Redshift event notification subscriptions for a customer account. If you specify a subscription name, lists the description for that subscription.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all event notification subscriptions that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all subscriptions that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, subscriptions are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching event notification subscriptions that are associated with the specified key or keys. For example, suppose that you have subscriptions that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the subscriptions that have either or both of these tag keys associated with them.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a DescribeEventSubscriptions request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   SubscriptionName: string
  ##                   : The name of the Amazon Redshift event notification subscription to be described.
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching event notification subscriptions that are associated with the specified tag value or values. For example, suppose that you have subscriptions that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the subscriptions that have either or both of these tag values associated with them.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_614941 = newJObject()
  var formData_614942 = newJObject()
  if TagKeys != nil:
    formData_614942.add "TagKeys", TagKeys
  add(formData_614942, "MaxRecords", newJInt(MaxRecords))
  add(formData_614942, "Marker", newJString(Marker))
  add(formData_614942, "SubscriptionName", newJString(SubscriptionName))
  if TagValues != nil:
    formData_614942.add "TagValues", TagValues
  add(query_614941, "Action", newJString(Action))
  add(query_614941, "Version", newJString(Version))
  result = call_614940.call(nil, query_614941, nil, formData_614942, nil)

var postDescribeEventSubscriptions* = Call_PostDescribeEventSubscriptions_614922(
    name: "postDescribeEventSubscriptions", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeEventSubscriptions",
    validator: validate_PostDescribeEventSubscriptions_614923, base: "/",
    url: url_PostDescribeEventSubscriptions_614924,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeEventSubscriptions_614902 = ref object of OpenApiRestCall_612642
proc url_GetDescribeEventSubscriptions_614904(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeEventSubscriptions_614903(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Lists descriptions of all the Amazon Redshift event notification subscriptions for a customer account. If you specify a subscription name, lists the description for that subscription.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all event notification subscriptions that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all subscriptions that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, subscriptions are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a DescribeEventSubscriptions request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching event notification subscriptions that are associated with the specified key or keys. For example, suppose that you have subscriptions that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the subscriptions that have either or both of these tag keys associated with them.
  ##   SubscriptionName: JString
  ##                   : The name of the Amazon Redshift event notification subscription to be described.
  ##   Action: JString (required)
  ##   Version: JString (required)
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching event notification subscriptions that are associated with the specified tag value or values. For example, suppose that you have subscriptions that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the subscriptions that have either or both of these tag values associated with them.
  section = newJObject()
  var valid_614905 = query.getOrDefault("Marker")
  valid_614905 = validateParameter(valid_614905, JString, required = false,
                                 default = nil)
  if valid_614905 != nil:
    section.add "Marker", valid_614905
  var valid_614906 = query.getOrDefault("TagKeys")
  valid_614906 = validateParameter(valid_614906, JArray, required = false,
                                 default = nil)
  if valid_614906 != nil:
    section.add "TagKeys", valid_614906
  var valid_614907 = query.getOrDefault("SubscriptionName")
  valid_614907 = validateParameter(valid_614907, JString, required = false,
                                 default = nil)
  if valid_614907 != nil:
    section.add "SubscriptionName", valid_614907
  var valid_614908 = query.getOrDefault("Action")
  valid_614908 = validateParameter(valid_614908, JString, required = true, default = newJString(
      "DescribeEventSubscriptions"))
  if valid_614908 != nil:
    section.add "Action", valid_614908
  var valid_614909 = query.getOrDefault("Version")
  valid_614909 = validateParameter(valid_614909, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_614909 != nil:
    section.add "Version", valid_614909
  var valid_614910 = query.getOrDefault("MaxRecords")
  valid_614910 = validateParameter(valid_614910, JInt, required = false, default = nil)
  if valid_614910 != nil:
    section.add "MaxRecords", valid_614910
  var valid_614911 = query.getOrDefault("TagValues")
  valid_614911 = validateParameter(valid_614911, JArray, required = false,
                                 default = nil)
  if valid_614911 != nil:
    section.add "TagValues", valid_614911
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614912 = header.getOrDefault("X-Amz-Signature")
  valid_614912 = validateParameter(valid_614912, JString, required = false,
                                 default = nil)
  if valid_614912 != nil:
    section.add "X-Amz-Signature", valid_614912
  var valid_614913 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614913 = validateParameter(valid_614913, JString, required = false,
                                 default = nil)
  if valid_614913 != nil:
    section.add "X-Amz-Content-Sha256", valid_614913
  var valid_614914 = header.getOrDefault("X-Amz-Date")
  valid_614914 = validateParameter(valid_614914, JString, required = false,
                                 default = nil)
  if valid_614914 != nil:
    section.add "X-Amz-Date", valid_614914
  var valid_614915 = header.getOrDefault("X-Amz-Credential")
  valid_614915 = validateParameter(valid_614915, JString, required = false,
                                 default = nil)
  if valid_614915 != nil:
    section.add "X-Amz-Credential", valid_614915
  var valid_614916 = header.getOrDefault("X-Amz-Security-Token")
  valid_614916 = validateParameter(valid_614916, JString, required = false,
                                 default = nil)
  if valid_614916 != nil:
    section.add "X-Amz-Security-Token", valid_614916
  var valid_614917 = header.getOrDefault("X-Amz-Algorithm")
  valid_614917 = validateParameter(valid_614917, JString, required = false,
                                 default = nil)
  if valid_614917 != nil:
    section.add "X-Amz-Algorithm", valid_614917
  var valid_614918 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614918 = validateParameter(valid_614918, JString, required = false,
                                 default = nil)
  if valid_614918 != nil:
    section.add "X-Amz-SignedHeaders", valid_614918
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614919: Call_GetDescribeEventSubscriptions_614902; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Lists descriptions of all the Amazon Redshift event notification subscriptions for a customer account. If you specify a subscription name, lists the description for that subscription.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all event notification subscriptions that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all subscriptions that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, subscriptions are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_614919.validator(path, query, header, formData, body)
  let scheme = call_614919.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614919.url(scheme.get, call_614919.host, call_614919.base,
                         call_614919.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614919, url, valid)

proc call*(call_614920: Call_GetDescribeEventSubscriptions_614902;
          Marker: string = ""; TagKeys: JsonNode = nil; SubscriptionName: string = "";
          Action: string = "DescribeEventSubscriptions";
          Version: string = "2012-12-01"; MaxRecords: int = 0; TagValues: JsonNode = nil): Recallable =
  ## getDescribeEventSubscriptions
  ## <p>Lists descriptions of all the Amazon Redshift event notification subscriptions for a customer account. If you specify a subscription name, lists the description for that subscription.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all event notification subscriptions that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all subscriptions that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, subscriptions are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a DescribeEventSubscriptions request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching event notification subscriptions that are associated with the specified key or keys. For example, suppose that you have subscriptions that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the subscriptions that have either or both of these tag keys associated with them.
  ##   SubscriptionName: string
  ##                   : The name of the Amazon Redshift event notification subscription to be described.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching event notification subscriptions that are associated with the specified tag value or values. For example, suppose that you have subscriptions that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the subscriptions that have either or both of these tag values associated with them.
  var query_614921 = newJObject()
  add(query_614921, "Marker", newJString(Marker))
  if TagKeys != nil:
    query_614921.add "TagKeys", TagKeys
  add(query_614921, "SubscriptionName", newJString(SubscriptionName))
  add(query_614921, "Action", newJString(Action))
  add(query_614921, "Version", newJString(Version))
  add(query_614921, "MaxRecords", newJInt(MaxRecords))
  if TagValues != nil:
    query_614921.add "TagValues", TagValues
  result = call_614920.call(nil, query_614921, nil, nil, nil)

var getDescribeEventSubscriptions* = Call_GetDescribeEventSubscriptions_614902(
    name: "getDescribeEventSubscriptions", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeEventSubscriptions",
    validator: validate_GetDescribeEventSubscriptions_614903, base: "/",
    url: url_GetDescribeEventSubscriptions_614904,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeEvents_614965 = ref object of OpenApiRestCall_612642
proc url_PostDescribeEvents_614967(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeEvents_614966(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Returns events related to clusters, security groups, snapshots, and parameter groups for the past 14 days. Events specific to a particular cluster, security group, snapshot or parameter group can be obtained by providing the name as a parameter. By default, the past hour of events are returned.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_614968 = query.getOrDefault("Action")
  valid_614968 = validateParameter(valid_614968, JString, required = true,
                                 default = newJString("DescribeEvents"))
  if valid_614968 != nil:
    section.add "Action", valid_614968
  var valid_614969 = query.getOrDefault("Version")
  valid_614969 = validateParameter(valid_614969, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_614969 != nil:
    section.add "Version", valid_614969
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614970 = header.getOrDefault("X-Amz-Signature")
  valid_614970 = validateParameter(valid_614970, JString, required = false,
                                 default = nil)
  if valid_614970 != nil:
    section.add "X-Amz-Signature", valid_614970
  var valid_614971 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614971 = validateParameter(valid_614971, JString, required = false,
                                 default = nil)
  if valid_614971 != nil:
    section.add "X-Amz-Content-Sha256", valid_614971
  var valid_614972 = header.getOrDefault("X-Amz-Date")
  valid_614972 = validateParameter(valid_614972, JString, required = false,
                                 default = nil)
  if valid_614972 != nil:
    section.add "X-Amz-Date", valid_614972
  var valid_614973 = header.getOrDefault("X-Amz-Credential")
  valid_614973 = validateParameter(valid_614973, JString, required = false,
                                 default = nil)
  if valid_614973 != nil:
    section.add "X-Amz-Credential", valid_614973
  var valid_614974 = header.getOrDefault("X-Amz-Security-Token")
  valid_614974 = validateParameter(valid_614974, JString, required = false,
                                 default = nil)
  if valid_614974 != nil:
    section.add "X-Amz-Security-Token", valid_614974
  var valid_614975 = header.getOrDefault("X-Amz-Algorithm")
  valid_614975 = validateParameter(valid_614975, JString, required = false,
                                 default = nil)
  if valid_614975 != nil:
    section.add "X-Amz-Algorithm", valid_614975
  var valid_614976 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614976 = validateParameter(valid_614976, JString, required = false,
                                 default = nil)
  if valid_614976 != nil:
    section.add "X-Amz-SignedHeaders", valid_614976
  result.add "header", section
  ## parameters in `formData` object:
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeEvents</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   SourceIdentifier: JString
  ##                   : <p>The identifier of the event source for which events will be returned. If this parameter is not specified, then all sources are included in the response.</p> <p>Constraints:</p> <p>If <i>SourceIdentifier</i> is supplied, <i>SourceType</i> must also be provided.</p> <ul> <li> <p>Specify a cluster identifier when <i>SourceType</i> is <code>cluster</code>.</p> </li> <li> <p>Specify a cluster security group name when <i>SourceType</i> is <code>cluster-security-group</code>.</p> </li> <li> <p>Specify a cluster parameter group name when <i>SourceType</i> is <code>cluster-parameter-group</code>.</p> </li> <li> <p>Specify a cluster snapshot identifier when <i>SourceType</i> is <code>cluster-snapshot</code>.</p> </li> </ul>
  ##   SourceType: JString
  ##             : <p>The event source to retrieve events for. If no value is specified, all events are returned.</p> <p>Constraints:</p> <p>If <i>SourceType</i> is supplied, <i>SourceIdentifier</i> must also be provided.</p> <ul> <li> <p>Specify <code>cluster</code> when <i>SourceIdentifier</i> is a cluster identifier.</p> </li> <li> <p>Specify <code>cluster-security-group</code> when <i>SourceIdentifier</i> is a cluster security group name.</p> </li> <li> <p>Specify <code>cluster-parameter-group</code> when <i>SourceIdentifier</i> is a cluster parameter group name.</p> </li> <li> <p>Specify <code>cluster-snapshot</code> when <i>SourceIdentifier</i> is a cluster snapshot identifier.</p> </li> </ul>
  ##   Duration: JInt
  ##           : <p>The number of minutes prior to the time of the request for which to retrieve events. For example, if the request is sent at 18:00 and you specify a duration of 60, then only events which have occurred after 17:00 will be returned.</p> <p>Default: <code>60</code> </p>
  ##   EndTime: JString
  ##          : <p>The end of the time interval for which to retrieve events, specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2009-07-08T18:00Z</code> </p>
  ##   StartTime: JString
  ##            : <p>The beginning of the time interval to retrieve events for, specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2009-07-08T18:00Z</code> </p>
  section = newJObject()
  var valid_614977 = formData.getOrDefault("MaxRecords")
  valid_614977 = validateParameter(valid_614977, JInt, required = false, default = nil)
  if valid_614977 != nil:
    section.add "MaxRecords", valid_614977
  var valid_614978 = formData.getOrDefault("Marker")
  valid_614978 = validateParameter(valid_614978, JString, required = false,
                                 default = nil)
  if valid_614978 != nil:
    section.add "Marker", valid_614978
  var valid_614979 = formData.getOrDefault("SourceIdentifier")
  valid_614979 = validateParameter(valid_614979, JString, required = false,
                                 default = nil)
  if valid_614979 != nil:
    section.add "SourceIdentifier", valid_614979
  var valid_614980 = formData.getOrDefault("SourceType")
  valid_614980 = validateParameter(valid_614980, JString, required = false,
                                 default = newJString("cluster"))
  if valid_614980 != nil:
    section.add "SourceType", valid_614980
  var valid_614981 = formData.getOrDefault("Duration")
  valid_614981 = validateParameter(valid_614981, JInt, required = false, default = nil)
  if valid_614981 != nil:
    section.add "Duration", valid_614981
  var valid_614982 = formData.getOrDefault("EndTime")
  valid_614982 = validateParameter(valid_614982, JString, required = false,
                                 default = nil)
  if valid_614982 != nil:
    section.add "EndTime", valid_614982
  var valid_614983 = formData.getOrDefault("StartTime")
  valid_614983 = validateParameter(valid_614983, JString, required = false,
                                 default = nil)
  if valid_614983 != nil:
    section.add "StartTime", valid_614983
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614984: Call_PostDescribeEvents_614965; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns events related to clusters, security groups, snapshots, and parameter groups for the past 14 days. Events specific to a particular cluster, security group, snapshot or parameter group can be obtained by providing the name as a parameter. By default, the past hour of events are returned.
  ## 
  let valid = call_614984.validator(path, query, header, formData, body)
  let scheme = call_614984.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614984.url(scheme.get, call_614984.host, call_614984.base,
                         call_614984.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614984, url, valid)

proc call*(call_614985: Call_PostDescribeEvents_614965; MaxRecords: int = 0;
          Marker: string = ""; SourceIdentifier: string = "";
          SourceType: string = "cluster"; Duration: int = 0; EndTime: string = "";
          StartTime: string = ""; Action: string = "DescribeEvents";
          Version: string = "2012-12-01"): Recallable =
  ## postDescribeEvents
  ## Returns events related to clusters, security groups, snapshots, and parameter groups for the past 14 days. Events specific to a particular cluster, security group, snapshot or parameter group can be obtained by providing the name as a parameter. By default, the past hour of events are returned.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeEvents</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   SourceIdentifier: string
  ##                   : <p>The identifier of the event source for which events will be returned. If this parameter is not specified, then all sources are included in the response.</p> <p>Constraints:</p> <p>If <i>SourceIdentifier</i> is supplied, <i>SourceType</i> must also be provided.</p> <ul> <li> <p>Specify a cluster identifier when <i>SourceType</i> is <code>cluster</code>.</p> </li> <li> <p>Specify a cluster security group name when <i>SourceType</i> is <code>cluster-security-group</code>.</p> </li> <li> <p>Specify a cluster parameter group name when <i>SourceType</i> is <code>cluster-parameter-group</code>.</p> </li> <li> <p>Specify a cluster snapshot identifier when <i>SourceType</i> is <code>cluster-snapshot</code>.</p> </li> </ul>
  ##   SourceType: string
  ##             : <p>The event source to retrieve events for. If no value is specified, all events are returned.</p> <p>Constraints:</p> <p>If <i>SourceType</i> is supplied, <i>SourceIdentifier</i> must also be provided.</p> <ul> <li> <p>Specify <code>cluster</code> when <i>SourceIdentifier</i> is a cluster identifier.</p> </li> <li> <p>Specify <code>cluster-security-group</code> when <i>SourceIdentifier</i> is a cluster security group name.</p> </li> <li> <p>Specify <code>cluster-parameter-group</code> when <i>SourceIdentifier</i> is a cluster parameter group name.</p> </li> <li> <p>Specify <code>cluster-snapshot</code> when <i>SourceIdentifier</i> is a cluster snapshot identifier.</p> </li> </ul>
  ##   Duration: int
  ##           : <p>The number of minutes prior to the time of the request for which to retrieve events. For example, if the request is sent at 18:00 and you specify a duration of 60, then only events which have occurred after 17:00 will be returned.</p> <p>Default: <code>60</code> </p>
  ##   EndTime: string
  ##          : <p>The end of the time interval for which to retrieve events, specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2009-07-08T18:00Z</code> </p>
  ##   StartTime: string
  ##            : <p>The beginning of the time interval to retrieve events for, specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2009-07-08T18:00Z</code> </p>
  ##   Action: string (required)
  ##   Version: string (required)
  var query_614986 = newJObject()
  var formData_614987 = newJObject()
  add(formData_614987, "MaxRecords", newJInt(MaxRecords))
  add(formData_614987, "Marker", newJString(Marker))
  add(formData_614987, "SourceIdentifier", newJString(SourceIdentifier))
  add(formData_614987, "SourceType", newJString(SourceType))
  add(formData_614987, "Duration", newJInt(Duration))
  add(formData_614987, "EndTime", newJString(EndTime))
  add(formData_614987, "StartTime", newJString(StartTime))
  add(query_614986, "Action", newJString(Action))
  add(query_614986, "Version", newJString(Version))
  result = call_614985.call(nil, query_614986, nil, formData_614987, nil)

var postDescribeEvents* = Call_PostDescribeEvents_614965(
    name: "postDescribeEvents", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeEvents",
    validator: validate_PostDescribeEvents_614966, base: "/",
    url: url_PostDescribeEvents_614967, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeEvents_614943 = ref object of OpenApiRestCall_612642
proc url_GetDescribeEvents_614945(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeEvents_614944(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## Returns events related to clusters, security groups, snapshots, and parameter groups for the past 14 days. Events specific to a particular cluster, security group, snapshot or parameter group can be obtained by providing the name as a parameter. By default, the past hour of events are returned.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeEvents</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   SourceType: JString
  ##             : <p>The event source to retrieve events for. If no value is specified, all events are returned.</p> <p>Constraints:</p> <p>If <i>SourceType</i> is supplied, <i>SourceIdentifier</i> must also be provided.</p> <ul> <li> <p>Specify <code>cluster</code> when <i>SourceIdentifier</i> is a cluster identifier.</p> </li> <li> <p>Specify <code>cluster-security-group</code> when <i>SourceIdentifier</i> is a cluster security group name.</p> </li> <li> <p>Specify <code>cluster-parameter-group</code> when <i>SourceIdentifier</i> is a cluster parameter group name.</p> </li> <li> <p>Specify <code>cluster-snapshot</code> when <i>SourceIdentifier</i> is a cluster snapshot identifier.</p> </li> </ul>
  ##   SourceIdentifier: JString
  ##                   : <p>The identifier of the event source for which events will be returned. If this parameter is not specified, then all sources are included in the response.</p> <p>Constraints:</p> <p>If <i>SourceIdentifier</i> is supplied, <i>SourceType</i> must also be provided.</p> <ul> <li> <p>Specify a cluster identifier when <i>SourceType</i> is <code>cluster</code>.</p> </li> <li> <p>Specify a cluster security group name when <i>SourceType</i> is <code>cluster-security-group</code>.</p> </li> <li> <p>Specify a cluster parameter group name when <i>SourceType</i> is <code>cluster-parameter-group</code>.</p> </li> <li> <p>Specify a cluster snapshot identifier when <i>SourceType</i> is <code>cluster-snapshot</code>.</p> </li> </ul>
  ##   Action: JString (required)
  ##   StartTime: JString
  ##            : <p>The beginning of the time interval to retrieve events for, specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2009-07-08T18:00Z</code> </p>
  ##   Duration: JInt
  ##           : <p>The number of minutes prior to the time of the request for which to retrieve events. For example, if the request is sent at 18:00 and you specify a duration of 60, then only events which have occurred after 17:00 will be returned.</p> <p>Default: <code>60</code> </p>
  ##   EndTime: JString
  ##          : <p>The end of the time interval for which to retrieve events, specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2009-07-08T18:00Z</code> </p>
  ##   Version: JString (required)
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  section = newJObject()
  var valid_614946 = query.getOrDefault("Marker")
  valid_614946 = validateParameter(valid_614946, JString, required = false,
                                 default = nil)
  if valid_614946 != nil:
    section.add "Marker", valid_614946
  var valid_614947 = query.getOrDefault("SourceType")
  valid_614947 = validateParameter(valid_614947, JString, required = false,
                                 default = newJString("cluster"))
  if valid_614947 != nil:
    section.add "SourceType", valid_614947
  var valid_614948 = query.getOrDefault("SourceIdentifier")
  valid_614948 = validateParameter(valid_614948, JString, required = false,
                                 default = nil)
  if valid_614948 != nil:
    section.add "SourceIdentifier", valid_614948
  var valid_614949 = query.getOrDefault("Action")
  valid_614949 = validateParameter(valid_614949, JString, required = true,
                                 default = newJString("DescribeEvents"))
  if valid_614949 != nil:
    section.add "Action", valid_614949
  var valid_614950 = query.getOrDefault("StartTime")
  valid_614950 = validateParameter(valid_614950, JString, required = false,
                                 default = nil)
  if valid_614950 != nil:
    section.add "StartTime", valid_614950
  var valid_614951 = query.getOrDefault("Duration")
  valid_614951 = validateParameter(valid_614951, JInt, required = false, default = nil)
  if valid_614951 != nil:
    section.add "Duration", valid_614951
  var valid_614952 = query.getOrDefault("EndTime")
  valid_614952 = validateParameter(valid_614952, JString, required = false,
                                 default = nil)
  if valid_614952 != nil:
    section.add "EndTime", valid_614952
  var valid_614953 = query.getOrDefault("Version")
  valid_614953 = validateParameter(valid_614953, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_614953 != nil:
    section.add "Version", valid_614953
  var valid_614954 = query.getOrDefault("MaxRecords")
  valid_614954 = validateParameter(valid_614954, JInt, required = false, default = nil)
  if valid_614954 != nil:
    section.add "MaxRecords", valid_614954
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614955 = header.getOrDefault("X-Amz-Signature")
  valid_614955 = validateParameter(valid_614955, JString, required = false,
                                 default = nil)
  if valid_614955 != nil:
    section.add "X-Amz-Signature", valid_614955
  var valid_614956 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614956 = validateParameter(valid_614956, JString, required = false,
                                 default = nil)
  if valid_614956 != nil:
    section.add "X-Amz-Content-Sha256", valid_614956
  var valid_614957 = header.getOrDefault("X-Amz-Date")
  valid_614957 = validateParameter(valid_614957, JString, required = false,
                                 default = nil)
  if valid_614957 != nil:
    section.add "X-Amz-Date", valid_614957
  var valid_614958 = header.getOrDefault("X-Amz-Credential")
  valid_614958 = validateParameter(valid_614958, JString, required = false,
                                 default = nil)
  if valid_614958 != nil:
    section.add "X-Amz-Credential", valid_614958
  var valid_614959 = header.getOrDefault("X-Amz-Security-Token")
  valid_614959 = validateParameter(valid_614959, JString, required = false,
                                 default = nil)
  if valid_614959 != nil:
    section.add "X-Amz-Security-Token", valid_614959
  var valid_614960 = header.getOrDefault("X-Amz-Algorithm")
  valid_614960 = validateParameter(valid_614960, JString, required = false,
                                 default = nil)
  if valid_614960 != nil:
    section.add "X-Amz-Algorithm", valid_614960
  var valid_614961 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614961 = validateParameter(valid_614961, JString, required = false,
                                 default = nil)
  if valid_614961 != nil:
    section.add "X-Amz-SignedHeaders", valid_614961
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614962: Call_GetDescribeEvents_614943; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns events related to clusters, security groups, snapshots, and parameter groups for the past 14 days. Events specific to a particular cluster, security group, snapshot or parameter group can be obtained by providing the name as a parameter. By default, the past hour of events are returned.
  ## 
  let valid = call_614962.validator(path, query, header, formData, body)
  let scheme = call_614962.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614962.url(scheme.get, call_614962.host, call_614962.base,
                         call_614962.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614962, url, valid)

proc call*(call_614963: Call_GetDescribeEvents_614943; Marker: string = "";
          SourceType: string = "cluster"; SourceIdentifier: string = "";
          Action: string = "DescribeEvents"; StartTime: string = ""; Duration: int = 0;
          EndTime: string = ""; Version: string = "2012-12-01"; MaxRecords: int = 0): Recallable =
  ## getDescribeEvents
  ## Returns events related to clusters, security groups, snapshots, and parameter groups for the past 14 days. Events specific to a particular cluster, security group, snapshot or parameter group can be obtained by providing the name as a parameter. By default, the past hour of events are returned.
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeEvents</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   SourceType: string
  ##             : <p>The event source to retrieve events for. If no value is specified, all events are returned.</p> <p>Constraints:</p> <p>If <i>SourceType</i> is supplied, <i>SourceIdentifier</i> must also be provided.</p> <ul> <li> <p>Specify <code>cluster</code> when <i>SourceIdentifier</i> is a cluster identifier.</p> </li> <li> <p>Specify <code>cluster-security-group</code> when <i>SourceIdentifier</i> is a cluster security group name.</p> </li> <li> <p>Specify <code>cluster-parameter-group</code> when <i>SourceIdentifier</i> is a cluster parameter group name.</p> </li> <li> <p>Specify <code>cluster-snapshot</code> when <i>SourceIdentifier</i> is a cluster snapshot identifier.</p> </li> </ul>
  ##   SourceIdentifier: string
  ##                   : <p>The identifier of the event source for which events will be returned. If this parameter is not specified, then all sources are included in the response.</p> <p>Constraints:</p> <p>If <i>SourceIdentifier</i> is supplied, <i>SourceType</i> must also be provided.</p> <ul> <li> <p>Specify a cluster identifier when <i>SourceType</i> is <code>cluster</code>.</p> </li> <li> <p>Specify a cluster security group name when <i>SourceType</i> is <code>cluster-security-group</code>.</p> </li> <li> <p>Specify a cluster parameter group name when <i>SourceType</i> is <code>cluster-parameter-group</code>.</p> </li> <li> <p>Specify a cluster snapshot identifier when <i>SourceType</i> is <code>cluster-snapshot</code>.</p> </li> </ul>
  ##   Action: string (required)
  ##   StartTime: string
  ##            : <p>The beginning of the time interval to retrieve events for, specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2009-07-08T18:00Z</code> </p>
  ##   Duration: int
  ##           : <p>The number of minutes prior to the time of the request for which to retrieve events. For example, if the request is sent at 18:00 and you specify a duration of 60, then only events which have occurred after 17:00 will be returned.</p> <p>Default: <code>60</code> </p>
  ##   EndTime: string
  ##          : <p>The end of the time interval for which to retrieve events, specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2009-07-08T18:00Z</code> </p>
  ##   Version: string (required)
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  var query_614964 = newJObject()
  add(query_614964, "Marker", newJString(Marker))
  add(query_614964, "SourceType", newJString(SourceType))
  add(query_614964, "SourceIdentifier", newJString(SourceIdentifier))
  add(query_614964, "Action", newJString(Action))
  add(query_614964, "StartTime", newJString(StartTime))
  add(query_614964, "Duration", newJInt(Duration))
  add(query_614964, "EndTime", newJString(EndTime))
  add(query_614964, "Version", newJString(Version))
  add(query_614964, "MaxRecords", newJInt(MaxRecords))
  result = call_614963.call(nil, query_614964, nil, nil, nil)

var getDescribeEvents* = Call_GetDescribeEvents_614943(name: "getDescribeEvents",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=DescribeEvents", validator: validate_GetDescribeEvents_614944,
    base: "/", url: url_GetDescribeEvents_614945,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeHsmClientCertificates_615008 = ref object of OpenApiRestCall_612642
proc url_PostDescribeHsmClientCertificates_615010(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeHsmClientCertificates_615009(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns information about the specified HSM client certificate. If no certificate ID is specified, returns information about all the HSM certificates owned by your AWS customer account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM client certificates that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all HSM client certificates that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, HSM client certificates are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_615011 = query.getOrDefault("Action")
  valid_615011 = validateParameter(valid_615011, JString, required = true, default = newJString(
      "DescribeHsmClientCertificates"))
  if valid_615011 != nil:
    section.add "Action", valid_615011
  var valid_615012 = query.getOrDefault("Version")
  valid_615012 = validateParameter(valid_615012, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_615012 != nil:
    section.add "Version", valid_615012
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_615013 = header.getOrDefault("X-Amz-Signature")
  valid_615013 = validateParameter(valid_615013, JString, required = false,
                                 default = nil)
  if valid_615013 != nil:
    section.add "X-Amz-Signature", valid_615013
  var valid_615014 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_615014 = validateParameter(valid_615014, JString, required = false,
                                 default = nil)
  if valid_615014 != nil:
    section.add "X-Amz-Content-Sha256", valid_615014
  var valid_615015 = header.getOrDefault("X-Amz-Date")
  valid_615015 = validateParameter(valid_615015, JString, required = false,
                                 default = nil)
  if valid_615015 != nil:
    section.add "X-Amz-Date", valid_615015
  var valid_615016 = header.getOrDefault("X-Amz-Credential")
  valid_615016 = validateParameter(valid_615016, JString, required = false,
                                 default = nil)
  if valid_615016 != nil:
    section.add "X-Amz-Credential", valid_615016
  var valid_615017 = header.getOrDefault("X-Amz-Security-Token")
  valid_615017 = validateParameter(valid_615017, JString, required = false,
                                 default = nil)
  if valid_615017 != nil:
    section.add "X-Amz-Security-Token", valid_615017
  var valid_615018 = header.getOrDefault("X-Amz-Algorithm")
  valid_615018 = validateParameter(valid_615018, JString, required = false,
                                 default = nil)
  if valid_615018 != nil:
    section.add "X-Amz-Algorithm", valid_615018
  var valid_615019 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_615019 = validateParameter(valid_615019, JString, required = false,
                                 default = nil)
  if valid_615019 != nil:
    section.add "X-Amz-SignedHeaders", valid_615019
  result.add "header", section
  ## parameters in `formData` object:
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching HSM client certificates that are associated with the specified key or keys. For example, suppose that you have HSM client certificates that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the HSM client certificates that have either or both of these tag keys associated with them.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeHsmClientCertificates</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching HSM client certificates that are associated with the specified tag value or values. For example, suppose that you have HSM client certificates that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the HSM client certificates that have either or both of these tag values associated with them.
  ##   HsmClientCertificateIdentifier: JString
  ##                                 : The identifier of a specific HSM client certificate for which you want information. If no identifier is specified, information is returned for all HSM client certificates owned by your AWS customer account.
  section = newJObject()
  var valid_615020 = formData.getOrDefault("TagKeys")
  valid_615020 = validateParameter(valid_615020, JArray, required = false,
                                 default = nil)
  if valid_615020 != nil:
    section.add "TagKeys", valid_615020
  var valid_615021 = formData.getOrDefault("MaxRecords")
  valid_615021 = validateParameter(valid_615021, JInt, required = false, default = nil)
  if valid_615021 != nil:
    section.add "MaxRecords", valid_615021
  var valid_615022 = formData.getOrDefault("Marker")
  valid_615022 = validateParameter(valid_615022, JString, required = false,
                                 default = nil)
  if valid_615022 != nil:
    section.add "Marker", valid_615022
  var valid_615023 = formData.getOrDefault("TagValues")
  valid_615023 = validateParameter(valid_615023, JArray, required = false,
                                 default = nil)
  if valid_615023 != nil:
    section.add "TagValues", valid_615023
  var valid_615024 = formData.getOrDefault("HsmClientCertificateIdentifier")
  valid_615024 = validateParameter(valid_615024, JString, required = false,
                                 default = nil)
  if valid_615024 != nil:
    section.add "HsmClientCertificateIdentifier", valid_615024
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_615025: Call_PostDescribeHsmClientCertificates_615008;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Returns information about the specified HSM client certificate. If no certificate ID is specified, returns information about all the HSM certificates owned by your AWS customer account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM client certificates that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all HSM client certificates that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, HSM client certificates are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_615025.validator(path, query, header, formData, body)
  let scheme = call_615025.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_615025.url(scheme.get, call_615025.host, call_615025.base,
                         call_615025.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_615025, url, valid)

proc call*(call_615026: Call_PostDescribeHsmClientCertificates_615008;
          TagKeys: JsonNode = nil; MaxRecords: int = 0; Marker: string = "";
          TagValues: JsonNode = nil;
          Action: string = "DescribeHsmClientCertificates";
          HsmClientCertificateIdentifier: string = "";
          Version: string = "2012-12-01"): Recallable =
  ## postDescribeHsmClientCertificates
  ## <p>Returns information about the specified HSM client certificate. If no certificate ID is specified, returns information about all the HSM certificates owned by your AWS customer account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM client certificates that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all HSM client certificates that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, HSM client certificates are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching HSM client certificates that are associated with the specified key or keys. For example, suppose that you have HSM client certificates that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the HSM client certificates that have either or both of these tag keys associated with them.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeHsmClientCertificates</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching HSM client certificates that are associated with the specified tag value or values. For example, suppose that you have HSM client certificates that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the HSM client certificates that have either or both of these tag values associated with them.
  ##   Action: string (required)
  ##   HsmClientCertificateIdentifier: string
  ##                                 : The identifier of a specific HSM client certificate for which you want information. If no identifier is specified, information is returned for all HSM client certificates owned by your AWS customer account.
  ##   Version: string (required)
  var query_615027 = newJObject()
  var formData_615028 = newJObject()
  if TagKeys != nil:
    formData_615028.add "TagKeys", TagKeys
  add(formData_615028, "MaxRecords", newJInt(MaxRecords))
  add(formData_615028, "Marker", newJString(Marker))
  if TagValues != nil:
    formData_615028.add "TagValues", TagValues
  add(query_615027, "Action", newJString(Action))
  add(formData_615028, "HsmClientCertificateIdentifier",
      newJString(HsmClientCertificateIdentifier))
  add(query_615027, "Version", newJString(Version))
  result = call_615026.call(nil, query_615027, nil, formData_615028, nil)

var postDescribeHsmClientCertificates* = Call_PostDescribeHsmClientCertificates_615008(
    name: "postDescribeHsmClientCertificates", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeHsmClientCertificates",
    validator: validate_PostDescribeHsmClientCertificates_615009, base: "/",
    url: url_PostDescribeHsmClientCertificates_615010,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeHsmClientCertificates_614988 = ref object of OpenApiRestCall_612642
proc url_GetDescribeHsmClientCertificates_614990(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeHsmClientCertificates_614989(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns information about the specified HSM client certificate. If no certificate ID is specified, returns information about all the HSM certificates owned by your AWS customer account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM client certificates that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all HSM client certificates that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, HSM client certificates are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeHsmClientCertificates</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   HsmClientCertificateIdentifier: JString
  ##                                 : The identifier of a specific HSM client certificate for which you want information. If no identifier is specified, information is returned for all HSM client certificates owned by your AWS customer account.
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching HSM client certificates that are associated with the specified key or keys. For example, suppose that you have HSM client certificates that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the HSM client certificates that have either or both of these tag keys associated with them.
  ##   Action: JString (required)
  ##   Version: JString (required)
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching HSM client certificates that are associated with the specified tag value or values. For example, suppose that you have HSM client certificates that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the HSM client certificates that have either or both of these tag values associated with them.
  section = newJObject()
  var valid_614991 = query.getOrDefault("Marker")
  valid_614991 = validateParameter(valid_614991, JString, required = false,
                                 default = nil)
  if valid_614991 != nil:
    section.add "Marker", valid_614991
  var valid_614992 = query.getOrDefault("HsmClientCertificateIdentifier")
  valid_614992 = validateParameter(valid_614992, JString, required = false,
                                 default = nil)
  if valid_614992 != nil:
    section.add "HsmClientCertificateIdentifier", valid_614992
  var valid_614993 = query.getOrDefault("TagKeys")
  valid_614993 = validateParameter(valid_614993, JArray, required = false,
                                 default = nil)
  if valid_614993 != nil:
    section.add "TagKeys", valid_614993
  var valid_614994 = query.getOrDefault("Action")
  valid_614994 = validateParameter(valid_614994, JString, required = true, default = newJString(
      "DescribeHsmClientCertificates"))
  if valid_614994 != nil:
    section.add "Action", valid_614994
  var valid_614995 = query.getOrDefault("Version")
  valid_614995 = validateParameter(valid_614995, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_614995 != nil:
    section.add "Version", valid_614995
  var valid_614996 = query.getOrDefault("MaxRecords")
  valid_614996 = validateParameter(valid_614996, JInt, required = false, default = nil)
  if valid_614996 != nil:
    section.add "MaxRecords", valid_614996
  var valid_614997 = query.getOrDefault("TagValues")
  valid_614997 = validateParameter(valid_614997, JArray, required = false,
                                 default = nil)
  if valid_614997 != nil:
    section.add "TagValues", valid_614997
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614998 = header.getOrDefault("X-Amz-Signature")
  valid_614998 = validateParameter(valid_614998, JString, required = false,
                                 default = nil)
  if valid_614998 != nil:
    section.add "X-Amz-Signature", valid_614998
  var valid_614999 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614999 = validateParameter(valid_614999, JString, required = false,
                                 default = nil)
  if valid_614999 != nil:
    section.add "X-Amz-Content-Sha256", valid_614999
  var valid_615000 = header.getOrDefault("X-Amz-Date")
  valid_615000 = validateParameter(valid_615000, JString, required = false,
                                 default = nil)
  if valid_615000 != nil:
    section.add "X-Amz-Date", valid_615000
  var valid_615001 = header.getOrDefault("X-Amz-Credential")
  valid_615001 = validateParameter(valid_615001, JString, required = false,
                                 default = nil)
  if valid_615001 != nil:
    section.add "X-Amz-Credential", valid_615001
  var valid_615002 = header.getOrDefault("X-Amz-Security-Token")
  valid_615002 = validateParameter(valid_615002, JString, required = false,
                                 default = nil)
  if valid_615002 != nil:
    section.add "X-Amz-Security-Token", valid_615002
  var valid_615003 = header.getOrDefault("X-Amz-Algorithm")
  valid_615003 = validateParameter(valid_615003, JString, required = false,
                                 default = nil)
  if valid_615003 != nil:
    section.add "X-Amz-Algorithm", valid_615003
  var valid_615004 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_615004 = validateParameter(valid_615004, JString, required = false,
                                 default = nil)
  if valid_615004 != nil:
    section.add "X-Amz-SignedHeaders", valid_615004
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_615005: Call_GetDescribeHsmClientCertificates_614988;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Returns information about the specified HSM client certificate. If no certificate ID is specified, returns information about all the HSM certificates owned by your AWS customer account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM client certificates that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all HSM client certificates that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, HSM client certificates are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_615005.validator(path, query, header, formData, body)
  let scheme = call_615005.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_615005.url(scheme.get, call_615005.host, call_615005.base,
                         call_615005.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_615005, url, valid)

proc call*(call_615006: Call_GetDescribeHsmClientCertificates_614988;
          Marker: string = ""; HsmClientCertificateIdentifier: string = "";
          TagKeys: JsonNode = nil; Action: string = "DescribeHsmClientCertificates";
          Version: string = "2012-12-01"; MaxRecords: int = 0; TagValues: JsonNode = nil): Recallable =
  ## getDescribeHsmClientCertificates
  ## <p>Returns information about the specified HSM client certificate. If no certificate ID is specified, returns information about all the HSM certificates owned by your AWS customer account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM client certificates that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all HSM client certificates that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, HSM client certificates are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeHsmClientCertificates</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   HsmClientCertificateIdentifier: string
  ##                                 : The identifier of a specific HSM client certificate for which you want information. If no identifier is specified, information is returned for all HSM client certificates owned by your AWS customer account.
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching HSM client certificates that are associated with the specified key or keys. For example, suppose that you have HSM client certificates that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the HSM client certificates that have either or both of these tag keys associated with them.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching HSM client certificates that are associated with the specified tag value or values. For example, suppose that you have HSM client certificates that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the HSM client certificates that have either or both of these tag values associated with them.
  var query_615007 = newJObject()
  add(query_615007, "Marker", newJString(Marker))
  add(query_615007, "HsmClientCertificateIdentifier",
      newJString(HsmClientCertificateIdentifier))
  if TagKeys != nil:
    query_615007.add "TagKeys", TagKeys
  add(query_615007, "Action", newJString(Action))
  add(query_615007, "Version", newJString(Version))
  add(query_615007, "MaxRecords", newJInt(MaxRecords))
  if TagValues != nil:
    query_615007.add "TagValues", TagValues
  result = call_615006.call(nil, query_615007, nil, nil, nil)

var getDescribeHsmClientCertificates* = Call_GetDescribeHsmClientCertificates_614988(
    name: "getDescribeHsmClientCertificates", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeHsmClientCertificates",
    validator: validate_GetDescribeHsmClientCertificates_614989, base: "/",
    url: url_GetDescribeHsmClientCertificates_614990,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeHsmConfigurations_615049 = ref object of OpenApiRestCall_612642
proc url_PostDescribeHsmConfigurations_615051(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeHsmConfigurations_615050(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns information about the specified Amazon Redshift HSM configuration. If no configuration ID is specified, returns information about all the HSM configurations owned by your AWS customer account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM connections that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all HSM connections that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, HSM connections are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_615052 = query.getOrDefault("Action")
  valid_615052 = validateParameter(valid_615052, JString, required = true, default = newJString(
      "DescribeHsmConfigurations"))
  if valid_615052 != nil:
    section.add "Action", valid_615052
  var valid_615053 = query.getOrDefault("Version")
  valid_615053 = validateParameter(valid_615053, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_615053 != nil:
    section.add "Version", valid_615053
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_615054 = header.getOrDefault("X-Amz-Signature")
  valid_615054 = validateParameter(valid_615054, JString, required = false,
                                 default = nil)
  if valid_615054 != nil:
    section.add "X-Amz-Signature", valid_615054
  var valid_615055 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_615055 = validateParameter(valid_615055, JString, required = false,
                                 default = nil)
  if valid_615055 != nil:
    section.add "X-Amz-Content-Sha256", valid_615055
  var valid_615056 = header.getOrDefault("X-Amz-Date")
  valid_615056 = validateParameter(valid_615056, JString, required = false,
                                 default = nil)
  if valid_615056 != nil:
    section.add "X-Amz-Date", valid_615056
  var valid_615057 = header.getOrDefault("X-Amz-Credential")
  valid_615057 = validateParameter(valid_615057, JString, required = false,
                                 default = nil)
  if valid_615057 != nil:
    section.add "X-Amz-Credential", valid_615057
  var valid_615058 = header.getOrDefault("X-Amz-Security-Token")
  valid_615058 = validateParameter(valid_615058, JString, required = false,
                                 default = nil)
  if valid_615058 != nil:
    section.add "X-Amz-Security-Token", valid_615058
  var valid_615059 = header.getOrDefault("X-Amz-Algorithm")
  valid_615059 = validateParameter(valid_615059, JString, required = false,
                                 default = nil)
  if valid_615059 != nil:
    section.add "X-Amz-Algorithm", valid_615059
  var valid_615060 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_615060 = validateParameter(valid_615060, JString, required = false,
                                 default = nil)
  if valid_615060 != nil:
    section.add "X-Amz-SignedHeaders", valid_615060
  result.add "header", section
  ## parameters in `formData` object:
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching HSM configurations that are associated with the specified key or keys. For example, suppose that you have HSM configurations that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the HSM configurations that have either or both of these tag keys associated with them.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeHsmConfigurations</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching HSM configurations that are associated with the specified tag value or values. For example, suppose that you have HSM configurations that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the HSM configurations that have either or both of these tag values associated with them.
  ##   HsmConfigurationIdentifier: JString
  ##                             : The identifier of a specific Amazon Redshift HSM configuration to be described. If no identifier is specified, information is returned for all HSM configurations owned by your AWS customer account.
  section = newJObject()
  var valid_615061 = formData.getOrDefault("TagKeys")
  valid_615061 = validateParameter(valid_615061, JArray, required = false,
                                 default = nil)
  if valid_615061 != nil:
    section.add "TagKeys", valid_615061
  var valid_615062 = formData.getOrDefault("MaxRecords")
  valid_615062 = validateParameter(valid_615062, JInt, required = false, default = nil)
  if valid_615062 != nil:
    section.add "MaxRecords", valid_615062
  var valid_615063 = formData.getOrDefault("Marker")
  valid_615063 = validateParameter(valid_615063, JString, required = false,
                                 default = nil)
  if valid_615063 != nil:
    section.add "Marker", valid_615063
  var valid_615064 = formData.getOrDefault("TagValues")
  valid_615064 = validateParameter(valid_615064, JArray, required = false,
                                 default = nil)
  if valid_615064 != nil:
    section.add "TagValues", valid_615064
  var valid_615065 = formData.getOrDefault("HsmConfigurationIdentifier")
  valid_615065 = validateParameter(valid_615065, JString, required = false,
                                 default = nil)
  if valid_615065 != nil:
    section.add "HsmConfigurationIdentifier", valid_615065
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_615066: Call_PostDescribeHsmConfigurations_615049; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns information about the specified Amazon Redshift HSM configuration. If no configuration ID is specified, returns information about all the HSM configurations owned by your AWS customer account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM connections that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all HSM connections that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, HSM connections are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_615066.validator(path, query, header, formData, body)
  let scheme = call_615066.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_615066.url(scheme.get, call_615066.host, call_615066.base,
                         call_615066.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_615066, url, valid)

proc call*(call_615067: Call_PostDescribeHsmConfigurations_615049;
          TagKeys: JsonNode = nil; MaxRecords: int = 0; Marker: string = "";
          TagValues: JsonNode = nil; Action: string = "DescribeHsmConfigurations";
          Version: string = "2012-12-01"; HsmConfigurationIdentifier: string = ""): Recallable =
  ## postDescribeHsmConfigurations
  ## <p>Returns information about the specified Amazon Redshift HSM configuration. If no configuration ID is specified, returns information about all the HSM configurations owned by your AWS customer account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM connections that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all HSM connections that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, HSM connections are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching HSM configurations that are associated with the specified key or keys. For example, suppose that you have HSM configurations that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the HSM configurations that have either or both of these tag keys associated with them.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeHsmConfigurations</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching HSM configurations that are associated with the specified tag value or values. For example, suppose that you have HSM configurations that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the HSM configurations that have either or both of these tag values associated with them.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   HsmConfigurationIdentifier: string
  ##                             : The identifier of a specific Amazon Redshift HSM configuration to be described. If no identifier is specified, information is returned for all HSM configurations owned by your AWS customer account.
  var query_615068 = newJObject()
  var formData_615069 = newJObject()
  if TagKeys != nil:
    formData_615069.add "TagKeys", TagKeys
  add(formData_615069, "MaxRecords", newJInt(MaxRecords))
  add(formData_615069, "Marker", newJString(Marker))
  if TagValues != nil:
    formData_615069.add "TagValues", TagValues
  add(query_615068, "Action", newJString(Action))
  add(query_615068, "Version", newJString(Version))
  add(formData_615069, "HsmConfigurationIdentifier",
      newJString(HsmConfigurationIdentifier))
  result = call_615067.call(nil, query_615068, nil, formData_615069, nil)

var postDescribeHsmConfigurations* = Call_PostDescribeHsmConfigurations_615049(
    name: "postDescribeHsmConfigurations", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeHsmConfigurations",
    validator: validate_PostDescribeHsmConfigurations_615050, base: "/",
    url: url_PostDescribeHsmConfigurations_615051,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeHsmConfigurations_615029 = ref object of OpenApiRestCall_612642
proc url_GetDescribeHsmConfigurations_615031(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeHsmConfigurations_615030(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns information about the specified Amazon Redshift HSM configuration. If no configuration ID is specified, returns information about all the HSM configurations owned by your AWS customer account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM connections that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all HSM connections that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, HSM connections are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeHsmConfigurations</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching HSM configurations that are associated with the specified key or keys. For example, suppose that you have HSM configurations that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the HSM configurations that have either or both of these tag keys associated with them.
  ##   Action: JString (required)
  ##   HsmConfigurationIdentifier: JString
  ##                             : The identifier of a specific Amazon Redshift HSM configuration to be described. If no identifier is specified, information is returned for all HSM configurations owned by your AWS customer account.
  ##   Version: JString (required)
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching HSM configurations that are associated with the specified tag value or values. For example, suppose that you have HSM configurations that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the HSM configurations that have either or both of these tag values associated with them.
  section = newJObject()
  var valid_615032 = query.getOrDefault("Marker")
  valid_615032 = validateParameter(valid_615032, JString, required = false,
                                 default = nil)
  if valid_615032 != nil:
    section.add "Marker", valid_615032
  var valid_615033 = query.getOrDefault("TagKeys")
  valid_615033 = validateParameter(valid_615033, JArray, required = false,
                                 default = nil)
  if valid_615033 != nil:
    section.add "TagKeys", valid_615033
  var valid_615034 = query.getOrDefault("Action")
  valid_615034 = validateParameter(valid_615034, JString, required = true, default = newJString(
      "DescribeHsmConfigurations"))
  if valid_615034 != nil:
    section.add "Action", valid_615034
  var valid_615035 = query.getOrDefault("HsmConfigurationIdentifier")
  valid_615035 = validateParameter(valid_615035, JString, required = false,
                                 default = nil)
  if valid_615035 != nil:
    section.add "HsmConfigurationIdentifier", valid_615035
  var valid_615036 = query.getOrDefault("Version")
  valid_615036 = validateParameter(valid_615036, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_615036 != nil:
    section.add "Version", valid_615036
  var valid_615037 = query.getOrDefault("MaxRecords")
  valid_615037 = validateParameter(valid_615037, JInt, required = false, default = nil)
  if valid_615037 != nil:
    section.add "MaxRecords", valid_615037
  var valid_615038 = query.getOrDefault("TagValues")
  valid_615038 = validateParameter(valid_615038, JArray, required = false,
                                 default = nil)
  if valid_615038 != nil:
    section.add "TagValues", valid_615038
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_615039 = header.getOrDefault("X-Amz-Signature")
  valid_615039 = validateParameter(valid_615039, JString, required = false,
                                 default = nil)
  if valid_615039 != nil:
    section.add "X-Amz-Signature", valid_615039
  var valid_615040 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_615040 = validateParameter(valid_615040, JString, required = false,
                                 default = nil)
  if valid_615040 != nil:
    section.add "X-Amz-Content-Sha256", valid_615040
  var valid_615041 = header.getOrDefault("X-Amz-Date")
  valid_615041 = validateParameter(valid_615041, JString, required = false,
                                 default = nil)
  if valid_615041 != nil:
    section.add "X-Amz-Date", valid_615041
  var valid_615042 = header.getOrDefault("X-Amz-Credential")
  valid_615042 = validateParameter(valid_615042, JString, required = false,
                                 default = nil)
  if valid_615042 != nil:
    section.add "X-Amz-Credential", valid_615042
  var valid_615043 = header.getOrDefault("X-Amz-Security-Token")
  valid_615043 = validateParameter(valid_615043, JString, required = false,
                                 default = nil)
  if valid_615043 != nil:
    section.add "X-Amz-Security-Token", valid_615043
  var valid_615044 = header.getOrDefault("X-Amz-Algorithm")
  valid_615044 = validateParameter(valid_615044, JString, required = false,
                                 default = nil)
  if valid_615044 != nil:
    section.add "X-Amz-Algorithm", valid_615044
  var valid_615045 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_615045 = validateParameter(valid_615045, JString, required = false,
                                 default = nil)
  if valid_615045 != nil:
    section.add "X-Amz-SignedHeaders", valid_615045
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_615046: Call_GetDescribeHsmConfigurations_615029; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns information about the specified Amazon Redshift HSM configuration. If no configuration ID is specified, returns information about all the HSM configurations owned by your AWS customer account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM connections that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all HSM connections that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, HSM connections are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_615046.validator(path, query, header, formData, body)
  let scheme = call_615046.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_615046.url(scheme.get, call_615046.host, call_615046.base,
                         call_615046.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_615046, url, valid)

proc call*(call_615047: Call_GetDescribeHsmConfigurations_615029;
          Marker: string = ""; TagKeys: JsonNode = nil;
          Action: string = "DescribeHsmConfigurations";
          HsmConfigurationIdentifier: string = ""; Version: string = "2012-12-01";
          MaxRecords: int = 0; TagValues: JsonNode = nil): Recallable =
  ## getDescribeHsmConfigurations
  ## <p>Returns information about the specified Amazon Redshift HSM configuration. If no configuration ID is specified, returns information about all the HSM configurations owned by your AWS customer account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM connections that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all HSM connections that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, HSM connections are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeHsmConfigurations</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching HSM configurations that are associated with the specified key or keys. For example, suppose that you have HSM configurations that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the HSM configurations that have either or both of these tag keys associated with them.
  ##   Action: string (required)
  ##   HsmConfigurationIdentifier: string
  ##                             : The identifier of a specific Amazon Redshift HSM configuration to be described. If no identifier is specified, information is returned for all HSM configurations owned by your AWS customer account.
  ##   Version: string (required)
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching HSM configurations that are associated with the specified tag value or values. For example, suppose that you have HSM configurations that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the HSM configurations that have either or both of these tag values associated with them.
  var query_615048 = newJObject()
  add(query_615048, "Marker", newJString(Marker))
  if TagKeys != nil:
    query_615048.add "TagKeys", TagKeys
  add(query_615048, "Action", newJString(Action))
  add(query_615048, "HsmConfigurationIdentifier",
      newJString(HsmConfigurationIdentifier))
  add(query_615048, "Version", newJString(Version))
  add(query_615048, "MaxRecords", newJInt(MaxRecords))
  if TagValues != nil:
    query_615048.add "TagValues", TagValues
  result = call_615047.call(nil, query_615048, nil, nil, nil)

var getDescribeHsmConfigurations* = Call_GetDescribeHsmConfigurations_615029(
    name: "getDescribeHsmConfigurations", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeHsmConfigurations",
    validator: validate_GetDescribeHsmConfigurations_615030, base: "/",
    url: url_GetDescribeHsmConfigurations_615031,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeLoggingStatus_615086 = ref object of OpenApiRestCall_612642
proc url_PostDescribeLoggingStatus_615088(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeLoggingStatus_615087(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Describes whether information, such as queries and connection attempts, is being logged for the specified Amazon Redshift cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_615089 = query.getOrDefault("Action")
  valid_615089 = validateParameter(valid_615089, JString, required = true,
                                 default = newJString("DescribeLoggingStatus"))
  if valid_615089 != nil:
    section.add "Action", valid_615089
  var valid_615090 = query.getOrDefault("Version")
  valid_615090 = validateParameter(valid_615090, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_615090 != nil:
    section.add "Version", valid_615090
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_615091 = header.getOrDefault("X-Amz-Signature")
  valid_615091 = validateParameter(valid_615091, JString, required = false,
                                 default = nil)
  if valid_615091 != nil:
    section.add "X-Amz-Signature", valid_615091
  var valid_615092 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_615092 = validateParameter(valid_615092, JString, required = false,
                                 default = nil)
  if valid_615092 != nil:
    section.add "X-Amz-Content-Sha256", valid_615092
  var valid_615093 = header.getOrDefault("X-Amz-Date")
  valid_615093 = validateParameter(valid_615093, JString, required = false,
                                 default = nil)
  if valid_615093 != nil:
    section.add "X-Amz-Date", valid_615093
  var valid_615094 = header.getOrDefault("X-Amz-Credential")
  valid_615094 = validateParameter(valid_615094, JString, required = false,
                                 default = nil)
  if valid_615094 != nil:
    section.add "X-Amz-Credential", valid_615094
  var valid_615095 = header.getOrDefault("X-Amz-Security-Token")
  valid_615095 = validateParameter(valid_615095, JString, required = false,
                                 default = nil)
  if valid_615095 != nil:
    section.add "X-Amz-Security-Token", valid_615095
  var valid_615096 = header.getOrDefault("X-Amz-Algorithm")
  valid_615096 = validateParameter(valid_615096, JString, required = false,
                                 default = nil)
  if valid_615096 != nil:
    section.add "X-Amz-Algorithm", valid_615096
  var valid_615097 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_615097 = validateParameter(valid_615097, JString, required = false,
                                 default = nil)
  if valid_615097 != nil:
    section.add "X-Amz-SignedHeaders", valid_615097
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The identifier of the cluster from which to get the logging status.</p> <p>Example: <code>examplecluster</code> </p>
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_615098 = formData.getOrDefault("ClusterIdentifier")
  valid_615098 = validateParameter(valid_615098, JString, required = true,
                                 default = nil)
  if valid_615098 != nil:
    section.add "ClusterIdentifier", valid_615098
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_615099: Call_PostDescribeLoggingStatus_615086; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Describes whether information, such as queries and connection attempts, is being logged for the specified Amazon Redshift cluster.
  ## 
  let valid = call_615099.validator(path, query, header, formData, body)
  let scheme = call_615099.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_615099.url(scheme.get, call_615099.host, call_615099.base,
                         call_615099.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_615099, url, valid)

proc call*(call_615100: Call_PostDescribeLoggingStatus_615086;
          ClusterIdentifier: string; Action: string = "DescribeLoggingStatus";
          Version: string = "2012-12-01"): Recallable =
  ## postDescribeLoggingStatus
  ## Describes whether information, such as queries and connection attempts, is being logged for the specified Amazon Redshift cluster.
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The identifier of the cluster from which to get the logging status.</p> <p>Example: <code>examplecluster</code> </p>
  ##   Action: string (required)
  ##   Version: string (required)
  var query_615101 = newJObject()
  var formData_615102 = newJObject()
  add(formData_615102, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_615101, "Action", newJString(Action))
  add(query_615101, "Version", newJString(Version))
  result = call_615100.call(nil, query_615101, nil, formData_615102, nil)

var postDescribeLoggingStatus* = Call_PostDescribeLoggingStatus_615086(
    name: "postDescribeLoggingStatus", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeLoggingStatus",
    validator: validate_PostDescribeLoggingStatus_615087, base: "/",
    url: url_PostDescribeLoggingStatus_615088,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeLoggingStatus_615070 = ref object of OpenApiRestCall_612642
proc url_GetDescribeLoggingStatus_615072(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeLoggingStatus_615071(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Describes whether information, such as queries and connection attempts, is being logged for the specified Amazon Redshift cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The identifier of the cluster from which to get the logging status.</p> <p>Example: <code>examplecluster</code> </p>
  ##   Version: JString (required)
  section = newJObject()
  var valid_615073 = query.getOrDefault("Action")
  valid_615073 = validateParameter(valid_615073, JString, required = true,
                                 default = newJString("DescribeLoggingStatus"))
  if valid_615073 != nil:
    section.add "Action", valid_615073
  var valid_615074 = query.getOrDefault("ClusterIdentifier")
  valid_615074 = validateParameter(valid_615074, JString, required = true,
                                 default = nil)
  if valid_615074 != nil:
    section.add "ClusterIdentifier", valid_615074
  var valid_615075 = query.getOrDefault("Version")
  valid_615075 = validateParameter(valid_615075, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_615075 != nil:
    section.add "Version", valid_615075
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_615076 = header.getOrDefault("X-Amz-Signature")
  valid_615076 = validateParameter(valid_615076, JString, required = false,
                                 default = nil)
  if valid_615076 != nil:
    section.add "X-Amz-Signature", valid_615076
  var valid_615077 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_615077 = validateParameter(valid_615077, JString, required = false,
                                 default = nil)
  if valid_615077 != nil:
    section.add "X-Amz-Content-Sha256", valid_615077
  var valid_615078 = header.getOrDefault("X-Amz-Date")
  valid_615078 = validateParameter(valid_615078, JString, required = false,
                                 default = nil)
  if valid_615078 != nil:
    section.add "X-Amz-Date", valid_615078
  var valid_615079 = header.getOrDefault("X-Amz-Credential")
  valid_615079 = validateParameter(valid_615079, JString, required = false,
                                 default = nil)
  if valid_615079 != nil:
    section.add "X-Amz-Credential", valid_615079
  var valid_615080 = header.getOrDefault("X-Amz-Security-Token")
  valid_615080 = validateParameter(valid_615080, JString, required = false,
                                 default = nil)
  if valid_615080 != nil:
    section.add "X-Amz-Security-Token", valid_615080
  var valid_615081 = header.getOrDefault("X-Amz-Algorithm")
  valid_615081 = validateParameter(valid_615081, JString, required = false,
                                 default = nil)
  if valid_615081 != nil:
    section.add "X-Amz-Algorithm", valid_615081
  var valid_615082 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_615082 = validateParameter(valid_615082, JString, required = false,
                                 default = nil)
  if valid_615082 != nil:
    section.add "X-Amz-SignedHeaders", valid_615082
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_615083: Call_GetDescribeLoggingStatus_615070; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Describes whether information, such as queries and connection attempts, is being logged for the specified Amazon Redshift cluster.
  ## 
  let valid = call_615083.validator(path, query, header, formData, body)
  let scheme = call_615083.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_615083.url(scheme.get, call_615083.host, call_615083.base,
                         call_615083.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_615083, url, valid)

proc call*(call_615084: Call_GetDescribeLoggingStatus_615070;
          ClusterIdentifier: string; Action: string = "DescribeLoggingStatus";
          Version: string = "2012-12-01"): Recallable =
  ## getDescribeLoggingStatus
  ## Describes whether information, such as queries and connection attempts, is being logged for the specified Amazon Redshift cluster.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The identifier of the cluster from which to get the logging status.</p> <p>Example: <code>examplecluster</code> </p>
  ##   Version: string (required)
  var query_615085 = newJObject()
  add(query_615085, "Action", newJString(Action))
  add(query_615085, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_615085, "Version", newJString(Version))
  result = call_615084.call(nil, query_615085, nil, nil, nil)

var getDescribeLoggingStatus* = Call_GetDescribeLoggingStatus_615070(
    name: "getDescribeLoggingStatus", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeLoggingStatus",
    validator: validate_GetDescribeLoggingStatus_615071, base: "/",
    url: url_GetDescribeLoggingStatus_615072, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeNodeConfigurationOptions_615125 = ref object of OpenApiRestCall_612642
proc url_PostDescribeNodeConfigurationOptions_615127(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeNodeConfigurationOptions_615126(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns properties of possible node configurations such as node type, number of nodes, and disk usage for the specified action type.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_615128 = query.getOrDefault("Action")
  valid_615128 = validateParameter(valid_615128, JString, required = true, default = newJString(
      "DescribeNodeConfigurationOptions"))
  if valid_615128 != nil:
    section.add "Action", valid_615128
  var valid_615129 = query.getOrDefault("Version")
  valid_615129 = validateParameter(valid_615129, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_615129 != nil:
    section.add "Version", valid_615129
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_615130 = header.getOrDefault("X-Amz-Signature")
  valid_615130 = validateParameter(valid_615130, JString, required = false,
                                 default = nil)
  if valid_615130 != nil:
    section.add "X-Amz-Signature", valid_615130
  var valid_615131 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_615131 = validateParameter(valid_615131, JString, required = false,
                                 default = nil)
  if valid_615131 != nil:
    section.add "X-Amz-Content-Sha256", valid_615131
  var valid_615132 = header.getOrDefault("X-Amz-Date")
  valid_615132 = validateParameter(valid_615132, JString, required = false,
                                 default = nil)
  if valid_615132 != nil:
    section.add "X-Amz-Date", valid_615132
  var valid_615133 = header.getOrDefault("X-Amz-Credential")
  valid_615133 = validateParameter(valid_615133, JString, required = false,
                                 default = nil)
  if valid_615133 != nil:
    section.add "X-Amz-Credential", valid_615133
  var valid_615134 = header.getOrDefault("X-Amz-Security-Token")
  valid_615134 = validateParameter(valid_615134, JString, required = false,
                                 default = nil)
  if valid_615134 != nil:
    section.add "X-Amz-Security-Token", valid_615134
  var valid_615135 = header.getOrDefault("X-Amz-Algorithm")
  valid_615135 = validateParameter(valid_615135, JString, required = false,
                                 default = nil)
  if valid_615135 != nil:
    section.add "X-Amz-Algorithm", valid_615135
  var valid_615136 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_615136 = validateParameter(valid_615136, JString, required = false,
                                 default = nil)
  if valid_615136 != nil:
    section.add "X-Amz-SignedHeaders", valid_615136
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString
  ##                    : The identifier of the cluster to evaluate for possible node configurations.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>500</code> </p> <p>Constraints: minimum 100, maximum 500.</p>
  ##   OwnerAccount: JString
  ##               : The AWS customer account used to create or copy the snapshot. Required if you are restoring a snapshot you do not own, optional if you own the snapshot.
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeNodeConfigurationOptions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   SnapshotIdentifier: JString
  ##                     : The identifier of the snapshot to evaluate for possible node configurations.
  ##   ActionType: JString (required)
  ##             : The action type to evaluate for possible node configurations. Specify "restore-cluster" to get configuration combinations based on an existing snapshot. Specify "recommend-node-config" to get configuration recommendations based on an existing cluster or snapshot. 
  ##   Filter: JArray
  ##         : A set of name, operator, and value items to filter the results.
  section = newJObject()
  var valid_615137 = formData.getOrDefault("ClusterIdentifier")
  valid_615137 = validateParameter(valid_615137, JString, required = false,
                                 default = nil)
  if valid_615137 != nil:
    section.add "ClusterIdentifier", valid_615137
  var valid_615138 = formData.getOrDefault("MaxRecords")
  valid_615138 = validateParameter(valid_615138, JInt, required = false, default = nil)
  if valid_615138 != nil:
    section.add "MaxRecords", valid_615138
  var valid_615139 = formData.getOrDefault("OwnerAccount")
  valid_615139 = validateParameter(valid_615139, JString, required = false,
                                 default = nil)
  if valid_615139 != nil:
    section.add "OwnerAccount", valid_615139
  var valid_615140 = formData.getOrDefault("Marker")
  valid_615140 = validateParameter(valid_615140, JString, required = false,
                                 default = nil)
  if valid_615140 != nil:
    section.add "Marker", valid_615140
  var valid_615141 = formData.getOrDefault("SnapshotIdentifier")
  valid_615141 = validateParameter(valid_615141, JString, required = false,
                                 default = nil)
  if valid_615141 != nil:
    section.add "SnapshotIdentifier", valid_615141
  var valid_615142 = formData.getOrDefault("ActionType")
  valid_615142 = validateParameter(valid_615142, JString, required = true,
                                 default = newJString("restore-cluster"))
  if valid_615142 != nil:
    section.add "ActionType", valid_615142
  var valid_615143 = formData.getOrDefault("Filter")
  valid_615143 = validateParameter(valid_615143, JArray, required = false,
                                 default = nil)
  if valid_615143 != nil:
    section.add "Filter", valid_615143
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_615144: Call_PostDescribeNodeConfigurationOptions_615125;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Returns properties of possible node configurations such as node type, number of nodes, and disk usage for the specified action type.
  ## 
  let valid = call_615144.validator(path, query, header, formData, body)
  let scheme = call_615144.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_615144.url(scheme.get, call_615144.host, call_615144.base,
                         call_615144.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_615144, url, valid)

proc call*(call_615145: Call_PostDescribeNodeConfigurationOptions_615125;
          ClusterIdentifier: string = ""; MaxRecords: int = 0;
          OwnerAccount: string = ""; Marker: string = "";
          SnapshotIdentifier: string = "";
          Action: string = "DescribeNodeConfigurationOptions";
          Version: string = "2012-12-01"; ActionType: string = "restore-cluster";
          Filter: JsonNode = nil): Recallable =
  ## postDescribeNodeConfigurationOptions
  ## Returns properties of possible node configurations such as node type, number of nodes, and disk usage for the specified action type.
  ##   ClusterIdentifier: string
  ##                    : The identifier of the cluster to evaluate for possible node configurations.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>500</code> </p> <p>Constraints: minimum 100, maximum 500.</p>
  ##   OwnerAccount: string
  ##               : The AWS customer account used to create or copy the snapshot. Required if you are restoring a snapshot you do not own, optional if you own the snapshot.
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeNodeConfigurationOptions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   SnapshotIdentifier: string
  ##                     : The identifier of the snapshot to evaluate for possible node configurations.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   ActionType: string (required)
  ##             : The action type to evaluate for possible node configurations. Specify "restore-cluster" to get configuration combinations based on an existing snapshot. Specify "recommend-node-config" to get configuration recommendations based on an existing cluster or snapshot. 
  ##   Filter: JArray
  ##         : A set of name, operator, and value items to filter the results.
  var query_615146 = newJObject()
  var formData_615147 = newJObject()
  add(formData_615147, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_615147, "MaxRecords", newJInt(MaxRecords))
  add(formData_615147, "OwnerAccount", newJString(OwnerAccount))
  add(formData_615147, "Marker", newJString(Marker))
  add(formData_615147, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_615146, "Action", newJString(Action))
  add(query_615146, "Version", newJString(Version))
  add(formData_615147, "ActionType", newJString(ActionType))
  if Filter != nil:
    formData_615147.add "Filter", Filter
  result = call_615145.call(nil, query_615146, nil, formData_615147, nil)

var postDescribeNodeConfigurationOptions* = Call_PostDescribeNodeConfigurationOptions_615125(
    name: "postDescribeNodeConfigurationOptions", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeNodeConfigurationOptions",
    validator: validate_PostDescribeNodeConfigurationOptions_615126, base: "/",
    url: url_PostDescribeNodeConfigurationOptions_615127,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeNodeConfigurationOptions_615103 = ref object of OpenApiRestCall_612642
proc url_GetDescribeNodeConfigurationOptions_615105(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeNodeConfigurationOptions_615104(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns properties of possible node configurations such as node type, number of nodes, and disk usage for the specified action type.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeNodeConfigurationOptions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   SnapshotIdentifier: JString
  ##                     : The identifier of the snapshot to evaluate for possible node configurations.
  ##   ActionType: JString (required)
  ##             : The action type to evaluate for possible node configurations. Specify "restore-cluster" to get configuration combinations based on an existing snapshot. Specify "recommend-node-config" to get configuration recommendations based on an existing cluster or snapshot. 
  ##   Filter: JArray
  ##         : A set of name, operator, and value items to filter the results.
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString
  ##                    : The identifier of the cluster to evaluate for possible node configurations.
  ##   OwnerAccount: JString
  ##               : The AWS customer account used to create or copy the snapshot. Required if you are restoring a snapshot you do not own, optional if you own the snapshot.
  ##   Version: JString (required)
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>500</code> </p> <p>Constraints: minimum 100, maximum 500.</p>
  section = newJObject()
  var valid_615106 = query.getOrDefault("Marker")
  valid_615106 = validateParameter(valid_615106, JString, required = false,
                                 default = nil)
  if valid_615106 != nil:
    section.add "Marker", valid_615106
  var valid_615107 = query.getOrDefault("SnapshotIdentifier")
  valid_615107 = validateParameter(valid_615107, JString, required = false,
                                 default = nil)
  if valid_615107 != nil:
    section.add "SnapshotIdentifier", valid_615107
  var valid_615108 = query.getOrDefault("ActionType")
  valid_615108 = validateParameter(valid_615108, JString, required = true,
                                 default = newJString("restore-cluster"))
  if valid_615108 != nil:
    section.add "ActionType", valid_615108
  var valid_615109 = query.getOrDefault("Filter")
  valid_615109 = validateParameter(valid_615109, JArray, required = false,
                                 default = nil)
  if valid_615109 != nil:
    section.add "Filter", valid_615109
  var valid_615110 = query.getOrDefault("Action")
  valid_615110 = validateParameter(valid_615110, JString, required = true, default = newJString(
      "DescribeNodeConfigurationOptions"))
  if valid_615110 != nil:
    section.add "Action", valid_615110
  var valid_615111 = query.getOrDefault("ClusterIdentifier")
  valid_615111 = validateParameter(valid_615111, JString, required = false,
                                 default = nil)
  if valid_615111 != nil:
    section.add "ClusterIdentifier", valid_615111
  var valid_615112 = query.getOrDefault("OwnerAccount")
  valid_615112 = validateParameter(valid_615112, JString, required = false,
                                 default = nil)
  if valid_615112 != nil:
    section.add "OwnerAccount", valid_615112
  var valid_615113 = query.getOrDefault("Version")
  valid_615113 = validateParameter(valid_615113, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_615113 != nil:
    section.add "Version", valid_615113
  var valid_615114 = query.getOrDefault("MaxRecords")
  valid_615114 = validateParameter(valid_615114, JInt, required = false, default = nil)
  if valid_615114 != nil:
    section.add "MaxRecords", valid_615114
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_615115 = header.getOrDefault("X-Amz-Signature")
  valid_615115 = validateParameter(valid_615115, JString, required = false,
                                 default = nil)
  if valid_615115 != nil:
    section.add "X-Amz-Signature", valid_615115
  var valid_615116 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_615116 = validateParameter(valid_615116, JString, required = false,
                                 default = nil)
  if valid_615116 != nil:
    section.add "X-Amz-Content-Sha256", valid_615116
  var valid_615117 = header.getOrDefault("X-Amz-Date")
  valid_615117 = validateParameter(valid_615117, JString, required = false,
                                 default = nil)
  if valid_615117 != nil:
    section.add "X-Amz-Date", valid_615117
  var valid_615118 = header.getOrDefault("X-Amz-Credential")
  valid_615118 = validateParameter(valid_615118, JString, required = false,
                                 default = nil)
  if valid_615118 != nil:
    section.add "X-Amz-Credential", valid_615118
  var valid_615119 = header.getOrDefault("X-Amz-Security-Token")
  valid_615119 = validateParameter(valid_615119, JString, required = false,
                                 default = nil)
  if valid_615119 != nil:
    section.add "X-Amz-Security-Token", valid_615119
  var valid_615120 = header.getOrDefault("X-Amz-Algorithm")
  valid_615120 = validateParameter(valid_615120, JString, required = false,
                                 default = nil)
  if valid_615120 != nil:
    section.add "X-Amz-Algorithm", valid_615120
  var valid_615121 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_615121 = validateParameter(valid_615121, JString, required = false,
                                 default = nil)
  if valid_615121 != nil:
    section.add "X-Amz-SignedHeaders", valid_615121
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_615122: Call_GetDescribeNodeConfigurationOptions_615103;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Returns properties of possible node configurations such as node type, number of nodes, and disk usage for the specified action type.
  ## 
  let valid = call_615122.validator(path, query, header, formData, body)
  let scheme = call_615122.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_615122.url(scheme.get, call_615122.host, call_615122.base,
                         call_615122.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_615122, url, valid)

proc call*(call_615123: Call_GetDescribeNodeConfigurationOptions_615103;
          Marker: string = ""; SnapshotIdentifier: string = "";
          ActionType: string = "restore-cluster"; Filter: JsonNode = nil;
          Action: string = "DescribeNodeConfigurationOptions";
          ClusterIdentifier: string = ""; OwnerAccount: string = "";
          Version: string = "2012-12-01"; MaxRecords: int = 0): Recallable =
  ## getDescribeNodeConfigurationOptions
  ## Returns properties of possible node configurations such as node type, number of nodes, and disk usage for the specified action type.
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeNodeConfigurationOptions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   SnapshotIdentifier: string
  ##                     : The identifier of the snapshot to evaluate for possible node configurations.
  ##   ActionType: string (required)
  ##             : The action type to evaluate for possible node configurations. Specify "restore-cluster" to get configuration combinations based on an existing snapshot. Specify "recommend-node-config" to get configuration recommendations based on an existing cluster or snapshot. 
  ##   Filter: JArray
  ##         : A set of name, operator, and value items to filter the results.
  ##   Action: string (required)
  ##   ClusterIdentifier: string
  ##                    : The identifier of the cluster to evaluate for possible node configurations.
  ##   OwnerAccount: string
  ##               : The AWS customer account used to create or copy the snapshot. Required if you are restoring a snapshot you do not own, optional if you own the snapshot.
  ##   Version: string (required)
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>500</code> </p> <p>Constraints: minimum 100, maximum 500.</p>
  var query_615124 = newJObject()
  add(query_615124, "Marker", newJString(Marker))
  add(query_615124, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_615124, "ActionType", newJString(ActionType))
  if Filter != nil:
    query_615124.add "Filter", Filter
  add(query_615124, "Action", newJString(Action))
  add(query_615124, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_615124, "OwnerAccount", newJString(OwnerAccount))
  add(query_615124, "Version", newJString(Version))
  add(query_615124, "MaxRecords", newJInt(MaxRecords))
  result = call_615123.call(nil, query_615124, nil, nil, nil)

var getDescribeNodeConfigurationOptions* = Call_GetDescribeNodeConfigurationOptions_615103(
    name: "getDescribeNodeConfigurationOptions", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeNodeConfigurationOptions",
    validator: validate_GetDescribeNodeConfigurationOptions_615104, base: "/",
    url: url_GetDescribeNodeConfigurationOptions_615105,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeOrderableClusterOptions_615167 = ref object of OpenApiRestCall_612642
proc url_PostDescribeOrderableClusterOptions_615169(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeOrderableClusterOptions_615168(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns a list of orderable cluster options. Before you create a new cluster you can use this operation to find what options are available, such as the EC2 Availability Zones (AZ) in the specific AWS Region that you can specify, and the node types you can request. The node types differ by available storage, memory, CPU and price. With the cost involved you might want to obtain a list of cluster options in the specific region and specify values when creating a cluster. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_615170 = query.getOrDefault("Action")
  valid_615170 = validateParameter(valid_615170, JString, required = true, default = newJString(
      "DescribeOrderableClusterOptions"))
  if valid_615170 != nil:
    section.add "Action", valid_615170
  var valid_615171 = query.getOrDefault("Version")
  valid_615171 = validateParameter(valid_615171, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_615171 != nil:
    section.add "Version", valid_615171
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_615172 = header.getOrDefault("X-Amz-Signature")
  valid_615172 = validateParameter(valid_615172, JString, required = false,
                                 default = nil)
  if valid_615172 != nil:
    section.add "X-Amz-Signature", valid_615172
  var valid_615173 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_615173 = validateParameter(valid_615173, JString, required = false,
                                 default = nil)
  if valid_615173 != nil:
    section.add "X-Amz-Content-Sha256", valid_615173
  var valid_615174 = header.getOrDefault("X-Amz-Date")
  valid_615174 = validateParameter(valid_615174, JString, required = false,
                                 default = nil)
  if valid_615174 != nil:
    section.add "X-Amz-Date", valid_615174
  var valid_615175 = header.getOrDefault("X-Amz-Credential")
  valid_615175 = validateParameter(valid_615175, JString, required = false,
                                 default = nil)
  if valid_615175 != nil:
    section.add "X-Amz-Credential", valid_615175
  var valid_615176 = header.getOrDefault("X-Amz-Security-Token")
  valid_615176 = validateParameter(valid_615176, JString, required = false,
                                 default = nil)
  if valid_615176 != nil:
    section.add "X-Amz-Security-Token", valid_615176
  var valid_615177 = header.getOrDefault("X-Amz-Algorithm")
  valid_615177 = validateParameter(valid_615177, JString, required = false,
                                 default = nil)
  if valid_615177 != nil:
    section.add "X-Amz-Algorithm", valid_615177
  var valid_615178 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_615178 = validateParameter(valid_615178, JString, required = false,
                                 default = nil)
  if valid_615178 != nil:
    section.add "X-Amz-SignedHeaders", valid_615178
  result.add "header", section
  ## parameters in `formData` object:
  ##   NodeType: JString
  ##           : The node type filter value. Specify this parameter to show only the available offerings matching the specified node type.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeOrderableClusterOptions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   ClusterVersion: JString
  ##                 : <p>The version filter value. Specify this parameter to show only the available offerings matching the specified version.</p> <p>Default: All versions.</p> <p>Constraints: Must be one of the version returned from <a>DescribeClusterVersions</a>.</p>
  section = newJObject()
  var valid_615179 = formData.getOrDefault("NodeType")
  valid_615179 = validateParameter(valid_615179, JString, required = false,
                                 default = nil)
  if valid_615179 != nil:
    section.add "NodeType", valid_615179
  var valid_615180 = formData.getOrDefault("MaxRecords")
  valid_615180 = validateParameter(valid_615180, JInt, required = false, default = nil)
  if valid_615180 != nil:
    section.add "MaxRecords", valid_615180
  var valid_615181 = formData.getOrDefault("Marker")
  valid_615181 = validateParameter(valid_615181, JString, required = false,
                                 default = nil)
  if valid_615181 != nil:
    section.add "Marker", valid_615181
  var valid_615182 = formData.getOrDefault("ClusterVersion")
  valid_615182 = validateParameter(valid_615182, JString, required = false,
                                 default = nil)
  if valid_615182 != nil:
    section.add "ClusterVersion", valid_615182
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_615183: Call_PostDescribeOrderableClusterOptions_615167;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Returns a list of orderable cluster options. Before you create a new cluster you can use this operation to find what options are available, such as the EC2 Availability Zones (AZ) in the specific AWS Region that you can specify, and the node types you can request. The node types differ by available storage, memory, CPU and price. With the cost involved you might want to obtain a list of cluster options in the specific region and specify values when creating a cluster. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.
  ## 
  let valid = call_615183.validator(path, query, header, formData, body)
  let scheme = call_615183.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_615183.url(scheme.get, call_615183.host, call_615183.base,
                         call_615183.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_615183, url, valid)

proc call*(call_615184: Call_PostDescribeOrderableClusterOptions_615167;
          NodeType: string = ""; MaxRecords: int = 0; Marker: string = "";
          Action: string = "DescribeOrderableClusterOptions";
          ClusterVersion: string = ""; Version: string = "2012-12-01"): Recallable =
  ## postDescribeOrderableClusterOptions
  ## Returns a list of orderable cluster options. Before you create a new cluster you can use this operation to find what options are available, such as the EC2 Availability Zones (AZ) in the specific AWS Region that you can specify, and the node types you can request. The node types differ by available storage, memory, CPU and price. With the cost involved you might want to obtain a list of cluster options in the specific region and specify values when creating a cluster. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.
  ##   NodeType: string
  ##           : The node type filter value. Specify this parameter to show only the available offerings matching the specified node type.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeOrderableClusterOptions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Action: string (required)
  ##   ClusterVersion: string
  ##                 : <p>The version filter value. Specify this parameter to show only the available offerings matching the specified version.</p> <p>Default: All versions.</p> <p>Constraints: Must be one of the version returned from <a>DescribeClusterVersions</a>.</p>
  ##   Version: string (required)
  var query_615185 = newJObject()
  var formData_615186 = newJObject()
  add(formData_615186, "NodeType", newJString(NodeType))
  add(formData_615186, "MaxRecords", newJInt(MaxRecords))
  add(formData_615186, "Marker", newJString(Marker))
  add(query_615185, "Action", newJString(Action))
  add(formData_615186, "ClusterVersion", newJString(ClusterVersion))
  add(query_615185, "Version", newJString(Version))
  result = call_615184.call(nil, query_615185, nil, formData_615186, nil)

var postDescribeOrderableClusterOptions* = Call_PostDescribeOrderableClusterOptions_615167(
    name: "postDescribeOrderableClusterOptions", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeOrderableClusterOptions",
    validator: validate_PostDescribeOrderableClusterOptions_615168, base: "/",
    url: url_PostDescribeOrderableClusterOptions_615169,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeOrderableClusterOptions_615148 = ref object of OpenApiRestCall_612642
proc url_GetDescribeOrderableClusterOptions_615150(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeOrderableClusterOptions_615149(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns a list of orderable cluster options. Before you create a new cluster you can use this operation to find what options are available, such as the EC2 Availability Zones (AZ) in the specific AWS Region that you can specify, and the node types you can request. The node types differ by available storage, memory, CPU and price. With the cost involved you might want to obtain a list of cluster options in the specific region and specify values when creating a cluster. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeOrderableClusterOptions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   ClusterVersion: JString
  ##                 : <p>The version filter value. Specify this parameter to show only the available offerings matching the specified version.</p> <p>Default: All versions.</p> <p>Constraints: Must be one of the version returned from <a>DescribeClusterVersions</a>.</p>
  ##   NodeType: JString
  ##           : The node type filter value. Specify this parameter to show only the available offerings matching the specified node type.
  ##   Action: JString (required)
  ##   Version: JString (required)
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  section = newJObject()
  var valid_615151 = query.getOrDefault("Marker")
  valid_615151 = validateParameter(valid_615151, JString, required = false,
                                 default = nil)
  if valid_615151 != nil:
    section.add "Marker", valid_615151
  var valid_615152 = query.getOrDefault("ClusterVersion")
  valid_615152 = validateParameter(valid_615152, JString, required = false,
                                 default = nil)
  if valid_615152 != nil:
    section.add "ClusterVersion", valid_615152
  var valid_615153 = query.getOrDefault("NodeType")
  valid_615153 = validateParameter(valid_615153, JString, required = false,
                                 default = nil)
  if valid_615153 != nil:
    section.add "NodeType", valid_615153
  var valid_615154 = query.getOrDefault("Action")
  valid_615154 = validateParameter(valid_615154, JString, required = true, default = newJString(
      "DescribeOrderableClusterOptions"))
  if valid_615154 != nil:
    section.add "Action", valid_615154
  var valid_615155 = query.getOrDefault("Version")
  valid_615155 = validateParameter(valid_615155, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_615155 != nil:
    section.add "Version", valid_615155
  var valid_615156 = query.getOrDefault("MaxRecords")
  valid_615156 = validateParameter(valid_615156, JInt, required = false, default = nil)
  if valid_615156 != nil:
    section.add "MaxRecords", valid_615156
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_615157 = header.getOrDefault("X-Amz-Signature")
  valid_615157 = validateParameter(valid_615157, JString, required = false,
                                 default = nil)
  if valid_615157 != nil:
    section.add "X-Amz-Signature", valid_615157
  var valid_615158 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_615158 = validateParameter(valid_615158, JString, required = false,
                                 default = nil)
  if valid_615158 != nil:
    section.add "X-Amz-Content-Sha256", valid_615158
  var valid_615159 = header.getOrDefault("X-Amz-Date")
  valid_615159 = validateParameter(valid_615159, JString, required = false,
                                 default = nil)
  if valid_615159 != nil:
    section.add "X-Amz-Date", valid_615159
  var valid_615160 = header.getOrDefault("X-Amz-Credential")
  valid_615160 = validateParameter(valid_615160, JString, required = false,
                                 default = nil)
  if valid_615160 != nil:
    section.add "X-Amz-Credential", valid_615160
  var valid_615161 = header.getOrDefault("X-Amz-Security-Token")
  valid_615161 = validateParameter(valid_615161, JString, required = false,
                                 default = nil)
  if valid_615161 != nil:
    section.add "X-Amz-Security-Token", valid_615161
  var valid_615162 = header.getOrDefault("X-Amz-Algorithm")
  valid_615162 = validateParameter(valid_615162, JString, required = false,
                                 default = nil)
  if valid_615162 != nil:
    section.add "X-Amz-Algorithm", valid_615162
  var valid_615163 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_615163 = validateParameter(valid_615163, JString, required = false,
                                 default = nil)
  if valid_615163 != nil:
    section.add "X-Amz-SignedHeaders", valid_615163
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_615164: Call_GetDescribeOrderableClusterOptions_615148;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Returns a list of orderable cluster options. Before you create a new cluster you can use this operation to find what options are available, such as the EC2 Availability Zones (AZ) in the specific AWS Region that you can specify, and the node types you can request. The node types differ by available storage, memory, CPU and price. With the cost involved you might want to obtain a list of cluster options in the specific region and specify values when creating a cluster. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.
  ## 
  let valid = call_615164.validator(path, query, header, formData, body)
  let scheme = call_615164.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_615164.url(scheme.get, call_615164.host, call_615164.base,
                         call_615164.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_615164, url, valid)

proc call*(call_615165: Call_GetDescribeOrderableClusterOptions_615148;
          Marker: string = ""; ClusterVersion: string = ""; NodeType: string = "";
          Action: string = "DescribeOrderableClusterOptions";
          Version: string = "2012-12-01"; MaxRecords: int = 0): Recallable =
  ## getDescribeOrderableClusterOptions
  ## Returns a list of orderable cluster options. Before you create a new cluster you can use this operation to find what options are available, such as the EC2 Availability Zones (AZ) in the specific AWS Region that you can specify, and the node types you can request. The node types differ by available storage, memory, CPU and price. With the cost involved you might want to obtain a list of cluster options in the specific region and specify values when creating a cluster. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeOrderableClusterOptions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   ClusterVersion: string
  ##                 : <p>The version filter value. Specify this parameter to show only the available offerings matching the specified version.</p> <p>Default: All versions.</p> <p>Constraints: Must be one of the version returned from <a>DescribeClusterVersions</a>.</p>
  ##   NodeType: string
  ##           : The node type filter value. Specify this parameter to show only the available offerings matching the specified node type.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  var query_615166 = newJObject()
  add(query_615166, "Marker", newJString(Marker))
  add(query_615166, "ClusterVersion", newJString(ClusterVersion))
  add(query_615166, "NodeType", newJString(NodeType))
  add(query_615166, "Action", newJString(Action))
  add(query_615166, "Version", newJString(Version))
  add(query_615166, "MaxRecords", newJInt(MaxRecords))
  result = call_615165.call(nil, query_615166, nil, nil, nil)

var getDescribeOrderableClusterOptions* = Call_GetDescribeOrderableClusterOptions_615148(
    name: "getDescribeOrderableClusterOptions", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeOrderableClusterOptions",
    validator: validate_GetDescribeOrderableClusterOptions_615149, base: "/",
    url: url_GetDescribeOrderableClusterOptions_615150,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeReservedNodeOfferings_615205 = ref object of OpenApiRestCall_612642
proc url_PostDescribeReservedNodeOfferings_615207(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeReservedNodeOfferings_615206(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns a list of the available reserved node offerings by Amazon Redshift with their descriptions including the node type, the fixed and recurring costs of reserving the node and duration the node will be reserved for you. These descriptions help you determine which reserve node offering you want to purchase. You then use the unique offering ID in you call to <a>PurchaseReservedNodeOffering</a> to reserve one or more nodes for your Amazon Redshift cluster. </p> <p> For more information about reserved node offerings, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_615208 = query.getOrDefault("Action")
  valid_615208 = validateParameter(valid_615208, JString, required = true, default = newJString(
      "DescribeReservedNodeOfferings"))
  if valid_615208 != nil:
    section.add "Action", valid_615208
  var valid_615209 = query.getOrDefault("Version")
  valid_615209 = validateParameter(valid_615209, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_615209 != nil:
    section.add "Version", valid_615209
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_615210 = header.getOrDefault("X-Amz-Signature")
  valid_615210 = validateParameter(valid_615210, JString, required = false,
                                 default = nil)
  if valid_615210 != nil:
    section.add "X-Amz-Signature", valid_615210
  var valid_615211 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_615211 = validateParameter(valid_615211, JString, required = false,
                                 default = nil)
  if valid_615211 != nil:
    section.add "X-Amz-Content-Sha256", valid_615211
  var valid_615212 = header.getOrDefault("X-Amz-Date")
  valid_615212 = validateParameter(valid_615212, JString, required = false,
                                 default = nil)
  if valid_615212 != nil:
    section.add "X-Amz-Date", valid_615212
  var valid_615213 = header.getOrDefault("X-Amz-Credential")
  valid_615213 = validateParameter(valid_615213, JString, required = false,
                                 default = nil)
  if valid_615213 != nil:
    section.add "X-Amz-Credential", valid_615213
  var valid_615214 = header.getOrDefault("X-Amz-Security-Token")
  valid_615214 = validateParameter(valid_615214, JString, required = false,
                                 default = nil)
  if valid_615214 != nil:
    section.add "X-Amz-Security-Token", valid_615214
  var valid_615215 = header.getOrDefault("X-Amz-Algorithm")
  valid_615215 = validateParameter(valid_615215, JString, required = false,
                                 default = nil)
  if valid_615215 != nil:
    section.add "X-Amz-Algorithm", valid_615215
  var valid_615216 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_615216 = validateParameter(valid_615216, JString, required = false,
                                 default = nil)
  if valid_615216 != nil:
    section.add "X-Amz-SignedHeaders", valid_615216
  result.add "header", section
  ## parameters in `formData` object:
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   ReservedNodeOfferingId: JString
  ##                         : The unique identifier for the offering.
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeReservedNodeOfferings</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  section = newJObject()
  var valid_615217 = formData.getOrDefault("MaxRecords")
  valid_615217 = validateParameter(valid_615217, JInt, required = false, default = nil)
  if valid_615217 != nil:
    section.add "MaxRecords", valid_615217
  var valid_615218 = formData.getOrDefault("ReservedNodeOfferingId")
  valid_615218 = validateParameter(valid_615218, JString, required = false,
                                 default = nil)
  if valid_615218 != nil:
    section.add "ReservedNodeOfferingId", valid_615218
  var valid_615219 = formData.getOrDefault("Marker")
  valid_615219 = validateParameter(valid_615219, JString, required = false,
                                 default = nil)
  if valid_615219 != nil:
    section.add "Marker", valid_615219
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_615220: Call_PostDescribeReservedNodeOfferings_615205;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Returns a list of the available reserved node offerings by Amazon Redshift with their descriptions including the node type, the fixed and recurring costs of reserving the node and duration the node will be reserved for you. These descriptions help you determine which reserve node offering you want to purchase. You then use the unique offering ID in you call to <a>PurchaseReservedNodeOffering</a> to reserve one or more nodes for your Amazon Redshift cluster. </p> <p> For more information about reserved node offerings, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_615220.validator(path, query, header, formData, body)
  let scheme = call_615220.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_615220.url(scheme.get, call_615220.host, call_615220.base,
                         call_615220.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_615220, url, valid)

proc call*(call_615221: Call_PostDescribeReservedNodeOfferings_615205;
          MaxRecords: int = 0; ReservedNodeOfferingId: string = ""; Marker: string = "";
          Action: string = "DescribeReservedNodeOfferings";
          Version: string = "2012-12-01"): Recallable =
  ## postDescribeReservedNodeOfferings
  ## <p>Returns a list of the available reserved node offerings by Amazon Redshift with their descriptions including the node type, the fixed and recurring costs of reserving the node and duration the node will be reserved for you. These descriptions help you determine which reserve node offering you want to purchase. You then use the unique offering ID in you call to <a>PurchaseReservedNodeOffering</a> to reserve one or more nodes for your Amazon Redshift cluster. </p> <p> For more information about reserved node offerings, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   ReservedNodeOfferingId: string
  ##                         : The unique identifier for the offering.
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeReservedNodeOfferings</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Action: string (required)
  ##   Version: string (required)
  var query_615222 = newJObject()
  var formData_615223 = newJObject()
  add(formData_615223, "MaxRecords", newJInt(MaxRecords))
  add(formData_615223, "ReservedNodeOfferingId",
      newJString(ReservedNodeOfferingId))
  add(formData_615223, "Marker", newJString(Marker))
  add(query_615222, "Action", newJString(Action))
  add(query_615222, "Version", newJString(Version))
  result = call_615221.call(nil, query_615222, nil, formData_615223, nil)

var postDescribeReservedNodeOfferings* = Call_PostDescribeReservedNodeOfferings_615205(
    name: "postDescribeReservedNodeOfferings", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeReservedNodeOfferings",
    validator: validate_PostDescribeReservedNodeOfferings_615206, base: "/",
    url: url_PostDescribeReservedNodeOfferings_615207,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeReservedNodeOfferings_615187 = ref object of OpenApiRestCall_612642
proc url_GetDescribeReservedNodeOfferings_615189(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeReservedNodeOfferings_615188(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns a list of the available reserved node offerings by Amazon Redshift with their descriptions including the node type, the fixed and recurring costs of reserving the node and duration the node will be reserved for you. These descriptions help you determine which reserve node offering you want to purchase. You then use the unique offering ID in you call to <a>PurchaseReservedNodeOffering</a> to reserve one or more nodes for your Amazon Redshift cluster. </p> <p> For more information about reserved node offerings, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeReservedNodeOfferings</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   ReservedNodeOfferingId: JString
  ##                         : The unique identifier for the offering.
  ##   Action: JString (required)
  ##   Version: JString (required)
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  section = newJObject()
  var valid_615190 = query.getOrDefault("Marker")
  valid_615190 = validateParameter(valid_615190, JString, required = false,
                                 default = nil)
  if valid_615190 != nil:
    section.add "Marker", valid_615190
  var valid_615191 = query.getOrDefault("ReservedNodeOfferingId")
  valid_615191 = validateParameter(valid_615191, JString, required = false,
                                 default = nil)
  if valid_615191 != nil:
    section.add "ReservedNodeOfferingId", valid_615191
  var valid_615192 = query.getOrDefault("Action")
  valid_615192 = validateParameter(valid_615192, JString, required = true, default = newJString(
      "DescribeReservedNodeOfferings"))
  if valid_615192 != nil:
    section.add "Action", valid_615192
  var valid_615193 = query.getOrDefault("Version")
  valid_615193 = validateParameter(valid_615193, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_615193 != nil:
    section.add "Version", valid_615193
  var valid_615194 = query.getOrDefault("MaxRecords")
  valid_615194 = validateParameter(valid_615194, JInt, required = false, default = nil)
  if valid_615194 != nil:
    section.add "MaxRecords", valid_615194
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_615195 = header.getOrDefault("X-Amz-Signature")
  valid_615195 = validateParameter(valid_615195, JString, required = false,
                                 default = nil)
  if valid_615195 != nil:
    section.add "X-Amz-Signature", valid_615195
  var valid_615196 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_615196 = validateParameter(valid_615196, JString, required = false,
                                 default = nil)
  if valid_615196 != nil:
    section.add "X-Amz-Content-Sha256", valid_615196
  var valid_615197 = header.getOrDefault("X-Amz-Date")
  valid_615197 = validateParameter(valid_615197, JString, required = false,
                                 default = nil)
  if valid_615197 != nil:
    section.add "X-Amz-Date", valid_615197
  var valid_615198 = header.getOrDefault("X-Amz-Credential")
  valid_615198 = validateParameter(valid_615198, JString, required = false,
                                 default = nil)
  if valid_615198 != nil:
    section.add "X-Amz-Credential", valid_615198
  var valid_615199 = header.getOrDefault("X-Amz-Security-Token")
  valid_615199 = validateParameter(valid_615199, JString, required = false,
                                 default = nil)
  if valid_615199 != nil:
    section.add "X-Amz-Security-Token", valid_615199
  var valid_615200 = header.getOrDefault("X-Amz-Algorithm")
  valid_615200 = validateParameter(valid_615200, JString, required = false,
                                 default = nil)
  if valid_615200 != nil:
    section.add "X-Amz-Algorithm", valid_615200
  var valid_615201 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_615201 = validateParameter(valid_615201, JString, required = false,
                                 default = nil)
  if valid_615201 != nil:
    section.add "X-Amz-SignedHeaders", valid_615201
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_615202: Call_GetDescribeReservedNodeOfferings_615187;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Returns a list of the available reserved node offerings by Amazon Redshift with their descriptions including the node type, the fixed and recurring costs of reserving the node and duration the node will be reserved for you. These descriptions help you determine which reserve node offering you want to purchase. You then use the unique offering ID in you call to <a>PurchaseReservedNodeOffering</a> to reserve one or more nodes for your Amazon Redshift cluster. </p> <p> For more information about reserved node offerings, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_615202.validator(path, query, header, formData, body)
  let scheme = call_615202.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_615202.url(scheme.get, call_615202.host, call_615202.base,
                         call_615202.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_615202, url, valid)

proc call*(call_615203: Call_GetDescribeReservedNodeOfferings_615187;
          Marker: string = ""; ReservedNodeOfferingId: string = "";
          Action: string = "DescribeReservedNodeOfferings";
          Version: string = "2012-12-01"; MaxRecords: int = 0): Recallable =
  ## getDescribeReservedNodeOfferings
  ## <p>Returns a list of the available reserved node offerings by Amazon Redshift with their descriptions including the node type, the fixed and recurring costs of reserving the node and duration the node will be reserved for you. These descriptions help you determine which reserve node offering you want to purchase. You then use the unique offering ID in you call to <a>PurchaseReservedNodeOffering</a> to reserve one or more nodes for your Amazon Redshift cluster. </p> <p> For more information about reserved node offerings, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeReservedNodeOfferings</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   ReservedNodeOfferingId: string
  ##                         : The unique identifier for the offering.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  var query_615204 = newJObject()
  add(query_615204, "Marker", newJString(Marker))
  add(query_615204, "ReservedNodeOfferingId", newJString(ReservedNodeOfferingId))
  add(query_615204, "Action", newJString(Action))
  add(query_615204, "Version", newJString(Version))
  add(query_615204, "MaxRecords", newJInt(MaxRecords))
  result = call_615203.call(nil, query_615204, nil, nil, nil)

var getDescribeReservedNodeOfferings* = Call_GetDescribeReservedNodeOfferings_615187(
    name: "getDescribeReservedNodeOfferings", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeReservedNodeOfferings",
    validator: validate_GetDescribeReservedNodeOfferings_615188, base: "/",
    url: url_GetDescribeReservedNodeOfferings_615189,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeReservedNodes_615242 = ref object of OpenApiRestCall_612642
proc url_PostDescribeReservedNodes_615244(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeReservedNodes_615243(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns the descriptions of the reserved nodes.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_615245 = query.getOrDefault("Action")
  valid_615245 = validateParameter(valid_615245, JString, required = true,
                                 default = newJString("DescribeReservedNodes"))
  if valid_615245 != nil:
    section.add "Action", valid_615245
  var valid_615246 = query.getOrDefault("Version")
  valid_615246 = validateParameter(valid_615246, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_615246 != nil:
    section.add "Version", valid_615246
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_615247 = header.getOrDefault("X-Amz-Signature")
  valid_615247 = validateParameter(valid_615247, JString, required = false,
                                 default = nil)
  if valid_615247 != nil:
    section.add "X-Amz-Signature", valid_615247
  var valid_615248 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_615248 = validateParameter(valid_615248, JString, required = false,
                                 default = nil)
  if valid_615248 != nil:
    section.add "X-Amz-Content-Sha256", valid_615248
  var valid_615249 = header.getOrDefault("X-Amz-Date")
  valid_615249 = validateParameter(valid_615249, JString, required = false,
                                 default = nil)
  if valid_615249 != nil:
    section.add "X-Amz-Date", valid_615249
  var valid_615250 = header.getOrDefault("X-Amz-Credential")
  valid_615250 = validateParameter(valid_615250, JString, required = false,
                                 default = nil)
  if valid_615250 != nil:
    section.add "X-Amz-Credential", valid_615250
  var valid_615251 = header.getOrDefault("X-Amz-Security-Token")
  valid_615251 = validateParameter(valid_615251, JString, required = false,
                                 default = nil)
  if valid_615251 != nil:
    section.add "X-Amz-Security-Token", valid_615251
  var valid_615252 = header.getOrDefault("X-Amz-Algorithm")
  valid_615252 = validateParameter(valid_615252, JString, required = false,
                                 default = nil)
  if valid_615252 != nil:
    section.add "X-Amz-Algorithm", valid_615252
  var valid_615253 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_615253 = validateParameter(valid_615253, JString, required = false,
                                 default = nil)
  if valid_615253 != nil:
    section.add "X-Amz-SignedHeaders", valid_615253
  result.add "header", section
  ## parameters in `formData` object:
  ##   ReservedNodeId: JString
  ##                 : Identifier for the node reservation.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeReservedNodes</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  section = newJObject()
  var valid_615254 = formData.getOrDefault("ReservedNodeId")
  valid_615254 = validateParameter(valid_615254, JString, required = false,
                                 default = nil)
  if valid_615254 != nil:
    section.add "ReservedNodeId", valid_615254
  var valid_615255 = formData.getOrDefault("MaxRecords")
  valid_615255 = validateParameter(valid_615255, JInt, required = false, default = nil)
  if valid_615255 != nil:
    section.add "MaxRecords", valid_615255
  var valid_615256 = formData.getOrDefault("Marker")
  valid_615256 = validateParameter(valid_615256, JString, required = false,
                                 default = nil)
  if valid_615256 != nil:
    section.add "Marker", valid_615256
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_615257: Call_PostDescribeReservedNodes_615242; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns the descriptions of the reserved nodes.
  ## 
  let valid = call_615257.validator(path, query, header, formData, body)
  let scheme = call_615257.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_615257.url(scheme.get, call_615257.host, call_615257.base,
                         call_615257.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_615257, url, valid)

proc call*(call_615258: Call_PostDescribeReservedNodes_615242;
          ReservedNodeId: string = ""; MaxRecords: int = 0; Marker: string = "";
          Action: string = "DescribeReservedNodes"; Version: string = "2012-12-01"): Recallable =
  ## postDescribeReservedNodes
  ## Returns the descriptions of the reserved nodes.
  ##   ReservedNodeId: string
  ##                 : Identifier for the node reservation.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeReservedNodes</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Action: string (required)
  ##   Version: string (required)
  var query_615259 = newJObject()
  var formData_615260 = newJObject()
  add(formData_615260, "ReservedNodeId", newJString(ReservedNodeId))
  add(formData_615260, "MaxRecords", newJInt(MaxRecords))
  add(formData_615260, "Marker", newJString(Marker))
  add(query_615259, "Action", newJString(Action))
  add(query_615259, "Version", newJString(Version))
  result = call_615258.call(nil, query_615259, nil, formData_615260, nil)

var postDescribeReservedNodes* = Call_PostDescribeReservedNodes_615242(
    name: "postDescribeReservedNodes", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeReservedNodes",
    validator: validate_PostDescribeReservedNodes_615243, base: "/",
    url: url_PostDescribeReservedNodes_615244,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeReservedNodes_615224 = ref object of OpenApiRestCall_612642
proc url_GetDescribeReservedNodes_615226(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeReservedNodes_615225(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns the descriptions of the reserved nodes.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeReservedNodes</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Action: JString (required)
  ##   ReservedNodeId: JString
  ##                 : Identifier for the node reservation.
  ##   Version: JString (required)
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  section = newJObject()
  var valid_615227 = query.getOrDefault("Marker")
  valid_615227 = validateParameter(valid_615227, JString, required = false,
                                 default = nil)
  if valid_615227 != nil:
    section.add "Marker", valid_615227
  var valid_615228 = query.getOrDefault("Action")
  valid_615228 = validateParameter(valid_615228, JString, required = true,
                                 default = newJString("DescribeReservedNodes"))
  if valid_615228 != nil:
    section.add "Action", valid_615228
  var valid_615229 = query.getOrDefault("ReservedNodeId")
  valid_615229 = validateParameter(valid_615229, JString, required = false,
                                 default = nil)
  if valid_615229 != nil:
    section.add "ReservedNodeId", valid_615229
  var valid_615230 = query.getOrDefault("Version")
  valid_615230 = validateParameter(valid_615230, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_615230 != nil:
    section.add "Version", valid_615230
  var valid_615231 = query.getOrDefault("MaxRecords")
  valid_615231 = validateParameter(valid_615231, JInt, required = false, default = nil)
  if valid_615231 != nil:
    section.add "MaxRecords", valid_615231
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_615232 = header.getOrDefault("X-Amz-Signature")
  valid_615232 = validateParameter(valid_615232, JString, required = false,
                                 default = nil)
  if valid_615232 != nil:
    section.add "X-Amz-Signature", valid_615232
  var valid_615233 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_615233 = validateParameter(valid_615233, JString, required = false,
                                 default = nil)
  if valid_615233 != nil:
    section.add "X-Amz-Content-Sha256", valid_615233
  var valid_615234 = header.getOrDefault("X-Amz-Date")
  valid_615234 = validateParameter(valid_615234, JString, required = false,
                                 default = nil)
  if valid_615234 != nil:
    section.add "X-Amz-Date", valid_615234
  var valid_615235 = header.getOrDefault("X-Amz-Credential")
  valid_615235 = validateParameter(valid_615235, JString, required = false,
                                 default = nil)
  if valid_615235 != nil:
    section.add "X-Amz-Credential", valid_615235
  var valid_615236 = header.getOrDefault("X-Amz-Security-Token")
  valid_615236 = validateParameter(valid_615236, JString, required = false,
                                 default = nil)
  if valid_615236 != nil:
    section.add "X-Amz-Security-Token", valid_615236
  var valid_615237 = header.getOrDefault("X-Amz-Algorithm")
  valid_615237 = validateParameter(valid_615237, JString, required = false,
                                 default = nil)
  if valid_615237 != nil:
    section.add "X-Amz-Algorithm", valid_615237
  var valid_615238 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_615238 = validateParameter(valid_615238, JString, required = false,
                                 default = nil)
  if valid_615238 != nil:
    section.add "X-Amz-SignedHeaders", valid_615238
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_615239: Call_GetDescribeReservedNodes_615224; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns the descriptions of the reserved nodes.
  ## 
  let valid = call_615239.validator(path, query, header, formData, body)
  let scheme = call_615239.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_615239.url(scheme.get, call_615239.host, call_615239.base,
                         call_615239.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_615239, url, valid)

proc call*(call_615240: Call_GetDescribeReservedNodes_615224; Marker: string = "";
          Action: string = "DescribeReservedNodes"; ReservedNodeId: string = "";
          Version: string = "2012-12-01"; MaxRecords: int = 0): Recallable =
  ## getDescribeReservedNodes
  ## Returns the descriptions of the reserved nodes.
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeReservedNodes</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Action: string (required)
  ##   ReservedNodeId: string
  ##                 : Identifier for the node reservation.
  ##   Version: string (required)
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  var query_615241 = newJObject()
  add(query_615241, "Marker", newJString(Marker))
  add(query_615241, "Action", newJString(Action))
  add(query_615241, "ReservedNodeId", newJString(ReservedNodeId))
  add(query_615241, "Version", newJString(Version))
  add(query_615241, "MaxRecords", newJInt(MaxRecords))
  result = call_615240.call(nil, query_615241, nil, nil, nil)

var getDescribeReservedNodes* = Call_GetDescribeReservedNodes_615224(
    name: "getDescribeReservedNodes", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeReservedNodes",
    validator: validate_GetDescribeReservedNodes_615225, base: "/",
    url: url_GetDescribeReservedNodes_615226, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeResize_615277 = ref object of OpenApiRestCall_612642
proc url_PostDescribeResize_615279(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeResize_615278(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## <p>Returns information about the last resize operation for the specified cluster. If no resize operation has ever been initiated for the specified cluster, a <code>HTTP 404</code> error is returned. If a resize operation was initiated and completed, the status of the resize remains as <code>SUCCEEDED</code> until the next resize. </p> <p>A resize operation can be requested using <a>ModifyCluster</a> and specifying a different number or type of nodes for the cluster. </p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_615280 = query.getOrDefault("Action")
  valid_615280 = validateParameter(valid_615280, JString, required = true,
                                 default = newJString("DescribeResize"))
  if valid_615280 != nil:
    section.add "Action", valid_615280
  var valid_615281 = query.getOrDefault("Version")
  valid_615281 = validateParameter(valid_615281, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_615281 != nil:
    section.add "Version", valid_615281
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_615282 = header.getOrDefault("X-Amz-Signature")
  valid_615282 = validateParameter(valid_615282, JString, required = false,
                                 default = nil)
  if valid_615282 != nil:
    section.add "X-Amz-Signature", valid_615282
  var valid_615283 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_615283 = validateParameter(valid_615283, JString, required = false,
                                 default = nil)
  if valid_615283 != nil:
    section.add "X-Amz-Content-Sha256", valid_615283
  var valid_615284 = header.getOrDefault("X-Amz-Date")
  valid_615284 = validateParameter(valid_615284, JString, required = false,
                                 default = nil)
  if valid_615284 != nil:
    section.add "X-Amz-Date", valid_615284
  var valid_615285 = header.getOrDefault("X-Amz-Credential")
  valid_615285 = validateParameter(valid_615285, JString, required = false,
                                 default = nil)
  if valid_615285 != nil:
    section.add "X-Amz-Credential", valid_615285
  var valid_615286 = header.getOrDefault("X-Amz-Security-Token")
  valid_615286 = validateParameter(valid_615286, JString, required = false,
                                 default = nil)
  if valid_615286 != nil:
    section.add "X-Amz-Security-Token", valid_615286
  var valid_615287 = header.getOrDefault("X-Amz-Algorithm")
  valid_615287 = validateParameter(valid_615287, JString, required = false,
                                 default = nil)
  if valid_615287 != nil:
    section.add "X-Amz-Algorithm", valid_615287
  var valid_615288 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_615288 = validateParameter(valid_615288, JString, required = false,
                                 default = nil)
  if valid_615288 != nil:
    section.add "X-Amz-SignedHeaders", valid_615288
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of a cluster whose resize progress you are requesting. This parameter is case-sensitive.</p> <p>By default, resize operations for all clusters defined for an AWS account are returned.</p>
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_615289 = formData.getOrDefault("ClusterIdentifier")
  valid_615289 = validateParameter(valid_615289, JString, required = true,
                                 default = nil)
  if valid_615289 != nil:
    section.add "ClusterIdentifier", valid_615289
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_615290: Call_PostDescribeResize_615277; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns information about the last resize operation for the specified cluster. If no resize operation has ever been initiated for the specified cluster, a <code>HTTP 404</code> error is returned. If a resize operation was initiated and completed, the status of the resize remains as <code>SUCCEEDED</code> until the next resize. </p> <p>A resize operation can be requested using <a>ModifyCluster</a> and specifying a different number or type of nodes for the cluster. </p>
  ## 
  let valid = call_615290.validator(path, query, header, formData, body)
  let scheme = call_615290.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_615290.url(scheme.get, call_615290.host, call_615290.base,
                         call_615290.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_615290, url, valid)

proc call*(call_615291: Call_PostDescribeResize_615277; ClusterIdentifier: string;
          Action: string = "DescribeResize"; Version: string = "2012-12-01"): Recallable =
  ## postDescribeResize
  ## <p>Returns information about the last resize operation for the specified cluster. If no resize operation has ever been initiated for the specified cluster, a <code>HTTP 404</code> error is returned. If a resize operation was initiated and completed, the status of the resize remains as <code>SUCCEEDED</code> until the next resize. </p> <p>A resize operation can be requested using <a>ModifyCluster</a> and specifying a different number or type of nodes for the cluster. </p>
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of a cluster whose resize progress you are requesting. This parameter is case-sensitive.</p> <p>By default, resize operations for all clusters defined for an AWS account are returned.</p>
  ##   Action: string (required)
  ##   Version: string (required)
  var query_615292 = newJObject()
  var formData_615293 = newJObject()
  add(formData_615293, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_615292, "Action", newJString(Action))
  add(query_615292, "Version", newJString(Version))
  result = call_615291.call(nil, query_615292, nil, formData_615293, nil)

var postDescribeResize* = Call_PostDescribeResize_615277(
    name: "postDescribeResize", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeResize",
    validator: validate_PostDescribeResize_615278, base: "/",
    url: url_PostDescribeResize_615279, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeResize_615261 = ref object of OpenApiRestCall_612642
proc url_GetDescribeResize_615263(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeResize_615262(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## <p>Returns information about the last resize operation for the specified cluster. If no resize operation has ever been initiated for the specified cluster, a <code>HTTP 404</code> error is returned. If a resize operation was initiated and completed, the status of the resize remains as <code>SUCCEEDED</code> until the next resize. </p> <p>A resize operation can be requested using <a>ModifyCluster</a> and specifying a different number or type of nodes for the cluster. </p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of a cluster whose resize progress you are requesting. This parameter is case-sensitive.</p> <p>By default, resize operations for all clusters defined for an AWS account are returned.</p>
  ##   Version: JString (required)
  section = newJObject()
  var valid_615264 = query.getOrDefault("Action")
  valid_615264 = validateParameter(valid_615264, JString, required = true,
                                 default = newJString("DescribeResize"))
  if valid_615264 != nil:
    section.add "Action", valid_615264
  var valid_615265 = query.getOrDefault("ClusterIdentifier")
  valid_615265 = validateParameter(valid_615265, JString, required = true,
                                 default = nil)
  if valid_615265 != nil:
    section.add "ClusterIdentifier", valid_615265
  var valid_615266 = query.getOrDefault("Version")
  valid_615266 = validateParameter(valid_615266, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_615266 != nil:
    section.add "Version", valid_615266
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_615267 = header.getOrDefault("X-Amz-Signature")
  valid_615267 = validateParameter(valid_615267, JString, required = false,
                                 default = nil)
  if valid_615267 != nil:
    section.add "X-Amz-Signature", valid_615267
  var valid_615268 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_615268 = validateParameter(valid_615268, JString, required = false,
                                 default = nil)
  if valid_615268 != nil:
    section.add "X-Amz-Content-Sha256", valid_615268
  var valid_615269 = header.getOrDefault("X-Amz-Date")
  valid_615269 = validateParameter(valid_615269, JString, required = false,
                                 default = nil)
  if valid_615269 != nil:
    section.add "X-Amz-Date", valid_615269
  var valid_615270 = header.getOrDefault("X-Amz-Credential")
  valid_615270 = validateParameter(valid_615270, JString, required = false,
                                 default = nil)
  if valid_615270 != nil:
    section.add "X-Amz-Credential", valid_615270
  var valid_615271 = header.getOrDefault("X-Amz-Security-Token")
  valid_615271 = validateParameter(valid_615271, JString, required = false,
                                 default = nil)
  if valid_615271 != nil:
    section.add "X-Amz-Security-Token", valid_615271
  var valid_615272 = header.getOrDefault("X-Amz-Algorithm")
  valid_615272 = validateParameter(valid_615272, JString, required = false,
                                 default = nil)
  if valid_615272 != nil:
    section.add "X-Amz-Algorithm", valid_615272
  var valid_615273 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_615273 = validateParameter(valid_615273, JString, required = false,
                                 default = nil)
  if valid_615273 != nil:
    section.add "X-Amz-SignedHeaders", valid_615273
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_615274: Call_GetDescribeResize_615261; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns information about the last resize operation for the specified cluster. If no resize operation has ever been initiated for the specified cluster, a <code>HTTP 404</code> error is returned. If a resize operation was initiated and completed, the status of the resize remains as <code>SUCCEEDED</code> until the next resize. </p> <p>A resize operation can be requested using <a>ModifyCluster</a> and specifying a different number or type of nodes for the cluster. </p>
  ## 
  let valid = call_615274.validator(path, query, header, formData, body)
  let scheme = call_615274.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_615274.url(scheme.get, call_615274.host, call_615274.base,
                         call_615274.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_615274, url, valid)

proc call*(call_615275: Call_GetDescribeResize_615261; ClusterIdentifier: string;
          Action: string = "DescribeResize"; Version: string = "2012-12-01"): Recallable =
  ## getDescribeResize
  ## <p>Returns information about the last resize operation for the specified cluster. If no resize operation has ever been initiated for the specified cluster, a <code>HTTP 404</code> error is returned. If a resize operation was initiated and completed, the status of the resize remains as <code>SUCCEEDED</code> until the next resize. </p> <p>A resize operation can be requested using <a>ModifyCluster</a> and specifying a different number or type of nodes for the cluster. </p>
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of a cluster whose resize progress you are requesting. This parameter is case-sensitive.</p> <p>By default, resize operations for all clusters defined for an AWS account are returned.</p>
  ##   Version: string (required)
  var query_615276 = newJObject()
  add(query_615276, "Action", newJString(Action))
  add(query_615276, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_615276, "Version", newJString(Version))
  result = call_615275.call(nil, query_615276, nil, nil, nil)

var getDescribeResize* = Call_GetDescribeResize_615261(name: "getDescribeResize",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=DescribeResize", validator: validate_GetDescribeResize_615262,
    base: "/", url: url_GetDescribeResize_615263,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeScheduledActions_615317 = ref object of OpenApiRestCall_612642
proc url_PostDescribeScheduledActions_615319(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeScheduledActions_615318(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Describes properties of scheduled actions. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_615320 = query.getOrDefault("Action")
  valid_615320 = validateParameter(valid_615320, JString, required = true, default = newJString(
      "DescribeScheduledActions"))
  if valid_615320 != nil:
    section.add "Action", valid_615320
  var valid_615321 = query.getOrDefault("Version")
  valid_615321 = validateParameter(valid_615321, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_615321 != nil:
    section.add "Version", valid_615321
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_615322 = header.getOrDefault("X-Amz-Signature")
  valid_615322 = validateParameter(valid_615322, JString, required = false,
                                 default = nil)
  if valid_615322 != nil:
    section.add "X-Amz-Signature", valid_615322
  var valid_615323 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_615323 = validateParameter(valid_615323, JString, required = false,
                                 default = nil)
  if valid_615323 != nil:
    section.add "X-Amz-Content-Sha256", valid_615323
  var valid_615324 = header.getOrDefault("X-Amz-Date")
  valid_615324 = validateParameter(valid_615324, JString, required = false,
                                 default = nil)
  if valid_615324 != nil:
    section.add "X-Amz-Date", valid_615324
  var valid_615325 = header.getOrDefault("X-Amz-Credential")
  valid_615325 = validateParameter(valid_615325, JString, required = false,
                                 default = nil)
  if valid_615325 != nil:
    section.add "X-Amz-Credential", valid_615325
  var valid_615326 = header.getOrDefault("X-Amz-Security-Token")
  valid_615326 = validateParameter(valid_615326, JString, required = false,
                                 default = nil)
  if valid_615326 != nil:
    section.add "X-Amz-Security-Token", valid_615326
  var valid_615327 = header.getOrDefault("X-Amz-Algorithm")
  valid_615327 = validateParameter(valid_615327, JString, required = false,
                                 default = nil)
  if valid_615327 != nil:
    section.add "X-Amz-Algorithm", valid_615327
  var valid_615328 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_615328 = validateParameter(valid_615328, JString, required = false,
                                 default = nil)
  if valid_615328 != nil:
    section.add "X-Amz-SignedHeaders", valid_615328
  result.add "header", section
  ## parameters in `formData` object:
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   ScheduledActionName: JString
  ##                      : The name of the scheduled action to retrieve. 
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeScheduledActions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   EndTime: JString
  ##          : The end time in UTC of the scheduled action to retrieve. Only active scheduled actions that have invocations before this time are retrieved.
  ##   StartTime: JString
  ##            : The start time in UTC of the scheduled actions to retrieve. Only active scheduled actions that have invocations after this time are retrieved.
  ##   Filters: JArray
  ##          : List of scheduled action filters. 
  ##   TargetActionType: JString
  ##                   : The type of the scheduled actions to retrieve. 
  ##   Active: JBool
  ##         : If true, retrieve only active scheduled actions. If false, retrieve only disabled scheduled actions. 
  section = newJObject()
  var valid_615329 = formData.getOrDefault("MaxRecords")
  valid_615329 = validateParameter(valid_615329, JInt, required = false, default = nil)
  if valid_615329 != nil:
    section.add "MaxRecords", valid_615329
  var valid_615330 = formData.getOrDefault("ScheduledActionName")
  valid_615330 = validateParameter(valid_615330, JString, required = false,
                                 default = nil)
  if valid_615330 != nil:
    section.add "ScheduledActionName", valid_615330
  var valid_615331 = formData.getOrDefault("Marker")
  valid_615331 = validateParameter(valid_615331, JString, required = false,
                                 default = nil)
  if valid_615331 != nil:
    section.add "Marker", valid_615331
  var valid_615332 = formData.getOrDefault("EndTime")
  valid_615332 = validateParameter(valid_615332, JString, required = false,
                                 default = nil)
  if valid_615332 != nil:
    section.add "EndTime", valid_615332
  var valid_615333 = formData.getOrDefault("StartTime")
  valid_615333 = validateParameter(valid_615333, JString, required = false,
                                 default = nil)
  if valid_615333 != nil:
    section.add "StartTime", valid_615333
  var valid_615334 = formData.getOrDefault("Filters")
  valid_615334 = validateParameter(valid_615334, JArray, required = false,
                                 default = nil)
  if valid_615334 != nil:
    section.add "Filters", valid_615334
  var valid_615335 = formData.getOrDefault("TargetActionType")
  valid_615335 = validateParameter(valid_615335, JString, required = false,
                                 default = newJString("ResizeCluster"))
  if valid_615335 != nil:
    section.add "TargetActionType", valid_615335
  var valid_615336 = formData.getOrDefault("Active")
  valid_615336 = validateParameter(valid_615336, JBool, required = false, default = nil)
  if valid_615336 != nil:
    section.add "Active", valid_615336
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_615337: Call_PostDescribeScheduledActions_615317; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Describes properties of scheduled actions. 
  ## 
  let valid = call_615337.validator(path, query, header, formData, body)
  let scheme = call_615337.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_615337.url(scheme.get, call_615337.host, call_615337.base,
                         call_615337.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_615337, url, valid)

proc call*(call_615338: Call_PostDescribeScheduledActions_615317;
          MaxRecords: int = 0; ScheduledActionName: string = ""; Marker: string = "";
          EndTime: string = ""; StartTime: string = "";
          Action: string = "DescribeScheduledActions"; Filters: JsonNode = nil;
          TargetActionType: string = "ResizeCluster";
          Version: string = "2012-12-01"; Active: bool = false): Recallable =
  ## postDescribeScheduledActions
  ## Describes properties of scheduled actions. 
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   ScheduledActionName: string
  ##                      : The name of the scheduled action to retrieve. 
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeScheduledActions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   EndTime: string
  ##          : The end time in UTC of the scheduled action to retrieve. Only active scheduled actions that have invocations before this time are retrieved.
  ##   StartTime: string
  ##            : The start time in UTC of the scheduled actions to retrieve. Only active scheduled actions that have invocations after this time are retrieved.
  ##   Action: string (required)
  ##   Filters: JArray
  ##          : List of scheduled action filters. 
  ##   TargetActionType: string
  ##                   : The type of the scheduled actions to retrieve. 
  ##   Version: string (required)
  ##   Active: bool
  ##         : If true, retrieve only active scheduled actions. If false, retrieve only disabled scheduled actions. 
  var query_615339 = newJObject()
  var formData_615340 = newJObject()
  add(formData_615340, "MaxRecords", newJInt(MaxRecords))
  add(formData_615340, "ScheduledActionName", newJString(ScheduledActionName))
  add(formData_615340, "Marker", newJString(Marker))
  add(formData_615340, "EndTime", newJString(EndTime))
  add(formData_615340, "StartTime", newJString(StartTime))
  add(query_615339, "Action", newJString(Action))
  if Filters != nil:
    formData_615340.add "Filters", Filters
  add(formData_615340, "TargetActionType", newJString(TargetActionType))
  add(query_615339, "Version", newJString(Version))
  add(formData_615340, "Active", newJBool(Active))
  result = call_615338.call(nil, query_615339, nil, formData_615340, nil)

var postDescribeScheduledActions* = Call_PostDescribeScheduledActions_615317(
    name: "postDescribeScheduledActions", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeScheduledActions",
    validator: validate_PostDescribeScheduledActions_615318, base: "/",
    url: url_PostDescribeScheduledActions_615319,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeScheduledActions_615294 = ref object of OpenApiRestCall_612642
proc url_GetDescribeScheduledActions_615296(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeScheduledActions_615295(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Describes properties of scheduled actions. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeScheduledActions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TargetActionType: JString
  ##                   : The type of the scheduled actions to retrieve. 
  ##   ScheduledActionName: JString
  ##                      : The name of the scheduled action to retrieve. 
  ##   Active: JBool
  ##         : If true, retrieve only active scheduled actions. If false, retrieve only disabled scheduled actions. 
  ##   Action: JString (required)
  ##   StartTime: JString
  ##            : The start time in UTC of the scheduled actions to retrieve. Only active scheduled actions that have invocations after this time are retrieved.
  ##   EndTime: JString
  ##          : The end time in UTC of the scheduled action to retrieve. Only active scheduled actions that have invocations before this time are retrieved.
  ##   Version: JString (required)
  ##   Filters: JArray
  ##          : List of scheduled action filters. 
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  section = newJObject()
  var valid_615297 = query.getOrDefault("Marker")
  valid_615297 = validateParameter(valid_615297, JString, required = false,
                                 default = nil)
  if valid_615297 != nil:
    section.add "Marker", valid_615297
  var valid_615298 = query.getOrDefault("TargetActionType")
  valid_615298 = validateParameter(valid_615298, JString, required = false,
                                 default = newJString("ResizeCluster"))
  if valid_615298 != nil:
    section.add "TargetActionType", valid_615298
  var valid_615299 = query.getOrDefault("ScheduledActionName")
  valid_615299 = validateParameter(valid_615299, JString, required = false,
                                 default = nil)
  if valid_615299 != nil:
    section.add "ScheduledActionName", valid_615299
  var valid_615300 = query.getOrDefault("Active")
  valid_615300 = validateParameter(valid_615300, JBool, required = false, default = nil)
  if valid_615300 != nil:
    section.add "Active", valid_615300
  var valid_615301 = query.getOrDefault("Action")
  valid_615301 = validateParameter(valid_615301, JString, required = true, default = newJString(
      "DescribeScheduledActions"))
  if valid_615301 != nil:
    section.add "Action", valid_615301
  var valid_615302 = query.getOrDefault("StartTime")
  valid_615302 = validateParameter(valid_615302, JString, required = false,
                                 default = nil)
  if valid_615302 != nil:
    section.add "StartTime", valid_615302
  var valid_615303 = query.getOrDefault("EndTime")
  valid_615303 = validateParameter(valid_615303, JString, required = false,
                                 default = nil)
  if valid_615303 != nil:
    section.add "EndTime", valid_615303
  var valid_615304 = query.getOrDefault("Version")
  valid_615304 = validateParameter(valid_615304, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_615304 != nil:
    section.add "Version", valid_615304
  var valid_615305 = query.getOrDefault("Filters")
  valid_615305 = validateParameter(valid_615305, JArray, required = false,
                                 default = nil)
  if valid_615305 != nil:
    section.add "Filters", valid_615305
  var valid_615306 = query.getOrDefault("MaxRecords")
  valid_615306 = validateParameter(valid_615306, JInt, required = false, default = nil)
  if valid_615306 != nil:
    section.add "MaxRecords", valid_615306
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_615307 = header.getOrDefault("X-Amz-Signature")
  valid_615307 = validateParameter(valid_615307, JString, required = false,
                                 default = nil)
  if valid_615307 != nil:
    section.add "X-Amz-Signature", valid_615307
  var valid_615308 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_615308 = validateParameter(valid_615308, JString, required = false,
                                 default = nil)
  if valid_615308 != nil:
    section.add "X-Amz-Content-Sha256", valid_615308
  var valid_615309 = header.getOrDefault("X-Amz-Date")
  valid_615309 = validateParameter(valid_615309, JString, required = false,
                                 default = nil)
  if valid_615309 != nil:
    section.add "X-Amz-Date", valid_615309
  var valid_615310 = header.getOrDefault("X-Amz-Credential")
  valid_615310 = validateParameter(valid_615310, JString, required = false,
                                 default = nil)
  if valid_615310 != nil:
    section.add "X-Amz-Credential", valid_615310
  var valid_615311 = header.getOrDefault("X-Amz-Security-Token")
  valid_615311 = validateParameter(valid_615311, JString, required = false,
                                 default = nil)
  if valid_615311 != nil:
    section.add "X-Amz-Security-Token", valid_615311
  var valid_615312 = header.getOrDefault("X-Amz-Algorithm")
  valid_615312 = validateParameter(valid_615312, JString, required = false,
                                 default = nil)
  if valid_615312 != nil:
    section.add "X-Amz-Algorithm", valid_615312
  var valid_615313 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_615313 = validateParameter(valid_615313, JString, required = false,
                                 default = nil)
  if valid_615313 != nil:
    section.add "X-Amz-SignedHeaders", valid_615313
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_615314: Call_GetDescribeScheduledActions_615294; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Describes properties of scheduled actions. 
  ## 
  let valid = call_615314.validator(path, query, header, formData, body)
  let scheme = call_615314.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_615314.url(scheme.get, call_615314.host, call_615314.base,
                         call_615314.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_615314, url, valid)

proc call*(call_615315: Call_GetDescribeScheduledActions_615294;
          Marker: string = ""; TargetActionType: string = "ResizeCluster";
          ScheduledActionName: string = ""; Active: bool = false;
          Action: string = "DescribeScheduledActions"; StartTime: string = "";
          EndTime: string = ""; Version: string = "2012-12-01"; Filters: JsonNode = nil;
          MaxRecords: int = 0): Recallable =
  ## getDescribeScheduledActions
  ## Describes properties of scheduled actions. 
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeScheduledActions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TargetActionType: string
  ##                   : The type of the scheduled actions to retrieve. 
  ##   ScheduledActionName: string
  ##                      : The name of the scheduled action to retrieve. 
  ##   Active: bool
  ##         : If true, retrieve only active scheduled actions. If false, retrieve only disabled scheduled actions. 
  ##   Action: string (required)
  ##   StartTime: string
  ##            : The start time in UTC of the scheduled actions to retrieve. Only active scheduled actions that have invocations after this time are retrieved.
  ##   EndTime: string
  ##          : The end time in UTC of the scheduled action to retrieve. Only active scheduled actions that have invocations before this time are retrieved.
  ##   Version: string (required)
  ##   Filters: JArray
  ##          : List of scheduled action filters. 
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  var query_615316 = newJObject()
  add(query_615316, "Marker", newJString(Marker))
  add(query_615316, "TargetActionType", newJString(TargetActionType))
  add(query_615316, "ScheduledActionName", newJString(ScheduledActionName))
  add(query_615316, "Active", newJBool(Active))
  add(query_615316, "Action", newJString(Action))
  add(query_615316, "StartTime", newJString(StartTime))
  add(query_615316, "EndTime", newJString(EndTime))
  add(query_615316, "Version", newJString(Version))
  if Filters != nil:
    query_615316.add "Filters", Filters
  add(query_615316, "MaxRecords", newJInt(MaxRecords))
  result = call_615315.call(nil, query_615316, nil, nil, nil)

var getDescribeScheduledActions* = Call_GetDescribeScheduledActions_615294(
    name: "getDescribeScheduledActions", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeScheduledActions",
    validator: validate_GetDescribeScheduledActions_615295, base: "/",
    url: url_GetDescribeScheduledActions_615296,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeSnapshotCopyGrants_615361 = ref object of OpenApiRestCall_612642
proc url_PostDescribeSnapshotCopyGrants_615363(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeSnapshotCopyGrants_615362(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns a list of snapshot copy grants owned by the AWS account in the destination region.</p> <p> For more information about managing snapshot copy grants, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_615364 = query.getOrDefault("Action")
  valid_615364 = validateParameter(valid_615364, JString, required = true, default = newJString(
      "DescribeSnapshotCopyGrants"))
  if valid_615364 != nil:
    section.add "Action", valid_615364
  var valid_615365 = query.getOrDefault("Version")
  valid_615365 = validateParameter(valid_615365, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_615365 != nil:
    section.add "Version", valid_615365
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_615366 = header.getOrDefault("X-Amz-Signature")
  valid_615366 = validateParameter(valid_615366, JString, required = false,
                                 default = nil)
  if valid_615366 != nil:
    section.add "X-Amz-Signature", valid_615366
  var valid_615367 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_615367 = validateParameter(valid_615367, JString, required = false,
                                 default = nil)
  if valid_615367 != nil:
    section.add "X-Amz-Content-Sha256", valid_615367
  var valid_615368 = header.getOrDefault("X-Amz-Date")
  valid_615368 = validateParameter(valid_615368, JString, required = false,
                                 default = nil)
  if valid_615368 != nil:
    section.add "X-Amz-Date", valid_615368
  var valid_615369 = header.getOrDefault("X-Amz-Credential")
  valid_615369 = validateParameter(valid_615369, JString, required = false,
                                 default = nil)
  if valid_615369 != nil:
    section.add "X-Amz-Credential", valid_615369
  var valid_615370 = header.getOrDefault("X-Amz-Security-Token")
  valid_615370 = validateParameter(valid_615370, JString, required = false,
                                 default = nil)
  if valid_615370 != nil:
    section.add "X-Amz-Security-Token", valid_615370
  var valid_615371 = header.getOrDefault("X-Amz-Algorithm")
  valid_615371 = validateParameter(valid_615371, JString, required = false,
                                 default = nil)
  if valid_615371 != nil:
    section.add "X-Amz-Algorithm", valid_615371
  var valid_615372 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_615372 = validateParameter(valid_615372, JString, required = false,
                                 default = nil)
  if valid_615372 != nil:
    section.add "X-Amz-SignedHeaders", valid_615372
  result.add "header", section
  ## parameters in `formData` object:
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching resources that are associated with the specified key or keys. For example, suppose that you have resources tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with all resources that have either or both of these tag keys associated with them.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: JString
  ##         : <p>An optional parameter that specifies the starting point to return a set of response records. When the results of a <code>DescribeSnapshotCopyGrant</code> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <b>SnapshotCopyGrantName</b> parameter or the <b>Marker</b> parameter, but not both. </p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching resources that are associated with the specified value or values. For example, suppose that you have resources tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with all resources that have either or both of these tag values associated with them.
  ##   SnapshotCopyGrantName: JString
  ##                        : The name of the snapshot copy grant.
  section = newJObject()
  var valid_615373 = formData.getOrDefault("TagKeys")
  valid_615373 = validateParameter(valid_615373, JArray, required = false,
                                 default = nil)
  if valid_615373 != nil:
    section.add "TagKeys", valid_615373
  var valid_615374 = formData.getOrDefault("MaxRecords")
  valid_615374 = validateParameter(valid_615374, JInt, required = false, default = nil)
  if valid_615374 != nil:
    section.add "MaxRecords", valid_615374
  var valid_615375 = formData.getOrDefault("Marker")
  valid_615375 = validateParameter(valid_615375, JString, required = false,
                                 default = nil)
  if valid_615375 != nil:
    section.add "Marker", valid_615375
  var valid_615376 = formData.getOrDefault("TagValues")
  valid_615376 = validateParameter(valid_615376, JArray, required = false,
                                 default = nil)
  if valid_615376 != nil:
    section.add "TagValues", valid_615376
  var valid_615377 = formData.getOrDefault("SnapshotCopyGrantName")
  valid_615377 = validateParameter(valid_615377, JString, required = false,
                                 default = nil)
  if valid_615377 != nil:
    section.add "SnapshotCopyGrantName", valid_615377
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_615378: Call_PostDescribeSnapshotCopyGrants_615361; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns a list of snapshot copy grants owned by the AWS account in the destination region.</p> <p> For more information about managing snapshot copy grants, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ## 
  let valid = call_615378.validator(path, query, header, formData, body)
  let scheme = call_615378.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_615378.url(scheme.get, call_615378.host, call_615378.base,
                         call_615378.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_615378, url, valid)

proc call*(call_615379: Call_PostDescribeSnapshotCopyGrants_615361;
          TagKeys: JsonNode = nil; MaxRecords: int = 0; Marker: string = "";
          TagValues: JsonNode = nil; Action: string = "DescribeSnapshotCopyGrants";
          SnapshotCopyGrantName: string = ""; Version: string = "2012-12-01"): Recallable =
  ## postDescribeSnapshotCopyGrants
  ## <p>Returns a list of snapshot copy grants owned by the AWS account in the destination region.</p> <p> For more information about managing snapshot copy grants, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching resources that are associated with the specified key or keys. For example, suppose that you have resources tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with all resources that have either or both of these tag keys associated with them.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: string
  ##         : <p>An optional parameter that specifies the starting point to return a set of response records. When the results of a <code>DescribeSnapshotCopyGrant</code> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <b>SnapshotCopyGrantName</b> parameter or the <b>Marker</b> parameter, but not both. </p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching resources that are associated with the specified value or values. For example, suppose that you have resources tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with all resources that have either or both of these tag values associated with them.
  ##   Action: string (required)
  ##   SnapshotCopyGrantName: string
  ##                        : The name of the snapshot copy grant.
  ##   Version: string (required)
  var query_615380 = newJObject()
  var formData_615381 = newJObject()
  if TagKeys != nil:
    formData_615381.add "TagKeys", TagKeys
  add(formData_615381, "MaxRecords", newJInt(MaxRecords))
  add(formData_615381, "Marker", newJString(Marker))
  if TagValues != nil:
    formData_615381.add "TagValues", TagValues
  add(query_615380, "Action", newJString(Action))
  add(formData_615381, "SnapshotCopyGrantName", newJString(SnapshotCopyGrantName))
  add(query_615380, "Version", newJString(Version))
  result = call_615379.call(nil, query_615380, nil, formData_615381, nil)

var postDescribeSnapshotCopyGrants* = Call_PostDescribeSnapshotCopyGrants_615361(
    name: "postDescribeSnapshotCopyGrants", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeSnapshotCopyGrants",
    validator: validate_PostDescribeSnapshotCopyGrants_615362, base: "/",
    url: url_PostDescribeSnapshotCopyGrants_615363,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeSnapshotCopyGrants_615341 = ref object of OpenApiRestCall_612642
proc url_GetDescribeSnapshotCopyGrants_615343(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeSnapshotCopyGrants_615342(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns a list of snapshot copy grants owned by the AWS account in the destination region.</p> <p> For more information about managing snapshot copy grants, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Marker: JString
  ##         : <p>An optional parameter that specifies the starting point to return a set of response records. When the results of a <code>DescribeSnapshotCopyGrant</code> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <b>SnapshotCopyGrantName</b> parameter or the <b>Marker</b> parameter, but not both. </p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching resources that are associated with the specified key or keys. For example, suppose that you have resources tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with all resources that have either or both of these tag keys associated with them.
  ##   Action: JString (required)
  ##   Version: JString (required)
  ##   SnapshotCopyGrantName: JString
  ##                        : The name of the snapshot copy grant.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching resources that are associated with the specified value or values. For example, suppose that you have resources tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with all resources that have either or both of these tag values associated with them.
  section = newJObject()
  var valid_615344 = query.getOrDefault("Marker")
  valid_615344 = validateParameter(valid_615344, JString, required = false,
                                 default = nil)
  if valid_615344 != nil:
    section.add "Marker", valid_615344
  var valid_615345 = query.getOrDefault("TagKeys")
  valid_615345 = validateParameter(valid_615345, JArray, required = false,
                                 default = nil)
  if valid_615345 != nil:
    section.add "TagKeys", valid_615345
  var valid_615346 = query.getOrDefault("Action")
  valid_615346 = validateParameter(valid_615346, JString, required = true, default = newJString(
      "DescribeSnapshotCopyGrants"))
  if valid_615346 != nil:
    section.add "Action", valid_615346
  var valid_615347 = query.getOrDefault("Version")
  valid_615347 = validateParameter(valid_615347, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_615347 != nil:
    section.add "Version", valid_615347
  var valid_615348 = query.getOrDefault("SnapshotCopyGrantName")
  valid_615348 = validateParameter(valid_615348, JString, required = false,
                                 default = nil)
  if valid_615348 != nil:
    section.add "SnapshotCopyGrantName", valid_615348
  var valid_615349 = query.getOrDefault("MaxRecords")
  valid_615349 = validateParameter(valid_615349, JInt, required = false, default = nil)
  if valid_615349 != nil:
    section.add "MaxRecords", valid_615349
  var valid_615350 = query.getOrDefault("TagValues")
  valid_615350 = validateParameter(valid_615350, JArray, required = false,
                                 default = nil)
  if valid_615350 != nil:
    section.add "TagValues", valid_615350
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_615351 = header.getOrDefault("X-Amz-Signature")
  valid_615351 = validateParameter(valid_615351, JString, required = false,
                                 default = nil)
  if valid_615351 != nil:
    section.add "X-Amz-Signature", valid_615351
  var valid_615352 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_615352 = validateParameter(valid_615352, JString, required = false,
                                 default = nil)
  if valid_615352 != nil:
    section.add "X-Amz-Content-Sha256", valid_615352
  var valid_615353 = header.getOrDefault("X-Amz-Date")
  valid_615353 = validateParameter(valid_615353, JString, required = false,
                                 default = nil)
  if valid_615353 != nil:
    section.add "X-Amz-Date", valid_615353
  var valid_615354 = header.getOrDefault("X-Amz-Credential")
  valid_615354 = validateParameter(valid_615354, JString, required = false,
                                 default = nil)
  if valid_615354 != nil:
    section.add "X-Amz-Credential", valid_615354
  var valid_615355 = header.getOrDefault("X-Amz-Security-Token")
  valid_615355 = validateParameter(valid_615355, JString, required = false,
                                 default = nil)
  if valid_615355 != nil:
    section.add "X-Amz-Security-Token", valid_615355
  var valid_615356 = header.getOrDefault("X-Amz-Algorithm")
  valid_615356 = validateParameter(valid_615356, JString, required = false,
                                 default = nil)
  if valid_615356 != nil:
    section.add "X-Amz-Algorithm", valid_615356
  var valid_615357 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_615357 = validateParameter(valid_615357, JString, required = false,
                                 default = nil)
  if valid_615357 != nil:
    section.add "X-Amz-SignedHeaders", valid_615357
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_615358: Call_GetDescribeSnapshotCopyGrants_615341; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns a list of snapshot copy grants owned by the AWS account in the destination region.</p> <p> For more information about managing snapshot copy grants, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ## 
  let valid = call_615358.validator(path, query, header, formData, body)
  let scheme = call_615358.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_615358.url(scheme.get, call_615358.host, call_615358.base,
                         call_615358.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_615358, url, valid)

proc call*(call_615359: Call_GetDescribeSnapshotCopyGrants_615341;
          Marker: string = ""; TagKeys: JsonNode = nil;
          Action: string = "DescribeSnapshotCopyGrants";
          Version: string = "2012-12-01"; SnapshotCopyGrantName: string = "";
          MaxRecords: int = 0; TagValues: JsonNode = nil): Recallable =
  ## getDescribeSnapshotCopyGrants
  ## <p>Returns a list of snapshot copy grants owned by the AWS account in the destination region.</p> <p> For more information about managing snapshot copy grants, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ##   Marker: string
  ##         : <p>An optional parameter that specifies the starting point to return a set of response records. When the results of a <code>DescribeSnapshotCopyGrant</code> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <b>SnapshotCopyGrantName</b> parameter or the <b>Marker</b> parameter, but not both. </p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching resources that are associated with the specified key or keys. For example, suppose that you have resources tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with all resources that have either or both of these tag keys associated with them.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   SnapshotCopyGrantName: string
  ##                        : The name of the snapshot copy grant.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching resources that are associated with the specified value or values. For example, suppose that you have resources tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with all resources that have either or both of these tag values associated with them.
  var query_615360 = newJObject()
  add(query_615360, "Marker", newJString(Marker))
  if TagKeys != nil:
    query_615360.add "TagKeys", TagKeys
  add(query_615360, "Action", newJString(Action))
  add(query_615360, "Version", newJString(Version))
  add(query_615360, "SnapshotCopyGrantName", newJString(SnapshotCopyGrantName))
  add(query_615360, "MaxRecords", newJInt(MaxRecords))
  if TagValues != nil:
    query_615360.add "TagValues", TagValues
  result = call_615359.call(nil, query_615360, nil, nil, nil)

var getDescribeSnapshotCopyGrants* = Call_GetDescribeSnapshotCopyGrants_615341(
    name: "getDescribeSnapshotCopyGrants", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeSnapshotCopyGrants",
    validator: validate_GetDescribeSnapshotCopyGrants_615342, base: "/",
    url: url_GetDescribeSnapshotCopyGrants_615343,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeSnapshotSchedules_615403 = ref object of OpenApiRestCall_612642
proc url_PostDescribeSnapshotSchedules_615405(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeSnapshotSchedules_615404(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns a list of snapshot schedules. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_615406 = query.getOrDefault("Action")
  valid_615406 = validateParameter(valid_615406, JString, required = true, default = newJString(
      "DescribeSnapshotSchedules"))
  if valid_615406 != nil:
    section.add "Action", valid_615406
  var valid_615407 = query.getOrDefault("Version")
  valid_615407 = validateParameter(valid_615407, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_615407 != nil:
    section.add "Version", valid_615407
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_615408 = header.getOrDefault("X-Amz-Signature")
  valid_615408 = validateParameter(valid_615408, JString, required = false,
                                 default = nil)
  if valid_615408 != nil:
    section.add "X-Amz-Signature", valid_615408
  var valid_615409 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_615409 = validateParameter(valid_615409, JString, required = false,
                                 default = nil)
  if valid_615409 != nil:
    section.add "X-Amz-Content-Sha256", valid_615409
  var valid_615410 = header.getOrDefault("X-Amz-Date")
  valid_615410 = validateParameter(valid_615410, JString, required = false,
                                 default = nil)
  if valid_615410 != nil:
    section.add "X-Amz-Date", valid_615410
  var valid_615411 = header.getOrDefault("X-Amz-Credential")
  valid_615411 = validateParameter(valid_615411, JString, required = false,
                                 default = nil)
  if valid_615411 != nil:
    section.add "X-Amz-Credential", valid_615411
  var valid_615412 = header.getOrDefault("X-Amz-Security-Token")
  valid_615412 = validateParameter(valid_615412, JString, required = false,
                                 default = nil)
  if valid_615412 != nil:
    section.add "X-Amz-Security-Token", valid_615412
  var valid_615413 = header.getOrDefault("X-Amz-Algorithm")
  valid_615413 = validateParameter(valid_615413, JString, required = false,
                                 default = nil)
  if valid_615413 != nil:
    section.add "X-Amz-Algorithm", valid_615413
  var valid_615414 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_615414 = validateParameter(valid_615414, JString, required = false,
                                 default = nil)
  if valid_615414 != nil:
    section.add "X-Amz-SignedHeaders", valid_615414
  result.add "header", section
  ## parameters in `formData` object:
  ##   TagKeys: JArray
  ##          : The key value for a snapshot schedule tag.
  ##   ClusterIdentifier: JString
  ##                    : The unique identifier for the cluster whose snapshot schedules you want to view.
  ##   MaxRecords: JInt
  ##             : The maximum number or response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned <code>marker</code> value.
  ##   Marker: JString
  ##         : A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned marker value in the <code>marker</code> parameter and retrying the command. If the <code>marker</code> field is empty, all response records have been retrieved for the request.
  ##   TagValues: JArray
  ##            : The value corresponding to the key of the snapshot schedule tag.
  ##   ScheduleIdentifier: JString
  ##                     : A unique identifier for a snapshot schedule.
  section = newJObject()
  var valid_615415 = formData.getOrDefault("TagKeys")
  valid_615415 = validateParameter(valid_615415, JArray, required = false,
                                 default = nil)
  if valid_615415 != nil:
    section.add "TagKeys", valid_615415
  var valid_615416 = formData.getOrDefault("ClusterIdentifier")
  valid_615416 = validateParameter(valid_615416, JString, required = false,
                                 default = nil)
  if valid_615416 != nil:
    section.add "ClusterIdentifier", valid_615416
  var valid_615417 = formData.getOrDefault("MaxRecords")
  valid_615417 = validateParameter(valid_615417, JInt, required = false, default = nil)
  if valid_615417 != nil:
    section.add "MaxRecords", valid_615417
  var valid_615418 = formData.getOrDefault("Marker")
  valid_615418 = validateParameter(valid_615418, JString, required = false,
                                 default = nil)
  if valid_615418 != nil:
    section.add "Marker", valid_615418
  var valid_615419 = formData.getOrDefault("TagValues")
  valid_615419 = validateParameter(valid_615419, JArray, required = false,
                                 default = nil)
  if valid_615419 != nil:
    section.add "TagValues", valid_615419
  var valid_615420 = formData.getOrDefault("ScheduleIdentifier")
  valid_615420 = validateParameter(valid_615420, JString, required = false,
                                 default = nil)
  if valid_615420 != nil:
    section.add "ScheduleIdentifier", valid_615420
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_615421: Call_PostDescribeSnapshotSchedules_615403; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns a list of snapshot schedules. 
  ## 
  let valid = call_615421.validator(path, query, header, formData, body)
  let scheme = call_615421.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_615421.url(scheme.get, call_615421.host, call_615421.base,
                         call_615421.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_615421, url, valid)

proc call*(call_615422: Call_PostDescribeSnapshotSchedules_615403;
          TagKeys: JsonNode = nil; ClusterIdentifier: string = ""; MaxRecords: int = 0;
          Marker: string = ""; TagValues: JsonNode = nil;
          Action: string = "DescribeSnapshotSchedules";
          ScheduleIdentifier: string = ""; Version: string = "2012-12-01"): Recallable =
  ## postDescribeSnapshotSchedules
  ## Returns a list of snapshot schedules. 
  ##   TagKeys: JArray
  ##          : The key value for a snapshot schedule tag.
  ##   ClusterIdentifier: string
  ##                    : The unique identifier for the cluster whose snapshot schedules you want to view.
  ##   MaxRecords: int
  ##             : The maximum number or response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned <code>marker</code> value.
  ##   Marker: string
  ##         : A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned marker value in the <code>marker</code> parameter and retrying the command. If the <code>marker</code> field is empty, all response records have been retrieved for the request.
  ##   TagValues: JArray
  ##            : The value corresponding to the key of the snapshot schedule tag.
  ##   Action: string (required)
  ##   ScheduleIdentifier: string
  ##                     : A unique identifier for a snapshot schedule.
  ##   Version: string (required)
  var query_615423 = newJObject()
  var formData_615424 = newJObject()
  if TagKeys != nil:
    formData_615424.add "TagKeys", TagKeys
  add(formData_615424, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_615424, "MaxRecords", newJInt(MaxRecords))
  add(formData_615424, "Marker", newJString(Marker))
  if TagValues != nil:
    formData_615424.add "TagValues", TagValues
  add(query_615423, "Action", newJString(Action))
  add(formData_615424, "ScheduleIdentifier", newJString(ScheduleIdentifier))
  add(query_615423, "Version", newJString(Version))
  result = call_615422.call(nil, query_615423, nil, formData_615424, nil)

var postDescribeSnapshotSchedules* = Call_PostDescribeSnapshotSchedules_615403(
    name: "postDescribeSnapshotSchedules", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeSnapshotSchedules",
    validator: validate_PostDescribeSnapshotSchedules_615404, base: "/",
    url: url_PostDescribeSnapshotSchedules_615405,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeSnapshotSchedules_615382 = ref object of OpenApiRestCall_612642
proc url_GetDescribeSnapshotSchedules_615384(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeSnapshotSchedules_615383(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns a list of snapshot schedules. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Marker: JString
  ##         : A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned marker value in the <code>marker</code> parameter and retrying the command. If the <code>marker</code> field is empty, all response records have been retrieved for the request.
  ##   ScheduleIdentifier: JString
  ##                     : A unique identifier for a snapshot schedule.
  ##   TagKeys: JArray
  ##          : The key value for a snapshot schedule tag.
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString
  ##                    : The unique identifier for the cluster whose snapshot schedules you want to view.
  ##   Version: JString (required)
  ##   MaxRecords: JInt
  ##             : The maximum number or response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned <code>marker</code> value.
  ##   TagValues: JArray
  ##            : The value corresponding to the key of the snapshot schedule tag.
  section = newJObject()
  var valid_615385 = query.getOrDefault("Marker")
  valid_615385 = validateParameter(valid_615385, JString, required = false,
                                 default = nil)
  if valid_615385 != nil:
    section.add "Marker", valid_615385
  var valid_615386 = query.getOrDefault("ScheduleIdentifier")
  valid_615386 = validateParameter(valid_615386, JString, required = false,
                                 default = nil)
  if valid_615386 != nil:
    section.add "ScheduleIdentifier", valid_615386
  var valid_615387 = query.getOrDefault("TagKeys")
  valid_615387 = validateParameter(valid_615387, JArray, required = false,
                                 default = nil)
  if valid_615387 != nil:
    section.add "TagKeys", valid_615387
  var valid_615388 = query.getOrDefault("Action")
  valid_615388 = validateParameter(valid_615388, JString, required = true, default = newJString(
      "DescribeSnapshotSchedules"))
  if valid_615388 != nil:
    section.add "Action", valid_615388
  var valid_615389 = query.getOrDefault("ClusterIdentifier")
  valid_615389 = validateParameter(valid_615389, JString, required = false,
                                 default = nil)
  if valid_615389 != nil:
    section.add "ClusterIdentifier", valid_615389
  var valid_615390 = query.getOrDefault("Version")
  valid_615390 = validateParameter(valid_615390, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_615390 != nil:
    section.add "Version", valid_615390
  var valid_615391 = query.getOrDefault("MaxRecords")
  valid_615391 = validateParameter(valid_615391, JInt, required = false, default = nil)
  if valid_615391 != nil:
    section.add "MaxRecords", valid_615391
  var valid_615392 = query.getOrDefault("TagValues")
  valid_615392 = validateParameter(valid_615392, JArray, required = false,
                                 default = nil)
  if valid_615392 != nil:
    section.add "TagValues", valid_615392
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_615393 = header.getOrDefault("X-Amz-Signature")
  valid_615393 = validateParameter(valid_615393, JString, required = false,
                                 default = nil)
  if valid_615393 != nil:
    section.add "X-Amz-Signature", valid_615393
  var valid_615394 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_615394 = validateParameter(valid_615394, JString, required = false,
                                 default = nil)
  if valid_615394 != nil:
    section.add "X-Amz-Content-Sha256", valid_615394
  var valid_615395 = header.getOrDefault("X-Amz-Date")
  valid_615395 = validateParameter(valid_615395, JString, required = false,
                                 default = nil)
  if valid_615395 != nil:
    section.add "X-Amz-Date", valid_615395
  var valid_615396 = header.getOrDefault("X-Amz-Credential")
  valid_615396 = validateParameter(valid_615396, JString, required = false,
                                 default = nil)
  if valid_615396 != nil:
    section.add "X-Amz-Credential", valid_615396
  var valid_615397 = header.getOrDefault("X-Amz-Security-Token")
  valid_615397 = validateParameter(valid_615397, JString, required = false,
                                 default = nil)
  if valid_615397 != nil:
    section.add "X-Amz-Security-Token", valid_615397
  var valid_615398 = header.getOrDefault("X-Amz-Algorithm")
  valid_615398 = validateParameter(valid_615398, JString, required = false,
                                 default = nil)
  if valid_615398 != nil:
    section.add "X-Amz-Algorithm", valid_615398
  var valid_615399 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_615399 = validateParameter(valid_615399, JString, required = false,
                                 default = nil)
  if valid_615399 != nil:
    section.add "X-Amz-SignedHeaders", valid_615399
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_615400: Call_GetDescribeSnapshotSchedules_615382; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns a list of snapshot schedules. 
  ## 
  let valid = call_615400.validator(path, query, header, formData, body)
  let scheme = call_615400.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_615400.url(scheme.get, call_615400.host, call_615400.base,
                         call_615400.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_615400, url, valid)

proc call*(call_615401: Call_GetDescribeSnapshotSchedules_615382;
          Marker: string = ""; ScheduleIdentifier: string = ""; TagKeys: JsonNode = nil;
          Action: string = "DescribeSnapshotSchedules";
          ClusterIdentifier: string = ""; Version: string = "2012-12-01";
          MaxRecords: int = 0; TagValues: JsonNode = nil): Recallable =
  ## getDescribeSnapshotSchedules
  ## Returns a list of snapshot schedules. 
  ##   Marker: string
  ##         : A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned marker value in the <code>marker</code> parameter and retrying the command. If the <code>marker</code> field is empty, all response records have been retrieved for the request.
  ##   ScheduleIdentifier: string
  ##                     : A unique identifier for a snapshot schedule.
  ##   TagKeys: JArray
  ##          : The key value for a snapshot schedule tag.
  ##   Action: string (required)
  ##   ClusterIdentifier: string
  ##                    : The unique identifier for the cluster whose snapshot schedules you want to view.
  ##   Version: string (required)
  ##   MaxRecords: int
  ##             : The maximum number or response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned <code>marker</code> value.
  ##   TagValues: JArray
  ##            : The value corresponding to the key of the snapshot schedule tag.
  var query_615402 = newJObject()
  add(query_615402, "Marker", newJString(Marker))
  add(query_615402, "ScheduleIdentifier", newJString(ScheduleIdentifier))
  if TagKeys != nil:
    query_615402.add "TagKeys", TagKeys
  add(query_615402, "Action", newJString(Action))
  add(query_615402, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_615402, "Version", newJString(Version))
  add(query_615402, "MaxRecords", newJInt(MaxRecords))
  if TagValues != nil:
    query_615402.add "TagValues", TagValues
  result = call_615401.call(nil, query_615402, nil, nil, nil)

var getDescribeSnapshotSchedules* = Call_GetDescribeSnapshotSchedules_615382(
    name: "getDescribeSnapshotSchedules", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeSnapshotSchedules",
    validator: validate_GetDescribeSnapshotSchedules_615383, base: "/",
    url: url_GetDescribeSnapshotSchedules_615384,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeStorage_615440 = ref object of OpenApiRestCall_612642
proc url_PostDescribeStorage_615442(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeStorage_615441(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Returns account level backups storage size and provisional storage.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_615443 = query.getOrDefault("Action")
  valid_615443 = validateParameter(valid_615443, JString, required = true,
                                 default = newJString("DescribeStorage"))
  if valid_615443 != nil:
    section.add "Action", valid_615443
  var valid_615444 = query.getOrDefault("Version")
  valid_615444 = validateParameter(valid_615444, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_615444 != nil:
    section.add "Version", valid_615444
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_615445 = header.getOrDefault("X-Amz-Signature")
  valid_615445 = validateParameter(valid_615445, JString, required = false,
                                 default = nil)
  if valid_615445 != nil:
    section.add "X-Amz-Signature", valid_615445
  var valid_615446 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_615446 = validateParameter(valid_615446, JString, required = false,
                                 default = nil)
  if valid_615446 != nil:
    section.add "X-Amz-Content-Sha256", valid_615446
  var valid_615447 = header.getOrDefault("X-Amz-Date")
  valid_615447 = validateParameter(valid_615447, JString, required = false,
                                 default = nil)
  if valid_615447 != nil:
    section.add "X-Amz-Date", valid_615447
  var valid_615448 = header.getOrDefault("X-Amz-Credential")
  valid_615448 = validateParameter(valid_615448, JString, required = false,
                                 default = nil)
  if valid_615448 != nil:
    section.add "X-Amz-Credential", valid_615448
  var valid_615449 = header.getOrDefault("X-Amz-Security-Token")
  valid_615449 = validateParameter(valid_615449, JString, required = false,
                                 default = nil)
  if valid_615449 != nil:
    section.add "X-Amz-Security-Token", valid_615449
  var valid_615450 = header.getOrDefault("X-Amz-Algorithm")
  valid_615450 = validateParameter(valid_615450, JString, required = false,
                                 default = nil)
  if valid_615450 != nil:
    section.add "X-Amz-Algorithm", valid_615450
  var valid_615451 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_615451 = validateParameter(valid_615451, JString, required = false,
                                 default = nil)
  if valid_615451 != nil:
    section.add "X-Amz-SignedHeaders", valid_615451
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_615452: Call_PostDescribeStorage_615440; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns account level backups storage size and provisional storage.
  ## 
  let valid = call_615452.validator(path, query, header, formData, body)
  let scheme = call_615452.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_615452.url(scheme.get, call_615452.host, call_615452.base,
                         call_615452.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_615452, url, valid)

proc call*(call_615453: Call_PostDescribeStorage_615440;
          Action: string = "DescribeStorage"; Version: string = "2012-12-01"): Recallable =
  ## postDescribeStorage
  ## Returns account level backups storage size and provisional storage.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_615454 = newJObject()
  add(query_615454, "Action", newJString(Action))
  add(query_615454, "Version", newJString(Version))
  result = call_615453.call(nil, query_615454, nil, nil, nil)

var postDescribeStorage* = Call_PostDescribeStorage_615440(
    name: "postDescribeStorage", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeStorage",
    validator: validate_PostDescribeStorage_615441, base: "/",
    url: url_PostDescribeStorage_615442, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeStorage_615425 = ref object of OpenApiRestCall_612642
proc url_GetDescribeStorage_615427(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeStorage_615426(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Returns account level backups storage size and provisional storage.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_615428 = query.getOrDefault("Action")
  valid_615428 = validateParameter(valid_615428, JString, required = true,
                                 default = newJString("DescribeStorage"))
  if valid_615428 != nil:
    section.add "Action", valid_615428
  var valid_615429 = query.getOrDefault("Version")
  valid_615429 = validateParameter(valid_615429, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_615429 != nil:
    section.add "Version", valid_615429
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_615430 = header.getOrDefault("X-Amz-Signature")
  valid_615430 = validateParameter(valid_615430, JString, required = false,
                                 default = nil)
  if valid_615430 != nil:
    section.add "X-Amz-Signature", valid_615430
  var valid_615431 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_615431 = validateParameter(valid_615431, JString, required = false,
                                 default = nil)
  if valid_615431 != nil:
    section.add "X-Amz-Content-Sha256", valid_615431
  var valid_615432 = header.getOrDefault("X-Amz-Date")
  valid_615432 = validateParameter(valid_615432, JString, required = false,
                                 default = nil)
  if valid_615432 != nil:
    section.add "X-Amz-Date", valid_615432
  var valid_615433 = header.getOrDefault("X-Amz-Credential")
  valid_615433 = validateParameter(valid_615433, JString, required = false,
                                 default = nil)
  if valid_615433 != nil:
    section.add "X-Amz-Credential", valid_615433
  var valid_615434 = header.getOrDefault("X-Amz-Security-Token")
  valid_615434 = validateParameter(valid_615434, JString, required = false,
                                 default = nil)
  if valid_615434 != nil:
    section.add "X-Amz-Security-Token", valid_615434
  var valid_615435 = header.getOrDefault("X-Amz-Algorithm")
  valid_615435 = validateParameter(valid_615435, JString, required = false,
                                 default = nil)
  if valid_615435 != nil:
    section.add "X-Amz-Algorithm", valid_615435
  var valid_615436 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_615436 = validateParameter(valid_615436, JString, required = false,
                                 default = nil)
  if valid_615436 != nil:
    section.add "X-Amz-SignedHeaders", valid_615436
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_615437: Call_GetDescribeStorage_615425; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns account level backups storage size and provisional storage.
  ## 
  let valid = call_615437.validator(path, query, header, formData, body)
  let scheme = call_615437.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_615437.url(scheme.get, call_615437.host, call_615437.base,
                         call_615437.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_615437, url, valid)

proc call*(call_615438: Call_GetDescribeStorage_615425;
          Action: string = "DescribeStorage"; Version: string = "2012-12-01"): Recallable =
  ## getDescribeStorage
  ## Returns account level backups storage size and provisional storage.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_615439 = newJObject()
  add(query_615439, "Action", newJString(Action))
  add(query_615439, "Version", newJString(Version))
  result = call_615438.call(nil, query_615439, nil, nil, nil)

var getDescribeStorage* = Call_GetDescribeStorage_615425(
    name: "getDescribeStorage", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeStorage",
    validator: validate_GetDescribeStorage_615426, base: "/",
    url: url_GetDescribeStorage_615427, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeTableRestoreStatus_615474 = ref object of OpenApiRestCall_612642
proc url_PostDescribeTableRestoreStatus_615476(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeTableRestoreStatus_615475(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists the status of one or more table restore requests made using the <a>RestoreTableFromClusterSnapshot</a> API action. If you don't specify a value for the <code>TableRestoreRequestId</code> parameter, then <code>DescribeTableRestoreStatus</code> returns the status of all table restore requests ordered by the date and time of the request in ascending order. Otherwise <code>DescribeTableRestoreStatus</code> returns the status of the table specified by <code>TableRestoreRequestId</code>.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_615477 = query.getOrDefault("Action")
  valid_615477 = validateParameter(valid_615477, JString, required = true, default = newJString(
      "DescribeTableRestoreStatus"))
  if valid_615477 != nil:
    section.add "Action", valid_615477
  var valid_615478 = query.getOrDefault("Version")
  valid_615478 = validateParameter(valid_615478, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_615478 != nil:
    section.add "Version", valid_615478
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_615479 = header.getOrDefault("X-Amz-Signature")
  valid_615479 = validateParameter(valid_615479, JString, required = false,
                                 default = nil)
  if valid_615479 != nil:
    section.add "X-Amz-Signature", valid_615479
  var valid_615480 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_615480 = validateParameter(valid_615480, JString, required = false,
                                 default = nil)
  if valid_615480 != nil:
    section.add "X-Amz-Content-Sha256", valid_615480
  var valid_615481 = header.getOrDefault("X-Amz-Date")
  valid_615481 = validateParameter(valid_615481, JString, required = false,
                                 default = nil)
  if valid_615481 != nil:
    section.add "X-Amz-Date", valid_615481
  var valid_615482 = header.getOrDefault("X-Amz-Credential")
  valid_615482 = validateParameter(valid_615482, JString, required = false,
                                 default = nil)
  if valid_615482 != nil:
    section.add "X-Amz-Credential", valid_615482
  var valid_615483 = header.getOrDefault("X-Amz-Security-Token")
  valid_615483 = validateParameter(valid_615483, JString, required = false,
                                 default = nil)
  if valid_615483 != nil:
    section.add "X-Amz-Security-Token", valid_615483
  var valid_615484 = header.getOrDefault("X-Amz-Algorithm")
  valid_615484 = validateParameter(valid_615484, JString, required = false,
                                 default = nil)
  if valid_615484 != nil:
    section.add "X-Amz-Algorithm", valid_615484
  var valid_615485 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_615485 = validateParameter(valid_615485, JString, required = false,
                                 default = nil)
  if valid_615485 != nil:
    section.add "X-Amz-SignedHeaders", valid_615485
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString
  ##                    : The Amazon Redshift cluster that the table is being restored to.
  ##   TableRestoreRequestId: JString
  ##                        : The identifier of the table restore request to return status for. If you don't specify a <code>TableRestoreRequestId</code> value, then <code>DescribeTableRestoreStatus</code> returns the status of all in-progress table restore requests.
  ##   MaxRecords: JInt
  ##             : The maximum number of records to include in the response. If more records exist than the specified <code>MaxRecords</code> value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.
  ##   Marker: JString
  ##         : An optional pagination token provided by a previous <code>DescribeTableRestoreStatus</code> request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by the <code>MaxRecords</code> parameter.
  section = newJObject()
  var valid_615486 = formData.getOrDefault("ClusterIdentifier")
  valid_615486 = validateParameter(valid_615486, JString, required = false,
                                 default = nil)
  if valid_615486 != nil:
    section.add "ClusterIdentifier", valid_615486
  var valid_615487 = formData.getOrDefault("TableRestoreRequestId")
  valid_615487 = validateParameter(valid_615487, JString, required = false,
                                 default = nil)
  if valid_615487 != nil:
    section.add "TableRestoreRequestId", valid_615487
  var valid_615488 = formData.getOrDefault("MaxRecords")
  valid_615488 = validateParameter(valid_615488, JInt, required = false, default = nil)
  if valid_615488 != nil:
    section.add "MaxRecords", valid_615488
  var valid_615489 = formData.getOrDefault("Marker")
  valid_615489 = validateParameter(valid_615489, JString, required = false,
                                 default = nil)
  if valid_615489 != nil:
    section.add "Marker", valid_615489
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_615490: Call_PostDescribeTableRestoreStatus_615474; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the status of one or more table restore requests made using the <a>RestoreTableFromClusterSnapshot</a> API action. If you don't specify a value for the <code>TableRestoreRequestId</code> parameter, then <code>DescribeTableRestoreStatus</code> returns the status of all table restore requests ordered by the date and time of the request in ascending order. Otherwise <code>DescribeTableRestoreStatus</code> returns the status of the table specified by <code>TableRestoreRequestId</code>.
  ## 
  let valid = call_615490.validator(path, query, header, formData, body)
  let scheme = call_615490.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_615490.url(scheme.get, call_615490.host, call_615490.base,
                         call_615490.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_615490, url, valid)

proc call*(call_615491: Call_PostDescribeTableRestoreStatus_615474;
          ClusterIdentifier: string = ""; TableRestoreRequestId: string = "";
          MaxRecords: int = 0; Marker: string = "";
          Action: string = "DescribeTableRestoreStatus";
          Version: string = "2012-12-01"): Recallable =
  ## postDescribeTableRestoreStatus
  ## Lists the status of one or more table restore requests made using the <a>RestoreTableFromClusterSnapshot</a> API action. If you don't specify a value for the <code>TableRestoreRequestId</code> parameter, then <code>DescribeTableRestoreStatus</code> returns the status of all table restore requests ordered by the date and time of the request in ascending order. Otherwise <code>DescribeTableRestoreStatus</code> returns the status of the table specified by <code>TableRestoreRequestId</code>.
  ##   ClusterIdentifier: string
  ##                    : The Amazon Redshift cluster that the table is being restored to.
  ##   TableRestoreRequestId: string
  ##                        : The identifier of the table restore request to return status for. If you don't specify a <code>TableRestoreRequestId</code> value, then <code>DescribeTableRestoreStatus</code> returns the status of all in-progress table restore requests.
  ##   MaxRecords: int
  ##             : The maximum number of records to include in the response. If more records exist than the specified <code>MaxRecords</code> value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.
  ##   Marker: string
  ##         : An optional pagination token provided by a previous <code>DescribeTableRestoreStatus</code> request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by the <code>MaxRecords</code> parameter.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_615492 = newJObject()
  var formData_615493 = newJObject()
  add(formData_615493, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_615493, "TableRestoreRequestId", newJString(TableRestoreRequestId))
  add(formData_615493, "MaxRecords", newJInt(MaxRecords))
  add(formData_615493, "Marker", newJString(Marker))
  add(query_615492, "Action", newJString(Action))
  add(query_615492, "Version", newJString(Version))
  result = call_615491.call(nil, query_615492, nil, formData_615493, nil)

var postDescribeTableRestoreStatus* = Call_PostDescribeTableRestoreStatus_615474(
    name: "postDescribeTableRestoreStatus", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeTableRestoreStatus",
    validator: validate_PostDescribeTableRestoreStatus_615475, base: "/",
    url: url_PostDescribeTableRestoreStatus_615476,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeTableRestoreStatus_615455 = ref object of OpenApiRestCall_612642
proc url_GetDescribeTableRestoreStatus_615457(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeTableRestoreStatus_615456(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists the status of one or more table restore requests made using the <a>RestoreTableFromClusterSnapshot</a> API action. If you don't specify a value for the <code>TableRestoreRequestId</code> parameter, then <code>DescribeTableRestoreStatus</code> returns the status of all table restore requests ordered by the date and time of the request in ascending order. Otherwise <code>DescribeTableRestoreStatus</code> returns the status of the table specified by <code>TableRestoreRequestId</code>.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Marker: JString
  ##         : An optional pagination token provided by a previous <code>DescribeTableRestoreStatus</code> request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by the <code>MaxRecords</code> parameter.
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString
  ##                    : The Amazon Redshift cluster that the table is being restored to.
  ##   Version: JString (required)
  ##   TableRestoreRequestId: JString
  ##                        : The identifier of the table restore request to return status for. If you don't specify a <code>TableRestoreRequestId</code> value, then <code>DescribeTableRestoreStatus</code> returns the status of all in-progress table restore requests.
  ##   MaxRecords: JInt
  ##             : The maximum number of records to include in the response. If more records exist than the specified <code>MaxRecords</code> value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.
  section = newJObject()
  var valid_615458 = query.getOrDefault("Marker")
  valid_615458 = validateParameter(valid_615458, JString, required = false,
                                 default = nil)
  if valid_615458 != nil:
    section.add "Marker", valid_615458
  var valid_615459 = query.getOrDefault("Action")
  valid_615459 = validateParameter(valid_615459, JString, required = true, default = newJString(
      "DescribeTableRestoreStatus"))
  if valid_615459 != nil:
    section.add "Action", valid_615459
  var valid_615460 = query.getOrDefault("ClusterIdentifier")
  valid_615460 = validateParameter(valid_615460, JString, required = false,
                                 default = nil)
  if valid_615460 != nil:
    section.add "ClusterIdentifier", valid_615460
  var valid_615461 = query.getOrDefault("Version")
  valid_615461 = validateParameter(valid_615461, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_615461 != nil:
    section.add "Version", valid_615461
  var valid_615462 = query.getOrDefault("TableRestoreRequestId")
  valid_615462 = validateParameter(valid_615462, JString, required = false,
                                 default = nil)
  if valid_615462 != nil:
    section.add "TableRestoreRequestId", valid_615462
  var valid_615463 = query.getOrDefault("MaxRecords")
  valid_615463 = validateParameter(valid_615463, JInt, required = false, default = nil)
  if valid_615463 != nil:
    section.add "MaxRecords", valid_615463
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_615464 = header.getOrDefault("X-Amz-Signature")
  valid_615464 = validateParameter(valid_615464, JString, required = false,
                                 default = nil)
  if valid_615464 != nil:
    section.add "X-Amz-Signature", valid_615464
  var valid_615465 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_615465 = validateParameter(valid_615465, JString, required = false,
                                 default = nil)
  if valid_615465 != nil:
    section.add "X-Amz-Content-Sha256", valid_615465
  var valid_615466 = header.getOrDefault("X-Amz-Date")
  valid_615466 = validateParameter(valid_615466, JString, required = false,
                                 default = nil)
  if valid_615466 != nil:
    section.add "X-Amz-Date", valid_615466
  var valid_615467 = header.getOrDefault("X-Amz-Credential")
  valid_615467 = validateParameter(valid_615467, JString, required = false,
                                 default = nil)
  if valid_615467 != nil:
    section.add "X-Amz-Credential", valid_615467
  var valid_615468 = header.getOrDefault("X-Amz-Security-Token")
  valid_615468 = validateParameter(valid_615468, JString, required = false,
                                 default = nil)
  if valid_615468 != nil:
    section.add "X-Amz-Security-Token", valid_615468
  var valid_615469 = header.getOrDefault("X-Amz-Algorithm")
  valid_615469 = validateParameter(valid_615469, JString, required = false,
                                 default = nil)
  if valid_615469 != nil:
    section.add "X-Amz-Algorithm", valid_615469
  var valid_615470 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_615470 = validateParameter(valid_615470, JString, required = false,
                                 default = nil)
  if valid_615470 != nil:
    section.add "X-Amz-SignedHeaders", valid_615470
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_615471: Call_GetDescribeTableRestoreStatus_615455; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the status of one or more table restore requests made using the <a>RestoreTableFromClusterSnapshot</a> API action. If you don't specify a value for the <code>TableRestoreRequestId</code> parameter, then <code>DescribeTableRestoreStatus</code> returns the status of all table restore requests ordered by the date and time of the request in ascending order. Otherwise <code>DescribeTableRestoreStatus</code> returns the status of the table specified by <code>TableRestoreRequestId</code>.
  ## 
  let valid = call_615471.validator(path, query, header, formData, body)
  let scheme = call_615471.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_615471.url(scheme.get, call_615471.host, call_615471.base,
                         call_615471.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_615471, url, valid)

proc call*(call_615472: Call_GetDescribeTableRestoreStatus_615455;
          Marker: string = ""; Action: string = "DescribeTableRestoreStatus";
          ClusterIdentifier: string = ""; Version: string = "2012-12-01";
          TableRestoreRequestId: string = ""; MaxRecords: int = 0): Recallable =
  ## getDescribeTableRestoreStatus
  ## Lists the status of one or more table restore requests made using the <a>RestoreTableFromClusterSnapshot</a> API action. If you don't specify a value for the <code>TableRestoreRequestId</code> parameter, then <code>DescribeTableRestoreStatus</code> returns the status of all table restore requests ordered by the date and time of the request in ascending order. Otherwise <code>DescribeTableRestoreStatus</code> returns the status of the table specified by <code>TableRestoreRequestId</code>.
  ##   Marker: string
  ##         : An optional pagination token provided by a previous <code>DescribeTableRestoreStatus</code> request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by the <code>MaxRecords</code> parameter.
  ##   Action: string (required)
  ##   ClusterIdentifier: string
  ##                    : The Amazon Redshift cluster that the table is being restored to.
  ##   Version: string (required)
  ##   TableRestoreRequestId: string
  ##                        : The identifier of the table restore request to return status for. If you don't specify a <code>TableRestoreRequestId</code> value, then <code>DescribeTableRestoreStatus</code> returns the status of all in-progress table restore requests.
  ##   MaxRecords: int
  ##             : The maximum number of records to include in the response. If more records exist than the specified <code>MaxRecords</code> value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.
  var query_615473 = newJObject()
  add(query_615473, "Marker", newJString(Marker))
  add(query_615473, "Action", newJString(Action))
  add(query_615473, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_615473, "Version", newJString(Version))
  add(query_615473, "TableRestoreRequestId", newJString(TableRestoreRequestId))
  add(query_615473, "MaxRecords", newJInt(MaxRecords))
  result = call_615472.call(nil, query_615473, nil, nil, nil)

var getDescribeTableRestoreStatus* = Call_GetDescribeTableRestoreStatus_615455(
    name: "getDescribeTableRestoreStatus", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeTableRestoreStatus",
    validator: validate_GetDescribeTableRestoreStatus_615456, base: "/",
    url: url_GetDescribeTableRestoreStatus_615457,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeTags_615515 = ref object of OpenApiRestCall_612642
proc url_PostDescribeTags_615517(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeTags_615516(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## <p>Returns a list of tags. You can return tags from a specific resource by specifying an ARN, or you can return all tags for a given type of resource, such as clusters, snapshots, and so on.</p> <p>The following are limitations for <code>DescribeTags</code>: </p> <ul> <li> <p>You cannot specify an ARN and a resource-type value together in the same request.</p> </li> <li> <p>You cannot use the <code>MaxRecords</code> and <code>Marker</code> parameters together with the ARN parameter.</p> </li> <li> <p>The <code>MaxRecords</code> parameter can be a range from 10 to 50 results to return in a request.</p> </li> </ul> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all resources that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all resources that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, resources are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_615518 = query.getOrDefault("Action")
  valid_615518 = validateParameter(valid_615518, JString, required = true,
                                 default = newJString("DescribeTags"))
  if valid_615518 != nil:
    section.add "Action", valid_615518
  var valid_615519 = query.getOrDefault("Version")
  valid_615519 = validateParameter(valid_615519, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_615519 != nil:
    section.add "Version", valid_615519
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_615520 = header.getOrDefault("X-Amz-Signature")
  valid_615520 = validateParameter(valid_615520, JString, required = false,
                                 default = nil)
  if valid_615520 != nil:
    section.add "X-Amz-Signature", valid_615520
  var valid_615521 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_615521 = validateParameter(valid_615521, JString, required = false,
                                 default = nil)
  if valid_615521 != nil:
    section.add "X-Amz-Content-Sha256", valid_615521
  var valid_615522 = header.getOrDefault("X-Amz-Date")
  valid_615522 = validateParameter(valid_615522, JString, required = false,
                                 default = nil)
  if valid_615522 != nil:
    section.add "X-Amz-Date", valid_615522
  var valid_615523 = header.getOrDefault("X-Amz-Credential")
  valid_615523 = validateParameter(valid_615523, JString, required = false,
                                 default = nil)
  if valid_615523 != nil:
    section.add "X-Amz-Credential", valid_615523
  var valid_615524 = header.getOrDefault("X-Amz-Security-Token")
  valid_615524 = validateParameter(valid_615524, JString, required = false,
                                 default = nil)
  if valid_615524 != nil:
    section.add "X-Amz-Security-Token", valid_615524
  var valid_615525 = header.getOrDefault("X-Amz-Algorithm")
  valid_615525 = validateParameter(valid_615525, JString, required = false,
                                 default = nil)
  if valid_615525 != nil:
    section.add "X-Amz-Algorithm", valid_615525
  var valid_615526 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_615526 = validateParameter(valid_615526, JString, required = false,
                                 default = nil)
  if valid_615526 != nil:
    section.add "X-Amz-SignedHeaders", valid_615526
  result.add "header", section
  ## parameters in `formData` object:
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching resources that are associated with the specified key or keys. For example, suppose that you have resources tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with all resources that have either or both of these tag keys associated with them.
  ##   MaxRecords: JInt
  ##             : The maximum number or response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned <code>marker</code> value. 
  ##   ResourceType: JString
  ##               : <p>The type of resource with which you want to view tags. Valid resource types are: </p> <ul> <li> <p>Cluster</p> </li> <li> <p>CIDR/IP</p> </li> <li> <p>EC2 security group</p> </li> <li> <p>Snapshot</p> </li> <li> <p>Cluster security group</p> </li> <li> <p>Subnet group</p> </li> <li> <p>HSM connection</p> </li> <li> <p>HSM certificate</p> </li> <li> <p>Parameter group</p> </li> <li> <p>Snapshot copy grant</p> </li> </ul> <p>For more information about Amazon Redshift resource types and constructing ARNs, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-overview.html#redshift-iam-access-control-specify-actions">Specifying Policy Elements: Actions, Effects, Resources, and Principals</a> in the Amazon Redshift Cluster Management Guide. </p>
  ##   Marker: JString
  ##         : A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned marker value in the <code>marker</code> parameter and retrying the command. If the <code>marker</code> field is empty, all response records have been retrieved for the request. 
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching resources that are associated with the specified value or values. For example, suppose that you have resources tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with all resources that have either or both of these tag values associated with them.
  ##   ResourceName: JString
  ##               : The Amazon Resource Name (ARN) for which you want to describe the tag or tags. For example, <code>arn:aws:redshift:us-east-2:123456789:cluster:t1</code>. 
  section = newJObject()
  var valid_615527 = formData.getOrDefault("TagKeys")
  valid_615527 = validateParameter(valid_615527, JArray, required = false,
                                 default = nil)
  if valid_615527 != nil:
    section.add "TagKeys", valid_615527
  var valid_615528 = formData.getOrDefault("MaxRecords")
  valid_615528 = validateParameter(valid_615528, JInt, required = false, default = nil)
  if valid_615528 != nil:
    section.add "MaxRecords", valid_615528
  var valid_615529 = formData.getOrDefault("ResourceType")
  valid_615529 = validateParameter(valid_615529, JString, required = false,
                                 default = nil)
  if valid_615529 != nil:
    section.add "ResourceType", valid_615529
  var valid_615530 = formData.getOrDefault("Marker")
  valid_615530 = validateParameter(valid_615530, JString, required = false,
                                 default = nil)
  if valid_615530 != nil:
    section.add "Marker", valid_615530
  var valid_615531 = formData.getOrDefault("TagValues")
  valid_615531 = validateParameter(valid_615531, JArray, required = false,
                                 default = nil)
  if valid_615531 != nil:
    section.add "TagValues", valid_615531
  var valid_615532 = formData.getOrDefault("ResourceName")
  valid_615532 = validateParameter(valid_615532, JString, required = false,
                                 default = nil)
  if valid_615532 != nil:
    section.add "ResourceName", valid_615532
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_615533: Call_PostDescribeTags_615515; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns a list of tags. You can return tags from a specific resource by specifying an ARN, or you can return all tags for a given type of resource, such as clusters, snapshots, and so on.</p> <p>The following are limitations for <code>DescribeTags</code>: </p> <ul> <li> <p>You cannot specify an ARN and a resource-type value together in the same request.</p> </li> <li> <p>You cannot use the <code>MaxRecords</code> and <code>Marker</code> parameters together with the ARN parameter.</p> </li> <li> <p>The <code>MaxRecords</code> parameter can be a range from 10 to 50 results to return in a request.</p> </li> </ul> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all resources that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all resources that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, resources are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_615533.validator(path, query, header, formData, body)
  let scheme = call_615533.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_615533.url(scheme.get, call_615533.host, call_615533.base,
                         call_615533.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_615533, url, valid)

proc call*(call_615534: Call_PostDescribeTags_615515; TagKeys: JsonNode = nil;
          MaxRecords: int = 0; ResourceType: string = ""; Marker: string = "";
          TagValues: JsonNode = nil; Action: string = "DescribeTags";
          Version: string = "2012-12-01"; ResourceName: string = ""): Recallable =
  ## postDescribeTags
  ## <p>Returns a list of tags. You can return tags from a specific resource by specifying an ARN, or you can return all tags for a given type of resource, such as clusters, snapshots, and so on.</p> <p>The following are limitations for <code>DescribeTags</code>: </p> <ul> <li> <p>You cannot specify an ARN and a resource-type value together in the same request.</p> </li> <li> <p>You cannot use the <code>MaxRecords</code> and <code>Marker</code> parameters together with the ARN parameter.</p> </li> <li> <p>The <code>MaxRecords</code> parameter can be a range from 10 to 50 results to return in a request.</p> </li> </ul> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all resources that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all resources that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, resources are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching resources that are associated with the specified key or keys. For example, suppose that you have resources tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with all resources that have either or both of these tag keys associated with them.
  ##   MaxRecords: int
  ##             : The maximum number or response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned <code>marker</code> value. 
  ##   ResourceType: string
  ##               : <p>The type of resource with which you want to view tags. Valid resource types are: </p> <ul> <li> <p>Cluster</p> </li> <li> <p>CIDR/IP</p> </li> <li> <p>EC2 security group</p> </li> <li> <p>Snapshot</p> </li> <li> <p>Cluster security group</p> </li> <li> <p>Subnet group</p> </li> <li> <p>HSM connection</p> </li> <li> <p>HSM certificate</p> </li> <li> <p>Parameter group</p> </li> <li> <p>Snapshot copy grant</p> </li> </ul> <p>For more information about Amazon Redshift resource types and constructing ARNs, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-overview.html#redshift-iam-access-control-specify-actions">Specifying Policy Elements: Actions, Effects, Resources, and Principals</a> in the Amazon Redshift Cluster Management Guide. </p>
  ##   Marker: string
  ##         : A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned marker value in the <code>marker</code> parameter and retrying the command. If the <code>marker</code> field is empty, all response records have been retrieved for the request. 
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching resources that are associated with the specified value or values. For example, suppose that you have resources tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with all resources that have either or both of these tag values associated with them.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   ResourceName: string
  ##               : The Amazon Resource Name (ARN) for which you want to describe the tag or tags. For example, <code>arn:aws:redshift:us-east-2:123456789:cluster:t1</code>. 
  var query_615535 = newJObject()
  var formData_615536 = newJObject()
  if TagKeys != nil:
    formData_615536.add "TagKeys", TagKeys
  add(formData_615536, "MaxRecords", newJInt(MaxRecords))
  add(formData_615536, "ResourceType", newJString(ResourceType))
  add(formData_615536, "Marker", newJString(Marker))
  if TagValues != nil:
    formData_615536.add "TagValues", TagValues
  add(query_615535, "Action", newJString(Action))
  add(query_615535, "Version", newJString(Version))
  add(formData_615536, "ResourceName", newJString(ResourceName))
  result = call_615534.call(nil, query_615535, nil, formData_615536, nil)

var postDescribeTags* = Call_PostDescribeTags_615515(name: "postDescribeTags",
    meth: HttpMethod.HttpPost, host: "redshift.amazonaws.com",
    route: "/#Action=DescribeTags", validator: validate_PostDescribeTags_615516,
    base: "/", url: url_PostDescribeTags_615517,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeTags_615494 = ref object of OpenApiRestCall_612642
proc url_GetDescribeTags_615496(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeTags_615495(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## <p>Returns a list of tags. You can return tags from a specific resource by specifying an ARN, or you can return all tags for a given type of resource, such as clusters, snapshots, and so on.</p> <p>The following are limitations for <code>DescribeTags</code>: </p> <ul> <li> <p>You cannot specify an ARN and a resource-type value together in the same request.</p> </li> <li> <p>You cannot use the <code>MaxRecords</code> and <code>Marker</code> parameters together with the ARN parameter.</p> </li> <li> <p>The <code>MaxRecords</code> parameter can be a range from 10 to 50 results to return in a request.</p> </li> </ul> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all resources that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all resources that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, resources are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Marker: JString
  ##         : A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned marker value in the <code>marker</code> parameter and retrying the command. If the <code>marker</code> field is empty, all response records have been retrieved for the request. 
  ##   ResourceName: JString
  ##               : The Amazon Resource Name (ARN) for which you want to describe the tag or tags. For example, <code>arn:aws:redshift:us-east-2:123456789:cluster:t1</code>. 
  ##   ResourceType: JString
  ##               : <p>The type of resource with which you want to view tags. Valid resource types are: </p> <ul> <li> <p>Cluster</p> </li> <li> <p>CIDR/IP</p> </li> <li> <p>EC2 security group</p> </li> <li> <p>Snapshot</p> </li> <li> <p>Cluster security group</p> </li> <li> <p>Subnet group</p> </li> <li> <p>HSM connection</p> </li> <li> <p>HSM certificate</p> </li> <li> <p>Parameter group</p> </li> <li> <p>Snapshot copy grant</p> </li> </ul> <p>For more information about Amazon Redshift resource types and constructing ARNs, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-overview.html#redshift-iam-access-control-specify-actions">Specifying Policy Elements: Actions, Effects, Resources, and Principals</a> in the Amazon Redshift Cluster Management Guide. </p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching resources that are associated with the specified key or keys. For example, suppose that you have resources tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with all resources that have either or both of these tag keys associated with them.
  ##   Action: JString (required)
  ##   Version: JString (required)
  ##   MaxRecords: JInt
  ##             : The maximum number or response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned <code>marker</code> value. 
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching resources that are associated with the specified value or values. For example, suppose that you have resources tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with all resources that have either or both of these tag values associated with them.
  section = newJObject()
  var valid_615497 = query.getOrDefault("Marker")
  valid_615497 = validateParameter(valid_615497, JString, required = false,
                                 default = nil)
  if valid_615497 != nil:
    section.add "Marker", valid_615497
  var valid_615498 = query.getOrDefault("ResourceName")
  valid_615498 = validateParameter(valid_615498, JString, required = false,
                                 default = nil)
  if valid_615498 != nil:
    section.add "ResourceName", valid_615498
  var valid_615499 = query.getOrDefault("ResourceType")
  valid_615499 = validateParameter(valid_615499, JString, required = false,
                                 default = nil)
  if valid_615499 != nil:
    section.add "ResourceType", valid_615499
  var valid_615500 = query.getOrDefault("TagKeys")
  valid_615500 = validateParameter(valid_615500, JArray, required = false,
                                 default = nil)
  if valid_615500 != nil:
    section.add "TagKeys", valid_615500
  var valid_615501 = query.getOrDefault("Action")
  valid_615501 = validateParameter(valid_615501, JString, required = true,
                                 default = newJString("DescribeTags"))
  if valid_615501 != nil:
    section.add "Action", valid_615501
  var valid_615502 = query.getOrDefault("Version")
  valid_615502 = validateParameter(valid_615502, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_615502 != nil:
    section.add "Version", valid_615502
  var valid_615503 = query.getOrDefault("MaxRecords")
  valid_615503 = validateParameter(valid_615503, JInt, required = false, default = nil)
  if valid_615503 != nil:
    section.add "MaxRecords", valid_615503
  var valid_615504 = query.getOrDefault("TagValues")
  valid_615504 = validateParameter(valid_615504, JArray, required = false,
                                 default = nil)
  if valid_615504 != nil:
    section.add "TagValues", valid_615504
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_615505 = header.getOrDefault("X-Amz-Signature")
  valid_615505 = validateParameter(valid_615505, JString, required = false,
                                 default = nil)
  if valid_615505 != nil:
    section.add "X-Amz-Signature", valid_615505
  var valid_615506 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_615506 = validateParameter(valid_615506, JString, required = false,
                                 default = nil)
  if valid_615506 != nil:
    section.add "X-Amz-Content-Sha256", valid_615506
  var valid_615507 = header.getOrDefault("X-Amz-Date")
  valid_615507 = validateParameter(valid_615507, JString, required = false,
                                 default = nil)
  if valid_615507 != nil:
    section.add "X-Amz-Date", valid_615507
  var valid_615508 = header.getOrDefault("X-Amz-Credential")
  valid_615508 = validateParameter(valid_615508, JString, required = false,
                                 default = nil)
  if valid_615508 != nil:
    section.add "X-Amz-Credential", valid_615508
  var valid_615509 = header.getOrDefault("X-Amz-Security-Token")
  valid_615509 = validateParameter(valid_615509, JString, required = false,
                                 default = nil)
  if valid_615509 != nil:
    section.add "X-Amz-Security-Token", valid_615509
  var valid_615510 = header.getOrDefault("X-Amz-Algorithm")
  valid_615510 = validateParameter(valid_615510, JString, required = false,
                                 default = nil)
  if valid_615510 != nil:
    section.add "X-Amz-Algorithm", valid_615510
  var valid_615511 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_615511 = validateParameter(valid_615511, JString, required = false,
                                 default = nil)
  if valid_615511 != nil:
    section.add "X-Amz-SignedHeaders", valid_615511
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_615512: Call_GetDescribeTags_615494; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns a list of tags. You can return tags from a specific resource by specifying an ARN, or you can return all tags for a given type of resource, such as clusters, snapshots, and so on.</p> <p>The following are limitations for <code>DescribeTags</code>: </p> <ul> <li> <p>You cannot specify an ARN and a resource-type value together in the same request.</p> </li> <li> <p>You cannot use the <code>MaxRecords</code> and <code>Marker</code> parameters together with the ARN parameter.</p> </li> <li> <p>The <code>MaxRecords</code> parameter can be a range from 10 to 50 results to return in a request.</p> </li> </ul> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all resources that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all resources that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, resources are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_615512.validator(path, query, header, formData, body)
  let scheme = call_615512.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_615512.url(scheme.get, call_615512.host, call_615512.base,
                         call_615512.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_615512, url, valid)

proc call*(call_615513: Call_GetDescribeTags_615494; Marker: string = "";
          ResourceName: string = ""; ResourceType: string = ""; TagKeys: JsonNode = nil;
          Action: string = "DescribeTags"; Version: string = "2012-12-01";
          MaxRecords: int = 0; TagValues: JsonNode = nil): Recallable =
  ## getDescribeTags
  ## <p>Returns a list of tags. You can return tags from a specific resource by specifying an ARN, or you can return all tags for a given type of resource, such as clusters, snapshots, and so on.</p> <p>The following are limitations for <code>DescribeTags</code>: </p> <ul> <li> <p>You cannot specify an ARN and a resource-type value together in the same request.</p> </li> <li> <p>You cannot use the <code>MaxRecords</code> and <code>Marker</code> parameters together with the ARN parameter.</p> </li> <li> <p>The <code>MaxRecords</code> parameter can be a range from 10 to 50 results to return in a request.</p> </li> </ul> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all resources that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all resources that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, resources are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   Marker: string
  ##         : A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned marker value in the <code>marker</code> parameter and retrying the command. If the <code>marker</code> field is empty, all response records have been retrieved for the request. 
  ##   ResourceName: string
  ##               : The Amazon Resource Name (ARN) for which you want to describe the tag or tags. For example, <code>arn:aws:redshift:us-east-2:123456789:cluster:t1</code>. 
  ##   ResourceType: string
  ##               : <p>The type of resource with which you want to view tags. Valid resource types are: </p> <ul> <li> <p>Cluster</p> </li> <li> <p>CIDR/IP</p> </li> <li> <p>EC2 security group</p> </li> <li> <p>Snapshot</p> </li> <li> <p>Cluster security group</p> </li> <li> <p>Subnet group</p> </li> <li> <p>HSM connection</p> </li> <li> <p>HSM certificate</p> </li> <li> <p>Parameter group</p> </li> <li> <p>Snapshot copy grant</p> </li> </ul> <p>For more information about Amazon Redshift resource types and constructing ARNs, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-overview.html#redshift-iam-access-control-specify-actions">Specifying Policy Elements: Actions, Effects, Resources, and Principals</a> in the Amazon Redshift Cluster Management Guide. </p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching resources that are associated with the specified key or keys. For example, suppose that you have resources tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with all resources that have either or both of these tag keys associated with them.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   MaxRecords: int
  ##             : The maximum number or response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned <code>marker</code> value. 
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching resources that are associated with the specified value or values. For example, suppose that you have resources tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with all resources that have either or both of these tag values associated with them.
  var query_615514 = newJObject()
  add(query_615514, "Marker", newJString(Marker))
  add(query_615514, "ResourceName", newJString(ResourceName))
  add(query_615514, "ResourceType", newJString(ResourceType))
  if TagKeys != nil:
    query_615514.add "TagKeys", TagKeys
  add(query_615514, "Action", newJString(Action))
  add(query_615514, "Version", newJString(Version))
  add(query_615514, "MaxRecords", newJInt(MaxRecords))
  if TagValues != nil:
    query_615514.add "TagValues", TagValues
  result = call_615513.call(nil, query_615514, nil, nil, nil)

var getDescribeTags* = Call_GetDescribeTags_615494(name: "getDescribeTags",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=DescribeTags", validator: validate_GetDescribeTags_615495,
    base: "/", url: url_GetDescribeTags_615496, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDisableLogging_615553 = ref object of OpenApiRestCall_612642
proc url_PostDisableLogging_615555(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDisableLogging_615554(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Stops logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_615556 = query.getOrDefault("Action")
  valid_615556 = validateParameter(valid_615556, JString, required = true,
                                 default = newJString("DisableLogging"))
  if valid_615556 != nil:
    section.add "Action", valid_615556
  var valid_615557 = query.getOrDefault("Version")
  valid_615557 = validateParameter(valid_615557, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_615557 != nil:
    section.add "Version", valid_615557
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_615558 = header.getOrDefault("X-Amz-Signature")
  valid_615558 = validateParameter(valid_615558, JString, required = false,
                                 default = nil)
  if valid_615558 != nil:
    section.add "X-Amz-Signature", valid_615558
  var valid_615559 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_615559 = validateParameter(valid_615559, JString, required = false,
                                 default = nil)
  if valid_615559 != nil:
    section.add "X-Amz-Content-Sha256", valid_615559
  var valid_615560 = header.getOrDefault("X-Amz-Date")
  valid_615560 = validateParameter(valid_615560, JString, required = false,
                                 default = nil)
  if valid_615560 != nil:
    section.add "X-Amz-Date", valid_615560
  var valid_615561 = header.getOrDefault("X-Amz-Credential")
  valid_615561 = validateParameter(valid_615561, JString, required = false,
                                 default = nil)
  if valid_615561 != nil:
    section.add "X-Amz-Credential", valid_615561
  var valid_615562 = header.getOrDefault("X-Amz-Security-Token")
  valid_615562 = validateParameter(valid_615562, JString, required = false,
                                 default = nil)
  if valid_615562 != nil:
    section.add "X-Amz-Security-Token", valid_615562
  var valid_615563 = header.getOrDefault("X-Amz-Algorithm")
  valid_615563 = validateParameter(valid_615563, JString, required = false,
                                 default = nil)
  if valid_615563 != nil:
    section.add "X-Amz-Algorithm", valid_615563
  var valid_615564 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_615564 = validateParameter(valid_615564, JString, required = false,
                                 default = nil)
  if valid_615564 != nil:
    section.add "X-Amz-SignedHeaders", valid_615564
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The identifier of the cluster on which logging is to be stopped.</p> <p>Example: <code>examplecluster</code> </p>
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_615565 = formData.getOrDefault("ClusterIdentifier")
  valid_615565 = validateParameter(valid_615565, JString, required = true,
                                 default = nil)
  if valid_615565 != nil:
    section.add "ClusterIdentifier", valid_615565
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_615566: Call_PostDisableLogging_615553; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Stops logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
  ## 
  let valid = call_615566.validator(path, query, header, formData, body)
  let scheme = call_615566.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_615566.url(scheme.get, call_615566.host, call_615566.base,
                         call_615566.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_615566, url, valid)

proc call*(call_615567: Call_PostDisableLogging_615553; ClusterIdentifier: string;
          Action: string = "DisableLogging"; Version: string = "2012-12-01"): Recallable =
  ## postDisableLogging
  ## Stops logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The identifier of the cluster on which logging is to be stopped.</p> <p>Example: <code>examplecluster</code> </p>
  ##   Action: string (required)
  ##   Version: string (required)
  var query_615568 = newJObject()
  var formData_615569 = newJObject()
  add(formData_615569, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_615568, "Action", newJString(Action))
  add(query_615568, "Version", newJString(Version))
  result = call_615567.call(nil, query_615568, nil, formData_615569, nil)

var postDisableLogging* = Call_PostDisableLogging_615553(
    name: "postDisableLogging", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DisableLogging",
    validator: validate_PostDisableLogging_615554, base: "/",
    url: url_PostDisableLogging_615555, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDisableLogging_615537 = ref object of OpenApiRestCall_612642
proc url_GetDisableLogging_615539(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDisableLogging_615538(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## Stops logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The identifier of the cluster on which logging is to be stopped.</p> <p>Example: <code>examplecluster</code> </p>
  ##   Version: JString (required)
  section = newJObject()
  var valid_615540 = query.getOrDefault("Action")
  valid_615540 = validateParameter(valid_615540, JString, required = true,
                                 default = newJString("DisableLogging"))
  if valid_615540 != nil:
    section.add "Action", valid_615540
  var valid_615541 = query.getOrDefault("ClusterIdentifier")
  valid_615541 = validateParameter(valid_615541, JString, required = true,
                                 default = nil)
  if valid_615541 != nil:
    section.add "ClusterIdentifier", valid_615541
  var valid_615542 = query.getOrDefault("Version")
  valid_615542 = validateParameter(valid_615542, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_615542 != nil:
    section.add "Version", valid_615542
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_615543 = header.getOrDefault("X-Amz-Signature")
  valid_615543 = validateParameter(valid_615543, JString, required = false,
                                 default = nil)
  if valid_615543 != nil:
    section.add "X-Amz-Signature", valid_615543
  var valid_615544 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_615544 = validateParameter(valid_615544, JString, required = false,
                                 default = nil)
  if valid_615544 != nil:
    section.add "X-Amz-Content-Sha256", valid_615544
  var valid_615545 = header.getOrDefault("X-Amz-Date")
  valid_615545 = validateParameter(valid_615545, JString, required = false,
                                 default = nil)
  if valid_615545 != nil:
    section.add "X-Amz-Date", valid_615545
  var valid_615546 = header.getOrDefault("X-Amz-Credential")
  valid_615546 = validateParameter(valid_615546, JString, required = false,
                                 default = nil)
  if valid_615546 != nil:
    section.add "X-Amz-Credential", valid_615546
  var valid_615547 = header.getOrDefault("X-Amz-Security-Token")
  valid_615547 = validateParameter(valid_615547, JString, required = false,
                                 default = nil)
  if valid_615547 != nil:
    section.add "X-Amz-Security-Token", valid_615547
  var valid_615548 = header.getOrDefault("X-Amz-Algorithm")
  valid_615548 = validateParameter(valid_615548, JString, required = false,
                                 default = nil)
  if valid_615548 != nil:
    section.add "X-Amz-Algorithm", valid_615548
  var valid_615549 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_615549 = validateParameter(valid_615549, JString, required = false,
                                 default = nil)
  if valid_615549 != nil:
    section.add "X-Amz-SignedHeaders", valid_615549
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_615550: Call_GetDisableLogging_615537; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Stops logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
  ## 
  let valid = call_615550.validator(path, query, header, formData, body)
  let scheme = call_615550.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_615550.url(scheme.get, call_615550.host, call_615550.base,
                         call_615550.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_615550, url, valid)

proc call*(call_615551: Call_GetDisableLogging_615537; ClusterIdentifier: string;
          Action: string = "DisableLogging"; Version: string = "2012-12-01"): Recallable =
  ## getDisableLogging
  ## Stops logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The identifier of the cluster on which logging is to be stopped.</p> <p>Example: <code>examplecluster</code> </p>
  ##   Version: string (required)
  var query_615552 = newJObject()
  add(query_615552, "Action", newJString(Action))
  add(query_615552, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_615552, "Version", newJString(Version))
  result = call_615551.call(nil, query_615552, nil, nil, nil)

var getDisableLogging* = Call_GetDisableLogging_615537(name: "getDisableLogging",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=DisableLogging", validator: validate_GetDisableLogging_615538,
    base: "/", url: url_GetDisableLogging_615539,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDisableSnapshotCopy_615586 = ref object of OpenApiRestCall_612642
proc url_PostDisableSnapshotCopy_615588(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDisableSnapshotCopy_615587(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Disables the automatic copying of snapshots from one region to another region for a specified cluster.</p> <p>If your cluster and its snapshots are encrypted using a customer master key (CMK) from AWS KMS, use <a>DeleteSnapshotCopyGrant</a> to delete the grant that grants Amazon Redshift permission to the CMK in the destination region. </p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_615589 = query.getOrDefault("Action")
  valid_615589 = validateParameter(valid_615589, JString, required = true,
                                 default = newJString("DisableSnapshotCopy"))
  if valid_615589 != nil:
    section.add "Action", valid_615589
  var valid_615590 = query.getOrDefault("Version")
  valid_615590 = validateParameter(valid_615590, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_615590 != nil:
    section.add "Version", valid_615590
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_615591 = header.getOrDefault("X-Amz-Signature")
  valid_615591 = validateParameter(valid_615591, JString, required = false,
                                 default = nil)
  if valid_615591 != nil:
    section.add "X-Amz-Signature", valid_615591
  var valid_615592 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_615592 = validateParameter(valid_615592, JString, required = false,
                                 default = nil)
  if valid_615592 != nil:
    section.add "X-Amz-Content-Sha256", valid_615592
  var valid_615593 = header.getOrDefault("X-Amz-Date")
  valid_615593 = validateParameter(valid_615593, JString, required = false,
                                 default = nil)
  if valid_615593 != nil:
    section.add "X-Amz-Date", valid_615593
  var valid_615594 = header.getOrDefault("X-Amz-Credential")
  valid_615594 = validateParameter(valid_615594, JString, required = false,
                                 default = nil)
  if valid_615594 != nil:
    section.add "X-Amz-Credential", valid_615594
  var valid_615595 = header.getOrDefault("X-Amz-Security-Token")
  valid_615595 = validateParameter(valid_615595, JString, required = false,
                                 default = nil)
  if valid_615595 != nil:
    section.add "X-Amz-Security-Token", valid_615595
  var valid_615596 = header.getOrDefault("X-Amz-Algorithm")
  valid_615596 = validateParameter(valid_615596, JString, required = false,
                                 default = nil)
  if valid_615596 != nil:
    section.add "X-Amz-Algorithm", valid_615596
  var valid_615597 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_615597 = validateParameter(valid_615597, JString, required = false,
                                 default = nil)
  if valid_615597 != nil:
    section.add "X-Amz-SignedHeaders", valid_615597
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of the source cluster that you want to disable copying of snapshots to a destination region.</p> <p>Constraints: Must be the valid name of an existing cluster that has cross-region snapshot copy enabled.</p>
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_615598 = formData.getOrDefault("ClusterIdentifier")
  valid_615598 = validateParameter(valid_615598, JString, required = true,
                                 default = nil)
  if valid_615598 != nil:
    section.add "ClusterIdentifier", valid_615598
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_615599: Call_PostDisableSnapshotCopy_615586; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Disables the automatic copying of snapshots from one region to another region for a specified cluster.</p> <p>If your cluster and its snapshots are encrypted using a customer master key (CMK) from AWS KMS, use <a>DeleteSnapshotCopyGrant</a> to delete the grant that grants Amazon Redshift permission to the CMK in the destination region. </p>
  ## 
  let valid = call_615599.validator(path, query, header, formData, body)
  let scheme = call_615599.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_615599.url(scheme.get, call_615599.host, call_615599.base,
                         call_615599.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_615599, url, valid)

proc call*(call_615600: Call_PostDisableSnapshotCopy_615586;
          ClusterIdentifier: string; Action: string = "DisableSnapshotCopy";
          Version: string = "2012-12-01"): Recallable =
  ## postDisableSnapshotCopy
  ## <p>Disables the automatic copying of snapshots from one region to another region for a specified cluster.</p> <p>If your cluster and its snapshots are encrypted using a customer master key (CMK) from AWS KMS, use <a>DeleteSnapshotCopyGrant</a> to delete the grant that grants Amazon Redshift permission to the CMK in the destination region. </p>
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of the source cluster that you want to disable copying of snapshots to a destination region.</p> <p>Constraints: Must be the valid name of an existing cluster that has cross-region snapshot copy enabled.</p>
  ##   Action: string (required)
  ##   Version: string (required)
  var query_615601 = newJObject()
  var formData_615602 = newJObject()
  add(formData_615602, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_615601, "Action", newJString(Action))
  add(query_615601, "Version", newJString(Version))
  result = call_615600.call(nil, query_615601, nil, formData_615602, nil)

var postDisableSnapshotCopy* = Call_PostDisableSnapshotCopy_615586(
    name: "postDisableSnapshotCopy", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DisableSnapshotCopy",
    validator: validate_PostDisableSnapshotCopy_615587, base: "/",
    url: url_PostDisableSnapshotCopy_615588, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDisableSnapshotCopy_615570 = ref object of OpenApiRestCall_612642
proc url_GetDisableSnapshotCopy_615572(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDisableSnapshotCopy_615571(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Disables the automatic copying of snapshots from one region to another region for a specified cluster.</p> <p>If your cluster and its snapshots are encrypted using a customer master key (CMK) from AWS KMS, use <a>DeleteSnapshotCopyGrant</a> to delete the grant that grants Amazon Redshift permission to the CMK in the destination region. </p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of the source cluster that you want to disable copying of snapshots to a destination region.</p> <p>Constraints: Must be the valid name of an existing cluster that has cross-region snapshot copy enabled.</p>
  ##   Version: JString (required)
  section = newJObject()
  var valid_615573 = query.getOrDefault("Action")
  valid_615573 = validateParameter(valid_615573, JString, required = true,
                                 default = newJString("DisableSnapshotCopy"))
  if valid_615573 != nil:
    section.add "Action", valid_615573
  var valid_615574 = query.getOrDefault("ClusterIdentifier")
  valid_615574 = validateParameter(valid_615574, JString, required = true,
                                 default = nil)
  if valid_615574 != nil:
    section.add "ClusterIdentifier", valid_615574
  var valid_615575 = query.getOrDefault("Version")
  valid_615575 = validateParameter(valid_615575, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_615575 != nil:
    section.add "Version", valid_615575
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_615576 = header.getOrDefault("X-Amz-Signature")
  valid_615576 = validateParameter(valid_615576, JString, required = false,
                                 default = nil)
  if valid_615576 != nil:
    section.add "X-Amz-Signature", valid_615576
  var valid_615577 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_615577 = validateParameter(valid_615577, JString, required = false,
                                 default = nil)
  if valid_615577 != nil:
    section.add "X-Amz-Content-Sha256", valid_615577
  var valid_615578 = header.getOrDefault("X-Amz-Date")
  valid_615578 = validateParameter(valid_615578, JString, required = false,
                                 default = nil)
  if valid_615578 != nil:
    section.add "X-Amz-Date", valid_615578
  var valid_615579 = header.getOrDefault("X-Amz-Credential")
  valid_615579 = validateParameter(valid_615579, JString, required = false,
                                 default = nil)
  if valid_615579 != nil:
    section.add "X-Amz-Credential", valid_615579
  var valid_615580 = header.getOrDefault("X-Amz-Security-Token")
  valid_615580 = validateParameter(valid_615580, JString, required = false,
                                 default = nil)
  if valid_615580 != nil:
    section.add "X-Amz-Security-Token", valid_615580
  var valid_615581 = header.getOrDefault("X-Amz-Algorithm")
  valid_615581 = validateParameter(valid_615581, JString, required = false,
                                 default = nil)
  if valid_615581 != nil:
    section.add "X-Amz-Algorithm", valid_615581
  var valid_615582 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_615582 = validateParameter(valid_615582, JString, required = false,
                                 default = nil)
  if valid_615582 != nil:
    section.add "X-Amz-SignedHeaders", valid_615582
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_615583: Call_GetDisableSnapshotCopy_615570; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Disables the automatic copying of snapshots from one region to another region for a specified cluster.</p> <p>If your cluster and its snapshots are encrypted using a customer master key (CMK) from AWS KMS, use <a>DeleteSnapshotCopyGrant</a> to delete the grant that grants Amazon Redshift permission to the CMK in the destination region. </p>
  ## 
  let valid = call_615583.validator(path, query, header, formData, body)
  let scheme = call_615583.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_615583.url(scheme.get, call_615583.host, call_615583.base,
                         call_615583.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_615583, url, valid)

proc call*(call_615584: Call_GetDisableSnapshotCopy_615570;
          ClusterIdentifier: string; Action: string = "DisableSnapshotCopy";
          Version: string = "2012-12-01"): Recallable =
  ## getDisableSnapshotCopy
  ## <p>Disables the automatic copying of snapshots from one region to another region for a specified cluster.</p> <p>If your cluster and its snapshots are encrypted using a customer master key (CMK) from AWS KMS, use <a>DeleteSnapshotCopyGrant</a> to delete the grant that grants Amazon Redshift permission to the CMK in the destination region. </p>
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of the source cluster that you want to disable copying of snapshots to a destination region.</p> <p>Constraints: Must be the valid name of an existing cluster that has cross-region snapshot copy enabled.</p>
  ##   Version: string (required)
  var query_615585 = newJObject()
  add(query_615585, "Action", newJString(Action))
  add(query_615585, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_615585, "Version", newJString(Version))
  result = call_615584.call(nil, query_615585, nil, nil, nil)

var getDisableSnapshotCopy* = Call_GetDisableSnapshotCopy_615570(
    name: "getDisableSnapshotCopy", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DisableSnapshotCopy",
    validator: validate_GetDisableSnapshotCopy_615571, base: "/",
    url: url_GetDisableSnapshotCopy_615572, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostEnableLogging_615621 = ref object of OpenApiRestCall_612642
proc url_PostEnableLogging_615623(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostEnableLogging_615622(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## Starts logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_615624 = query.getOrDefault("Action")
  valid_615624 = validateParameter(valid_615624, JString, required = true,
                                 default = newJString("EnableLogging"))
  if valid_615624 != nil:
    section.add "Action", valid_615624
  var valid_615625 = query.getOrDefault("Version")
  valid_615625 = validateParameter(valid_615625, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_615625 != nil:
    section.add "Version", valid_615625
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_615626 = header.getOrDefault("X-Amz-Signature")
  valid_615626 = validateParameter(valid_615626, JString, required = false,
                                 default = nil)
  if valid_615626 != nil:
    section.add "X-Amz-Signature", valid_615626
  var valid_615627 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_615627 = validateParameter(valid_615627, JString, required = false,
                                 default = nil)
  if valid_615627 != nil:
    section.add "X-Amz-Content-Sha256", valid_615627
  var valid_615628 = header.getOrDefault("X-Amz-Date")
  valid_615628 = validateParameter(valid_615628, JString, required = false,
                                 default = nil)
  if valid_615628 != nil:
    section.add "X-Amz-Date", valid_615628
  var valid_615629 = header.getOrDefault("X-Amz-Credential")
  valid_615629 = validateParameter(valid_615629, JString, required = false,
                                 default = nil)
  if valid_615629 != nil:
    section.add "X-Amz-Credential", valid_615629
  var valid_615630 = header.getOrDefault("X-Amz-Security-Token")
  valid_615630 = validateParameter(valid_615630, JString, required = false,
                                 default = nil)
  if valid_615630 != nil:
    section.add "X-Amz-Security-Token", valid_615630
  var valid_615631 = header.getOrDefault("X-Amz-Algorithm")
  valid_615631 = validateParameter(valid_615631, JString, required = false,
                                 default = nil)
  if valid_615631 != nil:
    section.add "X-Amz-Algorithm", valid_615631
  var valid_615632 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_615632 = validateParameter(valid_615632, JString, required = false,
                                 default = nil)
  if valid_615632 != nil:
    section.add "X-Amz-SignedHeaders", valid_615632
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The identifier of the cluster on which logging is to be started.</p> <p>Example: <code>examplecluster</code> </p>
  ##   BucketName: JString (required)
  ##             : <p>The name of an existing S3 bucket where the log files are to be stored.</p> <p>Constraints:</p> <ul> <li> <p>Must be in the same region as the cluster</p> </li> <li> <p>The cluster must have read bucket and put object permissions</p> </li> </ul>
  ##   S3KeyPrefix: JString
  ##              : <p>The prefix applied to the log file names.</p> <p>Constraints:</p> <ul> <li> <p>Cannot exceed 512 characters</p> </li> <li> <p>Cannot contain spaces( ), double quotes ("), single quotes ('), a backslash (\), or control characters. The hexadecimal codes for invalid characters are: </p> <ul> <li> <p>x00 to x20</p> </li> <li> <p>x22</p> </li> <li> <p>x27</p> </li> <li> <p>x5c</p> </li> <li> <p>x7f or larger</p> </li> </ul> </li> </ul>
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_615633 = formData.getOrDefault("ClusterIdentifier")
  valid_615633 = validateParameter(valid_615633, JString, required = true,
                                 default = nil)
  if valid_615633 != nil:
    section.add "ClusterIdentifier", valid_615633
  var valid_615634 = formData.getOrDefault("BucketName")
  valid_615634 = validateParameter(valid_615634, JString, required = true,
                                 default = nil)
  if valid_615634 != nil:
    section.add "BucketName", valid_615634
  var valid_615635 = formData.getOrDefault("S3KeyPrefix")
  valid_615635 = validateParameter(valid_615635, JString, required = false,
                                 default = nil)
  if valid_615635 != nil:
    section.add "S3KeyPrefix", valid_615635
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_615636: Call_PostEnableLogging_615621; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Starts logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
  ## 
  let valid = call_615636.validator(path, query, header, formData, body)
  let scheme = call_615636.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_615636.url(scheme.get, call_615636.host, call_615636.base,
                         call_615636.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_615636, url, valid)

proc call*(call_615637: Call_PostEnableLogging_615621; ClusterIdentifier: string;
          BucketName: string; Action: string = "EnableLogging";
          Version: string = "2012-12-01"; S3KeyPrefix: string = ""): Recallable =
  ## postEnableLogging
  ## Starts logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The identifier of the cluster on which logging is to be started.</p> <p>Example: <code>examplecluster</code> </p>
  ##   Action: string (required)
  ##   BucketName: string (required)
  ##             : <p>The name of an existing S3 bucket where the log files are to be stored.</p> <p>Constraints:</p> <ul> <li> <p>Must be in the same region as the cluster</p> </li> <li> <p>The cluster must have read bucket and put object permissions</p> </li> </ul>
  ##   Version: string (required)
  ##   S3KeyPrefix: string
  ##              : <p>The prefix applied to the log file names.</p> <p>Constraints:</p> <ul> <li> <p>Cannot exceed 512 characters</p> </li> <li> <p>Cannot contain spaces( ), double quotes ("), single quotes ('), a backslash (\), or control characters. The hexadecimal codes for invalid characters are: </p> <ul> <li> <p>x00 to x20</p> </li> <li> <p>x22</p> </li> <li> <p>x27</p> </li> <li> <p>x5c</p> </li> <li> <p>x7f or larger</p> </li> </ul> </li> </ul>
  var query_615638 = newJObject()
  var formData_615639 = newJObject()
  add(formData_615639, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_615638, "Action", newJString(Action))
  add(formData_615639, "BucketName", newJString(BucketName))
  add(query_615638, "Version", newJString(Version))
  add(formData_615639, "S3KeyPrefix", newJString(S3KeyPrefix))
  result = call_615637.call(nil, query_615638, nil, formData_615639, nil)

var postEnableLogging* = Call_PostEnableLogging_615621(name: "postEnableLogging",
    meth: HttpMethod.HttpPost, host: "redshift.amazonaws.com",
    route: "/#Action=EnableLogging", validator: validate_PostEnableLogging_615622,
    base: "/", url: url_PostEnableLogging_615623,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetEnableLogging_615603 = ref object of OpenApiRestCall_612642
proc url_GetEnableLogging_615605(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetEnableLogging_615604(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Starts logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   BucketName: JString (required)
  ##             : <p>The name of an existing S3 bucket where the log files are to be stored.</p> <p>Constraints:</p> <ul> <li> <p>Must be in the same region as the cluster</p> </li> <li> <p>The cluster must have read bucket and put object permissions</p> </li> </ul>
  ##   S3KeyPrefix: JString
  ##              : <p>The prefix applied to the log file names.</p> <p>Constraints:</p> <ul> <li> <p>Cannot exceed 512 characters</p> </li> <li> <p>Cannot contain spaces( ), double quotes ("), single quotes ('), a backslash (\), or control characters. The hexadecimal codes for invalid characters are: </p> <ul> <li> <p>x00 to x20</p> </li> <li> <p>x22</p> </li> <li> <p>x27</p> </li> <li> <p>x5c</p> </li> <li> <p>x7f or larger</p> </li> </ul> </li> </ul>
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The identifier of the cluster on which logging is to be started.</p> <p>Example: <code>examplecluster</code> </p>
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `BucketName` field"
  var valid_615606 = query.getOrDefault("BucketName")
  valid_615606 = validateParameter(valid_615606, JString, required = true,
                                 default = nil)
  if valid_615606 != nil:
    section.add "BucketName", valid_615606
  var valid_615607 = query.getOrDefault("S3KeyPrefix")
  valid_615607 = validateParameter(valid_615607, JString, required = false,
                                 default = nil)
  if valid_615607 != nil:
    section.add "S3KeyPrefix", valid_615607
  var valid_615608 = query.getOrDefault("Action")
  valid_615608 = validateParameter(valid_615608, JString, required = true,
                                 default = newJString("EnableLogging"))
  if valid_615608 != nil:
    section.add "Action", valid_615608
  var valid_615609 = query.getOrDefault("ClusterIdentifier")
  valid_615609 = validateParameter(valid_615609, JString, required = true,
                                 default = nil)
  if valid_615609 != nil:
    section.add "ClusterIdentifier", valid_615609
  var valid_615610 = query.getOrDefault("Version")
  valid_615610 = validateParameter(valid_615610, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_615610 != nil:
    section.add "Version", valid_615610
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_615611 = header.getOrDefault("X-Amz-Signature")
  valid_615611 = validateParameter(valid_615611, JString, required = false,
                                 default = nil)
  if valid_615611 != nil:
    section.add "X-Amz-Signature", valid_615611
  var valid_615612 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_615612 = validateParameter(valid_615612, JString, required = false,
                                 default = nil)
  if valid_615612 != nil:
    section.add "X-Amz-Content-Sha256", valid_615612
  var valid_615613 = header.getOrDefault("X-Amz-Date")
  valid_615613 = validateParameter(valid_615613, JString, required = false,
                                 default = nil)
  if valid_615613 != nil:
    section.add "X-Amz-Date", valid_615613
  var valid_615614 = header.getOrDefault("X-Amz-Credential")
  valid_615614 = validateParameter(valid_615614, JString, required = false,
                                 default = nil)
  if valid_615614 != nil:
    section.add "X-Amz-Credential", valid_615614
  var valid_615615 = header.getOrDefault("X-Amz-Security-Token")
  valid_615615 = validateParameter(valid_615615, JString, required = false,
                                 default = nil)
  if valid_615615 != nil:
    section.add "X-Amz-Security-Token", valid_615615
  var valid_615616 = header.getOrDefault("X-Amz-Algorithm")
  valid_615616 = validateParameter(valid_615616, JString, required = false,
                                 default = nil)
  if valid_615616 != nil:
    section.add "X-Amz-Algorithm", valid_615616
  var valid_615617 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_615617 = validateParameter(valid_615617, JString, required = false,
                                 default = nil)
  if valid_615617 != nil:
    section.add "X-Amz-SignedHeaders", valid_615617
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_615618: Call_GetEnableLogging_615603; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Starts logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
  ## 
  let valid = call_615618.validator(path, query, header, formData, body)
  let scheme = call_615618.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_615618.url(scheme.get, call_615618.host, call_615618.base,
                         call_615618.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_615618, url, valid)

proc call*(call_615619: Call_GetEnableLogging_615603; BucketName: string;
          ClusterIdentifier: string; S3KeyPrefix: string = "";
          Action: string = "EnableLogging"; Version: string = "2012-12-01"): Recallable =
  ## getEnableLogging
  ## Starts logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
  ##   BucketName: string (required)
  ##             : <p>The name of an existing S3 bucket where the log files are to be stored.</p> <p>Constraints:</p> <ul> <li> <p>Must be in the same region as the cluster</p> </li> <li> <p>The cluster must have read bucket and put object permissions</p> </li> </ul>
  ##   S3KeyPrefix: string
  ##              : <p>The prefix applied to the log file names.</p> <p>Constraints:</p> <ul> <li> <p>Cannot exceed 512 characters</p> </li> <li> <p>Cannot contain spaces( ), double quotes ("), single quotes ('), a backslash (\), or control characters. The hexadecimal codes for invalid characters are: </p> <ul> <li> <p>x00 to x20</p> </li> <li> <p>x22</p> </li> <li> <p>x27</p> </li> <li> <p>x5c</p> </li> <li> <p>x7f or larger</p> </li> </ul> </li> </ul>
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The identifier of the cluster on which logging is to be started.</p> <p>Example: <code>examplecluster</code> </p>
  ##   Version: string (required)
  var query_615620 = newJObject()
  add(query_615620, "BucketName", newJString(BucketName))
  add(query_615620, "S3KeyPrefix", newJString(S3KeyPrefix))
  add(query_615620, "Action", newJString(Action))
  add(query_615620, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_615620, "Version", newJString(Version))
  result = call_615619.call(nil, query_615620, nil, nil, nil)

var getEnableLogging* = Call_GetEnableLogging_615603(name: "getEnableLogging",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=EnableLogging", validator: validate_GetEnableLogging_615604,
    base: "/", url: url_GetEnableLogging_615605,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostEnableSnapshotCopy_615660 = ref object of OpenApiRestCall_612642
proc url_PostEnableSnapshotCopy_615662(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostEnableSnapshotCopy_615661(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Enables the automatic copy of snapshots from one region to another region for a specified cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_615663 = query.getOrDefault("Action")
  valid_615663 = validateParameter(valid_615663, JString, required = true,
                                 default = newJString("EnableSnapshotCopy"))
  if valid_615663 != nil:
    section.add "Action", valid_615663
  var valid_615664 = query.getOrDefault("Version")
  valid_615664 = validateParameter(valid_615664, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_615664 != nil:
    section.add "Version", valid_615664
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_615665 = header.getOrDefault("X-Amz-Signature")
  valid_615665 = validateParameter(valid_615665, JString, required = false,
                                 default = nil)
  if valid_615665 != nil:
    section.add "X-Amz-Signature", valid_615665
  var valid_615666 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_615666 = validateParameter(valid_615666, JString, required = false,
                                 default = nil)
  if valid_615666 != nil:
    section.add "X-Amz-Content-Sha256", valid_615666
  var valid_615667 = header.getOrDefault("X-Amz-Date")
  valid_615667 = validateParameter(valid_615667, JString, required = false,
                                 default = nil)
  if valid_615667 != nil:
    section.add "X-Amz-Date", valid_615667
  var valid_615668 = header.getOrDefault("X-Amz-Credential")
  valid_615668 = validateParameter(valid_615668, JString, required = false,
                                 default = nil)
  if valid_615668 != nil:
    section.add "X-Amz-Credential", valid_615668
  var valid_615669 = header.getOrDefault("X-Amz-Security-Token")
  valid_615669 = validateParameter(valid_615669, JString, required = false,
                                 default = nil)
  if valid_615669 != nil:
    section.add "X-Amz-Security-Token", valid_615669
  var valid_615670 = header.getOrDefault("X-Amz-Algorithm")
  valid_615670 = validateParameter(valid_615670, JString, required = false,
                                 default = nil)
  if valid_615670 != nil:
    section.add "X-Amz-Algorithm", valid_615670
  var valid_615671 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_615671 = validateParameter(valid_615671, JString, required = false,
                                 default = nil)
  if valid_615671 != nil:
    section.add "X-Amz-SignedHeaders", valid_615671
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of the source cluster to copy snapshots from.</p> <p>Constraints: Must be the valid name of an existing cluster that does not already have cross-region snapshot copy enabled.</p>
  ##   RetentionPeriod: JInt
  ##                  : <p>The number of days to retain automated snapshots in the destination region after they are copied from the source region.</p> <p>Default: 7.</p> <p>Constraints: Must be at least 1 and no more than 35.</p>
  ##   DestinationRegion: JString (required)
  ##                    : <p>The destination AWS Region that you want to copy snapshots to.</p> <p>Constraints: Must be the name of a valid AWS Region. For more information, see <a 
  ## href="https://docs.aws.amazon.com/general/latest/gr/rande.html#redshift_region">Regions and Endpoints</a> in the Amazon Web Services General Reference. </p>
  ##   SnapshotCopyGrantName: JString
  ##                        : The name of the snapshot copy grant to use when snapshots of an AWS KMS-encrypted cluster are copied to the destination region.
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The number of days to retain newly copied snapshots in the destination AWS Region after they are copied from the source AWS Region. If the value is -1, the manual snapshot is retained indefinitely. </p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_615672 = formData.getOrDefault("ClusterIdentifier")
  valid_615672 = validateParameter(valid_615672, JString, required = true,
                                 default = nil)
  if valid_615672 != nil:
    section.add "ClusterIdentifier", valid_615672
  var valid_615673 = formData.getOrDefault("RetentionPeriod")
  valid_615673 = validateParameter(valid_615673, JInt, required = false, default = nil)
  if valid_615673 != nil:
    section.add "RetentionPeriod", valid_615673
  var valid_615674 = formData.getOrDefault("DestinationRegion")
  valid_615674 = validateParameter(valid_615674, JString, required = true,
                                 default = nil)
  if valid_615674 != nil:
    section.add "DestinationRegion", valid_615674
  var valid_615675 = formData.getOrDefault("SnapshotCopyGrantName")
  valid_615675 = validateParameter(valid_615675, JString, required = false,
                                 default = nil)
  if valid_615675 != nil:
    section.add "SnapshotCopyGrantName", valid_615675
  var valid_615676 = formData.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_615676 = validateParameter(valid_615676, JInt, required = false, default = nil)
  if valid_615676 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_615676
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_615677: Call_PostEnableSnapshotCopy_615660; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Enables the automatic copy of snapshots from one region to another region for a specified cluster.
  ## 
  let valid = call_615677.validator(path, query, header, formData, body)
  let scheme = call_615677.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_615677.url(scheme.get, call_615677.host, call_615677.base,
                         call_615677.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_615677, url, valid)

proc call*(call_615678: Call_PostEnableSnapshotCopy_615660;
          ClusterIdentifier: string; DestinationRegion: string;
          RetentionPeriod: int = 0; Action: string = "EnableSnapshotCopy";
          SnapshotCopyGrantName: string = ""; Version: string = "2012-12-01";
          ManualSnapshotRetentionPeriod: int = 0): Recallable =
  ## postEnableSnapshotCopy
  ## Enables the automatic copy of snapshots from one region to another region for a specified cluster.
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of the source cluster to copy snapshots from.</p> <p>Constraints: Must be the valid name of an existing cluster that does not already have cross-region snapshot copy enabled.</p>
  ##   RetentionPeriod: int
  ##                  : <p>The number of days to retain automated snapshots in the destination region after they are copied from the source region.</p> <p>Default: 7.</p> <p>Constraints: Must be at least 1 and no more than 35.</p>
  ##   DestinationRegion: string (required)
  ##                    : <p>The destination AWS Region that you want to copy snapshots to.</p> <p>Constraints: Must be the name of a valid AWS Region. For more information, see <a 
  ## href="https://docs.aws.amazon.com/general/latest/gr/rande.html#redshift_region">Regions and Endpoints</a> in the Amazon Web Services General Reference. </p>
  ##   Action: string (required)
  ##   SnapshotCopyGrantName: string
  ##                        : The name of the snapshot copy grant to use when snapshots of an AWS KMS-encrypted cluster are copied to the destination region.
  ##   Version: string (required)
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The number of days to retain newly copied snapshots in the destination AWS Region after they are copied from the source AWS Region. If the value is -1, the manual snapshot is retained indefinitely. </p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  var query_615679 = newJObject()
  var formData_615680 = newJObject()
  add(formData_615680, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_615680, "RetentionPeriod", newJInt(RetentionPeriod))
  add(formData_615680, "DestinationRegion", newJString(DestinationRegion))
  add(query_615679, "Action", newJString(Action))
  add(formData_615680, "SnapshotCopyGrantName", newJString(SnapshotCopyGrantName))
  add(query_615679, "Version", newJString(Version))
  add(formData_615680, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  result = call_615678.call(nil, query_615679, nil, formData_615680, nil)

var postEnableSnapshotCopy* = Call_PostEnableSnapshotCopy_615660(
    name: "postEnableSnapshotCopy", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=EnableSnapshotCopy",
    validator: validate_PostEnableSnapshotCopy_615661, base: "/",
    url: url_PostEnableSnapshotCopy_615662, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetEnableSnapshotCopy_615640 = ref object of OpenApiRestCall_612642
proc url_GetEnableSnapshotCopy_615642(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetEnableSnapshotCopy_615641(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Enables the automatic copy of snapshots from one region to another region for a specified cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The number of days to retain newly copied snapshots in the destination AWS Region after they are copied from the source AWS Region. If the value is -1, the manual snapshot is retained indefinitely. </p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  ##   DestinationRegion: JString (required)
  ##                    : <p>The destination AWS Region that you want to copy snapshots to.</p> <p>Constraints: Must be the name of a valid AWS Region. For more information, see <a 
  ## href="https://docs.aws.amazon.com/general/latest/gr/rande.html#redshift_region">Regions and Endpoints</a> in the Amazon Web Services General Reference. </p>
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of the source cluster to copy snapshots from.</p> <p>Constraints: Must be the valid name of an existing cluster that does not already have cross-region snapshot copy enabled.</p>
  ##   Version: JString (required)
  ##   RetentionPeriod: JInt
  ##                  : <p>The number of days to retain automated snapshots in the destination region after they are copied from the source region.</p> <p>Default: 7.</p> <p>Constraints: Must be at least 1 and no more than 35.</p>
  ##   SnapshotCopyGrantName: JString
  ##                        : The name of the snapshot copy grant to use when snapshots of an AWS KMS-encrypted cluster are copied to the destination region.
  section = newJObject()
  var valid_615643 = query.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_615643 = validateParameter(valid_615643, JInt, required = false, default = nil)
  if valid_615643 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_615643
  assert query != nil,
        "query argument is necessary due to required `DestinationRegion` field"
  var valid_615644 = query.getOrDefault("DestinationRegion")
  valid_615644 = validateParameter(valid_615644, JString, required = true,
                                 default = nil)
  if valid_615644 != nil:
    section.add "DestinationRegion", valid_615644
  var valid_615645 = query.getOrDefault("Action")
  valid_615645 = validateParameter(valid_615645, JString, required = true,
                                 default = newJString("EnableSnapshotCopy"))
  if valid_615645 != nil:
    section.add "Action", valid_615645
  var valid_615646 = query.getOrDefault("ClusterIdentifier")
  valid_615646 = validateParameter(valid_615646, JString, required = true,
                                 default = nil)
  if valid_615646 != nil:
    section.add "ClusterIdentifier", valid_615646
  var valid_615647 = query.getOrDefault("Version")
  valid_615647 = validateParameter(valid_615647, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_615647 != nil:
    section.add "Version", valid_615647
  var valid_615648 = query.getOrDefault("RetentionPeriod")
  valid_615648 = validateParameter(valid_615648, JInt, required = false, default = nil)
  if valid_615648 != nil:
    section.add "RetentionPeriod", valid_615648
  var valid_615649 = query.getOrDefault("SnapshotCopyGrantName")
  valid_615649 = validateParameter(valid_615649, JString, required = false,
                                 default = nil)
  if valid_615649 != nil:
    section.add "SnapshotCopyGrantName", valid_615649
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_615650 = header.getOrDefault("X-Amz-Signature")
  valid_615650 = validateParameter(valid_615650, JString, required = false,
                                 default = nil)
  if valid_615650 != nil:
    section.add "X-Amz-Signature", valid_615650
  var valid_615651 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_615651 = validateParameter(valid_615651, JString, required = false,
                                 default = nil)
  if valid_615651 != nil:
    section.add "X-Amz-Content-Sha256", valid_615651
  var valid_615652 = header.getOrDefault("X-Amz-Date")
  valid_615652 = validateParameter(valid_615652, JString, required = false,
                                 default = nil)
  if valid_615652 != nil:
    section.add "X-Amz-Date", valid_615652
  var valid_615653 = header.getOrDefault("X-Amz-Credential")
  valid_615653 = validateParameter(valid_615653, JString, required = false,
                                 default = nil)
  if valid_615653 != nil:
    section.add "X-Amz-Credential", valid_615653
  var valid_615654 = header.getOrDefault("X-Amz-Security-Token")
  valid_615654 = validateParameter(valid_615654, JString, required = false,
                                 default = nil)
  if valid_615654 != nil:
    section.add "X-Amz-Security-Token", valid_615654
  var valid_615655 = header.getOrDefault("X-Amz-Algorithm")
  valid_615655 = validateParameter(valid_615655, JString, required = false,
                                 default = nil)
  if valid_615655 != nil:
    section.add "X-Amz-Algorithm", valid_615655
  var valid_615656 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_615656 = validateParameter(valid_615656, JString, required = false,
                                 default = nil)
  if valid_615656 != nil:
    section.add "X-Amz-SignedHeaders", valid_615656
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_615657: Call_GetEnableSnapshotCopy_615640; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Enables the automatic copy of snapshots from one region to another region for a specified cluster.
  ## 
  let valid = call_615657.validator(path, query, header, formData, body)
  let scheme = call_615657.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_615657.url(scheme.get, call_615657.host, call_615657.base,
                         call_615657.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_615657, url, valid)

proc call*(call_615658: Call_GetEnableSnapshotCopy_615640;
          DestinationRegion: string; ClusterIdentifier: string;
          ManualSnapshotRetentionPeriod: int = 0;
          Action: string = "EnableSnapshotCopy"; Version: string = "2012-12-01";
          RetentionPeriod: int = 0; SnapshotCopyGrantName: string = ""): Recallable =
  ## getEnableSnapshotCopy
  ## Enables the automatic copy of snapshots from one region to another region for a specified cluster.
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The number of days to retain newly copied snapshots in the destination AWS Region after they are copied from the source AWS Region. If the value is -1, the manual snapshot is retained indefinitely. </p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  ##   DestinationRegion: string (required)
  ##                    : <p>The destination AWS Region that you want to copy snapshots to.</p> <p>Constraints: Must be the name of a valid AWS Region. For more information, see <a 
  ## href="https://docs.aws.amazon.com/general/latest/gr/rande.html#redshift_region">Regions and Endpoints</a> in the Amazon Web Services General Reference. </p>
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of the source cluster to copy snapshots from.</p> <p>Constraints: Must be the valid name of an existing cluster that does not already have cross-region snapshot copy enabled.</p>
  ##   Version: string (required)
  ##   RetentionPeriod: int
  ##                  : <p>The number of days to retain automated snapshots in the destination region after they are copied from the source region.</p> <p>Default: 7.</p> <p>Constraints: Must be at least 1 and no more than 35.</p>
  ##   SnapshotCopyGrantName: string
  ##                        : The name of the snapshot copy grant to use when snapshots of an AWS KMS-encrypted cluster are copied to the destination region.
  var query_615659 = newJObject()
  add(query_615659, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  add(query_615659, "DestinationRegion", newJString(DestinationRegion))
  add(query_615659, "Action", newJString(Action))
  add(query_615659, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_615659, "Version", newJString(Version))
  add(query_615659, "RetentionPeriod", newJInt(RetentionPeriod))
  add(query_615659, "SnapshotCopyGrantName", newJString(SnapshotCopyGrantName))
  result = call_615658.call(nil, query_615659, nil, nil, nil)

var getEnableSnapshotCopy* = Call_GetEnableSnapshotCopy_615640(
    name: "getEnableSnapshotCopy", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=EnableSnapshotCopy",
    validator: validate_GetEnableSnapshotCopy_615641, base: "/",
    url: url_GetEnableSnapshotCopy_615642, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostGetClusterCredentials_615702 = ref object of OpenApiRestCall_612642
proc url_PostGetClusterCredentials_615704(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostGetClusterCredentials_615703(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns a database user name and temporary password with temporary authorization to log on to an Amazon Redshift database. The action returns the database user name prefixed with <code>IAM:</code> if <code>AutoCreate</code> is <code>False</code> or <code>IAMA:</code> if <code>AutoCreate</code> is <code>True</code>. You can optionally specify one or more database user groups that the user will join at log on. By default, the temporary credentials expire in 900 seconds. You can optionally specify a duration between 900 seconds (15 minutes) and 3600 seconds (60 minutes). For more information, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/generating-user-credentials.html">Using IAM Authentication to Generate Database User Credentials</a> in the Amazon Redshift Cluster Management Guide.</p> <p>The AWS Identity and Access Management (IAM)user or role that executes GetClusterCredentials must have an IAM policy attached that allows access to all necessary actions and resources. For more information about permissions, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-identity-based.html#redshift-policy-resources.getclustercredentials-resources">Resource Policies for GetClusterCredentials</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If the <code>DbGroups</code> parameter is specified, the IAM policy must allow the <code>redshift:JoinGroup</code> action with access to the listed <code>dbgroups</code>. </p> <p>In addition, if the <code>AutoCreate</code> parameter is set to <code>True</code>, then the policy must include the <code>redshift:CreateClusterUser</code> privilege.</p> <p>If the <code>DbName</code> parameter is specified, the IAM policy must allow access to the resource <code>dbname</code> for the specified database name. </p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_615705 = query.getOrDefault("Action")
  valid_615705 = validateParameter(valid_615705, JString, required = true,
                                 default = newJString("GetClusterCredentials"))
  if valid_615705 != nil:
    section.add "Action", valid_615705
  var valid_615706 = query.getOrDefault("Version")
  valid_615706 = validateParameter(valid_615706, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_615706 != nil:
    section.add "Version", valid_615706
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_615707 = header.getOrDefault("X-Amz-Signature")
  valid_615707 = validateParameter(valid_615707, JString, required = false,
                                 default = nil)
  if valid_615707 != nil:
    section.add "X-Amz-Signature", valid_615707
  var valid_615708 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_615708 = validateParameter(valid_615708, JString, required = false,
                                 default = nil)
  if valid_615708 != nil:
    section.add "X-Amz-Content-Sha256", valid_615708
  var valid_615709 = header.getOrDefault("X-Amz-Date")
  valid_615709 = validateParameter(valid_615709, JString, required = false,
                                 default = nil)
  if valid_615709 != nil:
    section.add "X-Amz-Date", valid_615709
  var valid_615710 = header.getOrDefault("X-Amz-Credential")
  valid_615710 = validateParameter(valid_615710, JString, required = false,
                                 default = nil)
  if valid_615710 != nil:
    section.add "X-Amz-Credential", valid_615710
  var valid_615711 = header.getOrDefault("X-Amz-Security-Token")
  valid_615711 = validateParameter(valid_615711, JString, required = false,
                                 default = nil)
  if valid_615711 != nil:
    section.add "X-Amz-Security-Token", valid_615711
  var valid_615712 = header.getOrDefault("X-Amz-Algorithm")
  valid_615712 = validateParameter(valid_615712, JString, required = false,
                                 default = nil)
  if valid_615712 != nil:
    section.add "X-Amz-Algorithm", valid_615712
  var valid_615713 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_615713 = validateParameter(valid_615713, JString, required = false,
                                 default = nil)
  if valid_615713 != nil:
    section.add "X-Amz-SignedHeaders", valid_615713
  result.add "header", section
  ## parameters in `formData` object:
  ##   DbUser: JString (required)
  ##         : <p>The name of a database user. If a user name matching <code>DbUser</code> exists in the database, the temporary user credentials have the same permissions as the existing user. If <code>DbUser</code> doesn't exist in the database and <code>Autocreate</code> is <code>True</code>, a new user is created using the value for <code>DbUser</code> with PUBLIC permissions. If a database user matching the value for <code>DbUser</code> doesn't exist and <code>Autocreate</code> is <code>False</code>, then the command succeeds but the connection attempt will fail because the user doesn't exist in the database.</p> <p>For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/r_CREATE_USER.html">CREATE USER</a> in the Amazon Redshift Database Developer Guide. </p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 64 alphanumeric characters or hyphens. The user name can't be <code>PUBLIC</code>.</p> </li> <li> <p>Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Must not contain a colon ( : ) or slash ( / ). </p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p> </li> </ul>
  ##   ClusterIdentifier: JString (required)
  ##                    : The unique identifier of the cluster that contains the database for which your are requesting credentials. This parameter is case sensitive.
  ##   DurationSeconds: JInt
  ##                  : <p>The number of seconds until the returned temporary password expires.</p> <p>Constraint: minimum 900, maximum 3600.</p> <p>Default: 900</p>
  ##   DbGroups: JArray
  ##           : <p>A list of the names of existing database groups that the user named in <code>DbUser</code> will join for the current session, in addition to any group memberships for an existing user. If not specified, a new user is added only to PUBLIC.</p> <p>Database group name constraints</p> <ul> <li> <p>Must be 1 to 64 alphanumeric characters or hyphens</p> </li> <li> <p>Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Must not contain a colon ( : ) or slash ( / ). </p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p> </li> </ul>
  ##   DbName: JString
  ##         : <p>The name of a database that <code>DbUser</code> is authorized to log on to. If <code>DbName</code> is not specified, <code>DbUser</code> can log on to any existing database.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 64 alphanumeric characters or hyphens</p> </li> <li> <p>Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Must not contain a colon ( : ) or slash ( / ). </p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p> </li> </ul>
  ##   AutoCreate: JBool
  ##             : Create a database user with the name specified for the user named in <code>DbUser</code> if one does not exist.
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `DbUser` field"
  var valid_615714 = formData.getOrDefault("DbUser")
  valid_615714 = validateParameter(valid_615714, JString, required = true,
                                 default = nil)
  if valid_615714 != nil:
    section.add "DbUser", valid_615714
  var valid_615715 = formData.getOrDefault("ClusterIdentifier")
  valid_615715 = validateParameter(valid_615715, JString, required = true,
                                 default = nil)
  if valid_615715 != nil:
    section.add "ClusterIdentifier", valid_615715
  var valid_615716 = formData.getOrDefault("DurationSeconds")
  valid_615716 = validateParameter(valid_615716, JInt, required = false, default = nil)
  if valid_615716 != nil:
    section.add "DurationSeconds", valid_615716
  var valid_615717 = formData.getOrDefault("DbGroups")
  valid_615717 = validateParameter(valid_615717, JArray, required = false,
                                 default = nil)
  if valid_615717 != nil:
    section.add "DbGroups", valid_615717
  var valid_615718 = formData.getOrDefault("DbName")
  valid_615718 = validateParameter(valid_615718, JString, required = false,
                                 default = nil)
  if valid_615718 != nil:
    section.add "DbName", valid_615718
  var valid_615719 = formData.getOrDefault("AutoCreate")
  valid_615719 = validateParameter(valid_615719, JBool, required = false, default = nil)
  if valid_615719 != nil:
    section.add "AutoCreate", valid_615719
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_615720: Call_PostGetClusterCredentials_615702; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns a database user name and temporary password with temporary authorization to log on to an Amazon Redshift database. The action returns the database user name prefixed with <code>IAM:</code> if <code>AutoCreate</code> is <code>False</code> or <code>IAMA:</code> if <code>AutoCreate</code> is <code>True</code>. You can optionally specify one or more database user groups that the user will join at log on. By default, the temporary credentials expire in 900 seconds. You can optionally specify a duration between 900 seconds (15 minutes) and 3600 seconds (60 minutes). For more information, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/generating-user-credentials.html">Using IAM Authentication to Generate Database User Credentials</a> in the Amazon Redshift Cluster Management Guide.</p> <p>The AWS Identity and Access Management (IAM)user or role that executes GetClusterCredentials must have an IAM policy attached that allows access to all necessary actions and resources. For more information about permissions, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-identity-based.html#redshift-policy-resources.getclustercredentials-resources">Resource Policies for GetClusterCredentials</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If the <code>DbGroups</code> parameter is specified, the IAM policy must allow the <code>redshift:JoinGroup</code> action with access to the listed <code>dbgroups</code>. </p> <p>In addition, if the <code>AutoCreate</code> parameter is set to <code>True</code>, then the policy must include the <code>redshift:CreateClusterUser</code> privilege.</p> <p>If the <code>DbName</code> parameter is specified, the IAM policy must allow access to the resource <code>dbname</code> for the specified database name. </p>
  ## 
  let valid = call_615720.validator(path, query, header, formData, body)
  let scheme = call_615720.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_615720.url(scheme.get, call_615720.host, call_615720.base,
                         call_615720.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_615720, url, valid)

proc call*(call_615721: Call_PostGetClusterCredentials_615702; DbUser: string;
          ClusterIdentifier: string; DurationSeconds: int = 0;
          DbGroups: JsonNode = nil; Action: string = "GetClusterCredentials";
          DbName: string = ""; AutoCreate: bool = false; Version: string = "2012-12-01"): Recallable =
  ## postGetClusterCredentials
  ## <p>Returns a database user name and temporary password with temporary authorization to log on to an Amazon Redshift database. The action returns the database user name prefixed with <code>IAM:</code> if <code>AutoCreate</code> is <code>False</code> or <code>IAMA:</code> if <code>AutoCreate</code> is <code>True</code>. You can optionally specify one or more database user groups that the user will join at log on. By default, the temporary credentials expire in 900 seconds. You can optionally specify a duration between 900 seconds (15 minutes) and 3600 seconds (60 minutes). For more information, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/generating-user-credentials.html">Using IAM Authentication to Generate Database User Credentials</a> in the Amazon Redshift Cluster Management Guide.</p> <p>The AWS Identity and Access Management (IAM)user or role that executes GetClusterCredentials must have an IAM policy attached that allows access to all necessary actions and resources. For more information about permissions, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-identity-based.html#redshift-policy-resources.getclustercredentials-resources">Resource Policies for GetClusterCredentials</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If the <code>DbGroups</code> parameter is specified, the IAM policy must allow the <code>redshift:JoinGroup</code> action with access to the listed <code>dbgroups</code>. </p> <p>In addition, if the <code>AutoCreate</code> parameter is set to <code>True</code>, then the policy must include the <code>redshift:CreateClusterUser</code> privilege.</p> <p>If the <code>DbName</code> parameter is specified, the IAM policy must allow access to the resource <code>dbname</code> for the specified database name. </p>
  ##   DbUser: string (required)
  ##         : <p>The name of a database user. If a user name matching <code>DbUser</code> exists in the database, the temporary user credentials have the same permissions as the existing user. If <code>DbUser</code> doesn't exist in the database and <code>Autocreate</code> is <code>True</code>, a new user is created using the value for <code>DbUser</code> with PUBLIC permissions. If a database user matching the value for <code>DbUser</code> doesn't exist and <code>Autocreate</code> is <code>False</code>, then the command succeeds but the connection attempt will fail because the user doesn't exist in the database.</p> <p>For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/r_CREATE_USER.html">CREATE USER</a> in the Amazon Redshift Database Developer Guide. </p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 64 alphanumeric characters or hyphens. The user name can't be <code>PUBLIC</code>.</p> </li> <li> <p>Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Must not contain a colon ( : ) or slash ( / ). </p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p> </li> </ul>
  ##   ClusterIdentifier: string (required)
  ##                    : The unique identifier of the cluster that contains the database for which your are requesting credentials. This parameter is case sensitive.
  ##   DurationSeconds: int
  ##                  : <p>The number of seconds until the returned temporary password expires.</p> <p>Constraint: minimum 900, maximum 3600.</p> <p>Default: 900</p>
  ##   DbGroups: JArray
  ##           : <p>A list of the names of existing database groups that the user named in <code>DbUser</code> will join for the current session, in addition to any group memberships for an existing user. If not specified, a new user is added only to PUBLIC.</p> <p>Database group name constraints</p> <ul> <li> <p>Must be 1 to 64 alphanumeric characters or hyphens</p> </li> <li> <p>Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Must not contain a colon ( : ) or slash ( / ). </p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p> </li> </ul>
  ##   Action: string (required)
  ##   DbName: string
  ##         : <p>The name of a database that <code>DbUser</code> is authorized to log on to. If <code>DbName</code> is not specified, <code>DbUser</code> can log on to any existing database.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 64 alphanumeric characters or hyphens</p> </li> <li> <p>Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Must not contain a colon ( : ) or slash ( / ). </p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p> </li> </ul>
  ##   AutoCreate: bool
  ##             : Create a database user with the name specified for the user named in <code>DbUser</code> if one does not exist.
  ##   Version: string (required)
  var query_615722 = newJObject()
  var formData_615723 = newJObject()
  add(formData_615723, "DbUser", newJString(DbUser))
  add(formData_615723, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_615723, "DurationSeconds", newJInt(DurationSeconds))
  if DbGroups != nil:
    formData_615723.add "DbGroups", DbGroups
  add(query_615722, "Action", newJString(Action))
  add(formData_615723, "DbName", newJString(DbName))
  add(formData_615723, "AutoCreate", newJBool(AutoCreate))
  add(query_615722, "Version", newJString(Version))
  result = call_615721.call(nil, query_615722, nil, formData_615723, nil)

var postGetClusterCredentials* = Call_PostGetClusterCredentials_615702(
    name: "postGetClusterCredentials", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=GetClusterCredentials",
    validator: validate_PostGetClusterCredentials_615703, base: "/",
    url: url_PostGetClusterCredentials_615704,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetGetClusterCredentials_615681 = ref object of OpenApiRestCall_612642
proc url_GetGetClusterCredentials_615683(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetGetClusterCredentials_615682(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns a database user name and temporary password with temporary authorization to log on to an Amazon Redshift database. The action returns the database user name prefixed with <code>IAM:</code> if <code>AutoCreate</code> is <code>False</code> or <code>IAMA:</code> if <code>AutoCreate</code> is <code>True</code>. You can optionally specify one or more database user groups that the user will join at log on. By default, the temporary credentials expire in 900 seconds. You can optionally specify a duration between 900 seconds (15 minutes) and 3600 seconds (60 minutes). For more information, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/generating-user-credentials.html">Using IAM Authentication to Generate Database User Credentials</a> in the Amazon Redshift Cluster Management Guide.</p> <p>The AWS Identity and Access Management (IAM)user or role that executes GetClusterCredentials must have an IAM policy attached that allows access to all necessary actions and resources. For more information about permissions, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-identity-based.html#redshift-policy-resources.getclustercredentials-resources">Resource Policies for GetClusterCredentials</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If the <code>DbGroups</code> parameter is specified, the IAM policy must allow the <code>redshift:JoinGroup</code> action with access to the listed <code>dbgroups</code>. </p> <p>In addition, if the <code>AutoCreate</code> parameter is set to <code>True</code>, then the policy must include the <code>redshift:CreateClusterUser</code> privilege.</p> <p>If the <code>DbName</code> parameter is specified, the IAM policy must allow access to the resource <code>dbname</code> for the specified database name. </p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   DbName: JString
  ##         : <p>The name of a database that <code>DbUser</code> is authorized to log on to. If <code>DbName</code> is not specified, <code>DbUser</code> can log on to any existing database.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 64 alphanumeric characters or hyphens</p> </li> <li> <p>Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Must not contain a colon ( : ) or slash ( / ). </p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p> </li> </ul>
  ##   DbUser: JString (required)
  ##         : <p>The name of a database user. If a user name matching <code>DbUser</code> exists in the database, the temporary user credentials have the same permissions as the existing user. If <code>DbUser</code> doesn't exist in the database and <code>Autocreate</code> is <code>True</code>, a new user is created using the value for <code>DbUser</code> with PUBLIC permissions. If a database user matching the value for <code>DbUser</code> doesn't exist and <code>Autocreate</code> is <code>False</code>, then the command succeeds but the connection attempt will fail because the user doesn't exist in the database.</p> <p>For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/r_CREATE_USER.html">CREATE USER</a> in the Amazon Redshift Database Developer Guide. </p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 64 alphanumeric characters or hyphens. The user name can't be <code>PUBLIC</code>.</p> </li> <li> <p>Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Must not contain a colon ( : ) or slash ( / ). </p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p> </li> </ul>
  ##   AutoCreate: JBool
  ##             : Create a database user with the name specified for the user named in <code>DbUser</code> if one does not exist.
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : The unique identifier of the cluster that contains the database for which your are requesting credentials. This parameter is case sensitive.
  ##   Version: JString (required)
  ##   DbGroups: JArray
  ##           : <p>A list of the names of existing database groups that the user named in <code>DbUser</code> will join for the current session, in addition to any group memberships for an existing user. If not specified, a new user is added only to PUBLIC.</p> <p>Database group name constraints</p> <ul> <li> <p>Must be 1 to 64 alphanumeric characters or hyphens</p> </li> <li> <p>Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Must not contain a colon ( : ) or slash ( / ). </p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p> </li> </ul>
  ##   DurationSeconds: JInt
  ##                  : <p>The number of seconds until the returned temporary password expires.</p> <p>Constraint: minimum 900, maximum 3600.</p> <p>Default: 900</p>
  section = newJObject()
  var valid_615684 = query.getOrDefault("DbName")
  valid_615684 = validateParameter(valid_615684, JString, required = false,
                                 default = nil)
  if valid_615684 != nil:
    section.add "DbName", valid_615684
  assert query != nil, "query argument is necessary due to required `DbUser` field"
  var valid_615685 = query.getOrDefault("DbUser")
  valid_615685 = validateParameter(valid_615685, JString, required = true,
                                 default = nil)
  if valid_615685 != nil:
    section.add "DbUser", valid_615685
  var valid_615686 = query.getOrDefault("AutoCreate")
  valid_615686 = validateParameter(valid_615686, JBool, required = false, default = nil)
  if valid_615686 != nil:
    section.add "AutoCreate", valid_615686
  var valid_615687 = query.getOrDefault("Action")
  valid_615687 = validateParameter(valid_615687, JString, required = true,
                                 default = newJString("GetClusterCredentials"))
  if valid_615687 != nil:
    section.add "Action", valid_615687
  var valid_615688 = query.getOrDefault("ClusterIdentifier")
  valid_615688 = validateParameter(valid_615688, JString, required = true,
                                 default = nil)
  if valid_615688 != nil:
    section.add "ClusterIdentifier", valid_615688
  var valid_615689 = query.getOrDefault("Version")
  valid_615689 = validateParameter(valid_615689, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_615689 != nil:
    section.add "Version", valid_615689
  var valid_615690 = query.getOrDefault("DbGroups")
  valid_615690 = validateParameter(valid_615690, JArray, required = false,
                                 default = nil)
  if valid_615690 != nil:
    section.add "DbGroups", valid_615690
  var valid_615691 = query.getOrDefault("DurationSeconds")
  valid_615691 = validateParameter(valid_615691, JInt, required = false, default = nil)
  if valid_615691 != nil:
    section.add "DurationSeconds", valid_615691
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_615692 = header.getOrDefault("X-Amz-Signature")
  valid_615692 = validateParameter(valid_615692, JString, required = false,
                                 default = nil)
  if valid_615692 != nil:
    section.add "X-Amz-Signature", valid_615692
  var valid_615693 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_615693 = validateParameter(valid_615693, JString, required = false,
                                 default = nil)
  if valid_615693 != nil:
    section.add "X-Amz-Content-Sha256", valid_615693
  var valid_615694 = header.getOrDefault("X-Amz-Date")
  valid_615694 = validateParameter(valid_615694, JString, required = false,
                                 default = nil)
  if valid_615694 != nil:
    section.add "X-Amz-Date", valid_615694
  var valid_615695 = header.getOrDefault("X-Amz-Credential")
  valid_615695 = validateParameter(valid_615695, JString, required = false,
                                 default = nil)
  if valid_615695 != nil:
    section.add "X-Amz-Credential", valid_615695
  var valid_615696 = header.getOrDefault("X-Amz-Security-Token")
  valid_615696 = validateParameter(valid_615696, JString, required = false,
                                 default = nil)
  if valid_615696 != nil:
    section.add "X-Amz-Security-Token", valid_615696
  var valid_615697 = header.getOrDefault("X-Amz-Algorithm")
  valid_615697 = validateParameter(valid_615697, JString, required = false,
                                 default = nil)
  if valid_615697 != nil:
    section.add "X-Amz-Algorithm", valid_615697
  var valid_615698 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_615698 = validateParameter(valid_615698, JString, required = false,
                                 default = nil)
  if valid_615698 != nil:
    section.add "X-Amz-SignedHeaders", valid_615698
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_615699: Call_GetGetClusterCredentials_615681; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns a database user name and temporary password with temporary authorization to log on to an Amazon Redshift database. The action returns the database user name prefixed with <code>IAM:</code> if <code>AutoCreate</code> is <code>False</code> or <code>IAMA:</code> if <code>AutoCreate</code> is <code>True</code>. You can optionally specify one or more database user groups that the user will join at log on. By default, the temporary credentials expire in 900 seconds. You can optionally specify a duration between 900 seconds (15 minutes) and 3600 seconds (60 minutes). For more information, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/generating-user-credentials.html">Using IAM Authentication to Generate Database User Credentials</a> in the Amazon Redshift Cluster Management Guide.</p> <p>The AWS Identity and Access Management (IAM)user or role that executes GetClusterCredentials must have an IAM policy attached that allows access to all necessary actions and resources. For more information about permissions, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-identity-based.html#redshift-policy-resources.getclustercredentials-resources">Resource Policies for GetClusterCredentials</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If the <code>DbGroups</code> parameter is specified, the IAM policy must allow the <code>redshift:JoinGroup</code> action with access to the listed <code>dbgroups</code>. </p> <p>In addition, if the <code>AutoCreate</code> parameter is set to <code>True</code>, then the policy must include the <code>redshift:CreateClusterUser</code> privilege.</p> <p>If the <code>DbName</code> parameter is specified, the IAM policy must allow access to the resource <code>dbname</code> for the specified database name. </p>
  ## 
  let valid = call_615699.validator(path, query, header, formData, body)
  let scheme = call_615699.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_615699.url(scheme.get, call_615699.host, call_615699.base,
                         call_615699.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_615699, url, valid)

proc call*(call_615700: Call_GetGetClusterCredentials_615681; DbUser: string;
          ClusterIdentifier: string; DbName: string = ""; AutoCreate: bool = false;
          Action: string = "GetClusterCredentials"; Version: string = "2012-12-01";
          DbGroups: JsonNode = nil; DurationSeconds: int = 0): Recallable =
  ## getGetClusterCredentials
  ## <p>Returns a database user name and temporary password with temporary authorization to log on to an Amazon Redshift database. The action returns the database user name prefixed with <code>IAM:</code> if <code>AutoCreate</code> is <code>False</code> or <code>IAMA:</code> if <code>AutoCreate</code> is <code>True</code>. You can optionally specify one or more database user groups that the user will join at log on. By default, the temporary credentials expire in 900 seconds. You can optionally specify a duration between 900 seconds (15 minutes) and 3600 seconds (60 minutes). For more information, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/generating-user-credentials.html">Using IAM Authentication to Generate Database User Credentials</a> in the Amazon Redshift Cluster Management Guide.</p> <p>The AWS Identity and Access Management (IAM)user or role that executes GetClusterCredentials must have an IAM policy attached that allows access to all necessary actions and resources. For more information about permissions, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-identity-based.html#redshift-policy-resources.getclustercredentials-resources">Resource Policies for GetClusterCredentials</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If the <code>DbGroups</code> parameter is specified, the IAM policy must allow the <code>redshift:JoinGroup</code> action with access to the listed <code>dbgroups</code>. </p> <p>In addition, if the <code>AutoCreate</code> parameter is set to <code>True</code>, then the policy must include the <code>redshift:CreateClusterUser</code> privilege.</p> <p>If the <code>DbName</code> parameter is specified, the IAM policy must allow access to the resource <code>dbname</code> for the specified database name. </p>
  ##   DbName: string
  ##         : <p>The name of a database that <code>DbUser</code> is authorized to log on to. If <code>DbName</code> is not specified, <code>DbUser</code> can log on to any existing database.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 64 alphanumeric characters or hyphens</p> </li> <li> <p>Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Must not contain a colon ( : ) or slash ( / ). </p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p> </li> </ul>
  ##   DbUser: string (required)
  ##         : <p>The name of a database user. If a user name matching <code>DbUser</code> exists in the database, the temporary user credentials have the same permissions as the existing user. If <code>DbUser</code> doesn't exist in the database and <code>Autocreate</code> is <code>True</code>, a new user is created using the value for <code>DbUser</code> with PUBLIC permissions. If a database user matching the value for <code>DbUser</code> doesn't exist and <code>Autocreate</code> is <code>False</code>, then the command succeeds but the connection attempt will fail because the user doesn't exist in the database.</p> <p>For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/r_CREATE_USER.html">CREATE USER</a> in the Amazon Redshift Database Developer Guide. </p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 64 alphanumeric characters or hyphens. The user name can't be <code>PUBLIC</code>.</p> </li> <li> <p>Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Must not contain a colon ( : ) or slash ( / ). </p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p> </li> </ul>
  ##   AutoCreate: bool
  ##             : Create a database user with the name specified for the user named in <code>DbUser</code> if one does not exist.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : The unique identifier of the cluster that contains the database for which your are requesting credentials. This parameter is case sensitive.
  ##   Version: string (required)
  ##   DbGroups: JArray
  ##           : <p>A list of the names of existing database groups that the user named in <code>DbUser</code> will join for the current session, in addition to any group memberships for an existing user. If not specified, a new user is added only to PUBLIC.</p> <p>Database group name constraints</p> <ul> <li> <p>Must be 1 to 64 alphanumeric characters or hyphens</p> </li> <li> <p>Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Must not contain a colon ( : ) or slash ( / ). </p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p> </li> </ul>
  ##   DurationSeconds: int
  ##                  : <p>The number of seconds until the returned temporary password expires.</p> <p>Constraint: minimum 900, maximum 3600.</p> <p>Default: 900</p>
  var query_615701 = newJObject()
  add(query_615701, "DbName", newJString(DbName))
  add(query_615701, "DbUser", newJString(DbUser))
  add(query_615701, "AutoCreate", newJBool(AutoCreate))
  add(query_615701, "Action", newJString(Action))
  add(query_615701, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_615701, "Version", newJString(Version))
  if DbGroups != nil:
    query_615701.add "DbGroups", DbGroups
  add(query_615701, "DurationSeconds", newJInt(DurationSeconds))
  result = call_615700.call(nil, query_615701, nil, nil, nil)

var getGetClusterCredentials* = Call_GetGetClusterCredentials_615681(
    name: "getGetClusterCredentials", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=GetClusterCredentials",
    validator: validate_GetGetClusterCredentials_615682, base: "/",
    url: url_GetGetClusterCredentials_615683, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostGetReservedNodeExchangeOfferings_615742 = ref object of OpenApiRestCall_612642
proc url_PostGetReservedNodeExchangeOfferings_615744(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostGetReservedNodeExchangeOfferings_615743(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns an array of DC2 ReservedNodeOfferings that matches the payment type, term, and usage price of the given DC1 reserved node.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_615745 = query.getOrDefault("Action")
  valid_615745 = validateParameter(valid_615745, JString, required = true, default = newJString(
      "GetReservedNodeExchangeOfferings"))
  if valid_615745 != nil:
    section.add "Action", valid_615745
  var valid_615746 = query.getOrDefault("Version")
  valid_615746 = validateParameter(valid_615746, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_615746 != nil:
    section.add "Version", valid_615746
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_615747 = header.getOrDefault("X-Amz-Signature")
  valid_615747 = validateParameter(valid_615747, JString, required = false,
                                 default = nil)
  if valid_615747 != nil:
    section.add "X-Amz-Signature", valid_615747
  var valid_615748 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_615748 = validateParameter(valid_615748, JString, required = false,
                                 default = nil)
  if valid_615748 != nil:
    section.add "X-Amz-Content-Sha256", valid_615748
  var valid_615749 = header.getOrDefault("X-Amz-Date")
  valid_615749 = validateParameter(valid_615749, JString, required = false,
                                 default = nil)
  if valid_615749 != nil:
    section.add "X-Amz-Date", valid_615749
  var valid_615750 = header.getOrDefault("X-Amz-Credential")
  valid_615750 = validateParameter(valid_615750, JString, required = false,
                                 default = nil)
  if valid_615750 != nil:
    section.add "X-Amz-Credential", valid_615750
  var valid_615751 = header.getOrDefault("X-Amz-Security-Token")
  valid_615751 = validateParameter(valid_615751, JString, required = false,
                                 default = nil)
  if valid_615751 != nil:
    section.add "X-Amz-Security-Token", valid_615751
  var valid_615752 = header.getOrDefault("X-Amz-Algorithm")
  valid_615752 = validateParameter(valid_615752, JString, required = false,
                                 default = nil)
  if valid_615752 != nil:
    section.add "X-Amz-Algorithm", valid_615752
  var valid_615753 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_615753 = validateParameter(valid_615753, JString, required = false,
                                 default = nil)
  if valid_615753 != nil:
    section.add "X-Amz-SignedHeaders", valid_615753
  result.add "header", section
  ## parameters in `formData` object:
  ##   ReservedNodeId: JString (required)
  ##                 : A string representing the node identifier for the DC1 Reserved Node to be exchanged.
  ##   MaxRecords: JInt
  ##             : An integer setting the maximum number of ReservedNodeOfferings to retrieve.
  ##   Marker: JString
  ##         : A value that indicates the starting point for the next set of ReservedNodeOfferings.
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `ReservedNodeId` field"
  var valid_615754 = formData.getOrDefault("ReservedNodeId")
  valid_615754 = validateParameter(valid_615754, JString, required = true,
                                 default = nil)
  if valid_615754 != nil:
    section.add "ReservedNodeId", valid_615754
  var valid_615755 = formData.getOrDefault("MaxRecords")
  valid_615755 = validateParameter(valid_615755, JInt, required = false, default = nil)
  if valid_615755 != nil:
    section.add "MaxRecords", valid_615755
  var valid_615756 = formData.getOrDefault("Marker")
  valid_615756 = validateParameter(valid_615756, JString, required = false,
                                 default = nil)
  if valid_615756 != nil:
    section.add "Marker", valid_615756
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_615757: Call_PostGetReservedNodeExchangeOfferings_615742;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Returns an array of DC2 ReservedNodeOfferings that matches the payment type, term, and usage price of the given DC1 reserved node.
  ## 
  let valid = call_615757.validator(path, query, header, formData, body)
  let scheme = call_615757.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_615757.url(scheme.get, call_615757.host, call_615757.base,
                         call_615757.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_615757, url, valid)

proc call*(call_615758: Call_PostGetReservedNodeExchangeOfferings_615742;
          ReservedNodeId: string; MaxRecords: int = 0; Marker: string = "";
          Action: string = "GetReservedNodeExchangeOfferings";
          Version: string = "2012-12-01"): Recallable =
  ## postGetReservedNodeExchangeOfferings
  ## Returns an array of DC2 ReservedNodeOfferings that matches the payment type, term, and usage price of the given DC1 reserved node.
  ##   ReservedNodeId: string (required)
  ##                 : A string representing the node identifier for the DC1 Reserved Node to be exchanged.
  ##   MaxRecords: int
  ##             : An integer setting the maximum number of ReservedNodeOfferings to retrieve.
  ##   Marker: string
  ##         : A value that indicates the starting point for the next set of ReservedNodeOfferings.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_615759 = newJObject()
  var formData_615760 = newJObject()
  add(formData_615760, "ReservedNodeId", newJString(ReservedNodeId))
  add(formData_615760, "MaxRecords", newJInt(MaxRecords))
  add(formData_615760, "Marker", newJString(Marker))
  add(query_615759, "Action", newJString(Action))
  add(query_615759, "Version", newJString(Version))
  result = call_615758.call(nil, query_615759, nil, formData_615760, nil)

var postGetReservedNodeExchangeOfferings* = Call_PostGetReservedNodeExchangeOfferings_615742(
    name: "postGetReservedNodeExchangeOfferings", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=GetReservedNodeExchangeOfferings",
    validator: validate_PostGetReservedNodeExchangeOfferings_615743, base: "/",
    url: url_PostGetReservedNodeExchangeOfferings_615744,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetGetReservedNodeExchangeOfferings_615724 = ref object of OpenApiRestCall_612642
proc url_GetGetReservedNodeExchangeOfferings_615726(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetGetReservedNodeExchangeOfferings_615725(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns an array of DC2 ReservedNodeOfferings that matches the payment type, term, and usage price of the given DC1 reserved node.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Marker: JString
  ##         : A value that indicates the starting point for the next set of ReservedNodeOfferings.
  ##   Action: JString (required)
  ##   ReservedNodeId: JString (required)
  ##                 : A string representing the node identifier for the DC1 Reserved Node to be exchanged.
  ##   Version: JString (required)
  ##   MaxRecords: JInt
  ##             : An integer setting the maximum number of ReservedNodeOfferings to retrieve.
  section = newJObject()
  var valid_615727 = query.getOrDefault("Marker")
  valid_615727 = validateParameter(valid_615727, JString, required = false,
                                 default = nil)
  if valid_615727 != nil:
    section.add "Marker", valid_615727
  var valid_615728 = query.getOrDefault("Action")
  valid_615728 = validateParameter(valid_615728, JString, required = true, default = newJString(
      "GetReservedNodeExchangeOfferings"))
  if valid_615728 != nil:
    section.add "Action", valid_615728
  var valid_615729 = query.getOrDefault("ReservedNodeId")
  valid_615729 = validateParameter(valid_615729, JString, required = true,
                                 default = nil)
  if valid_615729 != nil:
    section.add "ReservedNodeId", valid_615729
  var valid_615730 = query.getOrDefault("Version")
  valid_615730 = validateParameter(valid_615730, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_615730 != nil:
    section.add "Version", valid_615730
  var valid_615731 = query.getOrDefault("MaxRecords")
  valid_615731 = validateParameter(valid_615731, JInt, required = false, default = nil)
  if valid_615731 != nil:
    section.add "MaxRecords", valid_615731
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_615732 = header.getOrDefault("X-Amz-Signature")
  valid_615732 = validateParameter(valid_615732, JString, required = false,
                                 default = nil)
  if valid_615732 != nil:
    section.add "X-Amz-Signature", valid_615732
  var valid_615733 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_615733 = validateParameter(valid_615733, JString, required = false,
                                 default = nil)
  if valid_615733 != nil:
    section.add "X-Amz-Content-Sha256", valid_615733
  var valid_615734 = header.getOrDefault("X-Amz-Date")
  valid_615734 = validateParameter(valid_615734, JString, required = false,
                                 default = nil)
  if valid_615734 != nil:
    section.add "X-Amz-Date", valid_615734
  var valid_615735 = header.getOrDefault("X-Amz-Credential")
  valid_615735 = validateParameter(valid_615735, JString, required = false,
                                 default = nil)
  if valid_615735 != nil:
    section.add "X-Amz-Credential", valid_615735
  var valid_615736 = header.getOrDefault("X-Amz-Security-Token")
  valid_615736 = validateParameter(valid_615736, JString, required = false,
                                 default = nil)
  if valid_615736 != nil:
    section.add "X-Amz-Security-Token", valid_615736
  var valid_615737 = header.getOrDefault("X-Amz-Algorithm")
  valid_615737 = validateParameter(valid_615737, JString, required = false,
                                 default = nil)
  if valid_615737 != nil:
    section.add "X-Amz-Algorithm", valid_615737
  var valid_615738 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_615738 = validateParameter(valid_615738, JString, required = false,
                                 default = nil)
  if valid_615738 != nil:
    section.add "X-Amz-SignedHeaders", valid_615738
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_615739: Call_GetGetReservedNodeExchangeOfferings_615724;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Returns an array of DC2 ReservedNodeOfferings that matches the payment type, term, and usage price of the given DC1 reserved node.
  ## 
  let valid = call_615739.validator(path, query, header, formData, body)
  let scheme = call_615739.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_615739.url(scheme.get, call_615739.host, call_615739.base,
                         call_615739.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_615739, url, valid)

proc call*(call_615740: Call_GetGetReservedNodeExchangeOfferings_615724;
          ReservedNodeId: string; Marker: string = "";
          Action: string = "GetReservedNodeExchangeOfferings";
          Version: string = "2012-12-01"; MaxRecords: int = 0): Recallable =
  ## getGetReservedNodeExchangeOfferings
  ## Returns an array of DC2 ReservedNodeOfferings that matches the payment type, term, and usage price of the given DC1 reserved node.
  ##   Marker: string
  ##         : A value that indicates the starting point for the next set of ReservedNodeOfferings.
  ##   Action: string (required)
  ##   ReservedNodeId: string (required)
  ##                 : A string representing the node identifier for the DC1 Reserved Node to be exchanged.
  ##   Version: string (required)
  ##   MaxRecords: int
  ##             : An integer setting the maximum number of ReservedNodeOfferings to retrieve.
  var query_615741 = newJObject()
  add(query_615741, "Marker", newJString(Marker))
  add(query_615741, "Action", newJString(Action))
  add(query_615741, "ReservedNodeId", newJString(ReservedNodeId))
  add(query_615741, "Version", newJString(Version))
  add(query_615741, "MaxRecords", newJInt(MaxRecords))
  result = call_615740.call(nil, query_615741, nil, nil, nil)

var getGetReservedNodeExchangeOfferings* = Call_GetGetReservedNodeExchangeOfferings_615724(
    name: "getGetReservedNodeExchangeOfferings", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=GetReservedNodeExchangeOfferings",
    validator: validate_GetGetReservedNodeExchangeOfferings_615725, base: "/",
    url: url_GetGetReservedNodeExchangeOfferings_615726,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostModifyCluster_615798 = ref object of OpenApiRestCall_612642
proc url_PostModifyCluster_615800(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostModifyCluster_615799(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## <p>Modifies the settings for a cluster.</p> <p>You can also change node type and the number of nodes to scale up or down the cluster. When resizing a cluster, you must specify both the number of nodes and the node type even if one of the parameters does not change.</p> <p>You can add another security or parameter group, or change the master user password. Resetting a cluster password or modifying the security groups associated with a cluster do not need a reboot. However, modifying a parameter group requires a reboot for parameters to take effect. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_615801 = query.getOrDefault("Action")
  valid_615801 = validateParameter(valid_615801, JString, required = true,
                                 default = newJString("ModifyCluster"))
  if valid_615801 != nil:
    section.add "Action", valid_615801
  var valid_615802 = query.getOrDefault("Version")
  valid_615802 = validateParameter(valid_615802, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_615802 != nil:
    section.add "Version", valid_615802
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_615803 = header.getOrDefault("X-Amz-Signature")
  valid_615803 = validateParameter(valid_615803, JString, required = false,
                                 default = nil)
  if valid_615803 != nil:
    section.add "X-Amz-Signature", valid_615803
  var valid_615804 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_615804 = validateParameter(valid_615804, JString, required = false,
                                 default = nil)
  if valid_615804 != nil:
    section.add "X-Amz-Content-Sha256", valid_615804
  var valid_615805 = header.getOrDefault("X-Amz-Date")
  valid_615805 = validateParameter(valid_615805, JString, required = false,
                                 default = nil)
  if valid_615805 != nil:
    section.add "X-Amz-Date", valid_615805
  var valid_615806 = header.getOrDefault("X-Amz-Credential")
  valid_615806 = validateParameter(valid_615806, JString, required = false,
                                 default = nil)
  if valid_615806 != nil:
    section.add "X-Amz-Credential", valid_615806
  var valid_615807 = header.getOrDefault("X-Amz-Security-Token")
  valid_615807 = validateParameter(valid_615807, JString, required = false,
                                 default = nil)
  if valid_615807 != nil:
    section.add "X-Amz-Security-Token", valid_615807
  var valid_615808 = header.getOrDefault("X-Amz-Algorithm")
  valid_615808 = validateParameter(valid_615808, JString, required = false,
                                 default = nil)
  if valid_615808 != nil:
    section.add "X-Amz-Algorithm", valid_615808
  var valid_615809 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_615809 = validateParameter(valid_615809, JString, required = false,
                                 default = nil)
  if valid_615809 != nil:
    section.add "X-Amz-SignedHeaders", valid_615809
  result.add "header", section
  ## parameters in `formData` object:
  ##   PreferredMaintenanceWindow: JString
  ##                             : <p>The weekly time range (in UTC) during which system maintenance can occur, if necessary. If system maintenance is necessary during the window, it may result in an outage.</p> <p>This maintenance window change is made immediately. If the new maintenance window indicates the current time, there must be at least 120 minutes between the current time and end of the window in order to ensure that pending changes are applied.</p> <p>Default: Uses existing setting.</p> <p>Format: ddd:hh24:mi-ddd:hh24:mi, for example <code>wed:07:30-wed:08:00</code>.</p> <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p> <p>Constraints: Must be at least 30 minutes.</p>
  ##   NodeType: JString
  ##           : <p>The new node type of the cluster. If you specify a new node type, you must also specify the number of nodes parameter.</p> <p> For more information about resizing clusters, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/rs-resize-tutorial.html">Resizing Clusters in Amazon Redshift</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>Valid Values: <code>ds2.xlarge</code> | <code>ds2.8xlarge</code> | <code>dc1.large</code> | <code>dc1.8xlarge</code> | <code>dc2.large</code> | <code>dc2.8xlarge</code> | <code>ra3.16xlarge</code> </p>
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of the cluster to be modified.</p> <p>Example: <code>examplecluster</code> </p>
  ##   MasterUserPassword: JString
  ##                     : <p>The new password for the cluster master user. This change is asynchronously applied as soon as possible. Between the time of the request and the completion of the request, the <code>MasterUserPassword</code> element exists in the <code>PendingModifiedValues</code> element of the operation response. </p> <note> <p>Operations never return the password, so this operation provides a way to regain access to the master user account for a cluster if the password is lost.</p> </note> <p>Default: Uses existing setting.</p> <p>Constraints:</p> <ul> <li> <p>Must be between 8 and 64 characters in length.</p> </li> <li> <p>Must contain at least one uppercase letter.</p> </li> <li> <p>Must contain at least one lowercase letter.</p> </li> <li> <p>Must contain one number.</p> </li> <li> <p>Can be any printable ASCII character (ASCII code 33 to 126) except ' (single quote), " (double quote), \, /, @, or space.</p> </li> </ul>
  ##   MaintenanceTrackName: JString
  ##                       : The name for the maintenance track that you want to assign for the cluster. This name change is asynchronous. The new track name stays in the <code>PendingModifiedValues</code> for the cluster until the next maintenance window. When the maintenance track changes, the cluster is switched to the latest cluster release available for the maintenance track. At this point, the maintenance track name is applied.
  ##   ClusterSecurityGroups: JArray
  ##                        : <p>A list of cluster security groups to be authorized on this cluster. This change is asynchronously applied as soon as possible.</p> <p>Security groups currently associated with the cluster, and not in the list of groups to apply, will be revoked from the cluster.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens</p> </li> <li> <p>First character must be a letter</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens</p> </li> </ul>
  ##   NumberOfNodes: JInt
  ##                : <p>The new number of nodes of the cluster. If you specify a new number of nodes, you must also specify the node type parameter.</p> <p> For more information about resizing clusters, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/rs-resize-tutorial.html">Resizing Clusters in Amazon Redshift</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>Valid Values: Integer greater than <code>0</code>.</p>
  ##   VpcSecurityGroupIds: JArray
  ##                      : A list of virtual private cloud (VPC) security groups to be associated with the cluster. This change is asynchronously applied as soon as possible.
  ##   AutomatedSnapshotRetentionPeriod: JInt
  ##                                   : <p>The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p> <p>If you decrease the automated snapshot retention period from its current value, existing automated snapshots that fall outside of the new retention period will be immediately deleted.</p> <p>Default: Uses existing setting.</p> <p>Constraints: Must be a value from 0 to 35.</p>
  ##   NewClusterIdentifier: JString
  ##                       : <p>The new identifier for the cluster.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul> <p>Example: <code>examplecluster</code> </p>
  ##   EnhancedVpcRouting: JBool
  ##                     : <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p> <p>Default: false</p>
  ##   KmsKeyId: JString
  ##           : The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster.
  ##   AllowVersionUpgrade: JBool
  ##                      : <p>If <code>true</code>, major version upgrades will be applied automatically to the cluster during the maintenance window. </p> <p>Default: <code>false</code> </p>
  ##   PubliclyAccessible: JBool
  ##                     : If <code>true</code>, the cluster can be accessed from a public network. Only clusters in VPCs can be set to be publicly available.
  ##   ClusterParameterGroupName: JString
  ##                            : <p>The name of the cluster parameter group to apply to this cluster. This change is applied only after the cluster is rebooted. To reboot a cluster use <a>RebootCluster</a>. </p> <p>Default: Uses existing setting.</p> <p>Constraints: The cluster parameter group must be in the same parameter group family that matches the cluster version.</p>
  ##   ClusterVersion: JString
  ##                 : <p>The new version number of the Amazon Redshift engine to upgrade to.</p> <p>For major version upgrades, if a non-default cluster parameter group is currently in use, a new cluster parameter group in the cluster parameter group family for the new version must be specified. The new cluster parameter group can be the default for that cluster parameter group family. For more information about parameters and parameter groups, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>Example: <code>1.0</code> </p>
  ##   ClusterType: JString
  ##              : <p>The new cluster type.</p> <p>When you submit your cluster resize request, your existing cluster goes into a read-only mode. After Amazon Redshift provisions a new cluster based on your resize requirements, there will be outage for a period while the old cluster is deleted and your connection is switched to the new cluster. You can use <a>DescribeResize</a> to track the progress of the resize request. </p> <p>Valid Values: <code> multi-node | single-node </code> </p>
  ##   HsmClientCertificateIdentifier: JString
  ##                                 : Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM.
  ##   Encrypted: JBool
  ##            : <p>Indicates whether the cluster is encrypted. If the value is encrypted (true) and you provide a value for the <code>KmsKeyId</code> parameter, we encrypt the cluster with the provided <code>KmsKeyId</code>. If you don't provide a <code>KmsKeyId</code>, we encrypt with the default key. In the China region we use legacy encryption if you specify that the cluster is encrypted.</p> <p>If the value is not encrypted (false), then the cluster is decrypted. </p>
  ##   ElasticIp: JString
  ##            : <p>The Elastic IP (EIP) address for the cluster.</p> <p>Constraints: The cluster must be provisioned in EC2-VPC and publicly-accessible through an Internet gateway. For more information about provisioning clusters in EC2-VPC, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#cluster-platforms">Supported Platforms to Launch Your Cluster</a> in the Amazon Redshift Cluster Management Guide.</p>
  ##   HsmConfigurationIdentifier: JString
  ##                             : Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The default for number of days that a newly created manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. This value doesn't retroactively change the retention periods of existing manual snapshots.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  section = newJObject()
  var valid_615810 = formData.getOrDefault("PreferredMaintenanceWindow")
  valid_615810 = validateParameter(valid_615810, JString, required = false,
                                 default = nil)
  if valid_615810 != nil:
    section.add "PreferredMaintenanceWindow", valid_615810
  var valid_615811 = formData.getOrDefault("NodeType")
  valid_615811 = validateParameter(valid_615811, JString, required = false,
                                 default = nil)
  if valid_615811 != nil:
    section.add "NodeType", valid_615811
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_615812 = formData.getOrDefault("ClusterIdentifier")
  valid_615812 = validateParameter(valid_615812, JString, required = true,
                                 default = nil)
  if valid_615812 != nil:
    section.add "ClusterIdentifier", valid_615812
  var valid_615813 = formData.getOrDefault("MasterUserPassword")
  valid_615813 = validateParameter(valid_615813, JString, required = false,
                                 default = nil)
  if valid_615813 != nil:
    section.add "MasterUserPassword", valid_615813
  var valid_615814 = formData.getOrDefault("MaintenanceTrackName")
  valid_615814 = validateParameter(valid_615814, JString, required = false,
                                 default = nil)
  if valid_615814 != nil:
    section.add "MaintenanceTrackName", valid_615814
  var valid_615815 = formData.getOrDefault("ClusterSecurityGroups")
  valid_615815 = validateParameter(valid_615815, JArray, required = false,
                                 default = nil)
  if valid_615815 != nil:
    section.add "ClusterSecurityGroups", valid_615815
  var valid_615816 = formData.getOrDefault("NumberOfNodes")
  valid_615816 = validateParameter(valid_615816, JInt, required = false, default = nil)
  if valid_615816 != nil:
    section.add "NumberOfNodes", valid_615816
  var valid_615817 = formData.getOrDefault("VpcSecurityGroupIds")
  valid_615817 = validateParameter(valid_615817, JArray, required = false,
                                 default = nil)
  if valid_615817 != nil:
    section.add "VpcSecurityGroupIds", valid_615817
  var valid_615818 = formData.getOrDefault("AutomatedSnapshotRetentionPeriod")
  valid_615818 = validateParameter(valid_615818, JInt, required = false, default = nil)
  if valid_615818 != nil:
    section.add "AutomatedSnapshotRetentionPeriod", valid_615818
  var valid_615819 = formData.getOrDefault("NewClusterIdentifier")
  valid_615819 = validateParameter(valid_615819, JString, required = false,
                                 default = nil)
  if valid_615819 != nil:
    section.add "NewClusterIdentifier", valid_615819
  var valid_615820 = formData.getOrDefault("EnhancedVpcRouting")
  valid_615820 = validateParameter(valid_615820, JBool, required = false, default = nil)
  if valid_615820 != nil:
    section.add "EnhancedVpcRouting", valid_615820
  var valid_615821 = formData.getOrDefault("KmsKeyId")
  valid_615821 = validateParameter(valid_615821, JString, required = false,
                                 default = nil)
  if valid_615821 != nil:
    section.add "KmsKeyId", valid_615821
  var valid_615822 = formData.getOrDefault("AllowVersionUpgrade")
  valid_615822 = validateParameter(valid_615822, JBool, required = false, default = nil)
  if valid_615822 != nil:
    section.add "AllowVersionUpgrade", valid_615822
  var valid_615823 = formData.getOrDefault("PubliclyAccessible")
  valid_615823 = validateParameter(valid_615823, JBool, required = false, default = nil)
  if valid_615823 != nil:
    section.add "PubliclyAccessible", valid_615823
  var valid_615824 = formData.getOrDefault("ClusterParameterGroupName")
  valid_615824 = validateParameter(valid_615824, JString, required = false,
                                 default = nil)
  if valid_615824 != nil:
    section.add "ClusterParameterGroupName", valid_615824
  var valid_615825 = formData.getOrDefault("ClusterVersion")
  valid_615825 = validateParameter(valid_615825, JString, required = false,
                                 default = nil)
  if valid_615825 != nil:
    section.add "ClusterVersion", valid_615825
  var valid_615826 = formData.getOrDefault("ClusterType")
  valid_615826 = validateParameter(valid_615826, JString, required = false,
                                 default = nil)
  if valid_615826 != nil:
    section.add "ClusterType", valid_615826
  var valid_615827 = formData.getOrDefault("HsmClientCertificateIdentifier")
  valid_615827 = validateParameter(valid_615827, JString, required = false,
                                 default = nil)
  if valid_615827 != nil:
    section.add "HsmClientCertificateIdentifier", valid_615827
  var valid_615828 = formData.getOrDefault("Encrypted")
  valid_615828 = validateParameter(valid_615828, JBool, required = false, default = nil)
  if valid_615828 != nil:
    section.add "Encrypted", valid_615828
  var valid_615829 = formData.getOrDefault("ElasticIp")
  valid_615829 = validateParameter(valid_615829, JString, required = false,
                                 default = nil)
  if valid_615829 != nil:
    section.add "ElasticIp", valid_615829
  var valid_615830 = formData.getOrDefault("HsmConfigurationIdentifier")
  valid_615830 = validateParameter(valid_615830, JString, required = false,
                                 default = nil)
  if valid_615830 != nil:
    section.add "HsmConfigurationIdentifier", valid_615830
  var valid_615831 = formData.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_615831 = validateParameter(valid_615831, JInt, required = false, default = nil)
  if valid_615831 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_615831
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_615832: Call_PostModifyCluster_615798; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Modifies the settings for a cluster.</p> <p>You can also change node type and the number of nodes to scale up or down the cluster. When resizing a cluster, you must specify both the number of nodes and the node type even if one of the parameters does not change.</p> <p>You can add another security or parameter group, or change the master user password. Resetting a cluster password or modifying the security groups associated with a cluster do not need a reboot. However, modifying a parameter group requires a reboot for parameters to take effect. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_615832.validator(path, query, header, formData, body)
  let scheme = call_615832.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_615832.url(scheme.get, call_615832.host, call_615832.base,
                         call_615832.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_615832, url, valid)

proc call*(call_615833: Call_PostModifyCluster_615798; ClusterIdentifier: string;
          PreferredMaintenanceWindow: string = ""; NodeType: string = "";
          MasterUserPassword: string = ""; MaintenanceTrackName: string = "";
          ClusterSecurityGroups: JsonNode = nil; NumberOfNodes: int = 0;
          VpcSecurityGroupIds: JsonNode = nil;
          AutomatedSnapshotRetentionPeriod: int = 0;
          NewClusterIdentifier: string = ""; EnhancedVpcRouting: bool = false;
          KmsKeyId: string = ""; AllowVersionUpgrade: bool = false;
          PubliclyAccessible: bool = false; Action: string = "ModifyCluster";
          ClusterParameterGroupName: string = ""; ClusterVersion: string = "";
          ClusterType: string = ""; HsmClientCertificateIdentifier: string = "";
          Encrypted: bool = false; Version: string = "2012-12-01";
          ElasticIp: string = ""; HsmConfigurationIdentifier: string = "";
          ManualSnapshotRetentionPeriod: int = 0): Recallable =
  ## postModifyCluster
  ## <p>Modifies the settings for a cluster.</p> <p>You can also change node type and the number of nodes to scale up or down the cluster. When resizing a cluster, you must specify both the number of nodes and the node type even if one of the parameters does not change.</p> <p>You can add another security or parameter group, or change the master user password. Resetting a cluster password or modifying the security groups associated with a cluster do not need a reboot. However, modifying a parameter group requires a reboot for parameters to take effect. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   PreferredMaintenanceWindow: string
  ##                             : <p>The weekly time range (in UTC) during which system maintenance can occur, if necessary. If system maintenance is necessary during the window, it may result in an outage.</p> <p>This maintenance window change is made immediately. If the new maintenance window indicates the current time, there must be at least 120 minutes between the current time and end of the window in order to ensure that pending changes are applied.</p> <p>Default: Uses existing setting.</p> <p>Format: ddd:hh24:mi-ddd:hh24:mi, for example <code>wed:07:30-wed:08:00</code>.</p> <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p> <p>Constraints: Must be at least 30 minutes.</p>
  ##   NodeType: string
  ##           : <p>The new node type of the cluster. If you specify a new node type, you must also specify the number of nodes parameter.</p> <p> For more information about resizing clusters, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/rs-resize-tutorial.html">Resizing Clusters in Amazon Redshift</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>Valid Values: <code>ds2.xlarge</code> | <code>ds2.8xlarge</code> | <code>dc1.large</code> | <code>dc1.8xlarge</code> | <code>dc2.large</code> | <code>dc2.8xlarge</code> | <code>ra3.16xlarge</code> </p>
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of the cluster to be modified.</p> <p>Example: <code>examplecluster</code> </p>
  ##   MasterUserPassword: string
  ##                     : <p>The new password for the cluster master user. This change is asynchronously applied as soon as possible. Between the time of the request and the completion of the request, the <code>MasterUserPassword</code> element exists in the <code>PendingModifiedValues</code> element of the operation response. </p> <note> <p>Operations never return the password, so this operation provides a way to regain access to the master user account for a cluster if the password is lost.</p> </note> <p>Default: Uses existing setting.</p> <p>Constraints:</p> <ul> <li> <p>Must be between 8 and 64 characters in length.</p> </li> <li> <p>Must contain at least one uppercase letter.</p> </li> <li> <p>Must contain at least one lowercase letter.</p> </li> <li> <p>Must contain one number.</p> </li> <li> <p>Can be any printable ASCII character (ASCII code 33 to 126) except ' (single quote), " (double quote), \, /, @, or space.</p> </li> </ul>
  ##   MaintenanceTrackName: string
  ##                       : The name for the maintenance track that you want to assign for the cluster. This name change is asynchronous. The new track name stays in the <code>PendingModifiedValues</code> for the cluster until the next maintenance window. When the maintenance track changes, the cluster is switched to the latest cluster release available for the maintenance track. At this point, the maintenance track name is applied.
  ##   ClusterSecurityGroups: JArray
  ##                        : <p>A list of cluster security groups to be authorized on this cluster. This change is asynchronously applied as soon as possible.</p> <p>Security groups currently associated with the cluster, and not in the list of groups to apply, will be revoked from the cluster.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens</p> </li> <li> <p>First character must be a letter</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens</p> </li> </ul>
  ##   NumberOfNodes: int
  ##                : <p>The new number of nodes of the cluster. If you specify a new number of nodes, you must also specify the node type parameter.</p> <p> For more information about resizing clusters, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/rs-resize-tutorial.html">Resizing Clusters in Amazon Redshift</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>Valid Values: Integer greater than <code>0</code>.</p>
  ##   VpcSecurityGroupIds: JArray
  ##                      : A list of virtual private cloud (VPC) security groups to be associated with the cluster. This change is asynchronously applied as soon as possible.
  ##   AutomatedSnapshotRetentionPeriod: int
  ##                                   : <p>The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p> <p>If you decrease the automated snapshot retention period from its current value, existing automated snapshots that fall outside of the new retention period will be immediately deleted.</p> <p>Default: Uses existing setting.</p> <p>Constraints: Must be a value from 0 to 35.</p>
  ##   NewClusterIdentifier: string
  ##                       : <p>The new identifier for the cluster.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul> <p>Example: <code>examplecluster</code> </p>
  ##   EnhancedVpcRouting: bool
  ##                     : <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p> <p>Default: false</p>
  ##   KmsKeyId: string
  ##           : The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster.
  ##   AllowVersionUpgrade: bool
  ##                      : <p>If <code>true</code>, major version upgrades will be applied automatically to the cluster during the maintenance window. </p> <p>Default: <code>false</code> </p>
  ##   PubliclyAccessible: bool
  ##                     : If <code>true</code>, the cluster can be accessed from a public network. Only clusters in VPCs can be set to be publicly available.
  ##   Action: string (required)
  ##   ClusterParameterGroupName: string
  ##                            : <p>The name of the cluster parameter group to apply to this cluster. This change is applied only after the cluster is rebooted. To reboot a cluster use <a>RebootCluster</a>. </p> <p>Default: Uses existing setting.</p> <p>Constraints: The cluster parameter group must be in the same parameter group family that matches the cluster version.</p>
  ##   ClusterVersion: string
  ##                 : <p>The new version number of the Amazon Redshift engine to upgrade to.</p> <p>For major version upgrades, if a non-default cluster parameter group is currently in use, a new cluster parameter group in the cluster parameter group family for the new version must be specified. The new cluster parameter group can be the default for that cluster parameter group family. For more information about parameters and parameter groups, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>Example: <code>1.0</code> </p>
  ##   ClusterType: string
  ##              : <p>The new cluster type.</p> <p>When you submit your cluster resize request, your existing cluster goes into a read-only mode. After Amazon Redshift provisions a new cluster based on your resize requirements, there will be outage for a period while the old cluster is deleted and your connection is switched to the new cluster. You can use <a>DescribeResize</a> to track the progress of the resize request. </p> <p>Valid Values: <code> multi-node | single-node </code> </p>
  ##   HsmClientCertificateIdentifier: string
  ##                                 : Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM.
  ##   Encrypted: bool
  ##            : <p>Indicates whether the cluster is encrypted. If the value is encrypted (true) and you provide a value for the <code>KmsKeyId</code> parameter, we encrypt the cluster with the provided <code>KmsKeyId</code>. If you don't provide a <code>KmsKeyId</code>, we encrypt with the default key. In the China region we use legacy encryption if you specify that the cluster is encrypted.</p> <p>If the value is not encrypted (false), then the cluster is decrypted. </p>
  ##   Version: string (required)
  ##   ElasticIp: string
  ##            : <p>The Elastic IP (EIP) address for the cluster.</p> <p>Constraints: The cluster must be provisioned in EC2-VPC and publicly-accessible through an Internet gateway. For more information about provisioning clusters in EC2-VPC, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#cluster-platforms">Supported Platforms to Launch Your Cluster</a> in the Amazon Redshift Cluster Management Guide.</p>
  ##   HsmConfigurationIdentifier: string
  ##                             : Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The default for number of days that a newly created manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. This value doesn't retroactively change the retention periods of existing manual snapshots.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  var query_615834 = newJObject()
  var formData_615835 = newJObject()
  add(formData_615835, "PreferredMaintenanceWindow",
      newJString(PreferredMaintenanceWindow))
  add(formData_615835, "NodeType", newJString(NodeType))
  add(formData_615835, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_615835, "MasterUserPassword", newJString(MasterUserPassword))
  add(formData_615835, "MaintenanceTrackName", newJString(MaintenanceTrackName))
  if ClusterSecurityGroups != nil:
    formData_615835.add "ClusterSecurityGroups", ClusterSecurityGroups
  add(formData_615835, "NumberOfNodes", newJInt(NumberOfNodes))
  if VpcSecurityGroupIds != nil:
    formData_615835.add "VpcSecurityGroupIds", VpcSecurityGroupIds
  add(formData_615835, "AutomatedSnapshotRetentionPeriod",
      newJInt(AutomatedSnapshotRetentionPeriod))
  add(formData_615835, "NewClusterIdentifier", newJString(NewClusterIdentifier))
  add(formData_615835, "EnhancedVpcRouting", newJBool(EnhancedVpcRouting))
  add(formData_615835, "KmsKeyId", newJString(KmsKeyId))
  add(formData_615835, "AllowVersionUpgrade", newJBool(AllowVersionUpgrade))
  add(formData_615835, "PubliclyAccessible", newJBool(PubliclyAccessible))
  add(query_615834, "Action", newJString(Action))
  add(formData_615835, "ClusterParameterGroupName",
      newJString(ClusterParameterGroupName))
  add(formData_615835, "ClusterVersion", newJString(ClusterVersion))
  add(formData_615835, "ClusterType", newJString(ClusterType))
  add(formData_615835, "HsmClientCertificateIdentifier",
      newJString(HsmClientCertificateIdentifier))
  add(formData_615835, "Encrypted", newJBool(Encrypted))
  add(query_615834, "Version", newJString(Version))
  add(formData_615835, "ElasticIp", newJString(ElasticIp))
  add(formData_615835, "HsmConfigurationIdentifier",
      newJString(HsmConfigurationIdentifier))
  add(formData_615835, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  result = call_615833.call(nil, query_615834, nil, formData_615835, nil)

var postModifyCluster* = Call_PostModifyCluster_615798(name: "postModifyCluster",
    meth: HttpMethod.HttpPost, host: "redshift.amazonaws.com",
    route: "/#Action=ModifyCluster", validator: validate_PostModifyCluster_615799,
    base: "/", url: url_PostModifyCluster_615800,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetModifyCluster_615761 = ref object of OpenApiRestCall_612642
proc url_GetModifyCluster_615763(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetModifyCluster_615762(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## <p>Modifies the settings for a cluster.</p> <p>You can also change node type and the number of nodes to scale up or down the cluster. When resizing a cluster, you must specify both the number of nodes and the node type even if one of the parameters does not change.</p> <p>You can add another security or parameter group, or change the master user password. Resetting a cluster password or modifying the security groups associated with a cluster do not need a reboot. However, modifying a parameter group requires a reboot for parameters to take effect. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   MaintenanceTrackName: JString
  ##                       : The name for the maintenance track that you want to assign for the cluster. This name change is asynchronous. The new track name stays in the <code>PendingModifiedValues</code> for the cluster until the next maintenance window. When the maintenance track changes, the cluster is switched to the latest cluster release available for the maintenance track. At this point, the maintenance track name is applied.
  ##   Encrypted: JBool
  ##            : <p>Indicates whether the cluster is encrypted. If the value is encrypted (true) and you provide a value for the <code>KmsKeyId</code> parameter, we encrypt the cluster with the provided <code>KmsKeyId</code>. If you don't provide a <code>KmsKeyId</code>, we encrypt with the default key. In the China region we use legacy encryption if you specify that the cluster is encrypted.</p> <p>If the value is not encrypted (false), then the cluster is decrypted. </p>
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The default for number of days that a newly created manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. This value doesn't retroactively change the retention periods of existing manual snapshots.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  ##   HsmClientCertificateIdentifier: JString
  ##                                 : Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM.
  ##   ClusterSecurityGroups: JArray
  ##                        : <p>A list of cluster security groups to be authorized on this cluster. This change is asynchronously applied as soon as possible.</p> <p>Security groups currently associated with the cluster, and not in the list of groups to apply, will be revoked from the cluster.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens</p> </li> <li> <p>First character must be a letter</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens</p> </li> </ul>
  ##   KmsKeyId: JString
  ##           : The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster.
  ##   ClusterParameterGroupName: JString
  ##                            : <p>The name of the cluster parameter group to apply to this cluster. This change is applied only after the cluster is rebooted. To reboot a cluster use <a>RebootCluster</a>. </p> <p>Default: Uses existing setting.</p> <p>Constraints: The cluster parameter group must be in the same parameter group family that matches the cluster version.</p>
  ##   NodeType: JString
  ##           : <p>The new node type of the cluster. If you specify a new node type, you must also specify the number of nodes parameter.</p> <p> For more information about resizing clusters, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/rs-resize-tutorial.html">Resizing Clusters in Amazon Redshift</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>Valid Values: <code>ds2.xlarge</code> | <code>ds2.8xlarge</code> | <code>dc1.large</code> | <code>dc1.8xlarge</code> | <code>dc2.large</code> | <code>dc2.8xlarge</code> | <code>ra3.16xlarge</code> </p>
  ##   ClusterVersion: JString
  ##                 : <p>The new version number of the Amazon Redshift engine to upgrade to.</p> <p>For major version upgrades, if a non-default cluster parameter group is currently in use, a new cluster parameter group in the cluster parameter group family for the new version must be specified. The new cluster parameter group can be the default for that cluster parameter group family. For more information about parameters and parameter groups, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>Example: <code>1.0</code> </p>
  ##   ClusterType: JString
  ##              : <p>The new cluster type.</p> <p>When you submit your cluster resize request, your existing cluster goes into a read-only mode. After Amazon Redshift provisions a new cluster based on your resize requirements, there will be outage for a period while the old cluster is deleted and your connection is switched to the new cluster. You can use <a>DescribeResize</a> to track the progress of the resize request. </p> <p>Valid Values: <code> multi-node | single-node </code> </p>
  ##   NumberOfNodes: JInt
  ##                : <p>The new number of nodes of the cluster. If you specify a new number of nodes, you must also specify the node type parameter.</p> <p> For more information about resizing clusters, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/rs-resize-tutorial.html">Resizing Clusters in Amazon Redshift</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>Valid Values: Integer greater than <code>0</code>.</p>
  ##   AllowVersionUpgrade: JBool
  ##                      : <p>If <code>true</code>, major version upgrades will be applied automatically to the cluster during the maintenance window. </p> <p>Default: <code>false</code> </p>
  ##   ElasticIp: JString
  ##            : <p>The Elastic IP (EIP) address for the cluster.</p> <p>Constraints: The cluster must be provisioned in EC2-VPC and publicly-accessible through an Internet gateway. For more information about provisioning clusters in EC2-VPC, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#cluster-platforms">Supported Platforms to Launch Your Cluster</a> in the Amazon Redshift Cluster Management Guide.</p>
  ##   AutomatedSnapshotRetentionPeriod: JInt
  ##                                   : <p>The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p> <p>If you decrease the automated snapshot retention period from its current value, existing automated snapshots that fall outside of the new retention period will be immediately deleted.</p> <p>Default: Uses existing setting.</p> <p>Constraints: Must be a value from 0 to 35.</p>
  ##   EnhancedVpcRouting: JBool
  ##                     : <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p> <p>Default: false</p>
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of the cluster to be modified.</p> <p>Example: <code>examplecluster</code> </p>
  ##   VpcSecurityGroupIds: JArray
  ##                      : A list of virtual private cloud (VPC) security groups to be associated with the cluster. This change is asynchronously applied as soon as possible.
  ##   NewClusterIdentifier: JString
  ##                       : <p>The new identifier for the cluster.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul> <p>Example: <code>examplecluster</code> </p>
  ##   MasterUserPassword: JString
  ##                     : <p>The new password for the cluster master user. This change is asynchronously applied as soon as possible. Between the time of the request and the completion of the request, the <code>MasterUserPassword</code> element exists in the <code>PendingModifiedValues</code> element of the operation response. </p> <note> <p>Operations never return the password, so this operation provides a way to regain access to the master user account for a cluster if the password is lost.</p> </note> <p>Default: Uses existing setting.</p> <p>Constraints:</p> <ul> <li> <p>Must be between 8 and 64 characters in length.</p> </li> <li> <p>Must contain at least one uppercase letter.</p> </li> <li> <p>Must contain at least one lowercase letter.</p> </li> <li> <p>Must contain one number.</p> </li> <li> <p>Can be any printable ASCII character (ASCII code 33 to 126) except ' (single quote), " (double quote), \, /, @, or space.</p> </li> </ul>
  ##   HsmConfigurationIdentifier: JString
  ##                             : Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
  ##   Version: JString (required)
  ##   PreferredMaintenanceWindow: JString
  ##                             : <p>The weekly time range (in UTC) during which system maintenance can occur, if necessary. If system maintenance is necessary during the window, it may result in an outage.</p> <p>This maintenance window change is made immediately. If the new maintenance window indicates the current time, there must be at least 120 minutes between the current time and end of the window in order to ensure that pending changes are applied.</p> <p>Default: Uses existing setting.</p> <p>Format: ddd:hh24:mi-ddd:hh24:mi, for example <code>wed:07:30-wed:08:00</code>.</p> <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p> <p>Constraints: Must be at least 30 minutes.</p>
  ##   PubliclyAccessible: JBool
  ##                     : If <code>true</code>, the cluster can be accessed from a public network. Only clusters in VPCs can be set to be publicly available.
  section = newJObject()
  var valid_615764 = query.getOrDefault("MaintenanceTrackName")
  valid_615764 = validateParameter(valid_615764, JString, required = false,
                                 default = nil)
  if valid_615764 != nil:
    section.add "MaintenanceTrackName", valid_615764
  var valid_615765 = query.getOrDefault("Encrypted")
  valid_615765 = validateParameter(valid_615765, JBool, required = false, default = nil)
  if valid_615765 != nil:
    section.add "Encrypted", valid_615765
  var valid_615766 = query.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_615766 = validateParameter(valid_615766, JInt, required = false, default = nil)
  if valid_615766 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_615766
  var valid_615767 = query.getOrDefault("HsmClientCertificateIdentifier")
  valid_615767 = validateParameter(valid_615767, JString, required = false,
                                 default = nil)
  if valid_615767 != nil:
    section.add "HsmClientCertificateIdentifier", valid_615767
  var valid_615768 = query.getOrDefault("ClusterSecurityGroups")
  valid_615768 = validateParameter(valid_615768, JArray, required = false,
                                 default = nil)
  if valid_615768 != nil:
    section.add "ClusterSecurityGroups", valid_615768
  var valid_615769 = query.getOrDefault("KmsKeyId")
  valid_615769 = validateParameter(valid_615769, JString, required = false,
                                 default = nil)
  if valid_615769 != nil:
    section.add "KmsKeyId", valid_615769
  var valid_615770 = query.getOrDefault("ClusterParameterGroupName")
  valid_615770 = validateParameter(valid_615770, JString, required = false,
                                 default = nil)
  if valid_615770 != nil:
    section.add "ClusterParameterGroupName", valid_615770
  var valid_615771 = query.getOrDefault("NodeType")
  valid_615771 = validateParameter(valid_615771, JString, required = false,
                                 default = nil)
  if valid_615771 != nil:
    section.add "NodeType", valid_615771
  var valid_615772 = query.getOrDefault("ClusterVersion")
  valid_615772 = validateParameter(valid_615772, JString, required = false,
                                 default = nil)
  if valid_615772 != nil:
    section.add "ClusterVersion", valid_615772
  var valid_615773 = query.getOrDefault("ClusterType")
  valid_615773 = validateParameter(valid_615773, JString, required = false,
                                 default = nil)
  if valid_615773 != nil:
    section.add "ClusterType", valid_615773
  var valid_615774 = query.getOrDefault("NumberOfNodes")
  valid_615774 = validateParameter(valid_615774, JInt, required = false, default = nil)
  if valid_615774 != nil:
    section.add "NumberOfNodes", valid_615774
  var valid_615775 = query.getOrDefault("AllowVersionUpgrade")
  valid_615775 = validateParameter(valid_615775, JBool, required = false, default = nil)
  if valid_615775 != nil:
    section.add "AllowVersionUpgrade", valid_615775
  var valid_615776 = query.getOrDefault("ElasticIp")
  valid_615776 = validateParameter(valid_615776, JString, required = false,
                                 default = nil)
  if valid_615776 != nil:
    section.add "ElasticIp", valid_615776
  var valid_615777 = query.getOrDefault("AutomatedSnapshotRetentionPeriod")
  valid_615777 = validateParameter(valid_615777, JInt, required = false, default = nil)
  if valid_615777 != nil:
    section.add "AutomatedSnapshotRetentionPeriod", valid_615777
  var valid_615778 = query.getOrDefault("EnhancedVpcRouting")
  valid_615778 = validateParameter(valid_615778, JBool, required = false, default = nil)
  if valid_615778 != nil:
    section.add "EnhancedVpcRouting", valid_615778
  var valid_615779 = query.getOrDefault("Action")
  valid_615779 = validateParameter(valid_615779, JString, required = true,
                                 default = newJString("ModifyCluster"))
  if valid_615779 != nil:
    section.add "Action", valid_615779
  var valid_615780 = query.getOrDefault("ClusterIdentifier")
  valid_615780 = validateParameter(valid_615780, JString, required = true,
                                 default = nil)
  if valid_615780 != nil:
    section.add "ClusterIdentifier", valid_615780
  var valid_615781 = query.getOrDefault("VpcSecurityGroupIds")
  valid_615781 = validateParameter(valid_615781, JArray, required = false,
                                 default = nil)
  if valid_615781 != nil:
    section.add "VpcSecurityGroupIds", valid_615781
  var valid_615782 = query.getOrDefault("NewClusterIdentifier")
  valid_615782 = validateParameter(valid_615782, JString, required = false,
                                 default = nil)
  if valid_615782 != nil:
    section.add "NewClusterIdentifier", valid_615782
  var valid_615783 = query.getOrDefault("MasterUserPassword")
  valid_615783 = validateParameter(valid_615783, JString, required = false,
                                 default = nil)
  if valid_615783 != nil:
    section.add "MasterUserPassword", valid_615783
  var valid_615784 = query.getOrDefault("HsmConfigurationIdentifier")
  valid_615784 = validateParameter(valid_615784, JString, required = false,
                                 default = nil)
  if valid_615784 != nil:
    section.add "HsmConfigurationIdentifier", valid_615784
  var valid_615785 = query.getOrDefault("Version")
  valid_615785 = validateParameter(valid_615785, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_615785 != nil:
    section.add "Version", valid_615785
  var valid_615786 = query.getOrDefault("PreferredMaintenanceWindow")
  valid_615786 = validateParameter(valid_615786, JString, required = false,
                                 default = nil)
  if valid_615786 != nil:
    section.add "PreferredMaintenanceWindow", valid_615786
  var valid_615787 = query.getOrDefault("PubliclyAccessible")
  valid_615787 = validateParameter(valid_615787, JBool, required = false, default = nil)
  if valid_615787 != nil:
    section.add "PubliclyAccessible", valid_615787
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_615788 = header.getOrDefault("X-Amz-Signature")
  valid_615788 = validateParameter(valid_615788, JString, required = false,
                                 default = nil)
  if valid_615788 != nil:
    section.add "X-Amz-Signature", valid_615788
  var valid_615789 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_615789 = validateParameter(valid_615789, JString, required = false,
                                 default = nil)
  if valid_615789 != nil:
    section.add "X-Amz-Content-Sha256", valid_615789
  var valid_615790 = header.getOrDefault("X-Amz-Date")
  valid_615790 = validateParameter(valid_615790, JString, required = false,
                                 default = nil)
  if valid_615790 != nil:
    section.add "X-Amz-Date", valid_615790
  var valid_615791 = header.getOrDefault("X-Amz-Credential")
  valid_615791 = validateParameter(valid_615791, JString, required = false,
                                 default = nil)
  if valid_615791 != nil:
    section.add "X-Amz-Credential", valid_615791
  var valid_615792 = header.getOrDefault("X-Amz-Security-Token")
  valid_615792 = validateParameter(valid_615792, JString, required = false,
                                 default = nil)
  if valid_615792 != nil:
    section.add "X-Amz-Security-Token", valid_615792
  var valid_615793 = header.getOrDefault("X-Amz-Algorithm")
  valid_615793 = validateParameter(valid_615793, JString, required = false,
                                 default = nil)
  if valid_615793 != nil:
    section.add "X-Amz-Algorithm", valid_615793
  var valid_615794 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_615794 = validateParameter(valid_615794, JString, required = false,
                                 default = nil)
  if valid_615794 != nil:
    section.add "X-Amz-SignedHeaders", valid_615794
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_615795: Call_GetModifyCluster_615761; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Modifies the settings for a cluster.</p> <p>You can also change node type and the number of nodes to scale up or down the cluster. When resizing a cluster, you must specify both the number of nodes and the node type even if one of the parameters does not change.</p> <p>You can add another security or parameter group, or change the master user password. Resetting a cluster password or modifying the security groups associated with a cluster do not need a reboot. However, modifying a parameter group requires a reboot for parameters to take effect. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_615795.validator(path, query, header, formData, body)
  let scheme = call_615795.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_615795.url(scheme.get, call_615795.host, call_615795.base,
                         call_615795.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_615795, url, valid)

proc call*(call_615796: Call_GetModifyCluster_615761; ClusterIdentifier: string;
          MaintenanceTrackName: string = ""; Encrypted: bool = false;
          ManualSnapshotRetentionPeriod: int = 0;
          HsmClientCertificateIdentifier: string = "";
          ClusterSecurityGroups: JsonNode = nil; KmsKeyId: string = "";
          ClusterParameterGroupName: string = ""; NodeType: string = "";
          ClusterVersion: string = ""; ClusterType: string = ""; NumberOfNodes: int = 0;
          AllowVersionUpgrade: bool = false; ElasticIp: string = "";
          AutomatedSnapshotRetentionPeriod: int = 0;
          EnhancedVpcRouting: bool = false; Action: string = "ModifyCluster";
          VpcSecurityGroupIds: JsonNode = nil; NewClusterIdentifier: string = "";
          MasterUserPassword: string = ""; HsmConfigurationIdentifier: string = "";
          Version: string = "2012-12-01"; PreferredMaintenanceWindow: string = "";
          PubliclyAccessible: bool = false): Recallable =
  ## getModifyCluster
  ## <p>Modifies the settings for a cluster.</p> <p>You can also change node type and the number of nodes to scale up or down the cluster. When resizing a cluster, you must specify both the number of nodes and the node type even if one of the parameters does not change.</p> <p>You can add another security or parameter group, or change the master user password. Resetting a cluster password or modifying the security groups associated with a cluster do not need a reboot. However, modifying a parameter group requires a reboot for parameters to take effect. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   MaintenanceTrackName: string
  ##                       : The name for the maintenance track that you want to assign for the cluster. This name change is asynchronous. The new track name stays in the <code>PendingModifiedValues</code> for the cluster until the next maintenance window. When the maintenance track changes, the cluster is switched to the latest cluster release available for the maintenance track. At this point, the maintenance track name is applied.
  ##   Encrypted: bool
  ##            : <p>Indicates whether the cluster is encrypted. If the value is encrypted (true) and you provide a value for the <code>KmsKeyId</code> parameter, we encrypt the cluster with the provided <code>KmsKeyId</code>. If you don't provide a <code>KmsKeyId</code>, we encrypt with the default key. In the China region we use legacy encryption if you specify that the cluster is encrypted.</p> <p>If the value is not encrypted (false), then the cluster is decrypted. </p>
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The default for number of days that a newly created manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. This value doesn't retroactively change the retention periods of existing manual snapshots.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  ##   HsmClientCertificateIdentifier: string
  ##                                 : Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM.
  ##   ClusterSecurityGroups: JArray
  ##                        : <p>A list of cluster security groups to be authorized on this cluster. This change is asynchronously applied as soon as possible.</p> <p>Security groups currently associated with the cluster, and not in the list of groups to apply, will be revoked from the cluster.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens</p> </li> <li> <p>First character must be a letter</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens</p> </li> </ul>
  ##   KmsKeyId: string
  ##           : The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster.
  ##   ClusterParameterGroupName: string
  ##                            : <p>The name of the cluster parameter group to apply to this cluster. This change is applied only after the cluster is rebooted. To reboot a cluster use <a>RebootCluster</a>. </p> <p>Default: Uses existing setting.</p> <p>Constraints: The cluster parameter group must be in the same parameter group family that matches the cluster version.</p>
  ##   NodeType: string
  ##           : <p>The new node type of the cluster. If you specify a new node type, you must also specify the number of nodes parameter.</p> <p> For more information about resizing clusters, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/rs-resize-tutorial.html">Resizing Clusters in Amazon Redshift</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>Valid Values: <code>ds2.xlarge</code> | <code>ds2.8xlarge</code> | <code>dc1.large</code> | <code>dc1.8xlarge</code> | <code>dc2.large</code> | <code>dc2.8xlarge</code> | <code>ra3.16xlarge</code> </p>
  ##   ClusterVersion: string
  ##                 : <p>The new version number of the Amazon Redshift engine to upgrade to.</p> <p>For major version upgrades, if a non-default cluster parameter group is currently in use, a new cluster parameter group in the cluster parameter group family for the new version must be specified. The new cluster parameter group can be the default for that cluster parameter group family. For more information about parameters and parameter groups, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>Example: <code>1.0</code> </p>
  ##   ClusterType: string
  ##              : <p>The new cluster type.</p> <p>When you submit your cluster resize request, your existing cluster goes into a read-only mode. After Amazon Redshift provisions a new cluster based on your resize requirements, there will be outage for a period while the old cluster is deleted and your connection is switched to the new cluster. You can use <a>DescribeResize</a> to track the progress of the resize request. </p> <p>Valid Values: <code> multi-node | single-node </code> </p>
  ##   NumberOfNodes: int
  ##                : <p>The new number of nodes of the cluster. If you specify a new number of nodes, you must also specify the node type parameter.</p> <p> For more information about resizing clusters, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/rs-resize-tutorial.html">Resizing Clusters in Amazon Redshift</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>Valid Values: Integer greater than <code>0</code>.</p>
  ##   AllowVersionUpgrade: bool
  ##                      : <p>If <code>true</code>, major version upgrades will be applied automatically to the cluster during the maintenance window. </p> <p>Default: <code>false</code> </p>
  ##   ElasticIp: string
  ##            : <p>The Elastic IP (EIP) address for the cluster.</p> <p>Constraints: The cluster must be provisioned in EC2-VPC and publicly-accessible through an Internet gateway. For more information about provisioning clusters in EC2-VPC, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#cluster-platforms">Supported Platforms to Launch Your Cluster</a> in the Amazon Redshift Cluster Management Guide.</p>
  ##   AutomatedSnapshotRetentionPeriod: int
  ##                                   : <p>The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p> <p>If you decrease the automated snapshot retention period from its current value, existing automated snapshots that fall outside of the new retention period will be immediately deleted.</p> <p>Default: Uses existing setting.</p> <p>Constraints: Must be a value from 0 to 35.</p>
  ##   EnhancedVpcRouting: bool
  ##                     : <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p> <p>Default: false</p>
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of the cluster to be modified.</p> <p>Example: <code>examplecluster</code> </p>
  ##   VpcSecurityGroupIds: JArray
  ##                      : A list of virtual private cloud (VPC) security groups to be associated with the cluster. This change is asynchronously applied as soon as possible.
  ##   NewClusterIdentifier: string
  ##                       : <p>The new identifier for the cluster.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul> <p>Example: <code>examplecluster</code> </p>
  ##   MasterUserPassword: string
  ##                     : <p>The new password for the cluster master user. This change is asynchronously applied as soon as possible. Between the time of the request and the completion of the request, the <code>MasterUserPassword</code> element exists in the <code>PendingModifiedValues</code> element of the operation response. </p> <note> <p>Operations never return the password, so this operation provides a way to regain access to the master user account for a cluster if the password is lost.</p> </note> <p>Default: Uses existing setting.</p> <p>Constraints:</p> <ul> <li> <p>Must be between 8 and 64 characters in length.</p> </li> <li> <p>Must contain at least one uppercase letter.</p> </li> <li> <p>Must contain at least one lowercase letter.</p> </li> <li> <p>Must contain one number.</p> </li> <li> <p>Can be any printable ASCII character (ASCII code 33 to 126) except ' (single quote), " (double quote), \, /, @, or space.</p> </li> </ul>
  ##   HsmConfigurationIdentifier: string
  ##                             : Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
  ##   Version: string (required)
  ##   PreferredMaintenanceWindow: string
  ##                             : <p>The weekly time range (in UTC) during which system maintenance can occur, if necessary. If system maintenance is necessary during the window, it may result in an outage.</p> <p>This maintenance window change is made immediately. If the new maintenance window indicates the current time, there must be at least 120 minutes between the current time and end of the window in order to ensure that pending changes are applied.</p> <p>Default: Uses existing setting.</p> <p>Format: ddd:hh24:mi-ddd:hh24:mi, for example <code>wed:07:30-wed:08:00</code>.</p> <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p> <p>Constraints: Must be at least 30 minutes.</p>
  ##   PubliclyAccessible: bool
  ##                     : If <code>true</code>, the cluster can be accessed from a public network. Only clusters in VPCs can be set to be publicly available.
  var query_615797 = newJObject()
  add(query_615797, "MaintenanceTrackName", newJString(MaintenanceTrackName))
  add(query_615797, "Encrypted", newJBool(Encrypted))
  add(query_615797, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  add(query_615797, "HsmClientCertificateIdentifier",
      newJString(HsmClientCertificateIdentifier))
  if ClusterSecurityGroups != nil:
    query_615797.add "ClusterSecurityGroups", ClusterSecurityGroups
  add(query_615797, "KmsKeyId", newJString(KmsKeyId))
  add(query_615797, "ClusterParameterGroupName",
      newJString(ClusterParameterGroupName))
  add(query_615797, "NodeType", newJString(NodeType))
  add(query_615797, "ClusterVersion", newJString(ClusterVersion))
  add(query_615797, "ClusterType", newJString(ClusterType))
  add(query_615797, "NumberOfNodes", newJInt(NumberOfNodes))
  add(query_615797, "AllowVersionUpgrade", newJBool(AllowVersionUpgrade))
  add(query_615797, "ElasticIp", newJString(ElasticIp))
  add(query_615797, "AutomatedSnapshotRetentionPeriod",
      newJInt(AutomatedSnapshotRetentionPeriod))
  add(query_615797, "EnhancedVpcRouting", newJBool(EnhancedVpcRouting))
  add(query_615797, "Action", newJString(Action))
  add(query_615797, "ClusterIdentifier", newJString(ClusterIdentifier))
  if VpcSecurityGroupIds != nil:
    query_615797.add "VpcSecurityGroupIds", VpcSecurityGroupIds
  add(query_615797, "NewClusterIdentifier", newJString(NewClusterIdentifier))
  add(query_615797, "MasterUserPassword", newJString(MasterUserPassword))
  add(query_615797, "HsmConfigurationIdentifier",
      newJString(HsmConfigurationIdentifier))
  add(query_615797, "Version", newJString(Version))
  add(query_615797, "PreferredMaintenanceWindow",
      newJString(PreferredMaintenanceWindow))
  add(query_615797, "PubliclyAccessible", newJBool(PubliclyAccessible))
  result = call_615796.call(nil, query_615797, nil, nil, nil)

var getModifyCluster* = Call_GetModifyCluster_615761(name: "getModifyCluster",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=ModifyCluster", validator: validate_GetModifyCluster_615762,
    base: "/", url: url_GetModifyCluster_615763,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostModifyClusterDbRevision_615853 = ref object of OpenApiRestCall_612642
proc url_PostModifyClusterDbRevision_615855(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostModifyClusterDbRevision_615854(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies the database revision of a cluster. The database revision is a unique revision of the database running in a cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_615856 = query.getOrDefault("Action")
  valid_615856 = validateParameter(valid_615856, JString, required = true, default = newJString(
      "ModifyClusterDbRevision"))
  if valid_615856 != nil:
    section.add "Action", valid_615856
  var valid_615857 = query.getOrDefault("Version")
  valid_615857 = validateParameter(valid_615857, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_615857 != nil:
    section.add "Version", valid_615857
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_615858 = header.getOrDefault("X-Amz-Signature")
  valid_615858 = validateParameter(valid_615858, JString, required = false,
                                 default = nil)
  if valid_615858 != nil:
    section.add "X-Amz-Signature", valid_615858
  var valid_615859 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_615859 = validateParameter(valid_615859, JString, required = false,
                                 default = nil)
  if valid_615859 != nil:
    section.add "X-Amz-Content-Sha256", valid_615859
  var valid_615860 = header.getOrDefault("X-Amz-Date")
  valid_615860 = validateParameter(valid_615860, JString, required = false,
                                 default = nil)
  if valid_615860 != nil:
    section.add "X-Amz-Date", valid_615860
  var valid_615861 = header.getOrDefault("X-Amz-Credential")
  valid_615861 = validateParameter(valid_615861, JString, required = false,
                                 default = nil)
  if valid_615861 != nil:
    section.add "X-Amz-Credential", valid_615861
  var valid_615862 = header.getOrDefault("X-Amz-Security-Token")
  valid_615862 = validateParameter(valid_615862, JString, required = false,
                                 default = nil)
  if valid_615862 != nil:
    section.add "X-Amz-Security-Token", valid_615862
  var valid_615863 = header.getOrDefault("X-Amz-Algorithm")
  valid_615863 = validateParameter(valid_615863, JString, required = false,
                                 default = nil)
  if valid_615863 != nil:
    section.add "X-Amz-Algorithm", valid_615863
  var valid_615864 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_615864 = validateParameter(valid_615864, JString, required = false,
                                 default = nil)
  if valid_615864 != nil:
    section.add "X-Amz-SignedHeaders", valid_615864
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of a cluster whose database revision you want to modify. </p> <p>Example: <code>examplecluster</code> </p>
  ##   RevisionTarget: JString (required)
  ##                 : The identifier of the database revision. You can retrieve this value from the response to the <a>DescribeClusterDbRevisions</a> request.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_615865 = formData.getOrDefault("ClusterIdentifier")
  valid_615865 = validateParameter(valid_615865, JString, required = true,
                                 default = nil)
  if valid_615865 != nil:
    section.add "ClusterIdentifier", valid_615865
  var valid_615866 = formData.getOrDefault("RevisionTarget")
  valid_615866 = validateParameter(valid_615866, JString, required = true,
                                 default = nil)
  if valid_615866 != nil:
    section.add "RevisionTarget", valid_615866
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_615867: Call_PostModifyClusterDbRevision_615853; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Modifies the database revision of a cluster. The database revision is a unique revision of the database running in a cluster.
  ## 
  let valid = call_615867.validator(path, query, header, formData, body)
  let scheme = call_615867.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_615867.url(scheme.get, call_615867.host, call_615867.base,
                         call_615867.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_615867, url, valid)

proc call*(call_615868: Call_PostModifyClusterDbRevision_615853;
          ClusterIdentifier: string; RevisionTarget: string;
          Action: string = "ModifyClusterDbRevision"; Version: string = "2012-12-01"): Recallable =
  ## postModifyClusterDbRevision
  ## Modifies the database revision of a cluster. The database revision is a unique revision of the database running in a cluster.
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of a cluster whose database revision you want to modify. </p> <p>Example: <code>examplecluster</code> </p>
  ##   Action: string (required)
  ##   RevisionTarget: string (required)
  ##                 : The identifier of the database revision. You can retrieve this value from the response to the <a>DescribeClusterDbRevisions</a> request.
  ##   Version: string (required)
  var query_615869 = newJObject()
  var formData_615870 = newJObject()
  add(formData_615870, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_615869, "Action", newJString(Action))
  add(formData_615870, "RevisionTarget", newJString(RevisionTarget))
  add(query_615869, "Version", newJString(Version))
  result = call_615868.call(nil, query_615869, nil, formData_615870, nil)

var postModifyClusterDbRevision* = Call_PostModifyClusterDbRevision_615853(
    name: "postModifyClusterDbRevision", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyClusterDbRevision",
    validator: validate_PostModifyClusterDbRevision_615854, base: "/",
    url: url_PostModifyClusterDbRevision_615855,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetModifyClusterDbRevision_615836 = ref object of OpenApiRestCall_612642
proc url_GetModifyClusterDbRevision_615838(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetModifyClusterDbRevision_615837(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies the database revision of a cluster. The database revision is a unique revision of the database running in a cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   RevisionTarget: JString (required)
  ##                 : The identifier of the database revision. You can retrieve this value from the response to the <a>DescribeClusterDbRevisions</a> request.
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of a cluster whose database revision you want to modify. </p> <p>Example: <code>examplecluster</code> </p>
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `RevisionTarget` field"
  var valid_615839 = query.getOrDefault("RevisionTarget")
  valid_615839 = validateParameter(valid_615839, JString, required = true,
                                 default = nil)
  if valid_615839 != nil:
    section.add "RevisionTarget", valid_615839
  var valid_615840 = query.getOrDefault("Action")
  valid_615840 = validateParameter(valid_615840, JString, required = true, default = newJString(
      "ModifyClusterDbRevision"))
  if valid_615840 != nil:
    section.add "Action", valid_615840
  var valid_615841 = query.getOrDefault("ClusterIdentifier")
  valid_615841 = validateParameter(valid_615841, JString, required = true,
                                 default = nil)
  if valid_615841 != nil:
    section.add "ClusterIdentifier", valid_615841
  var valid_615842 = query.getOrDefault("Version")
  valid_615842 = validateParameter(valid_615842, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_615842 != nil:
    section.add "Version", valid_615842
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_615843 = header.getOrDefault("X-Amz-Signature")
  valid_615843 = validateParameter(valid_615843, JString, required = false,
                                 default = nil)
  if valid_615843 != nil:
    section.add "X-Amz-Signature", valid_615843
  var valid_615844 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_615844 = validateParameter(valid_615844, JString, required = false,
                                 default = nil)
  if valid_615844 != nil:
    section.add "X-Amz-Content-Sha256", valid_615844
  var valid_615845 = header.getOrDefault("X-Amz-Date")
  valid_615845 = validateParameter(valid_615845, JString, required = false,
                                 default = nil)
  if valid_615845 != nil:
    section.add "X-Amz-Date", valid_615845
  var valid_615846 = header.getOrDefault("X-Amz-Credential")
  valid_615846 = validateParameter(valid_615846, JString, required = false,
                                 default = nil)
  if valid_615846 != nil:
    section.add "X-Amz-Credential", valid_615846
  var valid_615847 = header.getOrDefault("X-Amz-Security-Token")
  valid_615847 = validateParameter(valid_615847, JString, required = false,
                                 default = nil)
  if valid_615847 != nil:
    section.add "X-Amz-Security-Token", valid_615847
  var valid_615848 = header.getOrDefault("X-Amz-Algorithm")
  valid_615848 = validateParameter(valid_615848, JString, required = false,
                                 default = nil)
  if valid_615848 != nil:
    section.add "X-Amz-Algorithm", valid_615848
  var valid_615849 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_615849 = validateParameter(valid_615849, JString, required = false,
                                 default = nil)
  if valid_615849 != nil:
    section.add "X-Amz-SignedHeaders", valid_615849
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_615850: Call_GetModifyClusterDbRevision_615836; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Modifies the database revision of a cluster. The database revision is a unique revision of the database running in a cluster.
  ## 
  let valid = call_615850.validator(path, query, header, formData, body)
  let scheme = call_615850.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_615850.url(scheme.get, call_615850.host, call_615850.base,
                         call_615850.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_615850, url, valid)

proc call*(call_615851: Call_GetModifyClusterDbRevision_615836;
          RevisionTarget: string; ClusterIdentifier: string;
          Action: string = "ModifyClusterDbRevision"; Version: string = "2012-12-01"): Recallable =
  ## getModifyClusterDbRevision
  ## Modifies the database revision of a cluster. The database revision is a unique revision of the database running in a cluster.
  ##   RevisionTarget: string (required)
  ##                 : The identifier of the database revision. You can retrieve this value from the response to the <a>DescribeClusterDbRevisions</a> request.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of a cluster whose database revision you want to modify. </p> <p>Example: <code>examplecluster</code> </p>
  ##   Version: string (required)
  var query_615852 = newJObject()
  add(query_615852, "RevisionTarget", newJString(RevisionTarget))
  add(query_615852, "Action", newJString(Action))
  add(query_615852, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_615852, "Version", newJString(Version))
  result = call_615851.call(nil, query_615852, nil, nil, nil)

var getModifyClusterDbRevision* = Call_GetModifyClusterDbRevision_615836(
    name: "getModifyClusterDbRevision", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyClusterDbRevision",
    validator: validate_GetModifyClusterDbRevision_615837, base: "/",
    url: url_GetModifyClusterDbRevision_615838,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostModifyClusterIamRoles_615889 = ref object of OpenApiRestCall_612642
proc url_PostModifyClusterIamRoles_615891(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostModifyClusterIamRoles_615890(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Modifies the list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services.</p> <p>A cluster can have up to 10 IAM roles associated at any time.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_615892 = query.getOrDefault("Action")
  valid_615892 = validateParameter(valid_615892, JString, required = true,
                                 default = newJString("ModifyClusterIamRoles"))
  if valid_615892 != nil:
    section.add "Action", valid_615892
  var valid_615893 = query.getOrDefault("Version")
  valid_615893 = validateParameter(valid_615893, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_615893 != nil:
    section.add "Version", valid_615893
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_615894 = header.getOrDefault("X-Amz-Signature")
  valid_615894 = validateParameter(valid_615894, JString, required = false,
                                 default = nil)
  if valid_615894 != nil:
    section.add "X-Amz-Signature", valid_615894
  var valid_615895 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_615895 = validateParameter(valid_615895, JString, required = false,
                                 default = nil)
  if valid_615895 != nil:
    section.add "X-Amz-Content-Sha256", valid_615895
  var valid_615896 = header.getOrDefault("X-Amz-Date")
  valid_615896 = validateParameter(valid_615896, JString, required = false,
                                 default = nil)
  if valid_615896 != nil:
    section.add "X-Amz-Date", valid_615896
  var valid_615897 = header.getOrDefault("X-Amz-Credential")
  valid_615897 = validateParameter(valid_615897, JString, required = false,
                                 default = nil)
  if valid_615897 != nil:
    section.add "X-Amz-Credential", valid_615897
  var valid_615898 = header.getOrDefault("X-Amz-Security-Token")
  valid_615898 = validateParameter(valid_615898, JString, required = false,
                                 default = nil)
  if valid_615898 != nil:
    section.add "X-Amz-Security-Token", valid_615898
  var valid_615899 = header.getOrDefault("X-Amz-Algorithm")
  valid_615899 = validateParameter(valid_615899, JString, required = false,
                                 default = nil)
  if valid_615899 != nil:
    section.add "X-Amz-Algorithm", valid_615899
  var valid_615900 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_615900 = validateParameter(valid_615900, JString, required = false,
                                 default = nil)
  if valid_615900 != nil:
    section.add "X-Amz-SignedHeaders", valid_615900
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : The unique identifier of the cluster for which you want to associate or disassociate IAM roles.
  ##   RemoveIamRoles: JArray
  ##                 : Zero or more IAM roles in ARN format to disassociate from the cluster. You can disassociate up to 10 IAM roles from a single cluster in a single request.
  ##   AddIamRoles: JArray
  ##              : Zero or more IAM roles to associate with the cluster. The roles must be in their Amazon Resource Name (ARN) format. You can associate up to 10 IAM roles with a single cluster in a single request.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_615901 = formData.getOrDefault("ClusterIdentifier")
  valid_615901 = validateParameter(valid_615901, JString, required = true,
                                 default = nil)
  if valid_615901 != nil:
    section.add "ClusterIdentifier", valid_615901
  var valid_615902 = formData.getOrDefault("RemoveIamRoles")
  valid_615902 = validateParameter(valid_615902, JArray, required = false,
                                 default = nil)
  if valid_615902 != nil:
    section.add "RemoveIamRoles", valid_615902
  var valid_615903 = formData.getOrDefault("AddIamRoles")
  valid_615903 = validateParameter(valid_615903, JArray, required = false,
                                 default = nil)
  if valid_615903 != nil:
    section.add "AddIamRoles", valid_615903
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_615904: Call_PostModifyClusterIamRoles_615889; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Modifies the list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services.</p> <p>A cluster can have up to 10 IAM roles associated at any time.</p>
  ## 
  let valid = call_615904.validator(path, query, header, formData, body)
  let scheme = call_615904.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_615904.url(scheme.get, call_615904.host, call_615904.base,
                         call_615904.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_615904, url, valid)

proc call*(call_615905: Call_PostModifyClusterIamRoles_615889;
          ClusterIdentifier: string; RemoveIamRoles: JsonNode = nil;
          Action: string = "ModifyClusterIamRoles"; AddIamRoles: JsonNode = nil;
          Version: string = "2012-12-01"): Recallable =
  ## postModifyClusterIamRoles
  ## <p>Modifies the list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services.</p> <p>A cluster can have up to 10 IAM roles associated at any time.</p>
  ##   ClusterIdentifier: string (required)
  ##                    : The unique identifier of the cluster for which you want to associate or disassociate IAM roles.
  ##   RemoveIamRoles: JArray
  ##                 : Zero or more IAM roles in ARN format to disassociate from the cluster. You can disassociate up to 10 IAM roles from a single cluster in a single request.
  ##   Action: string (required)
  ##   AddIamRoles: JArray
  ##              : Zero or more IAM roles to associate with the cluster. The roles must be in their Amazon Resource Name (ARN) format. You can associate up to 10 IAM roles with a single cluster in a single request.
  ##   Version: string (required)
  var query_615906 = newJObject()
  var formData_615907 = newJObject()
  add(formData_615907, "ClusterIdentifier", newJString(ClusterIdentifier))
  if RemoveIamRoles != nil:
    formData_615907.add "RemoveIamRoles", RemoveIamRoles
  add(query_615906, "Action", newJString(Action))
  if AddIamRoles != nil:
    formData_615907.add "AddIamRoles", AddIamRoles
  add(query_615906, "Version", newJString(Version))
  result = call_615905.call(nil, query_615906, nil, formData_615907, nil)

var postModifyClusterIamRoles* = Call_PostModifyClusterIamRoles_615889(
    name: "postModifyClusterIamRoles", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyClusterIamRoles",
    validator: validate_PostModifyClusterIamRoles_615890, base: "/",
    url: url_PostModifyClusterIamRoles_615891,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetModifyClusterIamRoles_615871 = ref object of OpenApiRestCall_612642
proc url_GetModifyClusterIamRoles_615873(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetModifyClusterIamRoles_615872(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Modifies the list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services.</p> <p>A cluster can have up to 10 IAM roles associated at any time.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   AddIamRoles: JArray
  ##              : Zero or more IAM roles to associate with the cluster. The roles must be in their Amazon Resource Name (ARN) format. You can associate up to 10 IAM roles with a single cluster in a single request.
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : The unique identifier of the cluster for which you want to associate or disassociate IAM roles.
  ##   RemoveIamRoles: JArray
  ##                 : Zero or more IAM roles in ARN format to disassociate from the cluster. You can disassociate up to 10 IAM roles from a single cluster in a single request.
  ##   Version: JString (required)
  section = newJObject()
  var valid_615874 = query.getOrDefault("AddIamRoles")
  valid_615874 = validateParameter(valid_615874, JArray, required = false,
                                 default = nil)
  if valid_615874 != nil:
    section.add "AddIamRoles", valid_615874
  var valid_615875 = query.getOrDefault("Action")
  valid_615875 = validateParameter(valid_615875, JString, required = true,
                                 default = newJString("ModifyClusterIamRoles"))
  if valid_615875 != nil:
    section.add "Action", valid_615875
  var valid_615876 = query.getOrDefault("ClusterIdentifier")
  valid_615876 = validateParameter(valid_615876, JString, required = true,
                                 default = nil)
  if valid_615876 != nil:
    section.add "ClusterIdentifier", valid_615876
  var valid_615877 = query.getOrDefault("RemoveIamRoles")
  valid_615877 = validateParameter(valid_615877, JArray, required = false,
                                 default = nil)
  if valid_615877 != nil:
    section.add "RemoveIamRoles", valid_615877
  var valid_615878 = query.getOrDefault("Version")
  valid_615878 = validateParameter(valid_615878, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_615878 != nil:
    section.add "Version", valid_615878
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_615879 = header.getOrDefault("X-Amz-Signature")
  valid_615879 = validateParameter(valid_615879, JString, required = false,
                                 default = nil)
  if valid_615879 != nil:
    section.add "X-Amz-Signature", valid_615879
  var valid_615880 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_615880 = validateParameter(valid_615880, JString, required = false,
                                 default = nil)
  if valid_615880 != nil:
    section.add "X-Amz-Content-Sha256", valid_615880
  var valid_615881 = header.getOrDefault("X-Amz-Date")
  valid_615881 = validateParameter(valid_615881, JString, required = false,
                                 default = nil)
  if valid_615881 != nil:
    section.add "X-Amz-Date", valid_615881
  var valid_615882 = header.getOrDefault("X-Amz-Credential")
  valid_615882 = validateParameter(valid_615882, JString, required = false,
                                 default = nil)
  if valid_615882 != nil:
    section.add "X-Amz-Credential", valid_615882
  var valid_615883 = header.getOrDefault("X-Amz-Security-Token")
  valid_615883 = validateParameter(valid_615883, JString, required = false,
                                 default = nil)
  if valid_615883 != nil:
    section.add "X-Amz-Security-Token", valid_615883
  var valid_615884 = header.getOrDefault("X-Amz-Algorithm")
  valid_615884 = validateParameter(valid_615884, JString, required = false,
                                 default = nil)
  if valid_615884 != nil:
    section.add "X-Amz-Algorithm", valid_615884
  var valid_615885 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_615885 = validateParameter(valid_615885, JString, required = false,
                                 default = nil)
  if valid_615885 != nil:
    section.add "X-Amz-SignedHeaders", valid_615885
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_615886: Call_GetModifyClusterIamRoles_615871; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Modifies the list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services.</p> <p>A cluster can have up to 10 IAM roles associated at any time.</p>
  ## 
  let valid = call_615886.validator(path, query, header, formData, body)
  let scheme = call_615886.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_615886.url(scheme.get, call_615886.host, call_615886.base,
                         call_615886.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_615886, url, valid)

proc call*(call_615887: Call_GetModifyClusterIamRoles_615871;
          ClusterIdentifier: string; AddIamRoles: JsonNode = nil;
          Action: string = "ModifyClusterIamRoles"; RemoveIamRoles: JsonNode = nil;
          Version: string = "2012-12-01"): Recallable =
  ## getModifyClusterIamRoles
  ## <p>Modifies the list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services.</p> <p>A cluster can have up to 10 IAM roles associated at any time.</p>
  ##   AddIamRoles: JArray
  ##              : Zero or more IAM roles to associate with the cluster. The roles must be in their Amazon Resource Name (ARN) format. You can associate up to 10 IAM roles with a single cluster in a single request.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : The unique identifier of the cluster for which you want to associate or disassociate IAM roles.
  ##   RemoveIamRoles: JArray
  ##                 : Zero or more IAM roles in ARN format to disassociate from the cluster. You can disassociate up to 10 IAM roles from a single cluster in a single request.
  ##   Version: string (required)
  var query_615888 = newJObject()
  if AddIamRoles != nil:
    query_615888.add "AddIamRoles", AddIamRoles
  add(query_615888, "Action", newJString(Action))
  add(query_615888, "ClusterIdentifier", newJString(ClusterIdentifier))
  if RemoveIamRoles != nil:
    query_615888.add "RemoveIamRoles", RemoveIamRoles
  add(query_615888, "Version", newJString(Version))
  result = call_615887.call(nil, query_615888, nil, nil, nil)

var getModifyClusterIamRoles* = Call_GetModifyClusterIamRoles_615871(
    name: "getModifyClusterIamRoles", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyClusterIamRoles",
    validator: validate_GetModifyClusterIamRoles_615872, base: "/",
    url: url_GetModifyClusterIamRoles_615873, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostModifyClusterMaintenance_615929 = ref object of OpenApiRestCall_612642
proc url_PostModifyClusterMaintenance_615931(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostModifyClusterMaintenance_615930(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies the maintenance settings of a cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_615932 = query.getOrDefault("Action")
  valid_615932 = validateParameter(valid_615932, JString, required = true, default = newJString(
      "ModifyClusterMaintenance"))
  if valid_615932 != nil:
    section.add "Action", valid_615932
  var valid_615933 = query.getOrDefault("Version")
  valid_615933 = validateParameter(valid_615933, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_615933 != nil:
    section.add "Version", valid_615933
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_615934 = header.getOrDefault("X-Amz-Signature")
  valid_615934 = validateParameter(valid_615934, JString, required = false,
                                 default = nil)
  if valid_615934 != nil:
    section.add "X-Amz-Signature", valid_615934
  var valid_615935 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_615935 = validateParameter(valid_615935, JString, required = false,
                                 default = nil)
  if valid_615935 != nil:
    section.add "X-Amz-Content-Sha256", valid_615935
  var valid_615936 = header.getOrDefault("X-Amz-Date")
  valid_615936 = validateParameter(valid_615936, JString, required = false,
                                 default = nil)
  if valid_615936 != nil:
    section.add "X-Amz-Date", valid_615936
  var valid_615937 = header.getOrDefault("X-Amz-Credential")
  valid_615937 = validateParameter(valid_615937, JString, required = false,
                                 default = nil)
  if valid_615937 != nil:
    section.add "X-Amz-Credential", valid_615937
  var valid_615938 = header.getOrDefault("X-Amz-Security-Token")
  valid_615938 = validateParameter(valid_615938, JString, required = false,
                                 default = nil)
  if valid_615938 != nil:
    section.add "X-Amz-Security-Token", valid_615938
  var valid_615939 = header.getOrDefault("X-Amz-Algorithm")
  valid_615939 = validateParameter(valid_615939, JString, required = false,
                                 default = nil)
  if valid_615939 != nil:
    section.add "X-Amz-Algorithm", valid_615939
  var valid_615940 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_615940 = validateParameter(valid_615940, JString, required = false,
                                 default = nil)
  if valid_615940 != nil:
    section.add "X-Amz-SignedHeaders", valid_615940
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : A unique identifier for the cluster.
  ##   DeferMaintenanceStartTime: JString
  ##                            : A timestamp indicating the start time for the deferred maintenance window.
  ##   DeferMaintenance: JBool
  ##                   : A boolean indicating whether to enable the deferred maintenance window. 
  ##   DeferMaintenanceDuration: JInt
  ##                           : An integer indicating the duration of the maintenance window in days. If you specify a duration, you can't specify an end time. The duration must be 45 days or less.
  ##   DeferMaintenanceEndTime: JString
  ##                          : A timestamp indicating end time for the deferred maintenance window. If you specify an end time, you can't specify a duration.
  ##   DeferMaintenanceIdentifier: JString
  ##                             : A unique identifier for the deferred maintenance window.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_615941 = formData.getOrDefault("ClusterIdentifier")
  valid_615941 = validateParameter(valid_615941, JString, required = true,
                                 default = nil)
  if valid_615941 != nil:
    section.add "ClusterIdentifier", valid_615941
  var valid_615942 = formData.getOrDefault("DeferMaintenanceStartTime")
  valid_615942 = validateParameter(valid_615942, JString, required = false,
                                 default = nil)
  if valid_615942 != nil:
    section.add "DeferMaintenanceStartTime", valid_615942
  var valid_615943 = formData.getOrDefault("DeferMaintenance")
  valid_615943 = validateParameter(valid_615943, JBool, required = false, default = nil)
  if valid_615943 != nil:
    section.add "DeferMaintenance", valid_615943
  var valid_615944 = formData.getOrDefault("DeferMaintenanceDuration")
  valid_615944 = validateParameter(valid_615944, JInt, required = false, default = nil)
  if valid_615944 != nil:
    section.add "DeferMaintenanceDuration", valid_615944
  var valid_615945 = formData.getOrDefault("DeferMaintenanceEndTime")
  valid_615945 = validateParameter(valid_615945, JString, required = false,
                                 default = nil)
  if valid_615945 != nil:
    section.add "DeferMaintenanceEndTime", valid_615945
  var valid_615946 = formData.getOrDefault("DeferMaintenanceIdentifier")
  valid_615946 = validateParameter(valid_615946, JString, required = false,
                                 default = nil)
  if valid_615946 != nil:
    section.add "DeferMaintenanceIdentifier", valid_615946
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_615947: Call_PostModifyClusterMaintenance_615929; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Modifies the maintenance settings of a cluster.
  ## 
  let valid = call_615947.validator(path, query, header, formData, body)
  let scheme = call_615947.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_615947.url(scheme.get, call_615947.host, call_615947.base,
                         call_615947.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_615947, url, valid)

proc call*(call_615948: Call_PostModifyClusterMaintenance_615929;
          ClusterIdentifier: string; DeferMaintenanceStartTime: string = "";
          DeferMaintenance: bool = false; DeferMaintenanceDuration: int = 0;
          DeferMaintenanceEndTime: string = "";
          Action: string = "ModifyClusterMaintenance";
          DeferMaintenanceIdentifier: string = ""; Version: string = "2012-12-01"): Recallable =
  ## postModifyClusterMaintenance
  ## Modifies the maintenance settings of a cluster.
  ##   ClusterIdentifier: string (required)
  ##                    : A unique identifier for the cluster.
  ##   DeferMaintenanceStartTime: string
  ##                            : A timestamp indicating the start time for the deferred maintenance window.
  ##   DeferMaintenance: bool
  ##                   : A boolean indicating whether to enable the deferred maintenance window. 
  ##   DeferMaintenanceDuration: int
  ##                           : An integer indicating the duration of the maintenance window in days. If you specify a duration, you can't specify an end time. The duration must be 45 days or less.
  ##   DeferMaintenanceEndTime: string
  ##                          : A timestamp indicating end time for the deferred maintenance window. If you specify an end time, you can't specify a duration.
  ##   Action: string (required)
  ##   DeferMaintenanceIdentifier: string
  ##                             : A unique identifier for the deferred maintenance window.
  ##   Version: string (required)
  var query_615949 = newJObject()
  var formData_615950 = newJObject()
  add(formData_615950, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_615950, "DeferMaintenanceStartTime",
      newJString(DeferMaintenanceStartTime))
  add(formData_615950, "DeferMaintenance", newJBool(DeferMaintenance))
  add(formData_615950, "DeferMaintenanceDuration",
      newJInt(DeferMaintenanceDuration))
  add(formData_615950, "DeferMaintenanceEndTime",
      newJString(DeferMaintenanceEndTime))
  add(query_615949, "Action", newJString(Action))
  add(formData_615950, "DeferMaintenanceIdentifier",
      newJString(DeferMaintenanceIdentifier))
  add(query_615949, "Version", newJString(Version))
  result = call_615948.call(nil, query_615949, nil, formData_615950, nil)

var postModifyClusterMaintenance* = Call_PostModifyClusterMaintenance_615929(
    name: "postModifyClusterMaintenance", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyClusterMaintenance",
    validator: validate_PostModifyClusterMaintenance_615930, base: "/",
    url: url_PostModifyClusterMaintenance_615931,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetModifyClusterMaintenance_615908 = ref object of OpenApiRestCall_612642
proc url_GetModifyClusterMaintenance_615910(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetModifyClusterMaintenance_615909(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies the maintenance settings of a cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   DeferMaintenanceDuration: JInt
  ##                           : An integer indicating the duration of the maintenance window in days. If you specify a duration, you can't specify an end time. The duration must be 45 days or less.
  ##   DeferMaintenanceIdentifier: JString
  ##                             : A unique identifier for the deferred maintenance window.
  ##   DeferMaintenanceEndTime: JString
  ##                          : A timestamp indicating end time for the deferred maintenance window. If you specify an end time, you can't specify a duration.
  ##   Action: JString (required)
  ##   DeferMaintenance: JBool
  ##                   : A boolean indicating whether to enable the deferred maintenance window. 
  ##   ClusterIdentifier: JString (required)
  ##                    : A unique identifier for the cluster.
  ##   Version: JString (required)
  ##   DeferMaintenanceStartTime: JString
  ##                            : A timestamp indicating the start time for the deferred maintenance window.
  section = newJObject()
  var valid_615911 = query.getOrDefault("DeferMaintenanceDuration")
  valid_615911 = validateParameter(valid_615911, JInt, required = false, default = nil)
  if valid_615911 != nil:
    section.add "DeferMaintenanceDuration", valid_615911
  var valid_615912 = query.getOrDefault("DeferMaintenanceIdentifier")
  valid_615912 = validateParameter(valid_615912, JString, required = false,
                                 default = nil)
  if valid_615912 != nil:
    section.add "DeferMaintenanceIdentifier", valid_615912
  var valid_615913 = query.getOrDefault("DeferMaintenanceEndTime")
  valid_615913 = validateParameter(valid_615913, JString, required = false,
                                 default = nil)
  if valid_615913 != nil:
    section.add "DeferMaintenanceEndTime", valid_615913
  var valid_615914 = query.getOrDefault("Action")
  valid_615914 = validateParameter(valid_615914, JString, required = true, default = newJString(
      "ModifyClusterMaintenance"))
  if valid_615914 != nil:
    section.add "Action", valid_615914
  var valid_615915 = query.getOrDefault("DeferMaintenance")
  valid_615915 = validateParameter(valid_615915, JBool, required = false, default = nil)
  if valid_615915 != nil:
    section.add "DeferMaintenance", valid_615915
  var valid_615916 = query.getOrDefault("ClusterIdentifier")
  valid_615916 = validateParameter(valid_615916, JString, required = true,
                                 default = nil)
  if valid_615916 != nil:
    section.add "ClusterIdentifier", valid_615916
  var valid_615917 = query.getOrDefault("Version")
  valid_615917 = validateParameter(valid_615917, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_615917 != nil:
    section.add "Version", valid_615917
  var valid_615918 = query.getOrDefault("DeferMaintenanceStartTime")
  valid_615918 = validateParameter(valid_615918, JString, required = false,
                                 default = nil)
  if valid_615918 != nil:
    section.add "DeferMaintenanceStartTime", valid_615918
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_615919 = header.getOrDefault("X-Amz-Signature")
  valid_615919 = validateParameter(valid_615919, JString, required = false,
                                 default = nil)
  if valid_615919 != nil:
    section.add "X-Amz-Signature", valid_615919
  var valid_615920 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_615920 = validateParameter(valid_615920, JString, required = false,
                                 default = nil)
  if valid_615920 != nil:
    section.add "X-Amz-Content-Sha256", valid_615920
  var valid_615921 = header.getOrDefault("X-Amz-Date")
  valid_615921 = validateParameter(valid_615921, JString, required = false,
                                 default = nil)
  if valid_615921 != nil:
    section.add "X-Amz-Date", valid_615921
  var valid_615922 = header.getOrDefault("X-Amz-Credential")
  valid_615922 = validateParameter(valid_615922, JString, required = false,
                                 default = nil)
  if valid_615922 != nil:
    section.add "X-Amz-Credential", valid_615922
  var valid_615923 = header.getOrDefault("X-Amz-Security-Token")
  valid_615923 = validateParameter(valid_615923, JString, required = false,
                                 default = nil)
  if valid_615923 != nil:
    section.add "X-Amz-Security-Token", valid_615923
  var valid_615924 = header.getOrDefault("X-Amz-Algorithm")
  valid_615924 = validateParameter(valid_615924, JString, required = false,
                                 default = nil)
  if valid_615924 != nil:
    section.add "X-Amz-Algorithm", valid_615924
  var valid_615925 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_615925 = validateParameter(valid_615925, JString, required = false,
                                 default = nil)
  if valid_615925 != nil:
    section.add "X-Amz-SignedHeaders", valid_615925
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_615926: Call_GetModifyClusterMaintenance_615908; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Modifies the maintenance settings of a cluster.
  ## 
  let valid = call_615926.validator(path, query, header, formData, body)
  let scheme = call_615926.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_615926.url(scheme.get, call_615926.host, call_615926.base,
                         call_615926.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_615926, url, valid)

proc call*(call_615927: Call_GetModifyClusterMaintenance_615908;
          ClusterIdentifier: string; DeferMaintenanceDuration: int = 0;
          DeferMaintenanceIdentifier: string = "";
          DeferMaintenanceEndTime: string = "";
          Action: string = "ModifyClusterMaintenance";
          DeferMaintenance: bool = false; Version: string = "2012-12-01";
          DeferMaintenanceStartTime: string = ""): Recallable =
  ## getModifyClusterMaintenance
  ## Modifies the maintenance settings of a cluster.
  ##   DeferMaintenanceDuration: int
  ##                           : An integer indicating the duration of the maintenance window in days. If you specify a duration, you can't specify an end time. The duration must be 45 days or less.
  ##   DeferMaintenanceIdentifier: string
  ##                             : A unique identifier for the deferred maintenance window.
  ##   DeferMaintenanceEndTime: string
  ##                          : A timestamp indicating end time for the deferred maintenance window. If you specify an end time, you can't specify a duration.
  ##   Action: string (required)
  ##   DeferMaintenance: bool
  ##                   : A boolean indicating whether to enable the deferred maintenance window. 
  ##   ClusterIdentifier: string (required)
  ##                    : A unique identifier for the cluster.
  ##   Version: string (required)
  ##   DeferMaintenanceStartTime: string
  ##                            : A timestamp indicating the start time for the deferred maintenance window.
  var query_615928 = newJObject()
  add(query_615928, "DeferMaintenanceDuration", newJInt(DeferMaintenanceDuration))
  add(query_615928, "DeferMaintenanceIdentifier",
      newJString(DeferMaintenanceIdentifier))
  add(query_615928, "DeferMaintenanceEndTime", newJString(DeferMaintenanceEndTime))
  add(query_615928, "Action", newJString(Action))
  add(query_615928, "DeferMaintenance", newJBool(DeferMaintenance))
  add(query_615928, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_615928, "Version", newJString(Version))
  add(query_615928, "DeferMaintenanceStartTime",
      newJString(DeferMaintenanceStartTime))
  result = call_615927.call(nil, query_615928, nil, nil, nil)

var getModifyClusterMaintenance* = Call_GetModifyClusterMaintenance_615908(
    name: "getModifyClusterMaintenance", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyClusterMaintenance",
    validator: validate_GetModifyClusterMaintenance_615909, base: "/",
    url: url_GetModifyClusterMaintenance_615910,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostModifyClusterParameterGroup_615968 = ref object of OpenApiRestCall_612642
proc url_PostModifyClusterParameterGroup_615970(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostModifyClusterParameterGroup_615969(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Modifies the parameters of a parameter group.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_615971 = query.getOrDefault("Action")
  valid_615971 = validateParameter(valid_615971, JString, required = true, default = newJString(
      "ModifyClusterParameterGroup"))
  if valid_615971 != nil:
    section.add "Action", valid_615971
  var valid_615972 = query.getOrDefault("Version")
  valid_615972 = validateParameter(valid_615972, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_615972 != nil:
    section.add "Version", valid_615972
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_615973 = header.getOrDefault("X-Amz-Signature")
  valid_615973 = validateParameter(valid_615973, JString, required = false,
                                 default = nil)
  if valid_615973 != nil:
    section.add "X-Amz-Signature", valid_615973
  var valid_615974 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_615974 = validateParameter(valid_615974, JString, required = false,
                                 default = nil)
  if valid_615974 != nil:
    section.add "X-Amz-Content-Sha256", valid_615974
  var valid_615975 = header.getOrDefault("X-Amz-Date")
  valid_615975 = validateParameter(valid_615975, JString, required = false,
                                 default = nil)
  if valid_615975 != nil:
    section.add "X-Amz-Date", valid_615975
  var valid_615976 = header.getOrDefault("X-Amz-Credential")
  valid_615976 = validateParameter(valid_615976, JString, required = false,
                                 default = nil)
  if valid_615976 != nil:
    section.add "X-Amz-Credential", valid_615976
  var valid_615977 = header.getOrDefault("X-Amz-Security-Token")
  valid_615977 = validateParameter(valid_615977, JString, required = false,
                                 default = nil)
  if valid_615977 != nil:
    section.add "X-Amz-Security-Token", valid_615977
  var valid_615978 = header.getOrDefault("X-Amz-Algorithm")
  valid_615978 = validateParameter(valid_615978, JString, required = false,
                                 default = nil)
  if valid_615978 != nil:
    section.add "X-Amz-Algorithm", valid_615978
  var valid_615979 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_615979 = validateParameter(valid_615979, JString, required = false,
                                 default = nil)
  if valid_615979 != nil:
    section.add "X-Amz-SignedHeaders", valid_615979
  result.add "header", section
  ## parameters in `formData` object:
  ##   Parameters: JArray (required)
  ##             : <p>An array of parameters to be modified. A maximum of 20 parameters can be modified in a single request.</p> <p>For each parameter to be modified, you must supply at least the parameter name and parameter value; other name-value pairs of the parameter are optional.</p> <p>For the workload management (WLM) configuration, you must supply all the name-value pairs in the wlm_json_configuration parameter.</p>
  ##   ParameterGroupName: JString (required)
  ##                     : The name of the parameter group to be modified.
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `Parameters` field"
  var valid_615980 = formData.getOrDefault("Parameters")
  valid_615980 = validateParameter(valid_615980, JArray, required = true, default = nil)
  if valid_615980 != nil:
    section.add "Parameters", valid_615980
  var valid_615981 = formData.getOrDefault("ParameterGroupName")
  valid_615981 = validateParameter(valid_615981, JString, required = true,
                                 default = nil)
  if valid_615981 != nil:
    section.add "ParameterGroupName", valid_615981
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_615982: Call_PostModifyClusterParameterGroup_615968;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Modifies the parameters of a parameter group.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_615982.validator(path, query, header, formData, body)
  let scheme = call_615982.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_615982.url(scheme.get, call_615982.host, call_615982.base,
                         call_615982.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_615982, url, valid)

proc call*(call_615983: Call_PostModifyClusterParameterGroup_615968;
          Parameters: JsonNode; ParameterGroupName: string;
          Action: string = "ModifyClusterParameterGroup";
          Version: string = "2012-12-01"): Recallable =
  ## postModifyClusterParameterGroup
  ## <p>Modifies the parameters of a parameter group.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   Action: string (required)
  ##   Parameters: JArray (required)
  ##             : <p>An array of parameters to be modified. A maximum of 20 parameters can be modified in a single request.</p> <p>For each parameter to be modified, you must supply at least the parameter name and parameter value; other name-value pairs of the parameter are optional.</p> <p>For the workload management (WLM) configuration, you must supply all the name-value pairs in the wlm_json_configuration parameter.</p>
  ##   ParameterGroupName: string (required)
  ##                     : The name of the parameter group to be modified.
  ##   Version: string (required)
  var query_615984 = newJObject()
  var formData_615985 = newJObject()
  add(query_615984, "Action", newJString(Action))
  if Parameters != nil:
    formData_615985.add "Parameters", Parameters
  add(formData_615985, "ParameterGroupName", newJString(ParameterGroupName))
  add(query_615984, "Version", newJString(Version))
  result = call_615983.call(nil, query_615984, nil, formData_615985, nil)

var postModifyClusterParameterGroup* = Call_PostModifyClusterParameterGroup_615968(
    name: "postModifyClusterParameterGroup", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyClusterParameterGroup",
    validator: validate_PostModifyClusterParameterGroup_615969, base: "/",
    url: url_PostModifyClusterParameterGroup_615970,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetModifyClusterParameterGroup_615951 = ref object of OpenApiRestCall_612642
proc url_GetModifyClusterParameterGroup_615953(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetModifyClusterParameterGroup_615952(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Modifies the parameters of a parameter group.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Parameters: JArray (required)
  ##             : <p>An array of parameters to be modified. A maximum of 20 parameters can be modified in a single request.</p> <p>For each parameter to be modified, you must supply at least the parameter name and parameter value; other name-value pairs of the parameter are optional.</p> <p>For the workload management (WLM) configuration, you must supply all the name-value pairs in the wlm_json_configuration parameter.</p>
  ##   Action: JString (required)
  ##   ParameterGroupName: JString (required)
  ##                     : The name of the parameter group to be modified.
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `Parameters` field"
  var valid_615954 = query.getOrDefault("Parameters")
  valid_615954 = validateParameter(valid_615954, JArray, required = true, default = nil)
  if valid_615954 != nil:
    section.add "Parameters", valid_615954
  var valid_615955 = query.getOrDefault("Action")
  valid_615955 = validateParameter(valid_615955, JString, required = true, default = newJString(
      "ModifyClusterParameterGroup"))
  if valid_615955 != nil:
    section.add "Action", valid_615955
  var valid_615956 = query.getOrDefault("ParameterGroupName")
  valid_615956 = validateParameter(valid_615956, JString, required = true,
                                 default = nil)
  if valid_615956 != nil:
    section.add "ParameterGroupName", valid_615956
  var valid_615957 = query.getOrDefault("Version")
  valid_615957 = validateParameter(valid_615957, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_615957 != nil:
    section.add "Version", valid_615957
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_615958 = header.getOrDefault("X-Amz-Signature")
  valid_615958 = validateParameter(valid_615958, JString, required = false,
                                 default = nil)
  if valid_615958 != nil:
    section.add "X-Amz-Signature", valid_615958
  var valid_615959 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_615959 = validateParameter(valid_615959, JString, required = false,
                                 default = nil)
  if valid_615959 != nil:
    section.add "X-Amz-Content-Sha256", valid_615959
  var valid_615960 = header.getOrDefault("X-Amz-Date")
  valid_615960 = validateParameter(valid_615960, JString, required = false,
                                 default = nil)
  if valid_615960 != nil:
    section.add "X-Amz-Date", valid_615960
  var valid_615961 = header.getOrDefault("X-Amz-Credential")
  valid_615961 = validateParameter(valid_615961, JString, required = false,
                                 default = nil)
  if valid_615961 != nil:
    section.add "X-Amz-Credential", valid_615961
  var valid_615962 = header.getOrDefault("X-Amz-Security-Token")
  valid_615962 = validateParameter(valid_615962, JString, required = false,
                                 default = nil)
  if valid_615962 != nil:
    section.add "X-Amz-Security-Token", valid_615962
  var valid_615963 = header.getOrDefault("X-Amz-Algorithm")
  valid_615963 = validateParameter(valid_615963, JString, required = false,
                                 default = nil)
  if valid_615963 != nil:
    section.add "X-Amz-Algorithm", valid_615963
  var valid_615964 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_615964 = validateParameter(valid_615964, JString, required = false,
                                 default = nil)
  if valid_615964 != nil:
    section.add "X-Amz-SignedHeaders", valid_615964
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_615965: Call_GetModifyClusterParameterGroup_615951; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Modifies the parameters of a parameter group.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_615965.validator(path, query, header, formData, body)
  let scheme = call_615965.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_615965.url(scheme.get, call_615965.host, call_615965.base,
                         call_615965.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_615965, url, valid)

proc call*(call_615966: Call_GetModifyClusterParameterGroup_615951;
          Parameters: JsonNode; ParameterGroupName: string;
          Action: string = "ModifyClusterParameterGroup";
          Version: string = "2012-12-01"): Recallable =
  ## getModifyClusterParameterGroup
  ## <p>Modifies the parameters of a parameter group.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   Parameters: JArray (required)
  ##             : <p>An array of parameters to be modified. A maximum of 20 parameters can be modified in a single request.</p> <p>For each parameter to be modified, you must supply at least the parameter name and parameter value; other name-value pairs of the parameter are optional.</p> <p>For the workload management (WLM) configuration, you must supply all the name-value pairs in the wlm_json_configuration parameter.</p>
  ##   Action: string (required)
  ##   ParameterGroupName: string (required)
  ##                     : The name of the parameter group to be modified.
  ##   Version: string (required)
  var query_615967 = newJObject()
  if Parameters != nil:
    query_615967.add "Parameters", Parameters
  add(query_615967, "Action", newJString(Action))
  add(query_615967, "ParameterGroupName", newJString(ParameterGroupName))
  add(query_615967, "Version", newJString(Version))
  result = call_615966.call(nil, query_615967, nil, nil, nil)

var getModifyClusterParameterGroup* = Call_GetModifyClusterParameterGroup_615951(
    name: "getModifyClusterParameterGroup", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyClusterParameterGroup",
    validator: validate_GetModifyClusterParameterGroup_615952, base: "/",
    url: url_GetModifyClusterParameterGroup_615953,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostModifyClusterSnapshot_616004 = ref object of OpenApiRestCall_612642
proc url_PostModifyClusterSnapshot_616006(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostModifyClusterSnapshot_616005(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Modifies the settings for a snapshot.</p> <p>This exanmple modifies the manual retention period setting for a cluster snapshot.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_616007 = query.getOrDefault("Action")
  valid_616007 = validateParameter(valid_616007, JString, required = true,
                                 default = newJString("ModifyClusterSnapshot"))
  if valid_616007 != nil:
    section.add "Action", valid_616007
  var valid_616008 = query.getOrDefault("Version")
  valid_616008 = validateParameter(valid_616008, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_616008 != nil:
    section.add "Version", valid_616008
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_616009 = header.getOrDefault("X-Amz-Signature")
  valid_616009 = validateParameter(valid_616009, JString, required = false,
                                 default = nil)
  if valid_616009 != nil:
    section.add "X-Amz-Signature", valid_616009
  var valid_616010 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_616010 = validateParameter(valid_616010, JString, required = false,
                                 default = nil)
  if valid_616010 != nil:
    section.add "X-Amz-Content-Sha256", valid_616010
  var valid_616011 = header.getOrDefault("X-Amz-Date")
  valid_616011 = validateParameter(valid_616011, JString, required = false,
                                 default = nil)
  if valid_616011 != nil:
    section.add "X-Amz-Date", valid_616011
  var valid_616012 = header.getOrDefault("X-Amz-Credential")
  valid_616012 = validateParameter(valid_616012, JString, required = false,
                                 default = nil)
  if valid_616012 != nil:
    section.add "X-Amz-Credential", valid_616012
  var valid_616013 = header.getOrDefault("X-Amz-Security-Token")
  valid_616013 = validateParameter(valid_616013, JString, required = false,
                                 default = nil)
  if valid_616013 != nil:
    section.add "X-Amz-Security-Token", valid_616013
  var valid_616014 = header.getOrDefault("X-Amz-Algorithm")
  valid_616014 = validateParameter(valid_616014, JString, required = false,
                                 default = nil)
  if valid_616014 != nil:
    section.add "X-Amz-Algorithm", valid_616014
  var valid_616015 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_616015 = validateParameter(valid_616015, JString, required = false,
                                 default = nil)
  if valid_616015 != nil:
    section.add "X-Amz-SignedHeaders", valid_616015
  result.add "header", section
  ## parameters in `formData` object:
  ##   Force: JBool
  ##        : A Boolean option to override an exception if the retention period has already passed.
  ##   SnapshotIdentifier: JString (required)
  ##                     : The identifier of the snapshot whose setting you want to modify.
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely.</p> <p>If the manual snapshot falls outside of the new retention period, you can specify the force option to immediately delete the snapshot.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  section = newJObject()
  var valid_616016 = formData.getOrDefault("Force")
  valid_616016 = validateParameter(valid_616016, JBool, required = false, default = nil)
  if valid_616016 != nil:
    section.add "Force", valid_616016
  assert formData != nil, "formData argument is necessary due to required `SnapshotIdentifier` field"
  var valid_616017 = formData.getOrDefault("SnapshotIdentifier")
  valid_616017 = validateParameter(valid_616017, JString, required = true,
                                 default = nil)
  if valid_616017 != nil:
    section.add "SnapshotIdentifier", valid_616017
  var valid_616018 = formData.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_616018 = validateParameter(valid_616018, JInt, required = false, default = nil)
  if valid_616018 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_616018
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_616019: Call_PostModifyClusterSnapshot_616004; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Modifies the settings for a snapshot.</p> <p>This exanmple modifies the manual retention period setting for a cluster snapshot.</p>
  ## 
  let valid = call_616019.validator(path, query, header, formData, body)
  let scheme = call_616019.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_616019.url(scheme.get, call_616019.host, call_616019.base,
                         call_616019.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_616019, url, valid)

proc call*(call_616020: Call_PostModifyClusterSnapshot_616004;
          SnapshotIdentifier: string; Force: bool = false;
          Action: string = "ModifyClusterSnapshot"; Version: string = "2012-12-01";
          ManualSnapshotRetentionPeriod: int = 0): Recallable =
  ## postModifyClusterSnapshot
  ## <p>Modifies the settings for a snapshot.</p> <p>This exanmple modifies the manual retention period setting for a cluster snapshot.</p>
  ##   Force: bool
  ##        : A Boolean option to override an exception if the retention period has already passed.
  ##   SnapshotIdentifier: string (required)
  ##                     : The identifier of the snapshot whose setting you want to modify.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely.</p> <p>If the manual snapshot falls outside of the new retention period, you can specify the force option to immediately delete the snapshot.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  var query_616021 = newJObject()
  var formData_616022 = newJObject()
  add(formData_616022, "Force", newJBool(Force))
  add(formData_616022, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_616021, "Action", newJString(Action))
  add(query_616021, "Version", newJString(Version))
  add(formData_616022, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  result = call_616020.call(nil, query_616021, nil, formData_616022, nil)

var postModifyClusterSnapshot* = Call_PostModifyClusterSnapshot_616004(
    name: "postModifyClusterSnapshot", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyClusterSnapshot",
    validator: validate_PostModifyClusterSnapshot_616005, base: "/",
    url: url_PostModifyClusterSnapshot_616006,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetModifyClusterSnapshot_615986 = ref object of OpenApiRestCall_612642
proc url_GetModifyClusterSnapshot_615988(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetModifyClusterSnapshot_615987(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Modifies the settings for a snapshot.</p> <p>This exanmple modifies the manual retention period setting for a cluster snapshot.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   SnapshotIdentifier: JString (required)
  ##                     : The identifier of the snapshot whose setting you want to modify.
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely.</p> <p>If the manual snapshot falls outside of the new retention period, you can specify the force option to immediately delete the snapshot.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  ##   Force: JBool
  ##        : A Boolean option to override an exception if the retention period has already passed.
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `SnapshotIdentifier` field"
  var valid_615989 = query.getOrDefault("SnapshotIdentifier")
  valid_615989 = validateParameter(valid_615989, JString, required = true,
                                 default = nil)
  if valid_615989 != nil:
    section.add "SnapshotIdentifier", valid_615989
  var valid_615990 = query.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_615990 = validateParameter(valid_615990, JInt, required = false, default = nil)
  if valid_615990 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_615990
  var valid_615991 = query.getOrDefault("Force")
  valid_615991 = validateParameter(valid_615991, JBool, required = false, default = nil)
  if valid_615991 != nil:
    section.add "Force", valid_615991
  var valid_615992 = query.getOrDefault("Action")
  valid_615992 = validateParameter(valid_615992, JString, required = true,
                                 default = newJString("ModifyClusterSnapshot"))
  if valid_615992 != nil:
    section.add "Action", valid_615992
  var valid_615993 = query.getOrDefault("Version")
  valid_615993 = validateParameter(valid_615993, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_615993 != nil:
    section.add "Version", valid_615993
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_615994 = header.getOrDefault("X-Amz-Signature")
  valid_615994 = validateParameter(valid_615994, JString, required = false,
                                 default = nil)
  if valid_615994 != nil:
    section.add "X-Amz-Signature", valid_615994
  var valid_615995 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_615995 = validateParameter(valid_615995, JString, required = false,
                                 default = nil)
  if valid_615995 != nil:
    section.add "X-Amz-Content-Sha256", valid_615995
  var valid_615996 = header.getOrDefault("X-Amz-Date")
  valid_615996 = validateParameter(valid_615996, JString, required = false,
                                 default = nil)
  if valid_615996 != nil:
    section.add "X-Amz-Date", valid_615996
  var valid_615997 = header.getOrDefault("X-Amz-Credential")
  valid_615997 = validateParameter(valid_615997, JString, required = false,
                                 default = nil)
  if valid_615997 != nil:
    section.add "X-Amz-Credential", valid_615997
  var valid_615998 = header.getOrDefault("X-Amz-Security-Token")
  valid_615998 = validateParameter(valid_615998, JString, required = false,
                                 default = nil)
  if valid_615998 != nil:
    section.add "X-Amz-Security-Token", valid_615998
  var valid_615999 = header.getOrDefault("X-Amz-Algorithm")
  valid_615999 = validateParameter(valid_615999, JString, required = false,
                                 default = nil)
  if valid_615999 != nil:
    section.add "X-Amz-Algorithm", valid_615999
  var valid_616000 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_616000 = validateParameter(valid_616000, JString, required = false,
                                 default = nil)
  if valid_616000 != nil:
    section.add "X-Amz-SignedHeaders", valid_616000
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_616001: Call_GetModifyClusterSnapshot_615986; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Modifies the settings for a snapshot.</p> <p>This exanmple modifies the manual retention period setting for a cluster snapshot.</p>
  ## 
  let valid = call_616001.validator(path, query, header, formData, body)
  let scheme = call_616001.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_616001.url(scheme.get, call_616001.host, call_616001.base,
                         call_616001.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_616001, url, valid)

proc call*(call_616002: Call_GetModifyClusterSnapshot_615986;
          SnapshotIdentifier: string; ManualSnapshotRetentionPeriod: int = 0;
          Force: bool = false; Action: string = "ModifyClusterSnapshot";
          Version: string = "2012-12-01"): Recallable =
  ## getModifyClusterSnapshot
  ## <p>Modifies the settings for a snapshot.</p> <p>This exanmple modifies the manual retention period setting for a cluster snapshot.</p>
  ##   SnapshotIdentifier: string (required)
  ##                     : The identifier of the snapshot whose setting you want to modify.
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely.</p> <p>If the manual snapshot falls outside of the new retention period, you can specify the force option to immediately delete the snapshot.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  ##   Force: bool
  ##        : A Boolean option to override an exception if the retention period has already passed.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_616003 = newJObject()
  add(query_616003, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_616003, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  add(query_616003, "Force", newJBool(Force))
  add(query_616003, "Action", newJString(Action))
  add(query_616003, "Version", newJString(Version))
  result = call_616002.call(nil, query_616003, nil, nil, nil)

var getModifyClusterSnapshot* = Call_GetModifyClusterSnapshot_615986(
    name: "getModifyClusterSnapshot", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyClusterSnapshot",
    validator: validate_GetModifyClusterSnapshot_615987, base: "/",
    url: url_GetModifyClusterSnapshot_615988, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostModifyClusterSnapshotSchedule_616041 = ref object of OpenApiRestCall_612642
proc url_PostModifyClusterSnapshotSchedule_616043(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostModifyClusterSnapshotSchedule_616042(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies a snapshot schedule for a cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_616044 = query.getOrDefault("Action")
  valid_616044 = validateParameter(valid_616044, JString, required = true, default = newJString(
      "ModifyClusterSnapshotSchedule"))
  if valid_616044 != nil:
    section.add "Action", valid_616044
  var valid_616045 = query.getOrDefault("Version")
  valid_616045 = validateParameter(valid_616045, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_616045 != nil:
    section.add "Version", valid_616045
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_616046 = header.getOrDefault("X-Amz-Signature")
  valid_616046 = validateParameter(valid_616046, JString, required = false,
                                 default = nil)
  if valid_616046 != nil:
    section.add "X-Amz-Signature", valid_616046
  var valid_616047 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_616047 = validateParameter(valid_616047, JString, required = false,
                                 default = nil)
  if valid_616047 != nil:
    section.add "X-Amz-Content-Sha256", valid_616047
  var valid_616048 = header.getOrDefault("X-Amz-Date")
  valid_616048 = validateParameter(valid_616048, JString, required = false,
                                 default = nil)
  if valid_616048 != nil:
    section.add "X-Amz-Date", valid_616048
  var valid_616049 = header.getOrDefault("X-Amz-Credential")
  valid_616049 = validateParameter(valid_616049, JString, required = false,
                                 default = nil)
  if valid_616049 != nil:
    section.add "X-Amz-Credential", valid_616049
  var valid_616050 = header.getOrDefault("X-Amz-Security-Token")
  valid_616050 = validateParameter(valid_616050, JString, required = false,
                                 default = nil)
  if valid_616050 != nil:
    section.add "X-Amz-Security-Token", valid_616050
  var valid_616051 = header.getOrDefault("X-Amz-Algorithm")
  valid_616051 = validateParameter(valid_616051, JString, required = false,
                                 default = nil)
  if valid_616051 != nil:
    section.add "X-Amz-Algorithm", valid_616051
  var valid_616052 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_616052 = validateParameter(valid_616052, JString, required = false,
                                 default = nil)
  if valid_616052 != nil:
    section.add "X-Amz-SignedHeaders", valid_616052
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : A unique identifier for the cluster whose snapshot schedule you want to modify. 
  ##   ScheduleIdentifier: JString
  ##                     : A unique alphanumeric identifier for the schedule that you want to associate with the cluster.
  ##   DisassociateSchedule: JBool
  ##                       : A boolean to indicate whether to remove the assoiciation between the cluster and the schedule.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_616053 = formData.getOrDefault("ClusterIdentifier")
  valid_616053 = validateParameter(valid_616053, JString, required = true,
                                 default = nil)
  if valid_616053 != nil:
    section.add "ClusterIdentifier", valid_616053
  var valid_616054 = formData.getOrDefault("ScheduleIdentifier")
  valid_616054 = validateParameter(valid_616054, JString, required = false,
                                 default = nil)
  if valid_616054 != nil:
    section.add "ScheduleIdentifier", valid_616054
  var valid_616055 = formData.getOrDefault("DisassociateSchedule")
  valid_616055 = validateParameter(valid_616055, JBool, required = false, default = nil)
  if valid_616055 != nil:
    section.add "DisassociateSchedule", valid_616055
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_616056: Call_PostModifyClusterSnapshotSchedule_616041;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Modifies a snapshot schedule for a cluster.
  ## 
  let valid = call_616056.validator(path, query, header, formData, body)
  let scheme = call_616056.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_616056.url(scheme.get, call_616056.host, call_616056.base,
                         call_616056.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_616056, url, valid)

proc call*(call_616057: Call_PostModifyClusterSnapshotSchedule_616041;
          ClusterIdentifier: string;
          Action: string = "ModifyClusterSnapshotSchedule";
          ScheduleIdentifier: string = ""; DisassociateSchedule: bool = false;
          Version: string = "2012-12-01"): Recallable =
  ## postModifyClusterSnapshotSchedule
  ## Modifies a snapshot schedule for a cluster.
  ##   ClusterIdentifier: string (required)
  ##                    : A unique identifier for the cluster whose snapshot schedule you want to modify. 
  ##   Action: string (required)
  ##   ScheduleIdentifier: string
  ##                     : A unique alphanumeric identifier for the schedule that you want to associate with the cluster.
  ##   DisassociateSchedule: bool
  ##                       : A boolean to indicate whether to remove the assoiciation between the cluster and the schedule.
  ##   Version: string (required)
  var query_616058 = newJObject()
  var formData_616059 = newJObject()
  add(formData_616059, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_616058, "Action", newJString(Action))
  add(formData_616059, "ScheduleIdentifier", newJString(ScheduleIdentifier))
  add(formData_616059, "DisassociateSchedule", newJBool(DisassociateSchedule))
  add(query_616058, "Version", newJString(Version))
  result = call_616057.call(nil, query_616058, nil, formData_616059, nil)

var postModifyClusterSnapshotSchedule* = Call_PostModifyClusterSnapshotSchedule_616041(
    name: "postModifyClusterSnapshotSchedule", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=ModifyClusterSnapshotSchedule",
    validator: validate_PostModifyClusterSnapshotSchedule_616042, base: "/",
    url: url_PostModifyClusterSnapshotSchedule_616043,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetModifyClusterSnapshotSchedule_616023 = ref object of OpenApiRestCall_612642
proc url_GetModifyClusterSnapshotSchedule_616025(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetModifyClusterSnapshotSchedule_616024(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies a snapshot schedule for a cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ScheduleIdentifier: JString
  ##                     : A unique alphanumeric identifier for the schedule that you want to associate with the cluster.
  ##   Action: JString (required)
  ##   DisassociateSchedule: JBool
  ##                       : A boolean to indicate whether to remove the assoiciation between the cluster and the schedule.
  ##   ClusterIdentifier: JString (required)
  ##                    : A unique identifier for the cluster whose snapshot schedule you want to modify. 
  ##   Version: JString (required)
  section = newJObject()
  var valid_616026 = query.getOrDefault("ScheduleIdentifier")
  valid_616026 = validateParameter(valid_616026, JString, required = false,
                                 default = nil)
  if valid_616026 != nil:
    section.add "ScheduleIdentifier", valid_616026
  var valid_616027 = query.getOrDefault("Action")
  valid_616027 = validateParameter(valid_616027, JString, required = true, default = newJString(
      "ModifyClusterSnapshotSchedule"))
  if valid_616027 != nil:
    section.add "Action", valid_616027
  var valid_616028 = query.getOrDefault("DisassociateSchedule")
  valid_616028 = validateParameter(valid_616028, JBool, required = false, default = nil)
  if valid_616028 != nil:
    section.add "DisassociateSchedule", valid_616028
  var valid_616029 = query.getOrDefault("ClusterIdentifier")
  valid_616029 = validateParameter(valid_616029, JString, required = true,
                                 default = nil)
  if valid_616029 != nil:
    section.add "ClusterIdentifier", valid_616029
  var valid_616030 = query.getOrDefault("Version")
  valid_616030 = validateParameter(valid_616030, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_616030 != nil:
    section.add "Version", valid_616030
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_616031 = header.getOrDefault("X-Amz-Signature")
  valid_616031 = validateParameter(valid_616031, JString, required = false,
                                 default = nil)
  if valid_616031 != nil:
    section.add "X-Amz-Signature", valid_616031
  var valid_616032 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_616032 = validateParameter(valid_616032, JString, required = false,
                                 default = nil)
  if valid_616032 != nil:
    section.add "X-Amz-Content-Sha256", valid_616032
  var valid_616033 = header.getOrDefault("X-Amz-Date")
  valid_616033 = validateParameter(valid_616033, JString, required = false,
                                 default = nil)
  if valid_616033 != nil:
    section.add "X-Amz-Date", valid_616033
  var valid_616034 = header.getOrDefault("X-Amz-Credential")
  valid_616034 = validateParameter(valid_616034, JString, required = false,
                                 default = nil)
  if valid_616034 != nil:
    section.add "X-Amz-Credential", valid_616034
  var valid_616035 = header.getOrDefault("X-Amz-Security-Token")
  valid_616035 = validateParameter(valid_616035, JString, required = false,
                                 default = nil)
  if valid_616035 != nil:
    section.add "X-Amz-Security-Token", valid_616035
  var valid_616036 = header.getOrDefault("X-Amz-Algorithm")
  valid_616036 = validateParameter(valid_616036, JString, required = false,
                                 default = nil)
  if valid_616036 != nil:
    section.add "X-Amz-Algorithm", valid_616036
  var valid_616037 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_616037 = validateParameter(valid_616037, JString, required = false,
                                 default = nil)
  if valid_616037 != nil:
    section.add "X-Amz-SignedHeaders", valid_616037
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_616038: Call_GetModifyClusterSnapshotSchedule_616023;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Modifies a snapshot schedule for a cluster.
  ## 
  let valid = call_616038.validator(path, query, header, formData, body)
  let scheme = call_616038.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_616038.url(scheme.get, call_616038.host, call_616038.base,
                         call_616038.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_616038, url, valid)

proc call*(call_616039: Call_GetModifyClusterSnapshotSchedule_616023;
          ClusterIdentifier: string; ScheduleIdentifier: string = "";
          Action: string = "ModifyClusterSnapshotSchedule";
          DisassociateSchedule: bool = false; Version: string = "2012-12-01"): Recallable =
  ## getModifyClusterSnapshotSchedule
  ## Modifies a snapshot schedule for a cluster.
  ##   ScheduleIdentifier: string
  ##                     : A unique alphanumeric identifier for the schedule that you want to associate with the cluster.
  ##   Action: string (required)
  ##   DisassociateSchedule: bool
  ##                       : A boolean to indicate whether to remove the assoiciation between the cluster and the schedule.
  ##   ClusterIdentifier: string (required)
  ##                    : A unique identifier for the cluster whose snapshot schedule you want to modify. 
  ##   Version: string (required)
  var query_616040 = newJObject()
  add(query_616040, "ScheduleIdentifier", newJString(ScheduleIdentifier))
  add(query_616040, "Action", newJString(Action))
  add(query_616040, "DisassociateSchedule", newJBool(DisassociateSchedule))
  add(query_616040, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_616040, "Version", newJString(Version))
  result = call_616039.call(nil, query_616040, nil, nil, nil)

var getModifyClusterSnapshotSchedule* = Call_GetModifyClusterSnapshotSchedule_616023(
    name: "getModifyClusterSnapshotSchedule", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=ModifyClusterSnapshotSchedule",
    validator: validate_GetModifyClusterSnapshotSchedule_616024, base: "/",
    url: url_GetModifyClusterSnapshotSchedule_616025,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostModifyClusterSubnetGroup_616078 = ref object of OpenApiRestCall_612642
proc url_PostModifyClusterSubnetGroup_616080(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostModifyClusterSubnetGroup_616079(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies a cluster subnet group to include the specified list of VPC subnets. The operation replaces the existing list of subnets with the new list of subnets.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_616081 = query.getOrDefault("Action")
  valid_616081 = validateParameter(valid_616081, JString, required = true, default = newJString(
      "ModifyClusterSubnetGroup"))
  if valid_616081 != nil:
    section.add "Action", valid_616081
  var valid_616082 = query.getOrDefault("Version")
  valid_616082 = validateParameter(valid_616082, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_616082 != nil:
    section.add "Version", valid_616082
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_616083 = header.getOrDefault("X-Amz-Signature")
  valid_616083 = validateParameter(valid_616083, JString, required = false,
                                 default = nil)
  if valid_616083 != nil:
    section.add "X-Amz-Signature", valid_616083
  var valid_616084 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_616084 = validateParameter(valid_616084, JString, required = false,
                                 default = nil)
  if valid_616084 != nil:
    section.add "X-Amz-Content-Sha256", valid_616084
  var valid_616085 = header.getOrDefault("X-Amz-Date")
  valid_616085 = validateParameter(valid_616085, JString, required = false,
                                 default = nil)
  if valid_616085 != nil:
    section.add "X-Amz-Date", valid_616085
  var valid_616086 = header.getOrDefault("X-Amz-Credential")
  valid_616086 = validateParameter(valid_616086, JString, required = false,
                                 default = nil)
  if valid_616086 != nil:
    section.add "X-Amz-Credential", valid_616086
  var valid_616087 = header.getOrDefault("X-Amz-Security-Token")
  valid_616087 = validateParameter(valid_616087, JString, required = false,
                                 default = nil)
  if valid_616087 != nil:
    section.add "X-Amz-Security-Token", valid_616087
  var valid_616088 = header.getOrDefault("X-Amz-Algorithm")
  valid_616088 = validateParameter(valid_616088, JString, required = false,
                                 default = nil)
  if valid_616088 != nil:
    section.add "X-Amz-Algorithm", valid_616088
  var valid_616089 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_616089 = validateParameter(valid_616089, JString, required = false,
                                 default = nil)
  if valid_616089 != nil:
    section.add "X-Amz-SignedHeaders", valid_616089
  result.add "header", section
  ## parameters in `formData` object:
  ##   Description: JString
  ##              : A text description of the subnet group to be modified.
  ##   ClusterSubnetGroupName: JString (required)
  ##                         : The name of the subnet group to be modified.
  ##   SubnetIds: JArray (required)
  ##            : An array of VPC subnet IDs. A maximum of 20 subnets can be modified in a single request.
  section = newJObject()
  var valid_616090 = formData.getOrDefault("Description")
  valid_616090 = validateParameter(valid_616090, JString, required = false,
                                 default = nil)
  if valid_616090 != nil:
    section.add "Description", valid_616090
  assert formData != nil, "formData argument is necessary due to required `ClusterSubnetGroupName` field"
  var valid_616091 = formData.getOrDefault("ClusterSubnetGroupName")
  valid_616091 = validateParameter(valid_616091, JString, required = true,
                                 default = nil)
  if valid_616091 != nil:
    section.add "ClusterSubnetGroupName", valid_616091
  var valid_616092 = formData.getOrDefault("SubnetIds")
  valid_616092 = validateParameter(valid_616092, JArray, required = true, default = nil)
  if valid_616092 != nil:
    section.add "SubnetIds", valid_616092
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_616093: Call_PostModifyClusterSubnetGroup_616078; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Modifies a cluster subnet group to include the specified list of VPC subnets. The operation replaces the existing list of subnets with the new list of subnets.
  ## 
  let valid = call_616093.validator(path, query, header, formData, body)
  let scheme = call_616093.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_616093.url(scheme.get, call_616093.host, call_616093.base,
                         call_616093.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_616093, url, valid)

proc call*(call_616094: Call_PostModifyClusterSubnetGroup_616078;
          ClusterSubnetGroupName: string; SubnetIds: JsonNode;
          Description: string = ""; Action: string = "ModifyClusterSubnetGroup";
          Version: string = "2012-12-01"): Recallable =
  ## postModifyClusterSubnetGroup
  ## Modifies a cluster subnet group to include the specified list of VPC subnets. The operation replaces the existing list of subnets with the new list of subnets.
  ##   Description: string
  ##              : A text description of the subnet group to be modified.
  ##   ClusterSubnetGroupName: string (required)
  ##                         : The name of the subnet group to be modified.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   SubnetIds: JArray (required)
  ##            : An array of VPC subnet IDs. A maximum of 20 subnets can be modified in a single request.
  var query_616095 = newJObject()
  var formData_616096 = newJObject()
  add(formData_616096, "Description", newJString(Description))
  add(formData_616096, "ClusterSubnetGroupName",
      newJString(ClusterSubnetGroupName))
  add(query_616095, "Action", newJString(Action))
  add(query_616095, "Version", newJString(Version))
  if SubnetIds != nil:
    formData_616096.add "SubnetIds", SubnetIds
  result = call_616094.call(nil, query_616095, nil, formData_616096, nil)

var postModifyClusterSubnetGroup* = Call_PostModifyClusterSubnetGroup_616078(
    name: "postModifyClusterSubnetGroup", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyClusterSubnetGroup",
    validator: validate_PostModifyClusterSubnetGroup_616079, base: "/",
    url: url_PostModifyClusterSubnetGroup_616080,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetModifyClusterSubnetGroup_616060 = ref object of OpenApiRestCall_612642
proc url_GetModifyClusterSubnetGroup_616062(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetModifyClusterSubnetGroup_616061(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies a cluster subnet group to include the specified list of VPC subnets. The operation replaces the existing list of subnets with the new list of subnets.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ClusterSubnetGroupName: JString (required)
  ##                         : The name of the subnet group to be modified.
  ##   SubnetIds: JArray (required)
  ##            : An array of VPC subnet IDs. A maximum of 20 subnets can be modified in a single request.
  ##   Action: JString (required)
  ##   Description: JString
  ##              : A text description of the subnet group to be modified.
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `ClusterSubnetGroupName` field"
  var valid_616063 = query.getOrDefault("ClusterSubnetGroupName")
  valid_616063 = validateParameter(valid_616063, JString, required = true,
                                 default = nil)
  if valid_616063 != nil:
    section.add "ClusterSubnetGroupName", valid_616063
  var valid_616064 = query.getOrDefault("SubnetIds")
  valid_616064 = validateParameter(valid_616064, JArray, required = true, default = nil)
  if valid_616064 != nil:
    section.add "SubnetIds", valid_616064
  var valid_616065 = query.getOrDefault("Action")
  valid_616065 = validateParameter(valid_616065, JString, required = true, default = newJString(
      "ModifyClusterSubnetGroup"))
  if valid_616065 != nil:
    section.add "Action", valid_616065
  var valid_616066 = query.getOrDefault("Description")
  valid_616066 = validateParameter(valid_616066, JString, required = false,
                                 default = nil)
  if valid_616066 != nil:
    section.add "Description", valid_616066
  var valid_616067 = query.getOrDefault("Version")
  valid_616067 = validateParameter(valid_616067, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_616067 != nil:
    section.add "Version", valid_616067
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_616068 = header.getOrDefault("X-Amz-Signature")
  valid_616068 = validateParameter(valid_616068, JString, required = false,
                                 default = nil)
  if valid_616068 != nil:
    section.add "X-Amz-Signature", valid_616068
  var valid_616069 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_616069 = validateParameter(valid_616069, JString, required = false,
                                 default = nil)
  if valid_616069 != nil:
    section.add "X-Amz-Content-Sha256", valid_616069
  var valid_616070 = header.getOrDefault("X-Amz-Date")
  valid_616070 = validateParameter(valid_616070, JString, required = false,
                                 default = nil)
  if valid_616070 != nil:
    section.add "X-Amz-Date", valid_616070
  var valid_616071 = header.getOrDefault("X-Amz-Credential")
  valid_616071 = validateParameter(valid_616071, JString, required = false,
                                 default = nil)
  if valid_616071 != nil:
    section.add "X-Amz-Credential", valid_616071
  var valid_616072 = header.getOrDefault("X-Amz-Security-Token")
  valid_616072 = validateParameter(valid_616072, JString, required = false,
                                 default = nil)
  if valid_616072 != nil:
    section.add "X-Amz-Security-Token", valid_616072
  var valid_616073 = header.getOrDefault("X-Amz-Algorithm")
  valid_616073 = validateParameter(valid_616073, JString, required = false,
                                 default = nil)
  if valid_616073 != nil:
    section.add "X-Amz-Algorithm", valid_616073
  var valid_616074 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_616074 = validateParameter(valid_616074, JString, required = false,
                                 default = nil)
  if valid_616074 != nil:
    section.add "X-Amz-SignedHeaders", valid_616074
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_616075: Call_GetModifyClusterSubnetGroup_616060; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Modifies a cluster subnet group to include the specified list of VPC subnets. The operation replaces the existing list of subnets with the new list of subnets.
  ## 
  let valid = call_616075.validator(path, query, header, formData, body)
  let scheme = call_616075.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_616075.url(scheme.get, call_616075.host, call_616075.base,
                         call_616075.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_616075, url, valid)

proc call*(call_616076: Call_GetModifyClusterSubnetGroup_616060;
          ClusterSubnetGroupName: string; SubnetIds: JsonNode;
          Action: string = "ModifyClusterSubnetGroup"; Description: string = "";
          Version: string = "2012-12-01"): Recallable =
  ## getModifyClusterSubnetGroup
  ## Modifies a cluster subnet group to include the specified list of VPC subnets. The operation replaces the existing list of subnets with the new list of subnets.
  ##   ClusterSubnetGroupName: string (required)
  ##                         : The name of the subnet group to be modified.
  ##   SubnetIds: JArray (required)
  ##            : An array of VPC subnet IDs. A maximum of 20 subnets can be modified in a single request.
  ##   Action: string (required)
  ##   Description: string
  ##              : A text description of the subnet group to be modified.
  ##   Version: string (required)
  var query_616077 = newJObject()
  add(query_616077, "ClusterSubnetGroupName", newJString(ClusterSubnetGroupName))
  if SubnetIds != nil:
    query_616077.add "SubnetIds", SubnetIds
  add(query_616077, "Action", newJString(Action))
  add(query_616077, "Description", newJString(Description))
  add(query_616077, "Version", newJString(Version))
  result = call_616076.call(nil, query_616077, nil, nil, nil)

var getModifyClusterSubnetGroup* = Call_GetModifyClusterSubnetGroup_616060(
    name: "getModifyClusterSubnetGroup", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyClusterSubnetGroup",
    validator: validate_GetModifyClusterSubnetGroup_616061, base: "/",
    url: url_GetModifyClusterSubnetGroup_616062,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostModifyEventSubscription_616119 = ref object of OpenApiRestCall_612642
proc url_PostModifyEventSubscription_616121(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostModifyEventSubscription_616120(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies an existing Amazon Redshift event notification subscription.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_616122 = query.getOrDefault("Action")
  valid_616122 = validateParameter(valid_616122, JString, required = true, default = newJString(
      "ModifyEventSubscription"))
  if valid_616122 != nil:
    section.add "Action", valid_616122
  var valid_616123 = query.getOrDefault("Version")
  valid_616123 = validateParameter(valid_616123, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_616123 != nil:
    section.add "Version", valid_616123
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_616124 = header.getOrDefault("X-Amz-Signature")
  valid_616124 = validateParameter(valid_616124, JString, required = false,
                                 default = nil)
  if valid_616124 != nil:
    section.add "X-Amz-Signature", valid_616124
  var valid_616125 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_616125 = validateParameter(valid_616125, JString, required = false,
                                 default = nil)
  if valid_616125 != nil:
    section.add "X-Amz-Content-Sha256", valid_616125
  var valid_616126 = header.getOrDefault("X-Amz-Date")
  valid_616126 = validateParameter(valid_616126, JString, required = false,
                                 default = nil)
  if valid_616126 != nil:
    section.add "X-Amz-Date", valid_616126
  var valid_616127 = header.getOrDefault("X-Amz-Credential")
  valid_616127 = validateParameter(valid_616127, JString, required = false,
                                 default = nil)
  if valid_616127 != nil:
    section.add "X-Amz-Credential", valid_616127
  var valid_616128 = header.getOrDefault("X-Amz-Security-Token")
  valid_616128 = validateParameter(valid_616128, JString, required = false,
                                 default = nil)
  if valid_616128 != nil:
    section.add "X-Amz-Security-Token", valid_616128
  var valid_616129 = header.getOrDefault("X-Amz-Algorithm")
  valid_616129 = validateParameter(valid_616129, JString, required = false,
                                 default = nil)
  if valid_616129 != nil:
    section.add "X-Amz-Algorithm", valid_616129
  var valid_616130 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_616130 = validateParameter(valid_616130, JString, required = false,
                                 default = nil)
  if valid_616130 != nil:
    section.add "X-Amz-SignedHeaders", valid_616130
  result.add "header", section
  ## parameters in `formData` object:
  ##   SourceIds: JArray
  ##            : <p>A list of one or more identifiers of Amazon Redshift source objects. All of the objects must be of the same type as was specified in the source type parameter. The event subscription will return only events generated by the specified objects. If not specified, then events are returned for all objects within the source type specified.</p> <p>Example: my-cluster-1, my-cluster-2</p> <p>Example: my-snapshot-20131010</p>
  ##   SnsTopicArn: JString
  ##              : The Amazon Resource Name (ARN) of the SNS topic to be used by the event notification subscription.
  ##   Enabled: JBool
  ##          : A Boolean value indicating if the subscription is enabled. <code>true</code> indicates the subscription is enabled 
  ##   SubscriptionName: JString (required)
  ##                   : The name of the modified Amazon Redshift event notification subscription.
  ##   SourceType: JString
  ##             : <p>The type of source that will be generating the events. For example, if you want to be notified of events generated by a cluster, you would set this parameter to cluster. If this value is not specified, events are returned for all Amazon Redshift objects in your AWS account. You must specify a source type in order to specify source IDs.</p> <p>Valid values: cluster, cluster-parameter-group, cluster-security-group, cluster-snapshot, and scheduled-action.</p>
  ##   Severity: JString
  ##           : <p>Specifies the Amazon Redshift event severity to be published by the event notification subscription.</p> <p>Values: ERROR, INFO</p>
  ##   EventCategories: JArray
  ##                  : <p>Specifies the Amazon Redshift event categories to be published by the event notification subscription.</p> <p>Values: configuration, management, monitoring, security</p>
  section = newJObject()
  var valid_616131 = formData.getOrDefault("SourceIds")
  valid_616131 = validateParameter(valid_616131, JArray, required = false,
                                 default = nil)
  if valid_616131 != nil:
    section.add "SourceIds", valid_616131
  var valid_616132 = formData.getOrDefault("SnsTopicArn")
  valid_616132 = validateParameter(valid_616132, JString, required = false,
                                 default = nil)
  if valid_616132 != nil:
    section.add "SnsTopicArn", valid_616132
  var valid_616133 = formData.getOrDefault("Enabled")
  valid_616133 = validateParameter(valid_616133, JBool, required = false, default = nil)
  if valid_616133 != nil:
    section.add "Enabled", valid_616133
  assert formData != nil, "formData argument is necessary due to required `SubscriptionName` field"
  var valid_616134 = formData.getOrDefault("SubscriptionName")
  valid_616134 = validateParameter(valid_616134, JString, required = true,
                                 default = nil)
  if valid_616134 != nil:
    section.add "SubscriptionName", valid_616134
  var valid_616135 = formData.getOrDefault("SourceType")
  valid_616135 = validateParameter(valid_616135, JString, required = false,
                                 default = nil)
  if valid_616135 != nil:
    section.add "SourceType", valid_616135
  var valid_616136 = formData.getOrDefault("Severity")
  valid_616136 = validateParameter(valid_616136, JString, required = false,
                                 default = nil)
  if valid_616136 != nil:
    section.add "Severity", valid_616136
  var valid_616137 = formData.getOrDefault("EventCategories")
  valid_616137 = validateParameter(valid_616137, JArray, required = false,
                                 default = nil)
  if valid_616137 != nil:
    section.add "EventCategories", valid_616137
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_616138: Call_PostModifyEventSubscription_616119; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Modifies an existing Amazon Redshift event notification subscription.
  ## 
  let valid = call_616138.validator(path, query, header, formData, body)
  let scheme = call_616138.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_616138.url(scheme.get, call_616138.host, call_616138.base,
                         call_616138.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_616138, url, valid)

proc call*(call_616139: Call_PostModifyEventSubscription_616119;
          SubscriptionName: string; SourceIds: JsonNode = nil;
          SnsTopicArn: string = ""; Enabled: bool = false; SourceType: string = "";
          Severity: string = ""; EventCategories: JsonNode = nil;
          Action: string = "ModifyEventSubscription"; Version: string = "2012-12-01"): Recallable =
  ## postModifyEventSubscription
  ## Modifies an existing Amazon Redshift event notification subscription.
  ##   SourceIds: JArray
  ##            : <p>A list of one or more identifiers of Amazon Redshift source objects. All of the objects must be of the same type as was specified in the source type parameter. The event subscription will return only events generated by the specified objects. If not specified, then events are returned for all objects within the source type specified.</p> <p>Example: my-cluster-1, my-cluster-2</p> <p>Example: my-snapshot-20131010</p>
  ##   SnsTopicArn: string
  ##              : The Amazon Resource Name (ARN) of the SNS topic to be used by the event notification subscription.
  ##   Enabled: bool
  ##          : A Boolean value indicating if the subscription is enabled. <code>true</code> indicates the subscription is enabled 
  ##   SubscriptionName: string (required)
  ##                   : The name of the modified Amazon Redshift event notification subscription.
  ##   SourceType: string
  ##             : <p>The type of source that will be generating the events. For example, if you want to be notified of events generated by a cluster, you would set this parameter to cluster. If this value is not specified, events are returned for all Amazon Redshift objects in your AWS account. You must specify a source type in order to specify source IDs.</p> <p>Valid values: cluster, cluster-parameter-group, cluster-security-group, cluster-snapshot, and scheduled-action.</p>
  ##   Severity: string
  ##           : <p>Specifies the Amazon Redshift event severity to be published by the event notification subscription.</p> <p>Values: ERROR, INFO</p>
  ##   EventCategories: JArray
  ##                  : <p>Specifies the Amazon Redshift event categories to be published by the event notification subscription.</p> <p>Values: configuration, management, monitoring, security</p>
  ##   Action: string (required)
  ##   Version: string (required)
  var query_616140 = newJObject()
  var formData_616141 = newJObject()
  if SourceIds != nil:
    formData_616141.add "SourceIds", SourceIds
  add(formData_616141, "SnsTopicArn", newJString(SnsTopicArn))
  add(formData_616141, "Enabled", newJBool(Enabled))
  add(formData_616141, "SubscriptionName", newJString(SubscriptionName))
  add(formData_616141, "SourceType", newJString(SourceType))
  add(formData_616141, "Severity", newJString(Severity))
  if EventCategories != nil:
    formData_616141.add "EventCategories", EventCategories
  add(query_616140, "Action", newJString(Action))
  add(query_616140, "Version", newJString(Version))
  result = call_616139.call(nil, query_616140, nil, formData_616141, nil)

var postModifyEventSubscription* = Call_PostModifyEventSubscription_616119(
    name: "postModifyEventSubscription", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyEventSubscription",
    validator: validate_PostModifyEventSubscription_616120, base: "/",
    url: url_PostModifyEventSubscription_616121,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetModifyEventSubscription_616097 = ref object of OpenApiRestCall_612642
proc url_GetModifyEventSubscription_616099(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetModifyEventSubscription_616098(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies an existing Amazon Redshift event notification subscription.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   SourceType: JString
  ##             : <p>The type of source that will be generating the events. For example, if you want to be notified of events generated by a cluster, you would set this parameter to cluster. If this value is not specified, events are returned for all Amazon Redshift objects in your AWS account. You must specify a source type in order to specify source IDs.</p> <p>Valid values: cluster, cluster-parameter-group, cluster-security-group, cluster-snapshot, and scheduled-action.</p>
  ##   Enabled: JBool
  ##          : A Boolean value indicating if the subscription is enabled. <code>true</code> indicates the subscription is enabled 
  ##   Severity: JString
  ##           : <p>Specifies the Amazon Redshift event severity to be published by the event notification subscription.</p> <p>Values: ERROR, INFO</p>
  ##   SubscriptionName: JString (required)
  ##                   : The name of the modified Amazon Redshift event notification subscription.
  ##   EventCategories: JArray
  ##                  : <p>Specifies the Amazon Redshift event categories to be published by the event notification subscription.</p> <p>Values: configuration, management, monitoring, security</p>
  ##   SourceIds: JArray
  ##            : <p>A list of one or more identifiers of Amazon Redshift source objects. All of the objects must be of the same type as was specified in the source type parameter. The event subscription will return only events generated by the specified objects. If not specified, then events are returned for all objects within the source type specified.</p> <p>Example: my-cluster-1, my-cluster-2</p> <p>Example: my-snapshot-20131010</p>
  ##   Action: JString (required)
  ##   SnsTopicArn: JString
  ##              : The Amazon Resource Name (ARN) of the SNS topic to be used by the event notification subscription.
  ##   Version: JString (required)
  section = newJObject()
  var valid_616100 = query.getOrDefault("SourceType")
  valid_616100 = validateParameter(valid_616100, JString, required = false,
                                 default = nil)
  if valid_616100 != nil:
    section.add "SourceType", valid_616100
  var valid_616101 = query.getOrDefault("Enabled")
  valid_616101 = validateParameter(valid_616101, JBool, required = false, default = nil)
  if valid_616101 != nil:
    section.add "Enabled", valid_616101
  var valid_616102 = query.getOrDefault("Severity")
  valid_616102 = validateParameter(valid_616102, JString, required = false,
                                 default = nil)
  if valid_616102 != nil:
    section.add "Severity", valid_616102
  assert query != nil,
        "query argument is necessary due to required `SubscriptionName` field"
  var valid_616103 = query.getOrDefault("SubscriptionName")
  valid_616103 = validateParameter(valid_616103, JString, required = true,
                                 default = nil)
  if valid_616103 != nil:
    section.add "SubscriptionName", valid_616103
  var valid_616104 = query.getOrDefault("EventCategories")
  valid_616104 = validateParameter(valid_616104, JArray, required = false,
                                 default = nil)
  if valid_616104 != nil:
    section.add "EventCategories", valid_616104
  var valid_616105 = query.getOrDefault("SourceIds")
  valid_616105 = validateParameter(valid_616105, JArray, required = false,
                                 default = nil)
  if valid_616105 != nil:
    section.add "SourceIds", valid_616105
  var valid_616106 = query.getOrDefault("Action")
  valid_616106 = validateParameter(valid_616106, JString, required = true, default = newJString(
      "ModifyEventSubscription"))
  if valid_616106 != nil:
    section.add "Action", valid_616106
  var valid_616107 = query.getOrDefault("SnsTopicArn")
  valid_616107 = validateParameter(valid_616107, JString, required = false,
                                 default = nil)
  if valid_616107 != nil:
    section.add "SnsTopicArn", valid_616107
  var valid_616108 = query.getOrDefault("Version")
  valid_616108 = validateParameter(valid_616108, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_616108 != nil:
    section.add "Version", valid_616108
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_616109 = header.getOrDefault("X-Amz-Signature")
  valid_616109 = validateParameter(valid_616109, JString, required = false,
                                 default = nil)
  if valid_616109 != nil:
    section.add "X-Amz-Signature", valid_616109
  var valid_616110 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_616110 = validateParameter(valid_616110, JString, required = false,
                                 default = nil)
  if valid_616110 != nil:
    section.add "X-Amz-Content-Sha256", valid_616110
  var valid_616111 = header.getOrDefault("X-Amz-Date")
  valid_616111 = validateParameter(valid_616111, JString, required = false,
                                 default = nil)
  if valid_616111 != nil:
    section.add "X-Amz-Date", valid_616111
  var valid_616112 = header.getOrDefault("X-Amz-Credential")
  valid_616112 = validateParameter(valid_616112, JString, required = false,
                                 default = nil)
  if valid_616112 != nil:
    section.add "X-Amz-Credential", valid_616112
  var valid_616113 = header.getOrDefault("X-Amz-Security-Token")
  valid_616113 = validateParameter(valid_616113, JString, required = false,
                                 default = nil)
  if valid_616113 != nil:
    section.add "X-Amz-Security-Token", valid_616113
  var valid_616114 = header.getOrDefault("X-Amz-Algorithm")
  valid_616114 = validateParameter(valid_616114, JString, required = false,
                                 default = nil)
  if valid_616114 != nil:
    section.add "X-Amz-Algorithm", valid_616114
  var valid_616115 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_616115 = validateParameter(valid_616115, JString, required = false,
                                 default = nil)
  if valid_616115 != nil:
    section.add "X-Amz-SignedHeaders", valid_616115
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_616116: Call_GetModifyEventSubscription_616097; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Modifies an existing Amazon Redshift event notification subscription.
  ## 
  let valid = call_616116.validator(path, query, header, formData, body)
  let scheme = call_616116.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_616116.url(scheme.get, call_616116.host, call_616116.base,
                         call_616116.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_616116, url, valid)

proc call*(call_616117: Call_GetModifyEventSubscription_616097;
          SubscriptionName: string; SourceType: string = ""; Enabled: bool = false;
          Severity: string = ""; EventCategories: JsonNode = nil;
          SourceIds: JsonNode = nil; Action: string = "ModifyEventSubscription";
          SnsTopicArn: string = ""; Version: string = "2012-12-01"): Recallable =
  ## getModifyEventSubscription
  ## Modifies an existing Amazon Redshift event notification subscription.
  ##   SourceType: string
  ##             : <p>The type of source that will be generating the events. For example, if you want to be notified of events generated by a cluster, you would set this parameter to cluster. If this value is not specified, events are returned for all Amazon Redshift objects in your AWS account. You must specify a source type in order to specify source IDs.</p> <p>Valid values: cluster, cluster-parameter-group, cluster-security-group, cluster-snapshot, and scheduled-action.</p>
  ##   Enabled: bool
  ##          : A Boolean value indicating if the subscription is enabled. <code>true</code> indicates the subscription is enabled 
  ##   Severity: string
  ##           : <p>Specifies the Amazon Redshift event severity to be published by the event notification subscription.</p> <p>Values: ERROR, INFO</p>
  ##   SubscriptionName: string (required)
  ##                   : The name of the modified Amazon Redshift event notification subscription.
  ##   EventCategories: JArray
  ##                  : <p>Specifies the Amazon Redshift event categories to be published by the event notification subscription.</p> <p>Values: configuration, management, monitoring, security</p>
  ##   SourceIds: JArray
  ##            : <p>A list of one or more identifiers of Amazon Redshift source objects. All of the objects must be of the same type as was specified in the source type parameter. The event subscription will return only events generated by the specified objects. If not specified, then events are returned for all objects within the source type specified.</p> <p>Example: my-cluster-1, my-cluster-2</p> <p>Example: my-snapshot-20131010</p>
  ##   Action: string (required)
  ##   SnsTopicArn: string
  ##              : The Amazon Resource Name (ARN) of the SNS topic to be used by the event notification subscription.
  ##   Version: string (required)
  var query_616118 = newJObject()
  add(query_616118, "SourceType", newJString(SourceType))
  add(query_616118, "Enabled", newJBool(Enabled))
  add(query_616118, "Severity", newJString(Severity))
  add(query_616118, "SubscriptionName", newJString(SubscriptionName))
  if EventCategories != nil:
    query_616118.add "EventCategories", EventCategories
  if SourceIds != nil:
    query_616118.add "SourceIds", SourceIds
  add(query_616118, "Action", newJString(Action))
  add(query_616118, "SnsTopicArn", newJString(SnsTopicArn))
  add(query_616118, "Version", newJString(Version))
  result = call_616117.call(nil, query_616118, nil, nil, nil)

var getModifyEventSubscription* = Call_GetModifyEventSubscription_616097(
    name: "getModifyEventSubscription", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyEventSubscription",
    validator: validate_GetModifyEventSubscription_616098, base: "/",
    url: url_GetModifyEventSubscription_616099,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostModifyScheduledAction_616165 = ref object of OpenApiRestCall_612642
proc url_PostModifyScheduledAction_616167(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostModifyScheduledAction_616166(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies a scheduled action. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_616168 = query.getOrDefault("Action")
  valid_616168 = validateParameter(valid_616168, JString, required = true,
                                 default = newJString("ModifyScheduledAction"))
  if valid_616168 != nil:
    section.add "Action", valid_616168
  var valid_616169 = query.getOrDefault("Version")
  valid_616169 = validateParameter(valid_616169, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_616169 != nil:
    section.add "Version", valid_616169
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_616170 = header.getOrDefault("X-Amz-Signature")
  valid_616170 = validateParameter(valid_616170, JString, required = false,
                                 default = nil)
  if valid_616170 != nil:
    section.add "X-Amz-Signature", valid_616170
  var valid_616171 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_616171 = validateParameter(valid_616171, JString, required = false,
                                 default = nil)
  if valid_616171 != nil:
    section.add "X-Amz-Content-Sha256", valid_616171
  var valid_616172 = header.getOrDefault("X-Amz-Date")
  valid_616172 = validateParameter(valid_616172, JString, required = false,
                                 default = nil)
  if valid_616172 != nil:
    section.add "X-Amz-Date", valid_616172
  var valid_616173 = header.getOrDefault("X-Amz-Credential")
  valid_616173 = validateParameter(valid_616173, JString, required = false,
                                 default = nil)
  if valid_616173 != nil:
    section.add "X-Amz-Credential", valid_616173
  var valid_616174 = header.getOrDefault("X-Amz-Security-Token")
  valid_616174 = validateParameter(valid_616174, JString, required = false,
                                 default = nil)
  if valid_616174 != nil:
    section.add "X-Amz-Security-Token", valid_616174
  var valid_616175 = header.getOrDefault("X-Amz-Algorithm")
  valid_616175 = validateParameter(valid_616175, JString, required = false,
                                 default = nil)
  if valid_616175 != nil:
    section.add "X-Amz-Algorithm", valid_616175
  var valid_616176 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_616176 = validateParameter(valid_616176, JString, required = false,
                                 default = nil)
  if valid_616176 != nil:
    section.add "X-Amz-SignedHeaders", valid_616176
  result.add "header", section
  ## parameters in `formData` object:
  ##   Enable: JBool
  ##         : A modified enable flag of the scheduled action. If true, the scheduled action is active. If false, the scheduled action is disabled. 
  ##   TargetAction.ResizeCluster: JString
  ##                             : The action type that specifies an Amazon Redshift API operation that is supported by the Amazon Redshift scheduler. 
  ## An action that runs a <code>ResizeCluster</code> API operation. 
  ##   ScheduledActionName: JString (required)
  ##                      : The name of the scheduled action to modify. 
  ##   ScheduledActionDescription: JString
  ##                             : A modified description of the scheduled action. 
  ##   Schedule: JString
  ##           : A modified schedule in either <code>at( )</code> or <code>cron( )</code> format. For more information about this parameter, see <a>ScheduledAction</a>.
  ##   EndTime: JString
  ##          : A modified end time of the scheduled action. For more information about this parameter, see <a>ScheduledAction</a>. 
  ##   StartTime: JString
  ##            : A modified start time of the scheduled action. For more information about this parameter, see <a>ScheduledAction</a>. 
  ##   IamRole: JString
  ##          : A different IAM role to assume to run the target action. For more information about this parameter, see <a>ScheduledAction</a>.
  section = newJObject()
  var valid_616177 = formData.getOrDefault("Enable")
  valid_616177 = validateParameter(valid_616177, JBool, required = false, default = nil)
  if valid_616177 != nil:
    section.add "Enable", valid_616177
  var valid_616178 = formData.getOrDefault("TargetAction.ResizeCluster")
  valid_616178 = validateParameter(valid_616178, JString, required = false,
                                 default = nil)
  if valid_616178 != nil:
    section.add "TargetAction.ResizeCluster", valid_616178
  assert formData != nil, "formData argument is necessary due to required `ScheduledActionName` field"
  var valid_616179 = formData.getOrDefault("ScheduledActionName")
  valid_616179 = validateParameter(valid_616179, JString, required = true,
                                 default = nil)
  if valid_616179 != nil:
    section.add "ScheduledActionName", valid_616179
  var valid_616180 = formData.getOrDefault("ScheduledActionDescription")
  valid_616180 = validateParameter(valid_616180, JString, required = false,
                                 default = nil)
  if valid_616180 != nil:
    section.add "ScheduledActionDescription", valid_616180
  var valid_616181 = formData.getOrDefault("Schedule")
  valid_616181 = validateParameter(valid_616181, JString, required = false,
                                 default = nil)
  if valid_616181 != nil:
    section.add "Schedule", valid_616181
  var valid_616182 = formData.getOrDefault("EndTime")
  valid_616182 = validateParameter(valid_616182, JString, required = false,
                                 default = nil)
  if valid_616182 != nil:
    section.add "EndTime", valid_616182
  var valid_616183 = formData.getOrDefault("StartTime")
  valid_616183 = validateParameter(valid_616183, JString, required = false,
                                 default = nil)
  if valid_616183 != nil:
    section.add "StartTime", valid_616183
  var valid_616184 = formData.getOrDefault("IamRole")
  valid_616184 = validateParameter(valid_616184, JString, required = false,
                                 default = nil)
  if valid_616184 != nil:
    section.add "IamRole", valid_616184
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_616185: Call_PostModifyScheduledAction_616165; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Modifies a scheduled action. 
  ## 
  let valid = call_616185.validator(path, query, header, formData, body)
  let scheme = call_616185.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_616185.url(scheme.get, call_616185.host, call_616185.base,
                         call_616185.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_616185, url, valid)

proc call*(call_616186: Call_PostModifyScheduledAction_616165;
          ScheduledActionName: string; Enable: bool = false;
          TargetActionResizeCluster: string = "";
          ScheduledActionDescription: string = ""; Schedule: string = "";
          EndTime: string = ""; StartTime: string = "";
          Action: string = "ModifyScheduledAction"; Version: string = "2012-12-01";
          IamRole: string = ""): Recallable =
  ## postModifyScheduledAction
  ## Modifies a scheduled action. 
  ##   Enable: bool
  ##         : A modified enable flag of the scheduled action. If true, the scheduled action is active. If false, the scheduled action is disabled. 
  ##   TargetActionResizeCluster: string
  ##                            : The action type that specifies an Amazon Redshift API operation that is supported by the Amazon Redshift scheduler. 
  ## An action that runs a <code>ResizeCluster</code> API operation. 
  ##   ScheduledActionName: string (required)
  ##                      : The name of the scheduled action to modify. 
  ##   ScheduledActionDescription: string
  ##                             : A modified description of the scheduled action. 
  ##   Schedule: string
  ##           : A modified schedule in either <code>at( )</code> or <code>cron( )</code> format. For more information about this parameter, see <a>ScheduledAction</a>.
  ##   EndTime: string
  ##          : A modified end time of the scheduled action. For more information about this parameter, see <a>ScheduledAction</a>. 
  ##   StartTime: string
  ##            : A modified start time of the scheduled action. For more information about this parameter, see <a>ScheduledAction</a>. 
  ##   Action: string (required)
  ##   Version: string (required)
  ##   IamRole: string
  ##          : A different IAM role to assume to run the target action. For more information about this parameter, see <a>ScheduledAction</a>.
  var query_616187 = newJObject()
  var formData_616188 = newJObject()
  add(formData_616188, "Enable", newJBool(Enable))
  add(formData_616188, "TargetAction.ResizeCluster",
      newJString(TargetActionResizeCluster))
  add(formData_616188, "ScheduledActionName", newJString(ScheduledActionName))
  add(formData_616188, "ScheduledActionDescription",
      newJString(ScheduledActionDescription))
  add(formData_616188, "Schedule", newJString(Schedule))
  add(formData_616188, "EndTime", newJString(EndTime))
  add(formData_616188, "StartTime", newJString(StartTime))
  add(query_616187, "Action", newJString(Action))
  add(query_616187, "Version", newJString(Version))
  add(formData_616188, "IamRole", newJString(IamRole))
  result = call_616186.call(nil, query_616187, nil, formData_616188, nil)

var postModifyScheduledAction* = Call_PostModifyScheduledAction_616165(
    name: "postModifyScheduledAction", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyScheduledAction",
    validator: validate_PostModifyScheduledAction_616166, base: "/",
    url: url_PostModifyScheduledAction_616167,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetModifyScheduledAction_616142 = ref object of OpenApiRestCall_612642
proc url_GetModifyScheduledAction_616144(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetModifyScheduledAction_616143(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies a scheduled action. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Schedule: JString
  ##           : A modified schedule in either <code>at( )</code> or <code>cron( )</code> format. For more information about this parameter, see <a>ScheduledAction</a>.
  ##   Enable: JBool
  ##         : A modified enable flag of the scheduled action. If true, the scheduled action is active. If false, the scheduled action is disabled. 
  ##   ScheduledActionName: JString (required)
  ##                      : The name of the scheduled action to modify. 
  ##   IamRole: JString
  ##          : A different IAM role to assume to run the target action. For more information about this parameter, see <a>ScheduledAction</a>.
  ##   TargetAction.ResizeCluster: JString
  ##                             : The action type that specifies an Amazon Redshift API operation that is supported by the Amazon Redshift scheduler. 
  ## An action that runs a <code>ResizeCluster</code> API operation. 
  ##   ScheduledActionDescription: JString
  ##                             : A modified description of the scheduled action. 
  ##   Action: JString (required)
  ##   StartTime: JString
  ##            : A modified start time of the scheduled action. For more information about this parameter, see <a>ScheduledAction</a>. 
  ##   EndTime: JString
  ##          : A modified end time of the scheduled action. For more information about this parameter, see <a>ScheduledAction</a>. 
  ##   Version: JString (required)
  section = newJObject()
  var valid_616145 = query.getOrDefault("Schedule")
  valid_616145 = validateParameter(valid_616145, JString, required = false,
                                 default = nil)
  if valid_616145 != nil:
    section.add "Schedule", valid_616145
  var valid_616146 = query.getOrDefault("Enable")
  valid_616146 = validateParameter(valid_616146, JBool, required = false, default = nil)
  if valid_616146 != nil:
    section.add "Enable", valid_616146
  assert query != nil, "query argument is necessary due to required `ScheduledActionName` field"
  var valid_616147 = query.getOrDefault("ScheduledActionName")
  valid_616147 = validateParameter(valid_616147, JString, required = true,
                                 default = nil)
  if valid_616147 != nil:
    section.add "ScheduledActionName", valid_616147
  var valid_616148 = query.getOrDefault("IamRole")
  valid_616148 = validateParameter(valid_616148, JString, required = false,
                                 default = nil)
  if valid_616148 != nil:
    section.add "IamRole", valid_616148
  var valid_616149 = query.getOrDefault("TargetAction.ResizeCluster")
  valid_616149 = validateParameter(valid_616149, JString, required = false,
                                 default = nil)
  if valid_616149 != nil:
    section.add "TargetAction.ResizeCluster", valid_616149
  var valid_616150 = query.getOrDefault("ScheduledActionDescription")
  valid_616150 = validateParameter(valid_616150, JString, required = false,
                                 default = nil)
  if valid_616150 != nil:
    section.add "ScheduledActionDescription", valid_616150
  var valid_616151 = query.getOrDefault("Action")
  valid_616151 = validateParameter(valid_616151, JString, required = true,
                                 default = newJString("ModifyScheduledAction"))
  if valid_616151 != nil:
    section.add "Action", valid_616151
  var valid_616152 = query.getOrDefault("StartTime")
  valid_616152 = validateParameter(valid_616152, JString, required = false,
                                 default = nil)
  if valid_616152 != nil:
    section.add "StartTime", valid_616152
  var valid_616153 = query.getOrDefault("EndTime")
  valid_616153 = validateParameter(valid_616153, JString, required = false,
                                 default = nil)
  if valid_616153 != nil:
    section.add "EndTime", valid_616153
  var valid_616154 = query.getOrDefault("Version")
  valid_616154 = validateParameter(valid_616154, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_616154 != nil:
    section.add "Version", valid_616154
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_616155 = header.getOrDefault("X-Amz-Signature")
  valid_616155 = validateParameter(valid_616155, JString, required = false,
                                 default = nil)
  if valid_616155 != nil:
    section.add "X-Amz-Signature", valid_616155
  var valid_616156 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_616156 = validateParameter(valid_616156, JString, required = false,
                                 default = nil)
  if valid_616156 != nil:
    section.add "X-Amz-Content-Sha256", valid_616156
  var valid_616157 = header.getOrDefault("X-Amz-Date")
  valid_616157 = validateParameter(valid_616157, JString, required = false,
                                 default = nil)
  if valid_616157 != nil:
    section.add "X-Amz-Date", valid_616157
  var valid_616158 = header.getOrDefault("X-Amz-Credential")
  valid_616158 = validateParameter(valid_616158, JString, required = false,
                                 default = nil)
  if valid_616158 != nil:
    section.add "X-Amz-Credential", valid_616158
  var valid_616159 = header.getOrDefault("X-Amz-Security-Token")
  valid_616159 = validateParameter(valid_616159, JString, required = false,
                                 default = nil)
  if valid_616159 != nil:
    section.add "X-Amz-Security-Token", valid_616159
  var valid_616160 = header.getOrDefault("X-Amz-Algorithm")
  valid_616160 = validateParameter(valid_616160, JString, required = false,
                                 default = nil)
  if valid_616160 != nil:
    section.add "X-Amz-Algorithm", valid_616160
  var valid_616161 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_616161 = validateParameter(valid_616161, JString, required = false,
                                 default = nil)
  if valid_616161 != nil:
    section.add "X-Amz-SignedHeaders", valid_616161
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_616162: Call_GetModifyScheduledAction_616142; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Modifies a scheduled action. 
  ## 
  let valid = call_616162.validator(path, query, header, formData, body)
  let scheme = call_616162.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_616162.url(scheme.get, call_616162.host, call_616162.base,
                         call_616162.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_616162, url, valid)

proc call*(call_616163: Call_GetModifyScheduledAction_616142;
          ScheduledActionName: string; Schedule: string = ""; Enable: bool = false;
          IamRole: string = ""; TargetActionResizeCluster: string = "";
          ScheduledActionDescription: string = "";
          Action: string = "ModifyScheduledAction"; StartTime: string = "";
          EndTime: string = ""; Version: string = "2012-12-01"): Recallable =
  ## getModifyScheduledAction
  ## Modifies a scheduled action. 
  ##   Schedule: string
  ##           : A modified schedule in either <code>at( )</code> or <code>cron( )</code> format. For more information about this parameter, see <a>ScheduledAction</a>.
  ##   Enable: bool
  ##         : A modified enable flag of the scheduled action. If true, the scheduled action is active. If false, the scheduled action is disabled. 
  ##   ScheduledActionName: string (required)
  ##                      : The name of the scheduled action to modify. 
  ##   IamRole: string
  ##          : A different IAM role to assume to run the target action. For more information about this parameter, see <a>ScheduledAction</a>.
  ##   TargetActionResizeCluster: string
  ##                            : The action type that specifies an Amazon Redshift API operation that is supported by the Amazon Redshift scheduler. 
  ## An action that runs a <code>ResizeCluster</code> API operation. 
  ##   ScheduledActionDescription: string
  ##                             : A modified description of the scheduled action. 
  ##   Action: string (required)
  ##   StartTime: string
  ##            : A modified start time of the scheduled action. For more information about this parameter, see <a>ScheduledAction</a>. 
  ##   EndTime: string
  ##          : A modified end time of the scheduled action. For more information about this parameter, see <a>ScheduledAction</a>. 
  ##   Version: string (required)
  var query_616164 = newJObject()
  add(query_616164, "Schedule", newJString(Schedule))
  add(query_616164, "Enable", newJBool(Enable))
  add(query_616164, "ScheduledActionName", newJString(ScheduledActionName))
  add(query_616164, "IamRole", newJString(IamRole))
  add(query_616164, "TargetAction.ResizeCluster",
      newJString(TargetActionResizeCluster))
  add(query_616164, "ScheduledActionDescription",
      newJString(ScheduledActionDescription))
  add(query_616164, "Action", newJString(Action))
  add(query_616164, "StartTime", newJString(StartTime))
  add(query_616164, "EndTime", newJString(EndTime))
  add(query_616164, "Version", newJString(Version))
  result = call_616163.call(nil, query_616164, nil, nil, nil)

var getModifyScheduledAction* = Call_GetModifyScheduledAction_616142(
    name: "getModifyScheduledAction", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyScheduledAction",
    validator: validate_GetModifyScheduledAction_616143, base: "/",
    url: url_GetModifyScheduledAction_616144, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostModifySnapshotCopyRetentionPeriod_616207 = ref object of OpenApiRestCall_612642
proc url_PostModifySnapshotCopyRetentionPeriod_616209(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostModifySnapshotCopyRetentionPeriod_616208(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies the number of days to retain snapshots in the destination AWS Region after they are copied from the source AWS Region. By default, this operation only changes the retention period of copied automated snapshots. The retention periods for both new and existing copied automated snapshots are updated with the new retention period. You can set the manual option to change only the retention periods of copied manual snapshots. If you set this option, only newly copied manual snapshots have the new retention period. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_616210 = query.getOrDefault("Action")
  valid_616210 = validateParameter(valid_616210, JString, required = true, default = newJString(
      "ModifySnapshotCopyRetentionPeriod"))
  if valid_616210 != nil:
    section.add "Action", valid_616210
  var valid_616211 = query.getOrDefault("Version")
  valid_616211 = validateParameter(valid_616211, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_616211 != nil:
    section.add "Version", valid_616211
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_616212 = header.getOrDefault("X-Amz-Signature")
  valid_616212 = validateParameter(valid_616212, JString, required = false,
                                 default = nil)
  if valid_616212 != nil:
    section.add "X-Amz-Signature", valid_616212
  var valid_616213 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_616213 = validateParameter(valid_616213, JString, required = false,
                                 default = nil)
  if valid_616213 != nil:
    section.add "X-Amz-Content-Sha256", valid_616213
  var valid_616214 = header.getOrDefault("X-Amz-Date")
  valid_616214 = validateParameter(valid_616214, JString, required = false,
                                 default = nil)
  if valid_616214 != nil:
    section.add "X-Amz-Date", valid_616214
  var valid_616215 = header.getOrDefault("X-Amz-Credential")
  valid_616215 = validateParameter(valid_616215, JString, required = false,
                                 default = nil)
  if valid_616215 != nil:
    section.add "X-Amz-Credential", valid_616215
  var valid_616216 = header.getOrDefault("X-Amz-Security-Token")
  valid_616216 = validateParameter(valid_616216, JString, required = false,
                                 default = nil)
  if valid_616216 != nil:
    section.add "X-Amz-Security-Token", valid_616216
  var valid_616217 = header.getOrDefault("X-Amz-Algorithm")
  valid_616217 = validateParameter(valid_616217, JString, required = false,
                                 default = nil)
  if valid_616217 != nil:
    section.add "X-Amz-Algorithm", valid_616217
  var valid_616218 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_616218 = validateParameter(valid_616218, JString, required = false,
                                 default = nil)
  if valid_616218 != nil:
    section.add "X-Amz-SignedHeaders", valid_616218
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of the cluster for which you want to change the retention period for either automated or manual snapshots that are copied to a destination AWS Region.</p> <p>Constraints: Must be the valid name of an existing cluster that has cross-region snapshot copy enabled.</p>
  ##   RetentionPeriod: JInt (required)
  ##                  : <p>The number of days to retain automated snapshots in the destination AWS Region after they are copied from the source AWS Region.</p> <p>By default, this only changes the retention period of copied automated snapshots. </p> <p>If you decrease the retention period for automated snapshots that are copied to a destination AWS Region, Amazon Redshift deletes any existing automated snapshots that were copied to the destination AWS Region and that fall outside of the new retention period.</p> <p>Constraints: Must be at least 1 and no more than 35 for automated snapshots. </p> <p>If you specify the <code>manual</code> option, only newly copied manual snapshots will have the new retention period. </p> <p>If you specify the value of -1 newly copied manual snapshots are retained indefinitely.</p> <p>Constraints: The number of days must be either -1 or an integer between 1 and 3,653 for manual snapshots.</p>
  ##   Manual: JBool
  ##         : Indicates whether to apply the snapshot retention period to newly copied manual snapshots instead of automated snapshots.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_616219 = formData.getOrDefault("ClusterIdentifier")
  valid_616219 = validateParameter(valid_616219, JString, required = true,
                                 default = nil)
  if valid_616219 != nil:
    section.add "ClusterIdentifier", valid_616219
  var valid_616220 = formData.getOrDefault("RetentionPeriod")
  valid_616220 = validateParameter(valid_616220, JInt, required = true, default = nil)
  if valid_616220 != nil:
    section.add "RetentionPeriod", valid_616220
  var valid_616221 = formData.getOrDefault("Manual")
  valid_616221 = validateParameter(valid_616221, JBool, required = false, default = nil)
  if valid_616221 != nil:
    section.add "Manual", valid_616221
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_616222: Call_PostModifySnapshotCopyRetentionPeriod_616207;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Modifies the number of days to retain snapshots in the destination AWS Region after they are copied from the source AWS Region. By default, this operation only changes the retention period of copied automated snapshots. The retention periods for both new and existing copied automated snapshots are updated with the new retention period. You can set the manual option to change only the retention periods of copied manual snapshots. If you set this option, only newly copied manual snapshots have the new retention period. 
  ## 
  let valid = call_616222.validator(path, query, header, formData, body)
  let scheme = call_616222.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_616222.url(scheme.get, call_616222.host, call_616222.base,
                         call_616222.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_616222, url, valid)

proc call*(call_616223: Call_PostModifySnapshotCopyRetentionPeriod_616207;
          ClusterIdentifier: string; RetentionPeriod: int;
          Action: string = "ModifySnapshotCopyRetentionPeriod";
          Manual: bool = false; Version: string = "2012-12-01"): Recallable =
  ## postModifySnapshotCopyRetentionPeriod
  ## Modifies the number of days to retain snapshots in the destination AWS Region after they are copied from the source AWS Region. By default, this operation only changes the retention period of copied automated snapshots. The retention periods for both new and existing copied automated snapshots are updated with the new retention period. You can set the manual option to change only the retention periods of copied manual snapshots. If you set this option, only newly copied manual snapshots have the new retention period. 
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of the cluster for which you want to change the retention period for either automated or manual snapshots that are copied to a destination AWS Region.</p> <p>Constraints: Must be the valid name of an existing cluster that has cross-region snapshot copy enabled.</p>
  ##   RetentionPeriod: int (required)
  ##                  : <p>The number of days to retain automated snapshots in the destination AWS Region after they are copied from the source AWS Region.</p> <p>By default, this only changes the retention period of copied automated snapshots. </p> <p>If you decrease the retention period for automated snapshots that are copied to a destination AWS Region, Amazon Redshift deletes any existing automated snapshots that were copied to the destination AWS Region and that fall outside of the new retention period.</p> <p>Constraints: Must be at least 1 and no more than 35 for automated snapshots. </p> <p>If you specify the <code>manual</code> option, only newly copied manual snapshots will have the new retention period. </p> <p>If you specify the value of -1 newly copied manual snapshots are retained indefinitely.</p> <p>Constraints: The number of days must be either -1 or an integer between 1 and 3,653 for manual snapshots.</p>
  ##   Action: string (required)
  ##   Manual: bool
  ##         : Indicates whether to apply the snapshot retention period to newly copied manual snapshots instead of automated snapshots.
  ##   Version: string (required)
  var query_616224 = newJObject()
  var formData_616225 = newJObject()
  add(formData_616225, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_616225, "RetentionPeriod", newJInt(RetentionPeriod))
  add(query_616224, "Action", newJString(Action))
  add(formData_616225, "Manual", newJBool(Manual))
  add(query_616224, "Version", newJString(Version))
  result = call_616223.call(nil, query_616224, nil, formData_616225, nil)

var postModifySnapshotCopyRetentionPeriod* = Call_PostModifySnapshotCopyRetentionPeriod_616207(
    name: "postModifySnapshotCopyRetentionPeriod", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=ModifySnapshotCopyRetentionPeriod",
    validator: validate_PostModifySnapshotCopyRetentionPeriod_616208, base: "/",
    url: url_PostModifySnapshotCopyRetentionPeriod_616209,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetModifySnapshotCopyRetentionPeriod_616189 = ref object of OpenApiRestCall_612642
proc url_GetModifySnapshotCopyRetentionPeriod_616191(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetModifySnapshotCopyRetentionPeriod_616190(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies the number of days to retain snapshots in the destination AWS Region after they are copied from the source AWS Region. By default, this operation only changes the retention period of copied automated snapshots. The retention periods for both new and existing copied automated snapshots are updated with the new retention period. You can set the manual option to change only the retention periods of copied manual snapshots. If you set this option, only newly copied manual snapshots have the new retention period. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Manual: JBool
  ##         : Indicates whether to apply the snapshot retention period to newly copied manual snapshots instead of automated snapshots.
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of the cluster for which you want to change the retention period for either automated or manual snapshots that are copied to a destination AWS Region.</p> <p>Constraints: Must be the valid name of an existing cluster that has cross-region snapshot copy enabled.</p>
  ##   Version: JString (required)
  ##   RetentionPeriod: JInt (required)
  ##                  : <p>The number of days to retain automated snapshots in the destination AWS Region after they are copied from the source AWS Region.</p> <p>By default, this only changes the retention period of copied automated snapshots. </p> <p>If you decrease the retention period for automated snapshots that are copied to a destination AWS Region, Amazon Redshift deletes any existing automated snapshots that were copied to the destination AWS Region and that fall outside of the new retention period.</p> <p>Constraints: Must be at least 1 and no more than 35 for automated snapshots. </p> <p>If you specify the <code>manual</code> option, only newly copied manual snapshots will have the new retention period. </p> <p>If you specify the value of -1 newly copied manual snapshots are retained indefinitely.</p> <p>Constraints: The number of days must be either -1 or an integer between 1 and 3,653 for manual snapshots.</p>
  section = newJObject()
  var valid_616192 = query.getOrDefault("Manual")
  valid_616192 = validateParameter(valid_616192, JBool, required = false, default = nil)
  if valid_616192 != nil:
    section.add "Manual", valid_616192
  var valid_616193 = query.getOrDefault("Action")
  valid_616193 = validateParameter(valid_616193, JString, required = true, default = newJString(
      "ModifySnapshotCopyRetentionPeriod"))
  if valid_616193 != nil:
    section.add "Action", valid_616193
  var valid_616194 = query.getOrDefault("ClusterIdentifier")
  valid_616194 = validateParameter(valid_616194, JString, required = true,
                                 default = nil)
  if valid_616194 != nil:
    section.add "ClusterIdentifier", valid_616194
  var valid_616195 = query.getOrDefault("Version")
  valid_616195 = validateParameter(valid_616195, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_616195 != nil:
    section.add "Version", valid_616195
  var valid_616196 = query.getOrDefault("RetentionPeriod")
  valid_616196 = validateParameter(valid_616196, JInt, required = true, default = nil)
  if valid_616196 != nil:
    section.add "RetentionPeriod", valid_616196
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_616197 = header.getOrDefault("X-Amz-Signature")
  valid_616197 = validateParameter(valid_616197, JString, required = false,
                                 default = nil)
  if valid_616197 != nil:
    section.add "X-Amz-Signature", valid_616197
  var valid_616198 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_616198 = validateParameter(valid_616198, JString, required = false,
                                 default = nil)
  if valid_616198 != nil:
    section.add "X-Amz-Content-Sha256", valid_616198
  var valid_616199 = header.getOrDefault("X-Amz-Date")
  valid_616199 = validateParameter(valid_616199, JString, required = false,
                                 default = nil)
  if valid_616199 != nil:
    section.add "X-Amz-Date", valid_616199
  var valid_616200 = header.getOrDefault("X-Amz-Credential")
  valid_616200 = validateParameter(valid_616200, JString, required = false,
                                 default = nil)
  if valid_616200 != nil:
    section.add "X-Amz-Credential", valid_616200
  var valid_616201 = header.getOrDefault("X-Amz-Security-Token")
  valid_616201 = validateParameter(valid_616201, JString, required = false,
                                 default = nil)
  if valid_616201 != nil:
    section.add "X-Amz-Security-Token", valid_616201
  var valid_616202 = header.getOrDefault("X-Amz-Algorithm")
  valid_616202 = validateParameter(valid_616202, JString, required = false,
                                 default = nil)
  if valid_616202 != nil:
    section.add "X-Amz-Algorithm", valid_616202
  var valid_616203 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_616203 = validateParameter(valid_616203, JString, required = false,
                                 default = nil)
  if valid_616203 != nil:
    section.add "X-Amz-SignedHeaders", valid_616203
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_616204: Call_GetModifySnapshotCopyRetentionPeriod_616189;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Modifies the number of days to retain snapshots in the destination AWS Region after they are copied from the source AWS Region. By default, this operation only changes the retention period of copied automated snapshots. The retention periods for both new and existing copied automated snapshots are updated with the new retention period. You can set the manual option to change only the retention periods of copied manual snapshots. If you set this option, only newly copied manual snapshots have the new retention period. 
  ## 
  let valid = call_616204.validator(path, query, header, formData, body)
  let scheme = call_616204.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_616204.url(scheme.get, call_616204.host, call_616204.base,
                         call_616204.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_616204, url, valid)

proc call*(call_616205: Call_GetModifySnapshotCopyRetentionPeriod_616189;
          ClusterIdentifier: string; RetentionPeriod: int; Manual: bool = false;
          Action: string = "ModifySnapshotCopyRetentionPeriod";
          Version: string = "2012-12-01"): Recallable =
  ## getModifySnapshotCopyRetentionPeriod
  ## Modifies the number of days to retain snapshots in the destination AWS Region after they are copied from the source AWS Region. By default, this operation only changes the retention period of copied automated snapshots. The retention periods for both new and existing copied automated snapshots are updated with the new retention period. You can set the manual option to change only the retention periods of copied manual snapshots. If you set this option, only newly copied manual snapshots have the new retention period. 
  ##   Manual: bool
  ##         : Indicates whether to apply the snapshot retention period to newly copied manual snapshots instead of automated snapshots.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of the cluster for which you want to change the retention period for either automated or manual snapshots that are copied to a destination AWS Region.</p> <p>Constraints: Must be the valid name of an existing cluster that has cross-region snapshot copy enabled.</p>
  ##   Version: string (required)
  ##   RetentionPeriod: int (required)
  ##                  : <p>The number of days to retain automated snapshots in the destination AWS Region after they are copied from the source AWS Region.</p> <p>By default, this only changes the retention period of copied automated snapshots. </p> <p>If you decrease the retention period for automated snapshots that are copied to a destination AWS Region, Amazon Redshift deletes any existing automated snapshots that were copied to the destination AWS Region and that fall outside of the new retention period.</p> <p>Constraints: Must be at least 1 and no more than 35 for automated snapshots. </p> <p>If you specify the <code>manual</code> option, only newly copied manual snapshots will have the new retention period. </p> <p>If you specify the value of -1 newly copied manual snapshots are retained indefinitely.</p> <p>Constraints: The number of days must be either -1 or an integer between 1 and 3,653 for manual snapshots.</p>
  var query_616206 = newJObject()
  add(query_616206, "Manual", newJBool(Manual))
  add(query_616206, "Action", newJString(Action))
  add(query_616206, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_616206, "Version", newJString(Version))
  add(query_616206, "RetentionPeriod", newJInt(RetentionPeriod))
  result = call_616205.call(nil, query_616206, nil, nil, nil)

var getModifySnapshotCopyRetentionPeriod* = Call_GetModifySnapshotCopyRetentionPeriod_616189(
    name: "getModifySnapshotCopyRetentionPeriod", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=ModifySnapshotCopyRetentionPeriod",
    validator: validate_GetModifySnapshotCopyRetentionPeriod_616190, base: "/",
    url: url_GetModifySnapshotCopyRetentionPeriod_616191,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostModifySnapshotSchedule_616243 = ref object of OpenApiRestCall_612642
proc url_PostModifySnapshotSchedule_616245(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostModifySnapshotSchedule_616244(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies a snapshot schedule. Any schedule associated with a cluster is modified asynchronously.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_616246 = query.getOrDefault("Action")
  valid_616246 = validateParameter(valid_616246, JString, required = true,
                                 default = newJString("ModifySnapshotSchedule"))
  if valid_616246 != nil:
    section.add "Action", valid_616246
  var valid_616247 = query.getOrDefault("Version")
  valid_616247 = validateParameter(valid_616247, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_616247 != nil:
    section.add "Version", valid_616247
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_616248 = header.getOrDefault("X-Amz-Signature")
  valid_616248 = validateParameter(valid_616248, JString, required = false,
                                 default = nil)
  if valid_616248 != nil:
    section.add "X-Amz-Signature", valid_616248
  var valid_616249 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_616249 = validateParameter(valid_616249, JString, required = false,
                                 default = nil)
  if valid_616249 != nil:
    section.add "X-Amz-Content-Sha256", valid_616249
  var valid_616250 = header.getOrDefault("X-Amz-Date")
  valid_616250 = validateParameter(valid_616250, JString, required = false,
                                 default = nil)
  if valid_616250 != nil:
    section.add "X-Amz-Date", valid_616250
  var valid_616251 = header.getOrDefault("X-Amz-Credential")
  valid_616251 = validateParameter(valid_616251, JString, required = false,
                                 default = nil)
  if valid_616251 != nil:
    section.add "X-Amz-Credential", valid_616251
  var valid_616252 = header.getOrDefault("X-Amz-Security-Token")
  valid_616252 = validateParameter(valid_616252, JString, required = false,
                                 default = nil)
  if valid_616252 != nil:
    section.add "X-Amz-Security-Token", valid_616252
  var valid_616253 = header.getOrDefault("X-Amz-Algorithm")
  valid_616253 = validateParameter(valid_616253, JString, required = false,
                                 default = nil)
  if valid_616253 != nil:
    section.add "X-Amz-Algorithm", valid_616253
  var valid_616254 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_616254 = validateParameter(valid_616254, JString, required = false,
                                 default = nil)
  if valid_616254 != nil:
    section.add "X-Amz-SignedHeaders", valid_616254
  result.add "header", section
  ## parameters in `formData` object:
  ##   ScheduleDefinitions: JArray (required)
  ##                      : An updated list of schedule definitions. A schedule definition is made up of schedule expressions, for example, "cron(30 12 *)" or "rate(12 hours)".
  ##   ScheduleIdentifier: JString (required)
  ##                     : A unique alphanumeric identifier of the schedule to modify.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ScheduleDefinitions` field"
  var valid_616255 = formData.getOrDefault("ScheduleDefinitions")
  valid_616255 = validateParameter(valid_616255, JArray, required = true, default = nil)
  if valid_616255 != nil:
    section.add "ScheduleDefinitions", valid_616255
  var valid_616256 = formData.getOrDefault("ScheduleIdentifier")
  valid_616256 = validateParameter(valid_616256, JString, required = true,
                                 default = nil)
  if valid_616256 != nil:
    section.add "ScheduleIdentifier", valid_616256
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_616257: Call_PostModifySnapshotSchedule_616243; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Modifies a snapshot schedule. Any schedule associated with a cluster is modified asynchronously.
  ## 
  let valid = call_616257.validator(path, query, header, formData, body)
  let scheme = call_616257.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_616257.url(scheme.get, call_616257.host, call_616257.base,
                         call_616257.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_616257, url, valid)

proc call*(call_616258: Call_PostModifySnapshotSchedule_616243;
          ScheduleDefinitions: JsonNode; ScheduleIdentifier: string;
          Action: string = "ModifySnapshotSchedule"; Version: string = "2012-12-01"): Recallable =
  ## postModifySnapshotSchedule
  ## Modifies a snapshot schedule. Any schedule associated with a cluster is modified asynchronously.
  ##   ScheduleDefinitions: JArray (required)
  ##                      : An updated list of schedule definitions. A schedule definition is made up of schedule expressions, for example, "cron(30 12 *)" or "rate(12 hours)".
  ##   Action: string (required)
  ##   ScheduleIdentifier: string (required)
  ##                     : A unique alphanumeric identifier of the schedule to modify.
  ##   Version: string (required)
  var query_616259 = newJObject()
  var formData_616260 = newJObject()
  if ScheduleDefinitions != nil:
    formData_616260.add "ScheduleDefinitions", ScheduleDefinitions
  add(query_616259, "Action", newJString(Action))
  add(formData_616260, "ScheduleIdentifier", newJString(ScheduleIdentifier))
  add(query_616259, "Version", newJString(Version))
  result = call_616258.call(nil, query_616259, nil, formData_616260, nil)

var postModifySnapshotSchedule* = Call_PostModifySnapshotSchedule_616243(
    name: "postModifySnapshotSchedule", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=ModifySnapshotSchedule",
    validator: validate_PostModifySnapshotSchedule_616244, base: "/",
    url: url_PostModifySnapshotSchedule_616245,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetModifySnapshotSchedule_616226 = ref object of OpenApiRestCall_612642
proc url_GetModifySnapshotSchedule_616228(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetModifySnapshotSchedule_616227(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies a snapshot schedule. Any schedule associated with a cluster is modified asynchronously.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ScheduleIdentifier: JString (required)
  ##                     : A unique alphanumeric identifier of the schedule to modify.
  ##   ScheduleDefinitions: JArray (required)
  ##                      : An updated list of schedule definitions. A schedule definition is made up of schedule expressions, for example, "cron(30 12 *)" or "rate(12 hours)".
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `ScheduleIdentifier` field"
  var valid_616229 = query.getOrDefault("ScheduleIdentifier")
  valid_616229 = validateParameter(valid_616229, JString, required = true,
                                 default = nil)
  if valid_616229 != nil:
    section.add "ScheduleIdentifier", valid_616229
  var valid_616230 = query.getOrDefault("ScheduleDefinitions")
  valid_616230 = validateParameter(valid_616230, JArray, required = true, default = nil)
  if valid_616230 != nil:
    section.add "ScheduleDefinitions", valid_616230
  var valid_616231 = query.getOrDefault("Action")
  valid_616231 = validateParameter(valid_616231, JString, required = true,
                                 default = newJString("ModifySnapshotSchedule"))
  if valid_616231 != nil:
    section.add "Action", valid_616231
  var valid_616232 = query.getOrDefault("Version")
  valid_616232 = validateParameter(valid_616232, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_616232 != nil:
    section.add "Version", valid_616232
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_616233 = header.getOrDefault("X-Amz-Signature")
  valid_616233 = validateParameter(valid_616233, JString, required = false,
                                 default = nil)
  if valid_616233 != nil:
    section.add "X-Amz-Signature", valid_616233
  var valid_616234 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_616234 = validateParameter(valid_616234, JString, required = false,
                                 default = nil)
  if valid_616234 != nil:
    section.add "X-Amz-Content-Sha256", valid_616234
  var valid_616235 = header.getOrDefault("X-Amz-Date")
  valid_616235 = validateParameter(valid_616235, JString, required = false,
                                 default = nil)
  if valid_616235 != nil:
    section.add "X-Amz-Date", valid_616235
  var valid_616236 = header.getOrDefault("X-Amz-Credential")
  valid_616236 = validateParameter(valid_616236, JString, required = false,
                                 default = nil)
  if valid_616236 != nil:
    section.add "X-Amz-Credential", valid_616236
  var valid_616237 = header.getOrDefault("X-Amz-Security-Token")
  valid_616237 = validateParameter(valid_616237, JString, required = false,
                                 default = nil)
  if valid_616237 != nil:
    section.add "X-Amz-Security-Token", valid_616237
  var valid_616238 = header.getOrDefault("X-Amz-Algorithm")
  valid_616238 = validateParameter(valid_616238, JString, required = false,
                                 default = nil)
  if valid_616238 != nil:
    section.add "X-Amz-Algorithm", valid_616238
  var valid_616239 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_616239 = validateParameter(valid_616239, JString, required = false,
                                 default = nil)
  if valid_616239 != nil:
    section.add "X-Amz-SignedHeaders", valid_616239
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_616240: Call_GetModifySnapshotSchedule_616226; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Modifies a snapshot schedule. Any schedule associated with a cluster is modified asynchronously.
  ## 
  let valid = call_616240.validator(path, query, header, formData, body)
  let scheme = call_616240.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_616240.url(scheme.get, call_616240.host, call_616240.base,
                         call_616240.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_616240, url, valid)

proc call*(call_616241: Call_GetModifySnapshotSchedule_616226;
          ScheduleIdentifier: string; ScheduleDefinitions: JsonNode;
          Action: string = "ModifySnapshotSchedule"; Version: string = "2012-12-01"): Recallable =
  ## getModifySnapshotSchedule
  ## Modifies a snapshot schedule. Any schedule associated with a cluster is modified asynchronously.
  ##   ScheduleIdentifier: string (required)
  ##                     : A unique alphanumeric identifier of the schedule to modify.
  ##   ScheduleDefinitions: JArray (required)
  ##                      : An updated list of schedule definitions. A schedule definition is made up of schedule expressions, for example, "cron(30 12 *)" or "rate(12 hours)".
  ##   Action: string (required)
  ##   Version: string (required)
  var query_616242 = newJObject()
  add(query_616242, "ScheduleIdentifier", newJString(ScheduleIdentifier))
  if ScheduleDefinitions != nil:
    query_616242.add "ScheduleDefinitions", ScheduleDefinitions
  add(query_616242, "Action", newJString(Action))
  add(query_616242, "Version", newJString(Version))
  result = call_616241.call(nil, query_616242, nil, nil, nil)

var getModifySnapshotSchedule* = Call_GetModifySnapshotSchedule_616226(
    name: "getModifySnapshotSchedule", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=ModifySnapshotSchedule",
    validator: validate_GetModifySnapshotSchedule_616227, base: "/",
    url: url_GetModifySnapshotSchedule_616228,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostPurchaseReservedNodeOffering_616278 = ref object of OpenApiRestCall_612642
proc url_PostPurchaseReservedNodeOffering_616280(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostPurchaseReservedNodeOffering_616279(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Allows you to purchase reserved nodes. Amazon Redshift offers a predefined set of reserved node offerings. You can purchase one or more of the offerings. You can call the <a>DescribeReservedNodeOfferings</a> API to obtain the available reserved node offerings. You can call this API by providing a specific reserved node offering and the number of nodes you want to reserve. </p> <p> For more information about reserved node offerings, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_616281 = query.getOrDefault("Action")
  valid_616281 = validateParameter(valid_616281, JString, required = true, default = newJString(
      "PurchaseReservedNodeOffering"))
  if valid_616281 != nil:
    section.add "Action", valid_616281
  var valid_616282 = query.getOrDefault("Version")
  valid_616282 = validateParameter(valid_616282, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_616282 != nil:
    section.add "Version", valid_616282
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_616283 = header.getOrDefault("X-Amz-Signature")
  valid_616283 = validateParameter(valid_616283, JString, required = false,
                                 default = nil)
  if valid_616283 != nil:
    section.add "X-Amz-Signature", valid_616283
  var valid_616284 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_616284 = validateParameter(valid_616284, JString, required = false,
                                 default = nil)
  if valid_616284 != nil:
    section.add "X-Amz-Content-Sha256", valid_616284
  var valid_616285 = header.getOrDefault("X-Amz-Date")
  valid_616285 = validateParameter(valid_616285, JString, required = false,
                                 default = nil)
  if valid_616285 != nil:
    section.add "X-Amz-Date", valid_616285
  var valid_616286 = header.getOrDefault("X-Amz-Credential")
  valid_616286 = validateParameter(valid_616286, JString, required = false,
                                 default = nil)
  if valid_616286 != nil:
    section.add "X-Amz-Credential", valid_616286
  var valid_616287 = header.getOrDefault("X-Amz-Security-Token")
  valid_616287 = validateParameter(valid_616287, JString, required = false,
                                 default = nil)
  if valid_616287 != nil:
    section.add "X-Amz-Security-Token", valid_616287
  var valid_616288 = header.getOrDefault("X-Amz-Algorithm")
  valid_616288 = validateParameter(valid_616288, JString, required = false,
                                 default = nil)
  if valid_616288 != nil:
    section.add "X-Amz-Algorithm", valid_616288
  var valid_616289 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_616289 = validateParameter(valid_616289, JString, required = false,
                                 default = nil)
  if valid_616289 != nil:
    section.add "X-Amz-SignedHeaders", valid_616289
  result.add "header", section
  ## parameters in `formData` object:
  ##   NodeCount: JInt
  ##            : <p>The number of reserved nodes that you want to purchase.</p> <p>Default: <code>1</code> </p>
  ##   ReservedNodeOfferingId: JString (required)
  ##                         : The unique identifier of the reserved node offering you want to purchase.
  section = newJObject()
  var valid_616290 = formData.getOrDefault("NodeCount")
  valid_616290 = validateParameter(valid_616290, JInt, required = false, default = nil)
  if valid_616290 != nil:
    section.add "NodeCount", valid_616290
  assert formData != nil, "formData argument is necessary due to required `ReservedNodeOfferingId` field"
  var valid_616291 = formData.getOrDefault("ReservedNodeOfferingId")
  valid_616291 = validateParameter(valid_616291, JString, required = true,
                                 default = nil)
  if valid_616291 != nil:
    section.add "ReservedNodeOfferingId", valid_616291
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_616292: Call_PostPurchaseReservedNodeOffering_616278;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Allows you to purchase reserved nodes. Amazon Redshift offers a predefined set of reserved node offerings. You can purchase one or more of the offerings. You can call the <a>DescribeReservedNodeOfferings</a> API to obtain the available reserved node offerings. You can call this API by providing a specific reserved node offering and the number of nodes you want to reserve. </p> <p> For more information about reserved node offerings, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_616292.validator(path, query, header, formData, body)
  let scheme = call_616292.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_616292.url(scheme.get, call_616292.host, call_616292.base,
                         call_616292.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_616292, url, valid)

proc call*(call_616293: Call_PostPurchaseReservedNodeOffering_616278;
          ReservedNodeOfferingId: string; NodeCount: int = 0;
          Action: string = "PurchaseReservedNodeOffering";
          Version: string = "2012-12-01"): Recallable =
  ## postPurchaseReservedNodeOffering
  ## <p>Allows you to purchase reserved nodes. Amazon Redshift offers a predefined set of reserved node offerings. You can purchase one or more of the offerings. You can call the <a>DescribeReservedNodeOfferings</a> API to obtain the available reserved node offerings. You can call this API by providing a specific reserved node offering and the number of nodes you want to reserve. </p> <p> For more information about reserved node offerings, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   NodeCount: int
  ##            : <p>The number of reserved nodes that you want to purchase.</p> <p>Default: <code>1</code> </p>
  ##   ReservedNodeOfferingId: string (required)
  ##                         : The unique identifier of the reserved node offering you want to purchase.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_616294 = newJObject()
  var formData_616295 = newJObject()
  add(formData_616295, "NodeCount", newJInt(NodeCount))
  add(formData_616295, "ReservedNodeOfferingId",
      newJString(ReservedNodeOfferingId))
  add(query_616294, "Action", newJString(Action))
  add(query_616294, "Version", newJString(Version))
  result = call_616293.call(nil, query_616294, nil, formData_616295, nil)

var postPurchaseReservedNodeOffering* = Call_PostPurchaseReservedNodeOffering_616278(
    name: "postPurchaseReservedNodeOffering", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=PurchaseReservedNodeOffering",
    validator: validate_PostPurchaseReservedNodeOffering_616279, base: "/",
    url: url_PostPurchaseReservedNodeOffering_616280,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetPurchaseReservedNodeOffering_616261 = ref object of OpenApiRestCall_612642
proc url_GetPurchaseReservedNodeOffering_616263(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetPurchaseReservedNodeOffering_616262(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Allows you to purchase reserved nodes. Amazon Redshift offers a predefined set of reserved node offerings. You can purchase one or more of the offerings. You can call the <a>DescribeReservedNodeOfferings</a> API to obtain the available reserved node offerings. You can call this API by providing a specific reserved node offering and the number of nodes you want to reserve. </p> <p> For more information about reserved node offerings, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ReservedNodeOfferingId: JString (required)
  ##                         : The unique identifier of the reserved node offering you want to purchase.
  ##   Action: JString (required)
  ##   Version: JString (required)
  ##   NodeCount: JInt
  ##            : <p>The number of reserved nodes that you want to purchase.</p> <p>Default: <code>1</code> </p>
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `ReservedNodeOfferingId` field"
  var valid_616264 = query.getOrDefault("ReservedNodeOfferingId")
  valid_616264 = validateParameter(valid_616264, JString, required = true,
                                 default = nil)
  if valid_616264 != nil:
    section.add "ReservedNodeOfferingId", valid_616264
  var valid_616265 = query.getOrDefault("Action")
  valid_616265 = validateParameter(valid_616265, JString, required = true, default = newJString(
      "PurchaseReservedNodeOffering"))
  if valid_616265 != nil:
    section.add "Action", valid_616265
  var valid_616266 = query.getOrDefault("Version")
  valid_616266 = validateParameter(valid_616266, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_616266 != nil:
    section.add "Version", valid_616266
  var valid_616267 = query.getOrDefault("NodeCount")
  valid_616267 = validateParameter(valid_616267, JInt, required = false, default = nil)
  if valid_616267 != nil:
    section.add "NodeCount", valid_616267
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_616268 = header.getOrDefault("X-Amz-Signature")
  valid_616268 = validateParameter(valid_616268, JString, required = false,
                                 default = nil)
  if valid_616268 != nil:
    section.add "X-Amz-Signature", valid_616268
  var valid_616269 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_616269 = validateParameter(valid_616269, JString, required = false,
                                 default = nil)
  if valid_616269 != nil:
    section.add "X-Amz-Content-Sha256", valid_616269
  var valid_616270 = header.getOrDefault("X-Amz-Date")
  valid_616270 = validateParameter(valid_616270, JString, required = false,
                                 default = nil)
  if valid_616270 != nil:
    section.add "X-Amz-Date", valid_616270
  var valid_616271 = header.getOrDefault("X-Amz-Credential")
  valid_616271 = validateParameter(valid_616271, JString, required = false,
                                 default = nil)
  if valid_616271 != nil:
    section.add "X-Amz-Credential", valid_616271
  var valid_616272 = header.getOrDefault("X-Amz-Security-Token")
  valid_616272 = validateParameter(valid_616272, JString, required = false,
                                 default = nil)
  if valid_616272 != nil:
    section.add "X-Amz-Security-Token", valid_616272
  var valid_616273 = header.getOrDefault("X-Amz-Algorithm")
  valid_616273 = validateParameter(valid_616273, JString, required = false,
                                 default = nil)
  if valid_616273 != nil:
    section.add "X-Amz-Algorithm", valid_616273
  var valid_616274 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_616274 = validateParameter(valid_616274, JString, required = false,
                                 default = nil)
  if valid_616274 != nil:
    section.add "X-Amz-SignedHeaders", valid_616274
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_616275: Call_GetPurchaseReservedNodeOffering_616261;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Allows you to purchase reserved nodes. Amazon Redshift offers a predefined set of reserved node offerings. You can purchase one or more of the offerings. You can call the <a>DescribeReservedNodeOfferings</a> API to obtain the available reserved node offerings. You can call this API by providing a specific reserved node offering and the number of nodes you want to reserve. </p> <p> For more information about reserved node offerings, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_616275.validator(path, query, header, formData, body)
  let scheme = call_616275.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_616275.url(scheme.get, call_616275.host, call_616275.base,
                         call_616275.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_616275, url, valid)

proc call*(call_616276: Call_GetPurchaseReservedNodeOffering_616261;
          ReservedNodeOfferingId: string;
          Action: string = "PurchaseReservedNodeOffering";
          Version: string = "2012-12-01"; NodeCount: int = 0): Recallable =
  ## getPurchaseReservedNodeOffering
  ## <p>Allows you to purchase reserved nodes. Amazon Redshift offers a predefined set of reserved node offerings. You can purchase one or more of the offerings. You can call the <a>DescribeReservedNodeOfferings</a> API to obtain the available reserved node offerings. You can call this API by providing a specific reserved node offering and the number of nodes you want to reserve. </p> <p> For more information about reserved node offerings, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   ReservedNodeOfferingId: string (required)
  ##                         : The unique identifier of the reserved node offering you want to purchase.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   NodeCount: int
  ##            : <p>The number of reserved nodes that you want to purchase.</p> <p>Default: <code>1</code> </p>
  var query_616277 = newJObject()
  add(query_616277, "ReservedNodeOfferingId", newJString(ReservedNodeOfferingId))
  add(query_616277, "Action", newJString(Action))
  add(query_616277, "Version", newJString(Version))
  add(query_616277, "NodeCount", newJInt(NodeCount))
  result = call_616276.call(nil, query_616277, nil, nil, nil)

var getPurchaseReservedNodeOffering* = Call_GetPurchaseReservedNodeOffering_616261(
    name: "getPurchaseReservedNodeOffering", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=PurchaseReservedNodeOffering",
    validator: validate_GetPurchaseReservedNodeOffering_616262, base: "/",
    url: url_GetPurchaseReservedNodeOffering_616263,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostRebootCluster_616312 = ref object of OpenApiRestCall_612642
proc url_PostRebootCluster_616314(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostRebootCluster_616313(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## Reboots a cluster. This action is taken as soon as possible. It results in a momentary outage to the cluster, during which the cluster status is set to <code>rebooting</code>. A cluster event is created when the reboot is completed. Any pending cluster modifications (see <a>ModifyCluster</a>) are applied at this reboot. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_616315 = query.getOrDefault("Action")
  valid_616315 = validateParameter(valid_616315, JString, required = true,
                                 default = newJString("RebootCluster"))
  if valid_616315 != nil:
    section.add "Action", valid_616315
  var valid_616316 = query.getOrDefault("Version")
  valid_616316 = validateParameter(valid_616316, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_616316 != nil:
    section.add "Version", valid_616316
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_616317 = header.getOrDefault("X-Amz-Signature")
  valid_616317 = validateParameter(valid_616317, JString, required = false,
                                 default = nil)
  if valid_616317 != nil:
    section.add "X-Amz-Signature", valid_616317
  var valid_616318 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_616318 = validateParameter(valid_616318, JString, required = false,
                                 default = nil)
  if valid_616318 != nil:
    section.add "X-Amz-Content-Sha256", valid_616318
  var valid_616319 = header.getOrDefault("X-Amz-Date")
  valid_616319 = validateParameter(valid_616319, JString, required = false,
                                 default = nil)
  if valid_616319 != nil:
    section.add "X-Amz-Date", valid_616319
  var valid_616320 = header.getOrDefault("X-Amz-Credential")
  valid_616320 = validateParameter(valid_616320, JString, required = false,
                                 default = nil)
  if valid_616320 != nil:
    section.add "X-Amz-Credential", valid_616320
  var valid_616321 = header.getOrDefault("X-Amz-Security-Token")
  valid_616321 = validateParameter(valid_616321, JString, required = false,
                                 default = nil)
  if valid_616321 != nil:
    section.add "X-Amz-Security-Token", valid_616321
  var valid_616322 = header.getOrDefault("X-Amz-Algorithm")
  valid_616322 = validateParameter(valid_616322, JString, required = false,
                                 default = nil)
  if valid_616322 != nil:
    section.add "X-Amz-Algorithm", valid_616322
  var valid_616323 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_616323 = validateParameter(valid_616323, JString, required = false,
                                 default = nil)
  if valid_616323 != nil:
    section.add "X-Amz-SignedHeaders", valid_616323
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : The cluster identifier.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_616324 = formData.getOrDefault("ClusterIdentifier")
  valid_616324 = validateParameter(valid_616324, JString, required = true,
                                 default = nil)
  if valid_616324 != nil:
    section.add "ClusterIdentifier", valid_616324
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_616325: Call_PostRebootCluster_616312; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Reboots a cluster. This action is taken as soon as possible. It results in a momentary outage to the cluster, during which the cluster status is set to <code>rebooting</code>. A cluster event is created when the reboot is completed. Any pending cluster modifications (see <a>ModifyCluster</a>) are applied at this reboot. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. 
  ## 
  let valid = call_616325.validator(path, query, header, formData, body)
  let scheme = call_616325.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_616325.url(scheme.get, call_616325.host, call_616325.base,
                         call_616325.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_616325, url, valid)

proc call*(call_616326: Call_PostRebootCluster_616312; ClusterIdentifier: string;
          Action: string = "RebootCluster"; Version: string = "2012-12-01"): Recallable =
  ## postRebootCluster
  ## Reboots a cluster. This action is taken as soon as possible. It results in a momentary outage to the cluster, during which the cluster status is set to <code>rebooting</code>. A cluster event is created when the reboot is completed. Any pending cluster modifications (see <a>ModifyCluster</a>) are applied at this reboot. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. 
  ##   ClusterIdentifier: string (required)
  ##                    : The cluster identifier.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_616327 = newJObject()
  var formData_616328 = newJObject()
  add(formData_616328, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_616327, "Action", newJString(Action))
  add(query_616327, "Version", newJString(Version))
  result = call_616326.call(nil, query_616327, nil, formData_616328, nil)

var postRebootCluster* = Call_PostRebootCluster_616312(name: "postRebootCluster",
    meth: HttpMethod.HttpPost, host: "redshift.amazonaws.com",
    route: "/#Action=RebootCluster", validator: validate_PostRebootCluster_616313,
    base: "/", url: url_PostRebootCluster_616314,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetRebootCluster_616296 = ref object of OpenApiRestCall_612642
proc url_GetRebootCluster_616298(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetRebootCluster_616297(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Reboots a cluster. This action is taken as soon as possible. It results in a momentary outage to the cluster, during which the cluster status is set to <code>rebooting</code>. A cluster event is created when the reboot is completed. Any pending cluster modifications (see <a>ModifyCluster</a>) are applied at this reboot. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : The cluster identifier.
  ##   Version: JString (required)
  section = newJObject()
  var valid_616299 = query.getOrDefault("Action")
  valid_616299 = validateParameter(valid_616299, JString, required = true,
                                 default = newJString("RebootCluster"))
  if valid_616299 != nil:
    section.add "Action", valid_616299
  var valid_616300 = query.getOrDefault("ClusterIdentifier")
  valid_616300 = validateParameter(valid_616300, JString, required = true,
                                 default = nil)
  if valid_616300 != nil:
    section.add "ClusterIdentifier", valid_616300
  var valid_616301 = query.getOrDefault("Version")
  valid_616301 = validateParameter(valid_616301, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_616301 != nil:
    section.add "Version", valid_616301
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_616302 = header.getOrDefault("X-Amz-Signature")
  valid_616302 = validateParameter(valid_616302, JString, required = false,
                                 default = nil)
  if valid_616302 != nil:
    section.add "X-Amz-Signature", valid_616302
  var valid_616303 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_616303 = validateParameter(valid_616303, JString, required = false,
                                 default = nil)
  if valid_616303 != nil:
    section.add "X-Amz-Content-Sha256", valid_616303
  var valid_616304 = header.getOrDefault("X-Amz-Date")
  valid_616304 = validateParameter(valid_616304, JString, required = false,
                                 default = nil)
  if valid_616304 != nil:
    section.add "X-Amz-Date", valid_616304
  var valid_616305 = header.getOrDefault("X-Amz-Credential")
  valid_616305 = validateParameter(valid_616305, JString, required = false,
                                 default = nil)
  if valid_616305 != nil:
    section.add "X-Amz-Credential", valid_616305
  var valid_616306 = header.getOrDefault("X-Amz-Security-Token")
  valid_616306 = validateParameter(valid_616306, JString, required = false,
                                 default = nil)
  if valid_616306 != nil:
    section.add "X-Amz-Security-Token", valid_616306
  var valid_616307 = header.getOrDefault("X-Amz-Algorithm")
  valid_616307 = validateParameter(valid_616307, JString, required = false,
                                 default = nil)
  if valid_616307 != nil:
    section.add "X-Amz-Algorithm", valid_616307
  var valid_616308 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_616308 = validateParameter(valid_616308, JString, required = false,
                                 default = nil)
  if valid_616308 != nil:
    section.add "X-Amz-SignedHeaders", valid_616308
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_616309: Call_GetRebootCluster_616296; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Reboots a cluster. This action is taken as soon as possible. It results in a momentary outage to the cluster, during which the cluster status is set to <code>rebooting</code>. A cluster event is created when the reboot is completed. Any pending cluster modifications (see <a>ModifyCluster</a>) are applied at this reboot. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. 
  ## 
  let valid = call_616309.validator(path, query, header, formData, body)
  let scheme = call_616309.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_616309.url(scheme.get, call_616309.host, call_616309.base,
                         call_616309.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_616309, url, valid)

proc call*(call_616310: Call_GetRebootCluster_616296; ClusterIdentifier: string;
          Action: string = "RebootCluster"; Version: string = "2012-12-01"): Recallable =
  ## getRebootCluster
  ## Reboots a cluster. This action is taken as soon as possible. It results in a momentary outage to the cluster, during which the cluster status is set to <code>rebooting</code>. A cluster event is created when the reboot is completed. Any pending cluster modifications (see <a>ModifyCluster</a>) are applied at this reboot. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. 
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : The cluster identifier.
  ##   Version: string (required)
  var query_616311 = newJObject()
  add(query_616311, "Action", newJString(Action))
  add(query_616311, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_616311, "Version", newJString(Version))
  result = call_616310.call(nil, query_616311, nil, nil, nil)

var getRebootCluster* = Call_GetRebootCluster_616296(name: "getRebootCluster",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=RebootCluster", validator: validate_GetRebootCluster_616297,
    base: "/", url: url_GetRebootCluster_616298,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostResetClusterParameterGroup_616347 = ref object of OpenApiRestCall_612642
proc url_PostResetClusterParameterGroup_616349(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostResetClusterParameterGroup_616348(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Sets one or more parameters of the specified parameter group to their default values and sets the source values of the parameters to "engine-default". To reset the entire parameter group specify the <i>ResetAllParameters</i> parameter. For parameter changes to take effect you must reboot any associated clusters. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_616350 = query.getOrDefault("Action")
  valid_616350 = validateParameter(valid_616350, JString, required = true, default = newJString(
      "ResetClusterParameterGroup"))
  if valid_616350 != nil:
    section.add "Action", valid_616350
  var valid_616351 = query.getOrDefault("Version")
  valid_616351 = validateParameter(valid_616351, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_616351 != nil:
    section.add "Version", valid_616351
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_616352 = header.getOrDefault("X-Amz-Signature")
  valid_616352 = validateParameter(valid_616352, JString, required = false,
                                 default = nil)
  if valid_616352 != nil:
    section.add "X-Amz-Signature", valid_616352
  var valid_616353 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_616353 = validateParameter(valid_616353, JString, required = false,
                                 default = nil)
  if valid_616353 != nil:
    section.add "X-Amz-Content-Sha256", valid_616353
  var valid_616354 = header.getOrDefault("X-Amz-Date")
  valid_616354 = validateParameter(valid_616354, JString, required = false,
                                 default = nil)
  if valid_616354 != nil:
    section.add "X-Amz-Date", valid_616354
  var valid_616355 = header.getOrDefault("X-Amz-Credential")
  valid_616355 = validateParameter(valid_616355, JString, required = false,
                                 default = nil)
  if valid_616355 != nil:
    section.add "X-Amz-Credential", valid_616355
  var valid_616356 = header.getOrDefault("X-Amz-Security-Token")
  valid_616356 = validateParameter(valid_616356, JString, required = false,
                                 default = nil)
  if valid_616356 != nil:
    section.add "X-Amz-Security-Token", valid_616356
  var valid_616357 = header.getOrDefault("X-Amz-Algorithm")
  valid_616357 = validateParameter(valid_616357, JString, required = false,
                                 default = nil)
  if valid_616357 != nil:
    section.add "X-Amz-Algorithm", valid_616357
  var valid_616358 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_616358 = validateParameter(valid_616358, JString, required = false,
                                 default = nil)
  if valid_616358 != nil:
    section.add "X-Amz-SignedHeaders", valid_616358
  result.add "header", section
  ## parameters in `formData` object:
  ##   ResetAllParameters: JBool
  ##                     : <p>If <code>true</code>, all parameters in the specified parameter group will be reset to their default values. </p> <p>Default: <code>true</code> </p>
  ##   Parameters: JArray
  ##             : <p>An array of names of parameters to be reset. If <i>ResetAllParameters</i> option is not used, then at least one parameter name must be supplied. </p> <p>Constraints: A maximum of 20 parameters can be reset in a single request.</p>
  ##   ParameterGroupName: JString (required)
  ##                     : The name of the cluster parameter group to be reset.
  section = newJObject()
  var valid_616359 = formData.getOrDefault("ResetAllParameters")
  valid_616359 = validateParameter(valid_616359, JBool, required = false, default = nil)
  if valid_616359 != nil:
    section.add "ResetAllParameters", valid_616359
  var valid_616360 = formData.getOrDefault("Parameters")
  valid_616360 = validateParameter(valid_616360, JArray, required = false,
                                 default = nil)
  if valid_616360 != nil:
    section.add "Parameters", valid_616360
  assert formData != nil, "formData argument is necessary due to required `ParameterGroupName` field"
  var valid_616361 = formData.getOrDefault("ParameterGroupName")
  valid_616361 = validateParameter(valid_616361, JString, required = true,
                                 default = nil)
  if valid_616361 != nil:
    section.add "ParameterGroupName", valid_616361
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_616362: Call_PostResetClusterParameterGroup_616347; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Sets one or more parameters of the specified parameter group to their default values and sets the source values of the parameters to "engine-default". To reset the entire parameter group specify the <i>ResetAllParameters</i> parameter. For parameter changes to take effect you must reboot any associated clusters. 
  ## 
  let valid = call_616362.validator(path, query, header, formData, body)
  let scheme = call_616362.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_616362.url(scheme.get, call_616362.host, call_616362.base,
                         call_616362.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_616362, url, valid)

proc call*(call_616363: Call_PostResetClusterParameterGroup_616347;
          ParameterGroupName: string; ResetAllParameters: bool = false;
          Action: string = "ResetClusterParameterGroup"; Parameters: JsonNode = nil;
          Version: string = "2012-12-01"): Recallable =
  ## postResetClusterParameterGroup
  ## Sets one or more parameters of the specified parameter group to their default values and sets the source values of the parameters to "engine-default". To reset the entire parameter group specify the <i>ResetAllParameters</i> parameter. For parameter changes to take effect you must reboot any associated clusters. 
  ##   ResetAllParameters: bool
  ##                     : <p>If <code>true</code>, all parameters in the specified parameter group will be reset to their default values. </p> <p>Default: <code>true</code> </p>
  ##   Action: string (required)
  ##   Parameters: JArray
  ##             : <p>An array of names of parameters to be reset. If <i>ResetAllParameters</i> option is not used, then at least one parameter name must be supplied. </p> <p>Constraints: A maximum of 20 parameters can be reset in a single request.</p>
  ##   ParameterGroupName: string (required)
  ##                     : The name of the cluster parameter group to be reset.
  ##   Version: string (required)
  var query_616364 = newJObject()
  var formData_616365 = newJObject()
  add(formData_616365, "ResetAllParameters", newJBool(ResetAllParameters))
  add(query_616364, "Action", newJString(Action))
  if Parameters != nil:
    formData_616365.add "Parameters", Parameters
  add(formData_616365, "ParameterGroupName", newJString(ParameterGroupName))
  add(query_616364, "Version", newJString(Version))
  result = call_616363.call(nil, query_616364, nil, formData_616365, nil)

var postResetClusterParameterGroup* = Call_PostResetClusterParameterGroup_616347(
    name: "postResetClusterParameterGroup", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=ResetClusterParameterGroup",
    validator: validate_PostResetClusterParameterGroup_616348, base: "/",
    url: url_PostResetClusterParameterGroup_616349,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetResetClusterParameterGroup_616329 = ref object of OpenApiRestCall_612642
proc url_GetResetClusterParameterGroup_616331(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetResetClusterParameterGroup_616330(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Sets one or more parameters of the specified parameter group to their default values and sets the source values of the parameters to "engine-default". To reset the entire parameter group specify the <i>ResetAllParameters</i> parameter. For parameter changes to take effect you must reboot any associated clusters. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Parameters: JArray
  ##             : <p>An array of names of parameters to be reset. If <i>ResetAllParameters</i> option is not used, then at least one parameter name must be supplied. </p> <p>Constraints: A maximum of 20 parameters can be reset in a single request.</p>
  ##   ResetAllParameters: JBool
  ##                     : <p>If <code>true</code>, all parameters in the specified parameter group will be reset to their default values. </p> <p>Default: <code>true</code> </p>
  ##   Action: JString (required)
  ##   ParameterGroupName: JString (required)
  ##                     : The name of the cluster parameter group to be reset.
  ##   Version: JString (required)
  section = newJObject()
  var valid_616332 = query.getOrDefault("Parameters")
  valid_616332 = validateParameter(valid_616332, JArray, required = false,
                                 default = nil)
  if valid_616332 != nil:
    section.add "Parameters", valid_616332
  var valid_616333 = query.getOrDefault("ResetAllParameters")
  valid_616333 = validateParameter(valid_616333, JBool, required = false, default = nil)
  if valid_616333 != nil:
    section.add "ResetAllParameters", valid_616333
  var valid_616334 = query.getOrDefault("Action")
  valid_616334 = validateParameter(valid_616334, JString, required = true, default = newJString(
      "ResetClusterParameterGroup"))
  if valid_616334 != nil:
    section.add "Action", valid_616334
  var valid_616335 = query.getOrDefault("ParameterGroupName")
  valid_616335 = validateParameter(valid_616335, JString, required = true,
                                 default = nil)
  if valid_616335 != nil:
    section.add "ParameterGroupName", valid_616335
  var valid_616336 = query.getOrDefault("Version")
  valid_616336 = validateParameter(valid_616336, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_616336 != nil:
    section.add "Version", valid_616336
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_616337 = header.getOrDefault("X-Amz-Signature")
  valid_616337 = validateParameter(valid_616337, JString, required = false,
                                 default = nil)
  if valid_616337 != nil:
    section.add "X-Amz-Signature", valid_616337
  var valid_616338 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_616338 = validateParameter(valid_616338, JString, required = false,
                                 default = nil)
  if valid_616338 != nil:
    section.add "X-Amz-Content-Sha256", valid_616338
  var valid_616339 = header.getOrDefault("X-Amz-Date")
  valid_616339 = validateParameter(valid_616339, JString, required = false,
                                 default = nil)
  if valid_616339 != nil:
    section.add "X-Amz-Date", valid_616339
  var valid_616340 = header.getOrDefault("X-Amz-Credential")
  valid_616340 = validateParameter(valid_616340, JString, required = false,
                                 default = nil)
  if valid_616340 != nil:
    section.add "X-Amz-Credential", valid_616340
  var valid_616341 = header.getOrDefault("X-Amz-Security-Token")
  valid_616341 = validateParameter(valid_616341, JString, required = false,
                                 default = nil)
  if valid_616341 != nil:
    section.add "X-Amz-Security-Token", valid_616341
  var valid_616342 = header.getOrDefault("X-Amz-Algorithm")
  valid_616342 = validateParameter(valid_616342, JString, required = false,
                                 default = nil)
  if valid_616342 != nil:
    section.add "X-Amz-Algorithm", valid_616342
  var valid_616343 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_616343 = validateParameter(valid_616343, JString, required = false,
                                 default = nil)
  if valid_616343 != nil:
    section.add "X-Amz-SignedHeaders", valid_616343
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_616344: Call_GetResetClusterParameterGroup_616329; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Sets one or more parameters of the specified parameter group to their default values and sets the source values of the parameters to "engine-default". To reset the entire parameter group specify the <i>ResetAllParameters</i> parameter. For parameter changes to take effect you must reboot any associated clusters. 
  ## 
  let valid = call_616344.validator(path, query, header, formData, body)
  let scheme = call_616344.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_616344.url(scheme.get, call_616344.host, call_616344.base,
                         call_616344.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_616344, url, valid)

proc call*(call_616345: Call_GetResetClusterParameterGroup_616329;
          ParameterGroupName: string; Parameters: JsonNode = nil;
          ResetAllParameters: bool = false;
          Action: string = "ResetClusterParameterGroup";
          Version: string = "2012-12-01"): Recallable =
  ## getResetClusterParameterGroup
  ## Sets one or more parameters of the specified parameter group to their default values and sets the source values of the parameters to "engine-default". To reset the entire parameter group specify the <i>ResetAllParameters</i> parameter. For parameter changes to take effect you must reboot any associated clusters. 
  ##   Parameters: JArray
  ##             : <p>An array of names of parameters to be reset. If <i>ResetAllParameters</i> option is not used, then at least one parameter name must be supplied. </p> <p>Constraints: A maximum of 20 parameters can be reset in a single request.</p>
  ##   ResetAllParameters: bool
  ##                     : <p>If <code>true</code>, all parameters in the specified parameter group will be reset to their default values. </p> <p>Default: <code>true</code> </p>
  ##   Action: string (required)
  ##   ParameterGroupName: string (required)
  ##                     : The name of the cluster parameter group to be reset.
  ##   Version: string (required)
  var query_616346 = newJObject()
  if Parameters != nil:
    query_616346.add "Parameters", Parameters
  add(query_616346, "ResetAllParameters", newJBool(ResetAllParameters))
  add(query_616346, "Action", newJString(Action))
  add(query_616346, "ParameterGroupName", newJString(ParameterGroupName))
  add(query_616346, "Version", newJString(Version))
  result = call_616345.call(nil, query_616346, nil, nil, nil)

var getResetClusterParameterGroup* = Call_GetResetClusterParameterGroup_616329(
    name: "getResetClusterParameterGroup", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=ResetClusterParameterGroup",
    validator: validate_GetResetClusterParameterGroup_616330, base: "/",
    url: url_GetResetClusterParameterGroup_616331,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostResizeCluster_616386 = ref object of OpenApiRestCall_612642
proc url_PostResizeCluster_616388(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostResizeCluster_616387(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## <p>Changes the size of the cluster. You can change the cluster's type, or change the number or type of nodes. The default behavior is to use the elastic resize method. With an elastic resize, your cluster is available for read and write operations more quickly than with the classic resize method. </p> <p>Elastic resize operations have the following restrictions:</p> <ul> <li> <p>You can only resize clusters of the following types:</p> <ul> <li> <p>dc2.large</p> </li> <li> <p>dc2.8xlarge</p> </li> <li> <p>ds2.xlarge</p> </li> <li> <p>ds2.8xlarge</p> </li> <li> <p>ra3.16xlarge</p> </li> </ul> </li> <li> <p>The type of nodes that you add must match the node type for the cluster.</p> </li> </ul>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_616389 = query.getOrDefault("Action")
  valid_616389 = validateParameter(valid_616389, JString, required = true,
                                 default = newJString("ResizeCluster"))
  if valid_616389 != nil:
    section.add "Action", valid_616389
  var valid_616390 = query.getOrDefault("Version")
  valid_616390 = validateParameter(valid_616390, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_616390 != nil:
    section.add "Version", valid_616390
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_616391 = header.getOrDefault("X-Amz-Signature")
  valid_616391 = validateParameter(valid_616391, JString, required = false,
                                 default = nil)
  if valid_616391 != nil:
    section.add "X-Amz-Signature", valid_616391
  var valid_616392 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_616392 = validateParameter(valid_616392, JString, required = false,
                                 default = nil)
  if valid_616392 != nil:
    section.add "X-Amz-Content-Sha256", valid_616392
  var valid_616393 = header.getOrDefault("X-Amz-Date")
  valid_616393 = validateParameter(valid_616393, JString, required = false,
                                 default = nil)
  if valid_616393 != nil:
    section.add "X-Amz-Date", valid_616393
  var valid_616394 = header.getOrDefault("X-Amz-Credential")
  valid_616394 = validateParameter(valid_616394, JString, required = false,
                                 default = nil)
  if valid_616394 != nil:
    section.add "X-Amz-Credential", valid_616394
  var valid_616395 = header.getOrDefault("X-Amz-Security-Token")
  valid_616395 = validateParameter(valid_616395, JString, required = false,
                                 default = nil)
  if valid_616395 != nil:
    section.add "X-Amz-Security-Token", valid_616395
  var valid_616396 = header.getOrDefault("X-Amz-Algorithm")
  valid_616396 = validateParameter(valid_616396, JString, required = false,
                                 default = nil)
  if valid_616396 != nil:
    section.add "X-Amz-Algorithm", valid_616396
  var valid_616397 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_616397 = validateParameter(valid_616397, JString, required = false,
                                 default = nil)
  if valid_616397 != nil:
    section.add "X-Amz-SignedHeaders", valid_616397
  result.add "header", section
  ## parameters in `formData` object:
  ##   NodeType: JString
  ##           : The new node type for the nodes you are adding. If not specified, the cluster's current node type is used.
  ##   ClusterIdentifier: JString (required)
  ##                    : The unique identifier for the cluster to resize.
  ##   NumberOfNodes: JInt (required)
  ##                : The new number of nodes for the cluster.
  ##   ClusterType: JString
  ##              : The new cluster type for the specified cluster.
  ##   Classic: JBool
  ##          : A boolean value indicating whether the resize operation is using the classic resize process. If you don't provide this parameter or set the value to <code>false</code>, the resize type is elastic. 
  section = newJObject()
  var valid_616398 = formData.getOrDefault("NodeType")
  valid_616398 = validateParameter(valid_616398, JString, required = false,
                                 default = nil)
  if valid_616398 != nil:
    section.add "NodeType", valid_616398
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_616399 = formData.getOrDefault("ClusterIdentifier")
  valid_616399 = validateParameter(valid_616399, JString, required = true,
                                 default = nil)
  if valid_616399 != nil:
    section.add "ClusterIdentifier", valid_616399
  var valid_616400 = formData.getOrDefault("NumberOfNodes")
  valid_616400 = validateParameter(valid_616400, JInt, required = true, default = nil)
  if valid_616400 != nil:
    section.add "NumberOfNodes", valid_616400
  var valid_616401 = formData.getOrDefault("ClusterType")
  valid_616401 = validateParameter(valid_616401, JString, required = false,
                                 default = nil)
  if valid_616401 != nil:
    section.add "ClusterType", valid_616401
  var valid_616402 = formData.getOrDefault("Classic")
  valid_616402 = validateParameter(valid_616402, JBool, required = false, default = nil)
  if valid_616402 != nil:
    section.add "Classic", valid_616402
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_616403: Call_PostResizeCluster_616386; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Changes the size of the cluster. You can change the cluster's type, or change the number or type of nodes. The default behavior is to use the elastic resize method. With an elastic resize, your cluster is available for read and write operations more quickly than with the classic resize method. </p> <p>Elastic resize operations have the following restrictions:</p> <ul> <li> <p>You can only resize clusters of the following types:</p> <ul> <li> <p>dc2.large</p> </li> <li> <p>dc2.8xlarge</p> </li> <li> <p>ds2.xlarge</p> </li> <li> <p>ds2.8xlarge</p> </li> <li> <p>ra3.16xlarge</p> </li> </ul> </li> <li> <p>The type of nodes that you add must match the node type for the cluster.</p> </li> </ul>
  ## 
  let valid = call_616403.validator(path, query, header, formData, body)
  let scheme = call_616403.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_616403.url(scheme.get, call_616403.host, call_616403.base,
                         call_616403.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_616403, url, valid)

proc call*(call_616404: Call_PostResizeCluster_616386; ClusterIdentifier: string;
          NumberOfNodes: int; NodeType: string = ""; Action: string = "ResizeCluster";
          ClusterType: string = ""; Version: string = "2012-12-01";
          Classic: bool = false): Recallable =
  ## postResizeCluster
  ## <p>Changes the size of the cluster. You can change the cluster's type, or change the number or type of nodes. The default behavior is to use the elastic resize method. With an elastic resize, your cluster is available for read and write operations more quickly than with the classic resize method. </p> <p>Elastic resize operations have the following restrictions:</p> <ul> <li> <p>You can only resize clusters of the following types:</p> <ul> <li> <p>dc2.large</p> </li> <li> <p>dc2.8xlarge</p> </li> <li> <p>ds2.xlarge</p> </li> <li> <p>ds2.8xlarge</p> </li> <li> <p>ra3.16xlarge</p> </li> </ul> </li> <li> <p>The type of nodes that you add must match the node type for the cluster.</p> </li> </ul>
  ##   NodeType: string
  ##           : The new node type for the nodes you are adding. If not specified, the cluster's current node type is used.
  ##   ClusterIdentifier: string (required)
  ##                    : The unique identifier for the cluster to resize.
  ##   NumberOfNodes: int (required)
  ##                : The new number of nodes for the cluster.
  ##   Action: string (required)
  ##   ClusterType: string
  ##              : The new cluster type for the specified cluster.
  ##   Version: string (required)
  ##   Classic: bool
  ##          : A boolean value indicating whether the resize operation is using the classic resize process. If you don't provide this parameter or set the value to <code>false</code>, the resize type is elastic. 
  var query_616405 = newJObject()
  var formData_616406 = newJObject()
  add(formData_616406, "NodeType", newJString(NodeType))
  add(formData_616406, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_616406, "NumberOfNodes", newJInt(NumberOfNodes))
  add(query_616405, "Action", newJString(Action))
  add(formData_616406, "ClusterType", newJString(ClusterType))
  add(query_616405, "Version", newJString(Version))
  add(formData_616406, "Classic", newJBool(Classic))
  result = call_616404.call(nil, query_616405, nil, formData_616406, nil)

var postResizeCluster* = Call_PostResizeCluster_616386(name: "postResizeCluster",
    meth: HttpMethod.HttpPost, host: "redshift.amazonaws.com",
    route: "/#Action=ResizeCluster", validator: validate_PostResizeCluster_616387,
    base: "/", url: url_PostResizeCluster_616388,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetResizeCluster_616366 = ref object of OpenApiRestCall_612642
proc url_GetResizeCluster_616368(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetResizeCluster_616367(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## <p>Changes the size of the cluster. You can change the cluster's type, or change the number or type of nodes. The default behavior is to use the elastic resize method. With an elastic resize, your cluster is available for read and write operations more quickly than with the classic resize method. </p> <p>Elastic resize operations have the following restrictions:</p> <ul> <li> <p>You can only resize clusters of the following types:</p> <ul> <li> <p>dc2.large</p> </li> <li> <p>dc2.8xlarge</p> </li> <li> <p>ds2.xlarge</p> </li> <li> <p>ds2.8xlarge</p> </li> <li> <p>ra3.16xlarge</p> </li> </ul> </li> <li> <p>The type of nodes that you add must match the node type for the cluster.</p> </li> </ul>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   NodeType: JString
  ##           : The new node type for the nodes you are adding. If not specified, the cluster's current node type is used.
  ##   ClusterType: JString
  ##              : The new cluster type for the specified cluster.
  ##   NumberOfNodes: JInt (required)
  ##                : The new number of nodes for the cluster.
  ##   Classic: JBool
  ##          : A boolean value indicating whether the resize operation is using the classic resize process. If you don't provide this parameter or set the value to <code>false</code>, the resize type is elastic. 
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : The unique identifier for the cluster to resize.
  ##   Version: JString (required)
  section = newJObject()
  var valid_616369 = query.getOrDefault("NodeType")
  valid_616369 = validateParameter(valid_616369, JString, required = false,
                                 default = nil)
  if valid_616369 != nil:
    section.add "NodeType", valid_616369
  var valid_616370 = query.getOrDefault("ClusterType")
  valid_616370 = validateParameter(valid_616370, JString, required = false,
                                 default = nil)
  if valid_616370 != nil:
    section.add "ClusterType", valid_616370
  assert query != nil,
        "query argument is necessary due to required `NumberOfNodes` field"
  var valid_616371 = query.getOrDefault("NumberOfNodes")
  valid_616371 = validateParameter(valid_616371, JInt, required = true, default = nil)
  if valid_616371 != nil:
    section.add "NumberOfNodes", valid_616371
  var valid_616372 = query.getOrDefault("Classic")
  valid_616372 = validateParameter(valid_616372, JBool, required = false, default = nil)
  if valid_616372 != nil:
    section.add "Classic", valid_616372
  var valid_616373 = query.getOrDefault("Action")
  valid_616373 = validateParameter(valid_616373, JString, required = true,
                                 default = newJString("ResizeCluster"))
  if valid_616373 != nil:
    section.add "Action", valid_616373
  var valid_616374 = query.getOrDefault("ClusterIdentifier")
  valid_616374 = validateParameter(valid_616374, JString, required = true,
                                 default = nil)
  if valid_616374 != nil:
    section.add "ClusterIdentifier", valid_616374
  var valid_616375 = query.getOrDefault("Version")
  valid_616375 = validateParameter(valid_616375, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_616375 != nil:
    section.add "Version", valid_616375
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_616376 = header.getOrDefault("X-Amz-Signature")
  valid_616376 = validateParameter(valid_616376, JString, required = false,
                                 default = nil)
  if valid_616376 != nil:
    section.add "X-Amz-Signature", valid_616376
  var valid_616377 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_616377 = validateParameter(valid_616377, JString, required = false,
                                 default = nil)
  if valid_616377 != nil:
    section.add "X-Amz-Content-Sha256", valid_616377
  var valid_616378 = header.getOrDefault("X-Amz-Date")
  valid_616378 = validateParameter(valid_616378, JString, required = false,
                                 default = nil)
  if valid_616378 != nil:
    section.add "X-Amz-Date", valid_616378
  var valid_616379 = header.getOrDefault("X-Amz-Credential")
  valid_616379 = validateParameter(valid_616379, JString, required = false,
                                 default = nil)
  if valid_616379 != nil:
    section.add "X-Amz-Credential", valid_616379
  var valid_616380 = header.getOrDefault("X-Amz-Security-Token")
  valid_616380 = validateParameter(valid_616380, JString, required = false,
                                 default = nil)
  if valid_616380 != nil:
    section.add "X-Amz-Security-Token", valid_616380
  var valid_616381 = header.getOrDefault("X-Amz-Algorithm")
  valid_616381 = validateParameter(valid_616381, JString, required = false,
                                 default = nil)
  if valid_616381 != nil:
    section.add "X-Amz-Algorithm", valid_616381
  var valid_616382 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_616382 = validateParameter(valid_616382, JString, required = false,
                                 default = nil)
  if valid_616382 != nil:
    section.add "X-Amz-SignedHeaders", valid_616382
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_616383: Call_GetResizeCluster_616366; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Changes the size of the cluster. You can change the cluster's type, or change the number or type of nodes. The default behavior is to use the elastic resize method. With an elastic resize, your cluster is available for read and write operations more quickly than with the classic resize method. </p> <p>Elastic resize operations have the following restrictions:</p> <ul> <li> <p>You can only resize clusters of the following types:</p> <ul> <li> <p>dc2.large</p> </li> <li> <p>dc2.8xlarge</p> </li> <li> <p>ds2.xlarge</p> </li> <li> <p>ds2.8xlarge</p> </li> <li> <p>ra3.16xlarge</p> </li> </ul> </li> <li> <p>The type of nodes that you add must match the node type for the cluster.</p> </li> </ul>
  ## 
  let valid = call_616383.validator(path, query, header, formData, body)
  let scheme = call_616383.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_616383.url(scheme.get, call_616383.host, call_616383.base,
                         call_616383.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_616383, url, valid)

proc call*(call_616384: Call_GetResizeCluster_616366; NumberOfNodes: int;
          ClusterIdentifier: string; NodeType: string = ""; ClusterType: string = "";
          Classic: bool = false; Action: string = "ResizeCluster";
          Version: string = "2012-12-01"): Recallable =
  ## getResizeCluster
  ## <p>Changes the size of the cluster. You can change the cluster's type, or change the number or type of nodes. The default behavior is to use the elastic resize method. With an elastic resize, your cluster is available for read and write operations more quickly than with the classic resize method. </p> <p>Elastic resize operations have the following restrictions:</p> <ul> <li> <p>You can only resize clusters of the following types:</p> <ul> <li> <p>dc2.large</p> </li> <li> <p>dc2.8xlarge</p> </li> <li> <p>ds2.xlarge</p> </li> <li> <p>ds2.8xlarge</p> </li> <li> <p>ra3.16xlarge</p> </li> </ul> </li> <li> <p>The type of nodes that you add must match the node type for the cluster.</p> </li> </ul>
  ##   NodeType: string
  ##           : The new node type for the nodes you are adding. If not specified, the cluster's current node type is used.
  ##   ClusterType: string
  ##              : The new cluster type for the specified cluster.
  ##   NumberOfNodes: int (required)
  ##                : The new number of nodes for the cluster.
  ##   Classic: bool
  ##          : A boolean value indicating whether the resize operation is using the classic resize process. If you don't provide this parameter or set the value to <code>false</code>, the resize type is elastic. 
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : The unique identifier for the cluster to resize.
  ##   Version: string (required)
  var query_616385 = newJObject()
  add(query_616385, "NodeType", newJString(NodeType))
  add(query_616385, "ClusterType", newJString(ClusterType))
  add(query_616385, "NumberOfNodes", newJInt(NumberOfNodes))
  add(query_616385, "Classic", newJBool(Classic))
  add(query_616385, "Action", newJString(Action))
  add(query_616385, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_616385, "Version", newJString(Version))
  result = call_616384.call(nil, query_616385, nil, nil, nil)

var getResizeCluster* = Call_GetResizeCluster_616366(name: "getResizeCluster",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=ResizeCluster", validator: validate_GetResizeCluster_616367,
    base: "/", url: url_GetResizeCluster_616368,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostRestoreFromClusterSnapshot_616448 = ref object of OpenApiRestCall_612642
proc url_PostRestoreFromClusterSnapshot_616450(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostRestoreFromClusterSnapshot_616449(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a new cluster from a snapshot. By default, Amazon Redshift creates the resulting cluster with the same configuration as the original cluster from which the snapshot was created, except that the new cluster is created with the default cluster security and parameter groups. After Amazon Redshift creates the cluster, you can use the <a>ModifyCluster</a> API to associate a different security group and different parameter group with the restored cluster. If you are using a DS node type, you can also choose to change to another DS node type of the same size during restore.</p> <p>If you restore a cluster into a VPC, you must provide a cluster subnet group where you want the cluster restored.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_616451 = query.getOrDefault("Action")
  valid_616451 = validateParameter(valid_616451, JString, required = true, default = newJString(
      "RestoreFromClusterSnapshot"))
  if valid_616451 != nil:
    section.add "Action", valid_616451
  var valid_616452 = query.getOrDefault("Version")
  valid_616452 = validateParameter(valid_616452, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_616452 != nil:
    section.add "Version", valid_616452
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_616453 = header.getOrDefault("X-Amz-Signature")
  valid_616453 = validateParameter(valid_616453, JString, required = false,
                                 default = nil)
  if valid_616453 != nil:
    section.add "X-Amz-Signature", valid_616453
  var valid_616454 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_616454 = validateParameter(valid_616454, JString, required = false,
                                 default = nil)
  if valid_616454 != nil:
    section.add "X-Amz-Content-Sha256", valid_616454
  var valid_616455 = header.getOrDefault("X-Amz-Date")
  valid_616455 = validateParameter(valid_616455, JString, required = false,
                                 default = nil)
  if valid_616455 != nil:
    section.add "X-Amz-Date", valid_616455
  var valid_616456 = header.getOrDefault("X-Amz-Credential")
  valid_616456 = validateParameter(valid_616456, JString, required = false,
                                 default = nil)
  if valid_616456 != nil:
    section.add "X-Amz-Credential", valid_616456
  var valid_616457 = header.getOrDefault("X-Amz-Security-Token")
  valid_616457 = validateParameter(valid_616457, JString, required = false,
                                 default = nil)
  if valid_616457 != nil:
    section.add "X-Amz-Security-Token", valid_616457
  var valid_616458 = header.getOrDefault("X-Amz-Algorithm")
  valid_616458 = validateParameter(valid_616458, JString, required = false,
                                 default = nil)
  if valid_616458 != nil:
    section.add "X-Amz-Algorithm", valid_616458
  var valid_616459 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_616459 = validateParameter(valid_616459, JString, required = false,
                                 default = nil)
  if valid_616459 != nil:
    section.add "X-Amz-SignedHeaders", valid_616459
  result.add "header", section
  ## parameters in `formData` object:
  ##   Port: JInt
  ##       : <p>The port number on which the cluster accepts connections.</p> <p>Default: The same port as the original cluster.</p> <p>Constraints: Must be between <code>1115</code> and <code>65535</code>.</p>
  ##   PreferredMaintenanceWindow: JString
  ##                             : <p>The weekly time range (in UTC) during which automated cluster maintenance can occur.</p> <p> Format: <code>ddd:hh24:mi-ddd:hh24:mi</code> </p> <p> Default: The value selected for the cluster from which the snapshot was taken. For more information about the time blocks for each region, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-maintenance-windows">Maintenance Windows</a> in Amazon Redshift Cluster Management Guide. </p> <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p> <p>Constraints: Minimum 30-minute window.</p>
  ##   NodeType: JString
  ##           : <p>The node type that the restored cluster will be provisioned with.</p> <p>Default: The node type of the cluster from which the snapshot was taken. You can modify this if you are using any DS node type. In that case, you can choose to restore into another DS node type of the same size. For example, you can restore ds1.8xlarge into ds2.8xlarge, or ds1.xlarge into ds2.xlarge. If you have a DC instance type, you must restore into that same instance type and size. In other words, you can only restore a dc1.large instance type into another dc1.large instance type or dc2.large instance type. You can't restore dc1.8xlarge to dc2.8xlarge. First restore to a dc1.8xlareg cluster, then resize to a dc2.8large cluster. For more information about node types, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-about-clusters-and-nodes"> About Clusters and Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The identifier of the cluster that will be created from restoring the snapshot.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul>
  ##   MaintenanceTrackName: JString
  ##                       : The name of the maintenance track for the restored cluster. When you take a snapshot, the snapshot inherits the <code>MaintenanceTrack</code> value from the cluster. The snapshot might be on a different track than the cluster that was the source for the snapshot. For example, suppose that you take a snapshot of a cluster that is on the current track and then change the cluster to be on the trailing track. In this case, the snapshot and the source cluster are on different tracks.
  ##   ClusterSecurityGroups: JArray
  ##                        : <p>A list of security groups to be associated with this cluster.</p> <p>Default: The default cluster security group for Amazon Redshift.</p> <p>Cluster security groups only apply to clusters outside of VPCs.</p>
  ##   IamRoles: JArray
  ##           : <p>A list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services. You must supply the IAM roles in their Amazon Resource Name (ARN) format. You can supply up to 10 IAM roles in a single request.</p> <p>A cluster can have up to 10 IAM roles associated at any time.</p>
  ##   OwnerAccount: JString
  ##               : The AWS customer account used to create or copy the snapshot. Required if you are restoring a snapshot you do not own, optional if you own the snapshot.
  ##   VpcSecurityGroupIds: JArray
  ##                      : <p>A list of Virtual Private Cloud (VPC) security groups to be associated with the cluster.</p> <p>Default: The default VPC security group is associated with the cluster.</p> <p>VPC security groups only apply to clusters in VPCs.</p>
  ##   AutomatedSnapshotRetentionPeriod: JInt
  ##                                   : <p>The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p> <p>Default: The value selected for the cluster from which the snapshot was taken.</p> <p>Constraints: Must be a value from 0 to 35.</p>
  ##   AvailabilityZone: JString
  ##                   : <p>The Amazon EC2 Availability Zone in which to restore the cluster.</p> <p>Default: A random, system-chosen Availability Zone.</p> <p>Example: <code>us-east-2a</code> </p>
  ##   EnhancedVpcRouting: JBool
  ##                     : <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p> <p>Default: false</p>
  ##   KmsKeyId: JString
  ##           : The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster that you restore from a shared snapshot.
  ##   NumberOfNodes: JInt
  ##                : The number of nodes specified when provisioning the restored cluster.
  ##   ClusterSubnetGroupName: JString
  ##                         : <p>The name of the subnet group where you want to cluster restored.</p> <p>A snapshot of cluster in VPC can be restored only in VPC. Therefore, you must provide subnet group name where you want the cluster restored.</p>
  ##   AllowVersionUpgrade: JBool
  ##                      : <p>If <code>true</code>, major version upgrades can be applied during the maintenance window to the Amazon Redshift engine that is running on the cluster. </p> <p>Default: <code>true</code> </p>
  ##   SnapshotIdentifier: JString (required)
  ##                     : <p>The name of the snapshot from which to create the new cluster. This parameter isn't case sensitive.</p> <p>Example: <code>my-snapshot-id</code> </p>
  ##   PubliclyAccessible: JBool
  ##                     : If <code>true</code>, the cluster can be accessed from a public network. 
  ##   ClusterParameterGroupName: JString
  ##                            : <p>The name of the parameter group to be associated with this cluster.</p> <p>Default: The default Amazon Redshift cluster parameter group. For information about the default parameter group, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Working with Amazon Redshift Parameter Groups</a>.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   HsmClientCertificateIdentifier: JString
  ##                                 : Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM.
  ##   SnapshotClusterIdentifier: JString
  ##                            : The name of the cluster the source snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.
  ##   AdditionalInfo: JString
  ##                 : Reserved.
  ##   SnapshotScheduleIdentifier: JString
  ##                             : A unique identifier for the snapshot schedule.
  ##   ElasticIp: JString
  ##            : The elastic IP (EIP) address for the cluster.
  ##   HsmConfigurationIdentifier: JString
  ##                             : Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The default number of days to retain a manual snapshot. If the value is -1, the snapshot is retained indefinitely. This setting doesn't change the retention period of existing snapshots.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  section = newJObject()
  var valid_616460 = formData.getOrDefault("Port")
  valid_616460 = validateParameter(valid_616460, JInt, required = false, default = nil)
  if valid_616460 != nil:
    section.add "Port", valid_616460
  var valid_616461 = formData.getOrDefault("PreferredMaintenanceWindow")
  valid_616461 = validateParameter(valid_616461, JString, required = false,
                                 default = nil)
  if valid_616461 != nil:
    section.add "PreferredMaintenanceWindow", valid_616461
  var valid_616462 = formData.getOrDefault("NodeType")
  valid_616462 = validateParameter(valid_616462, JString, required = false,
                                 default = nil)
  if valid_616462 != nil:
    section.add "NodeType", valid_616462
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_616463 = formData.getOrDefault("ClusterIdentifier")
  valid_616463 = validateParameter(valid_616463, JString, required = true,
                                 default = nil)
  if valid_616463 != nil:
    section.add "ClusterIdentifier", valid_616463
  var valid_616464 = formData.getOrDefault("MaintenanceTrackName")
  valid_616464 = validateParameter(valid_616464, JString, required = false,
                                 default = nil)
  if valid_616464 != nil:
    section.add "MaintenanceTrackName", valid_616464
  var valid_616465 = formData.getOrDefault("ClusterSecurityGroups")
  valid_616465 = validateParameter(valid_616465, JArray, required = false,
                                 default = nil)
  if valid_616465 != nil:
    section.add "ClusterSecurityGroups", valid_616465
  var valid_616466 = formData.getOrDefault("IamRoles")
  valid_616466 = validateParameter(valid_616466, JArray, required = false,
                                 default = nil)
  if valid_616466 != nil:
    section.add "IamRoles", valid_616466
  var valid_616467 = formData.getOrDefault("OwnerAccount")
  valid_616467 = validateParameter(valid_616467, JString, required = false,
                                 default = nil)
  if valid_616467 != nil:
    section.add "OwnerAccount", valid_616467
  var valid_616468 = formData.getOrDefault("VpcSecurityGroupIds")
  valid_616468 = validateParameter(valid_616468, JArray, required = false,
                                 default = nil)
  if valid_616468 != nil:
    section.add "VpcSecurityGroupIds", valid_616468
  var valid_616469 = formData.getOrDefault("AutomatedSnapshotRetentionPeriod")
  valid_616469 = validateParameter(valid_616469, JInt, required = false, default = nil)
  if valid_616469 != nil:
    section.add "AutomatedSnapshotRetentionPeriod", valid_616469
  var valid_616470 = formData.getOrDefault("AvailabilityZone")
  valid_616470 = validateParameter(valid_616470, JString, required = false,
                                 default = nil)
  if valid_616470 != nil:
    section.add "AvailabilityZone", valid_616470
  var valid_616471 = formData.getOrDefault("EnhancedVpcRouting")
  valid_616471 = validateParameter(valid_616471, JBool, required = false, default = nil)
  if valid_616471 != nil:
    section.add "EnhancedVpcRouting", valid_616471
  var valid_616472 = formData.getOrDefault("KmsKeyId")
  valid_616472 = validateParameter(valid_616472, JString, required = false,
                                 default = nil)
  if valid_616472 != nil:
    section.add "KmsKeyId", valid_616472
  var valid_616473 = formData.getOrDefault("NumberOfNodes")
  valid_616473 = validateParameter(valid_616473, JInt, required = false, default = nil)
  if valid_616473 != nil:
    section.add "NumberOfNodes", valid_616473
  var valid_616474 = formData.getOrDefault("ClusterSubnetGroupName")
  valid_616474 = validateParameter(valid_616474, JString, required = false,
                                 default = nil)
  if valid_616474 != nil:
    section.add "ClusterSubnetGroupName", valid_616474
  var valid_616475 = formData.getOrDefault("AllowVersionUpgrade")
  valid_616475 = validateParameter(valid_616475, JBool, required = false, default = nil)
  if valid_616475 != nil:
    section.add "AllowVersionUpgrade", valid_616475
  var valid_616476 = formData.getOrDefault("SnapshotIdentifier")
  valid_616476 = validateParameter(valid_616476, JString, required = true,
                                 default = nil)
  if valid_616476 != nil:
    section.add "SnapshotIdentifier", valid_616476
  var valid_616477 = formData.getOrDefault("PubliclyAccessible")
  valid_616477 = validateParameter(valid_616477, JBool, required = false, default = nil)
  if valid_616477 != nil:
    section.add "PubliclyAccessible", valid_616477
  var valid_616478 = formData.getOrDefault("ClusterParameterGroupName")
  valid_616478 = validateParameter(valid_616478, JString, required = false,
                                 default = nil)
  if valid_616478 != nil:
    section.add "ClusterParameterGroupName", valid_616478
  var valid_616479 = formData.getOrDefault("HsmClientCertificateIdentifier")
  valid_616479 = validateParameter(valid_616479, JString, required = false,
                                 default = nil)
  if valid_616479 != nil:
    section.add "HsmClientCertificateIdentifier", valid_616479
  var valid_616480 = formData.getOrDefault("SnapshotClusterIdentifier")
  valid_616480 = validateParameter(valid_616480, JString, required = false,
                                 default = nil)
  if valid_616480 != nil:
    section.add "SnapshotClusterIdentifier", valid_616480
  var valid_616481 = formData.getOrDefault("AdditionalInfo")
  valid_616481 = validateParameter(valid_616481, JString, required = false,
                                 default = nil)
  if valid_616481 != nil:
    section.add "AdditionalInfo", valid_616481
  var valid_616482 = formData.getOrDefault("SnapshotScheduleIdentifier")
  valid_616482 = validateParameter(valid_616482, JString, required = false,
                                 default = nil)
  if valid_616482 != nil:
    section.add "SnapshotScheduleIdentifier", valid_616482
  var valid_616483 = formData.getOrDefault("ElasticIp")
  valid_616483 = validateParameter(valid_616483, JString, required = false,
                                 default = nil)
  if valid_616483 != nil:
    section.add "ElasticIp", valid_616483
  var valid_616484 = formData.getOrDefault("HsmConfigurationIdentifier")
  valid_616484 = validateParameter(valid_616484, JString, required = false,
                                 default = nil)
  if valid_616484 != nil:
    section.add "HsmConfigurationIdentifier", valid_616484
  var valid_616485 = formData.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_616485 = validateParameter(valid_616485, JInt, required = false, default = nil)
  if valid_616485 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_616485
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_616486: Call_PostRestoreFromClusterSnapshot_616448; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a new cluster from a snapshot. By default, Amazon Redshift creates the resulting cluster with the same configuration as the original cluster from which the snapshot was created, except that the new cluster is created with the default cluster security and parameter groups. After Amazon Redshift creates the cluster, you can use the <a>ModifyCluster</a> API to associate a different security group and different parameter group with the restored cluster. If you are using a DS node type, you can also choose to change to another DS node type of the same size during restore.</p> <p>If you restore a cluster into a VPC, you must provide a cluster subnet group where you want the cluster restored.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_616486.validator(path, query, header, formData, body)
  let scheme = call_616486.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_616486.url(scheme.get, call_616486.host, call_616486.base,
                         call_616486.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_616486, url, valid)

proc call*(call_616487: Call_PostRestoreFromClusterSnapshot_616448;
          ClusterIdentifier: string; SnapshotIdentifier: string; Port: int = 0;
          PreferredMaintenanceWindow: string = ""; NodeType: string = "";
          MaintenanceTrackName: string = ""; ClusterSecurityGroups: JsonNode = nil;
          IamRoles: JsonNode = nil; OwnerAccount: string = "";
          VpcSecurityGroupIds: JsonNode = nil;
          AutomatedSnapshotRetentionPeriod: int = 0; AvailabilityZone: string = "";
          EnhancedVpcRouting: bool = false; KmsKeyId: string = "";
          NumberOfNodes: int = 0; ClusterSubnetGroupName: string = "";
          AllowVersionUpgrade: bool = false; PubliclyAccessible: bool = false;
          Action: string = "RestoreFromClusterSnapshot";
          ClusterParameterGroupName: string = "";
          HsmClientCertificateIdentifier: string = "";
          SnapshotClusterIdentifier: string = ""; AdditionalInfo: string = "";
          SnapshotScheduleIdentifier: string = ""; Version: string = "2012-12-01";
          ElasticIp: string = ""; HsmConfigurationIdentifier: string = "";
          ManualSnapshotRetentionPeriod: int = 0): Recallable =
  ## postRestoreFromClusterSnapshot
  ## <p>Creates a new cluster from a snapshot. By default, Amazon Redshift creates the resulting cluster with the same configuration as the original cluster from which the snapshot was created, except that the new cluster is created with the default cluster security and parameter groups. After Amazon Redshift creates the cluster, you can use the <a>ModifyCluster</a> API to associate a different security group and different parameter group with the restored cluster. If you are using a DS node type, you can also choose to change to another DS node type of the same size during restore.</p> <p>If you restore a cluster into a VPC, you must provide a cluster subnet group where you want the cluster restored.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   Port: int
  ##       : <p>The port number on which the cluster accepts connections.</p> <p>Default: The same port as the original cluster.</p> <p>Constraints: Must be between <code>1115</code> and <code>65535</code>.</p>
  ##   PreferredMaintenanceWindow: string
  ##                             : <p>The weekly time range (in UTC) during which automated cluster maintenance can occur.</p> <p> Format: <code>ddd:hh24:mi-ddd:hh24:mi</code> </p> <p> Default: The value selected for the cluster from which the snapshot was taken. For more information about the time blocks for each region, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-maintenance-windows">Maintenance Windows</a> in Amazon Redshift Cluster Management Guide. </p> <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p> <p>Constraints: Minimum 30-minute window.</p>
  ##   NodeType: string
  ##           : <p>The node type that the restored cluster will be provisioned with.</p> <p>Default: The node type of the cluster from which the snapshot was taken. You can modify this if you are using any DS node type. In that case, you can choose to restore into another DS node type of the same size. For example, you can restore ds1.8xlarge into ds2.8xlarge, or ds1.xlarge into ds2.xlarge. If you have a DC instance type, you must restore into that same instance type and size. In other words, you can only restore a dc1.large instance type into another dc1.large instance type or dc2.large instance type. You can't restore dc1.8xlarge to dc2.8xlarge. First restore to a dc1.8xlareg cluster, then resize to a dc2.8large cluster. For more information about node types, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-about-clusters-and-nodes"> About Clusters and Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The identifier of the cluster that will be created from restoring the snapshot.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul>
  ##   MaintenanceTrackName: string
  ##                       : The name of the maintenance track for the restored cluster. When you take a snapshot, the snapshot inherits the <code>MaintenanceTrack</code> value from the cluster. The snapshot might be on a different track than the cluster that was the source for the snapshot. For example, suppose that you take a snapshot of a cluster that is on the current track and then change the cluster to be on the trailing track. In this case, the snapshot and the source cluster are on different tracks.
  ##   ClusterSecurityGroups: JArray
  ##                        : <p>A list of security groups to be associated with this cluster.</p> <p>Default: The default cluster security group for Amazon Redshift.</p> <p>Cluster security groups only apply to clusters outside of VPCs.</p>
  ##   IamRoles: JArray
  ##           : <p>A list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services. You must supply the IAM roles in their Amazon Resource Name (ARN) format. You can supply up to 10 IAM roles in a single request.</p> <p>A cluster can have up to 10 IAM roles associated at any time.</p>
  ##   OwnerAccount: string
  ##               : The AWS customer account used to create or copy the snapshot. Required if you are restoring a snapshot you do not own, optional if you own the snapshot.
  ##   VpcSecurityGroupIds: JArray
  ##                      : <p>A list of Virtual Private Cloud (VPC) security groups to be associated with the cluster.</p> <p>Default: The default VPC security group is associated with the cluster.</p> <p>VPC security groups only apply to clusters in VPCs.</p>
  ##   AutomatedSnapshotRetentionPeriod: int
  ##                                   : <p>The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p> <p>Default: The value selected for the cluster from which the snapshot was taken.</p> <p>Constraints: Must be a value from 0 to 35.</p>
  ##   AvailabilityZone: string
  ##                   : <p>The Amazon EC2 Availability Zone in which to restore the cluster.</p> <p>Default: A random, system-chosen Availability Zone.</p> <p>Example: <code>us-east-2a</code> </p>
  ##   EnhancedVpcRouting: bool
  ##                     : <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p> <p>Default: false</p>
  ##   KmsKeyId: string
  ##           : The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster that you restore from a shared snapshot.
  ##   NumberOfNodes: int
  ##                : The number of nodes specified when provisioning the restored cluster.
  ##   ClusterSubnetGroupName: string
  ##                         : <p>The name of the subnet group where you want to cluster restored.</p> <p>A snapshot of cluster in VPC can be restored only in VPC. Therefore, you must provide subnet group name where you want the cluster restored.</p>
  ##   AllowVersionUpgrade: bool
  ##                      : <p>If <code>true</code>, major version upgrades can be applied during the maintenance window to the Amazon Redshift engine that is running on the cluster. </p> <p>Default: <code>true</code> </p>
  ##   SnapshotIdentifier: string (required)
  ##                     : <p>The name of the snapshot from which to create the new cluster. This parameter isn't case sensitive.</p> <p>Example: <code>my-snapshot-id</code> </p>
  ##   PubliclyAccessible: bool
  ##                     : If <code>true</code>, the cluster can be accessed from a public network. 
  ##   Action: string (required)
  ##   ClusterParameterGroupName: string
  ##                            : <p>The name of the parameter group to be associated with this cluster.</p> <p>Default: The default Amazon Redshift cluster parameter group. For information about the default parameter group, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Working with Amazon Redshift Parameter Groups</a>.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   HsmClientCertificateIdentifier: string
  ##                                 : Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM.
  ##   SnapshotClusterIdentifier: string
  ##                            : The name of the cluster the source snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.
  ##   AdditionalInfo: string
  ##                 : Reserved.
  ##   SnapshotScheduleIdentifier: string
  ##                             : A unique identifier for the snapshot schedule.
  ##   Version: string (required)
  ##   ElasticIp: string
  ##            : The elastic IP (EIP) address for the cluster.
  ##   HsmConfigurationIdentifier: string
  ##                             : Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The default number of days to retain a manual snapshot. If the value is -1, the snapshot is retained indefinitely. This setting doesn't change the retention period of existing snapshots.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  var query_616488 = newJObject()
  var formData_616489 = newJObject()
  add(formData_616489, "Port", newJInt(Port))
  add(formData_616489, "PreferredMaintenanceWindow",
      newJString(PreferredMaintenanceWindow))
  add(formData_616489, "NodeType", newJString(NodeType))
  add(formData_616489, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_616489, "MaintenanceTrackName", newJString(MaintenanceTrackName))
  if ClusterSecurityGroups != nil:
    formData_616489.add "ClusterSecurityGroups", ClusterSecurityGroups
  if IamRoles != nil:
    formData_616489.add "IamRoles", IamRoles
  add(formData_616489, "OwnerAccount", newJString(OwnerAccount))
  if VpcSecurityGroupIds != nil:
    formData_616489.add "VpcSecurityGroupIds", VpcSecurityGroupIds
  add(formData_616489, "AutomatedSnapshotRetentionPeriod",
      newJInt(AutomatedSnapshotRetentionPeriod))
  add(formData_616489, "AvailabilityZone", newJString(AvailabilityZone))
  add(formData_616489, "EnhancedVpcRouting", newJBool(EnhancedVpcRouting))
  add(formData_616489, "KmsKeyId", newJString(KmsKeyId))
  add(formData_616489, "NumberOfNodes", newJInt(NumberOfNodes))
  add(formData_616489, "ClusterSubnetGroupName",
      newJString(ClusterSubnetGroupName))
  add(formData_616489, "AllowVersionUpgrade", newJBool(AllowVersionUpgrade))
  add(formData_616489, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(formData_616489, "PubliclyAccessible", newJBool(PubliclyAccessible))
  add(query_616488, "Action", newJString(Action))
  add(formData_616489, "ClusterParameterGroupName",
      newJString(ClusterParameterGroupName))
  add(formData_616489, "HsmClientCertificateIdentifier",
      newJString(HsmClientCertificateIdentifier))
  add(formData_616489, "SnapshotClusterIdentifier",
      newJString(SnapshotClusterIdentifier))
  add(formData_616489, "AdditionalInfo", newJString(AdditionalInfo))
  add(formData_616489, "SnapshotScheduleIdentifier",
      newJString(SnapshotScheduleIdentifier))
  add(query_616488, "Version", newJString(Version))
  add(formData_616489, "ElasticIp", newJString(ElasticIp))
  add(formData_616489, "HsmConfigurationIdentifier",
      newJString(HsmConfigurationIdentifier))
  add(formData_616489, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  result = call_616487.call(nil, query_616488, nil, formData_616489, nil)

var postRestoreFromClusterSnapshot* = Call_PostRestoreFromClusterSnapshot_616448(
    name: "postRestoreFromClusterSnapshot", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=RestoreFromClusterSnapshot",
    validator: validate_PostRestoreFromClusterSnapshot_616449, base: "/",
    url: url_PostRestoreFromClusterSnapshot_616450,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetRestoreFromClusterSnapshot_616407 = ref object of OpenApiRestCall_612642
proc url_GetRestoreFromClusterSnapshot_616409(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetRestoreFromClusterSnapshot_616408(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a new cluster from a snapshot. By default, Amazon Redshift creates the resulting cluster with the same configuration as the original cluster from which the snapshot was created, except that the new cluster is created with the default cluster security and parameter groups. After Amazon Redshift creates the cluster, you can use the <a>ModifyCluster</a> API to associate a different security group and different parameter group with the restored cluster. If you are using a DS node type, you can also choose to change to another DS node type of the same size during restore.</p> <p>If you restore a cluster into a VPC, you must provide a cluster subnet group where you want the cluster restored.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ClusterSubnetGroupName: JString
  ##                         : <p>The name of the subnet group where you want to cluster restored.</p> <p>A snapshot of cluster in VPC can be restored only in VPC. Therefore, you must provide subnet group name where you want the cluster restored.</p>
  ##   MaintenanceTrackName: JString
  ##                       : The name of the maintenance track for the restored cluster. When you take a snapshot, the snapshot inherits the <code>MaintenanceTrack</code> value from the cluster. The snapshot might be on a different track than the cluster that was the source for the snapshot. For example, suppose that you take a snapshot of a cluster that is on the current track and then change the cluster to be on the trailing track. In this case, the snapshot and the source cluster are on different tracks.
  ##   SnapshotIdentifier: JString (required)
  ##                     : <p>The name of the snapshot from which to create the new cluster. This parameter isn't case sensitive.</p> <p>Example: <code>my-snapshot-id</code> </p>
  ##   HsmClientCertificateIdentifier: JString
  ##                                 : Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM.
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The default number of days to retain a manual snapshot. If the value is -1, the snapshot is retained indefinitely. This setting doesn't change the retention period of existing snapshots.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  ##   ClusterSecurityGroups: JArray
  ##                        : <p>A list of security groups to be associated with this cluster.</p> <p>Default: The default cluster security group for Amazon Redshift.</p> <p>Cluster security groups only apply to clusters outside of VPCs.</p>
  ##   KmsKeyId: JString
  ##           : The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster that you restore from a shared snapshot.
  ##   ClusterParameterGroupName: JString
  ##                            : <p>The name of the parameter group to be associated with this cluster.</p> <p>Default: The default Amazon Redshift cluster parameter group. For information about the default parameter group, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Working with Amazon Redshift Parameter Groups</a>.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   NodeType: JString
  ##           : <p>The node type that the restored cluster will be provisioned with.</p> <p>Default: The node type of the cluster from which the snapshot was taken. You can modify this if you are using any DS node type. In that case, you can choose to restore into another DS node type of the same size. For example, you can restore ds1.8xlarge into ds2.8xlarge, or ds1.xlarge into ds2.xlarge. If you have a DC instance type, you must restore into that same instance type and size. In other words, you can only restore a dc1.large instance type into another dc1.large instance type or dc2.large instance type. You can't restore dc1.8xlarge to dc2.8xlarge. First restore to a dc1.8xlareg cluster, then resize to a dc2.8large cluster. For more information about node types, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-about-clusters-and-nodes"> About Clusters and Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ##   SnapshotScheduleIdentifier: JString
  ##                             : A unique identifier for the snapshot schedule.
  ##   IamRoles: JArray
  ##           : <p>A list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services. You must supply the IAM roles in their Amazon Resource Name (ARN) format. You can supply up to 10 IAM roles in a single request.</p> <p>A cluster can have up to 10 IAM roles associated at any time.</p>
  ##   NumberOfNodes: JInt
  ##                : The number of nodes specified when provisioning the restored cluster.
  ##   AdditionalInfo: JString
  ##                 : Reserved.
  ##   SnapshotClusterIdentifier: JString
  ##                            : The name of the cluster the source snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.
  ##   AllowVersionUpgrade: JBool
  ##                      : <p>If <code>true</code>, major version upgrades can be applied during the maintenance window to the Amazon Redshift engine that is running on the cluster. </p> <p>Default: <code>true</code> </p>
  ##   ElasticIp: JString
  ##            : The elastic IP (EIP) address for the cluster.
  ##   AutomatedSnapshotRetentionPeriod: JInt
  ##                                   : <p>The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p> <p>Default: The value selected for the cluster from which the snapshot was taken.</p> <p>Constraints: Must be a value from 0 to 35.</p>
  ##   EnhancedVpcRouting: JBool
  ##                     : <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p> <p>Default: false</p>
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The identifier of the cluster that will be created from restoring the snapshot.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul>
  ##   Port: JInt
  ##       : <p>The port number on which the cluster accepts connections.</p> <p>Default: The same port as the original cluster.</p> <p>Constraints: Must be between <code>1115</code> and <code>65535</code>.</p>
  ##   VpcSecurityGroupIds: JArray
  ##                      : <p>A list of Virtual Private Cloud (VPC) security groups to be associated with the cluster.</p> <p>Default: The default VPC security group is associated with the cluster.</p> <p>VPC security groups only apply to clusters in VPCs.</p>
  ##   AvailabilityZone: JString
  ##                   : <p>The Amazon EC2 Availability Zone in which to restore the cluster.</p> <p>Default: A random, system-chosen Availability Zone.</p> <p>Example: <code>us-east-2a</code> </p>
  ##   HsmConfigurationIdentifier: JString
  ##                             : Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
  ##   OwnerAccount: JString
  ##               : The AWS customer account used to create or copy the snapshot. Required if you are restoring a snapshot you do not own, optional if you own the snapshot.
  ##   Version: JString (required)
  ##   PreferredMaintenanceWindow: JString
  ##                             : <p>The weekly time range (in UTC) during which automated cluster maintenance can occur.</p> <p> Format: <code>ddd:hh24:mi-ddd:hh24:mi</code> </p> <p> Default: The value selected for the cluster from which the snapshot was taken. For more information about the time blocks for each region, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-maintenance-windows">Maintenance Windows</a> in Amazon Redshift Cluster Management Guide. </p> <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p> <p>Constraints: Minimum 30-minute window.</p>
  ##   PubliclyAccessible: JBool
  ##                     : If <code>true</code>, the cluster can be accessed from a public network. 
  section = newJObject()
  var valid_616410 = query.getOrDefault("ClusterSubnetGroupName")
  valid_616410 = validateParameter(valid_616410, JString, required = false,
                                 default = nil)
  if valid_616410 != nil:
    section.add "ClusterSubnetGroupName", valid_616410
  var valid_616411 = query.getOrDefault("MaintenanceTrackName")
  valid_616411 = validateParameter(valid_616411, JString, required = false,
                                 default = nil)
  if valid_616411 != nil:
    section.add "MaintenanceTrackName", valid_616411
  assert query != nil, "query argument is necessary due to required `SnapshotIdentifier` field"
  var valid_616412 = query.getOrDefault("SnapshotIdentifier")
  valid_616412 = validateParameter(valid_616412, JString, required = true,
                                 default = nil)
  if valid_616412 != nil:
    section.add "SnapshotIdentifier", valid_616412
  var valid_616413 = query.getOrDefault("HsmClientCertificateIdentifier")
  valid_616413 = validateParameter(valid_616413, JString, required = false,
                                 default = nil)
  if valid_616413 != nil:
    section.add "HsmClientCertificateIdentifier", valid_616413
  var valid_616414 = query.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_616414 = validateParameter(valid_616414, JInt, required = false, default = nil)
  if valid_616414 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_616414
  var valid_616415 = query.getOrDefault("ClusterSecurityGroups")
  valid_616415 = validateParameter(valid_616415, JArray, required = false,
                                 default = nil)
  if valid_616415 != nil:
    section.add "ClusterSecurityGroups", valid_616415
  var valid_616416 = query.getOrDefault("KmsKeyId")
  valid_616416 = validateParameter(valid_616416, JString, required = false,
                                 default = nil)
  if valid_616416 != nil:
    section.add "KmsKeyId", valid_616416
  var valid_616417 = query.getOrDefault("ClusterParameterGroupName")
  valid_616417 = validateParameter(valid_616417, JString, required = false,
                                 default = nil)
  if valid_616417 != nil:
    section.add "ClusterParameterGroupName", valid_616417
  var valid_616418 = query.getOrDefault("NodeType")
  valid_616418 = validateParameter(valid_616418, JString, required = false,
                                 default = nil)
  if valid_616418 != nil:
    section.add "NodeType", valid_616418
  var valid_616419 = query.getOrDefault("SnapshotScheduleIdentifier")
  valid_616419 = validateParameter(valid_616419, JString, required = false,
                                 default = nil)
  if valid_616419 != nil:
    section.add "SnapshotScheduleIdentifier", valid_616419
  var valid_616420 = query.getOrDefault("IamRoles")
  valid_616420 = validateParameter(valid_616420, JArray, required = false,
                                 default = nil)
  if valid_616420 != nil:
    section.add "IamRoles", valid_616420
  var valid_616421 = query.getOrDefault("NumberOfNodes")
  valid_616421 = validateParameter(valid_616421, JInt, required = false, default = nil)
  if valid_616421 != nil:
    section.add "NumberOfNodes", valid_616421
  var valid_616422 = query.getOrDefault("AdditionalInfo")
  valid_616422 = validateParameter(valid_616422, JString, required = false,
                                 default = nil)
  if valid_616422 != nil:
    section.add "AdditionalInfo", valid_616422
  var valid_616423 = query.getOrDefault("SnapshotClusterIdentifier")
  valid_616423 = validateParameter(valid_616423, JString, required = false,
                                 default = nil)
  if valid_616423 != nil:
    section.add "SnapshotClusterIdentifier", valid_616423
  var valid_616424 = query.getOrDefault("AllowVersionUpgrade")
  valid_616424 = validateParameter(valid_616424, JBool, required = false, default = nil)
  if valid_616424 != nil:
    section.add "AllowVersionUpgrade", valid_616424
  var valid_616425 = query.getOrDefault("ElasticIp")
  valid_616425 = validateParameter(valid_616425, JString, required = false,
                                 default = nil)
  if valid_616425 != nil:
    section.add "ElasticIp", valid_616425
  var valid_616426 = query.getOrDefault("AutomatedSnapshotRetentionPeriod")
  valid_616426 = validateParameter(valid_616426, JInt, required = false, default = nil)
  if valid_616426 != nil:
    section.add "AutomatedSnapshotRetentionPeriod", valid_616426
  var valid_616427 = query.getOrDefault("EnhancedVpcRouting")
  valid_616427 = validateParameter(valid_616427, JBool, required = false, default = nil)
  if valid_616427 != nil:
    section.add "EnhancedVpcRouting", valid_616427
  var valid_616428 = query.getOrDefault("Action")
  valid_616428 = validateParameter(valid_616428, JString, required = true, default = newJString(
      "RestoreFromClusterSnapshot"))
  if valid_616428 != nil:
    section.add "Action", valid_616428
  var valid_616429 = query.getOrDefault("ClusterIdentifier")
  valid_616429 = validateParameter(valid_616429, JString, required = true,
                                 default = nil)
  if valid_616429 != nil:
    section.add "ClusterIdentifier", valid_616429
  var valid_616430 = query.getOrDefault("Port")
  valid_616430 = validateParameter(valid_616430, JInt, required = false, default = nil)
  if valid_616430 != nil:
    section.add "Port", valid_616430
  var valid_616431 = query.getOrDefault("VpcSecurityGroupIds")
  valid_616431 = validateParameter(valid_616431, JArray, required = false,
                                 default = nil)
  if valid_616431 != nil:
    section.add "VpcSecurityGroupIds", valid_616431
  var valid_616432 = query.getOrDefault("AvailabilityZone")
  valid_616432 = validateParameter(valid_616432, JString, required = false,
                                 default = nil)
  if valid_616432 != nil:
    section.add "AvailabilityZone", valid_616432
  var valid_616433 = query.getOrDefault("HsmConfigurationIdentifier")
  valid_616433 = validateParameter(valid_616433, JString, required = false,
                                 default = nil)
  if valid_616433 != nil:
    section.add "HsmConfigurationIdentifier", valid_616433
  var valid_616434 = query.getOrDefault("OwnerAccount")
  valid_616434 = validateParameter(valid_616434, JString, required = false,
                                 default = nil)
  if valid_616434 != nil:
    section.add "OwnerAccount", valid_616434
  var valid_616435 = query.getOrDefault("Version")
  valid_616435 = validateParameter(valid_616435, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_616435 != nil:
    section.add "Version", valid_616435
  var valid_616436 = query.getOrDefault("PreferredMaintenanceWindow")
  valid_616436 = validateParameter(valid_616436, JString, required = false,
                                 default = nil)
  if valid_616436 != nil:
    section.add "PreferredMaintenanceWindow", valid_616436
  var valid_616437 = query.getOrDefault("PubliclyAccessible")
  valid_616437 = validateParameter(valid_616437, JBool, required = false, default = nil)
  if valid_616437 != nil:
    section.add "PubliclyAccessible", valid_616437
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_616438 = header.getOrDefault("X-Amz-Signature")
  valid_616438 = validateParameter(valid_616438, JString, required = false,
                                 default = nil)
  if valid_616438 != nil:
    section.add "X-Amz-Signature", valid_616438
  var valid_616439 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_616439 = validateParameter(valid_616439, JString, required = false,
                                 default = nil)
  if valid_616439 != nil:
    section.add "X-Amz-Content-Sha256", valid_616439
  var valid_616440 = header.getOrDefault("X-Amz-Date")
  valid_616440 = validateParameter(valid_616440, JString, required = false,
                                 default = nil)
  if valid_616440 != nil:
    section.add "X-Amz-Date", valid_616440
  var valid_616441 = header.getOrDefault("X-Amz-Credential")
  valid_616441 = validateParameter(valid_616441, JString, required = false,
                                 default = nil)
  if valid_616441 != nil:
    section.add "X-Amz-Credential", valid_616441
  var valid_616442 = header.getOrDefault("X-Amz-Security-Token")
  valid_616442 = validateParameter(valid_616442, JString, required = false,
                                 default = nil)
  if valid_616442 != nil:
    section.add "X-Amz-Security-Token", valid_616442
  var valid_616443 = header.getOrDefault("X-Amz-Algorithm")
  valid_616443 = validateParameter(valid_616443, JString, required = false,
                                 default = nil)
  if valid_616443 != nil:
    section.add "X-Amz-Algorithm", valid_616443
  var valid_616444 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_616444 = validateParameter(valid_616444, JString, required = false,
                                 default = nil)
  if valid_616444 != nil:
    section.add "X-Amz-SignedHeaders", valid_616444
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_616445: Call_GetRestoreFromClusterSnapshot_616407; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a new cluster from a snapshot. By default, Amazon Redshift creates the resulting cluster with the same configuration as the original cluster from which the snapshot was created, except that the new cluster is created with the default cluster security and parameter groups. After Amazon Redshift creates the cluster, you can use the <a>ModifyCluster</a> API to associate a different security group and different parameter group with the restored cluster. If you are using a DS node type, you can also choose to change to another DS node type of the same size during restore.</p> <p>If you restore a cluster into a VPC, you must provide a cluster subnet group where you want the cluster restored.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_616445.validator(path, query, header, formData, body)
  let scheme = call_616445.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_616445.url(scheme.get, call_616445.host, call_616445.base,
                         call_616445.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_616445, url, valid)

proc call*(call_616446: Call_GetRestoreFromClusterSnapshot_616407;
          SnapshotIdentifier: string; ClusterIdentifier: string;
          ClusterSubnetGroupName: string = ""; MaintenanceTrackName: string = "";
          HsmClientCertificateIdentifier: string = "";
          ManualSnapshotRetentionPeriod: int = 0;
          ClusterSecurityGroups: JsonNode = nil; KmsKeyId: string = "";
          ClusterParameterGroupName: string = ""; NodeType: string = "";
          SnapshotScheduleIdentifier: string = ""; IamRoles: JsonNode = nil;
          NumberOfNodes: int = 0; AdditionalInfo: string = "";
          SnapshotClusterIdentifier: string = ""; AllowVersionUpgrade: bool = false;
          ElasticIp: string = ""; AutomatedSnapshotRetentionPeriod: int = 0;
          EnhancedVpcRouting: bool = false;
          Action: string = "RestoreFromClusterSnapshot"; Port: int = 0;
          VpcSecurityGroupIds: JsonNode = nil; AvailabilityZone: string = "";
          HsmConfigurationIdentifier: string = ""; OwnerAccount: string = "";
          Version: string = "2012-12-01"; PreferredMaintenanceWindow: string = "";
          PubliclyAccessible: bool = false): Recallable =
  ## getRestoreFromClusterSnapshot
  ## <p>Creates a new cluster from a snapshot. By default, Amazon Redshift creates the resulting cluster with the same configuration as the original cluster from which the snapshot was created, except that the new cluster is created with the default cluster security and parameter groups. After Amazon Redshift creates the cluster, you can use the <a>ModifyCluster</a> API to associate a different security group and different parameter group with the restored cluster. If you are using a DS node type, you can also choose to change to another DS node type of the same size during restore.</p> <p>If you restore a cluster into a VPC, you must provide a cluster subnet group where you want the cluster restored.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   ClusterSubnetGroupName: string
  ##                         : <p>The name of the subnet group where you want to cluster restored.</p> <p>A snapshot of cluster in VPC can be restored only in VPC. Therefore, you must provide subnet group name where you want the cluster restored.</p>
  ##   MaintenanceTrackName: string
  ##                       : The name of the maintenance track for the restored cluster. When you take a snapshot, the snapshot inherits the <code>MaintenanceTrack</code> value from the cluster. The snapshot might be on a different track than the cluster that was the source for the snapshot. For example, suppose that you take a snapshot of a cluster that is on the current track and then change the cluster to be on the trailing track. In this case, the snapshot and the source cluster are on different tracks.
  ##   SnapshotIdentifier: string (required)
  ##                     : <p>The name of the snapshot from which to create the new cluster. This parameter isn't case sensitive.</p> <p>Example: <code>my-snapshot-id</code> </p>
  ##   HsmClientCertificateIdentifier: string
  ##                                 : Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM.
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The default number of days to retain a manual snapshot. If the value is -1, the snapshot is retained indefinitely. This setting doesn't change the retention period of existing snapshots.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  ##   ClusterSecurityGroups: JArray
  ##                        : <p>A list of security groups to be associated with this cluster.</p> <p>Default: The default cluster security group for Amazon Redshift.</p> <p>Cluster security groups only apply to clusters outside of VPCs.</p>
  ##   KmsKeyId: string
  ##           : The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster that you restore from a shared snapshot.
  ##   ClusterParameterGroupName: string
  ##                            : <p>The name of the parameter group to be associated with this cluster.</p> <p>Default: The default Amazon Redshift cluster parameter group. For information about the default parameter group, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Working with Amazon Redshift Parameter Groups</a>.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   NodeType: string
  ##           : <p>The node type that the restored cluster will be provisioned with.</p> <p>Default: The node type of the cluster from which the snapshot was taken. You can modify this if you are using any DS node type. In that case, you can choose to restore into another DS node type of the same size. For example, you can restore ds1.8xlarge into ds2.8xlarge, or ds1.xlarge into ds2.xlarge. If you have a DC instance type, you must restore into that same instance type and size. In other words, you can only restore a dc1.large instance type into another dc1.large instance type or dc2.large instance type. You can't restore dc1.8xlarge to dc2.8xlarge. First restore to a dc1.8xlareg cluster, then resize to a dc2.8large cluster. For more information about node types, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-about-clusters-and-nodes"> About Clusters and Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ##   SnapshotScheduleIdentifier: string
  ##                             : A unique identifier for the snapshot schedule.
  ##   IamRoles: JArray
  ##           : <p>A list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services. You must supply the IAM roles in their Amazon Resource Name (ARN) format. You can supply up to 10 IAM roles in a single request.</p> <p>A cluster can have up to 10 IAM roles associated at any time.</p>
  ##   NumberOfNodes: int
  ##                : The number of nodes specified when provisioning the restored cluster.
  ##   AdditionalInfo: string
  ##                 : Reserved.
  ##   SnapshotClusterIdentifier: string
  ##                            : The name of the cluster the source snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.
  ##   AllowVersionUpgrade: bool
  ##                      : <p>If <code>true</code>, major version upgrades can be applied during the maintenance window to the Amazon Redshift engine that is running on the cluster. </p> <p>Default: <code>true</code> </p>
  ##   ElasticIp: string
  ##            : The elastic IP (EIP) address for the cluster.
  ##   AutomatedSnapshotRetentionPeriod: int
  ##                                   : <p>The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p> <p>Default: The value selected for the cluster from which the snapshot was taken.</p> <p>Constraints: Must be a value from 0 to 35.</p>
  ##   EnhancedVpcRouting: bool
  ##                     : <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p> <p>Default: false</p>
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The identifier of the cluster that will be created from restoring the snapshot.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul>
  ##   Port: int
  ##       : <p>The port number on which the cluster accepts connections.</p> <p>Default: The same port as the original cluster.</p> <p>Constraints: Must be between <code>1115</code> and <code>65535</code>.</p>
  ##   VpcSecurityGroupIds: JArray
  ##                      : <p>A list of Virtual Private Cloud (VPC) security groups to be associated with the cluster.</p> <p>Default: The default VPC security group is associated with the cluster.</p> <p>VPC security groups only apply to clusters in VPCs.</p>
  ##   AvailabilityZone: string
  ##                   : <p>The Amazon EC2 Availability Zone in which to restore the cluster.</p> <p>Default: A random, system-chosen Availability Zone.</p> <p>Example: <code>us-east-2a</code> </p>
  ##   HsmConfigurationIdentifier: string
  ##                             : Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
  ##   OwnerAccount: string
  ##               : The AWS customer account used to create or copy the snapshot. Required if you are restoring a snapshot you do not own, optional if you own the snapshot.
  ##   Version: string (required)
  ##   PreferredMaintenanceWindow: string
  ##                             : <p>The weekly time range (in UTC) during which automated cluster maintenance can occur.</p> <p> Format: <code>ddd:hh24:mi-ddd:hh24:mi</code> </p> <p> Default: The value selected for the cluster from which the snapshot was taken. For more information about the time blocks for each region, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-maintenance-windows">Maintenance Windows</a> in Amazon Redshift Cluster Management Guide. </p> <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p> <p>Constraints: Minimum 30-minute window.</p>
  ##   PubliclyAccessible: bool
  ##                     : If <code>true</code>, the cluster can be accessed from a public network. 
  var query_616447 = newJObject()
  add(query_616447, "ClusterSubnetGroupName", newJString(ClusterSubnetGroupName))
  add(query_616447, "MaintenanceTrackName", newJString(MaintenanceTrackName))
  add(query_616447, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_616447, "HsmClientCertificateIdentifier",
      newJString(HsmClientCertificateIdentifier))
  add(query_616447, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  if ClusterSecurityGroups != nil:
    query_616447.add "ClusterSecurityGroups", ClusterSecurityGroups
  add(query_616447, "KmsKeyId", newJString(KmsKeyId))
  add(query_616447, "ClusterParameterGroupName",
      newJString(ClusterParameterGroupName))
  add(query_616447, "NodeType", newJString(NodeType))
  add(query_616447, "SnapshotScheduleIdentifier",
      newJString(SnapshotScheduleIdentifier))
  if IamRoles != nil:
    query_616447.add "IamRoles", IamRoles
  add(query_616447, "NumberOfNodes", newJInt(NumberOfNodes))
  add(query_616447, "AdditionalInfo", newJString(AdditionalInfo))
  add(query_616447, "SnapshotClusterIdentifier",
      newJString(SnapshotClusterIdentifier))
  add(query_616447, "AllowVersionUpgrade", newJBool(AllowVersionUpgrade))
  add(query_616447, "ElasticIp", newJString(ElasticIp))
  add(query_616447, "AutomatedSnapshotRetentionPeriod",
      newJInt(AutomatedSnapshotRetentionPeriod))
  add(query_616447, "EnhancedVpcRouting", newJBool(EnhancedVpcRouting))
  add(query_616447, "Action", newJString(Action))
  add(query_616447, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_616447, "Port", newJInt(Port))
  if VpcSecurityGroupIds != nil:
    query_616447.add "VpcSecurityGroupIds", VpcSecurityGroupIds
  add(query_616447, "AvailabilityZone", newJString(AvailabilityZone))
  add(query_616447, "HsmConfigurationIdentifier",
      newJString(HsmConfigurationIdentifier))
  add(query_616447, "OwnerAccount", newJString(OwnerAccount))
  add(query_616447, "Version", newJString(Version))
  add(query_616447, "PreferredMaintenanceWindow",
      newJString(PreferredMaintenanceWindow))
  add(query_616447, "PubliclyAccessible", newJBool(PubliclyAccessible))
  result = call_616446.call(nil, query_616447, nil, nil, nil)

var getRestoreFromClusterSnapshot* = Call_GetRestoreFromClusterSnapshot_616407(
    name: "getRestoreFromClusterSnapshot", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=RestoreFromClusterSnapshot",
    validator: validate_GetRestoreFromClusterSnapshot_616408, base: "/",
    url: url_GetRestoreFromClusterSnapshot_616409,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostRestoreTableFromClusterSnapshot_616513 = ref object of OpenApiRestCall_612642
proc url_PostRestoreTableFromClusterSnapshot_616515(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostRestoreTableFromClusterSnapshot_616514(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a new table from a table in an Amazon Redshift cluster snapshot. You must create the new table within the Amazon Redshift cluster that the snapshot was taken from.</p> <p>You cannot use <code>RestoreTableFromClusterSnapshot</code> to restore a table with the same name as an existing table in an Amazon Redshift cluster. That is, you cannot overwrite an existing table in a cluster with a restored table. If you want to replace your original table with a new, restored table, then rename or drop your original table before you call <code>RestoreTableFromClusterSnapshot</code>. When you have renamed your original table, then you can pass the original name of the table as the <code>NewTableName</code> parameter value in the call to <code>RestoreTableFromClusterSnapshot</code>. This way, you can replace the original table with the table created from the snapshot.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_616516 = query.getOrDefault("Action")
  valid_616516 = validateParameter(valid_616516, JString, required = true, default = newJString(
      "RestoreTableFromClusterSnapshot"))
  if valid_616516 != nil:
    section.add "Action", valid_616516
  var valid_616517 = query.getOrDefault("Version")
  valid_616517 = validateParameter(valid_616517, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_616517 != nil:
    section.add "Version", valid_616517
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_616518 = header.getOrDefault("X-Amz-Signature")
  valid_616518 = validateParameter(valid_616518, JString, required = false,
                                 default = nil)
  if valid_616518 != nil:
    section.add "X-Amz-Signature", valid_616518
  var valid_616519 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_616519 = validateParameter(valid_616519, JString, required = false,
                                 default = nil)
  if valid_616519 != nil:
    section.add "X-Amz-Content-Sha256", valid_616519
  var valid_616520 = header.getOrDefault("X-Amz-Date")
  valid_616520 = validateParameter(valid_616520, JString, required = false,
                                 default = nil)
  if valid_616520 != nil:
    section.add "X-Amz-Date", valid_616520
  var valid_616521 = header.getOrDefault("X-Amz-Credential")
  valid_616521 = validateParameter(valid_616521, JString, required = false,
                                 default = nil)
  if valid_616521 != nil:
    section.add "X-Amz-Credential", valid_616521
  var valid_616522 = header.getOrDefault("X-Amz-Security-Token")
  valid_616522 = validateParameter(valid_616522, JString, required = false,
                                 default = nil)
  if valid_616522 != nil:
    section.add "X-Amz-Security-Token", valid_616522
  var valid_616523 = header.getOrDefault("X-Amz-Algorithm")
  valid_616523 = validateParameter(valid_616523, JString, required = false,
                                 default = nil)
  if valid_616523 != nil:
    section.add "X-Amz-Algorithm", valid_616523
  var valid_616524 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_616524 = validateParameter(valid_616524, JString, required = false,
                                 default = nil)
  if valid_616524 != nil:
    section.add "X-Amz-SignedHeaders", valid_616524
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : The identifier of the Amazon Redshift cluster to restore the table to.
  ##   NewTableName: JString (required)
  ##               : The name of the table to create as a result of the current request.
  ##   TargetSchemaName: JString
  ##                   : The name of the schema to restore the table to.
  ##   TargetDatabaseName: JString
  ##                     : The name of the database to restore the table to.
  ##   SnapshotIdentifier: JString (required)
  ##                     : The identifier of the snapshot to restore the table from. This snapshot must have been created from the Amazon Redshift cluster specified by the <code>ClusterIdentifier</code> parameter.
  ##   SourceDatabaseName: JString (required)
  ##                     : The name of the source database that contains the table to restore from.
  ##   SourceSchemaName: JString
  ##                   : The name of the source schema that contains the table to restore from. If you do not specify a <code>SourceSchemaName</code> value, the default is <code>public</code>.
  ##   SourceTableName: JString (required)
  ##                  : The name of the source table to restore from.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_616525 = formData.getOrDefault("ClusterIdentifier")
  valid_616525 = validateParameter(valid_616525, JString, required = true,
                                 default = nil)
  if valid_616525 != nil:
    section.add "ClusterIdentifier", valid_616525
  var valid_616526 = formData.getOrDefault("NewTableName")
  valid_616526 = validateParameter(valid_616526, JString, required = true,
                                 default = nil)
  if valid_616526 != nil:
    section.add "NewTableName", valid_616526
  var valid_616527 = formData.getOrDefault("TargetSchemaName")
  valid_616527 = validateParameter(valid_616527, JString, required = false,
                                 default = nil)
  if valid_616527 != nil:
    section.add "TargetSchemaName", valid_616527
  var valid_616528 = formData.getOrDefault("TargetDatabaseName")
  valid_616528 = validateParameter(valid_616528, JString, required = false,
                                 default = nil)
  if valid_616528 != nil:
    section.add "TargetDatabaseName", valid_616528
  var valid_616529 = formData.getOrDefault("SnapshotIdentifier")
  valid_616529 = validateParameter(valid_616529, JString, required = true,
                                 default = nil)
  if valid_616529 != nil:
    section.add "SnapshotIdentifier", valid_616529
  var valid_616530 = formData.getOrDefault("SourceDatabaseName")
  valid_616530 = validateParameter(valid_616530, JString, required = true,
                                 default = nil)
  if valid_616530 != nil:
    section.add "SourceDatabaseName", valid_616530
  var valid_616531 = formData.getOrDefault("SourceSchemaName")
  valid_616531 = validateParameter(valid_616531, JString, required = false,
                                 default = nil)
  if valid_616531 != nil:
    section.add "SourceSchemaName", valid_616531
  var valid_616532 = formData.getOrDefault("SourceTableName")
  valid_616532 = validateParameter(valid_616532, JString, required = true,
                                 default = nil)
  if valid_616532 != nil:
    section.add "SourceTableName", valid_616532
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_616533: Call_PostRestoreTableFromClusterSnapshot_616513;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Creates a new table from a table in an Amazon Redshift cluster snapshot. You must create the new table within the Amazon Redshift cluster that the snapshot was taken from.</p> <p>You cannot use <code>RestoreTableFromClusterSnapshot</code> to restore a table with the same name as an existing table in an Amazon Redshift cluster. That is, you cannot overwrite an existing table in a cluster with a restored table. If you want to replace your original table with a new, restored table, then rename or drop your original table before you call <code>RestoreTableFromClusterSnapshot</code>. When you have renamed your original table, then you can pass the original name of the table as the <code>NewTableName</code> parameter value in the call to <code>RestoreTableFromClusterSnapshot</code>. This way, you can replace the original table with the table created from the snapshot.</p>
  ## 
  let valid = call_616533.validator(path, query, header, formData, body)
  let scheme = call_616533.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_616533.url(scheme.get, call_616533.host, call_616533.base,
                         call_616533.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_616533, url, valid)

proc call*(call_616534: Call_PostRestoreTableFromClusterSnapshot_616513;
          ClusterIdentifier: string; NewTableName: string;
          SnapshotIdentifier: string; SourceDatabaseName: string;
          SourceTableName: string; TargetSchemaName: string = "";
          TargetDatabaseName: string = "";
          Action: string = "RestoreTableFromClusterSnapshot";
          Version: string = "2012-12-01"; SourceSchemaName: string = ""): Recallable =
  ## postRestoreTableFromClusterSnapshot
  ## <p>Creates a new table from a table in an Amazon Redshift cluster snapshot. You must create the new table within the Amazon Redshift cluster that the snapshot was taken from.</p> <p>You cannot use <code>RestoreTableFromClusterSnapshot</code> to restore a table with the same name as an existing table in an Amazon Redshift cluster. That is, you cannot overwrite an existing table in a cluster with a restored table. If you want to replace your original table with a new, restored table, then rename or drop your original table before you call <code>RestoreTableFromClusterSnapshot</code>. When you have renamed your original table, then you can pass the original name of the table as the <code>NewTableName</code> parameter value in the call to <code>RestoreTableFromClusterSnapshot</code>. This way, you can replace the original table with the table created from the snapshot.</p>
  ##   ClusterIdentifier: string (required)
  ##                    : The identifier of the Amazon Redshift cluster to restore the table to.
  ##   NewTableName: string (required)
  ##               : The name of the table to create as a result of the current request.
  ##   TargetSchemaName: string
  ##                   : The name of the schema to restore the table to.
  ##   TargetDatabaseName: string
  ##                     : The name of the database to restore the table to.
  ##   SnapshotIdentifier: string (required)
  ##                     : The identifier of the snapshot to restore the table from. This snapshot must have been created from the Amazon Redshift cluster specified by the <code>ClusterIdentifier</code> parameter.
  ##   SourceDatabaseName: string (required)
  ##                     : The name of the source database that contains the table to restore from.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   SourceSchemaName: string
  ##                   : The name of the source schema that contains the table to restore from. If you do not specify a <code>SourceSchemaName</code> value, the default is <code>public</code>.
  ##   SourceTableName: string (required)
  ##                  : The name of the source table to restore from.
  var query_616535 = newJObject()
  var formData_616536 = newJObject()
  add(formData_616536, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_616536, "NewTableName", newJString(NewTableName))
  add(formData_616536, "TargetSchemaName", newJString(TargetSchemaName))
  add(formData_616536, "TargetDatabaseName", newJString(TargetDatabaseName))
  add(formData_616536, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(formData_616536, "SourceDatabaseName", newJString(SourceDatabaseName))
  add(query_616535, "Action", newJString(Action))
  add(query_616535, "Version", newJString(Version))
  add(formData_616536, "SourceSchemaName", newJString(SourceSchemaName))
  add(formData_616536, "SourceTableName", newJString(SourceTableName))
  result = call_616534.call(nil, query_616535, nil, formData_616536, nil)

var postRestoreTableFromClusterSnapshot* = Call_PostRestoreTableFromClusterSnapshot_616513(
    name: "postRestoreTableFromClusterSnapshot", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=RestoreTableFromClusterSnapshot",
    validator: validate_PostRestoreTableFromClusterSnapshot_616514, base: "/",
    url: url_PostRestoreTableFromClusterSnapshot_616515,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetRestoreTableFromClusterSnapshot_616490 = ref object of OpenApiRestCall_612642
proc url_GetRestoreTableFromClusterSnapshot_616492(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetRestoreTableFromClusterSnapshot_616491(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a new table from a table in an Amazon Redshift cluster snapshot. You must create the new table within the Amazon Redshift cluster that the snapshot was taken from.</p> <p>You cannot use <code>RestoreTableFromClusterSnapshot</code> to restore a table with the same name as an existing table in an Amazon Redshift cluster. That is, you cannot overwrite an existing table in a cluster with a restored table. If you want to replace your original table with a new, restored table, then rename or drop your original table before you call <code>RestoreTableFromClusterSnapshot</code>. When you have renamed your original table, then you can pass the original name of the table as the <code>NewTableName</code> parameter value in the call to <code>RestoreTableFromClusterSnapshot</code>. This way, you can replace the original table with the table created from the snapshot.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   SnapshotIdentifier: JString (required)
  ##                     : The identifier of the snapshot to restore the table from. This snapshot must have been created from the Amazon Redshift cluster specified by the <code>ClusterIdentifier</code> parameter.
  ##   SourceTableName: JString (required)
  ##                  : The name of the source table to restore from.
  ##   SourceDatabaseName: JString (required)
  ##                     : The name of the source database that contains the table to restore from.
  ##   TargetSchemaName: JString
  ##                   : The name of the schema to restore the table to.
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : The identifier of the Amazon Redshift cluster to restore the table to.
  ##   SourceSchemaName: JString
  ##                   : The name of the source schema that contains the table to restore from. If you do not specify a <code>SourceSchemaName</code> value, the default is <code>public</code>.
  ##   Version: JString (required)
  ##   TargetDatabaseName: JString
  ##                     : The name of the database to restore the table to.
  ##   NewTableName: JString (required)
  ##               : The name of the table to create as a result of the current request.
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `SnapshotIdentifier` field"
  var valid_616493 = query.getOrDefault("SnapshotIdentifier")
  valid_616493 = validateParameter(valid_616493, JString, required = true,
                                 default = nil)
  if valid_616493 != nil:
    section.add "SnapshotIdentifier", valid_616493
  var valid_616494 = query.getOrDefault("SourceTableName")
  valid_616494 = validateParameter(valid_616494, JString, required = true,
                                 default = nil)
  if valid_616494 != nil:
    section.add "SourceTableName", valid_616494
  var valid_616495 = query.getOrDefault("SourceDatabaseName")
  valid_616495 = validateParameter(valid_616495, JString, required = true,
                                 default = nil)
  if valid_616495 != nil:
    section.add "SourceDatabaseName", valid_616495
  var valid_616496 = query.getOrDefault("TargetSchemaName")
  valid_616496 = validateParameter(valid_616496, JString, required = false,
                                 default = nil)
  if valid_616496 != nil:
    section.add "TargetSchemaName", valid_616496
  var valid_616497 = query.getOrDefault("Action")
  valid_616497 = validateParameter(valid_616497, JString, required = true, default = newJString(
      "RestoreTableFromClusterSnapshot"))
  if valid_616497 != nil:
    section.add "Action", valid_616497
  var valid_616498 = query.getOrDefault("ClusterIdentifier")
  valid_616498 = validateParameter(valid_616498, JString, required = true,
                                 default = nil)
  if valid_616498 != nil:
    section.add "ClusterIdentifier", valid_616498
  var valid_616499 = query.getOrDefault("SourceSchemaName")
  valid_616499 = validateParameter(valid_616499, JString, required = false,
                                 default = nil)
  if valid_616499 != nil:
    section.add "SourceSchemaName", valid_616499
  var valid_616500 = query.getOrDefault("Version")
  valid_616500 = validateParameter(valid_616500, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_616500 != nil:
    section.add "Version", valid_616500
  var valid_616501 = query.getOrDefault("TargetDatabaseName")
  valid_616501 = validateParameter(valid_616501, JString, required = false,
                                 default = nil)
  if valid_616501 != nil:
    section.add "TargetDatabaseName", valid_616501
  var valid_616502 = query.getOrDefault("NewTableName")
  valid_616502 = validateParameter(valid_616502, JString, required = true,
                                 default = nil)
  if valid_616502 != nil:
    section.add "NewTableName", valid_616502
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_616503 = header.getOrDefault("X-Amz-Signature")
  valid_616503 = validateParameter(valid_616503, JString, required = false,
                                 default = nil)
  if valid_616503 != nil:
    section.add "X-Amz-Signature", valid_616503
  var valid_616504 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_616504 = validateParameter(valid_616504, JString, required = false,
                                 default = nil)
  if valid_616504 != nil:
    section.add "X-Amz-Content-Sha256", valid_616504
  var valid_616505 = header.getOrDefault("X-Amz-Date")
  valid_616505 = validateParameter(valid_616505, JString, required = false,
                                 default = nil)
  if valid_616505 != nil:
    section.add "X-Amz-Date", valid_616505
  var valid_616506 = header.getOrDefault("X-Amz-Credential")
  valid_616506 = validateParameter(valid_616506, JString, required = false,
                                 default = nil)
  if valid_616506 != nil:
    section.add "X-Amz-Credential", valid_616506
  var valid_616507 = header.getOrDefault("X-Amz-Security-Token")
  valid_616507 = validateParameter(valid_616507, JString, required = false,
                                 default = nil)
  if valid_616507 != nil:
    section.add "X-Amz-Security-Token", valid_616507
  var valid_616508 = header.getOrDefault("X-Amz-Algorithm")
  valid_616508 = validateParameter(valid_616508, JString, required = false,
                                 default = nil)
  if valid_616508 != nil:
    section.add "X-Amz-Algorithm", valid_616508
  var valid_616509 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_616509 = validateParameter(valid_616509, JString, required = false,
                                 default = nil)
  if valid_616509 != nil:
    section.add "X-Amz-SignedHeaders", valid_616509
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_616510: Call_GetRestoreTableFromClusterSnapshot_616490;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Creates a new table from a table in an Amazon Redshift cluster snapshot. You must create the new table within the Amazon Redshift cluster that the snapshot was taken from.</p> <p>You cannot use <code>RestoreTableFromClusterSnapshot</code> to restore a table with the same name as an existing table in an Amazon Redshift cluster. That is, you cannot overwrite an existing table in a cluster with a restored table. If you want to replace your original table with a new, restored table, then rename or drop your original table before you call <code>RestoreTableFromClusterSnapshot</code>. When you have renamed your original table, then you can pass the original name of the table as the <code>NewTableName</code> parameter value in the call to <code>RestoreTableFromClusterSnapshot</code>. This way, you can replace the original table with the table created from the snapshot.</p>
  ## 
  let valid = call_616510.validator(path, query, header, formData, body)
  let scheme = call_616510.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_616510.url(scheme.get, call_616510.host, call_616510.base,
                         call_616510.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_616510, url, valid)

proc call*(call_616511: Call_GetRestoreTableFromClusterSnapshot_616490;
          SnapshotIdentifier: string; SourceTableName: string;
          SourceDatabaseName: string; ClusterIdentifier: string;
          NewTableName: string; TargetSchemaName: string = "";
          Action: string = "RestoreTableFromClusterSnapshot";
          SourceSchemaName: string = ""; Version: string = "2012-12-01";
          TargetDatabaseName: string = ""): Recallable =
  ## getRestoreTableFromClusterSnapshot
  ## <p>Creates a new table from a table in an Amazon Redshift cluster snapshot. You must create the new table within the Amazon Redshift cluster that the snapshot was taken from.</p> <p>You cannot use <code>RestoreTableFromClusterSnapshot</code> to restore a table with the same name as an existing table in an Amazon Redshift cluster. That is, you cannot overwrite an existing table in a cluster with a restored table. If you want to replace your original table with a new, restored table, then rename or drop your original table before you call <code>RestoreTableFromClusterSnapshot</code>. When you have renamed your original table, then you can pass the original name of the table as the <code>NewTableName</code> parameter value in the call to <code>RestoreTableFromClusterSnapshot</code>. This way, you can replace the original table with the table created from the snapshot.</p>
  ##   SnapshotIdentifier: string (required)
  ##                     : The identifier of the snapshot to restore the table from. This snapshot must have been created from the Amazon Redshift cluster specified by the <code>ClusterIdentifier</code> parameter.
  ##   SourceTableName: string (required)
  ##                  : The name of the source table to restore from.
  ##   SourceDatabaseName: string (required)
  ##                     : The name of the source database that contains the table to restore from.
  ##   TargetSchemaName: string
  ##                   : The name of the schema to restore the table to.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : The identifier of the Amazon Redshift cluster to restore the table to.
  ##   SourceSchemaName: string
  ##                   : The name of the source schema that contains the table to restore from. If you do not specify a <code>SourceSchemaName</code> value, the default is <code>public</code>.
  ##   Version: string (required)
  ##   TargetDatabaseName: string
  ##                     : The name of the database to restore the table to.
  ##   NewTableName: string (required)
  ##               : The name of the table to create as a result of the current request.
  var query_616512 = newJObject()
  add(query_616512, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_616512, "SourceTableName", newJString(SourceTableName))
  add(query_616512, "SourceDatabaseName", newJString(SourceDatabaseName))
  add(query_616512, "TargetSchemaName", newJString(TargetSchemaName))
  add(query_616512, "Action", newJString(Action))
  add(query_616512, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_616512, "SourceSchemaName", newJString(SourceSchemaName))
  add(query_616512, "Version", newJString(Version))
  add(query_616512, "TargetDatabaseName", newJString(TargetDatabaseName))
  add(query_616512, "NewTableName", newJString(NewTableName))
  result = call_616511.call(nil, query_616512, nil, nil, nil)

var getRestoreTableFromClusterSnapshot* = Call_GetRestoreTableFromClusterSnapshot_616490(
    name: "getRestoreTableFromClusterSnapshot", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=RestoreTableFromClusterSnapshot",
    validator: validate_GetRestoreTableFromClusterSnapshot_616491, base: "/",
    url: url_GetRestoreTableFromClusterSnapshot_616492,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostRevokeClusterSecurityGroupIngress_616556 = ref object of OpenApiRestCall_612642
proc url_PostRevokeClusterSecurityGroupIngress_616558(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostRevokeClusterSecurityGroupIngress_616557(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Revokes an ingress rule in an Amazon Redshift security group for a previously authorized IP range or Amazon EC2 security group. To add an ingress rule, see <a>AuthorizeClusterSecurityGroupIngress</a>. For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_616559 = query.getOrDefault("Action")
  valid_616559 = validateParameter(valid_616559, JString, required = true, default = newJString(
      "RevokeClusterSecurityGroupIngress"))
  if valid_616559 != nil:
    section.add "Action", valid_616559
  var valid_616560 = query.getOrDefault("Version")
  valid_616560 = validateParameter(valid_616560, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_616560 != nil:
    section.add "Version", valid_616560
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_616561 = header.getOrDefault("X-Amz-Signature")
  valid_616561 = validateParameter(valid_616561, JString, required = false,
                                 default = nil)
  if valid_616561 != nil:
    section.add "X-Amz-Signature", valid_616561
  var valid_616562 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_616562 = validateParameter(valid_616562, JString, required = false,
                                 default = nil)
  if valid_616562 != nil:
    section.add "X-Amz-Content-Sha256", valid_616562
  var valid_616563 = header.getOrDefault("X-Amz-Date")
  valid_616563 = validateParameter(valid_616563, JString, required = false,
                                 default = nil)
  if valid_616563 != nil:
    section.add "X-Amz-Date", valid_616563
  var valid_616564 = header.getOrDefault("X-Amz-Credential")
  valid_616564 = validateParameter(valid_616564, JString, required = false,
                                 default = nil)
  if valid_616564 != nil:
    section.add "X-Amz-Credential", valid_616564
  var valid_616565 = header.getOrDefault("X-Amz-Security-Token")
  valid_616565 = validateParameter(valid_616565, JString, required = false,
                                 default = nil)
  if valid_616565 != nil:
    section.add "X-Amz-Security-Token", valid_616565
  var valid_616566 = header.getOrDefault("X-Amz-Algorithm")
  valid_616566 = validateParameter(valid_616566, JString, required = false,
                                 default = nil)
  if valid_616566 != nil:
    section.add "X-Amz-Algorithm", valid_616566
  var valid_616567 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_616567 = validateParameter(valid_616567, JString, required = false,
                                 default = nil)
  if valid_616567 != nil:
    section.add "X-Amz-SignedHeaders", valid_616567
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterSecurityGroupName: JString (required)
  ##                           : The name of the security Group from which to revoke the ingress rule.
  ##   EC2SecurityGroupName: JString
  ##                       : The name of the EC2 Security Group whose access is to be revoked. If <code>EC2SecurityGroupName</code> is specified, <code>EC2SecurityGroupOwnerId</code> must also be provided and <code>CIDRIP</code> cannot be provided. 
  ##   EC2SecurityGroupOwnerId: JString
  ##                          : <p>The AWS account number of the owner of the security group specified in the <code>EC2SecurityGroupName</code> parameter. The AWS access key ID is not an acceptable value. If <code>EC2SecurityGroupOwnerId</code> is specified, <code>EC2SecurityGroupName</code> must also be provided. and <code>CIDRIP</code> cannot be provided. </p> <p>Example: <code>111122223333</code> </p>
  ##   CIDRIP: JString
  ##         : The IP range for which to revoke access. This range must be a valid Classless Inter-Domain Routing (CIDR) block of IP addresses. If <code>CIDRIP</code> is specified, <code>EC2SecurityGroupName</code> and <code>EC2SecurityGroupOwnerId</code> cannot be provided. 
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterSecurityGroupName` field"
  var valid_616568 = formData.getOrDefault("ClusterSecurityGroupName")
  valid_616568 = validateParameter(valid_616568, JString, required = true,
                                 default = nil)
  if valid_616568 != nil:
    section.add "ClusterSecurityGroupName", valid_616568
  var valid_616569 = formData.getOrDefault("EC2SecurityGroupName")
  valid_616569 = validateParameter(valid_616569, JString, required = false,
                                 default = nil)
  if valid_616569 != nil:
    section.add "EC2SecurityGroupName", valid_616569
  var valid_616570 = formData.getOrDefault("EC2SecurityGroupOwnerId")
  valid_616570 = validateParameter(valid_616570, JString, required = false,
                                 default = nil)
  if valid_616570 != nil:
    section.add "EC2SecurityGroupOwnerId", valid_616570
  var valid_616571 = formData.getOrDefault("CIDRIP")
  valid_616571 = validateParameter(valid_616571, JString, required = false,
                                 default = nil)
  if valid_616571 != nil:
    section.add "CIDRIP", valid_616571
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_616572: Call_PostRevokeClusterSecurityGroupIngress_616556;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Revokes an ingress rule in an Amazon Redshift security group for a previously authorized IP range or Amazon EC2 security group. To add an ingress rule, see <a>AuthorizeClusterSecurityGroupIngress</a>. For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>. 
  ## 
  let valid = call_616572.validator(path, query, header, formData, body)
  let scheme = call_616572.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_616572.url(scheme.get, call_616572.host, call_616572.base,
                         call_616572.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_616572, url, valid)

proc call*(call_616573: Call_PostRevokeClusterSecurityGroupIngress_616556;
          ClusterSecurityGroupName: string; EC2SecurityGroupName: string = "";
          EC2SecurityGroupOwnerId: string = ""; CIDRIP: string = "";
          Action: string = "RevokeClusterSecurityGroupIngress";
          Version: string = "2012-12-01"): Recallable =
  ## postRevokeClusterSecurityGroupIngress
  ## Revokes an ingress rule in an Amazon Redshift security group for a previously authorized IP range or Amazon EC2 security group. To add an ingress rule, see <a>AuthorizeClusterSecurityGroupIngress</a>. For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>. 
  ##   ClusterSecurityGroupName: string (required)
  ##                           : The name of the security Group from which to revoke the ingress rule.
  ##   EC2SecurityGroupName: string
  ##                       : The name of the EC2 Security Group whose access is to be revoked. If <code>EC2SecurityGroupName</code> is specified, <code>EC2SecurityGroupOwnerId</code> must also be provided and <code>CIDRIP</code> cannot be provided. 
  ##   EC2SecurityGroupOwnerId: string
  ##                          : <p>The AWS account number of the owner of the security group specified in the <code>EC2SecurityGroupName</code> parameter. The AWS access key ID is not an acceptable value. If <code>EC2SecurityGroupOwnerId</code> is specified, <code>EC2SecurityGroupName</code> must also be provided. and <code>CIDRIP</code> cannot be provided. </p> <p>Example: <code>111122223333</code> </p>
  ##   CIDRIP: string
  ##         : The IP range for which to revoke access. This range must be a valid Classless Inter-Domain Routing (CIDR) block of IP addresses. If <code>CIDRIP</code> is specified, <code>EC2SecurityGroupName</code> and <code>EC2SecurityGroupOwnerId</code> cannot be provided. 
  ##   Action: string (required)
  ##   Version: string (required)
  var query_616574 = newJObject()
  var formData_616575 = newJObject()
  add(formData_616575, "ClusterSecurityGroupName",
      newJString(ClusterSecurityGroupName))
  add(formData_616575, "EC2SecurityGroupName", newJString(EC2SecurityGroupName))
  add(formData_616575, "EC2SecurityGroupOwnerId",
      newJString(EC2SecurityGroupOwnerId))
  add(formData_616575, "CIDRIP", newJString(CIDRIP))
  add(query_616574, "Action", newJString(Action))
  add(query_616574, "Version", newJString(Version))
  result = call_616573.call(nil, query_616574, nil, formData_616575, nil)

var postRevokeClusterSecurityGroupIngress* = Call_PostRevokeClusterSecurityGroupIngress_616556(
    name: "postRevokeClusterSecurityGroupIngress", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=RevokeClusterSecurityGroupIngress",
    validator: validate_PostRevokeClusterSecurityGroupIngress_616557, base: "/",
    url: url_PostRevokeClusterSecurityGroupIngress_616558,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetRevokeClusterSecurityGroupIngress_616537 = ref object of OpenApiRestCall_612642
proc url_GetRevokeClusterSecurityGroupIngress_616539(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetRevokeClusterSecurityGroupIngress_616538(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Revokes an ingress rule in an Amazon Redshift security group for a previously authorized IP range or Amazon EC2 security group. To add an ingress rule, see <a>AuthorizeClusterSecurityGroupIngress</a>. For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   EC2SecurityGroupName: JString
  ##                       : The name of the EC2 Security Group whose access is to be revoked. If <code>EC2SecurityGroupName</code> is specified, <code>EC2SecurityGroupOwnerId</code> must also be provided and <code>CIDRIP</code> cannot be provided. 
  ##   EC2SecurityGroupOwnerId: JString
  ##                          : <p>The AWS account number of the owner of the security group specified in the <code>EC2SecurityGroupName</code> parameter. The AWS access key ID is not an acceptable value. If <code>EC2SecurityGroupOwnerId</code> is specified, <code>EC2SecurityGroupName</code> must also be provided. and <code>CIDRIP</code> cannot be provided. </p> <p>Example: <code>111122223333</code> </p>
  ##   ClusterSecurityGroupName: JString (required)
  ##                           : The name of the security Group from which to revoke the ingress rule.
  ##   Action: JString (required)
  ##   Version: JString (required)
  ##   CIDRIP: JString
  ##         : The IP range for which to revoke access. This range must be a valid Classless Inter-Domain Routing (CIDR) block of IP addresses. If <code>CIDRIP</code> is specified, <code>EC2SecurityGroupName</code> and <code>EC2SecurityGroupOwnerId</code> cannot be provided. 
  section = newJObject()
  var valid_616540 = query.getOrDefault("EC2SecurityGroupName")
  valid_616540 = validateParameter(valid_616540, JString, required = false,
                                 default = nil)
  if valid_616540 != nil:
    section.add "EC2SecurityGroupName", valid_616540
  var valid_616541 = query.getOrDefault("EC2SecurityGroupOwnerId")
  valid_616541 = validateParameter(valid_616541, JString, required = false,
                                 default = nil)
  if valid_616541 != nil:
    section.add "EC2SecurityGroupOwnerId", valid_616541
  assert query != nil, "query argument is necessary due to required `ClusterSecurityGroupName` field"
  var valid_616542 = query.getOrDefault("ClusterSecurityGroupName")
  valid_616542 = validateParameter(valid_616542, JString, required = true,
                                 default = nil)
  if valid_616542 != nil:
    section.add "ClusterSecurityGroupName", valid_616542
  var valid_616543 = query.getOrDefault("Action")
  valid_616543 = validateParameter(valid_616543, JString, required = true, default = newJString(
      "RevokeClusterSecurityGroupIngress"))
  if valid_616543 != nil:
    section.add "Action", valid_616543
  var valid_616544 = query.getOrDefault("Version")
  valid_616544 = validateParameter(valid_616544, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_616544 != nil:
    section.add "Version", valid_616544
  var valid_616545 = query.getOrDefault("CIDRIP")
  valid_616545 = validateParameter(valid_616545, JString, required = false,
                                 default = nil)
  if valid_616545 != nil:
    section.add "CIDRIP", valid_616545
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_616546 = header.getOrDefault("X-Amz-Signature")
  valid_616546 = validateParameter(valid_616546, JString, required = false,
                                 default = nil)
  if valid_616546 != nil:
    section.add "X-Amz-Signature", valid_616546
  var valid_616547 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_616547 = validateParameter(valid_616547, JString, required = false,
                                 default = nil)
  if valid_616547 != nil:
    section.add "X-Amz-Content-Sha256", valid_616547
  var valid_616548 = header.getOrDefault("X-Amz-Date")
  valid_616548 = validateParameter(valid_616548, JString, required = false,
                                 default = nil)
  if valid_616548 != nil:
    section.add "X-Amz-Date", valid_616548
  var valid_616549 = header.getOrDefault("X-Amz-Credential")
  valid_616549 = validateParameter(valid_616549, JString, required = false,
                                 default = nil)
  if valid_616549 != nil:
    section.add "X-Amz-Credential", valid_616549
  var valid_616550 = header.getOrDefault("X-Amz-Security-Token")
  valid_616550 = validateParameter(valid_616550, JString, required = false,
                                 default = nil)
  if valid_616550 != nil:
    section.add "X-Amz-Security-Token", valid_616550
  var valid_616551 = header.getOrDefault("X-Amz-Algorithm")
  valid_616551 = validateParameter(valid_616551, JString, required = false,
                                 default = nil)
  if valid_616551 != nil:
    section.add "X-Amz-Algorithm", valid_616551
  var valid_616552 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_616552 = validateParameter(valid_616552, JString, required = false,
                                 default = nil)
  if valid_616552 != nil:
    section.add "X-Amz-SignedHeaders", valid_616552
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_616553: Call_GetRevokeClusterSecurityGroupIngress_616537;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Revokes an ingress rule in an Amazon Redshift security group for a previously authorized IP range or Amazon EC2 security group. To add an ingress rule, see <a>AuthorizeClusterSecurityGroupIngress</a>. For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>. 
  ## 
  let valid = call_616553.validator(path, query, header, formData, body)
  let scheme = call_616553.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_616553.url(scheme.get, call_616553.host, call_616553.base,
                         call_616553.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_616553, url, valid)

proc call*(call_616554: Call_GetRevokeClusterSecurityGroupIngress_616537;
          ClusterSecurityGroupName: string; EC2SecurityGroupName: string = "";
          EC2SecurityGroupOwnerId: string = "";
          Action: string = "RevokeClusterSecurityGroupIngress";
          Version: string = "2012-12-01"; CIDRIP: string = ""): Recallable =
  ## getRevokeClusterSecurityGroupIngress
  ## Revokes an ingress rule in an Amazon Redshift security group for a previously authorized IP range or Amazon EC2 security group. To add an ingress rule, see <a>AuthorizeClusterSecurityGroupIngress</a>. For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>. 
  ##   EC2SecurityGroupName: string
  ##                       : The name of the EC2 Security Group whose access is to be revoked. If <code>EC2SecurityGroupName</code> is specified, <code>EC2SecurityGroupOwnerId</code> must also be provided and <code>CIDRIP</code> cannot be provided. 
  ##   EC2SecurityGroupOwnerId: string
  ##                          : <p>The AWS account number of the owner of the security group specified in the <code>EC2SecurityGroupName</code> parameter. The AWS access key ID is not an acceptable value. If <code>EC2SecurityGroupOwnerId</code> is specified, <code>EC2SecurityGroupName</code> must also be provided. and <code>CIDRIP</code> cannot be provided. </p> <p>Example: <code>111122223333</code> </p>
  ##   ClusterSecurityGroupName: string (required)
  ##                           : The name of the security Group from which to revoke the ingress rule.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   CIDRIP: string
  ##         : The IP range for which to revoke access. This range must be a valid Classless Inter-Domain Routing (CIDR) block of IP addresses. If <code>CIDRIP</code> is specified, <code>EC2SecurityGroupName</code> and <code>EC2SecurityGroupOwnerId</code> cannot be provided. 
  var query_616555 = newJObject()
  add(query_616555, "EC2SecurityGroupName", newJString(EC2SecurityGroupName))
  add(query_616555, "EC2SecurityGroupOwnerId", newJString(EC2SecurityGroupOwnerId))
  add(query_616555, "ClusterSecurityGroupName",
      newJString(ClusterSecurityGroupName))
  add(query_616555, "Action", newJString(Action))
  add(query_616555, "Version", newJString(Version))
  add(query_616555, "CIDRIP", newJString(CIDRIP))
  result = call_616554.call(nil, query_616555, nil, nil, nil)

var getRevokeClusterSecurityGroupIngress* = Call_GetRevokeClusterSecurityGroupIngress_616537(
    name: "getRevokeClusterSecurityGroupIngress", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=RevokeClusterSecurityGroupIngress",
    validator: validate_GetRevokeClusterSecurityGroupIngress_616538, base: "/",
    url: url_GetRevokeClusterSecurityGroupIngress_616539,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostRevokeSnapshotAccess_616594 = ref object of OpenApiRestCall_612642
proc url_PostRevokeSnapshotAccess_616596(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostRevokeSnapshotAccess_616595(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Removes the ability of the specified AWS customer account to restore the specified snapshot. If the account is currently restoring the snapshot, the restore will run to completion.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_616597 = query.getOrDefault("Action")
  valid_616597 = validateParameter(valid_616597, JString, required = true,
                                 default = newJString("RevokeSnapshotAccess"))
  if valid_616597 != nil:
    section.add "Action", valid_616597
  var valid_616598 = query.getOrDefault("Version")
  valid_616598 = validateParameter(valid_616598, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_616598 != nil:
    section.add "Version", valid_616598
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_616599 = header.getOrDefault("X-Amz-Signature")
  valid_616599 = validateParameter(valid_616599, JString, required = false,
                                 default = nil)
  if valid_616599 != nil:
    section.add "X-Amz-Signature", valid_616599
  var valid_616600 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_616600 = validateParameter(valid_616600, JString, required = false,
                                 default = nil)
  if valid_616600 != nil:
    section.add "X-Amz-Content-Sha256", valid_616600
  var valid_616601 = header.getOrDefault("X-Amz-Date")
  valid_616601 = validateParameter(valid_616601, JString, required = false,
                                 default = nil)
  if valid_616601 != nil:
    section.add "X-Amz-Date", valid_616601
  var valid_616602 = header.getOrDefault("X-Amz-Credential")
  valid_616602 = validateParameter(valid_616602, JString, required = false,
                                 default = nil)
  if valid_616602 != nil:
    section.add "X-Amz-Credential", valid_616602
  var valid_616603 = header.getOrDefault("X-Amz-Security-Token")
  valid_616603 = validateParameter(valid_616603, JString, required = false,
                                 default = nil)
  if valid_616603 != nil:
    section.add "X-Amz-Security-Token", valid_616603
  var valid_616604 = header.getOrDefault("X-Amz-Algorithm")
  valid_616604 = validateParameter(valid_616604, JString, required = false,
                                 default = nil)
  if valid_616604 != nil:
    section.add "X-Amz-Algorithm", valid_616604
  var valid_616605 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_616605 = validateParameter(valid_616605, JString, required = false,
                                 default = nil)
  if valid_616605 != nil:
    section.add "X-Amz-SignedHeaders", valid_616605
  result.add "header", section
  ## parameters in `formData` object:
  ##   SnapshotIdentifier: JString (required)
  ##                     : The identifier of the snapshot that the account can no longer access.
  ##   AccountWithRestoreAccess: JString (required)
  ##                           : The identifier of the AWS customer account that can no longer restore the specified snapshot.
  ##   SnapshotClusterIdentifier: JString
  ##                            : The identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `SnapshotIdentifier` field"
  var valid_616606 = formData.getOrDefault("SnapshotIdentifier")
  valid_616606 = validateParameter(valid_616606, JString, required = true,
                                 default = nil)
  if valid_616606 != nil:
    section.add "SnapshotIdentifier", valid_616606
  var valid_616607 = formData.getOrDefault("AccountWithRestoreAccess")
  valid_616607 = validateParameter(valid_616607, JString, required = true,
                                 default = nil)
  if valid_616607 != nil:
    section.add "AccountWithRestoreAccess", valid_616607
  var valid_616608 = formData.getOrDefault("SnapshotClusterIdentifier")
  valid_616608 = validateParameter(valid_616608, JString, required = false,
                                 default = nil)
  if valid_616608 != nil:
    section.add "SnapshotClusterIdentifier", valid_616608
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_616609: Call_PostRevokeSnapshotAccess_616594; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Removes the ability of the specified AWS customer account to restore the specified snapshot. If the account is currently restoring the snapshot, the restore will run to completion.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_616609.validator(path, query, header, formData, body)
  let scheme = call_616609.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_616609.url(scheme.get, call_616609.host, call_616609.base,
                         call_616609.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_616609, url, valid)

proc call*(call_616610: Call_PostRevokeSnapshotAccess_616594;
          SnapshotIdentifier: string; AccountWithRestoreAccess: string;
          Action: string = "RevokeSnapshotAccess";
          SnapshotClusterIdentifier: string = ""; Version: string = "2012-12-01"): Recallable =
  ## postRevokeSnapshotAccess
  ## <p>Removes the ability of the specified AWS customer account to restore the specified snapshot. If the account is currently restoring the snapshot, the restore will run to completion.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   SnapshotIdentifier: string (required)
  ##                     : The identifier of the snapshot that the account can no longer access.
  ##   Action: string (required)
  ##   AccountWithRestoreAccess: string (required)
  ##                           : The identifier of the AWS customer account that can no longer restore the specified snapshot.
  ##   SnapshotClusterIdentifier: string
  ##                            : The identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.
  ##   Version: string (required)
  var query_616611 = newJObject()
  var formData_616612 = newJObject()
  add(formData_616612, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_616611, "Action", newJString(Action))
  add(formData_616612, "AccountWithRestoreAccess",
      newJString(AccountWithRestoreAccess))
  add(formData_616612, "SnapshotClusterIdentifier",
      newJString(SnapshotClusterIdentifier))
  add(query_616611, "Version", newJString(Version))
  result = call_616610.call(nil, query_616611, nil, formData_616612, nil)

var postRevokeSnapshotAccess* = Call_PostRevokeSnapshotAccess_616594(
    name: "postRevokeSnapshotAccess", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=RevokeSnapshotAccess",
    validator: validate_PostRevokeSnapshotAccess_616595, base: "/",
    url: url_PostRevokeSnapshotAccess_616596, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetRevokeSnapshotAccess_616576 = ref object of OpenApiRestCall_612642
proc url_GetRevokeSnapshotAccess_616578(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetRevokeSnapshotAccess_616577(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Removes the ability of the specified AWS customer account to restore the specified snapshot. If the account is currently restoring the snapshot, the restore will run to completion.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   SnapshotIdentifier: JString (required)
  ##                     : The identifier of the snapshot that the account can no longer access.
  ##   SnapshotClusterIdentifier: JString
  ##                            : The identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.
  ##   Action: JString (required)
  ##   Version: JString (required)
  ##   AccountWithRestoreAccess: JString (required)
  ##                           : The identifier of the AWS customer account that can no longer restore the specified snapshot.
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `SnapshotIdentifier` field"
  var valid_616579 = query.getOrDefault("SnapshotIdentifier")
  valid_616579 = validateParameter(valid_616579, JString, required = true,
                                 default = nil)
  if valid_616579 != nil:
    section.add "SnapshotIdentifier", valid_616579
  var valid_616580 = query.getOrDefault("SnapshotClusterIdentifier")
  valid_616580 = validateParameter(valid_616580, JString, required = false,
                                 default = nil)
  if valid_616580 != nil:
    section.add "SnapshotClusterIdentifier", valid_616580
  var valid_616581 = query.getOrDefault("Action")
  valid_616581 = validateParameter(valid_616581, JString, required = true,
                                 default = newJString("RevokeSnapshotAccess"))
  if valid_616581 != nil:
    section.add "Action", valid_616581
  var valid_616582 = query.getOrDefault("Version")
  valid_616582 = validateParameter(valid_616582, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_616582 != nil:
    section.add "Version", valid_616582
  var valid_616583 = query.getOrDefault("AccountWithRestoreAccess")
  valid_616583 = validateParameter(valid_616583, JString, required = true,
                                 default = nil)
  if valid_616583 != nil:
    section.add "AccountWithRestoreAccess", valid_616583
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_616584 = header.getOrDefault("X-Amz-Signature")
  valid_616584 = validateParameter(valid_616584, JString, required = false,
                                 default = nil)
  if valid_616584 != nil:
    section.add "X-Amz-Signature", valid_616584
  var valid_616585 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_616585 = validateParameter(valid_616585, JString, required = false,
                                 default = nil)
  if valid_616585 != nil:
    section.add "X-Amz-Content-Sha256", valid_616585
  var valid_616586 = header.getOrDefault("X-Amz-Date")
  valid_616586 = validateParameter(valid_616586, JString, required = false,
                                 default = nil)
  if valid_616586 != nil:
    section.add "X-Amz-Date", valid_616586
  var valid_616587 = header.getOrDefault("X-Amz-Credential")
  valid_616587 = validateParameter(valid_616587, JString, required = false,
                                 default = nil)
  if valid_616587 != nil:
    section.add "X-Amz-Credential", valid_616587
  var valid_616588 = header.getOrDefault("X-Amz-Security-Token")
  valid_616588 = validateParameter(valid_616588, JString, required = false,
                                 default = nil)
  if valid_616588 != nil:
    section.add "X-Amz-Security-Token", valid_616588
  var valid_616589 = header.getOrDefault("X-Amz-Algorithm")
  valid_616589 = validateParameter(valid_616589, JString, required = false,
                                 default = nil)
  if valid_616589 != nil:
    section.add "X-Amz-Algorithm", valid_616589
  var valid_616590 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_616590 = validateParameter(valid_616590, JString, required = false,
                                 default = nil)
  if valid_616590 != nil:
    section.add "X-Amz-SignedHeaders", valid_616590
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_616591: Call_GetRevokeSnapshotAccess_616576; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Removes the ability of the specified AWS customer account to restore the specified snapshot. If the account is currently restoring the snapshot, the restore will run to completion.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_616591.validator(path, query, header, formData, body)
  let scheme = call_616591.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_616591.url(scheme.get, call_616591.host, call_616591.base,
                         call_616591.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_616591, url, valid)

proc call*(call_616592: Call_GetRevokeSnapshotAccess_616576;
          SnapshotIdentifier: string; AccountWithRestoreAccess: string;
          SnapshotClusterIdentifier: string = "";
          Action: string = "RevokeSnapshotAccess"; Version: string = "2012-12-01"): Recallable =
  ## getRevokeSnapshotAccess
  ## <p>Removes the ability of the specified AWS customer account to restore the specified snapshot. If the account is currently restoring the snapshot, the restore will run to completion.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   SnapshotIdentifier: string (required)
  ##                     : The identifier of the snapshot that the account can no longer access.
  ##   SnapshotClusterIdentifier: string
  ##                            : The identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   AccountWithRestoreAccess: string (required)
  ##                           : The identifier of the AWS customer account that can no longer restore the specified snapshot.
  var query_616593 = newJObject()
  add(query_616593, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_616593, "SnapshotClusterIdentifier",
      newJString(SnapshotClusterIdentifier))
  add(query_616593, "Action", newJString(Action))
  add(query_616593, "Version", newJString(Version))
  add(query_616593, "AccountWithRestoreAccess",
      newJString(AccountWithRestoreAccess))
  result = call_616592.call(nil, query_616593, nil, nil, nil)

var getRevokeSnapshotAccess* = Call_GetRevokeSnapshotAccess_616576(
    name: "getRevokeSnapshotAccess", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=RevokeSnapshotAccess",
    validator: validate_GetRevokeSnapshotAccess_616577, base: "/",
    url: url_GetRevokeSnapshotAccess_616578, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostRotateEncryptionKey_616629 = ref object of OpenApiRestCall_612642
proc url_PostRotateEncryptionKey_616631(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostRotateEncryptionKey_616630(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Rotates the encryption keys for a cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_616632 = query.getOrDefault("Action")
  valid_616632 = validateParameter(valid_616632, JString, required = true,
                                 default = newJString("RotateEncryptionKey"))
  if valid_616632 != nil:
    section.add "Action", valid_616632
  var valid_616633 = query.getOrDefault("Version")
  valid_616633 = validateParameter(valid_616633, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_616633 != nil:
    section.add "Version", valid_616633
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_616634 = header.getOrDefault("X-Amz-Signature")
  valid_616634 = validateParameter(valid_616634, JString, required = false,
                                 default = nil)
  if valid_616634 != nil:
    section.add "X-Amz-Signature", valid_616634
  var valid_616635 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_616635 = validateParameter(valid_616635, JString, required = false,
                                 default = nil)
  if valid_616635 != nil:
    section.add "X-Amz-Content-Sha256", valid_616635
  var valid_616636 = header.getOrDefault("X-Amz-Date")
  valid_616636 = validateParameter(valid_616636, JString, required = false,
                                 default = nil)
  if valid_616636 != nil:
    section.add "X-Amz-Date", valid_616636
  var valid_616637 = header.getOrDefault("X-Amz-Credential")
  valid_616637 = validateParameter(valid_616637, JString, required = false,
                                 default = nil)
  if valid_616637 != nil:
    section.add "X-Amz-Credential", valid_616637
  var valid_616638 = header.getOrDefault("X-Amz-Security-Token")
  valid_616638 = validateParameter(valid_616638, JString, required = false,
                                 default = nil)
  if valid_616638 != nil:
    section.add "X-Amz-Security-Token", valid_616638
  var valid_616639 = header.getOrDefault("X-Amz-Algorithm")
  valid_616639 = validateParameter(valid_616639, JString, required = false,
                                 default = nil)
  if valid_616639 != nil:
    section.add "X-Amz-Algorithm", valid_616639
  var valid_616640 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_616640 = validateParameter(valid_616640, JString, required = false,
                                 default = nil)
  if valid_616640 != nil:
    section.add "X-Amz-SignedHeaders", valid_616640
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of the cluster that you want to rotate the encryption keys for.</p> <p>Constraints: Must be the name of valid cluster that has encryption enabled.</p>
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_616641 = formData.getOrDefault("ClusterIdentifier")
  valid_616641 = validateParameter(valid_616641, JString, required = true,
                                 default = nil)
  if valid_616641 != nil:
    section.add "ClusterIdentifier", valid_616641
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_616642: Call_PostRotateEncryptionKey_616629; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Rotates the encryption keys for a cluster.
  ## 
  let valid = call_616642.validator(path, query, header, formData, body)
  let scheme = call_616642.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_616642.url(scheme.get, call_616642.host, call_616642.base,
                         call_616642.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_616642, url, valid)

proc call*(call_616643: Call_PostRotateEncryptionKey_616629;
          ClusterIdentifier: string; Action: string = "RotateEncryptionKey";
          Version: string = "2012-12-01"): Recallable =
  ## postRotateEncryptionKey
  ## Rotates the encryption keys for a cluster.
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of the cluster that you want to rotate the encryption keys for.</p> <p>Constraints: Must be the name of valid cluster that has encryption enabled.</p>
  ##   Action: string (required)
  ##   Version: string (required)
  var query_616644 = newJObject()
  var formData_616645 = newJObject()
  add(formData_616645, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_616644, "Action", newJString(Action))
  add(query_616644, "Version", newJString(Version))
  result = call_616643.call(nil, query_616644, nil, formData_616645, nil)

var postRotateEncryptionKey* = Call_PostRotateEncryptionKey_616629(
    name: "postRotateEncryptionKey", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=RotateEncryptionKey",
    validator: validate_PostRotateEncryptionKey_616630, base: "/",
    url: url_PostRotateEncryptionKey_616631, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetRotateEncryptionKey_616613 = ref object of OpenApiRestCall_612642
proc url_GetRotateEncryptionKey_616615(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetRotateEncryptionKey_616614(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Rotates the encryption keys for a cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of the cluster that you want to rotate the encryption keys for.</p> <p>Constraints: Must be the name of valid cluster that has encryption enabled.</p>
  ##   Version: JString (required)
  section = newJObject()
  var valid_616616 = query.getOrDefault("Action")
  valid_616616 = validateParameter(valid_616616, JString, required = true,
                                 default = newJString("RotateEncryptionKey"))
  if valid_616616 != nil:
    section.add "Action", valid_616616
  var valid_616617 = query.getOrDefault("ClusterIdentifier")
  valid_616617 = validateParameter(valid_616617, JString, required = true,
                                 default = nil)
  if valid_616617 != nil:
    section.add "ClusterIdentifier", valid_616617
  var valid_616618 = query.getOrDefault("Version")
  valid_616618 = validateParameter(valid_616618, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_616618 != nil:
    section.add "Version", valid_616618
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_616619 = header.getOrDefault("X-Amz-Signature")
  valid_616619 = validateParameter(valid_616619, JString, required = false,
                                 default = nil)
  if valid_616619 != nil:
    section.add "X-Amz-Signature", valid_616619
  var valid_616620 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_616620 = validateParameter(valid_616620, JString, required = false,
                                 default = nil)
  if valid_616620 != nil:
    section.add "X-Amz-Content-Sha256", valid_616620
  var valid_616621 = header.getOrDefault("X-Amz-Date")
  valid_616621 = validateParameter(valid_616621, JString, required = false,
                                 default = nil)
  if valid_616621 != nil:
    section.add "X-Amz-Date", valid_616621
  var valid_616622 = header.getOrDefault("X-Amz-Credential")
  valid_616622 = validateParameter(valid_616622, JString, required = false,
                                 default = nil)
  if valid_616622 != nil:
    section.add "X-Amz-Credential", valid_616622
  var valid_616623 = header.getOrDefault("X-Amz-Security-Token")
  valid_616623 = validateParameter(valid_616623, JString, required = false,
                                 default = nil)
  if valid_616623 != nil:
    section.add "X-Amz-Security-Token", valid_616623
  var valid_616624 = header.getOrDefault("X-Amz-Algorithm")
  valid_616624 = validateParameter(valid_616624, JString, required = false,
                                 default = nil)
  if valid_616624 != nil:
    section.add "X-Amz-Algorithm", valid_616624
  var valid_616625 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_616625 = validateParameter(valid_616625, JString, required = false,
                                 default = nil)
  if valid_616625 != nil:
    section.add "X-Amz-SignedHeaders", valid_616625
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_616626: Call_GetRotateEncryptionKey_616613; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Rotates the encryption keys for a cluster.
  ## 
  let valid = call_616626.validator(path, query, header, formData, body)
  let scheme = call_616626.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_616626.url(scheme.get, call_616626.host, call_616626.base,
                         call_616626.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_616626, url, valid)

proc call*(call_616627: Call_GetRotateEncryptionKey_616613;
          ClusterIdentifier: string; Action: string = "RotateEncryptionKey";
          Version: string = "2012-12-01"): Recallable =
  ## getRotateEncryptionKey
  ## Rotates the encryption keys for a cluster.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of the cluster that you want to rotate the encryption keys for.</p> <p>Constraints: Must be the name of valid cluster that has encryption enabled.</p>
  ##   Version: string (required)
  var query_616628 = newJObject()
  add(query_616628, "Action", newJString(Action))
  add(query_616628, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_616628, "Version", newJString(Version))
  result = call_616627.call(nil, query_616628, nil, nil, nil)

var getRotateEncryptionKey* = Call_GetRotateEncryptionKey_616613(
    name: "getRotateEncryptionKey", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=RotateEncryptionKey",
    validator: validate_GetRotateEncryptionKey_616614, base: "/",
    url: url_GetRotateEncryptionKey_616615, schemes: {Scheme.Https, Scheme.Http})
export
  rest

type
  EnvKind = enum
    BakeIntoBinary = "Baking $1 into the binary",
    FetchFromEnv = "Fetch $1 from the environment"
template sloppyConst(via: EnvKind; name: untyped): untyped =
  import
    macros

  const
    name {.strdefine.}: string = case via
    of BakeIntoBinary:
      getEnv(astToStr(name), "")
    of FetchFromEnv:
      ""
  static :
    let msg = block:
      if name == "":
        "Missing $1 in the environment"
      else:
        $via
    warning msg % [astToStr(name)]

sloppyConst FetchFromEnv, AWS_ACCESS_KEY_ID
sloppyConst FetchFromEnv, AWS_SECRET_ACCESS_KEY
sloppyConst BakeIntoBinary, AWS_REGION
sloppyConst FetchFromEnv, AWS_ACCOUNT_ID
proc atozSign(recall: var Recallable; query: JsonNode; algo: SigningAlgo = SHA256) =
  let
    date = makeDateTime()
    access = os.getEnv("AWS_ACCESS_KEY_ID", AWS_ACCESS_KEY_ID)
    secret = os.getEnv("AWS_SECRET_ACCESS_KEY", AWS_SECRET_ACCESS_KEY)
    region = os.getEnv("AWS_REGION", AWS_REGION)
  assert secret != "", "need $AWS_SECRET_ACCESS_KEY in environment"
  assert access != "", "need $AWS_ACCESS_KEY_ID in environment"
  assert region != "", "need $AWS_REGION in environment"
  var
    normal: PathNormal
    url = normalizeUrl(recall.url, query, normalize = normal)
    scheme = parseEnum[Scheme](url.scheme)
  assert scheme in awsServers, "unknown scheme `" & $scheme & "`"
  assert region in awsServers[scheme], "unknown region `" & region & "`"
  url.hostname = awsServers[scheme][region]
  case awsServiceName.toLowerAscii
  of "s3":
    normal = PathNormal.S3
  else:
    normal = PathNormal.Default
  recall.headers["Host"] = url.hostname
  recall.headers["X-Amz-Date"] = date
  let
    algo = SHA256
    scope = credentialScope(region = region, service = awsServiceName, date = date)
    request = canonicalRequest(recall.meth, $url, query, recall.headers, recall.body,
                             normalize = normal, digest = algo)
    sts = stringToSign(request.hash(algo), scope, date = date, digest = algo)
    signature = calculateSignature(secret = secret, date = date, region = region,
                                 service = awsServiceName, sts, digest = algo)
  var auth = $algo & " "
  auth &= "Credential=" & access / scope & ", "
  auth &= "SignedHeaders=" & recall.headers.signedHeaders & ", "
  auth &= "Signature=" & signature
  recall.headers["Authorization"] = auth
  recall.headers.del "Host"
  recall.url = $url

method atozHook(call: OpenApiRestCall; url: Uri; input: JsonNode): Recallable {.base.} =
  ## the hook is a terrible earworm
  var headers = newHttpHeaders(massageHeaders(input.getOrDefault("header")))
  let
    body = input.getOrDefault("body")
    text = if body == nil:
      "" elif body.kind == JString:
      body.getStr else:
      $body
  if body != nil and body.kind != JString:
    if not headers.hasKey("content-type"):
      headers["content-type"] = "application/x-amz-json-1.0"
  const
    XAmzSecurityToken = "X-Amz-Security-Token"
  if not headers.hasKey(XAmzSecurityToken):
    let session = getEnv("AWS_SESSION_TOKEN", "")
    if session != "":
      headers[XAmzSecurityToken] = session
  result = newRecallable(call, url, headers, text)
  result.atozSign(input.getOrDefault("query"), SHA256)
