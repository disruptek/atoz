
import
  json, options, hashes, tables, openapi/rest, os, uri, strutils, httpcore, sigv4

## auto-generated via openapi macro
## title: Amazon Redshift
## version: 2012-12-01
## termsOfService: https://aws.amazon.com/service-terms/
## license:
##     name: Apache 2.0 License
##     url: http://www.apache.org/licenses/
## 
## <fullname>Amazon Redshift</fullname> <p> <b>Overview</b> </p> <p>This is an interface reference for Amazon Redshift. It contains documentation for one of the programming or command line interfaces you can use to manage Amazon Redshift clusters. Note that Amazon Redshift is asynchronous, which means that some interfaces may require techniques, such as polling or asynchronous callback handlers, to determine when a command has been applied. In this reference, the parameter descriptions indicate whether a change is applied immediately, on the next instance reboot, or during the next maintenance window. For a summary of the Amazon Redshift cluster management interfaces, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/using-aws-sdk.html">Using the Amazon Redshift Management Interfaces</a>.</p> <p>Amazon Redshift manages all the work of setting up, operating, and scaling a data warehouse: provisioning capacity, monitoring and backing up the cluster, and applying patches and upgrades to the Amazon Redshift engine. You can focus on using your data to acquire new insights for your business and customers.</p> <p>If you are a first-time user of Amazon Redshift, we recommend that you begin by reading the <a href="https://docs.aws.amazon.com/redshift/latest/gsg/getting-started.html">Amazon Redshift Getting Started Guide</a>.</p> <p>If you are a database developer, the <a href="https://docs.aws.amazon.com/redshift/latest/dg/welcome.html">Amazon Redshift Database Developer Guide</a> explains how to design, build, query, and maintain the databases that make up your data warehouse. </p>
## 
## Amazon Web Services documentation
## https://docs.aws.amazon.com/redshift/
type
  Scheme {.pure.} = enum
    Https = "https", Http = "http", Wss = "wss", Ws = "ws"
  ValidatorSignature = proc (query: JsonNode = nil; body: JsonNode = nil;
                          header: JsonNode = nil; path: JsonNode = nil;
                          formData: JsonNode = nil): JsonNode
  OpenApiRestCall = ref object of RestCall
    validator*: ValidatorSignature
    route*: string
    base*: string
    host*: string
    schemes*: set[Scheme]
    url*: proc (protocol: Scheme; host: string; base: string; route: string;
              path: JsonNode): string

  OpenApiRestCall_772581 = ref object of OpenApiRestCall
proc hash(scheme: Scheme): Hash {.used.} =
  result = hash(ord(scheme))

proc clone[T: OpenApiRestCall_772581](t: T): T {.used.} =
  result = T(name: t.name, meth: t.meth, host: t.host, base: t.base, route: t.route,
           schemes: t.schemes, validator: t.validator, url: t.url)

proc pickScheme(t: OpenApiRestCall_772581): Option[Scheme] {.used.} =
  ## select a supported scheme from a set of candidates
  for scheme in Scheme.low ..
      Scheme.high:
    if scheme notin t.schemes:
      continue
    if scheme in [Scheme.Https, Scheme.Wss]:
      when defined(ssl):
        return some(scheme)
      else:
        continue
    return some(scheme)

proc validateParameter(js: JsonNode; kind: JsonNodeKind; required: bool;
                      default: JsonNode = nil): JsonNode =
  ## ensure an input is of the correct json type and yield
  ## a suitable default value when appropriate
  if js ==
      nil:
    if default != nil:
      return validateParameter(default, kind, required = required)
  result = js
  if result ==
      nil:
    assert not required, $kind & " expected; received nil"
    if required:
      result = newJNull()
  else:
    assert js.kind ==
        kind, $kind & " expected; received " &
        $js.kind

type
  KeyVal {.used.} = tuple[key: string, val: string]
  PathTokenKind = enum
    ConstantSegment, VariableSegment
  PathToken = tuple[kind: PathTokenKind, value: string]
proc hydratePath(input: JsonNode; segments: seq[PathToken]): Option[string] =
  ## reconstitute a path with constants and variable values taken from json
  var head: string
  if segments.len == 0:
    return some("")
  head = segments[0].value
  case segments[0].kind
  of ConstantSegment:
    discard
  of VariableSegment:
    if head notin input:
      return
    let js = input[head]
    if js.kind notin {JString, JInt, JFloat, JNull, JBool}:
      return
    head = $js
  var remainder = input.hydratePath(segments[1 ..^ 1])
  if remainder.isNone:
    return
  result = some(head & remainder.get())

const
  awsServers = {Scheme.Http: {"ap-northeast-1": "redshift.ap-northeast-1.amazonaws.com", "ap-southeast-1": "redshift.ap-southeast-1.amazonaws.com",
                           "us-west-2": "redshift.us-west-2.amazonaws.com",
                           "eu-west-2": "redshift.eu-west-2.amazonaws.com", "ap-northeast-3": "redshift.ap-northeast-3.amazonaws.com", "eu-central-1": "redshift.eu-central-1.amazonaws.com",
                           "us-east-2": "redshift.us-east-2.amazonaws.com",
                           "us-east-1": "redshift.us-east-1.amazonaws.com", "cn-northwest-1": "redshift.cn-northwest-1.amazonaws.com.cn",
                           "ap-south-1": "redshift.ap-south-1.amazonaws.com",
                           "eu-north-1": "redshift.eu-north-1.amazonaws.com", "ap-northeast-2": "redshift.ap-northeast-2.amazonaws.com",
                           "us-west-1": "redshift.us-west-1.amazonaws.com", "us-gov-east-1": "redshift.us-gov-east-1.amazonaws.com",
                           "eu-west-3": "redshift.eu-west-3.amazonaws.com", "cn-north-1": "redshift.cn-north-1.amazonaws.com.cn",
                           "sa-east-1": "redshift.sa-east-1.amazonaws.com",
                           "eu-west-1": "redshift.eu-west-1.amazonaws.com", "us-gov-west-1": "redshift.us-gov-west-1.amazonaws.com", "ap-southeast-2": "redshift.ap-southeast-2.amazonaws.com", "ca-central-1": "redshift.ca-central-1.amazonaws.com"}.toTable, Scheme.Https: {
      "ap-northeast-1": "redshift.ap-northeast-1.amazonaws.com",
      "ap-southeast-1": "redshift.ap-southeast-1.amazonaws.com",
      "us-west-2": "redshift.us-west-2.amazonaws.com",
      "eu-west-2": "redshift.eu-west-2.amazonaws.com",
      "ap-northeast-3": "redshift.ap-northeast-3.amazonaws.com",
      "eu-central-1": "redshift.eu-central-1.amazonaws.com",
      "us-east-2": "redshift.us-east-2.amazonaws.com",
      "us-east-1": "redshift.us-east-1.amazonaws.com",
      "cn-northwest-1": "redshift.cn-northwest-1.amazonaws.com.cn",
      "ap-south-1": "redshift.ap-south-1.amazonaws.com",
      "eu-north-1": "redshift.eu-north-1.amazonaws.com",
      "ap-northeast-2": "redshift.ap-northeast-2.amazonaws.com",
      "us-west-1": "redshift.us-west-1.amazonaws.com",
      "us-gov-east-1": "redshift.us-gov-east-1.amazonaws.com",
      "eu-west-3": "redshift.eu-west-3.amazonaws.com",
      "cn-north-1": "redshift.cn-north-1.amazonaws.com.cn",
      "sa-east-1": "redshift.sa-east-1.amazonaws.com",
      "eu-west-1": "redshift.eu-west-1.amazonaws.com",
      "us-gov-west-1": "redshift.us-gov-west-1.amazonaws.com",
      "ap-southeast-2": "redshift.ap-southeast-2.amazonaws.com",
      "ca-central-1": "redshift.ca-central-1.amazonaws.com"}.toTable}.toTable
const
  awsServiceName = "redshift"
method hook(call: OpenApiRestCall; url: string; input: JsonNode): Recallable {.base.}
type
  Call_PostAcceptReservedNodeExchange_773189 = ref object of OpenApiRestCall_772581
proc url_PostAcceptReservedNodeExchange_773191(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_PostAcceptReservedNodeExchange_773190(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Exchanges a DC1 Reserved Node for a DC2 Reserved Node with no changes to the configuration (term, payment type, or number of nodes) and no additional costs. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_773192 = query.getOrDefault("Action")
  valid_773192 = validateParameter(valid_773192, JString, required = true, default = newJString(
      "AcceptReservedNodeExchange"))
  if valid_773192 != nil:
    section.add "Action", valid_773192
  var valid_773193 = query.getOrDefault("Version")
  valid_773193 = validateParameter(valid_773193, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_773193 != nil:
    section.add "Version", valid_773193
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_773194 = header.getOrDefault("X-Amz-Date")
  valid_773194 = validateParameter(valid_773194, JString, required = false,
                                 default = nil)
  if valid_773194 != nil:
    section.add "X-Amz-Date", valid_773194
  var valid_773195 = header.getOrDefault("X-Amz-Security-Token")
  valid_773195 = validateParameter(valid_773195, JString, required = false,
                                 default = nil)
  if valid_773195 != nil:
    section.add "X-Amz-Security-Token", valid_773195
  var valid_773196 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_773196 = validateParameter(valid_773196, JString, required = false,
                                 default = nil)
  if valid_773196 != nil:
    section.add "X-Amz-Content-Sha256", valid_773196
  var valid_773197 = header.getOrDefault("X-Amz-Algorithm")
  valid_773197 = validateParameter(valid_773197, JString, required = false,
                                 default = nil)
  if valid_773197 != nil:
    section.add "X-Amz-Algorithm", valid_773197
  var valid_773198 = header.getOrDefault("X-Amz-Signature")
  valid_773198 = validateParameter(valid_773198, JString, required = false,
                                 default = nil)
  if valid_773198 != nil:
    section.add "X-Amz-Signature", valid_773198
  var valid_773199 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_773199 = validateParameter(valid_773199, JString, required = false,
                                 default = nil)
  if valid_773199 != nil:
    section.add "X-Amz-SignedHeaders", valid_773199
  var valid_773200 = header.getOrDefault("X-Amz-Credential")
  valid_773200 = validateParameter(valid_773200, JString, required = false,
                                 default = nil)
  if valid_773200 != nil:
    section.add "X-Amz-Credential", valid_773200
  result.add "header", section
  ## parameters in `formData` object:
  ##   ReservedNodeId: JString (required)
  ##                 : A string representing the node identifier of the DC1 Reserved Node to be exchanged.
  ##   TargetReservedNodeOfferingId: JString (required)
  ##                               : The unique identifier of the DC2 Reserved Node offering to be used for the exchange. You can obtain the value for the parameter by calling <a>GetReservedNodeExchangeOfferings</a> 
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `ReservedNodeId` field"
  var valid_773201 = formData.getOrDefault("ReservedNodeId")
  valid_773201 = validateParameter(valid_773201, JString, required = true,
                                 default = nil)
  if valid_773201 != nil:
    section.add "ReservedNodeId", valid_773201
  var valid_773202 = formData.getOrDefault("TargetReservedNodeOfferingId")
  valid_773202 = validateParameter(valid_773202, JString, required = true,
                                 default = nil)
  if valid_773202 != nil:
    section.add "TargetReservedNodeOfferingId", valid_773202
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_773203: Call_PostAcceptReservedNodeExchange_773189; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Exchanges a DC1 Reserved Node for a DC2 Reserved Node with no changes to the configuration (term, payment type, or number of nodes) and no additional costs. 
  ## 
  let valid = call_773203.validator(path, query, header, formData, body)
  let scheme = call_773203.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_773203.url(scheme.get, call_773203.host, call_773203.base,
                         call_773203.route, valid.getOrDefault("path"))
  result = hook(call_773203, url, valid)

proc call*(call_773204: Call_PostAcceptReservedNodeExchange_773189;
          ReservedNodeId: string; TargetReservedNodeOfferingId: string;
          Action: string = "AcceptReservedNodeExchange";
          Version: string = "2012-12-01"): Recallable =
  ## postAcceptReservedNodeExchange
  ## Exchanges a DC1 Reserved Node for a DC2 Reserved Node with no changes to the configuration (term, payment type, or number of nodes) and no additional costs. 
  ##   ReservedNodeId: string (required)
  ##                 : A string representing the node identifier of the DC1 Reserved Node to be exchanged.
  ##   TargetReservedNodeOfferingId: string (required)
  ##                               : The unique identifier of the DC2 Reserved Node offering to be used for the exchange. You can obtain the value for the parameter by calling <a>GetReservedNodeExchangeOfferings</a> 
  ##   Action: string (required)
  ##   Version: string (required)
  var query_773205 = newJObject()
  var formData_773206 = newJObject()
  add(formData_773206, "ReservedNodeId", newJString(ReservedNodeId))
  add(formData_773206, "TargetReservedNodeOfferingId",
      newJString(TargetReservedNodeOfferingId))
  add(query_773205, "Action", newJString(Action))
  add(query_773205, "Version", newJString(Version))
  result = call_773204.call(nil, query_773205, nil, formData_773206, nil)

var postAcceptReservedNodeExchange* = Call_PostAcceptReservedNodeExchange_773189(
    name: "postAcceptReservedNodeExchange", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=AcceptReservedNodeExchange",
    validator: validate_PostAcceptReservedNodeExchange_773190, base: "/",
    url: url_PostAcceptReservedNodeExchange_773191,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetAcceptReservedNodeExchange_772917 = ref object of OpenApiRestCall_772581
proc url_GetAcceptReservedNodeExchange_772919(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_GetAcceptReservedNodeExchange_772918(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Exchanges a DC1 Reserved Node for a DC2 Reserved Node with no changes to the configuration (term, payment type, or number of nodes) and no additional costs. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   TargetReservedNodeOfferingId: JString (required)
  ##                               : The unique identifier of the DC2 Reserved Node offering to be used for the exchange. You can obtain the value for the parameter by calling <a>GetReservedNodeExchangeOfferings</a> 
  ##   Version: JString (required)
  ##   ReservedNodeId: JString (required)
  ##                 : A string representing the node identifier of the DC1 Reserved Node to be exchanged.
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_773044 = query.getOrDefault("Action")
  valid_773044 = validateParameter(valid_773044, JString, required = true, default = newJString(
      "AcceptReservedNodeExchange"))
  if valid_773044 != nil:
    section.add "Action", valid_773044
  var valid_773045 = query.getOrDefault("TargetReservedNodeOfferingId")
  valid_773045 = validateParameter(valid_773045, JString, required = true,
                                 default = nil)
  if valid_773045 != nil:
    section.add "TargetReservedNodeOfferingId", valid_773045
  var valid_773046 = query.getOrDefault("Version")
  valid_773046 = validateParameter(valid_773046, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_773046 != nil:
    section.add "Version", valid_773046
  var valid_773047 = query.getOrDefault("ReservedNodeId")
  valid_773047 = validateParameter(valid_773047, JString, required = true,
                                 default = nil)
  if valid_773047 != nil:
    section.add "ReservedNodeId", valid_773047
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_773048 = header.getOrDefault("X-Amz-Date")
  valid_773048 = validateParameter(valid_773048, JString, required = false,
                                 default = nil)
  if valid_773048 != nil:
    section.add "X-Amz-Date", valid_773048
  var valid_773049 = header.getOrDefault("X-Amz-Security-Token")
  valid_773049 = validateParameter(valid_773049, JString, required = false,
                                 default = nil)
  if valid_773049 != nil:
    section.add "X-Amz-Security-Token", valid_773049
  var valid_773050 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_773050 = validateParameter(valid_773050, JString, required = false,
                                 default = nil)
  if valid_773050 != nil:
    section.add "X-Amz-Content-Sha256", valid_773050
  var valid_773051 = header.getOrDefault("X-Amz-Algorithm")
  valid_773051 = validateParameter(valid_773051, JString, required = false,
                                 default = nil)
  if valid_773051 != nil:
    section.add "X-Amz-Algorithm", valid_773051
  var valid_773052 = header.getOrDefault("X-Amz-Signature")
  valid_773052 = validateParameter(valid_773052, JString, required = false,
                                 default = nil)
  if valid_773052 != nil:
    section.add "X-Amz-Signature", valid_773052
  var valid_773053 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_773053 = validateParameter(valid_773053, JString, required = false,
                                 default = nil)
  if valid_773053 != nil:
    section.add "X-Amz-SignedHeaders", valid_773053
  var valid_773054 = header.getOrDefault("X-Amz-Credential")
  valid_773054 = validateParameter(valid_773054, JString, required = false,
                                 default = nil)
  if valid_773054 != nil:
    section.add "X-Amz-Credential", valid_773054
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_773077: Call_GetAcceptReservedNodeExchange_772917; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Exchanges a DC1 Reserved Node for a DC2 Reserved Node with no changes to the configuration (term, payment type, or number of nodes) and no additional costs. 
  ## 
  let valid = call_773077.validator(path, query, header, formData, body)
  let scheme = call_773077.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_773077.url(scheme.get, call_773077.host, call_773077.base,
                         call_773077.route, valid.getOrDefault("path"))
  result = hook(call_773077, url, valid)

proc call*(call_773148: Call_GetAcceptReservedNodeExchange_772917;
          TargetReservedNodeOfferingId: string; ReservedNodeId: string;
          Action: string = "AcceptReservedNodeExchange";
          Version: string = "2012-12-01"): Recallable =
  ## getAcceptReservedNodeExchange
  ## Exchanges a DC1 Reserved Node for a DC2 Reserved Node with no changes to the configuration (term, payment type, or number of nodes) and no additional costs. 
  ##   Action: string (required)
  ##   TargetReservedNodeOfferingId: string (required)
  ##                               : The unique identifier of the DC2 Reserved Node offering to be used for the exchange. You can obtain the value for the parameter by calling <a>GetReservedNodeExchangeOfferings</a> 
  ##   Version: string (required)
  ##   ReservedNodeId: string (required)
  ##                 : A string representing the node identifier of the DC1 Reserved Node to be exchanged.
  var query_773149 = newJObject()
  add(query_773149, "Action", newJString(Action))
  add(query_773149, "TargetReservedNodeOfferingId",
      newJString(TargetReservedNodeOfferingId))
  add(query_773149, "Version", newJString(Version))
  add(query_773149, "ReservedNodeId", newJString(ReservedNodeId))
  result = call_773148.call(nil, query_773149, nil, nil, nil)

var getAcceptReservedNodeExchange* = Call_GetAcceptReservedNodeExchange_772917(
    name: "getAcceptReservedNodeExchange", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=AcceptReservedNodeExchange",
    validator: validate_GetAcceptReservedNodeExchange_772918, base: "/",
    url: url_GetAcceptReservedNodeExchange_772919,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostAuthorizeClusterSecurityGroupIngress_773226 = ref object of OpenApiRestCall_772581
proc url_PostAuthorizeClusterSecurityGroupIngress_773228(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_PostAuthorizeClusterSecurityGroupIngress_773227(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Adds an inbound (ingress) rule to an Amazon Redshift security group. Depending on whether the application accessing your cluster is running on the Internet or an Amazon EC2 instance, you can authorize inbound access to either a Classless Interdomain Routing (CIDR)/Internet Protocol (IP) range or to an Amazon EC2 security group. You can add as many as 20 ingress rules to an Amazon Redshift security group.</p> <p>If you authorize access to an Amazon EC2 security group, specify <i>EC2SecurityGroupName</i> and <i>EC2SecurityGroupOwnerId</i>. The Amazon EC2 security group and Amazon Redshift cluster must be in the same AWS Region. </p> <p>If you authorize access to a CIDR/IP address range, specify <i>CIDRIP</i>. For an overview of CIDR blocks, see the Wikipedia article on <a href="http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing">Classless Inter-Domain Routing</a>. </p> <p>You must also associate the security group with a cluster so that clients running on these IP addresses or the EC2 instance are authorized to connect to the cluster. For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Working with Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_773229 = query.getOrDefault("Action")
  valid_773229 = validateParameter(valid_773229, JString, required = true, default = newJString(
      "AuthorizeClusterSecurityGroupIngress"))
  if valid_773229 != nil:
    section.add "Action", valid_773229
  var valid_773230 = query.getOrDefault("Version")
  valid_773230 = validateParameter(valid_773230, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_773230 != nil:
    section.add "Version", valid_773230
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_773231 = header.getOrDefault("X-Amz-Date")
  valid_773231 = validateParameter(valid_773231, JString, required = false,
                                 default = nil)
  if valid_773231 != nil:
    section.add "X-Amz-Date", valid_773231
  var valid_773232 = header.getOrDefault("X-Amz-Security-Token")
  valid_773232 = validateParameter(valid_773232, JString, required = false,
                                 default = nil)
  if valid_773232 != nil:
    section.add "X-Amz-Security-Token", valid_773232
  var valid_773233 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_773233 = validateParameter(valid_773233, JString, required = false,
                                 default = nil)
  if valid_773233 != nil:
    section.add "X-Amz-Content-Sha256", valid_773233
  var valid_773234 = header.getOrDefault("X-Amz-Algorithm")
  valid_773234 = validateParameter(valid_773234, JString, required = false,
                                 default = nil)
  if valid_773234 != nil:
    section.add "X-Amz-Algorithm", valid_773234
  var valid_773235 = header.getOrDefault("X-Amz-Signature")
  valid_773235 = validateParameter(valid_773235, JString, required = false,
                                 default = nil)
  if valid_773235 != nil:
    section.add "X-Amz-Signature", valid_773235
  var valid_773236 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_773236 = validateParameter(valid_773236, JString, required = false,
                                 default = nil)
  if valid_773236 != nil:
    section.add "X-Amz-SignedHeaders", valid_773236
  var valid_773237 = header.getOrDefault("X-Amz-Credential")
  valid_773237 = validateParameter(valid_773237, JString, required = false,
                                 default = nil)
  if valid_773237 != nil:
    section.add "X-Amz-Credential", valid_773237
  result.add "header", section
  ## parameters in `formData` object:
  ##   EC2SecurityGroupName: JString
  ##                       : The EC2 security group to be added the Amazon Redshift security group.
  ##   CIDRIP: JString
  ##         : The IP range to be added the Amazon Redshift security group.
  ##   EC2SecurityGroupOwnerId: JString
  ##                          : <p>The AWS account number of the owner of the security group specified by the <i>EC2SecurityGroupName</i> parameter. The AWS Access Key ID is not an acceptable value. </p> <p>Example: <code>111122223333</code> </p>
  ##   ClusterSecurityGroupName: JString (required)
  ##                           : The name of the security group to which the ingress rule is added.
  section = newJObject()
  var valid_773238 = formData.getOrDefault("EC2SecurityGroupName")
  valid_773238 = validateParameter(valid_773238, JString, required = false,
                                 default = nil)
  if valid_773238 != nil:
    section.add "EC2SecurityGroupName", valid_773238
  var valid_773239 = formData.getOrDefault("CIDRIP")
  valid_773239 = validateParameter(valid_773239, JString, required = false,
                                 default = nil)
  if valid_773239 != nil:
    section.add "CIDRIP", valid_773239
  var valid_773240 = formData.getOrDefault("EC2SecurityGroupOwnerId")
  valid_773240 = validateParameter(valid_773240, JString, required = false,
                                 default = nil)
  if valid_773240 != nil:
    section.add "EC2SecurityGroupOwnerId", valid_773240
  assert formData != nil, "formData argument is necessary due to required `ClusterSecurityGroupName` field"
  var valid_773241 = formData.getOrDefault("ClusterSecurityGroupName")
  valid_773241 = validateParameter(valid_773241, JString, required = true,
                                 default = nil)
  if valid_773241 != nil:
    section.add "ClusterSecurityGroupName", valid_773241
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_773242: Call_PostAuthorizeClusterSecurityGroupIngress_773226;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Adds an inbound (ingress) rule to an Amazon Redshift security group. Depending on whether the application accessing your cluster is running on the Internet or an Amazon EC2 instance, you can authorize inbound access to either a Classless Interdomain Routing (CIDR)/Internet Protocol (IP) range or to an Amazon EC2 security group. You can add as many as 20 ingress rules to an Amazon Redshift security group.</p> <p>If you authorize access to an Amazon EC2 security group, specify <i>EC2SecurityGroupName</i> and <i>EC2SecurityGroupOwnerId</i>. The Amazon EC2 security group and Amazon Redshift cluster must be in the same AWS Region. </p> <p>If you authorize access to a CIDR/IP address range, specify <i>CIDRIP</i>. For an overview of CIDR blocks, see the Wikipedia article on <a href="http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing">Classless Inter-Domain Routing</a>. </p> <p>You must also associate the security group with a cluster so that clients running on these IP addresses or the EC2 instance are authorized to connect to the cluster. For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Working with Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_773242.validator(path, query, header, formData, body)
  let scheme = call_773242.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_773242.url(scheme.get, call_773242.host, call_773242.base,
                         call_773242.route, valid.getOrDefault("path"))
  result = hook(call_773242, url, valid)

proc call*(call_773243: Call_PostAuthorizeClusterSecurityGroupIngress_773226;
          ClusterSecurityGroupName: string;
          Action: string = "AuthorizeClusterSecurityGroupIngress";
          EC2SecurityGroupName: string = ""; CIDRIP: string = "";
          Version: string = "2012-12-01"; EC2SecurityGroupOwnerId: string = ""): Recallable =
  ## postAuthorizeClusterSecurityGroupIngress
  ## <p>Adds an inbound (ingress) rule to an Amazon Redshift security group. Depending on whether the application accessing your cluster is running on the Internet or an Amazon EC2 instance, you can authorize inbound access to either a Classless Interdomain Routing (CIDR)/Internet Protocol (IP) range or to an Amazon EC2 security group. You can add as many as 20 ingress rules to an Amazon Redshift security group.</p> <p>If you authorize access to an Amazon EC2 security group, specify <i>EC2SecurityGroupName</i> and <i>EC2SecurityGroupOwnerId</i>. The Amazon EC2 security group and Amazon Redshift cluster must be in the same AWS Region. </p> <p>If you authorize access to a CIDR/IP address range, specify <i>CIDRIP</i>. For an overview of CIDR blocks, see the Wikipedia article on <a href="http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing">Classless Inter-Domain Routing</a>. </p> <p>You must also associate the security group with a cluster so that clients running on these IP addresses or the EC2 instance are authorized to connect to the cluster. For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Working with Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   Action: string (required)
  ##   EC2SecurityGroupName: string
  ##                       : The EC2 security group to be added the Amazon Redshift security group.
  ##   CIDRIP: string
  ##         : The IP range to be added the Amazon Redshift security group.
  ##   Version: string (required)
  ##   EC2SecurityGroupOwnerId: string
  ##                          : <p>The AWS account number of the owner of the security group specified by the <i>EC2SecurityGroupName</i> parameter. The AWS Access Key ID is not an acceptable value. </p> <p>Example: <code>111122223333</code> </p>
  ##   ClusterSecurityGroupName: string (required)
  ##                           : The name of the security group to which the ingress rule is added.
  var query_773244 = newJObject()
  var formData_773245 = newJObject()
  add(query_773244, "Action", newJString(Action))
  add(formData_773245, "EC2SecurityGroupName", newJString(EC2SecurityGroupName))
  add(formData_773245, "CIDRIP", newJString(CIDRIP))
  add(query_773244, "Version", newJString(Version))
  add(formData_773245, "EC2SecurityGroupOwnerId",
      newJString(EC2SecurityGroupOwnerId))
  add(formData_773245, "ClusterSecurityGroupName",
      newJString(ClusterSecurityGroupName))
  result = call_773243.call(nil, query_773244, nil, formData_773245, nil)

var postAuthorizeClusterSecurityGroupIngress* = Call_PostAuthorizeClusterSecurityGroupIngress_773226(
    name: "postAuthorizeClusterSecurityGroupIngress", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=AuthorizeClusterSecurityGroupIngress",
    validator: validate_PostAuthorizeClusterSecurityGroupIngress_773227,
    base: "/", url: url_PostAuthorizeClusterSecurityGroupIngress_773228,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetAuthorizeClusterSecurityGroupIngress_773207 = ref object of OpenApiRestCall_772581
proc url_GetAuthorizeClusterSecurityGroupIngress_773209(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_GetAuthorizeClusterSecurityGroupIngress_773208(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Adds an inbound (ingress) rule to an Amazon Redshift security group. Depending on whether the application accessing your cluster is running on the Internet or an Amazon EC2 instance, you can authorize inbound access to either a Classless Interdomain Routing (CIDR)/Internet Protocol (IP) range or to an Amazon EC2 security group. You can add as many as 20 ingress rules to an Amazon Redshift security group.</p> <p>If you authorize access to an Amazon EC2 security group, specify <i>EC2SecurityGroupName</i> and <i>EC2SecurityGroupOwnerId</i>. The Amazon EC2 security group and Amazon Redshift cluster must be in the same AWS Region. </p> <p>If you authorize access to a CIDR/IP address range, specify <i>CIDRIP</i>. For an overview of CIDR blocks, see the Wikipedia article on <a href="http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing">Classless Inter-Domain Routing</a>. </p> <p>You must also associate the security group with a cluster so that clients running on these IP addresses or the EC2 instance are authorized to connect to the cluster. For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Working with Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ClusterSecurityGroupName: JString (required)
  ##                           : The name of the security group to which the ingress rule is added.
  ##   EC2SecurityGroupOwnerId: JString
  ##                          : <p>The AWS account number of the owner of the security group specified by the <i>EC2SecurityGroupName</i> parameter. The AWS Access Key ID is not an acceptable value. </p> <p>Example: <code>111122223333</code> </p>
  ##   Action: JString (required)
  ##   CIDRIP: JString
  ##         : The IP range to be added the Amazon Redshift security group.
  ##   EC2SecurityGroupName: JString
  ##                       : The EC2 security group to be added the Amazon Redshift security group.
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `ClusterSecurityGroupName` field"
  var valid_773210 = query.getOrDefault("ClusterSecurityGroupName")
  valid_773210 = validateParameter(valid_773210, JString, required = true,
                                 default = nil)
  if valid_773210 != nil:
    section.add "ClusterSecurityGroupName", valid_773210
  var valid_773211 = query.getOrDefault("EC2SecurityGroupOwnerId")
  valid_773211 = validateParameter(valid_773211, JString, required = false,
                                 default = nil)
  if valid_773211 != nil:
    section.add "EC2SecurityGroupOwnerId", valid_773211
  var valid_773212 = query.getOrDefault("Action")
  valid_773212 = validateParameter(valid_773212, JString, required = true, default = newJString(
      "AuthorizeClusterSecurityGroupIngress"))
  if valid_773212 != nil:
    section.add "Action", valid_773212
  var valid_773213 = query.getOrDefault("CIDRIP")
  valid_773213 = validateParameter(valid_773213, JString, required = false,
                                 default = nil)
  if valid_773213 != nil:
    section.add "CIDRIP", valid_773213
  var valid_773214 = query.getOrDefault("EC2SecurityGroupName")
  valid_773214 = validateParameter(valid_773214, JString, required = false,
                                 default = nil)
  if valid_773214 != nil:
    section.add "EC2SecurityGroupName", valid_773214
  var valid_773215 = query.getOrDefault("Version")
  valid_773215 = validateParameter(valid_773215, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_773215 != nil:
    section.add "Version", valid_773215
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_773216 = header.getOrDefault("X-Amz-Date")
  valid_773216 = validateParameter(valid_773216, JString, required = false,
                                 default = nil)
  if valid_773216 != nil:
    section.add "X-Amz-Date", valid_773216
  var valid_773217 = header.getOrDefault("X-Amz-Security-Token")
  valid_773217 = validateParameter(valid_773217, JString, required = false,
                                 default = nil)
  if valid_773217 != nil:
    section.add "X-Amz-Security-Token", valid_773217
  var valid_773218 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_773218 = validateParameter(valid_773218, JString, required = false,
                                 default = nil)
  if valid_773218 != nil:
    section.add "X-Amz-Content-Sha256", valid_773218
  var valid_773219 = header.getOrDefault("X-Amz-Algorithm")
  valid_773219 = validateParameter(valid_773219, JString, required = false,
                                 default = nil)
  if valid_773219 != nil:
    section.add "X-Amz-Algorithm", valid_773219
  var valid_773220 = header.getOrDefault("X-Amz-Signature")
  valid_773220 = validateParameter(valid_773220, JString, required = false,
                                 default = nil)
  if valid_773220 != nil:
    section.add "X-Amz-Signature", valid_773220
  var valid_773221 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_773221 = validateParameter(valid_773221, JString, required = false,
                                 default = nil)
  if valid_773221 != nil:
    section.add "X-Amz-SignedHeaders", valid_773221
  var valid_773222 = header.getOrDefault("X-Amz-Credential")
  valid_773222 = validateParameter(valid_773222, JString, required = false,
                                 default = nil)
  if valid_773222 != nil:
    section.add "X-Amz-Credential", valid_773222
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_773223: Call_GetAuthorizeClusterSecurityGroupIngress_773207;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Adds an inbound (ingress) rule to an Amazon Redshift security group. Depending on whether the application accessing your cluster is running on the Internet or an Amazon EC2 instance, you can authorize inbound access to either a Classless Interdomain Routing (CIDR)/Internet Protocol (IP) range or to an Amazon EC2 security group. You can add as many as 20 ingress rules to an Amazon Redshift security group.</p> <p>If you authorize access to an Amazon EC2 security group, specify <i>EC2SecurityGroupName</i> and <i>EC2SecurityGroupOwnerId</i>. The Amazon EC2 security group and Amazon Redshift cluster must be in the same AWS Region. </p> <p>If you authorize access to a CIDR/IP address range, specify <i>CIDRIP</i>. For an overview of CIDR blocks, see the Wikipedia article on <a href="http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing">Classless Inter-Domain Routing</a>. </p> <p>You must also associate the security group with a cluster so that clients running on these IP addresses or the EC2 instance are authorized to connect to the cluster. For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Working with Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_773223.validator(path, query, header, formData, body)
  let scheme = call_773223.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_773223.url(scheme.get, call_773223.host, call_773223.base,
                         call_773223.route, valid.getOrDefault("path"))
  result = hook(call_773223, url, valid)

proc call*(call_773224: Call_GetAuthorizeClusterSecurityGroupIngress_773207;
          ClusterSecurityGroupName: string; EC2SecurityGroupOwnerId: string = "";
          Action: string = "AuthorizeClusterSecurityGroupIngress";
          CIDRIP: string = ""; EC2SecurityGroupName: string = "";
          Version: string = "2012-12-01"): Recallable =
  ## getAuthorizeClusterSecurityGroupIngress
  ## <p>Adds an inbound (ingress) rule to an Amazon Redshift security group. Depending on whether the application accessing your cluster is running on the Internet or an Amazon EC2 instance, you can authorize inbound access to either a Classless Interdomain Routing (CIDR)/Internet Protocol (IP) range or to an Amazon EC2 security group. You can add as many as 20 ingress rules to an Amazon Redshift security group.</p> <p>If you authorize access to an Amazon EC2 security group, specify <i>EC2SecurityGroupName</i> and <i>EC2SecurityGroupOwnerId</i>. The Amazon EC2 security group and Amazon Redshift cluster must be in the same AWS Region. </p> <p>If you authorize access to a CIDR/IP address range, specify <i>CIDRIP</i>. For an overview of CIDR blocks, see the Wikipedia article on <a href="http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing">Classless Inter-Domain Routing</a>. </p> <p>You must also associate the security group with a cluster so that clients running on these IP addresses or the EC2 instance are authorized to connect to the cluster. For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Working with Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   ClusterSecurityGroupName: string (required)
  ##                           : The name of the security group to which the ingress rule is added.
  ##   EC2SecurityGroupOwnerId: string
  ##                          : <p>The AWS account number of the owner of the security group specified by the <i>EC2SecurityGroupName</i> parameter. The AWS Access Key ID is not an acceptable value. </p> <p>Example: <code>111122223333</code> </p>
  ##   Action: string (required)
  ##   CIDRIP: string
  ##         : The IP range to be added the Amazon Redshift security group.
  ##   EC2SecurityGroupName: string
  ##                       : The EC2 security group to be added the Amazon Redshift security group.
  ##   Version: string (required)
  var query_773225 = newJObject()
  add(query_773225, "ClusterSecurityGroupName",
      newJString(ClusterSecurityGroupName))
  add(query_773225, "EC2SecurityGroupOwnerId", newJString(EC2SecurityGroupOwnerId))
  add(query_773225, "Action", newJString(Action))
  add(query_773225, "CIDRIP", newJString(CIDRIP))
  add(query_773225, "EC2SecurityGroupName", newJString(EC2SecurityGroupName))
  add(query_773225, "Version", newJString(Version))
  result = call_773224.call(nil, query_773225, nil, nil, nil)

var getAuthorizeClusterSecurityGroupIngress* = Call_GetAuthorizeClusterSecurityGroupIngress_773207(
    name: "getAuthorizeClusterSecurityGroupIngress", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=AuthorizeClusterSecurityGroupIngress",
    validator: validate_GetAuthorizeClusterSecurityGroupIngress_773208, base: "/",
    url: url_GetAuthorizeClusterSecurityGroupIngress_773209,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostAuthorizeSnapshotAccess_773264 = ref object of OpenApiRestCall_772581
proc url_PostAuthorizeSnapshotAccess_773266(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_PostAuthorizeSnapshotAccess_773265(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Authorizes the specified AWS customer account to restore the specified snapshot.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_773267 = query.getOrDefault("Action")
  valid_773267 = validateParameter(valid_773267, JString, required = true, default = newJString(
      "AuthorizeSnapshotAccess"))
  if valid_773267 != nil:
    section.add "Action", valid_773267
  var valid_773268 = query.getOrDefault("Version")
  valid_773268 = validateParameter(valid_773268, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_773268 != nil:
    section.add "Version", valid_773268
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_773269 = header.getOrDefault("X-Amz-Date")
  valid_773269 = validateParameter(valid_773269, JString, required = false,
                                 default = nil)
  if valid_773269 != nil:
    section.add "X-Amz-Date", valid_773269
  var valid_773270 = header.getOrDefault("X-Amz-Security-Token")
  valid_773270 = validateParameter(valid_773270, JString, required = false,
                                 default = nil)
  if valid_773270 != nil:
    section.add "X-Amz-Security-Token", valid_773270
  var valid_773271 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_773271 = validateParameter(valid_773271, JString, required = false,
                                 default = nil)
  if valid_773271 != nil:
    section.add "X-Amz-Content-Sha256", valid_773271
  var valid_773272 = header.getOrDefault("X-Amz-Algorithm")
  valid_773272 = validateParameter(valid_773272, JString, required = false,
                                 default = nil)
  if valid_773272 != nil:
    section.add "X-Amz-Algorithm", valid_773272
  var valid_773273 = header.getOrDefault("X-Amz-Signature")
  valid_773273 = validateParameter(valid_773273, JString, required = false,
                                 default = nil)
  if valid_773273 != nil:
    section.add "X-Amz-Signature", valid_773273
  var valid_773274 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_773274 = validateParameter(valid_773274, JString, required = false,
                                 default = nil)
  if valid_773274 != nil:
    section.add "X-Amz-SignedHeaders", valid_773274
  var valid_773275 = header.getOrDefault("X-Amz-Credential")
  valid_773275 = validateParameter(valid_773275, JString, required = false,
                                 default = nil)
  if valid_773275 != nil:
    section.add "X-Amz-Credential", valid_773275
  result.add "header", section
  ## parameters in `formData` object:
  ##   AccountWithRestoreAccess: JString (required)
  ##                           : <p>The identifier of the AWS customer account authorized to restore the specified snapshot.</p> <p>To share a snapshot with AWS support, specify amazon-redshift-support.</p>
  ##   SnapshotClusterIdentifier: JString
  ##                            : The identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.
  ##   SnapshotIdentifier: JString (required)
  ##                     : The identifier of the snapshot the account is authorized to restore.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `AccountWithRestoreAccess` field"
  var valid_773276 = formData.getOrDefault("AccountWithRestoreAccess")
  valid_773276 = validateParameter(valid_773276, JString, required = true,
                                 default = nil)
  if valid_773276 != nil:
    section.add "AccountWithRestoreAccess", valid_773276
  var valid_773277 = formData.getOrDefault("SnapshotClusterIdentifier")
  valid_773277 = validateParameter(valid_773277, JString, required = false,
                                 default = nil)
  if valid_773277 != nil:
    section.add "SnapshotClusterIdentifier", valid_773277
  var valid_773278 = formData.getOrDefault("SnapshotIdentifier")
  valid_773278 = validateParameter(valid_773278, JString, required = true,
                                 default = nil)
  if valid_773278 != nil:
    section.add "SnapshotIdentifier", valid_773278
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_773279: Call_PostAuthorizeSnapshotAccess_773264; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Authorizes the specified AWS customer account to restore the specified snapshot.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_773279.validator(path, query, header, formData, body)
  let scheme = call_773279.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_773279.url(scheme.get, call_773279.host, call_773279.base,
                         call_773279.route, valid.getOrDefault("path"))
  result = hook(call_773279, url, valid)

proc call*(call_773280: Call_PostAuthorizeSnapshotAccess_773264;
          AccountWithRestoreAccess: string; SnapshotIdentifier: string;
          SnapshotClusterIdentifier: string = "";
          Action: string = "AuthorizeSnapshotAccess"; Version: string = "2012-12-01"): Recallable =
  ## postAuthorizeSnapshotAccess
  ## <p>Authorizes the specified AWS customer account to restore the specified snapshot.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   AccountWithRestoreAccess: string (required)
  ##                           : <p>The identifier of the AWS customer account authorized to restore the specified snapshot.</p> <p>To share a snapshot with AWS support, specify amazon-redshift-support.</p>
  ##   SnapshotClusterIdentifier: string
  ##                            : The identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.
  ##   Action: string (required)
  ##   SnapshotIdentifier: string (required)
  ##                     : The identifier of the snapshot the account is authorized to restore.
  ##   Version: string (required)
  var query_773281 = newJObject()
  var formData_773282 = newJObject()
  add(formData_773282, "AccountWithRestoreAccess",
      newJString(AccountWithRestoreAccess))
  add(formData_773282, "SnapshotClusterIdentifier",
      newJString(SnapshotClusterIdentifier))
  add(query_773281, "Action", newJString(Action))
  add(formData_773282, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_773281, "Version", newJString(Version))
  result = call_773280.call(nil, query_773281, nil, formData_773282, nil)

var postAuthorizeSnapshotAccess* = Call_PostAuthorizeSnapshotAccess_773264(
    name: "postAuthorizeSnapshotAccess", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=AuthorizeSnapshotAccess",
    validator: validate_PostAuthorizeSnapshotAccess_773265, base: "/",
    url: url_PostAuthorizeSnapshotAccess_773266,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetAuthorizeSnapshotAccess_773246 = ref object of OpenApiRestCall_772581
proc url_GetAuthorizeSnapshotAccess_773248(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_GetAuthorizeSnapshotAccess_773247(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Authorizes the specified AWS customer account to restore the specified snapshot.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   AccountWithRestoreAccess: JString (required)
  ##                           : <p>The identifier of the AWS customer account authorized to restore the specified snapshot.</p> <p>To share a snapshot with AWS support, specify amazon-redshift-support.</p>
  ##   Action: JString (required)
  ##   SnapshotClusterIdentifier: JString
  ##                            : The identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.
  ##   SnapshotIdentifier: JString (required)
  ##                     : The identifier of the snapshot the account is authorized to restore.
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `AccountWithRestoreAccess` field"
  var valid_773249 = query.getOrDefault("AccountWithRestoreAccess")
  valid_773249 = validateParameter(valid_773249, JString, required = true,
                                 default = nil)
  if valid_773249 != nil:
    section.add "AccountWithRestoreAccess", valid_773249
  var valid_773250 = query.getOrDefault("Action")
  valid_773250 = validateParameter(valid_773250, JString, required = true, default = newJString(
      "AuthorizeSnapshotAccess"))
  if valid_773250 != nil:
    section.add "Action", valid_773250
  var valid_773251 = query.getOrDefault("SnapshotClusterIdentifier")
  valid_773251 = validateParameter(valid_773251, JString, required = false,
                                 default = nil)
  if valid_773251 != nil:
    section.add "SnapshotClusterIdentifier", valid_773251
  var valid_773252 = query.getOrDefault("SnapshotIdentifier")
  valid_773252 = validateParameter(valid_773252, JString, required = true,
                                 default = nil)
  if valid_773252 != nil:
    section.add "SnapshotIdentifier", valid_773252
  var valid_773253 = query.getOrDefault("Version")
  valid_773253 = validateParameter(valid_773253, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_773253 != nil:
    section.add "Version", valid_773253
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_773254 = header.getOrDefault("X-Amz-Date")
  valid_773254 = validateParameter(valid_773254, JString, required = false,
                                 default = nil)
  if valid_773254 != nil:
    section.add "X-Amz-Date", valid_773254
  var valid_773255 = header.getOrDefault("X-Amz-Security-Token")
  valid_773255 = validateParameter(valid_773255, JString, required = false,
                                 default = nil)
  if valid_773255 != nil:
    section.add "X-Amz-Security-Token", valid_773255
  var valid_773256 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_773256 = validateParameter(valid_773256, JString, required = false,
                                 default = nil)
  if valid_773256 != nil:
    section.add "X-Amz-Content-Sha256", valid_773256
  var valid_773257 = header.getOrDefault("X-Amz-Algorithm")
  valid_773257 = validateParameter(valid_773257, JString, required = false,
                                 default = nil)
  if valid_773257 != nil:
    section.add "X-Amz-Algorithm", valid_773257
  var valid_773258 = header.getOrDefault("X-Amz-Signature")
  valid_773258 = validateParameter(valid_773258, JString, required = false,
                                 default = nil)
  if valid_773258 != nil:
    section.add "X-Amz-Signature", valid_773258
  var valid_773259 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_773259 = validateParameter(valid_773259, JString, required = false,
                                 default = nil)
  if valid_773259 != nil:
    section.add "X-Amz-SignedHeaders", valid_773259
  var valid_773260 = header.getOrDefault("X-Amz-Credential")
  valid_773260 = validateParameter(valid_773260, JString, required = false,
                                 default = nil)
  if valid_773260 != nil:
    section.add "X-Amz-Credential", valid_773260
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_773261: Call_GetAuthorizeSnapshotAccess_773246; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Authorizes the specified AWS customer account to restore the specified snapshot.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_773261.validator(path, query, header, formData, body)
  let scheme = call_773261.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_773261.url(scheme.get, call_773261.host, call_773261.base,
                         call_773261.route, valid.getOrDefault("path"))
  result = hook(call_773261, url, valid)

proc call*(call_773262: Call_GetAuthorizeSnapshotAccess_773246;
          AccountWithRestoreAccess: string; SnapshotIdentifier: string;
          Action: string = "AuthorizeSnapshotAccess";
          SnapshotClusterIdentifier: string = ""; Version: string = "2012-12-01"): Recallable =
  ## getAuthorizeSnapshotAccess
  ## <p>Authorizes the specified AWS customer account to restore the specified snapshot.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   AccountWithRestoreAccess: string (required)
  ##                           : <p>The identifier of the AWS customer account authorized to restore the specified snapshot.</p> <p>To share a snapshot with AWS support, specify amazon-redshift-support.</p>
  ##   Action: string (required)
  ##   SnapshotClusterIdentifier: string
  ##                            : The identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.
  ##   SnapshotIdentifier: string (required)
  ##                     : The identifier of the snapshot the account is authorized to restore.
  ##   Version: string (required)
  var query_773263 = newJObject()
  add(query_773263, "AccountWithRestoreAccess",
      newJString(AccountWithRestoreAccess))
  add(query_773263, "Action", newJString(Action))
  add(query_773263, "SnapshotClusterIdentifier",
      newJString(SnapshotClusterIdentifier))
  add(query_773263, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_773263, "Version", newJString(Version))
  result = call_773262.call(nil, query_773263, nil, nil, nil)

var getAuthorizeSnapshotAccess* = Call_GetAuthorizeSnapshotAccess_773246(
    name: "getAuthorizeSnapshotAccess", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=AuthorizeSnapshotAccess",
    validator: validate_GetAuthorizeSnapshotAccess_773247, base: "/",
    url: url_GetAuthorizeSnapshotAccess_773248,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostBatchDeleteClusterSnapshots_773299 = ref object of OpenApiRestCall_772581
proc url_PostBatchDeleteClusterSnapshots_773301(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_PostBatchDeleteClusterSnapshots_773300(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a set of cluster snapshots.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_773302 = query.getOrDefault("Action")
  valid_773302 = validateParameter(valid_773302, JString, required = true, default = newJString(
      "BatchDeleteClusterSnapshots"))
  if valid_773302 != nil:
    section.add "Action", valid_773302
  var valid_773303 = query.getOrDefault("Version")
  valid_773303 = validateParameter(valid_773303, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_773303 != nil:
    section.add "Version", valid_773303
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_773304 = header.getOrDefault("X-Amz-Date")
  valid_773304 = validateParameter(valid_773304, JString, required = false,
                                 default = nil)
  if valid_773304 != nil:
    section.add "X-Amz-Date", valid_773304
  var valid_773305 = header.getOrDefault("X-Amz-Security-Token")
  valid_773305 = validateParameter(valid_773305, JString, required = false,
                                 default = nil)
  if valid_773305 != nil:
    section.add "X-Amz-Security-Token", valid_773305
  var valid_773306 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_773306 = validateParameter(valid_773306, JString, required = false,
                                 default = nil)
  if valid_773306 != nil:
    section.add "X-Amz-Content-Sha256", valid_773306
  var valid_773307 = header.getOrDefault("X-Amz-Algorithm")
  valid_773307 = validateParameter(valid_773307, JString, required = false,
                                 default = nil)
  if valid_773307 != nil:
    section.add "X-Amz-Algorithm", valid_773307
  var valid_773308 = header.getOrDefault("X-Amz-Signature")
  valid_773308 = validateParameter(valid_773308, JString, required = false,
                                 default = nil)
  if valid_773308 != nil:
    section.add "X-Amz-Signature", valid_773308
  var valid_773309 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_773309 = validateParameter(valid_773309, JString, required = false,
                                 default = nil)
  if valid_773309 != nil:
    section.add "X-Amz-SignedHeaders", valid_773309
  var valid_773310 = header.getOrDefault("X-Amz-Credential")
  valid_773310 = validateParameter(valid_773310, JString, required = false,
                                 default = nil)
  if valid_773310 != nil:
    section.add "X-Amz-Credential", valid_773310
  result.add "header", section
  ## parameters in `formData` object:
  ##   Identifiers: JArray (required)
  ##              : A list of identifiers for the snapshots that you want to delete.
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `Identifiers` field"
  var valid_773311 = formData.getOrDefault("Identifiers")
  valid_773311 = validateParameter(valid_773311, JArray, required = true, default = nil)
  if valid_773311 != nil:
    section.add "Identifiers", valid_773311
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_773312: Call_PostBatchDeleteClusterSnapshots_773299;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Deletes a set of cluster snapshots.
  ## 
  let valid = call_773312.validator(path, query, header, formData, body)
  let scheme = call_773312.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_773312.url(scheme.get, call_773312.host, call_773312.base,
                         call_773312.route, valid.getOrDefault("path"))
  result = hook(call_773312, url, valid)

proc call*(call_773313: Call_PostBatchDeleteClusterSnapshots_773299;
          Identifiers: JsonNode; Action: string = "BatchDeleteClusterSnapshots";
          Version: string = "2012-12-01"): Recallable =
  ## postBatchDeleteClusterSnapshots
  ## Deletes a set of cluster snapshots.
  ##   Identifiers: JArray (required)
  ##              : A list of identifiers for the snapshots that you want to delete.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_773314 = newJObject()
  var formData_773315 = newJObject()
  if Identifiers != nil:
    formData_773315.add "Identifiers", Identifiers
  add(query_773314, "Action", newJString(Action))
  add(query_773314, "Version", newJString(Version))
  result = call_773313.call(nil, query_773314, nil, formData_773315, nil)

var postBatchDeleteClusterSnapshots* = Call_PostBatchDeleteClusterSnapshots_773299(
    name: "postBatchDeleteClusterSnapshots", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=BatchDeleteClusterSnapshots",
    validator: validate_PostBatchDeleteClusterSnapshots_773300, base: "/",
    url: url_PostBatchDeleteClusterSnapshots_773301,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetBatchDeleteClusterSnapshots_773283 = ref object of OpenApiRestCall_772581
proc url_GetBatchDeleteClusterSnapshots_773285(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_GetBatchDeleteClusterSnapshots_773284(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a set of cluster snapshots.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Identifiers: JArray (required)
  ##              : A list of identifiers for the snapshots that you want to delete.
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_773286 = query.getOrDefault("Action")
  valid_773286 = validateParameter(valid_773286, JString, required = true, default = newJString(
      "BatchDeleteClusterSnapshots"))
  if valid_773286 != nil:
    section.add "Action", valid_773286
  var valid_773287 = query.getOrDefault("Identifiers")
  valid_773287 = validateParameter(valid_773287, JArray, required = true, default = nil)
  if valid_773287 != nil:
    section.add "Identifiers", valid_773287
  var valid_773288 = query.getOrDefault("Version")
  valid_773288 = validateParameter(valid_773288, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_773288 != nil:
    section.add "Version", valid_773288
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_773289 = header.getOrDefault("X-Amz-Date")
  valid_773289 = validateParameter(valid_773289, JString, required = false,
                                 default = nil)
  if valid_773289 != nil:
    section.add "X-Amz-Date", valid_773289
  var valid_773290 = header.getOrDefault("X-Amz-Security-Token")
  valid_773290 = validateParameter(valid_773290, JString, required = false,
                                 default = nil)
  if valid_773290 != nil:
    section.add "X-Amz-Security-Token", valid_773290
  var valid_773291 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_773291 = validateParameter(valid_773291, JString, required = false,
                                 default = nil)
  if valid_773291 != nil:
    section.add "X-Amz-Content-Sha256", valid_773291
  var valid_773292 = header.getOrDefault("X-Amz-Algorithm")
  valid_773292 = validateParameter(valid_773292, JString, required = false,
                                 default = nil)
  if valid_773292 != nil:
    section.add "X-Amz-Algorithm", valid_773292
  var valid_773293 = header.getOrDefault("X-Amz-Signature")
  valid_773293 = validateParameter(valid_773293, JString, required = false,
                                 default = nil)
  if valid_773293 != nil:
    section.add "X-Amz-Signature", valid_773293
  var valid_773294 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_773294 = validateParameter(valid_773294, JString, required = false,
                                 default = nil)
  if valid_773294 != nil:
    section.add "X-Amz-SignedHeaders", valid_773294
  var valid_773295 = header.getOrDefault("X-Amz-Credential")
  valid_773295 = validateParameter(valid_773295, JString, required = false,
                                 default = nil)
  if valid_773295 != nil:
    section.add "X-Amz-Credential", valid_773295
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_773296: Call_GetBatchDeleteClusterSnapshots_773283; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a set of cluster snapshots.
  ## 
  let valid = call_773296.validator(path, query, header, formData, body)
  let scheme = call_773296.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_773296.url(scheme.get, call_773296.host, call_773296.base,
                         call_773296.route, valid.getOrDefault("path"))
  result = hook(call_773296, url, valid)

proc call*(call_773297: Call_GetBatchDeleteClusterSnapshots_773283;
          Identifiers: JsonNode; Action: string = "BatchDeleteClusterSnapshots";
          Version: string = "2012-12-01"): Recallable =
  ## getBatchDeleteClusterSnapshots
  ## Deletes a set of cluster snapshots.
  ##   Action: string (required)
  ##   Identifiers: JArray (required)
  ##              : A list of identifiers for the snapshots that you want to delete.
  ##   Version: string (required)
  var query_773298 = newJObject()
  add(query_773298, "Action", newJString(Action))
  if Identifiers != nil:
    query_773298.add "Identifiers", Identifiers
  add(query_773298, "Version", newJString(Version))
  result = call_773297.call(nil, query_773298, nil, nil, nil)

var getBatchDeleteClusterSnapshots* = Call_GetBatchDeleteClusterSnapshots_773283(
    name: "getBatchDeleteClusterSnapshots", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=BatchDeleteClusterSnapshots",
    validator: validate_GetBatchDeleteClusterSnapshots_773284, base: "/",
    url: url_GetBatchDeleteClusterSnapshots_773285,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostBatchModifyClusterSnapshots_773334 = ref object of OpenApiRestCall_772581
proc url_PostBatchModifyClusterSnapshots_773336(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_PostBatchModifyClusterSnapshots_773335(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies the settings for a list of snapshots.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_773337 = query.getOrDefault("Action")
  valid_773337 = validateParameter(valid_773337, JString, required = true, default = newJString(
      "BatchModifyClusterSnapshots"))
  if valid_773337 != nil:
    section.add "Action", valid_773337
  var valid_773338 = query.getOrDefault("Version")
  valid_773338 = validateParameter(valid_773338, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_773338 != nil:
    section.add "Version", valid_773338
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_773339 = header.getOrDefault("X-Amz-Date")
  valid_773339 = validateParameter(valid_773339, JString, required = false,
                                 default = nil)
  if valid_773339 != nil:
    section.add "X-Amz-Date", valid_773339
  var valid_773340 = header.getOrDefault("X-Amz-Security-Token")
  valid_773340 = validateParameter(valid_773340, JString, required = false,
                                 default = nil)
  if valid_773340 != nil:
    section.add "X-Amz-Security-Token", valid_773340
  var valid_773341 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_773341 = validateParameter(valid_773341, JString, required = false,
                                 default = nil)
  if valid_773341 != nil:
    section.add "X-Amz-Content-Sha256", valid_773341
  var valid_773342 = header.getOrDefault("X-Amz-Algorithm")
  valid_773342 = validateParameter(valid_773342, JString, required = false,
                                 default = nil)
  if valid_773342 != nil:
    section.add "X-Amz-Algorithm", valid_773342
  var valid_773343 = header.getOrDefault("X-Amz-Signature")
  valid_773343 = validateParameter(valid_773343, JString, required = false,
                                 default = nil)
  if valid_773343 != nil:
    section.add "X-Amz-Signature", valid_773343
  var valid_773344 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_773344 = validateParameter(valid_773344, JString, required = false,
                                 default = nil)
  if valid_773344 != nil:
    section.add "X-Amz-SignedHeaders", valid_773344
  var valid_773345 = header.getOrDefault("X-Amz-Credential")
  valid_773345 = validateParameter(valid_773345, JString, required = false,
                                 default = nil)
  if valid_773345 != nil:
    section.add "X-Amz-Credential", valid_773345
  result.add "header", section
  ## parameters in `formData` object:
  ##   Force: JBool
  ##        : A boolean value indicating whether to override an exception if the retention period has passed. 
  ##   SnapshotIdentifierList: JArray (required)
  ##                         : A list of snapshot identifiers you want to modify.
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The number of days that a manual snapshot is retained. If you specify the value -1, the manual snapshot is retained indefinitely.</p> <p>The number must be either -1 or an integer between 1 and 3,653.</p> <p>If you decrease the manual snapshot retention period from its current value, existing manual snapshots that fall outside of the new retention period will return an error. If you want to suppress the errors and delete the snapshots, use the force option. </p>
  section = newJObject()
  var valid_773346 = formData.getOrDefault("Force")
  valid_773346 = validateParameter(valid_773346, JBool, required = false, default = nil)
  if valid_773346 != nil:
    section.add "Force", valid_773346
  assert formData != nil, "formData argument is necessary due to required `SnapshotIdentifierList` field"
  var valid_773347 = formData.getOrDefault("SnapshotIdentifierList")
  valid_773347 = validateParameter(valid_773347, JArray, required = true, default = nil)
  if valid_773347 != nil:
    section.add "SnapshotIdentifierList", valid_773347
  var valid_773348 = formData.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_773348 = validateParameter(valid_773348, JInt, required = false, default = nil)
  if valid_773348 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_773348
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_773349: Call_PostBatchModifyClusterSnapshots_773334;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Modifies the settings for a list of snapshots.
  ## 
  let valid = call_773349.validator(path, query, header, formData, body)
  let scheme = call_773349.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_773349.url(scheme.get, call_773349.host, call_773349.base,
                         call_773349.route, valid.getOrDefault("path"))
  result = hook(call_773349, url, valid)

proc call*(call_773350: Call_PostBatchModifyClusterSnapshots_773334;
          SnapshotIdentifierList: JsonNode; Force: bool = false;
          Action: string = "BatchModifyClusterSnapshots";
          ManualSnapshotRetentionPeriod: int = 0; Version: string = "2012-12-01"): Recallable =
  ## postBatchModifyClusterSnapshots
  ## Modifies the settings for a list of snapshots.
  ##   Force: bool
  ##        : A boolean value indicating whether to override an exception if the retention period has passed. 
  ##   SnapshotIdentifierList: JArray (required)
  ##                         : A list of snapshot identifiers you want to modify.
  ##   Action: string (required)
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The number of days that a manual snapshot is retained. If you specify the value -1, the manual snapshot is retained indefinitely.</p> <p>The number must be either -1 or an integer between 1 and 3,653.</p> <p>If you decrease the manual snapshot retention period from its current value, existing manual snapshots that fall outside of the new retention period will return an error. If you want to suppress the errors and delete the snapshots, use the force option. </p>
  ##   Version: string (required)
  var query_773351 = newJObject()
  var formData_773352 = newJObject()
  add(formData_773352, "Force", newJBool(Force))
  if SnapshotIdentifierList != nil:
    formData_773352.add "SnapshotIdentifierList", SnapshotIdentifierList
  add(query_773351, "Action", newJString(Action))
  add(formData_773352, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  add(query_773351, "Version", newJString(Version))
  result = call_773350.call(nil, query_773351, nil, formData_773352, nil)

var postBatchModifyClusterSnapshots* = Call_PostBatchModifyClusterSnapshots_773334(
    name: "postBatchModifyClusterSnapshots", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=BatchModifyClusterSnapshots",
    validator: validate_PostBatchModifyClusterSnapshots_773335, base: "/",
    url: url_PostBatchModifyClusterSnapshots_773336,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetBatchModifyClusterSnapshots_773316 = ref object of OpenApiRestCall_772581
proc url_GetBatchModifyClusterSnapshots_773318(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_GetBatchModifyClusterSnapshots_773317(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies the settings for a list of snapshots.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   SnapshotIdentifierList: JArray (required)
  ##                         : A list of snapshot identifiers you want to modify.
  ##   Action: JString (required)
  ##   Version: JString (required)
  ##   Force: JBool
  ##        : A boolean value indicating whether to override an exception if the retention period has passed. 
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The number of days that a manual snapshot is retained. If you specify the value -1, the manual snapshot is retained indefinitely.</p> <p>The number must be either -1 or an integer between 1 and 3,653.</p> <p>If you decrease the manual snapshot retention period from its current value, existing manual snapshots that fall outside of the new retention period will return an error. If you want to suppress the errors and delete the snapshots, use the force option. </p>
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `SnapshotIdentifierList` field"
  var valid_773319 = query.getOrDefault("SnapshotIdentifierList")
  valid_773319 = validateParameter(valid_773319, JArray, required = true, default = nil)
  if valid_773319 != nil:
    section.add "SnapshotIdentifierList", valid_773319
  var valid_773320 = query.getOrDefault("Action")
  valid_773320 = validateParameter(valid_773320, JString, required = true, default = newJString(
      "BatchModifyClusterSnapshots"))
  if valid_773320 != nil:
    section.add "Action", valid_773320
  var valid_773321 = query.getOrDefault("Version")
  valid_773321 = validateParameter(valid_773321, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_773321 != nil:
    section.add "Version", valid_773321
  var valid_773322 = query.getOrDefault("Force")
  valid_773322 = validateParameter(valid_773322, JBool, required = false, default = nil)
  if valid_773322 != nil:
    section.add "Force", valid_773322
  var valid_773323 = query.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_773323 = validateParameter(valid_773323, JInt, required = false, default = nil)
  if valid_773323 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_773323
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_773324 = header.getOrDefault("X-Amz-Date")
  valid_773324 = validateParameter(valid_773324, JString, required = false,
                                 default = nil)
  if valid_773324 != nil:
    section.add "X-Amz-Date", valid_773324
  var valid_773325 = header.getOrDefault("X-Amz-Security-Token")
  valid_773325 = validateParameter(valid_773325, JString, required = false,
                                 default = nil)
  if valid_773325 != nil:
    section.add "X-Amz-Security-Token", valid_773325
  var valid_773326 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_773326 = validateParameter(valid_773326, JString, required = false,
                                 default = nil)
  if valid_773326 != nil:
    section.add "X-Amz-Content-Sha256", valid_773326
  var valid_773327 = header.getOrDefault("X-Amz-Algorithm")
  valid_773327 = validateParameter(valid_773327, JString, required = false,
                                 default = nil)
  if valid_773327 != nil:
    section.add "X-Amz-Algorithm", valid_773327
  var valid_773328 = header.getOrDefault("X-Amz-Signature")
  valid_773328 = validateParameter(valid_773328, JString, required = false,
                                 default = nil)
  if valid_773328 != nil:
    section.add "X-Amz-Signature", valid_773328
  var valid_773329 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_773329 = validateParameter(valid_773329, JString, required = false,
                                 default = nil)
  if valid_773329 != nil:
    section.add "X-Amz-SignedHeaders", valid_773329
  var valid_773330 = header.getOrDefault("X-Amz-Credential")
  valid_773330 = validateParameter(valid_773330, JString, required = false,
                                 default = nil)
  if valid_773330 != nil:
    section.add "X-Amz-Credential", valid_773330
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_773331: Call_GetBatchModifyClusterSnapshots_773316; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Modifies the settings for a list of snapshots.
  ## 
  let valid = call_773331.validator(path, query, header, formData, body)
  let scheme = call_773331.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_773331.url(scheme.get, call_773331.host, call_773331.base,
                         call_773331.route, valid.getOrDefault("path"))
  result = hook(call_773331, url, valid)

proc call*(call_773332: Call_GetBatchModifyClusterSnapshots_773316;
          SnapshotIdentifierList: JsonNode;
          Action: string = "BatchModifyClusterSnapshots";
          Version: string = "2012-12-01"; Force: bool = false;
          ManualSnapshotRetentionPeriod: int = 0): Recallable =
  ## getBatchModifyClusterSnapshots
  ## Modifies the settings for a list of snapshots.
  ##   SnapshotIdentifierList: JArray (required)
  ##                         : A list of snapshot identifiers you want to modify.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   Force: bool
  ##        : A boolean value indicating whether to override an exception if the retention period has passed. 
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The number of days that a manual snapshot is retained. If you specify the value -1, the manual snapshot is retained indefinitely.</p> <p>The number must be either -1 or an integer between 1 and 3,653.</p> <p>If you decrease the manual snapshot retention period from its current value, existing manual snapshots that fall outside of the new retention period will return an error. If you want to suppress the errors and delete the snapshots, use the force option. </p>
  var query_773333 = newJObject()
  if SnapshotIdentifierList != nil:
    query_773333.add "SnapshotIdentifierList", SnapshotIdentifierList
  add(query_773333, "Action", newJString(Action))
  add(query_773333, "Version", newJString(Version))
  add(query_773333, "Force", newJBool(Force))
  add(query_773333, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  result = call_773332.call(nil, query_773333, nil, nil, nil)

var getBatchModifyClusterSnapshots* = Call_GetBatchModifyClusterSnapshots_773316(
    name: "getBatchModifyClusterSnapshots", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=BatchModifyClusterSnapshots",
    validator: validate_GetBatchModifyClusterSnapshots_773317, base: "/",
    url: url_GetBatchModifyClusterSnapshots_773318,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCancelResize_773369 = ref object of OpenApiRestCall_772581
proc url_PostCancelResize_773371(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_PostCancelResize_773370(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Cancels a resize operation.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_773372 = query.getOrDefault("Action")
  valid_773372 = validateParameter(valid_773372, JString, required = true,
                                 default = newJString("CancelResize"))
  if valid_773372 != nil:
    section.add "Action", valid_773372
  var valid_773373 = query.getOrDefault("Version")
  valid_773373 = validateParameter(valid_773373, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_773373 != nil:
    section.add "Version", valid_773373
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_773374 = header.getOrDefault("X-Amz-Date")
  valid_773374 = validateParameter(valid_773374, JString, required = false,
                                 default = nil)
  if valid_773374 != nil:
    section.add "X-Amz-Date", valid_773374
  var valid_773375 = header.getOrDefault("X-Amz-Security-Token")
  valid_773375 = validateParameter(valid_773375, JString, required = false,
                                 default = nil)
  if valid_773375 != nil:
    section.add "X-Amz-Security-Token", valid_773375
  var valid_773376 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_773376 = validateParameter(valid_773376, JString, required = false,
                                 default = nil)
  if valid_773376 != nil:
    section.add "X-Amz-Content-Sha256", valid_773376
  var valid_773377 = header.getOrDefault("X-Amz-Algorithm")
  valid_773377 = validateParameter(valid_773377, JString, required = false,
                                 default = nil)
  if valid_773377 != nil:
    section.add "X-Amz-Algorithm", valid_773377
  var valid_773378 = header.getOrDefault("X-Amz-Signature")
  valid_773378 = validateParameter(valid_773378, JString, required = false,
                                 default = nil)
  if valid_773378 != nil:
    section.add "X-Amz-Signature", valid_773378
  var valid_773379 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_773379 = validateParameter(valid_773379, JString, required = false,
                                 default = nil)
  if valid_773379 != nil:
    section.add "X-Amz-SignedHeaders", valid_773379
  var valid_773380 = header.getOrDefault("X-Amz-Credential")
  valid_773380 = validateParameter(valid_773380, JString, required = false,
                                 default = nil)
  if valid_773380 != nil:
    section.add "X-Amz-Credential", valid_773380
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : The unique identifier for the cluster that you want to cancel a resize operation for.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_773381 = formData.getOrDefault("ClusterIdentifier")
  valid_773381 = validateParameter(valid_773381, JString, required = true,
                                 default = nil)
  if valid_773381 != nil:
    section.add "ClusterIdentifier", valid_773381
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_773382: Call_PostCancelResize_773369; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Cancels a resize operation.
  ## 
  let valid = call_773382.validator(path, query, header, formData, body)
  let scheme = call_773382.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_773382.url(scheme.get, call_773382.host, call_773382.base,
                         call_773382.route, valid.getOrDefault("path"))
  result = hook(call_773382, url, valid)

proc call*(call_773383: Call_PostCancelResize_773369; ClusterIdentifier: string;
          Action: string = "CancelResize"; Version: string = "2012-12-01"): Recallable =
  ## postCancelResize
  ## Cancels a resize operation.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : The unique identifier for the cluster that you want to cancel a resize operation for.
  ##   Version: string (required)
  var query_773384 = newJObject()
  var formData_773385 = newJObject()
  add(query_773384, "Action", newJString(Action))
  add(formData_773385, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_773384, "Version", newJString(Version))
  result = call_773383.call(nil, query_773384, nil, formData_773385, nil)

var postCancelResize* = Call_PostCancelResize_773369(name: "postCancelResize",
    meth: HttpMethod.HttpPost, host: "redshift.amazonaws.com",
    route: "/#Action=CancelResize", validator: validate_PostCancelResize_773370,
    base: "/", url: url_PostCancelResize_773371,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCancelResize_773353 = ref object of OpenApiRestCall_772581
proc url_GetCancelResize_773355(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_GetCancelResize_773354(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Cancels a resize operation.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : The unique identifier for the cluster that you want to cancel a resize operation for.
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_773356 = query.getOrDefault("Action")
  valid_773356 = validateParameter(valid_773356, JString, required = true,
                                 default = newJString("CancelResize"))
  if valid_773356 != nil:
    section.add "Action", valid_773356
  var valid_773357 = query.getOrDefault("ClusterIdentifier")
  valid_773357 = validateParameter(valid_773357, JString, required = true,
                                 default = nil)
  if valid_773357 != nil:
    section.add "ClusterIdentifier", valid_773357
  var valid_773358 = query.getOrDefault("Version")
  valid_773358 = validateParameter(valid_773358, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_773358 != nil:
    section.add "Version", valid_773358
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_773359 = header.getOrDefault("X-Amz-Date")
  valid_773359 = validateParameter(valid_773359, JString, required = false,
                                 default = nil)
  if valid_773359 != nil:
    section.add "X-Amz-Date", valid_773359
  var valid_773360 = header.getOrDefault("X-Amz-Security-Token")
  valid_773360 = validateParameter(valid_773360, JString, required = false,
                                 default = nil)
  if valid_773360 != nil:
    section.add "X-Amz-Security-Token", valid_773360
  var valid_773361 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_773361 = validateParameter(valid_773361, JString, required = false,
                                 default = nil)
  if valid_773361 != nil:
    section.add "X-Amz-Content-Sha256", valid_773361
  var valid_773362 = header.getOrDefault("X-Amz-Algorithm")
  valid_773362 = validateParameter(valid_773362, JString, required = false,
                                 default = nil)
  if valid_773362 != nil:
    section.add "X-Amz-Algorithm", valid_773362
  var valid_773363 = header.getOrDefault("X-Amz-Signature")
  valid_773363 = validateParameter(valid_773363, JString, required = false,
                                 default = nil)
  if valid_773363 != nil:
    section.add "X-Amz-Signature", valid_773363
  var valid_773364 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_773364 = validateParameter(valid_773364, JString, required = false,
                                 default = nil)
  if valid_773364 != nil:
    section.add "X-Amz-SignedHeaders", valid_773364
  var valid_773365 = header.getOrDefault("X-Amz-Credential")
  valid_773365 = validateParameter(valid_773365, JString, required = false,
                                 default = nil)
  if valid_773365 != nil:
    section.add "X-Amz-Credential", valid_773365
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_773366: Call_GetCancelResize_773353; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Cancels a resize operation.
  ## 
  let valid = call_773366.validator(path, query, header, formData, body)
  let scheme = call_773366.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_773366.url(scheme.get, call_773366.host, call_773366.base,
                         call_773366.route, valid.getOrDefault("path"))
  result = hook(call_773366, url, valid)

proc call*(call_773367: Call_GetCancelResize_773353; ClusterIdentifier: string;
          Action: string = "CancelResize"; Version: string = "2012-12-01"): Recallable =
  ## getCancelResize
  ## Cancels a resize operation.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : The unique identifier for the cluster that you want to cancel a resize operation for.
  ##   Version: string (required)
  var query_773368 = newJObject()
  add(query_773368, "Action", newJString(Action))
  add(query_773368, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_773368, "Version", newJString(Version))
  result = call_773367.call(nil, query_773368, nil, nil, nil)

var getCancelResize* = Call_GetCancelResize_773353(name: "getCancelResize",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=CancelResize", validator: validate_GetCancelResize_773354,
    base: "/", url: url_GetCancelResize_773355, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCopyClusterSnapshot_773405 = ref object of OpenApiRestCall_772581
proc url_PostCopyClusterSnapshot_773407(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_PostCopyClusterSnapshot_773406(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Copies the specified automated cluster snapshot to a new manual cluster snapshot. The source must be an automated snapshot and it must be in the available state.</p> <p>When you delete a cluster, Amazon Redshift deletes any automated snapshots of the cluster. Also, when the retention period of the snapshot expires, Amazon Redshift automatically deletes it. If you want to keep an automated snapshot for a longer period, you can make a manual copy of the snapshot. Manual snapshots are retained until you delete them.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_773408 = query.getOrDefault("Action")
  valid_773408 = validateParameter(valid_773408, JString, required = true,
                                 default = newJString("CopyClusterSnapshot"))
  if valid_773408 != nil:
    section.add "Action", valid_773408
  var valid_773409 = query.getOrDefault("Version")
  valid_773409 = validateParameter(valid_773409, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_773409 != nil:
    section.add "Version", valid_773409
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_773410 = header.getOrDefault("X-Amz-Date")
  valid_773410 = validateParameter(valid_773410, JString, required = false,
                                 default = nil)
  if valid_773410 != nil:
    section.add "X-Amz-Date", valid_773410
  var valid_773411 = header.getOrDefault("X-Amz-Security-Token")
  valid_773411 = validateParameter(valid_773411, JString, required = false,
                                 default = nil)
  if valid_773411 != nil:
    section.add "X-Amz-Security-Token", valid_773411
  var valid_773412 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_773412 = validateParameter(valid_773412, JString, required = false,
                                 default = nil)
  if valid_773412 != nil:
    section.add "X-Amz-Content-Sha256", valid_773412
  var valid_773413 = header.getOrDefault("X-Amz-Algorithm")
  valid_773413 = validateParameter(valid_773413, JString, required = false,
                                 default = nil)
  if valid_773413 != nil:
    section.add "X-Amz-Algorithm", valid_773413
  var valid_773414 = header.getOrDefault("X-Amz-Signature")
  valid_773414 = validateParameter(valid_773414, JString, required = false,
                                 default = nil)
  if valid_773414 != nil:
    section.add "X-Amz-Signature", valid_773414
  var valid_773415 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_773415 = validateParameter(valid_773415, JString, required = false,
                                 default = nil)
  if valid_773415 != nil:
    section.add "X-Amz-SignedHeaders", valid_773415
  var valid_773416 = header.getOrDefault("X-Amz-Credential")
  valid_773416 = validateParameter(valid_773416, JString, required = false,
                                 default = nil)
  if valid_773416 != nil:
    section.add "X-Amz-Credential", valid_773416
  result.add "header", section
  ## parameters in `formData` object:
  ##   SourceSnapshotIdentifier: JString (required)
  ##                           : <p>The identifier for the source snapshot.</p> <p>Constraints:</p> <ul> <li> <p>Must be the identifier for a valid automated snapshot whose state is <code>available</code>.</p> </li> </ul>
  ##   TargetSnapshotIdentifier: JString (required)
  ##                           : <p>The identifier given to the new manual snapshot.</p> <p>Constraints:</p> <ul> <li> <p>Cannot be null, empty, or blank.</p> </li> <li> <p>Must contain from 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for the AWS account that is making the request.</p> </li> </ul>
  ##   SourceSnapshotClusterIdentifier: JString
  ##                                  : <p>The identifier of the cluster the source snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.</p> <p>Constraints:</p> <ul> <li> <p>Must be the identifier for a valid cluster.</p> </li> </ul>
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. </p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `SourceSnapshotIdentifier` field"
  var valid_773417 = formData.getOrDefault("SourceSnapshotIdentifier")
  valid_773417 = validateParameter(valid_773417, JString, required = true,
                                 default = nil)
  if valid_773417 != nil:
    section.add "SourceSnapshotIdentifier", valid_773417
  var valid_773418 = formData.getOrDefault("TargetSnapshotIdentifier")
  valid_773418 = validateParameter(valid_773418, JString, required = true,
                                 default = nil)
  if valid_773418 != nil:
    section.add "TargetSnapshotIdentifier", valid_773418
  var valid_773419 = formData.getOrDefault("SourceSnapshotClusterIdentifier")
  valid_773419 = validateParameter(valid_773419, JString, required = false,
                                 default = nil)
  if valid_773419 != nil:
    section.add "SourceSnapshotClusterIdentifier", valid_773419
  var valid_773420 = formData.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_773420 = validateParameter(valid_773420, JInt, required = false, default = nil)
  if valid_773420 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_773420
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_773421: Call_PostCopyClusterSnapshot_773405; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Copies the specified automated cluster snapshot to a new manual cluster snapshot. The source must be an automated snapshot and it must be in the available state.</p> <p>When you delete a cluster, Amazon Redshift deletes any automated snapshots of the cluster. Also, when the retention period of the snapshot expires, Amazon Redshift automatically deletes it. If you want to keep an automated snapshot for a longer period, you can make a manual copy of the snapshot. Manual snapshots are retained until you delete them.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_773421.validator(path, query, header, formData, body)
  let scheme = call_773421.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_773421.url(scheme.get, call_773421.host, call_773421.base,
                         call_773421.route, valid.getOrDefault("path"))
  result = hook(call_773421, url, valid)

proc call*(call_773422: Call_PostCopyClusterSnapshot_773405;
          SourceSnapshotIdentifier: string; TargetSnapshotIdentifier: string;
          Action: string = "CopyClusterSnapshot";
          SourceSnapshotClusterIdentifier: string = "";
          ManualSnapshotRetentionPeriod: int = 0; Version: string = "2012-12-01"): Recallable =
  ## postCopyClusterSnapshot
  ## <p>Copies the specified automated cluster snapshot to a new manual cluster snapshot. The source must be an automated snapshot and it must be in the available state.</p> <p>When you delete a cluster, Amazon Redshift deletes any automated snapshots of the cluster. Also, when the retention period of the snapshot expires, Amazon Redshift automatically deletes it. If you want to keep an automated snapshot for a longer period, you can make a manual copy of the snapshot. Manual snapshots are retained until you delete them.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   SourceSnapshotIdentifier: string (required)
  ##                           : <p>The identifier for the source snapshot.</p> <p>Constraints:</p> <ul> <li> <p>Must be the identifier for a valid automated snapshot whose state is <code>available</code>.</p> </li> </ul>
  ##   TargetSnapshotIdentifier: string (required)
  ##                           : <p>The identifier given to the new manual snapshot.</p> <p>Constraints:</p> <ul> <li> <p>Cannot be null, empty, or blank.</p> </li> <li> <p>Must contain from 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for the AWS account that is making the request.</p> </li> </ul>
  ##   Action: string (required)
  ##   SourceSnapshotClusterIdentifier: string
  ##                                  : <p>The identifier of the cluster the source snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.</p> <p>Constraints:</p> <ul> <li> <p>Must be the identifier for a valid cluster.</p> </li> </ul>
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. </p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  ##   Version: string (required)
  var query_773423 = newJObject()
  var formData_773424 = newJObject()
  add(formData_773424, "SourceSnapshotIdentifier",
      newJString(SourceSnapshotIdentifier))
  add(formData_773424, "TargetSnapshotIdentifier",
      newJString(TargetSnapshotIdentifier))
  add(query_773423, "Action", newJString(Action))
  add(formData_773424, "SourceSnapshotClusterIdentifier",
      newJString(SourceSnapshotClusterIdentifier))
  add(formData_773424, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  add(query_773423, "Version", newJString(Version))
  result = call_773422.call(nil, query_773423, nil, formData_773424, nil)

var postCopyClusterSnapshot* = Call_PostCopyClusterSnapshot_773405(
    name: "postCopyClusterSnapshot", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=CopyClusterSnapshot",
    validator: validate_PostCopyClusterSnapshot_773406, base: "/",
    url: url_PostCopyClusterSnapshot_773407, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCopyClusterSnapshot_773386 = ref object of OpenApiRestCall_772581
proc url_GetCopyClusterSnapshot_773388(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_GetCopyClusterSnapshot_773387(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Copies the specified automated cluster snapshot to a new manual cluster snapshot. The source must be an automated snapshot and it must be in the available state.</p> <p>When you delete a cluster, Amazon Redshift deletes any automated snapshots of the cluster. Also, when the retention period of the snapshot expires, Amazon Redshift automatically deletes it. If you want to keep an automated snapshot for a longer period, you can make a manual copy of the snapshot. Manual snapshots are retained until you delete them.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   SourceSnapshotIdentifier: JString (required)
  ##                           : <p>The identifier for the source snapshot.</p> <p>Constraints:</p> <ul> <li> <p>Must be the identifier for a valid automated snapshot whose state is <code>available</code>.</p> </li> </ul>
  ##   Action: JString (required)
  ##   TargetSnapshotIdentifier: JString (required)
  ##                           : <p>The identifier given to the new manual snapshot.</p> <p>Constraints:</p> <ul> <li> <p>Cannot be null, empty, or blank.</p> </li> <li> <p>Must contain from 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for the AWS account that is making the request.</p> </li> </ul>
  ##   Version: JString (required)
  ##   SourceSnapshotClusterIdentifier: JString
  ##                                  : <p>The identifier of the cluster the source snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.</p> <p>Constraints:</p> <ul> <li> <p>Must be the identifier for a valid cluster.</p> </li> </ul>
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. </p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `SourceSnapshotIdentifier` field"
  var valid_773389 = query.getOrDefault("SourceSnapshotIdentifier")
  valid_773389 = validateParameter(valid_773389, JString, required = true,
                                 default = nil)
  if valid_773389 != nil:
    section.add "SourceSnapshotIdentifier", valid_773389
  var valid_773390 = query.getOrDefault("Action")
  valid_773390 = validateParameter(valid_773390, JString, required = true,
                                 default = newJString("CopyClusterSnapshot"))
  if valid_773390 != nil:
    section.add "Action", valid_773390
  var valid_773391 = query.getOrDefault("TargetSnapshotIdentifier")
  valid_773391 = validateParameter(valid_773391, JString, required = true,
                                 default = nil)
  if valid_773391 != nil:
    section.add "TargetSnapshotIdentifier", valid_773391
  var valid_773392 = query.getOrDefault("Version")
  valid_773392 = validateParameter(valid_773392, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_773392 != nil:
    section.add "Version", valid_773392
  var valid_773393 = query.getOrDefault("SourceSnapshotClusterIdentifier")
  valid_773393 = validateParameter(valid_773393, JString, required = false,
                                 default = nil)
  if valid_773393 != nil:
    section.add "SourceSnapshotClusterIdentifier", valid_773393
  var valid_773394 = query.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_773394 = validateParameter(valid_773394, JInt, required = false, default = nil)
  if valid_773394 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_773394
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_773395 = header.getOrDefault("X-Amz-Date")
  valid_773395 = validateParameter(valid_773395, JString, required = false,
                                 default = nil)
  if valid_773395 != nil:
    section.add "X-Amz-Date", valid_773395
  var valid_773396 = header.getOrDefault("X-Amz-Security-Token")
  valid_773396 = validateParameter(valid_773396, JString, required = false,
                                 default = nil)
  if valid_773396 != nil:
    section.add "X-Amz-Security-Token", valid_773396
  var valid_773397 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_773397 = validateParameter(valid_773397, JString, required = false,
                                 default = nil)
  if valid_773397 != nil:
    section.add "X-Amz-Content-Sha256", valid_773397
  var valid_773398 = header.getOrDefault("X-Amz-Algorithm")
  valid_773398 = validateParameter(valid_773398, JString, required = false,
                                 default = nil)
  if valid_773398 != nil:
    section.add "X-Amz-Algorithm", valid_773398
  var valid_773399 = header.getOrDefault("X-Amz-Signature")
  valid_773399 = validateParameter(valid_773399, JString, required = false,
                                 default = nil)
  if valid_773399 != nil:
    section.add "X-Amz-Signature", valid_773399
  var valid_773400 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_773400 = validateParameter(valid_773400, JString, required = false,
                                 default = nil)
  if valid_773400 != nil:
    section.add "X-Amz-SignedHeaders", valid_773400
  var valid_773401 = header.getOrDefault("X-Amz-Credential")
  valid_773401 = validateParameter(valid_773401, JString, required = false,
                                 default = nil)
  if valid_773401 != nil:
    section.add "X-Amz-Credential", valid_773401
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_773402: Call_GetCopyClusterSnapshot_773386; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Copies the specified automated cluster snapshot to a new manual cluster snapshot. The source must be an automated snapshot and it must be in the available state.</p> <p>When you delete a cluster, Amazon Redshift deletes any automated snapshots of the cluster. Also, when the retention period of the snapshot expires, Amazon Redshift automatically deletes it. If you want to keep an automated snapshot for a longer period, you can make a manual copy of the snapshot. Manual snapshots are retained until you delete them.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_773402.validator(path, query, header, formData, body)
  let scheme = call_773402.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_773402.url(scheme.get, call_773402.host, call_773402.base,
                         call_773402.route, valid.getOrDefault("path"))
  result = hook(call_773402, url, valid)

proc call*(call_773403: Call_GetCopyClusterSnapshot_773386;
          SourceSnapshotIdentifier: string; TargetSnapshotIdentifier: string;
          Action: string = "CopyClusterSnapshot"; Version: string = "2012-12-01";
          SourceSnapshotClusterIdentifier: string = "";
          ManualSnapshotRetentionPeriod: int = 0): Recallable =
  ## getCopyClusterSnapshot
  ## <p>Copies the specified automated cluster snapshot to a new manual cluster snapshot. The source must be an automated snapshot and it must be in the available state.</p> <p>When you delete a cluster, Amazon Redshift deletes any automated snapshots of the cluster. Also, when the retention period of the snapshot expires, Amazon Redshift automatically deletes it. If you want to keep an automated snapshot for a longer period, you can make a manual copy of the snapshot. Manual snapshots are retained until you delete them.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   SourceSnapshotIdentifier: string (required)
  ##                           : <p>The identifier for the source snapshot.</p> <p>Constraints:</p> <ul> <li> <p>Must be the identifier for a valid automated snapshot whose state is <code>available</code>.</p> </li> </ul>
  ##   Action: string (required)
  ##   TargetSnapshotIdentifier: string (required)
  ##                           : <p>The identifier given to the new manual snapshot.</p> <p>Constraints:</p> <ul> <li> <p>Cannot be null, empty, or blank.</p> </li> <li> <p>Must contain from 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for the AWS account that is making the request.</p> </li> </ul>
  ##   Version: string (required)
  ##   SourceSnapshotClusterIdentifier: string
  ##                                  : <p>The identifier of the cluster the source snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.</p> <p>Constraints:</p> <ul> <li> <p>Must be the identifier for a valid cluster.</p> </li> </ul>
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. </p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  var query_773404 = newJObject()
  add(query_773404, "SourceSnapshotIdentifier",
      newJString(SourceSnapshotIdentifier))
  add(query_773404, "Action", newJString(Action))
  add(query_773404, "TargetSnapshotIdentifier",
      newJString(TargetSnapshotIdentifier))
  add(query_773404, "Version", newJString(Version))
  add(query_773404, "SourceSnapshotClusterIdentifier",
      newJString(SourceSnapshotClusterIdentifier))
  add(query_773404, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  result = call_773403.call(nil, query_773404, nil, nil, nil)

var getCopyClusterSnapshot* = Call_GetCopyClusterSnapshot_773386(
    name: "getCopyClusterSnapshot", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=CopyClusterSnapshot",
    validator: validate_GetCopyClusterSnapshot_773387, base: "/",
    url: url_GetCopyClusterSnapshot_773388, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCreateCluster_773470 = ref object of OpenApiRestCall_772581
proc url_PostCreateCluster_773472(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_PostCreateCluster_773471(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## <p>Creates a new cluster.</p> <p>To create a cluster in Virtual Private Cloud (VPC), you must provide a cluster subnet group name. The cluster subnet group identifies the subnets of your VPC that Amazon Redshift uses when creating the cluster. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_773473 = query.getOrDefault("Action")
  valid_773473 = validateParameter(valid_773473, JString, required = true,
                                 default = newJString("CreateCluster"))
  if valid_773473 != nil:
    section.add "Action", valid_773473
  var valid_773474 = query.getOrDefault("Version")
  valid_773474 = validateParameter(valid_773474, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_773474 != nil:
    section.add "Version", valid_773474
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_773475 = header.getOrDefault("X-Amz-Date")
  valid_773475 = validateParameter(valid_773475, JString, required = false,
                                 default = nil)
  if valid_773475 != nil:
    section.add "X-Amz-Date", valid_773475
  var valid_773476 = header.getOrDefault("X-Amz-Security-Token")
  valid_773476 = validateParameter(valid_773476, JString, required = false,
                                 default = nil)
  if valid_773476 != nil:
    section.add "X-Amz-Security-Token", valid_773476
  var valid_773477 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_773477 = validateParameter(valid_773477, JString, required = false,
                                 default = nil)
  if valid_773477 != nil:
    section.add "X-Amz-Content-Sha256", valid_773477
  var valid_773478 = header.getOrDefault("X-Amz-Algorithm")
  valid_773478 = validateParameter(valid_773478, JString, required = false,
                                 default = nil)
  if valid_773478 != nil:
    section.add "X-Amz-Algorithm", valid_773478
  var valid_773479 = header.getOrDefault("X-Amz-Signature")
  valid_773479 = validateParameter(valid_773479, JString, required = false,
                                 default = nil)
  if valid_773479 != nil:
    section.add "X-Amz-Signature", valid_773479
  var valid_773480 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_773480 = validateParameter(valid_773480, JString, required = false,
                                 default = nil)
  if valid_773480 != nil:
    section.add "X-Amz-SignedHeaders", valid_773480
  var valid_773481 = header.getOrDefault("X-Amz-Credential")
  valid_773481 = validateParameter(valid_773481, JString, required = false,
                                 default = nil)
  if valid_773481 != nil:
    section.add "X-Amz-Credential", valid_773481
  result.add "header", section
  ## parameters in `formData` object:
  ##   PreferredMaintenanceWindow: JString
  ##                             : <p>The weekly time range (in UTC) during which automated cluster maintenance can occur.</p> <p> Format: <code>ddd:hh24:mi-ddd:hh24:mi</code> </p> <p> Default: A 30-minute window selected at random from an 8-hour block of time per region, occurring on a random day of the week. For more information about the time blocks for each region, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-maintenance-windows">Maintenance Windows</a> in Amazon Redshift Cluster Management Guide.</p> <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p> <p>Constraints: Minimum 30-minute window.</p>
  ##   EnhancedVpcRouting: JBool
  ##                     : <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p> <p>Default: false</p>
  ##   Port: JInt
  ##       : <p>The port number on which the cluster accepts incoming connections.</p> <p>The cluster is accessible only via the JDBC and ODBC connection strings. Part of the connection string requires the port on which the cluster will listen for incoming connections.</p> <p>Default: <code>5439</code> </p> <p>Valid Values: <code>1150-65535</code> </p>
  ##   VpcSecurityGroupIds: JArray
  ##                      : <p>A list of Virtual Private Cloud (VPC) security groups to be associated with the cluster.</p> <p>Default: The default VPC security group is associated with the cluster.</p>
  ##   DBName: JString
  ##         : <p>The name of the first database to be created when the cluster is created.</p> <p>To create additional databases after the cluster is created, connect to the cluster with a SQL client and use SQL commands to create a database. For more information, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/t_creating_database.html">Create a Database</a> in the Amazon Redshift Database Developer Guide. </p> <p>Default: <code>dev</code> </p> <p>Constraints:</p> <ul> <li> <p>Must contain 1 to 64 alphanumeric characters.</p> </li> <li> <p>Must contain only lowercase letters.</p> </li> <li> <p>Cannot be a word that is reserved by the service. A list of reserved words can be found in <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide. </p> </li> </ul>
  ##   ClusterVersion: JString
  ##                 : <p>The version of the Amazon Redshift engine software that you want to deploy on the cluster.</p> <p>The version selected runs on all the nodes in the cluster.</p> <p>Constraints: Only version 1.0 is currently available.</p> <p>Example: <code>1.0</code> </p>
  ##   ClusterType: JString
  ##              : <p>The type of the cluster. When cluster type is specified as</p> <ul> <li> <p> <code>single-node</code>, the <b>NumberOfNodes</b> parameter is not required.</p> </li> <li> <p> <code>multi-node</code>, the <b>NumberOfNodes</b> parameter is required.</p> </li> </ul> <p>Valid Values: <code>multi-node</code> | <code>single-node</code> </p> <p>Default: <code>multi-node</code> </p>
  ##   MasterUserPassword: JString (required)
  ##                     : <p>The password associated with the master user account for the cluster that is being created.</p> <p>Constraints:</p> <ul> <li> <p>Must be between 8 and 64 characters in length.</p> </li> <li> <p>Must contain at least one uppercase letter.</p> </li> <li> <p>Must contain at least one lowercase letter.</p> </li> <li> <p>Must contain one number.</p> </li> <li> <p>Can be any printable ASCII character (ASCII code 33 to 126) except ' (single quote), " (double quote), \, /, @, or space.</p> </li> </ul>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   AdditionalInfo: JString
  ##                 : Reserved.
  ##   ClusterSecurityGroups: JArray
  ##                        : <p>A list of security groups to be associated with this cluster.</p> <p>Default: The default cluster security group for Amazon Redshift.</p>
  ##   AvailabilityZone: JString
  ##                   : <p>The EC2 Availability Zone (AZ) in which you want Amazon Redshift to provision the cluster. For example, if you have several EC2 instances running in a specific Availability Zone, then you might want the cluster to be provisioned in the same zone in order to decrease network latency.</p> <p>Default: A random, system-chosen Availability Zone in the region that is specified by the endpoint.</p> <p>Example: <code>us-east-1d</code> </p> <p>Constraint: The specified Availability Zone must be in the same region as the current endpoint.</p>
  ##   Encrypted: JBool
  ##            : <p>If <code>true</code>, the data in the cluster is encrypted at rest. </p> <p>Default: false</p>
  ##   HsmConfigurationIdentifier: JString
  ##                             : Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
  ##   HsmClientCertificateIdentifier: JString
  ##                                 : Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM.
  ##   PubliclyAccessible: JBool
  ##                     : If <code>true</code>, the cluster can be accessed from a public network. 
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>A unique identifier for the cluster. You use this identifier to refer to the cluster for any subsequent cluster operations such as deleting or modifying. The identifier also appears in the Amazon Redshift console.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul> <p>Example: <code>myexamplecluster</code> </p>
  ##   MasterUsername: JString (required)
  ##                 : <p>The user name associated with the master user account for the cluster that is being created.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 - 128 alphanumeric characters. The user name can't be <code>PUBLIC</code>.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide. </p> </li> </ul>
  ##   NumberOfNodes: JInt
  ##                : <p>The number of compute nodes in the cluster. This parameter is required when the <b>ClusterType</b> parameter is specified as <code>multi-node</code>. </p> <p>For information about determining how many nodes you need, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#how-many-nodes"> Working with Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p> <p>If you don't specify this parameter, you get a single-node cluster. When requesting a multi-node cluster, you must specify the number of nodes that you want in the cluster.</p> <p>Default: <code>1</code> </p> <p>Constraints: Value must be at least 1 and no more than 100.</p>
  ##   IamRoles: JArray
  ##           : <p>A list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services. You must supply the IAM roles in their Amazon Resource Name (ARN) format. You can supply up to 10 IAM roles in a single request.</p> <p>A cluster can have up to 10 IAM roles associated with it at any time.</p>
  ##   ClusterParameterGroupName: JString
  ##                            : <p>The name of the parameter group to be associated with this cluster.</p> <p>Default: The default Amazon Redshift cluster parameter group. For information about the default parameter group, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Working with Amazon Redshift Parameter Groups</a> </p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   SnapshotScheduleIdentifier: JString
  ##                             : A unique identifier for the snapshot schedule.
  ##   KmsKeyId: JString
  ##           : The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster.
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The default number of days to retain a manual snapshot. If the value is -1, the snapshot is retained indefinitely. This setting doesn't change the retention period of existing snapshots.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  ##   ElasticIp: JString
  ##            : <p>The Elastic IP (EIP) address for the cluster.</p> <p>Constraints: The cluster must be provisioned in EC2-VPC and publicly-accessible through an Internet gateway. For more information about provisioning clusters in EC2-VPC, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#cluster-platforms">Supported Platforms to Launch Your Cluster</a> in the Amazon Redshift Cluster Management Guide.</p>
  ##   AllowVersionUpgrade: JBool
  ##                      : <p>If <code>true</code>, major version upgrades can be applied during the maintenance window to the Amazon Redshift engine that is running on the cluster.</p> <p>When a new major version of the Amazon Redshift engine is released, you can request that the service automatically apply upgrades during the maintenance window to the Amazon Redshift engine that is running on your cluster.</p> <p>Default: <code>true</code> </p>
  ##   AutomatedSnapshotRetentionPeriod: JInt
  ##                                   : <p>The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p> <p>Default: <code>1</code> </p> <p>Constraints: Must be a value from 0 to 35.</p>
  ##   NodeType: JString (required)
  ##           : <p>The node type to be provisioned for the cluster. For information about node types, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#how-many-nodes"> Working with Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p> <p>Valid Values: <code>ds2.xlarge</code> | <code>ds2.8xlarge</code> | <code>ds2.xlarge</code> | <code>ds2.8xlarge</code> | <code>dc1.large</code> | <code>dc1.8xlarge</code> | <code>dc2.large</code> | <code>dc2.8xlarge</code> </p>
  ##   MaintenanceTrackName: JString
  ##                       : An optional parameter for the name of the maintenance track for the cluster. If you don't provide a maintenance track name, the cluster is assigned to the <code>current</code> track.
  ##   ClusterSubnetGroupName: JString
  ##                         : <p>The name of a cluster subnet group to be associated with this cluster.</p> <p>If this parameter is not provided the resulting cluster will be deployed outside virtual private cloud (VPC).</p>
  section = newJObject()
  var valid_773482 = formData.getOrDefault("PreferredMaintenanceWindow")
  valid_773482 = validateParameter(valid_773482, JString, required = false,
                                 default = nil)
  if valid_773482 != nil:
    section.add "PreferredMaintenanceWindow", valid_773482
  var valid_773483 = formData.getOrDefault("EnhancedVpcRouting")
  valid_773483 = validateParameter(valid_773483, JBool, required = false, default = nil)
  if valid_773483 != nil:
    section.add "EnhancedVpcRouting", valid_773483
  var valid_773484 = formData.getOrDefault("Port")
  valid_773484 = validateParameter(valid_773484, JInt, required = false, default = nil)
  if valid_773484 != nil:
    section.add "Port", valid_773484
  var valid_773485 = formData.getOrDefault("VpcSecurityGroupIds")
  valid_773485 = validateParameter(valid_773485, JArray, required = false,
                                 default = nil)
  if valid_773485 != nil:
    section.add "VpcSecurityGroupIds", valid_773485
  var valid_773486 = formData.getOrDefault("DBName")
  valid_773486 = validateParameter(valid_773486, JString, required = false,
                                 default = nil)
  if valid_773486 != nil:
    section.add "DBName", valid_773486
  var valid_773487 = formData.getOrDefault("ClusterVersion")
  valid_773487 = validateParameter(valid_773487, JString, required = false,
                                 default = nil)
  if valid_773487 != nil:
    section.add "ClusterVersion", valid_773487
  var valid_773488 = formData.getOrDefault("ClusterType")
  valid_773488 = validateParameter(valid_773488, JString, required = false,
                                 default = nil)
  if valid_773488 != nil:
    section.add "ClusterType", valid_773488
  assert formData != nil, "formData argument is necessary due to required `MasterUserPassword` field"
  var valid_773489 = formData.getOrDefault("MasterUserPassword")
  valid_773489 = validateParameter(valid_773489, JString, required = true,
                                 default = nil)
  if valid_773489 != nil:
    section.add "MasterUserPassword", valid_773489
  var valid_773490 = formData.getOrDefault("Tags")
  valid_773490 = validateParameter(valid_773490, JArray, required = false,
                                 default = nil)
  if valid_773490 != nil:
    section.add "Tags", valid_773490
  var valid_773491 = formData.getOrDefault("AdditionalInfo")
  valid_773491 = validateParameter(valid_773491, JString, required = false,
                                 default = nil)
  if valid_773491 != nil:
    section.add "AdditionalInfo", valid_773491
  var valid_773492 = formData.getOrDefault("ClusterSecurityGroups")
  valid_773492 = validateParameter(valid_773492, JArray, required = false,
                                 default = nil)
  if valid_773492 != nil:
    section.add "ClusterSecurityGroups", valid_773492
  var valid_773493 = formData.getOrDefault("AvailabilityZone")
  valid_773493 = validateParameter(valid_773493, JString, required = false,
                                 default = nil)
  if valid_773493 != nil:
    section.add "AvailabilityZone", valid_773493
  var valid_773494 = formData.getOrDefault("Encrypted")
  valid_773494 = validateParameter(valid_773494, JBool, required = false, default = nil)
  if valid_773494 != nil:
    section.add "Encrypted", valid_773494
  var valid_773495 = formData.getOrDefault("HsmConfigurationIdentifier")
  valid_773495 = validateParameter(valid_773495, JString, required = false,
                                 default = nil)
  if valid_773495 != nil:
    section.add "HsmConfigurationIdentifier", valid_773495
  var valid_773496 = formData.getOrDefault("HsmClientCertificateIdentifier")
  valid_773496 = validateParameter(valid_773496, JString, required = false,
                                 default = nil)
  if valid_773496 != nil:
    section.add "HsmClientCertificateIdentifier", valid_773496
  var valid_773497 = formData.getOrDefault("PubliclyAccessible")
  valid_773497 = validateParameter(valid_773497, JBool, required = false, default = nil)
  if valid_773497 != nil:
    section.add "PubliclyAccessible", valid_773497
  var valid_773498 = formData.getOrDefault("ClusterIdentifier")
  valid_773498 = validateParameter(valid_773498, JString, required = true,
                                 default = nil)
  if valid_773498 != nil:
    section.add "ClusterIdentifier", valid_773498
  var valid_773499 = formData.getOrDefault("MasterUsername")
  valid_773499 = validateParameter(valid_773499, JString, required = true,
                                 default = nil)
  if valid_773499 != nil:
    section.add "MasterUsername", valid_773499
  var valid_773500 = formData.getOrDefault("NumberOfNodes")
  valid_773500 = validateParameter(valid_773500, JInt, required = false, default = nil)
  if valid_773500 != nil:
    section.add "NumberOfNodes", valid_773500
  var valid_773501 = formData.getOrDefault("IamRoles")
  valid_773501 = validateParameter(valid_773501, JArray, required = false,
                                 default = nil)
  if valid_773501 != nil:
    section.add "IamRoles", valid_773501
  var valid_773502 = formData.getOrDefault("ClusterParameterGroupName")
  valid_773502 = validateParameter(valid_773502, JString, required = false,
                                 default = nil)
  if valid_773502 != nil:
    section.add "ClusterParameterGroupName", valid_773502
  var valid_773503 = formData.getOrDefault("SnapshotScheduleIdentifier")
  valid_773503 = validateParameter(valid_773503, JString, required = false,
                                 default = nil)
  if valid_773503 != nil:
    section.add "SnapshotScheduleIdentifier", valid_773503
  var valid_773504 = formData.getOrDefault("KmsKeyId")
  valid_773504 = validateParameter(valid_773504, JString, required = false,
                                 default = nil)
  if valid_773504 != nil:
    section.add "KmsKeyId", valid_773504
  var valid_773505 = formData.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_773505 = validateParameter(valid_773505, JInt, required = false, default = nil)
  if valid_773505 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_773505
  var valid_773506 = formData.getOrDefault("ElasticIp")
  valid_773506 = validateParameter(valid_773506, JString, required = false,
                                 default = nil)
  if valid_773506 != nil:
    section.add "ElasticIp", valid_773506
  var valid_773507 = formData.getOrDefault("AllowVersionUpgrade")
  valid_773507 = validateParameter(valid_773507, JBool, required = false, default = nil)
  if valid_773507 != nil:
    section.add "AllowVersionUpgrade", valid_773507
  var valid_773508 = formData.getOrDefault("AutomatedSnapshotRetentionPeriod")
  valid_773508 = validateParameter(valid_773508, JInt, required = false, default = nil)
  if valid_773508 != nil:
    section.add "AutomatedSnapshotRetentionPeriod", valid_773508
  var valid_773509 = formData.getOrDefault("NodeType")
  valid_773509 = validateParameter(valid_773509, JString, required = true,
                                 default = nil)
  if valid_773509 != nil:
    section.add "NodeType", valid_773509
  var valid_773510 = formData.getOrDefault("MaintenanceTrackName")
  valid_773510 = validateParameter(valid_773510, JString, required = false,
                                 default = nil)
  if valid_773510 != nil:
    section.add "MaintenanceTrackName", valid_773510
  var valid_773511 = formData.getOrDefault("ClusterSubnetGroupName")
  valid_773511 = validateParameter(valid_773511, JString, required = false,
                                 default = nil)
  if valid_773511 != nil:
    section.add "ClusterSubnetGroupName", valid_773511
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_773512: Call_PostCreateCluster_773470; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a new cluster.</p> <p>To create a cluster in Virtual Private Cloud (VPC), you must provide a cluster subnet group name. The cluster subnet group identifies the subnets of your VPC that Amazon Redshift uses when creating the cluster. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_773512.validator(path, query, header, formData, body)
  let scheme = call_773512.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_773512.url(scheme.get, call_773512.host, call_773512.base,
                         call_773512.route, valid.getOrDefault("path"))
  result = hook(call_773512, url, valid)

proc call*(call_773513: Call_PostCreateCluster_773470; MasterUserPassword: string;
          ClusterIdentifier: string; MasterUsername: string; NodeType: string;
          PreferredMaintenanceWindow: string = ""; EnhancedVpcRouting: bool = false;
          Port: int = 0; VpcSecurityGroupIds: JsonNode = nil; DBName: string = "";
          ClusterVersion: string = ""; ClusterType: string = ""; Tags: JsonNode = nil;
          AdditionalInfo: string = ""; ClusterSecurityGroups: JsonNode = nil;
          AvailabilityZone: string = ""; Encrypted: bool = false;
          HsmConfigurationIdentifier: string = ""; Action: string = "CreateCluster";
          HsmClientCertificateIdentifier: string = "";
          PubliclyAccessible: bool = false; NumberOfNodes: int = 0;
          IamRoles: JsonNode = nil; ClusterParameterGroupName: string = "";
          SnapshotScheduleIdentifier: string = ""; KmsKeyId: string = "";
          ManualSnapshotRetentionPeriod: int = 0; ElasticIp: string = "";
          AllowVersionUpgrade: bool = false;
          AutomatedSnapshotRetentionPeriod: int = 0; Version: string = "2012-12-01";
          MaintenanceTrackName: string = ""; ClusterSubnetGroupName: string = ""): Recallable =
  ## postCreateCluster
  ## <p>Creates a new cluster.</p> <p>To create a cluster in Virtual Private Cloud (VPC), you must provide a cluster subnet group name. The cluster subnet group identifies the subnets of your VPC that Amazon Redshift uses when creating the cluster. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   PreferredMaintenanceWindow: string
  ##                             : <p>The weekly time range (in UTC) during which automated cluster maintenance can occur.</p> <p> Format: <code>ddd:hh24:mi-ddd:hh24:mi</code> </p> <p> Default: A 30-minute window selected at random from an 8-hour block of time per region, occurring on a random day of the week. For more information about the time blocks for each region, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-maintenance-windows">Maintenance Windows</a> in Amazon Redshift Cluster Management Guide.</p> <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p> <p>Constraints: Minimum 30-minute window.</p>
  ##   EnhancedVpcRouting: bool
  ##                     : <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p> <p>Default: false</p>
  ##   Port: int
  ##       : <p>The port number on which the cluster accepts incoming connections.</p> <p>The cluster is accessible only via the JDBC and ODBC connection strings. Part of the connection string requires the port on which the cluster will listen for incoming connections.</p> <p>Default: <code>5439</code> </p> <p>Valid Values: <code>1150-65535</code> </p>
  ##   VpcSecurityGroupIds: JArray
  ##                      : <p>A list of Virtual Private Cloud (VPC) security groups to be associated with the cluster.</p> <p>Default: The default VPC security group is associated with the cluster.</p>
  ##   DBName: string
  ##         : <p>The name of the first database to be created when the cluster is created.</p> <p>To create additional databases after the cluster is created, connect to the cluster with a SQL client and use SQL commands to create a database. For more information, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/t_creating_database.html">Create a Database</a> in the Amazon Redshift Database Developer Guide. </p> <p>Default: <code>dev</code> </p> <p>Constraints:</p> <ul> <li> <p>Must contain 1 to 64 alphanumeric characters.</p> </li> <li> <p>Must contain only lowercase letters.</p> </li> <li> <p>Cannot be a word that is reserved by the service. A list of reserved words can be found in <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide. </p> </li> </ul>
  ##   ClusterVersion: string
  ##                 : <p>The version of the Amazon Redshift engine software that you want to deploy on the cluster.</p> <p>The version selected runs on all the nodes in the cluster.</p> <p>Constraints: Only version 1.0 is currently available.</p> <p>Example: <code>1.0</code> </p>
  ##   ClusterType: string
  ##              : <p>The type of the cluster. When cluster type is specified as</p> <ul> <li> <p> <code>single-node</code>, the <b>NumberOfNodes</b> parameter is not required.</p> </li> <li> <p> <code>multi-node</code>, the <b>NumberOfNodes</b> parameter is required.</p> </li> </ul> <p>Valid Values: <code>multi-node</code> | <code>single-node</code> </p> <p>Default: <code>multi-node</code> </p>
  ##   MasterUserPassword: string (required)
  ##                     : <p>The password associated with the master user account for the cluster that is being created.</p> <p>Constraints:</p> <ul> <li> <p>Must be between 8 and 64 characters in length.</p> </li> <li> <p>Must contain at least one uppercase letter.</p> </li> <li> <p>Must contain at least one lowercase letter.</p> </li> <li> <p>Must contain one number.</p> </li> <li> <p>Can be any printable ASCII character (ASCII code 33 to 126) except ' (single quote), " (double quote), \, /, @, or space.</p> </li> </ul>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   AdditionalInfo: string
  ##                 : Reserved.
  ##   ClusterSecurityGroups: JArray
  ##                        : <p>A list of security groups to be associated with this cluster.</p> <p>Default: The default cluster security group for Amazon Redshift.</p>
  ##   AvailabilityZone: string
  ##                   : <p>The EC2 Availability Zone (AZ) in which you want Amazon Redshift to provision the cluster. For example, if you have several EC2 instances running in a specific Availability Zone, then you might want the cluster to be provisioned in the same zone in order to decrease network latency.</p> <p>Default: A random, system-chosen Availability Zone in the region that is specified by the endpoint.</p> <p>Example: <code>us-east-1d</code> </p> <p>Constraint: The specified Availability Zone must be in the same region as the current endpoint.</p>
  ##   Encrypted: bool
  ##            : <p>If <code>true</code>, the data in the cluster is encrypted at rest. </p> <p>Default: false</p>
  ##   HsmConfigurationIdentifier: string
  ##                             : Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
  ##   Action: string (required)
  ##   HsmClientCertificateIdentifier: string
  ##                                 : Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM.
  ##   PubliclyAccessible: bool
  ##                     : If <code>true</code>, the cluster can be accessed from a public network. 
  ##   ClusterIdentifier: string (required)
  ##                    : <p>A unique identifier for the cluster. You use this identifier to refer to the cluster for any subsequent cluster operations such as deleting or modifying. The identifier also appears in the Amazon Redshift console.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul> <p>Example: <code>myexamplecluster</code> </p>
  ##   MasterUsername: string (required)
  ##                 : <p>The user name associated with the master user account for the cluster that is being created.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 - 128 alphanumeric characters. The user name can't be <code>PUBLIC</code>.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide. </p> </li> </ul>
  ##   NumberOfNodes: int
  ##                : <p>The number of compute nodes in the cluster. This parameter is required when the <b>ClusterType</b> parameter is specified as <code>multi-node</code>. </p> <p>For information about determining how many nodes you need, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#how-many-nodes"> Working with Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p> <p>If you don't specify this parameter, you get a single-node cluster. When requesting a multi-node cluster, you must specify the number of nodes that you want in the cluster.</p> <p>Default: <code>1</code> </p> <p>Constraints: Value must be at least 1 and no more than 100.</p>
  ##   IamRoles: JArray
  ##           : <p>A list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services. You must supply the IAM roles in their Amazon Resource Name (ARN) format. You can supply up to 10 IAM roles in a single request.</p> <p>A cluster can have up to 10 IAM roles associated with it at any time.</p>
  ##   ClusterParameterGroupName: string
  ##                            : <p>The name of the parameter group to be associated with this cluster.</p> <p>Default: The default Amazon Redshift cluster parameter group. For information about the default parameter group, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Working with Amazon Redshift Parameter Groups</a> </p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   SnapshotScheduleIdentifier: string
  ##                             : A unique identifier for the snapshot schedule.
  ##   KmsKeyId: string
  ##           : The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster.
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The default number of days to retain a manual snapshot. If the value is -1, the snapshot is retained indefinitely. This setting doesn't change the retention period of existing snapshots.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  ##   ElasticIp: string
  ##            : <p>The Elastic IP (EIP) address for the cluster.</p> <p>Constraints: The cluster must be provisioned in EC2-VPC and publicly-accessible through an Internet gateway. For more information about provisioning clusters in EC2-VPC, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#cluster-platforms">Supported Platforms to Launch Your Cluster</a> in the Amazon Redshift Cluster Management Guide.</p>
  ##   AllowVersionUpgrade: bool
  ##                      : <p>If <code>true</code>, major version upgrades can be applied during the maintenance window to the Amazon Redshift engine that is running on the cluster.</p> <p>When a new major version of the Amazon Redshift engine is released, you can request that the service automatically apply upgrades during the maintenance window to the Amazon Redshift engine that is running on your cluster.</p> <p>Default: <code>true</code> </p>
  ##   AutomatedSnapshotRetentionPeriod: int
  ##                                   : <p>The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p> <p>Default: <code>1</code> </p> <p>Constraints: Must be a value from 0 to 35.</p>
  ##   Version: string (required)
  ##   NodeType: string (required)
  ##           : <p>The node type to be provisioned for the cluster. For information about node types, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#how-many-nodes"> Working with Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p> <p>Valid Values: <code>ds2.xlarge</code> | <code>ds2.8xlarge</code> | <code>ds2.xlarge</code> | <code>ds2.8xlarge</code> | <code>dc1.large</code> | <code>dc1.8xlarge</code> | <code>dc2.large</code> | <code>dc2.8xlarge</code> </p>
  ##   MaintenanceTrackName: string
  ##                       : An optional parameter for the name of the maintenance track for the cluster. If you don't provide a maintenance track name, the cluster is assigned to the <code>current</code> track.
  ##   ClusterSubnetGroupName: string
  ##                         : <p>The name of a cluster subnet group to be associated with this cluster.</p> <p>If this parameter is not provided the resulting cluster will be deployed outside virtual private cloud (VPC).</p>
  var query_773514 = newJObject()
  var formData_773515 = newJObject()
  add(formData_773515, "PreferredMaintenanceWindow",
      newJString(PreferredMaintenanceWindow))
  add(formData_773515, "EnhancedVpcRouting", newJBool(EnhancedVpcRouting))
  add(formData_773515, "Port", newJInt(Port))
  if VpcSecurityGroupIds != nil:
    formData_773515.add "VpcSecurityGroupIds", VpcSecurityGroupIds
  add(formData_773515, "DBName", newJString(DBName))
  add(formData_773515, "ClusterVersion", newJString(ClusterVersion))
  add(formData_773515, "ClusterType", newJString(ClusterType))
  add(formData_773515, "MasterUserPassword", newJString(MasterUserPassword))
  if Tags != nil:
    formData_773515.add "Tags", Tags
  add(formData_773515, "AdditionalInfo", newJString(AdditionalInfo))
  if ClusterSecurityGroups != nil:
    formData_773515.add "ClusterSecurityGroups", ClusterSecurityGroups
  add(formData_773515, "AvailabilityZone", newJString(AvailabilityZone))
  add(formData_773515, "Encrypted", newJBool(Encrypted))
  add(formData_773515, "HsmConfigurationIdentifier",
      newJString(HsmConfigurationIdentifier))
  add(query_773514, "Action", newJString(Action))
  add(formData_773515, "HsmClientCertificateIdentifier",
      newJString(HsmClientCertificateIdentifier))
  add(formData_773515, "PubliclyAccessible", newJBool(PubliclyAccessible))
  add(formData_773515, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_773515, "MasterUsername", newJString(MasterUsername))
  add(formData_773515, "NumberOfNodes", newJInt(NumberOfNodes))
  if IamRoles != nil:
    formData_773515.add "IamRoles", IamRoles
  add(formData_773515, "ClusterParameterGroupName",
      newJString(ClusterParameterGroupName))
  add(formData_773515, "SnapshotScheduleIdentifier",
      newJString(SnapshotScheduleIdentifier))
  add(formData_773515, "KmsKeyId", newJString(KmsKeyId))
  add(formData_773515, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  add(formData_773515, "ElasticIp", newJString(ElasticIp))
  add(formData_773515, "AllowVersionUpgrade", newJBool(AllowVersionUpgrade))
  add(formData_773515, "AutomatedSnapshotRetentionPeriod",
      newJInt(AutomatedSnapshotRetentionPeriod))
  add(query_773514, "Version", newJString(Version))
  add(formData_773515, "NodeType", newJString(NodeType))
  add(formData_773515, "MaintenanceTrackName", newJString(MaintenanceTrackName))
  add(formData_773515, "ClusterSubnetGroupName",
      newJString(ClusterSubnetGroupName))
  result = call_773513.call(nil, query_773514, nil, formData_773515, nil)

var postCreateCluster* = Call_PostCreateCluster_773470(name: "postCreateCluster",
    meth: HttpMethod.HttpPost, host: "redshift.amazonaws.com",
    route: "/#Action=CreateCluster", validator: validate_PostCreateCluster_773471,
    base: "/", url: url_PostCreateCluster_773472,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCreateCluster_773425 = ref object of OpenApiRestCall_772581
proc url_GetCreateCluster_773427(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_GetCreateCluster_773426(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## <p>Creates a new cluster.</p> <p>To create a cluster in Virtual Private Cloud (VPC), you must provide a cluster subnet group name. The cluster subnet group identifies the subnets of your VPC that Amazon Redshift uses when creating the cluster. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ClusterSecurityGroups: JArray
  ##                        : <p>A list of security groups to be associated with this cluster.</p> <p>Default: The default cluster security group for Amazon Redshift.</p>
  ##   MasterUsername: JString (required)
  ##                 : <p>The user name associated with the master user account for the cluster that is being created.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 - 128 alphanumeric characters. The user name can't be <code>PUBLIC</code>.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide. </p> </li> </ul>
  ##   ClusterSubnetGroupName: JString
  ##                         : <p>The name of a cluster subnet group to be associated with this cluster.</p> <p>If this parameter is not provided the resulting cluster will be deployed outside virtual private cloud (VPC).</p>
  ##   HsmClientCertificateIdentifier: JString
  ##                                 : Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM.
  ##   PreferredMaintenanceWindow: JString
  ##                             : <p>The weekly time range (in UTC) during which automated cluster maintenance can occur.</p> <p> Format: <code>ddd:hh24:mi-ddd:hh24:mi</code> </p> <p> Default: A 30-minute window selected at random from an 8-hour block of time per region, occurring on a random day of the week. For more information about the time blocks for each region, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-maintenance-windows">Maintenance Windows</a> in Amazon Redshift Cluster Management Guide.</p> <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p> <p>Constraints: Minimum 30-minute window.</p>
  ##   Encrypted: JBool
  ##            : <p>If <code>true</code>, the data in the cluster is encrypted at rest. </p> <p>Default: false</p>
  ##   MaintenanceTrackName: JString
  ##                       : An optional parameter for the name of the maintenance track for the cluster. If you don't provide a maintenance track name, the cluster is assigned to the <code>current</code> track.
  ##   IamRoles: JArray
  ##           : <p>A list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services. You must supply the IAM roles in their Amazon Resource Name (ARN) format. You can supply up to 10 IAM roles in a single request.</p> <p>A cluster can have up to 10 IAM roles associated with it at any time.</p>
  ##   AvailabilityZone: JString
  ##                   : <p>The EC2 Availability Zone (AZ) in which you want Amazon Redshift to provision the cluster. For example, if you have several EC2 instances running in a specific Availability Zone, then you might want the cluster to be provisioned in the same zone in order to decrease network latency.</p> <p>Default: A random, system-chosen Availability Zone in the region that is specified by the endpoint.</p> <p>Example: <code>us-east-1d</code> </p> <p>Constraint: The specified Availability Zone must be in the same region as the current endpoint.</p>
  ##   MasterUserPassword: JString (required)
  ##                     : <p>The password associated with the master user account for the cluster that is being created.</p> <p>Constraints:</p> <ul> <li> <p>Must be between 8 and 64 characters in length.</p> </li> <li> <p>Must contain at least one uppercase letter.</p> </li> <li> <p>Must contain at least one lowercase letter.</p> </li> <li> <p>Must contain one number.</p> </li> <li> <p>Can be any printable ASCII character (ASCII code 33 to 126) except ' (single quote), " (double quote), \, /, @, or space.</p> </li> </ul>
  ##   AllowVersionUpgrade: JBool
  ##                      : <p>If <code>true</code>, major version upgrades can be applied during the maintenance window to the Amazon Redshift engine that is running on the cluster.</p> <p>When a new major version of the Amazon Redshift engine is released, you can request that the service automatically apply upgrades during the maintenance window to the Amazon Redshift engine that is running on your cluster.</p> <p>Default: <code>true</code> </p>
  ##   EnhancedVpcRouting: JBool
  ##                     : <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p> <p>Default: false</p>
  ##   VpcSecurityGroupIds: JArray
  ##                      : <p>A list of Virtual Private Cloud (VPC) security groups to be associated with the cluster.</p> <p>Default: The default VPC security group is associated with the cluster.</p>
  ##   ClusterParameterGroupName: JString
  ##                            : <p>The name of the parameter group to be associated with this cluster.</p> <p>Default: The default Amazon Redshift cluster parameter group. For information about the default parameter group, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Working with Amazon Redshift Parameter Groups</a> </p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   HsmConfigurationIdentifier: JString
  ##                             : Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   DBName: JString
  ##         : <p>The name of the first database to be created when the cluster is created.</p> <p>To create additional databases after the cluster is created, connect to the cluster with a SQL client and use SQL commands to create a database. For more information, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/t_creating_database.html">Create a Database</a> in the Amazon Redshift Database Developer Guide. </p> <p>Default: <code>dev</code> </p> <p>Constraints:</p> <ul> <li> <p>Must contain 1 to 64 alphanumeric characters.</p> </li> <li> <p>Must contain only lowercase letters.</p> </li> <li> <p>Cannot be a word that is reserved by the service. A list of reserved words can be found in <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide. </p> </li> </ul>
  ##   SnapshotScheduleIdentifier: JString
  ##                             : A unique identifier for the snapshot schedule.
  ##   AdditionalInfo: JString
  ##                 : Reserved.
  ##   ElasticIp: JString
  ##            : <p>The Elastic IP (EIP) address for the cluster.</p> <p>Constraints: The cluster must be provisioned in EC2-VPC and publicly-accessible through an Internet gateway. For more information about provisioning clusters in EC2-VPC, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#cluster-platforms">Supported Platforms to Launch Your Cluster</a> in the Amazon Redshift Cluster Management Guide.</p>
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>A unique identifier for the cluster. You use this identifier to refer to the cluster for any subsequent cluster operations such as deleting or modifying. The identifier also appears in the Amazon Redshift console.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul> <p>Example: <code>myexamplecluster</code> </p>
  ##   Action: JString (required)
  ##   KmsKeyId: JString
  ##           : The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster.
  ##   PubliclyAccessible: JBool
  ##                     : If <code>true</code>, the cluster can be accessed from a public network. 
  ##   Port: JInt
  ##       : <p>The port number on which the cluster accepts incoming connections.</p> <p>The cluster is accessible only via the JDBC and ODBC connection strings. Part of the connection string requires the port on which the cluster will listen for incoming connections.</p> <p>Default: <code>5439</code> </p> <p>Valid Values: <code>1150-65535</code> </p>
  ##   NumberOfNodes: JInt
  ##                : <p>The number of compute nodes in the cluster. This parameter is required when the <b>ClusterType</b> parameter is specified as <code>multi-node</code>. </p> <p>For information about determining how many nodes you need, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#how-many-nodes"> Working with Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p> <p>If you don't specify this parameter, you get a single-node cluster. When requesting a multi-node cluster, you must specify the number of nodes that you want in the cluster.</p> <p>Default: <code>1</code> </p> <p>Constraints: Value must be at least 1 and no more than 100.</p>
  ##   AutomatedSnapshotRetentionPeriod: JInt
  ##                                   : <p>The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p> <p>Default: <code>1</code> </p> <p>Constraints: Must be a value from 0 to 35.</p>
  ##   NodeType: JString (required)
  ##           : <p>The node type to be provisioned for the cluster. For information about node types, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#how-many-nodes"> Working with Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p> <p>Valid Values: <code>ds2.xlarge</code> | <code>ds2.8xlarge</code> | <code>ds2.xlarge</code> | <code>ds2.8xlarge</code> | <code>dc1.large</code> | <code>dc1.8xlarge</code> | <code>dc2.large</code> | <code>dc2.8xlarge</code> </p>
  ##   ClusterVersion: JString
  ##                 : <p>The version of the Amazon Redshift engine software that you want to deploy on the cluster.</p> <p>The version selected runs on all the nodes in the cluster.</p> <p>Constraints: Only version 1.0 is currently available.</p> <p>Example: <code>1.0</code> </p>
  ##   Version: JString (required)
  ##   ClusterType: JString
  ##              : <p>The type of the cluster. When cluster type is specified as</p> <ul> <li> <p> <code>single-node</code>, the <b>NumberOfNodes</b> parameter is not required.</p> </li> <li> <p> <code>multi-node</code>, the <b>NumberOfNodes</b> parameter is required.</p> </li> </ul> <p>Valid Values: <code>multi-node</code> | <code>single-node</code> </p> <p>Default: <code>multi-node</code> </p>
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The default number of days to retain a manual snapshot. If the value is -1, the snapshot is retained indefinitely. This setting doesn't change the retention period of existing snapshots.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  section = newJObject()
  var valid_773428 = query.getOrDefault("ClusterSecurityGroups")
  valid_773428 = validateParameter(valid_773428, JArray, required = false,
                                 default = nil)
  if valid_773428 != nil:
    section.add "ClusterSecurityGroups", valid_773428
  assert query != nil,
        "query argument is necessary due to required `MasterUsername` field"
  var valid_773429 = query.getOrDefault("MasterUsername")
  valid_773429 = validateParameter(valid_773429, JString, required = true,
                                 default = nil)
  if valid_773429 != nil:
    section.add "MasterUsername", valid_773429
  var valid_773430 = query.getOrDefault("ClusterSubnetGroupName")
  valid_773430 = validateParameter(valid_773430, JString, required = false,
                                 default = nil)
  if valid_773430 != nil:
    section.add "ClusterSubnetGroupName", valid_773430
  var valid_773431 = query.getOrDefault("HsmClientCertificateIdentifier")
  valid_773431 = validateParameter(valid_773431, JString, required = false,
                                 default = nil)
  if valid_773431 != nil:
    section.add "HsmClientCertificateIdentifier", valid_773431
  var valid_773432 = query.getOrDefault("PreferredMaintenanceWindow")
  valid_773432 = validateParameter(valid_773432, JString, required = false,
                                 default = nil)
  if valid_773432 != nil:
    section.add "PreferredMaintenanceWindow", valid_773432
  var valid_773433 = query.getOrDefault("Encrypted")
  valid_773433 = validateParameter(valid_773433, JBool, required = false, default = nil)
  if valid_773433 != nil:
    section.add "Encrypted", valid_773433
  var valid_773434 = query.getOrDefault("MaintenanceTrackName")
  valid_773434 = validateParameter(valid_773434, JString, required = false,
                                 default = nil)
  if valid_773434 != nil:
    section.add "MaintenanceTrackName", valid_773434
  var valid_773435 = query.getOrDefault("IamRoles")
  valid_773435 = validateParameter(valid_773435, JArray, required = false,
                                 default = nil)
  if valid_773435 != nil:
    section.add "IamRoles", valid_773435
  var valid_773436 = query.getOrDefault("AvailabilityZone")
  valid_773436 = validateParameter(valid_773436, JString, required = false,
                                 default = nil)
  if valid_773436 != nil:
    section.add "AvailabilityZone", valid_773436
  var valid_773437 = query.getOrDefault("MasterUserPassword")
  valid_773437 = validateParameter(valid_773437, JString, required = true,
                                 default = nil)
  if valid_773437 != nil:
    section.add "MasterUserPassword", valid_773437
  var valid_773438 = query.getOrDefault("AllowVersionUpgrade")
  valid_773438 = validateParameter(valid_773438, JBool, required = false, default = nil)
  if valid_773438 != nil:
    section.add "AllowVersionUpgrade", valid_773438
  var valid_773439 = query.getOrDefault("EnhancedVpcRouting")
  valid_773439 = validateParameter(valid_773439, JBool, required = false, default = nil)
  if valid_773439 != nil:
    section.add "EnhancedVpcRouting", valid_773439
  var valid_773440 = query.getOrDefault("VpcSecurityGroupIds")
  valid_773440 = validateParameter(valid_773440, JArray, required = false,
                                 default = nil)
  if valid_773440 != nil:
    section.add "VpcSecurityGroupIds", valid_773440
  var valid_773441 = query.getOrDefault("ClusterParameterGroupName")
  valid_773441 = validateParameter(valid_773441, JString, required = false,
                                 default = nil)
  if valid_773441 != nil:
    section.add "ClusterParameterGroupName", valid_773441
  var valid_773442 = query.getOrDefault("HsmConfigurationIdentifier")
  valid_773442 = validateParameter(valid_773442, JString, required = false,
                                 default = nil)
  if valid_773442 != nil:
    section.add "HsmConfigurationIdentifier", valid_773442
  var valid_773443 = query.getOrDefault("Tags")
  valid_773443 = validateParameter(valid_773443, JArray, required = false,
                                 default = nil)
  if valid_773443 != nil:
    section.add "Tags", valid_773443
  var valid_773444 = query.getOrDefault("DBName")
  valid_773444 = validateParameter(valid_773444, JString, required = false,
                                 default = nil)
  if valid_773444 != nil:
    section.add "DBName", valid_773444
  var valid_773445 = query.getOrDefault("SnapshotScheduleIdentifier")
  valid_773445 = validateParameter(valid_773445, JString, required = false,
                                 default = nil)
  if valid_773445 != nil:
    section.add "SnapshotScheduleIdentifier", valid_773445
  var valid_773446 = query.getOrDefault("AdditionalInfo")
  valid_773446 = validateParameter(valid_773446, JString, required = false,
                                 default = nil)
  if valid_773446 != nil:
    section.add "AdditionalInfo", valid_773446
  var valid_773447 = query.getOrDefault("ElasticIp")
  valid_773447 = validateParameter(valid_773447, JString, required = false,
                                 default = nil)
  if valid_773447 != nil:
    section.add "ElasticIp", valid_773447
  var valid_773448 = query.getOrDefault("ClusterIdentifier")
  valid_773448 = validateParameter(valid_773448, JString, required = true,
                                 default = nil)
  if valid_773448 != nil:
    section.add "ClusterIdentifier", valid_773448
  var valid_773449 = query.getOrDefault("Action")
  valid_773449 = validateParameter(valid_773449, JString, required = true,
                                 default = newJString("CreateCluster"))
  if valid_773449 != nil:
    section.add "Action", valid_773449
  var valid_773450 = query.getOrDefault("KmsKeyId")
  valid_773450 = validateParameter(valid_773450, JString, required = false,
                                 default = nil)
  if valid_773450 != nil:
    section.add "KmsKeyId", valid_773450
  var valid_773451 = query.getOrDefault("PubliclyAccessible")
  valid_773451 = validateParameter(valid_773451, JBool, required = false, default = nil)
  if valid_773451 != nil:
    section.add "PubliclyAccessible", valid_773451
  var valid_773452 = query.getOrDefault("Port")
  valid_773452 = validateParameter(valid_773452, JInt, required = false, default = nil)
  if valid_773452 != nil:
    section.add "Port", valid_773452
  var valid_773453 = query.getOrDefault("NumberOfNodes")
  valid_773453 = validateParameter(valid_773453, JInt, required = false, default = nil)
  if valid_773453 != nil:
    section.add "NumberOfNodes", valid_773453
  var valid_773454 = query.getOrDefault("AutomatedSnapshotRetentionPeriod")
  valid_773454 = validateParameter(valid_773454, JInt, required = false, default = nil)
  if valid_773454 != nil:
    section.add "AutomatedSnapshotRetentionPeriod", valid_773454
  var valid_773455 = query.getOrDefault("NodeType")
  valid_773455 = validateParameter(valid_773455, JString, required = true,
                                 default = nil)
  if valid_773455 != nil:
    section.add "NodeType", valid_773455
  var valid_773456 = query.getOrDefault("ClusterVersion")
  valid_773456 = validateParameter(valid_773456, JString, required = false,
                                 default = nil)
  if valid_773456 != nil:
    section.add "ClusterVersion", valid_773456
  var valid_773457 = query.getOrDefault("Version")
  valid_773457 = validateParameter(valid_773457, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_773457 != nil:
    section.add "Version", valid_773457
  var valid_773458 = query.getOrDefault("ClusterType")
  valid_773458 = validateParameter(valid_773458, JString, required = false,
                                 default = nil)
  if valid_773458 != nil:
    section.add "ClusterType", valid_773458
  var valid_773459 = query.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_773459 = validateParameter(valid_773459, JInt, required = false, default = nil)
  if valid_773459 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_773459
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_773460 = header.getOrDefault("X-Amz-Date")
  valid_773460 = validateParameter(valid_773460, JString, required = false,
                                 default = nil)
  if valid_773460 != nil:
    section.add "X-Amz-Date", valid_773460
  var valid_773461 = header.getOrDefault("X-Amz-Security-Token")
  valid_773461 = validateParameter(valid_773461, JString, required = false,
                                 default = nil)
  if valid_773461 != nil:
    section.add "X-Amz-Security-Token", valid_773461
  var valid_773462 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_773462 = validateParameter(valid_773462, JString, required = false,
                                 default = nil)
  if valid_773462 != nil:
    section.add "X-Amz-Content-Sha256", valid_773462
  var valid_773463 = header.getOrDefault("X-Amz-Algorithm")
  valid_773463 = validateParameter(valid_773463, JString, required = false,
                                 default = nil)
  if valid_773463 != nil:
    section.add "X-Amz-Algorithm", valid_773463
  var valid_773464 = header.getOrDefault("X-Amz-Signature")
  valid_773464 = validateParameter(valid_773464, JString, required = false,
                                 default = nil)
  if valid_773464 != nil:
    section.add "X-Amz-Signature", valid_773464
  var valid_773465 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_773465 = validateParameter(valid_773465, JString, required = false,
                                 default = nil)
  if valid_773465 != nil:
    section.add "X-Amz-SignedHeaders", valid_773465
  var valid_773466 = header.getOrDefault("X-Amz-Credential")
  valid_773466 = validateParameter(valid_773466, JString, required = false,
                                 default = nil)
  if valid_773466 != nil:
    section.add "X-Amz-Credential", valid_773466
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_773467: Call_GetCreateCluster_773425; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a new cluster.</p> <p>To create a cluster in Virtual Private Cloud (VPC), you must provide a cluster subnet group name. The cluster subnet group identifies the subnets of your VPC that Amazon Redshift uses when creating the cluster. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_773467.validator(path, query, header, formData, body)
  let scheme = call_773467.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_773467.url(scheme.get, call_773467.host, call_773467.base,
                         call_773467.route, valid.getOrDefault("path"))
  result = hook(call_773467, url, valid)

proc call*(call_773468: Call_GetCreateCluster_773425; MasterUsername: string;
          MasterUserPassword: string; ClusterIdentifier: string; NodeType: string;
          ClusterSecurityGroups: JsonNode = nil;
          ClusterSubnetGroupName: string = "";
          HsmClientCertificateIdentifier: string = "";
          PreferredMaintenanceWindow: string = ""; Encrypted: bool = false;
          MaintenanceTrackName: string = ""; IamRoles: JsonNode = nil;
          AvailabilityZone: string = ""; AllowVersionUpgrade: bool = false;
          EnhancedVpcRouting: bool = false; VpcSecurityGroupIds: JsonNode = nil;
          ClusterParameterGroupName: string = "";
          HsmConfigurationIdentifier: string = ""; Tags: JsonNode = nil;
          DBName: string = ""; SnapshotScheduleIdentifier: string = "";
          AdditionalInfo: string = ""; ElasticIp: string = "";
          Action: string = "CreateCluster"; KmsKeyId: string = "";
          PubliclyAccessible: bool = false; Port: int = 0; NumberOfNodes: int = 0;
          AutomatedSnapshotRetentionPeriod: int = 0; ClusterVersion: string = "";
          Version: string = "2012-12-01"; ClusterType: string = "";
          ManualSnapshotRetentionPeriod: int = 0): Recallable =
  ## getCreateCluster
  ## <p>Creates a new cluster.</p> <p>To create a cluster in Virtual Private Cloud (VPC), you must provide a cluster subnet group name. The cluster subnet group identifies the subnets of your VPC that Amazon Redshift uses when creating the cluster. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   ClusterSecurityGroups: JArray
  ##                        : <p>A list of security groups to be associated with this cluster.</p> <p>Default: The default cluster security group for Amazon Redshift.</p>
  ##   MasterUsername: string (required)
  ##                 : <p>The user name associated with the master user account for the cluster that is being created.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 - 128 alphanumeric characters. The user name can't be <code>PUBLIC</code>.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide. </p> </li> </ul>
  ##   ClusterSubnetGroupName: string
  ##                         : <p>The name of a cluster subnet group to be associated with this cluster.</p> <p>If this parameter is not provided the resulting cluster will be deployed outside virtual private cloud (VPC).</p>
  ##   HsmClientCertificateIdentifier: string
  ##                                 : Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM.
  ##   PreferredMaintenanceWindow: string
  ##                             : <p>The weekly time range (in UTC) during which automated cluster maintenance can occur.</p> <p> Format: <code>ddd:hh24:mi-ddd:hh24:mi</code> </p> <p> Default: A 30-minute window selected at random from an 8-hour block of time per region, occurring on a random day of the week. For more information about the time blocks for each region, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-maintenance-windows">Maintenance Windows</a> in Amazon Redshift Cluster Management Guide.</p> <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p> <p>Constraints: Minimum 30-minute window.</p>
  ##   Encrypted: bool
  ##            : <p>If <code>true</code>, the data in the cluster is encrypted at rest. </p> <p>Default: false</p>
  ##   MaintenanceTrackName: string
  ##                       : An optional parameter for the name of the maintenance track for the cluster. If you don't provide a maintenance track name, the cluster is assigned to the <code>current</code> track.
  ##   IamRoles: JArray
  ##           : <p>A list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services. You must supply the IAM roles in their Amazon Resource Name (ARN) format. You can supply up to 10 IAM roles in a single request.</p> <p>A cluster can have up to 10 IAM roles associated with it at any time.</p>
  ##   AvailabilityZone: string
  ##                   : <p>The EC2 Availability Zone (AZ) in which you want Amazon Redshift to provision the cluster. For example, if you have several EC2 instances running in a specific Availability Zone, then you might want the cluster to be provisioned in the same zone in order to decrease network latency.</p> <p>Default: A random, system-chosen Availability Zone in the region that is specified by the endpoint.</p> <p>Example: <code>us-east-1d</code> </p> <p>Constraint: The specified Availability Zone must be in the same region as the current endpoint.</p>
  ##   MasterUserPassword: string (required)
  ##                     : <p>The password associated with the master user account for the cluster that is being created.</p> <p>Constraints:</p> <ul> <li> <p>Must be between 8 and 64 characters in length.</p> </li> <li> <p>Must contain at least one uppercase letter.</p> </li> <li> <p>Must contain at least one lowercase letter.</p> </li> <li> <p>Must contain one number.</p> </li> <li> <p>Can be any printable ASCII character (ASCII code 33 to 126) except ' (single quote), " (double quote), \, /, @, or space.</p> </li> </ul>
  ##   AllowVersionUpgrade: bool
  ##                      : <p>If <code>true</code>, major version upgrades can be applied during the maintenance window to the Amazon Redshift engine that is running on the cluster.</p> <p>When a new major version of the Amazon Redshift engine is released, you can request that the service automatically apply upgrades during the maintenance window to the Amazon Redshift engine that is running on your cluster.</p> <p>Default: <code>true</code> </p>
  ##   EnhancedVpcRouting: bool
  ##                     : <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p> <p>Default: false</p>
  ##   VpcSecurityGroupIds: JArray
  ##                      : <p>A list of Virtual Private Cloud (VPC) security groups to be associated with the cluster.</p> <p>Default: The default VPC security group is associated with the cluster.</p>
  ##   ClusterParameterGroupName: string
  ##                            : <p>The name of the parameter group to be associated with this cluster.</p> <p>Default: The default Amazon Redshift cluster parameter group. For information about the default parameter group, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Working with Amazon Redshift Parameter Groups</a> </p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   HsmConfigurationIdentifier: string
  ##                             : Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   DBName: string
  ##         : <p>The name of the first database to be created when the cluster is created.</p> <p>To create additional databases after the cluster is created, connect to the cluster with a SQL client and use SQL commands to create a database. For more information, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/t_creating_database.html">Create a Database</a> in the Amazon Redshift Database Developer Guide. </p> <p>Default: <code>dev</code> </p> <p>Constraints:</p> <ul> <li> <p>Must contain 1 to 64 alphanumeric characters.</p> </li> <li> <p>Must contain only lowercase letters.</p> </li> <li> <p>Cannot be a word that is reserved by the service. A list of reserved words can be found in <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide. </p> </li> </ul>
  ##   SnapshotScheduleIdentifier: string
  ##                             : A unique identifier for the snapshot schedule.
  ##   AdditionalInfo: string
  ##                 : Reserved.
  ##   ElasticIp: string
  ##            : <p>The Elastic IP (EIP) address for the cluster.</p> <p>Constraints: The cluster must be provisioned in EC2-VPC and publicly-accessible through an Internet gateway. For more information about provisioning clusters in EC2-VPC, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#cluster-platforms">Supported Platforms to Launch Your Cluster</a> in the Amazon Redshift Cluster Management Guide.</p>
  ##   ClusterIdentifier: string (required)
  ##                    : <p>A unique identifier for the cluster. You use this identifier to refer to the cluster for any subsequent cluster operations such as deleting or modifying. The identifier also appears in the Amazon Redshift console.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul> <p>Example: <code>myexamplecluster</code> </p>
  ##   Action: string (required)
  ##   KmsKeyId: string
  ##           : The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster.
  ##   PubliclyAccessible: bool
  ##                     : If <code>true</code>, the cluster can be accessed from a public network. 
  ##   Port: int
  ##       : <p>The port number on which the cluster accepts incoming connections.</p> <p>The cluster is accessible only via the JDBC and ODBC connection strings. Part of the connection string requires the port on which the cluster will listen for incoming connections.</p> <p>Default: <code>5439</code> </p> <p>Valid Values: <code>1150-65535</code> </p>
  ##   NumberOfNodes: int
  ##                : <p>The number of compute nodes in the cluster. This parameter is required when the <b>ClusterType</b> parameter is specified as <code>multi-node</code>. </p> <p>For information about determining how many nodes you need, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#how-many-nodes"> Working with Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p> <p>If you don't specify this parameter, you get a single-node cluster. When requesting a multi-node cluster, you must specify the number of nodes that you want in the cluster.</p> <p>Default: <code>1</code> </p> <p>Constraints: Value must be at least 1 and no more than 100.</p>
  ##   AutomatedSnapshotRetentionPeriod: int
  ##                                   : <p>The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p> <p>Default: <code>1</code> </p> <p>Constraints: Must be a value from 0 to 35.</p>
  ##   NodeType: string (required)
  ##           : <p>The node type to be provisioned for the cluster. For information about node types, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#how-many-nodes"> Working with Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p> <p>Valid Values: <code>ds2.xlarge</code> | <code>ds2.8xlarge</code> | <code>ds2.xlarge</code> | <code>ds2.8xlarge</code> | <code>dc1.large</code> | <code>dc1.8xlarge</code> | <code>dc2.large</code> | <code>dc2.8xlarge</code> </p>
  ##   ClusterVersion: string
  ##                 : <p>The version of the Amazon Redshift engine software that you want to deploy on the cluster.</p> <p>The version selected runs on all the nodes in the cluster.</p> <p>Constraints: Only version 1.0 is currently available.</p> <p>Example: <code>1.0</code> </p>
  ##   Version: string (required)
  ##   ClusterType: string
  ##              : <p>The type of the cluster. When cluster type is specified as</p> <ul> <li> <p> <code>single-node</code>, the <b>NumberOfNodes</b> parameter is not required.</p> </li> <li> <p> <code>multi-node</code>, the <b>NumberOfNodes</b> parameter is required.</p> </li> </ul> <p>Valid Values: <code>multi-node</code> | <code>single-node</code> </p> <p>Default: <code>multi-node</code> </p>
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The default number of days to retain a manual snapshot. If the value is -1, the snapshot is retained indefinitely. This setting doesn't change the retention period of existing snapshots.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  var query_773469 = newJObject()
  if ClusterSecurityGroups != nil:
    query_773469.add "ClusterSecurityGroups", ClusterSecurityGroups
  add(query_773469, "MasterUsername", newJString(MasterUsername))
  add(query_773469, "ClusterSubnetGroupName", newJString(ClusterSubnetGroupName))
  add(query_773469, "HsmClientCertificateIdentifier",
      newJString(HsmClientCertificateIdentifier))
  add(query_773469, "PreferredMaintenanceWindow",
      newJString(PreferredMaintenanceWindow))
  add(query_773469, "Encrypted", newJBool(Encrypted))
  add(query_773469, "MaintenanceTrackName", newJString(MaintenanceTrackName))
  if IamRoles != nil:
    query_773469.add "IamRoles", IamRoles
  add(query_773469, "AvailabilityZone", newJString(AvailabilityZone))
  add(query_773469, "MasterUserPassword", newJString(MasterUserPassword))
  add(query_773469, "AllowVersionUpgrade", newJBool(AllowVersionUpgrade))
  add(query_773469, "EnhancedVpcRouting", newJBool(EnhancedVpcRouting))
  if VpcSecurityGroupIds != nil:
    query_773469.add "VpcSecurityGroupIds", VpcSecurityGroupIds
  add(query_773469, "ClusterParameterGroupName",
      newJString(ClusterParameterGroupName))
  add(query_773469, "HsmConfigurationIdentifier",
      newJString(HsmConfigurationIdentifier))
  if Tags != nil:
    query_773469.add "Tags", Tags
  add(query_773469, "DBName", newJString(DBName))
  add(query_773469, "SnapshotScheduleIdentifier",
      newJString(SnapshotScheduleIdentifier))
  add(query_773469, "AdditionalInfo", newJString(AdditionalInfo))
  add(query_773469, "ElasticIp", newJString(ElasticIp))
  add(query_773469, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_773469, "Action", newJString(Action))
  add(query_773469, "KmsKeyId", newJString(KmsKeyId))
  add(query_773469, "PubliclyAccessible", newJBool(PubliclyAccessible))
  add(query_773469, "Port", newJInt(Port))
  add(query_773469, "NumberOfNodes", newJInt(NumberOfNodes))
  add(query_773469, "AutomatedSnapshotRetentionPeriod",
      newJInt(AutomatedSnapshotRetentionPeriod))
  add(query_773469, "NodeType", newJString(NodeType))
  add(query_773469, "ClusterVersion", newJString(ClusterVersion))
  add(query_773469, "Version", newJString(Version))
  add(query_773469, "ClusterType", newJString(ClusterType))
  add(query_773469, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  result = call_773468.call(nil, query_773469, nil, nil, nil)

var getCreateCluster* = Call_GetCreateCluster_773425(name: "getCreateCluster",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=CreateCluster", validator: validate_GetCreateCluster_773426,
    base: "/", url: url_GetCreateCluster_773427,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCreateClusterParameterGroup_773535 = ref object of OpenApiRestCall_772581
proc url_PostCreateClusterParameterGroup_773537(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_PostCreateClusterParameterGroup_773536(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates an Amazon Redshift parameter group.</p> <p>Creating parameter groups is independent of creating clusters. You can associate a cluster with a parameter group when you create the cluster. You can also associate an existing cluster with a parameter group after the cluster is created by using <a>ModifyCluster</a>. </p> <p>Parameters in the parameter group define specific behavior that applies to the databases you create on the cluster. For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_773538 = query.getOrDefault("Action")
  valid_773538 = validateParameter(valid_773538, JString, required = true, default = newJString(
      "CreateClusterParameterGroup"))
  if valid_773538 != nil:
    section.add "Action", valid_773538
  var valid_773539 = query.getOrDefault("Version")
  valid_773539 = validateParameter(valid_773539, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_773539 != nil:
    section.add "Version", valid_773539
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_773540 = header.getOrDefault("X-Amz-Date")
  valid_773540 = validateParameter(valid_773540, JString, required = false,
                                 default = nil)
  if valid_773540 != nil:
    section.add "X-Amz-Date", valid_773540
  var valid_773541 = header.getOrDefault("X-Amz-Security-Token")
  valid_773541 = validateParameter(valid_773541, JString, required = false,
                                 default = nil)
  if valid_773541 != nil:
    section.add "X-Amz-Security-Token", valid_773541
  var valid_773542 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_773542 = validateParameter(valid_773542, JString, required = false,
                                 default = nil)
  if valid_773542 != nil:
    section.add "X-Amz-Content-Sha256", valid_773542
  var valid_773543 = header.getOrDefault("X-Amz-Algorithm")
  valid_773543 = validateParameter(valid_773543, JString, required = false,
                                 default = nil)
  if valid_773543 != nil:
    section.add "X-Amz-Algorithm", valid_773543
  var valid_773544 = header.getOrDefault("X-Amz-Signature")
  valid_773544 = validateParameter(valid_773544, JString, required = false,
                                 default = nil)
  if valid_773544 != nil:
    section.add "X-Amz-Signature", valid_773544
  var valid_773545 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_773545 = validateParameter(valid_773545, JString, required = false,
                                 default = nil)
  if valid_773545 != nil:
    section.add "X-Amz-SignedHeaders", valid_773545
  var valid_773546 = header.getOrDefault("X-Amz-Credential")
  valid_773546 = validateParameter(valid_773546, JString, required = false,
                                 default = nil)
  if valid_773546 != nil:
    section.add "X-Amz-Credential", valid_773546
  result.add "header", section
  ## parameters in `formData` object:
  ##   ParameterGroupName: JString (required)
  ##                     : <p>The name of the cluster parameter group.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique withing your AWS account.</p> </li> </ul> <note> <p>This value is stored as a lower-case string.</p> </note>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   ParameterGroupFamily: JString (required)
  ##                       : <p>The Amazon Redshift engine version to which the cluster parameter group applies. The cluster engine version determines the set of parameters.</p> <p>To get a list of valid parameter group family names, you can call <a>DescribeClusterParameterGroups</a>. By default, Amazon Redshift returns a list of all the parameter groups that are owned by your AWS account, including the default parameter groups for each Amazon Redshift engine version. The parameter group family names associated with the default parameter groups provide you the valid values. For example, a valid family name is "redshift-1.0". </p>
  ##   Description: JString (required)
  ##              : A description of the parameter group.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ParameterGroupName` field"
  var valid_773547 = formData.getOrDefault("ParameterGroupName")
  valid_773547 = validateParameter(valid_773547, JString, required = true,
                                 default = nil)
  if valid_773547 != nil:
    section.add "ParameterGroupName", valid_773547
  var valid_773548 = formData.getOrDefault("Tags")
  valid_773548 = validateParameter(valid_773548, JArray, required = false,
                                 default = nil)
  if valid_773548 != nil:
    section.add "Tags", valid_773548
  var valid_773549 = formData.getOrDefault("ParameterGroupFamily")
  valid_773549 = validateParameter(valid_773549, JString, required = true,
                                 default = nil)
  if valid_773549 != nil:
    section.add "ParameterGroupFamily", valid_773549
  var valid_773550 = formData.getOrDefault("Description")
  valid_773550 = validateParameter(valid_773550, JString, required = true,
                                 default = nil)
  if valid_773550 != nil:
    section.add "Description", valid_773550
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_773551: Call_PostCreateClusterParameterGroup_773535;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Creates an Amazon Redshift parameter group.</p> <p>Creating parameter groups is independent of creating clusters. You can associate a cluster with a parameter group when you create the cluster. You can also associate an existing cluster with a parameter group after the cluster is created by using <a>ModifyCluster</a>. </p> <p>Parameters in the parameter group define specific behavior that applies to the databases you create on the cluster. For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_773551.validator(path, query, header, formData, body)
  let scheme = call_773551.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_773551.url(scheme.get, call_773551.host, call_773551.base,
                         call_773551.route, valid.getOrDefault("path"))
  result = hook(call_773551, url, valid)

proc call*(call_773552: Call_PostCreateClusterParameterGroup_773535;
          ParameterGroupName: string; ParameterGroupFamily: string;
          Description: string; Tags: JsonNode = nil;
          Action: string = "CreateClusterParameterGroup";
          Version: string = "2012-12-01"): Recallable =
  ## postCreateClusterParameterGroup
  ## <p>Creates an Amazon Redshift parameter group.</p> <p>Creating parameter groups is independent of creating clusters. You can associate a cluster with a parameter group when you create the cluster. You can also associate an existing cluster with a parameter group after the cluster is created by using <a>ModifyCluster</a>. </p> <p>Parameters in the parameter group define specific behavior that applies to the databases you create on the cluster. For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   ParameterGroupName: string (required)
  ##                     : <p>The name of the cluster parameter group.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique withing your AWS account.</p> </li> </ul> <note> <p>This value is stored as a lower-case string.</p> </note>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Action: string (required)
  ##   ParameterGroupFamily: string (required)
  ##                       : <p>The Amazon Redshift engine version to which the cluster parameter group applies. The cluster engine version determines the set of parameters.</p> <p>To get a list of valid parameter group family names, you can call <a>DescribeClusterParameterGroups</a>. By default, Amazon Redshift returns a list of all the parameter groups that are owned by your AWS account, including the default parameter groups for each Amazon Redshift engine version. The parameter group family names associated with the default parameter groups provide you the valid values. For example, a valid family name is "redshift-1.0". </p>
  ##   Version: string (required)
  ##   Description: string (required)
  ##              : A description of the parameter group.
  var query_773553 = newJObject()
  var formData_773554 = newJObject()
  add(formData_773554, "ParameterGroupName", newJString(ParameterGroupName))
  if Tags != nil:
    formData_773554.add "Tags", Tags
  add(query_773553, "Action", newJString(Action))
  add(formData_773554, "ParameterGroupFamily", newJString(ParameterGroupFamily))
  add(query_773553, "Version", newJString(Version))
  add(formData_773554, "Description", newJString(Description))
  result = call_773552.call(nil, query_773553, nil, formData_773554, nil)

var postCreateClusterParameterGroup* = Call_PostCreateClusterParameterGroup_773535(
    name: "postCreateClusterParameterGroup", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=CreateClusterParameterGroup",
    validator: validate_PostCreateClusterParameterGroup_773536, base: "/",
    url: url_PostCreateClusterParameterGroup_773537,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCreateClusterParameterGroup_773516 = ref object of OpenApiRestCall_772581
proc url_GetCreateClusterParameterGroup_773518(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_GetCreateClusterParameterGroup_773517(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates an Amazon Redshift parameter group.</p> <p>Creating parameter groups is independent of creating clusters. You can associate a cluster with a parameter group when you create the cluster. You can also associate an existing cluster with a parameter group after the cluster is created by using <a>ModifyCluster</a>. </p> <p>Parameters in the parameter group define specific behavior that applies to the databases you create on the cluster. For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Description: JString (required)
  ##              : A description of the parameter group.
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   ParameterGroupName: JString (required)
  ##                     : <p>The name of the cluster parameter group.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique withing your AWS account.</p> </li> </ul> <note> <p>This value is stored as a lower-case string.</p> </note>
  ##   Action: JString (required)
  ##   ParameterGroupFamily: JString (required)
  ##                       : <p>The Amazon Redshift engine version to which the cluster parameter group applies. The cluster engine version determines the set of parameters.</p> <p>To get a list of valid parameter group family names, you can call <a>DescribeClusterParameterGroups</a>. By default, Amazon Redshift returns a list of all the parameter groups that are owned by your AWS account, including the default parameter groups for each Amazon Redshift engine version. The parameter group family names associated with the default parameter groups provide you the valid values. For example, a valid family name is "redshift-1.0". </p>
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `Description` field"
  var valid_773519 = query.getOrDefault("Description")
  valid_773519 = validateParameter(valid_773519, JString, required = true,
                                 default = nil)
  if valid_773519 != nil:
    section.add "Description", valid_773519
  var valid_773520 = query.getOrDefault("Tags")
  valid_773520 = validateParameter(valid_773520, JArray, required = false,
                                 default = nil)
  if valid_773520 != nil:
    section.add "Tags", valid_773520
  var valid_773521 = query.getOrDefault("ParameterGroupName")
  valid_773521 = validateParameter(valid_773521, JString, required = true,
                                 default = nil)
  if valid_773521 != nil:
    section.add "ParameterGroupName", valid_773521
  var valid_773522 = query.getOrDefault("Action")
  valid_773522 = validateParameter(valid_773522, JString, required = true, default = newJString(
      "CreateClusterParameterGroup"))
  if valid_773522 != nil:
    section.add "Action", valid_773522
  var valid_773523 = query.getOrDefault("ParameterGroupFamily")
  valid_773523 = validateParameter(valid_773523, JString, required = true,
                                 default = nil)
  if valid_773523 != nil:
    section.add "ParameterGroupFamily", valid_773523
  var valid_773524 = query.getOrDefault("Version")
  valid_773524 = validateParameter(valid_773524, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_773524 != nil:
    section.add "Version", valid_773524
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_773525 = header.getOrDefault("X-Amz-Date")
  valid_773525 = validateParameter(valid_773525, JString, required = false,
                                 default = nil)
  if valid_773525 != nil:
    section.add "X-Amz-Date", valid_773525
  var valid_773526 = header.getOrDefault("X-Amz-Security-Token")
  valid_773526 = validateParameter(valid_773526, JString, required = false,
                                 default = nil)
  if valid_773526 != nil:
    section.add "X-Amz-Security-Token", valid_773526
  var valid_773527 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_773527 = validateParameter(valid_773527, JString, required = false,
                                 default = nil)
  if valid_773527 != nil:
    section.add "X-Amz-Content-Sha256", valid_773527
  var valid_773528 = header.getOrDefault("X-Amz-Algorithm")
  valid_773528 = validateParameter(valid_773528, JString, required = false,
                                 default = nil)
  if valid_773528 != nil:
    section.add "X-Amz-Algorithm", valid_773528
  var valid_773529 = header.getOrDefault("X-Amz-Signature")
  valid_773529 = validateParameter(valid_773529, JString, required = false,
                                 default = nil)
  if valid_773529 != nil:
    section.add "X-Amz-Signature", valid_773529
  var valid_773530 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_773530 = validateParameter(valid_773530, JString, required = false,
                                 default = nil)
  if valid_773530 != nil:
    section.add "X-Amz-SignedHeaders", valid_773530
  var valid_773531 = header.getOrDefault("X-Amz-Credential")
  valid_773531 = validateParameter(valid_773531, JString, required = false,
                                 default = nil)
  if valid_773531 != nil:
    section.add "X-Amz-Credential", valid_773531
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_773532: Call_GetCreateClusterParameterGroup_773516; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates an Amazon Redshift parameter group.</p> <p>Creating parameter groups is independent of creating clusters. You can associate a cluster with a parameter group when you create the cluster. You can also associate an existing cluster with a parameter group after the cluster is created by using <a>ModifyCluster</a>. </p> <p>Parameters in the parameter group define specific behavior that applies to the databases you create on the cluster. For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_773532.validator(path, query, header, formData, body)
  let scheme = call_773532.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_773532.url(scheme.get, call_773532.host, call_773532.base,
                         call_773532.route, valid.getOrDefault("path"))
  result = hook(call_773532, url, valid)

proc call*(call_773533: Call_GetCreateClusterParameterGroup_773516;
          Description: string; ParameterGroupName: string;
          ParameterGroupFamily: string; Tags: JsonNode = nil;
          Action: string = "CreateClusterParameterGroup";
          Version: string = "2012-12-01"): Recallable =
  ## getCreateClusterParameterGroup
  ## <p>Creates an Amazon Redshift parameter group.</p> <p>Creating parameter groups is independent of creating clusters. You can associate a cluster with a parameter group when you create the cluster. You can also associate an existing cluster with a parameter group after the cluster is created by using <a>ModifyCluster</a>. </p> <p>Parameters in the parameter group define specific behavior that applies to the databases you create on the cluster. For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   Description: string (required)
  ##              : A description of the parameter group.
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   ParameterGroupName: string (required)
  ##                     : <p>The name of the cluster parameter group.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique withing your AWS account.</p> </li> </ul> <note> <p>This value is stored as a lower-case string.</p> </note>
  ##   Action: string (required)
  ##   ParameterGroupFamily: string (required)
  ##                       : <p>The Amazon Redshift engine version to which the cluster parameter group applies. The cluster engine version determines the set of parameters.</p> <p>To get a list of valid parameter group family names, you can call <a>DescribeClusterParameterGroups</a>. By default, Amazon Redshift returns a list of all the parameter groups that are owned by your AWS account, including the default parameter groups for each Amazon Redshift engine version. The parameter group family names associated with the default parameter groups provide you the valid values. For example, a valid family name is "redshift-1.0". </p>
  ##   Version: string (required)
  var query_773534 = newJObject()
  add(query_773534, "Description", newJString(Description))
  if Tags != nil:
    query_773534.add "Tags", Tags
  add(query_773534, "ParameterGroupName", newJString(ParameterGroupName))
  add(query_773534, "Action", newJString(Action))
  add(query_773534, "ParameterGroupFamily", newJString(ParameterGroupFamily))
  add(query_773534, "Version", newJString(Version))
  result = call_773533.call(nil, query_773534, nil, nil, nil)

var getCreateClusterParameterGroup* = Call_GetCreateClusterParameterGroup_773516(
    name: "getCreateClusterParameterGroup", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=CreateClusterParameterGroup",
    validator: validate_GetCreateClusterParameterGroup_773517, base: "/",
    url: url_GetCreateClusterParameterGroup_773518,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCreateClusterSecurityGroup_773573 = ref object of OpenApiRestCall_772581
proc url_PostCreateClusterSecurityGroup_773575(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_PostCreateClusterSecurityGroup_773574(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a new Amazon Redshift security group. You use security groups to control access to non-VPC clusters.</p> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_773576 = query.getOrDefault("Action")
  valid_773576 = validateParameter(valid_773576, JString, required = true, default = newJString(
      "CreateClusterSecurityGroup"))
  if valid_773576 != nil:
    section.add "Action", valid_773576
  var valid_773577 = query.getOrDefault("Version")
  valid_773577 = validateParameter(valid_773577, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_773577 != nil:
    section.add "Version", valid_773577
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_773578 = header.getOrDefault("X-Amz-Date")
  valid_773578 = validateParameter(valid_773578, JString, required = false,
                                 default = nil)
  if valid_773578 != nil:
    section.add "X-Amz-Date", valid_773578
  var valid_773579 = header.getOrDefault("X-Amz-Security-Token")
  valid_773579 = validateParameter(valid_773579, JString, required = false,
                                 default = nil)
  if valid_773579 != nil:
    section.add "X-Amz-Security-Token", valid_773579
  var valid_773580 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_773580 = validateParameter(valid_773580, JString, required = false,
                                 default = nil)
  if valid_773580 != nil:
    section.add "X-Amz-Content-Sha256", valid_773580
  var valid_773581 = header.getOrDefault("X-Amz-Algorithm")
  valid_773581 = validateParameter(valid_773581, JString, required = false,
                                 default = nil)
  if valid_773581 != nil:
    section.add "X-Amz-Algorithm", valid_773581
  var valid_773582 = header.getOrDefault("X-Amz-Signature")
  valid_773582 = validateParameter(valid_773582, JString, required = false,
                                 default = nil)
  if valid_773582 != nil:
    section.add "X-Amz-Signature", valid_773582
  var valid_773583 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_773583 = validateParameter(valid_773583, JString, required = false,
                                 default = nil)
  if valid_773583 != nil:
    section.add "X-Amz-SignedHeaders", valid_773583
  var valid_773584 = header.getOrDefault("X-Amz-Credential")
  valid_773584 = validateParameter(valid_773584, JString, required = false,
                                 default = nil)
  if valid_773584 != nil:
    section.add "X-Amz-Credential", valid_773584
  result.add "header", section
  ## parameters in `formData` object:
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Description: JString (required)
  ##              : A description for the security group.
  ##   ClusterSecurityGroupName: JString (required)
  ##                           : <p>The name for the security group. Amazon Redshift stores the value as a lowercase string.</p> <p>Constraints:</p> <ul> <li> <p>Must contain no more than 255 alphanumeric characters or hyphens.</p> </li> <li> <p>Must not be "Default".</p> </li> <li> <p>Must be unique for all security groups that are created by your AWS account.</p> </li> </ul> <p>Example: <code>examplesecuritygroup</code> </p>
  section = newJObject()
  var valid_773585 = formData.getOrDefault("Tags")
  valid_773585 = validateParameter(valid_773585, JArray, required = false,
                                 default = nil)
  if valid_773585 != nil:
    section.add "Tags", valid_773585
  assert formData != nil,
        "formData argument is necessary due to required `Description` field"
  var valid_773586 = formData.getOrDefault("Description")
  valid_773586 = validateParameter(valid_773586, JString, required = true,
                                 default = nil)
  if valid_773586 != nil:
    section.add "Description", valid_773586
  var valid_773587 = formData.getOrDefault("ClusterSecurityGroupName")
  valid_773587 = validateParameter(valid_773587, JString, required = true,
                                 default = nil)
  if valid_773587 != nil:
    section.add "ClusterSecurityGroupName", valid_773587
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_773588: Call_PostCreateClusterSecurityGroup_773573; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a new Amazon Redshift security group. You use security groups to control access to non-VPC clusters.</p> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_773588.validator(path, query, header, formData, body)
  let scheme = call_773588.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_773588.url(scheme.get, call_773588.host, call_773588.base,
                         call_773588.route, valid.getOrDefault("path"))
  result = hook(call_773588, url, valid)

proc call*(call_773589: Call_PostCreateClusterSecurityGroup_773573;
          Description: string; ClusterSecurityGroupName: string;
          Tags: JsonNode = nil; Action: string = "CreateClusterSecurityGroup";
          Version: string = "2012-12-01"): Recallable =
  ## postCreateClusterSecurityGroup
  ## <p>Creates a new Amazon Redshift security group. You use security groups to control access to non-VPC clusters.</p> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   Description: string (required)
  ##              : A description for the security group.
  ##   ClusterSecurityGroupName: string (required)
  ##                           : <p>The name for the security group. Amazon Redshift stores the value as a lowercase string.</p> <p>Constraints:</p> <ul> <li> <p>Must contain no more than 255 alphanumeric characters or hyphens.</p> </li> <li> <p>Must not be "Default".</p> </li> <li> <p>Must be unique for all security groups that are created by your AWS account.</p> </li> </ul> <p>Example: <code>examplesecuritygroup</code> </p>
  var query_773590 = newJObject()
  var formData_773591 = newJObject()
  if Tags != nil:
    formData_773591.add "Tags", Tags
  add(query_773590, "Action", newJString(Action))
  add(query_773590, "Version", newJString(Version))
  add(formData_773591, "Description", newJString(Description))
  add(formData_773591, "ClusterSecurityGroupName",
      newJString(ClusterSecurityGroupName))
  result = call_773589.call(nil, query_773590, nil, formData_773591, nil)

var postCreateClusterSecurityGroup* = Call_PostCreateClusterSecurityGroup_773573(
    name: "postCreateClusterSecurityGroup", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=CreateClusterSecurityGroup",
    validator: validate_PostCreateClusterSecurityGroup_773574, base: "/",
    url: url_PostCreateClusterSecurityGroup_773575,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCreateClusterSecurityGroup_773555 = ref object of OpenApiRestCall_772581
proc url_GetCreateClusterSecurityGroup_773557(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_GetCreateClusterSecurityGroup_773556(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a new Amazon Redshift security group. You use security groups to control access to non-VPC clusters.</p> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ClusterSecurityGroupName: JString (required)
  ##                           : <p>The name for the security group. Amazon Redshift stores the value as a lowercase string.</p> <p>Constraints:</p> <ul> <li> <p>Must contain no more than 255 alphanumeric characters or hyphens.</p> </li> <li> <p>Must not be "Default".</p> </li> <li> <p>Must be unique for all security groups that are created by your AWS account.</p> </li> </ul> <p>Example: <code>examplesecuritygroup</code> </p>
  ##   Description: JString (required)
  ##              : A description for the security group.
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `ClusterSecurityGroupName` field"
  var valid_773558 = query.getOrDefault("ClusterSecurityGroupName")
  valid_773558 = validateParameter(valid_773558, JString, required = true,
                                 default = nil)
  if valid_773558 != nil:
    section.add "ClusterSecurityGroupName", valid_773558
  var valid_773559 = query.getOrDefault("Description")
  valid_773559 = validateParameter(valid_773559, JString, required = true,
                                 default = nil)
  if valid_773559 != nil:
    section.add "Description", valid_773559
  var valid_773560 = query.getOrDefault("Tags")
  valid_773560 = validateParameter(valid_773560, JArray, required = false,
                                 default = nil)
  if valid_773560 != nil:
    section.add "Tags", valid_773560
  var valid_773561 = query.getOrDefault("Action")
  valid_773561 = validateParameter(valid_773561, JString, required = true, default = newJString(
      "CreateClusterSecurityGroup"))
  if valid_773561 != nil:
    section.add "Action", valid_773561
  var valid_773562 = query.getOrDefault("Version")
  valid_773562 = validateParameter(valid_773562, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_773562 != nil:
    section.add "Version", valid_773562
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_773563 = header.getOrDefault("X-Amz-Date")
  valid_773563 = validateParameter(valid_773563, JString, required = false,
                                 default = nil)
  if valid_773563 != nil:
    section.add "X-Amz-Date", valid_773563
  var valid_773564 = header.getOrDefault("X-Amz-Security-Token")
  valid_773564 = validateParameter(valid_773564, JString, required = false,
                                 default = nil)
  if valid_773564 != nil:
    section.add "X-Amz-Security-Token", valid_773564
  var valid_773565 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_773565 = validateParameter(valid_773565, JString, required = false,
                                 default = nil)
  if valid_773565 != nil:
    section.add "X-Amz-Content-Sha256", valid_773565
  var valid_773566 = header.getOrDefault("X-Amz-Algorithm")
  valid_773566 = validateParameter(valid_773566, JString, required = false,
                                 default = nil)
  if valid_773566 != nil:
    section.add "X-Amz-Algorithm", valid_773566
  var valid_773567 = header.getOrDefault("X-Amz-Signature")
  valid_773567 = validateParameter(valid_773567, JString, required = false,
                                 default = nil)
  if valid_773567 != nil:
    section.add "X-Amz-Signature", valid_773567
  var valid_773568 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_773568 = validateParameter(valid_773568, JString, required = false,
                                 default = nil)
  if valid_773568 != nil:
    section.add "X-Amz-SignedHeaders", valid_773568
  var valid_773569 = header.getOrDefault("X-Amz-Credential")
  valid_773569 = validateParameter(valid_773569, JString, required = false,
                                 default = nil)
  if valid_773569 != nil:
    section.add "X-Amz-Credential", valid_773569
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_773570: Call_GetCreateClusterSecurityGroup_773555; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a new Amazon Redshift security group. You use security groups to control access to non-VPC clusters.</p> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_773570.validator(path, query, header, formData, body)
  let scheme = call_773570.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_773570.url(scheme.get, call_773570.host, call_773570.base,
                         call_773570.route, valid.getOrDefault("path"))
  result = hook(call_773570, url, valid)

proc call*(call_773571: Call_GetCreateClusterSecurityGroup_773555;
          ClusterSecurityGroupName: string; Description: string;
          Tags: JsonNode = nil; Action: string = "CreateClusterSecurityGroup";
          Version: string = "2012-12-01"): Recallable =
  ## getCreateClusterSecurityGroup
  ## <p>Creates a new Amazon Redshift security group. You use security groups to control access to non-VPC clusters.</p> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   ClusterSecurityGroupName: string (required)
  ##                           : <p>The name for the security group. Amazon Redshift stores the value as a lowercase string.</p> <p>Constraints:</p> <ul> <li> <p>Must contain no more than 255 alphanumeric characters or hyphens.</p> </li> <li> <p>Must not be "Default".</p> </li> <li> <p>Must be unique for all security groups that are created by your AWS account.</p> </li> </ul> <p>Example: <code>examplesecuritygroup</code> </p>
  ##   Description: string (required)
  ##              : A description for the security group.
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_773572 = newJObject()
  add(query_773572, "ClusterSecurityGroupName",
      newJString(ClusterSecurityGroupName))
  add(query_773572, "Description", newJString(Description))
  if Tags != nil:
    query_773572.add "Tags", Tags
  add(query_773572, "Action", newJString(Action))
  add(query_773572, "Version", newJString(Version))
  result = call_773571.call(nil, query_773572, nil, nil, nil)

var getCreateClusterSecurityGroup* = Call_GetCreateClusterSecurityGroup_773555(
    name: "getCreateClusterSecurityGroup", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=CreateClusterSecurityGroup",
    validator: validate_GetCreateClusterSecurityGroup_773556, base: "/",
    url: url_GetCreateClusterSecurityGroup_773557,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCreateClusterSnapshot_773611 = ref object of OpenApiRestCall_772581
proc url_PostCreateClusterSnapshot_773613(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_PostCreateClusterSnapshot_773612(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a manual snapshot of the specified cluster. The cluster must be in the <code>available</code> state. </p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_773614 = query.getOrDefault("Action")
  valid_773614 = validateParameter(valid_773614, JString, required = true,
                                 default = newJString("CreateClusterSnapshot"))
  if valid_773614 != nil:
    section.add "Action", valid_773614
  var valid_773615 = query.getOrDefault("Version")
  valid_773615 = validateParameter(valid_773615, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_773615 != nil:
    section.add "Version", valid_773615
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_773616 = header.getOrDefault("X-Amz-Date")
  valid_773616 = validateParameter(valid_773616, JString, required = false,
                                 default = nil)
  if valid_773616 != nil:
    section.add "X-Amz-Date", valid_773616
  var valid_773617 = header.getOrDefault("X-Amz-Security-Token")
  valid_773617 = validateParameter(valid_773617, JString, required = false,
                                 default = nil)
  if valid_773617 != nil:
    section.add "X-Amz-Security-Token", valid_773617
  var valid_773618 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_773618 = validateParameter(valid_773618, JString, required = false,
                                 default = nil)
  if valid_773618 != nil:
    section.add "X-Amz-Content-Sha256", valid_773618
  var valid_773619 = header.getOrDefault("X-Amz-Algorithm")
  valid_773619 = validateParameter(valid_773619, JString, required = false,
                                 default = nil)
  if valid_773619 != nil:
    section.add "X-Amz-Algorithm", valid_773619
  var valid_773620 = header.getOrDefault("X-Amz-Signature")
  valid_773620 = validateParameter(valid_773620, JString, required = false,
                                 default = nil)
  if valid_773620 != nil:
    section.add "X-Amz-Signature", valid_773620
  var valid_773621 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_773621 = validateParameter(valid_773621, JString, required = false,
                                 default = nil)
  if valid_773621 != nil:
    section.add "X-Amz-SignedHeaders", valid_773621
  var valid_773622 = header.getOrDefault("X-Amz-Credential")
  valid_773622 = validateParameter(valid_773622, JString, required = false,
                                 default = nil)
  if valid_773622 != nil:
    section.add "X-Amz-Credential", valid_773622
  result.add "header", section
  ## parameters in `formData` object:
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   ClusterIdentifier: JString (required)
  ##                    : The cluster identifier for which you want a snapshot.
  ##   SnapshotIdentifier: JString (required)
  ##                     : <p>A unique identifier for the snapshot that you are requesting. This identifier must be unique for all snapshots within the AWS account.</p> <p>Constraints:</p> <ul> <li> <p>Cannot be null, empty, or blank</p> </li> <li> <p>Must contain from 1 to 255 alphanumeric characters or hyphens</p> </li> <li> <p>First character must be a letter</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens</p> </li> </ul> <p>Example: <code>my-snapshot-id</code> </p>
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. </p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  section = newJObject()
  var valid_773623 = formData.getOrDefault("Tags")
  valid_773623 = validateParameter(valid_773623, JArray, required = false,
                                 default = nil)
  if valid_773623 != nil:
    section.add "Tags", valid_773623
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_773624 = formData.getOrDefault("ClusterIdentifier")
  valid_773624 = validateParameter(valid_773624, JString, required = true,
                                 default = nil)
  if valid_773624 != nil:
    section.add "ClusterIdentifier", valid_773624
  var valid_773625 = formData.getOrDefault("SnapshotIdentifier")
  valid_773625 = validateParameter(valid_773625, JString, required = true,
                                 default = nil)
  if valid_773625 != nil:
    section.add "SnapshotIdentifier", valid_773625
  var valid_773626 = formData.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_773626 = validateParameter(valid_773626, JInt, required = false, default = nil)
  if valid_773626 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_773626
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_773627: Call_PostCreateClusterSnapshot_773611; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a manual snapshot of the specified cluster. The cluster must be in the <code>available</code> state. </p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_773627.validator(path, query, header, formData, body)
  let scheme = call_773627.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_773627.url(scheme.get, call_773627.host, call_773627.base,
                         call_773627.route, valid.getOrDefault("path"))
  result = hook(call_773627, url, valid)

proc call*(call_773628: Call_PostCreateClusterSnapshot_773611;
          ClusterIdentifier: string; SnapshotIdentifier: string;
          Tags: JsonNode = nil; Action: string = "CreateClusterSnapshot";
          ManualSnapshotRetentionPeriod: int = 0; Version: string = "2012-12-01"): Recallable =
  ## postCreateClusterSnapshot
  ## <p>Creates a manual snapshot of the specified cluster. The cluster must be in the <code>available</code> state. </p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : The cluster identifier for which you want a snapshot.
  ##   SnapshotIdentifier: string (required)
  ##                     : <p>A unique identifier for the snapshot that you are requesting. This identifier must be unique for all snapshots within the AWS account.</p> <p>Constraints:</p> <ul> <li> <p>Cannot be null, empty, or blank</p> </li> <li> <p>Must contain from 1 to 255 alphanumeric characters or hyphens</p> </li> <li> <p>First character must be a letter</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens</p> </li> </ul> <p>Example: <code>my-snapshot-id</code> </p>
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. </p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  ##   Version: string (required)
  var query_773629 = newJObject()
  var formData_773630 = newJObject()
  if Tags != nil:
    formData_773630.add "Tags", Tags
  add(query_773629, "Action", newJString(Action))
  add(formData_773630, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_773630, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(formData_773630, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  add(query_773629, "Version", newJString(Version))
  result = call_773628.call(nil, query_773629, nil, formData_773630, nil)

var postCreateClusterSnapshot* = Call_PostCreateClusterSnapshot_773611(
    name: "postCreateClusterSnapshot", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=CreateClusterSnapshot",
    validator: validate_PostCreateClusterSnapshot_773612, base: "/",
    url: url_PostCreateClusterSnapshot_773613,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCreateClusterSnapshot_773592 = ref object of OpenApiRestCall_772581
proc url_GetCreateClusterSnapshot_773594(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_GetCreateClusterSnapshot_773593(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a manual snapshot of the specified cluster. The cluster must be in the <code>available</code> state. </p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : The cluster identifier for which you want a snapshot.
  ##   SnapshotIdentifier: JString (required)
  ##                     : <p>A unique identifier for the snapshot that you are requesting. This identifier must be unique for all snapshots within the AWS account.</p> <p>Constraints:</p> <ul> <li> <p>Cannot be null, empty, or blank</p> </li> <li> <p>Must contain from 1 to 255 alphanumeric characters or hyphens</p> </li> <li> <p>First character must be a letter</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens</p> </li> </ul> <p>Example: <code>my-snapshot-id</code> </p>
  ##   Version: JString (required)
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. </p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  section = newJObject()
  var valid_773595 = query.getOrDefault("Tags")
  valid_773595 = validateParameter(valid_773595, JArray, required = false,
                                 default = nil)
  if valid_773595 != nil:
    section.add "Tags", valid_773595
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_773596 = query.getOrDefault("Action")
  valid_773596 = validateParameter(valid_773596, JString, required = true,
                                 default = newJString("CreateClusterSnapshot"))
  if valid_773596 != nil:
    section.add "Action", valid_773596
  var valid_773597 = query.getOrDefault("ClusterIdentifier")
  valid_773597 = validateParameter(valid_773597, JString, required = true,
                                 default = nil)
  if valid_773597 != nil:
    section.add "ClusterIdentifier", valid_773597
  var valid_773598 = query.getOrDefault("SnapshotIdentifier")
  valid_773598 = validateParameter(valid_773598, JString, required = true,
                                 default = nil)
  if valid_773598 != nil:
    section.add "SnapshotIdentifier", valid_773598
  var valid_773599 = query.getOrDefault("Version")
  valid_773599 = validateParameter(valid_773599, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_773599 != nil:
    section.add "Version", valid_773599
  var valid_773600 = query.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_773600 = validateParameter(valid_773600, JInt, required = false, default = nil)
  if valid_773600 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_773600
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_773601 = header.getOrDefault("X-Amz-Date")
  valid_773601 = validateParameter(valid_773601, JString, required = false,
                                 default = nil)
  if valid_773601 != nil:
    section.add "X-Amz-Date", valid_773601
  var valid_773602 = header.getOrDefault("X-Amz-Security-Token")
  valid_773602 = validateParameter(valid_773602, JString, required = false,
                                 default = nil)
  if valid_773602 != nil:
    section.add "X-Amz-Security-Token", valid_773602
  var valid_773603 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_773603 = validateParameter(valid_773603, JString, required = false,
                                 default = nil)
  if valid_773603 != nil:
    section.add "X-Amz-Content-Sha256", valid_773603
  var valid_773604 = header.getOrDefault("X-Amz-Algorithm")
  valid_773604 = validateParameter(valid_773604, JString, required = false,
                                 default = nil)
  if valid_773604 != nil:
    section.add "X-Amz-Algorithm", valid_773604
  var valid_773605 = header.getOrDefault("X-Amz-Signature")
  valid_773605 = validateParameter(valid_773605, JString, required = false,
                                 default = nil)
  if valid_773605 != nil:
    section.add "X-Amz-Signature", valid_773605
  var valid_773606 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_773606 = validateParameter(valid_773606, JString, required = false,
                                 default = nil)
  if valid_773606 != nil:
    section.add "X-Amz-SignedHeaders", valid_773606
  var valid_773607 = header.getOrDefault("X-Amz-Credential")
  valid_773607 = validateParameter(valid_773607, JString, required = false,
                                 default = nil)
  if valid_773607 != nil:
    section.add "X-Amz-Credential", valid_773607
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_773608: Call_GetCreateClusterSnapshot_773592; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a manual snapshot of the specified cluster. The cluster must be in the <code>available</code> state. </p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_773608.validator(path, query, header, formData, body)
  let scheme = call_773608.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_773608.url(scheme.get, call_773608.host, call_773608.base,
                         call_773608.route, valid.getOrDefault("path"))
  result = hook(call_773608, url, valid)

proc call*(call_773609: Call_GetCreateClusterSnapshot_773592;
          ClusterIdentifier: string; SnapshotIdentifier: string;
          Tags: JsonNode = nil; Action: string = "CreateClusterSnapshot";
          Version: string = "2012-12-01"; ManualSnapshotRetentionPeriod: int = 0): Recallable =
  ## getCreateClusterSnapshot
  ## <p>Creates a manual snapshot of the specified cluster. The cluster must be in the <code>available</code> state. </p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : The cluster identifier for which you want a snapshot.
  ##   SnapshotIdentifier: string (required)
  ##                     : <p>A unique identifier for the snapshot that you are requesting. This identifier must be unique for all snapshots within the AWS account.</p> <p>Constraints:</p> <ul> <li> <p>Cannot be null, empty, or blank</p> </li> <li> <p>Must contain from 1 to 255 alphanumeric characters or hyphens</p> </li> <li> <p>First character must be a letter</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens</p> </li> </ul> <p>Example: <code>my-snapshot-id</code> </p>
  ##   Version: string (required)
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. </p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  var query_773610 = newJObject()
  if Tags != nil:
    query_773610.add "Tags", Tags
  add(query_773610, "Action", newJString(Action))
  add(query_773610, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_773610, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_773610, "Version", newJString(Version))
  add(query_773610, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  result = call_773609.call(nil, query_773610, nil, nil, nil)

var getCreateClusterSnapshot* = Call_GetCreateClusterSnapshot_773592(
    name: "getCreateClusterSnapshot", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=CreateClusterSnapshot",
    validator: validate_GetCreateClusterSnapshot_773593, base: "/",
    url: url_GetCreateClusterSnapshot_773594, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCreateClusterSubnetGroup_773650 = ref object of OpenApiRestCall_772581
proc url_PostCreateClusterSubnetGroup_773652(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_PostCreateClusterSubnetGroup_773651(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a new Amazon Redshift subnet group. You must provide a list of one or more subnets in your existing Amazon Virtual Private Cloud (Amazon VPC) when creating Amazon Redshift subnet group.</p> <p> For information about subnet groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-cluster-subnet-groups.html">Amazon Redshift Cluster Subnet Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_773653 = query.getOrDefault("Action")
  valid_773653 = validateParameter(valid_773653, JString, required = true, default = newJString(
      "CreateClusterSubnetGroup"))
  if valid_773653 != nil:
    section.add "Action", valid_773653
  var valid_773654 = query.getOrDefault("Version")
  valid_773654 = validateParameter(valid_773654, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_773654 != nil:
    section.add "Version", valid_773654
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_773655 = header.getOrDefault("X-Amz-Date")
  valid_773655 = validateParameter(valid_773655, JString, required = false,
                                 default = nil)
  if valid_773655 != nil:
    section.add "X-Amz-Date", valid_773655
  var valid_773656 = header.getOrDefault("X-Amz-Security-Token")
  valid_773656 = validateParameter(valid_773656, JString, required = false,
                                 default = nil)
  if valid_773656 != nil:
    section.add "X-Amz-Security-Token", valid_773656
  var valid_773657 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_773657 = validateParameter(valid_773657, JString, required = false,
                                 default = nil)
  if valid_773657 != nil:
    section.add "X-Amz-Content-Sha256", valid_773657
  var valid_773658 = header.getOrDefault("X-Amz-Algorithm")
  valid_773658 = validateParameter(valid_773658, JString, required = false,
                                 default = nil)
  if valid_773658 != nil:
    section.add "X-Amz-Algorithm", valid_773658
  var valid_773659 = header.getOrDefault("X-Amz-Signature")
  valid_773659 = validateParameter(valid_773659, JString, required = false,
                                 default = nil)
  if valid_773659 != nil:
    section.add "X-Amz-Signature", valid_773659
  var valid_773660 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_773660 = validateParameter(valid_773660, JString, required = false,
                                 default = nil)
  if valid_773660 != nil:
    section.add "X-Amz-SignedHeaders", valid_773660
  var valid_773661 = header.getOrDefault("X-Amz-Credential")
  valid_773661 = validateParameter(valid_773661, JString, required = false,
                                 default = nil)
  if valid_773661 != nil:
    section.add "X-Amz-Credential", valid_773661
  result.add "header", section
  ## parameters in `formData` object:
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   SubnetIds: JArray (required)
  ##            : An array of VPC subnet IDs. A maximum of 20 subnets can be modified in a single request.
  ##   Description: JString (required)
  ##              : A description for the subnet group.
  ##   ClusterSubnetGroupName: JString (required)
  ##                         : <p>The name for the subnet group. Amazon Redshift stores the value as a lowercase string.</p> <p>Constraints:</p> <ul> <li> <p>Must contain no more than 255 alphanumeric characters or hyphens.</p> </li> <li> <p>Must not be "Default".</p> </li> <li> <p>Must be unique for all subnet groups that are created by your AWS account.</p> </li> </ul> <p>Example: <code>examplesubnetgroup</code> </p>
  section = newJObject()
  var valid_773662 = formData.getOrDefault("Tags")
  valid_773662 = validateParameter(valid_773662, JArray, required = false,
                                 default = nil)
  if valid_773662 != nil:
    section.add "Tags", valid_773662
  assert formData != nil,
        "formData argument is necessary due to required `SubnetIds` field"
  var valid_773663 = formData.getOrDefault("SubnetIds")
  valid_773663 = validateParameter(valid_773663, JArray, required = true, default = nil)
  if valid_773663 != nil:
    section.add "SubnetIds", valid_773663
  var valid_773664 = formData.getOrDefault("Description")
  valid_773664 = validateParameter(valid_773664, JString, required = true,
                                 default = nil)
  if valid_773664 != nil:
    section.add "Description", valid_773664
  var valid_773665 = formData.getOrDefault("ClusterSubnetGroupName")
  valid_773665 = validateParameter(valid_773665, JString, required = true,
                                 default = nil)
  if valid_773665 != nil:
    section.add "ClusterSubnetGroupName", valid_773665
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_773666: Call_PostCreateClusterSubnetGroup_773650; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a new Amazon Redshift subnet group. You must provide a list of one or more subnets in your existing Amazon Virtual Private Cloud (Amazon VPC) when creating Amazon Redshift subnet group.</p> <p> For information about subnet groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-cluster-subnet-groups.html">Amazon Redshift Cluster Subnet Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_773666.validator(path, query, header, formData, body)
  let scheme = call_773666.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_773666.url(scheme.get, call_773666.host, call_773666.base,
                         call_773666.route, valid.getOrDefault("path"))
  result = hook(call_773666, url, valid)

proc call*(call_773667: Call_PostCreateClusterSubnetGroup_773650;
          SubnetIds: JsonNode; Description: string; ClusterSubnetGroupName: string;
          Tags: JsonNode = nil; Action: string = "CreateClusterSubnetGroup";
          Version: string = "2012-12-01"): Recallable =
  ## postCreateClusterSubnetGroup
  ## <p>Creates a new Amazon Redshift subnet group. You must provide a list of one or more subnets in your existing Amazon Virtual Private Cloud (Amazon VPC) when creating Amazon Redshift subnet group.</p> <p> For information about subnet groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-cluster-subnet-groups.html">Amazon Redshift Cluster Subnet Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   SubnetIds: JArray (required)
  ##            : An array of VPC subnet IDs. A maximum of 20 subnets can be modified in a single request.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   Description: string (required)
  ##              : A description for the subnet group.
  ##   ClusterSubnetGroupName: string (required)
  ##                         : <p>The name for the subnet group. Amazon Redshift stores the value as a lowercase string.</p> <p>Constraints:</p> <ul> <li> <p>Must contain no more than 255 alphanumeric characters or hyphens.</p> </li> <li> <p>Must not be "Default".</p> </li> <li> <p>Must be unique for all subnet groups that are created by your AWS account.</p> </li> </ul> <p>Example: <code>examplesubnetgroup</code> </p>
  var query_773668 = newJObject()
  var formData_773669 = newJObject()
  if Tags != nil:
    formData_773669.add "Tags", Tags
  if SubnetIds != nil:
    formData_773669.add "SubnetIds", SubnetIds
  add(query_773668, "Action", newJString(Action))
  add(query_773668, "Version", newJString(Version))
  add(formData_773669, "Description", newJString(Description))
  add(formData_773669, "ClusterSubnetGroupName",
      newJString(ClusterSubnetGroupName))
  result = call_773667.call(nil, query_773668, nil, formData_773669, nil)

var postCreateClusterSubnetGroup* = Call_PostCreateClusterSubnetGroup_773650(
    name: "postCreateClusterSubnetGroup", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=CreateClusterSubnetGroup",
    validator: validate_PostCreateClusterSubnetGroup_773651, base: "/",
    url: url_PostCreateClusterSubnetGroup_773652,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCreateClusterSubnetGroup_773631 = ref object of OpenApiRestCall_772581
proc url_GetCreateClusterSubnetGroup_773633(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_GetCreateClusterSubnetGroup_773632(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a new Amazon Redshift subnet group. You must provide a list of one or more subnets in your existing Amazon Virtual Private Cloud (Amazon VPC) when creating Amazon Redshift subnet group.</p> <p> For information about subnet groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-cluster-subnet-groups.html">Amazon Redshift Cluster Subnet Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ClusterSubnetGroupName: JString (required)
  ##                         : <p>The name for the subnet group. Amazon Redshift stores the value as a lowercase string.</p> <p>Constraints:</p> <ul> <li> <p>Must contain no more than 255 alphanumeric characters or hyphens.</p> </li> <li> <p>Must not be "Default".</p> </li> <li> <p>Must be unique for all subnet groups that are created by your AWS account.</p> </li> </ul> <p>Example: <code>examplesubnetgroup</code> </p>
  ##   Description: JString (required)
  ##              : A description for the subnet group.
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Action: JString (required)
  ##   SubnetIds: JArray (required)
  ##            : An array of VPC subnet IDs. A maximum of 20 subnets can be modified in a single request.
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `ClusterSubnetGroupName` field"
  var valid_773634 = query.getOrDefault("ClusterSubnetGroupName")
  valid_773634 = validateParameter(valid_773634, JString, required = true,
                                 default = nil)
  if valid_773634 != nil:
    section.add "ClusterSubnetGroupName", valid_773634
  var valid_773635 = query.getOrDefault("Description")
  valid_773635 = validateParameter(valid_773635, JString, required = true,
                                 default = nil)
  if valid_773635 != nil:
    section.add "Description", valid_773635
  var valid_773636 = query.getOrDefault("Tags")
  valid_773636 = validateParameter(valid_773636, JArray, required = false,
                                 default = nil)
  if valid_773636 != nil:
    section.add "Tags", valid_773636
  var valid_773637 = query.getOrDefault("Action")
  valid_773637 = validateParameter(valid_773637, JString, required = true, default = newJString(
      "CreateClusterSubnetGroup"))
  if valid_773637 != nil:
    section.add "Action", valid_773637
  var valid_773638 = query.getOrDefault("SubnetIds")
  valid_773638 = validateParameter(valid_773638, JArray, required = true, default = nil)
  if valid_773638 != nil:
    section.add "SubnetIds", valid_773638
  var valid_773639 = query.getOrDefault("Version")
  valid_773639 = validateParameter(valid_773639, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_773639 != nil:
    section.add "Version", valid_773639
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_773640 = header.getOrDefault("X-Amz-Date")
  valid_773640 = validateParameter(valid_773640, JString, required = false,
                                 default = nil)
  if valid_773640 != nil:
    section.add "X-Amz-Date", valid_773640
  var valid_773641 = header.getOrDefault("X-Amz-Security-Token")
  valid_773641 = validateParameter(valid_773641, JString, required = false,
                                 default = nil)
  if valid_773641 != nil:
    section.add "X-Amz-Security-Token", valid_773641
  var valid_773642 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_773642 = validateParameter(valid_773642, JString, required = false,
                                 default = nil)
  if valid_773642 != nil:
    section.add "X-Amz-Content-Sha256", valid_773642
  var valid_773643 = header.getOrDefault("X-Amz-Algorithm")
  valid_773643 = validateParameter(valid_773643, JString, required = false,
                                 default = nil)
  if valid_773643 != nil:
    section.add "X-Amz-Algorithm", valid_773643
  var valid_773644 = header.getOrDefault("X-Amz-Signature")
  valid_773644 = validateParameter(valid_773644, JString, required = false,
                                 default = nil)
  if valid_773644 != nil:
    section.add "X-Amz-Signature", valid_773644
  var valid_773645 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_773645 = validateParameter(valid_773645, JString, required = false,
                                 default = nil)
  if valid_773645 != nil:
    section.add "X-Amz-SignedHeaders", valid_773645
  var valid_773646 = header.getOrDefault("X-Amz-Credential")
  valid_773646 = validateParameter(valid_773646, JString, required = false,
                                 default = nil)
  if valid_773646 != nil:
    section.add "X-Amz-Credential", valid_773646
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_773647: Call_GetCreateClusterSubnetGroup_773631; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a new Amazon Redshift subnet group. You must provide a list of one or more subnets in your existing Amazon Virtual Private Cloud (Amazon VPC) when creating Amazon Redshift subnet group.</p> <p> For information about subnet groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-cluster-subnet-groups.html">Amazon Redshift Cluster Subnet Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_773647.validator(path, query, header, formData, body)
  let scheme = call_773647.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_773647.url(scheme.get, call_773647.host, call_773647.base,
                         call_773647.route, valid.getOrDefault("path"))
  result = hook(call_773647, url, valid)

proc call*(call_773648: Call_GetCreateClusterSubnetGroup_773631;
          ClusterSubnetGroupName: string; Description: string; SubnetIds: JsonNode;
          Tags: JsonNode = nil; Action: string = "CreateClusterSubnetGroup";
          Version: string = "2012-12-01"): Recallable =
  ## getCreateClusterSubnetGroup
  ## <p>Creates a new Amazon Redshift subnet group. You must provide a list of one or more subnets in your existing Amazon Virtual Private Cloud (Amazon VPC) when creating Amazon Redshift subnet group.</p> <p> For information about subnet groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-cluster-subnet-groups.html">Amazon Redshift Cluster Subnet Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   ClusterSubnetGroupName: string (required)
  ##                         : <p>The name for the subnet group. Amazon Redshift stores the value as a lowercase string.</p> <p>Constraints:</p> <ul> <li> <p>Must contain no more than 255 alphanumeric characters or hyphens.</p> </li> <li> <p>Must not be "Default".</p> </li> <li> <p>Must be unique for all subnet groups that are created by your AWS account.</p> </li> </ul> <p>Example: <code>examplesubnetgroup</code> </p>
  ##   Description: string (required)
  ##              : A description for the subnet group.
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Action: string (required)
  ##   SubnetIds: JArray (required)
  ##            : An array of VPC subnet IDs. A maximum of 20 subnets can be modified in a single request.
  ##   Version: string (required)
  var query_773649 = newJObject()
  add(query_773649, "ClusterSubnetGroupName", newJString(ClusterSubnetGroupName))
  add(query_773649, "Description", newJString(Description))
  if Tags != nil:
    query_773649.add "Tags", Tags
  add(query_773649, "Action", newJString(Action))
  if SubnetIds != nil:
    query_773649.add "SubnetIds", SubnetIds
  add(query_773649, "Version", newJString(Version))
  result = call_773648.call(nil, query_773649, nil, nil, nil)

var getCreateClusterSubnetGroup* = Call_GetCreateClusterSubnetGroup_773631(
    name: "getCreateClusterSubnetGroup", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=CreateClusterSubnetGroup",
    validator: validate_GetCreateClusterSubnetGroup_773632, base: "/",
    url: url_GetCreateClusterSubnetGroup_773633,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCreateEventSubscription_773693 = ref object of OpenApiRestCall_772581
proc url_PostCreateEventSubscription_773695(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_PostCreateEventSubscription_773694(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates an Amazon Redshift event notification subscription. This action requires an ARN (Amazon Resource Name) of an Amazon SNS topic created by either the Amazon Redshift console, the Amazon SNS console, or the Amazon SNS API. To obtain an ARN with Amazon SNS, you must create a topic in Amazon SNS and subscribe to the topic. The ARN is displayed in the SNS console.</p> <p>You can specify the source type, and lists of Amazon Redshift source IDs, event categories, and event severities. Notifications will be sent for all events you want that match those criteria. For example, you can specify source type = cluster, source ID = my-cluster-1 and mycluster2, event categories = Availability, Backup, and severity = ERROR. The subscription will only send notifications for those ERROR events in the Availability and Backup categories for the specified clusters.</p> <p>If you specify both the source type and source IDs, such as source type = cluster and source identifier = my-cluster-1, notifications will be sent for all the cluster events for my-cluster-1. If you specify a source type but do not specify a source identifier, you will receive notice of the events for the objects of that type in your AWS account. If you do not specify either the SourceType nor the SourceIdentifier, you will be notified of events generated from all Amazon Redshift sources belonging to your AWS account. You must specify a source type if you specify a source ID.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_773696 = query.getOrDefault("Action")
  valid_773696 = validateParameter(valid_773696, JString, required = true, default = newJString(
      "CreateEventSubscription"))
  if valid_773696 != nil:
    section.add "Action", valid_773696
  var valid_773697 = query.getOrDefault("Version")
  valid_773697 = validateParameter(valid_773697, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_773697 != nil:
    section.add "Version", valid_773697
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_773698 = header.getOrDefault("X-Amz-Date")
  valid_773698 = validateParameter(valid_773698, JString, required = false,
                                 default = nil)
  if valid_773698 != nil:
    section.add "X-Amz-Date", valid_773698
  var valid_773699 = header.getOrDefault("X-Amz-Security-Token")
  valid_773699 = validateParameter(valid_773699, JString, required = false,
                                 default = nil)
  if valid_773699 != nil:
    section.add "X-Amz-Security-Token", valid_773699
  var valid_773700 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_773700 = validateParameter(valid_773700, JString, required = false,
                                 default = nil)
  if valid_773700 != nil:
    section.add "X-Amz-Content-Sha256", valid_773700
  var valid_773701 = header.getOrDefault("X-Amz-Algorithm")
  valid_773701 = validateParameter(valid_773701, JString, required = false,
                                 default = nil)
  if valid_773701 != nil:
    section.add "X-Amz-Algorithm", valid_773701
  var valid_773702 = header.getOrDefault("X-Amz-Signature")
  valid_773702 = validateParameter(valid_773702, JString, required = false,
                                 default = nil)
  if valid_773702 != nil:
    section.add "X-Amz-Signature", valid_773702
  var valid_773703 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_773703 = validateParameter(valid_773703, JString, required = false,
                                 default = nil)
  if valid_773703 != nil:
    section.add "X-Amz-SignedHeaders", valid_773703
  var valid_773704 = header.getOrDefault("X-Amz-Credential")
  valid_773704 = validateParameter(valid_773704, JString, required = false,
                                 default = nil)
  if valid_773704 != nil:
    section.add "X-Amz-Credential", valid_773704
  result.add "header", section
  ## parameters in `formData` object:
  ##   Enabled: JBool
  ##          : A boolean value; set to <code>true</code> to activate the subscription, and set to <code>false</code> to create the subscription but not activate it. 
  ##   EventCategories: JArray
  ##                  : <p>Specifies the Amazon Redshift event categories to be published by the event notification subscription.</p> <p>Values: configuration, management, monitoring, security</p>
  ##   SnsTopicArn: JString (required)
  ##              : The Amazon Resource Name (ARN) of the Amazon SNS topic used to transmit the event notifications. The ARN is created by Amazon SNS when you create a topic and subscribe to it.
  ##   Severity: JString
  ##           : <p>Specifies the Amazon Redshift event severity to be published by the event notification subscription.</p> <p>Values: ERROR, INFO</p>
  ##   SourceIds: JArray
  ##            : <p>A list of one or more identifiers of Amazon Redshift source objects. All of the objects must be of the same type as was specified in the source type parameter. The event subscription will return only events generated by the specified objects. If not specified, then events are returned for all objects within the source type specified.</p> <p>Example: my-cluster-1, my-cluster-2</p> <p>Example: my-snapshot-20131010</p>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   SubscriptionName: JString (required)
  ##                   : <p>The name of the event subscription to be created.</p> <p>Constraints:</p> <ul> <li> <p>Cannot be null, empty, or blank.</p> </li> <li> <p>Must contain from 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   SourceType: JString
  ##             : <p>The type of source that will be generating the events. For example, if you want to be notified of events generated by a cluster, you would set this parameter to cluster. If this value is not specified, events are returned for all Amazon Redshift objects in your AWS account. You must specify a source type in order to specify source IDs.</p> <p>Valid values: cluster, cluster-parameter-group, cluster-security-group, and cluster-snapshot.</p>
  section = newJObject()
  var valid_773705 = formData.getOrDefault("Enabled")
  valid_773705 = validateParameter(valid_773705, JBool, required = false, default = nil)
  if valid_773705 != nil:
    section.add "Enabled", valid_773705
  var valid_773706 = formData.getOrDefault("EventCategories")
  valid_773706 = validateParameter(valid_773706, JArray, required = false,
                                 default = nil)
  if valid_773706 != nil:
    section.add "EventCategories", valid_773706
  assert formData != nil,
        "formData argument is necessary due to required `SnsTopicArn` field"
  var valid_773707 = formData.getOrDefault("SnsTopicArn")
  valid_773707 = validateParameter(valid_773707, JString, required = true,
                                 default = nil)
  if valid_773707 != nil:
    section.add "SnsTopicArn", valid_773707
  var valid_773708 = formData.getOrDefault("Severity")
  valid_773708 = validateParameter(valid_773708, JString, required = false,
                                 default = nil)
  if valid_773708 != nil:
    section.add "Severity", valid_773708
  var valid_773709 = formData.getOrDefault("SourceIds")
  valid_773709 = validateParameter(valid_773709, JArray, required = false,
                                 default = nil)
  if valid_773709 != nil:
    section.add "SourceIds", valid_773709
  var valid_773710 = formData.getOrDefault("Tags")
  valid_773710 = validateParameter(valid_773710, JArray, required = false,
                                 default = nil)
  if valid_773710 != nil:
    section.add "Tags", valid_773710
  var valid_773711 = formData.getOrDefault("SubscriptionName")
  valid_773711 = validateParameter(valid_773711, JString, required = true,
                                 default = nil)
  if valid_773711 != nil:
    section.add "SubscriptionName", valid_773711
  var valid_773712 = formData.getOrDefault("SourceType")
  valid_773712 = validateParameter(valid_773712, JString, required = false,
                                 default = nil)
  if valid_773712 != nil:
    section.add "SourceType", valid_773712
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_773713: Call_PostCreateEventSubscription_773693; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates an Amazon Redshift event notification subscription. This action requires an ARN (Amazon Resource Name) of an Amazon SNS topic created by either the Amazon Redshift console, the Amazon SNS console, or the Amazon SNS API. To obtain an ARN with Amazon SNS, you must create a topic in Amazon SNS and subscribe to the topic. The ARN is displayed in the SNS console.</p> <p>You can specify the source type, and lists of Amazon Redshift source IDs, event categories, and event severities. Notifications will be sent for all events you want that match those criteria. For example, you can specify source type = cluster, source ID = my-cluster-1 and mycluster2, event categories = Availability, Backup, and severity = ERROR. The subscription will only send notifications for those ERROR events in the Availability and Backup categories for the specified clusters.</p> <p>If you specify both the source type and source IDs, such as source type = cluster and source identifier = my-cluster-1, notifications will be sent for all the cluster events for my-cluster-1. If you specify a source type but do not specify a source identifier, you will receive notice of the events for the objects of that type in your AWS account. If you do not specify either the SourceType nor the SourceIdentifier, you will be notified of events generated from all Amazon Redshift sources belonging to your AWS account. You must specify a source type if you specify a source ID.</p>
  ## 
  let valid = call_773713.validator(path, query, header, formData, body)
  let scheme = call_773713.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_773713.url(scheme.get, call_773713.host, call_773713.base,
                         call_773713.route, valid.getOrDefault("path"))
  result = hook(call_773713, url, valid)

proc call*(call_773714: Call_PostCreateEventSubscription_773693;
          SnsTopicArn: string; SubscriptionName: string; Enabled: bool = false;
          EventCategories: JsonNode = nil; Severity: string = "";
          SourceIds: JsonNode = nil; Tags: JsonNode = nil;
          Action: string = "CreateEventSubscription";
          Version: string = "2012-12-01"; SourceType: string = ""): Recallable =
  ## postCreateEventSubscription
  ## <p>Creates an Amazon Redshift event notification subscription. This action requires an ARN (Amazon Resource Name) of an Amazon SNS topic created by either the Amazon Redshift console, the Amazon SNS console, or the Amazon SNS API. To obtain an ARN with Amazon SNS, you must create a topic in Amazon SNS and subscribe to the topic. The ARN is displayed in the SNS console.</p> <p>You can specify the source type, and lists of Amazon Redshift source IDs, event categories, and event severities. Notifications will be sent for all events you want that match those criteria. For example, you can specify source type = cluster, source ID = my-cluster-1 and mycluster2, event categories = Availability, Backup, and severity = ERROR. The subscription will only send notifications for those ERROR events in the Availability and Backup categories for the specified clusters.</p> <p>If you specify both the source type and source IDs, such as source type = cluster and source identifier = my-cluster-1, notifications will be sent for all the cluster events for my-cluster-1. If you specify a source type but do not specify a source identifier, you will receive notice of the events for the objects of that type in your AWS account. If you do not specify either the SourceType nor the SourceIdentifier, you will be notified of events generated from all Amazon Redshift sources belonging to your AWS account. You must specify a source type if you specify a source ID.</p>
  ##   Enabled: bool
  ##          : A boolean value; set to <code>true</code> to activate the subscription, and set to <code>false</code> to create the subscription but not activate it. 
  ##   EventCategories: JArray
  ##                  : <p>Specifies the Amazon Redshift event categories to be published by the event notification subscription.</p> <p>Values: configuration, management, monitoring, security</p>
  ##   SnsTopicArn: string (required)
  ##              : The Amazon Resource Name (ARN) of the Amazon SNS topic used to transmit the event notifications. The ARN is created by Amazon SNS when you create a topic and subscribe to it.
  ##   Severity: string
  ##           : <p>Specifies the Amazon Redshift event severity to be published by the event notification subscription.</p> <p>Values: ERROR, INFO</p>
  ##   SourceIds: JArray
  ##            : <p>A list of one or more identifiers of Amazon Redshift source objects. All of the objects must be of the same type as was specified in the source type parameter. The event subscription will return only events generated by the specified objects. If not specified, then events are returned for all objects within the source type specified.</p> <p>Example: my-cluster-1, my-cluster-2</p> <p>Example: my-snapshot-20131010</p>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   SubscriptionName: string (required)
  ##                   : <p>The name of the event subscription to be created.</p> <p>Constraints:</p> <ul> <li> <p>Cannot be null, empty, or blank.</p> </li> <li> <p>Must contain from 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   Action: string (required)
  ##   Version: string (required)
  ##   SourceType: string
  ##             : <p>The type of source that will be generating the events. For example, if you want to be notified of events generated by a cluster, you would set this parameter to cluster. If this value is not specified, events are returned for all Amazon Redshift objects in your AWS account. You must specify a source type in order to specify source IDs.</p> <p>Valid values: cluster, cluster-parameter-group, cluster-security-group, and cluster-snapshot.</p>
  var query_773715 = newJObject()
  var formData_773716 = newJObject()
  add(formData_773716, "Enabled", newJBool(Enabled))
  if EventCategories != nil:
    formData_773716.add "EventCategories", EventCategories
  add(formData_773716, "SnsTopicArn", newJString(SnsTopicArn))
  add(formData_773716, "Severity", newJString(Severity))
  if SourceIds != nil:
    formData_773716.add "SourceIds", SourceIds
  if Tags != nil:
    formData_773716.add "Tags", Tags
  add(formData_773716, "SubscriptionName", newJString(SubscriptionName))
  add(query_773715, "Action", newJString(Action))
  add(query_773715, "Version", newJString(Version))
  add(formData_773716, "SourceType", newJString(SourceType))
  result = call_773714.call(nil, query_773715, nil, formData_773716, nil)

var postCreateEventSubscription* = Call_PostCreateEventSubscription_773693(
    name: "postCreateEventSubscription", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=CreateEventSubscription",
    validator: validate_PostCreateEventSubscription_773694, base: "/",
    url: url_PostCreateEventSubscription_773695,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCreateEventSubscription_773670 = ref object of OpenApiRestCall_772581
proc url_GetCreateEventSubscription_773672(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_GetCreateEventSubscription_773671(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates an Amazon Redshift event notification subscription. This action requires an ARN (Amazon Resource Name) of an Amazon SNS topic created by either the Amazon Redshift console, the Amazon SNS console, or the Amazon SNS API. To obtain an ARN with Amazon SNS, you must create a topic in Amazon SNS and subscribe to the topic. The ARN is displayed in the SNS console.</p> <p>You can specify the source type, and lists of Amazon Redshift source IDs, event categories, and event severities. Notifications will be sent for all events you want that match those criteria. For example, you can specify source type = cluster, source ID = my-cluster-1 and mycluster2, event categories = Availability, Backup, and severity = ERROR. The subscription will only send notifications for those ERROR events in the Availability and Backup categories for the specified clusters.</p> <p>If you specify both the source type and source IDs, such as source type = cluster and source identifier = my-cluster-1, notifications will be sent for all the cluster events for my-cluster-1. If you specify a source type but do not specify a source identifier, you will receive notice of the events for the objects of that type in your AWS account. If you do not specify either the SourceType nor the SourceIdentifier, you will be notified of events generated from all Amazon Redshift sources belonging to your AWS account. You must specify a source type if you specify a source ID.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   SourceType: JString
  ##             : <p>The type of source that will be generating the events. For example, if you want to be notified of events generated by a cluster, you would set this parameter to cluster. If this value is not specified, events are returned for all Amazon Redshift objects in your AWS account. You must specify a source type in order to specify source IDs.</p> <p>Valid values: cluster, cluster-parameter-group, cluster-security-group, and cluster-snapshot.</p>
  ##   SourceIds: JArray
  ##            : <p>A list of one or more identifiers of Amazon Redshift source objects. All of the objects must be of the same type as was specified in the source type parameter. The event subscription will return only events generated by the specified objects. If not specified, then events are returned for all objects within the source type specified.</p> <p>Example: my-cluster-1, my-cluster-2</p> <p>Example: my-snapshot-20131010</p>
  ##   Enabled: JBool
  ##          : A boolean value; set to <code>true</code> to activate the subscription, and set to <code>false</code> to create the subscription but not activate it. 
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Action: JString (required)
  ##   SnsTopicArn: JString (required)
  ##              : The Amazon Resource Name (ARN) of the Amazon SNS topic used to transmit the event notifications. The ARN is created by Amazon SNS when you create a topic and subscribe to it.
  ##   EventCategories: JArray
  ##                  : <p>Specifies the Amazon Redshift event categories to be published by the event notification subscription.</p> <p>Values: configuration, management, monitoring, security</p>
  ##   SubscriptionName: JString (required)
  ##                   : <p>The name of the event subscription to be created.</p> <p>Constraints:</p> <ul> <li> <p>Cannot be null, empty, or blank.</p> </li> <li> <p>Must contain from 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   Severity: JString
  ##           : <p>Specifies the Amazon Redshift event severity to be published by the event notification subscription.</p> <p>Values: ERROR, INFO</p>
  ##   Version: JString (required)
  section = newJObject()
  var valid_773673 = query.getOrDefault("SourceType")
  valid_773673 = validateParameter(valid_773673, JString, required = false,
                                 default = nil)
  if valid_773673 != nil:
    section.add "SourceType", valid_773673
  var valid_773674 = query.getOrDefault("SourceIds")
  valid_773674 = validateParameter(valid_773674, JArray, required = false,
                                 default = nil)
  if valid_773674 != nil:
    section.add "SourceIds", valid_773674
  var valid_773675 = query.getOrDefault("Enabled")
  valid_773675 = validateParameter(valid_773675, JBool, required = false, default = nil)
  if valid_773675 != nil:
    section.add "Enabled", valid_773675
  var valid_773676 = query.getOrDefault("Tags")
  valid_773676 = validateParameter(valid_773676, JArray, required = false,
                                 default = nil)
  if valid_773676 != nil:
    section.add "Tags", valid_773676
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_773677 = query.getOrDefault("Action")
  valid_773677 = validateParameter(valid_773677, JString, required = true, default = newJString(
      "CreateEventSubscription"))
  if valid_773677 != nil:
    section.add "Action", valid_773677
  var valid_773678 = query.getOrDefault("SnsTopicArn")
  valid_773678 = validateParameter(valid_773678, JString, required = true,
                                 default = nil)
  if valid_773678 != nil:
    section.add "SnsTopicArn", valid_773678
  var valid_773679 = query.getOrDefault("EventCategories")
  valid_773679 = validateParameter(valid_773679, JArray, required = false,
                                 default = nil)
  if valid_773679 != nil:
    section.add "EventCategories", valid_773679
  var valid_773680 = query.getOrDefault("SubscriptionName")
  valid_773680 = validateParameter(valid_773680, JString, required = true,
                                 default = nil)
  if valid_773680 != nil:
    section.add "SubscriptionName", valid_773680
  var valid_773681 = query.getOrDefault("Severity")
  valid_773681 = validateParameter(valid_773681, JString, required = false,
                                 default = nil)
  if valid_773681 != nil:
    section.add "Severity", valid_773681
  var valid_773682 = query.getOrDefault("Version")
  valid_773682 = validateParameter(valid_773682, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_773682 != nil:
    section.add "Version", valid_773682
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_773683 = header.getOrDefault("X-Amz-Date")
  valid_773683 = validateParameter(valid_773683, JString, required = false,
                                 default = nil)
  if valid_773683 != nil:
    section.add "X-Amz-Date", valid_773683
  var valid_773684 = header.getOrDefault("X-Amz-Security-Token")
  valid_773684 = validateParameter(valid_773684, JString, required = false,
                                 default = nil)
  if valid_773684 != nil:
    section.add "X-Amz-Security-Token", valid_773684
  var valid_773685 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_773685 = validateParameter(valid_773685, JString, required = false,
                                 default = nil)
  if valid_773685 != nil:
    section.add "X-Amz-Content-Sha256", valid_773685
  var valid_773686 = header.getOrDefault("X-Amz-Algorithm")
  valid_773686 = validateParameter(valid_773686, JString, required = false,
                                 default = nil)
  if valid_773686 != nil:
    section.add "X-Amz-Algorithm", valid_773686
  var valid_773687 = header.getOrDefault("X-Amz-Signature")
  valid_773687 = validateParameter(valid_773687, JString, required = false,
                                 default = nil)
  if valid_773687 != nil:
    section.add "X-Amz-Signature", valid_773687
  var valid_773688 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_773688 = validateParameter(valid_773688, JString, required = false,
                                 default = nil)
  if valid_773688 != nil:
    section.add "X-Amz-SignedHeaders", valid_773688
  var valid_773689 = header.getOrDefault("X-Amz-Credential")
  valid_773689 = validateParameter(valid_773689, JString, required = false,
                                 default = nil)
  if valid_773689 != nil:
    section.add "X-Amz-Credential", valid_773689
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_773690: Call_GetCreateEventSubscription_773670; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates an Amazon Redshift event notification subscription. This action requires an ARN (Amazon Resource Name) of an Amazon SNS topic created by either the Amazon Redshift console, the Amazon SNS console, or the Amazon SNS API. To obtain an ARN with Amazon SNS, you must create a topic in Amazon SNS and subscribe to the topic. The ARN is displayed in the SNS console.</p> <p>You can specify the source type, and lists of Amazon Redshift source IDs, event categories, and event severities. Notifications will be sent for all events you want that match those criteria. For example, you can specify source type = cluster, source ID = my-cluster-1 and mycluster2, event categories = Availability, Backup, and severity = ERROR. The subscription will only send notifications for those ERROR events in the Availability and Backup categories for the specified clusters.</p> <p>If you specify both the source type and source IDs, such as source type = cluster and source identifier = my-cluster-1, notifications will be sent for all the cluster events for my-cluster-1. If you specify a source type but do not specify a source identifier, you will receive notice of the events for the objects of that type in your AWS account. If you do not specify either the SourceType nor the SourceIdentifier, you will be notified of events generated from all Amazon Redshift sources belonging to your AWS account. You must specify a source type if you specify a source ID.</p>
  ## 
  let valid = call_773690.validator(path, query, header, formData, body)
  let scheme = call_773690.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_773690.url(scheme.get, call_773690.host, call_773690.base,
                         call_773690.route, valid.getOrDefault("path"))
  result = hook(call_773690, url, valid)

proc call*(call_773691: Call_GetCreateEventSubscription_773670;
          SnsTopicArn: string; SubscriptionName: string; SourceType: string = "";
          SourceIds: JsonNode = nil; Enabled: bool = false; Tags: JsonNode = nil;
          Action: string = "CreateEventSubscription";
          EventCategories: JsonNode = nil; Severity: string = "";
          Version: string = "2012-12-01"): Recallable =
  ## getCreateEventSubscription
  ## <p>Creates an Amazon Redshift event notification subscription. This action requires an ARN (Amazon Resource Name) of an Amazon SNS topic created by either the Amazon Redshift console, the Amazon SNS console, or the Amazon SNS API. To obtain an ARN with Amazon SNS, you must create a topic in Amazon SNS and subscribe to the topic. The ARN is displayed in the SNS console.</p> <p>You can specify the source type, and lists of Amazon Redshift source IDs, event categories, and event severities. Notifications will be sent for all events you want that match those criteria. For example, you can specify source type = cluster, source ID = my-cluster-1 and mycluster2, event categories = Availability, Backup, and severity = ERROR. The subscription will only send notifications for those ERROR events in the Availability and Backup categories for the specified clusters.</p> <p>If you specify both the source type and source IDs, such as source type = cluster and source identifier = my-cluster-1, notifications will be sent for all the cluster events for my-cluster-1. If you specify a source type but do not specify a source identifier, you will receive notice of the events for the objects of that type in your AWS account. If you do not specify either the SourceType nor the SourceIdentifier, you will be notified of events generated from all Amazon Redshift sources belonging to your AWS account. You must specify a source type if you specify a source ID.</p>
  ##   SourceType: string
  ##             : <p>The type of source that will be generating the events. For example, if you want to be notified of events generated by a cluster, you would set this parameter to cluster. If this value is not specified, events are returned for all Amazon Redshift objects in your AWS account. You must specify a source type in order to specify source IDs.</p> <p>Valid values: cluster, cluster-parameter-group, cluster-security-group, and cluster-snapshot.</p>
  ##   SourceIds: JArray
  ##            : <p>A list of one or more identifiers of Amazon Redshift source objects. All of the objects must be of the same type as was specified in the source type parameter. The event subscription will return only events generated by the specified objects. If not specified, then events are returned for all objects within the source type specified.</p> <p>Example: my-cluster-1, my-cluster-2</p> <p>Example: my-snapshot-20131010</p>
  ##   Enabled: bool
  ##          : A boolean value; set to <code>true</code> to activate the subscription, and set to <code>false</code> to create the subscription but not activate it. 
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Action: string (required)
  ##   SnsTopicArn: string (required)
  ##              : The Amazon Resource Name (ARN) of the Amazon SNS topic used to transmit the event notifications. The ARN is created by Amazon SNS when you create a topic and subscribe to it.
  ##   EventCategories: JArray
  ##                  : <p>Specifies the Amazon Redshift event categories to be published by the event notification subscription.</p> <p>Values: configuration, management, monitoring, security</p>
  ##   SubscriptionName: string (required)
  ##                   : <p>The name of the event subscription to be created.</p> <p>Constraints:</p> <ul> <li> <p>Cannot be null, empty, or blank.</p> </li> <li> <p>Must contain from 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   Severity: string
  ##           : <p>Specifies the Amazon Redshift event severity to be published by the event notification subscription.</p> <p>Values: ERROR, INFO</p>
  ##   Version: string (required)
  var query_773692 = newJObject()
  add(query_773692, "SourceType", newJString(SourceType))
  if SourceIds != nil:
    query_773692.add "SourceIds", SourceIds
  add(query_773692, "Enabled", newJBool(Enabled))
  if Tags != nil:
    query_773692.add "Tags", Tags
  add(query_773692, "Action", newJString(Action))
  add(query_773692, "SnsTopicArn", newJString(SnsTopicArn))
  if EventCategories != nil:
    query_773692.add "EventCategories", EventCategories
  add(query_773692, "SubscriptionName", newJString(SubscriptionName))
  add(query_773692, "Severity", newJString(Severity))
  add(query_773692, "Version", newJString(Version))
  result = call_773691.call(nil, query_773692, nil, nil, nil)

var getCreateEventSubscription* = Call_GetCreateEventSubscription_773670(
    name: "getCreateEventSubscription", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=CreateEventSubscription",
    validator: validate_GetCreateEventSubscription_773671, base: "/",
    url: url_GetCreateEventSubscription_773672,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCreateHsmClientCertificate_773734 = ref object of OpenApiRestCall_772581
proc url_PostCreateHsmClientCertificate_773736(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_PostCreateHsmClientCertificate_773735(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates an HSM client certificate that an Amazon Redshift cluster will use to connect to the client's HSM in order to store and retrieve the keys used to encrypt the cluster databases.</p> <p>The command returns a public key, which you must store in the HSM. In addition to creating the HSM certificate, you must create an Amazon Redshift HSM configuration that provides a cluster the information needed to store and use encryption keys in the HSM. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a> in the Amazon Redshift Cluster Management Guide.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_773737 = query.getOrDefault("Action")
  valid_773737 = validateParameter(valid_773737, JString, required = true, default = newJString(
      "CreateHsmClientCertificate"))
  if valid_773737 != nil:
    section.add "Action", valid_773737
  var valid_773738 = query.getOrDefault("Version")
  valid_773738 = validateParameter(valid_773738, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_773738 != nil:
    section.add "Version", valid_773738
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_773739 = header.getOrDefault("X-Amz-Date")
  valid_773739 = validateParameter(valid_773739, JString, required = false,
                                 default = nil)
  if valid_773739 != nil:
    section.add "X-Amz-Date", valid_773739
  var valid_773740 = header.getOrDefault("X-Amz-Security-Token")
  valid_773740 = validateParameter(valid_773740, JString, required = false,
                                 default = nil)
  if valid_773740 != nil:
    section.add "X-Amz-Security-Token", valid_773740
  var valid_773741 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_773741 = validateParameter(valid_773741, JString, required = false,
                                 default = nil)
  if valid_773741 != nil:
    section.add "X-Amz-Content-Sha256", valid_773741
  var valid_773742 = header.getOrDefault("X-Amz-Algorithm")
  valid_773742 = validateParameter(valid_773742, JString, required = false,
                                 default = nil)
  if valid_773742 != nil:
    section.add "X-Amz-Algorithm", valid_773742
  var valid_773743 = header.getOrDefault("X-Amz-Signature")
  valid_773743 = validateParameter(valid_773743, JString, required = false,
                                 default = nil)
  if valid_773743 != nil:
    section.add "X-Amz-Signature", valid_773743
  var valid_773744 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_773744 = validateParameter(valid_773744, JString, required = false,
                                 default = nil)
  if valid_773744 != nil:
    section.add "X-Amz-SignedHeaders", valid_773744
  var valid_773745 = header.getOrDefault("X-Amz-Credential")
  valid_773745 = validateParameter(valid_773745, JString, required = false,
                                 default = nil)
  if valid_773745 != nil:
    section.add "X-Amz-Credential", valid_773745
  result.add "header", section
  ## parameters in `formData` object:
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   HsmClientCertificateIdentifier: JString (required)
  ##                                 : The identifier to be assigned to the new HSM client certificate that the cluster will use to connect to the HSM to use the database encryption keys.
  section = newJObject()
  var valid_773746 = formData.getOrDefault("Tags")
  valid_773746 = validateParameter(valid_773746, JArray, required = false,
                                 default = nil)
  if valid_773746 != nil:
    section.add "Tags", valid_773746
  assert formData != nil, "formData argument is necessary due to required `HsmClientCertificateIdentifier` field"
  var valid_773747 = formData.getOrDefault("HsmClientCertificateIdentifier")
  valid_773747 = validateParameter(valid_773747, JString, required = true,
                                 default = nil)
  if valid_773747 != nil:
    section.add "HsmClientCertificateIdentifier", valid_773747
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_773748: Call_PostCreateHsmClientCertificate_773734; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates an HSM client certificate that an Amazon Redshift cluster will use to connect to the client's HSM in order to store and retrieve the keys used to encrypt the cluster databases.</p> <p>The command returns a public key, which you must store in the HSM. In addition to creating the HSM certificate, you must create an Amazon Redshift HSM configuration that provides a cluster the information needed to store and use encryption keys in the HSM. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a> in the Amazon Redshift Cluster Management Guide.</p>
  ## 
  let valid = call_773748.validator(path, query, header, formData, body)
  let scheme = call_773748.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_773748.url(scheme.get, call_773748.host, call_773748.base,
                         call_773748.route, valid.getOrDefault("path"))
  result = hook(call_773748, url, valid)

proc call*(call_773749: Call_PostCreateHsmClientCertificate_773734;
          HsmClientCertificateIdentifier: string; Tags: JsonNode = nil;
          Action: string = "CreateHsmClientCertificate";
          Version: string = "2012-12-01"): Recallable =
  ## postCreateHsmClientCertificate
  ## <p>Creates an HSM client certificate that an Amazon Redshift cluster will use to connect to the client's HSM in order to store and retrieve the keys used to encrypt the cluster databases.</p> <p>The command returns a public key, which you must store in the HSM. In addition to creating the HSM certificate, you must create an Amazon Redshift HSM configuration that provides a cluster the information needed to store and use encryption keys in the HSM. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a> in the Amazon Redshift Cluster Management Guide.</p>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Action: string (required)
  ##   HsmClientCertificateIdentifier: string (required)
  ##                                 : The identifier to be assigned to the new HSM client certificate that the cluster will use to connect to the HSM to use the database encryption keys.
  ##   Version: string (required)
  var query_773750 = newJObject()
  var formData_773751 = newJObject()
  if Tags != nil:
    formData_773751.add "Tags", Tags
  add(query_773750, "Action", newJString(Action))
  add(formData_773751, "HsmClientCertificateIdentifier",
      newJString(HsmClientCertificateIdentifier))
  add(query_773750, "Version", newJString(Version))
  result = call_773749.call(nil, query_773750, nil, formData_773751, nil)

var postCreateHsmClientCertificate* = Call_PostCreateHsmClientCertificate_773734(
    name: "postCreateHsmClientCertificate", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=CreateHsmClientCertificate",
    validator: validate_PostCreateHsmClientCertificate_773735, base: "/",
    url: url_PostCreateHsmClientCertificate_773736,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCreateHsmClientCertificate_773717 = ref object of OpenApiRestCall_772581
proc url_GetCreateHsmClientCertificate_773719(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_GetCreateHsmClientCertificate_773718(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates an HSM client certificate that an Amazon Redshift cluster will use to connect to the client's HSM in order to store and retrieve the keys used to encrypt the cluster databases.</p> <p>The command returns a public key, which you must store in the HSM. In addition to creating the HSM certificate, you must create an Amazon Redshift HSM configuration that provides a cluster the information needed to store and use encryption keys in the HSM. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a> in the Amazon Redshift Cluster Management Guide.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   HsmClientCertificateIdentifier: JString (required)
  ##                                 : The identifier to be assigned to the new HSM client certificate that the cluster will use to connect to the HSM to use the database encryption keys.
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `HsmClientCertificateIdentifier` field"
  var valid_773720 = query.getOrDefault("HsmClientCertificateIdentifier")
  valid_773720 = validateParameter(valid_773720, JString, required = true,
                                 default = nil)
  if valid_773720 != nil:
    section.add "HsmClientCertificateIdentifier", valid_773720
  var valid_773721 = query.getOrDefault("Tags")
  valid_773721 = validateParameter(valid_773721, JArray, required = false,
                                 default = nil)
  if valid_773721 != nil:
    section.add "Tags", valid_773721
  var valid_773722 = query.getOrDefault("Action")
  valid_773722 = validateParameter(valid_773722, JString, required = true, default = newJString(
      "CreateHsmClientCertificate"))
  if valid_773722 != nil:
    section.add "Action", valid_773722
  var valid_773723 = query.getOrDefault("Version")
  valid_773723 = validateParameter(valid_773723, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_773723 != nil:
    section.add "Version", valid_773723
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_773724 = header.getOrDefault("X-Amz-Date")
  valid_773724 = validateParameter(valid_773724, JString, required = false,
                                 default = nil)
  if valid_773724 != nil:
    section.add "X-Amz-Date", valid_773724
  var valid_773725 = header.getOrDefault("X-Amz-Security-Token")
  valid_773725 = validateParameter(valid_773725, JString, required = false,
                                 default = nil)
  if valid_773725 != nil:
    section.add "X-Amz-Security-Token", valid_773725
  var valid_773726 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_773726 = validateParameter(valid_773726, JString, required = false,
                                 default = nil)
  if valid_773726 != nil:
    section.add "X-Amz-Content-Sha256", valid_773726
  var valid_773727 = header.getOrDefault("X-Amz-Algorithm")
  valid_773727 = validateParameter(valid_773727, JString, required = false,
                                 default = nil)
  if valid_773727 != nil:
    section.add "X-Amz-Algorithm", valid_773727
  var valid_773728 = header.getOrDefault("X-Amz-Signature")
  valid_773728 = validateParameter(valid_773728, JString, required = false,
                                 default = nil)
  if valid_773728 != nil:
    section.add "X-Amz-Signature", valid_773728
  var valid_773729 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_773729 = validateParameter(valid_773729, JString, required = false,
                                 default = nil)
  if valid_773729 != nil:
    section.add "X-Amz-SignedHeaders", valid_773729
  var valid_773730 = header.getOrDefault("X-Amz-Credential")
  valid_773730 = validateParameter(valid_773730, JString, required = false,
                                 default = nil)
  if valid_773730 != nil:
    section.add "X-Amz-Credential", valid_773730
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_773731: Call_GetCreateHsmClientCertificate_773717; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates an HSM client certificate that an Amazon Redshift cluster will use to connect to the client's HSM in order to store and retrieve the keys used to encrypt the cluster databases.</p> <p>The command returns a public key, which you must store in the HSM. In addition to creating the HSM certificate, you must create an Amazon Redshift HSM configuration that provides a cluster the information needed to store and use encryption keys in the HSM. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a> in the Amazon Redshift Cluster Management Guide.</p>
  ## 
  let valid = call_773731.validator(path, query, header, formData, body)
  let scheme = call_773731.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_773731.url(scheme.get, call_773731.host, call_773731.base,
                         call_773731.route, valid.getOrDefault("path"))
  result = hook(call_773731, url, valid)

proc call*(call_773732: Call_GetCreateHsmClientCertificate_773717;
          HsmClientCertificateIdentifier: string; Tags: JsonNode = nil;
          Action: string = "CreateHsmClientCertificate";
          Version: string = "2012-12-01"): Recallable =
  ## getCreateHsmClientCertificate
  ## <p>Creates an HSM client certificate that an Amazon Redshift cluster will use to connect to the client's HSM in order to store and retrieve the keys used to encrypt the cluster databases.</p> <p>The command returns a public key, which you must store in the HSM. In addition to creating the HSM certificate, you must create an Amazon Redshift HSM configuration that provides a cluster the information needed to store and use encryption keys in the HSM. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a> in the Amazon Redshift Cluster Management Guide.</p>
  ##   HsmClientCertificateIdentifier: string (required)
  ##                                 : The identifier to be assigned to the new HSM client certificate that the cluster will use to connect to the HSM to use the database encryption keys.
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_773733 = newJObject()
  add(query_773733, "HsmClientCertificateIdentifier",
      newJString(HsmClientCertificateIdentifier))
  if Tags != nil:
    query_773733.add "Tags", Tags
  add(query_773733, "Action", newJString(Action))
  add(query_773733, "Version", newJString(Version))
  result = call_773732.call(nil, query_773733, nil, nil, nil)

var getCreateHsmClientCertificate* = Call_GetCreateHsmClientCertificate_773717(
    name: "getCreateHsmClientCertificate", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=CreateHsmClientCertificate",
    validator: validate_GetCreateHsmClientCertificate_773718, base: "/",
    url: url_GetCreateHsmClientCertificate_773719,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCreateHsmConfiguration_773774 = ref object of OpenApiRestCall_772581
proc url_PostCreateHsmConfiguration_773776(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_PostCreateHsmConfiguration_773775(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates an HSM configuration that contains the information required by an Amazon Redshift cluster to store and use database encryption keys in a Hardware Security Module (HSM). After creating the HSM configuration, you can specify it as a parameter when creating a cluster. The cluster will then store its encryption keys in the HSM.</p> <p>In addition to creating an HSM configuration, you must also create an HSM client certificate. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a> in the Amazon Redshift Cluster Management Guide.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_773777 = query.getOrDefault("Action")
  valid_773777 = validateParameter(valid_773777, JString, required = true,
                                 default = newJString("CreateHsmConfiguration"))
  if valid_773777 != nil:
    section.add "Action", valid_773777
  var valid_773778 = query.getOrDefault("Version")
  valid_773778 = validateParameter(valid_773778, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_773778 != nil:
    section.add "Version", valid_773778
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_773779 = header.getOrDefault("X-Amz-Date")
  valid_773779 = validateParameter(valid_773779, JString, required = false,
                                 default = nil)
  if valid_773779 != nil:
    section.add "X-Amz-Date", valid_773779
  var valid_773780 = header.getOrDefault("X-Amz-Security-Token")
  valid_773780 = validateParameter(valid_773780, JString, required = false,
                                 default = nil)
  if valid_773780 != nil:
    section.add "X-Amz-Security-Token", valid_773780
  var valid_773781 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_773781 = validateParameter(valid_773781, JString, required = false,
                                 default = nil)
  if valid_773781 != nil:
    section.add "X-Amz-Content-Sha256", valid_773781
  var valid_773782 = header.getOrDefault("X-Amz-Algorithm")
  valid_773782 = validateParameter(valid_773782, JString, required = false,
                                 default = nil)
  if valid_773782 != nil:
    section.add "X-Amz-Algorithm", valid_773782
  var valid_773783 = header.getOrDefault("X-Amz-Signature")
  valid_773783 = validateParameter(valid_773783, JString, required = false,
                                 default = nil)
  if valid_773783 != nil:
    section.add "X-Amz-Signature", valid_773783
  var valid_773784 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_773784 = validateParameter(valid_773784, JString, required = false,
                                 default = nil)
  if valid_773784 != nil:
    section.add "X-Amz-SignedHeaders", valid_773784
  var valid_773785 = header.getOrDefault("X-Amz-Credential")
  valid_773785 = validateParameter(valid_773785, JString, required = false,
                                 default = nil)
  if valid_773785 != nil:
    section.add "X-Amz-Credential", valid_773785
  result.add "header", section
  ## parameters in `formData` object:
  ##   HsmIpAddress: JString (required)
  ##               : The IP address that the Amazon Redshift cluster must use to access the HSM.
  ##   HsmPartitionName: JString (required)
  ##                   : The name of the partition in the HSM where the Amazon Redshift clusters will store their database encryption keys.
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   HsmPartitionPassword: JString (required)
  ##                       : The password required to access the HSM partition.
  ##   HsmConfigurationIdentifier: JString (required)
  ##                             : The identifier to be assigned to the new Amazon Redshift HSM configuration.
  ##   HsmServerPublicCertificate: JString (required)
  ##                             : The HSMs public certificate file. When using Cloud HSM, the file name is server.pem.
  ##   Description: JString (required)
  ##              : A text description of the HSM configuration to be created.
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `HsmIpAddress` field"
  var valid_773786 = formData.getOrDefault("HsmIpAddress")
  valid_773786 = validateParameter(valid_773786, JString, required = true,
                                 default = nil)
  if valid_773786 != nil:
    section.add "HsmIpAddress", valid_773786
  var valid_773787 = formData.getOrDefault("HsmPartitionName")
  valid_773787 = validateParameter(valid_773787, JString, required = true,
                                 default = nil)
  if valid_773787 != nil:
    section.add "HsmPartitionName", valid_773787
  var valid_773788 = formData.getOrDefault("Tags")
  valid_773788 = validateParameter(valid_773788, JArray, required = false,
                                 default = nil)
  if valid_773788 != nil:
    section.add "Tags", valid_773788
  var valid_773789 = formData.getOrDefault("HsmPartitionPassword")
  valid_773789 = validateParameter(valid_773789, JString, required = true,
                                 default = nil)
  if valid_773789 != nil:
    section.add "HsmPartitionPassword", valid_773789
  var valid_773790 = formData.getOrDefault("HsmConfigurationIdentifier")
  valid_773790 = validateParameter(valid_773790, JString, required = true,
                                 default = nil)
  if valid_773790 != nil:
    section.add "HsmConfigurationIdentifier", valid_773790
  var valid_773791 = formData.getOrDefault("HsmServerPublicCertificate")
  valid_773791 = validateParameter(valid_773791, JString, required = true,
                                 default = nil)
  if valid_773791 != nil:
    section.add "HsmServerPublicCertificate", valid_773791
  var valid_773792 = formData.getOrDefault("Description")
  valid_773792 = validateParameter(valid_773792, JString, required = true,
                                 default = nil)
  if valid_773792 != nil:
    section.add "Description", valid_773792
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_773793: Call_PostCreateHsmConfiguration_773774; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates an HSM configuration that contains the information required by an Amazon Redshift cluster to store and use database encryption keys in a Hardware Security Module (HSM). After creating the HSM configuration, you can specify it as a parameter when creating a cluster. The cluster will then store its encryption keys in the HSM.</p> <p>In addition to creating an HSM configuration, you must also create an HSM client certificate. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a> in the Amazon Redshift Cluster Management Guide.</p>
  ## 
  let valid = call_773793.validator(path, query, header, formData, body)
  let scheme = call_773793.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_773793.url(scheme.get, call_773793.host, call_773793.base,
                         call_773793.route, valid.getOrDefault("path"))
  result = hook(call_773793, url, valid)

proc call*(call_773794: Call_PostCreateHsmConfiguration_773774;
          HsmIpAddress: string; HsmPartitionName: string;
          HsmPartitionPassword: string; HsmConfigurationIdentifier: string;
          HsmServerPublicCertificate: string; Description: string;
          Tags: JsonNode = nil; Action: string = "CreateHsmConfiguration";
          Version: string = "2012-12-01"): Recallable =
  ## postCreateHsmConfiguration
  ## <p>Creates an HSM configuration that contains the information required by an Amazon Redshift cluster to store and use database encryption keys in a Hardware Security Module (HSM). After creating the HSM configuration, you can specify it as a parameter when creating a cluster. The cluster will then store its encryption keys in the HSM.</p> <p>In addition to creating an HSM configuration, you must also create an HSM client certificate. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a> in the Amazon Redshift Cluster Management Guide.</p>
  ##   HsmIpAddress: string (required)
  ##               : The IP address that the Amazon Redshift cluster must use to access the HSM.
  ##   HsmPartitionName: string (required)
  ##                   : The name of the partition in the HSM where the Amazon Redshift clusters will store their database encryption keys.
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   HsmPartitionPassword: string (required)
  ##                       : The password required to access the HSM partition.
  ##   HsmConfigurationIdentifier: string (required)
  ##                             : The identifier to be assigned to the new Amazon Redshift HSM configuration.
  ##   Action: string (required)
  ##   HsmServerPublicCertificate: string (required)
  ##                             : The HSMs public certificate file. When using Cloud HSM, the file name is server.pem.
  ##   Version: string (required)
  ##   Description: string (required)
  ##              : A text description of the HSM configuration to be created.
  var query_773795 = newJObject()
  var formData_773796 = newJObject()
  add(formData_773796, "HsmIpAddress", newJString(HsmIpAddress))
  add(formData_773796, "HsmPartitionName", newJString(HsmPartitionName))
  if Tags != nil:
    formData_773796.add "Tags", Tags
  add(formData_773796, "HsmPartitionPassword", newJString(HsmPartitionPassword))
  add(formData_773796, "HsmConfigurationIdentifier",
      newJString(HsmConfigurationIdentifier))
  add(query_773795, "Action", newJString(Action))
  add(formData_773796, "HsmServerPublicCertificate",
      newJString(HsmServerPublicCertificate))
  add(query_773795, "Version", newJString(Version))
  add(formData_773796, "Description", newJString(Description))
  result = call_773794.call(nil, query_773795, nil, formData_773796, nil)

var postCreateHsmConfiguration* = Call_PostCreateHsmConfiguration_773774(
    name: "postCreateHsmConfiguration", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=CreateHsmConfiguration",
    validator: validate_PostCreateHsmConfiguration_773775, base: "/",
    url: url_PostCreateHsmConfiguration_773776,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCreateHsmConfiguration_773752 = ref object of OpenApiRestCall_772581
proc url_GetCreateHsmConfiguration_773754(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_GetCreateHsmConfiguration_773753(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates an HSM configuration that contains the information required by an Amazon Redshift cluster to store and use database encryption keys in a Hardware Security Module (HSM). After creating the HSM configuration, you can specify it as a parameter when creating a cluster. The cluster will then store its encryption keys in the HSM.</p> <p>In addition to creating an HSM configuration, you must also create an HSM client certificate. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a> in the Amazon Redshift Cluster Management Guide.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   HsmPartitionPassword: JString (required)
  ##                       : The password required to access the HSM partition.
  ##   Description: JString (required)
  ##              : A text description of the HSM configuration to be created.
  ##   HsmPartitionName: JString (required)
  ##                   : The name of the partition in the HSM where the Amazon Redshift clusters will store their database encryption keys.
  ##   HsmConfigurationIdentifier: JString (required)
  ##                             : The identifier to be assigned to the new Amazon Redshift HSM configuration.
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Action: JString (required)
  ##   HsmServerPublicCertificate: JString (required)
  ##                             : The HSMs public certificate file. When using Cloud HSM, the file name is server.pem.
  ##   HsmIpAddress: JString (required)
  ##               : The IP address that the Amazon Redshift cluster must use to access the HSM.
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `HsmPartitionPassword` field"
  var valid_773755 = query.getOrDefault("HsmPartitionPassword")
  valid_773755 = validateParameter(valid_773755, JString, required = true,
                                 default = nil)
  if valid_773755 != nil:
    section.add "HsmPartitionPassword", valid_773755
  var valid_773756 = query.getOrDefault("Description")
  valid_773756 = validateParameter(valid_773756, JString, required = true,
                                 default = nil)
  if valid_773756 != nil:
    section.add "Description", valid_773756
  var valid_773757 = query.getOrDefault("HsmPartitionName")
  valid_773757 = validateParameter(valid_773757, JString, required = true,
                                 default = nil)
  if valid_773757 != nil:
    section.add "HsmPartitionName", valid_773757
  var valid_773758 = query.getOrDefault("HsmConfigurationIdentifier")
  valid_773758 = validateParameter(valid_773758, JString, required = true,
                                 default = nil)
  if valid_773758 != nil:
    section.add "HsmConfigurationIdentifier", valid_773758
  var valid_773759 = query.getOrDefault("Tags")
  valid_773759 = validateParameter(valid_773759, JArray, required = false,
                                 default = nil)
  if valid_773759 != nil:
    section.add "Tags", valid_773759
  var valid_773760 = query.getOrDefault("Action")
  valid_773760 = validateParameter(valid_773760, JString, required = true,
                                 default = newJString("CreateHsmConfiguration"))
  if valid_773760 != nil:
    section.add "Action", valid_773760
  var valid_773761 = query.getOrDefault("HsmServerPublicCertificate")
  valid_773761 = validateParameter(valid_773761, JString, required = true,
                                 default = nil)
  if valid_773761 != nil:
    section.add "HsmServerPublicCertificate", valid_773761
  var valid_773762 = query.getOrDefault("HsmIpAddress")
  valid_773762 = validateParameter(valid_773762, JString, required = true,
                                 default = nil)
  if valid_773762 != nil:
    section.add "HsmIpAddress", valid_773762
  var valid_773763 = query.getOrDefault("Version")
  valid_773763 = validateParameter(valid_773763, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_773763 != nil:
    section.add "Version", valid_773763
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_773764 = header.getOrDefault("X-Amz-Date")
  valid_773764 = validateParameter(valid_773764, JString, required = false,
                                 default = nil)
  if valid_773764 != nil:
    section.add "X-Amz-Date", valid_773764
  var valid_773765 = header.getOrDefault("X-Amz-Security-Token")
  valid_773765 = validateParameter(valid_773765, JString, required = false,
                                 default = nil)
  if valid_773765 != nil:
    section.add "X-Amz-Security-Token", valid_773765
  var valid_773766 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_773766 = validateParameter(valid_773766, JString, required = false,
                                 default = nil)
  if valid_773766 != nil:
    section.add "X-Amz-Content-Sha256", valid_773766
  var valid_773767 = header.getOrDefault("X-Amz-Algorithm")
  valid_773767 = validateParameter(valid_773767, JString, required = false,
                                 default = nil)
  if valid_773767 != nil:
    section.add "X-Amz-Algorithm", valid_773767
  var valid_773768 = header.getOrDefault("X-Amz-Signature")
  valid_773768 = validateParameter(valid_773768, JString, required = false,
                                 default = nil)
  if valid_773768 != nil:
    section.add "X-Amz-Signature", valid_773768
  var valid_773769 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_773769 = validateParameter(valid_773769, JString, required = false,
                                 default = nil)
  if valid_773769 != nil:
    section.add "X-Amz-SignedHeaders", valid_773769
  var valid_773770 = header.getOrDefault("X-Amz-Credential")
  valid_773770 = validateParameter(valid_773770, JString, required = false,
                                 default = nil)
  if valid_773770 != nil:
    section.add "X-Amz-Credential", valid_773770
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_773771: Call_GetCreateHsmConfiguration_773752; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates an HSM configuration that contains the information required by an Amazon Redshift cluster to store and use database encryption keys in a Hardware Security Module (HSM). After creating the HSM configuration, you can specify it as a parameter when creating a cluster. The cluster will then store its encryption keys in the HSM.</p> <p>In addition to creating an HSM configuration, you must also create an HSM client certificate. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a> in the Amazon Redshift Cluster Management Guide.</p>
  ## 
  let valid = call_773771.validator(path, query, header, formData, body)
  let scheme = call_773771.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_773771.url(scheme.get, call_773771.host, call_773771.base,
                         call_773771.route, valid.getOrDefault("path"))
  result = hook(call_773771, url, valid)

proc call*(call_773772: Call_GetCreateHsmConfiguration_773752;
          HsmPartitionPassword: string; Description: string;
          HsmPartitionName: string; HsmConfigurationIdentifier: string;
          HsmServerPublicCertificate: string; HsmIpAddress: string;
          Tags: JsonNode = nil; Action: string = "CreateHsmConfiguration";
          Version: string = "2012-12-01"): Recallable =
  ## getCreateHsmConfiguration
  ## <p>Creates an HSM configuration that contains the information required by an Amazon Redshift cluster to store and use database encryption keys in a Hardware Security Module (HSM). After creating the HSM configuration, you can specify it as a parameter when creating a cluster. The cluster will then store its encryption keys in the HSM.</p> <p>In addition to creating an HSM configuration, you must also create an HSM client certificate. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a> in the Amazon Redshift Cluster Management Guide.</p>
  ##   HsmPartitionPassword: string (required)
  ##                       : The password required to access the HSM partition.
  ##   Description: string (required)
  ##              : A text description of the HSM configuration to be created.
  ##   HsmPartitionName: string (required)
  ##                   : The name of the partition in the HSM where the Amazon Redshift clusters will store their database encryption keys.
  ##   HsmConfigurationIdentifier: string (required)
  ##                             : The identifier to be assigned to the new Amazon Redshift HSM configuration.
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Action: string (required)
  ##   HsmServerPublicCertificate: string (required)
  ##                             : The HSMs public certificate file. When using Cloud HSM, the file name is server.pem.
  ##   HsmIpAddress: string (required)
  ##               : The IP address that the Amazon Redshift cluster must use to access the HSM.
  ##   Version: string (required)
  var query_773773 = newJObject()
  add(query_773773, "HsmPartitionPassword", newJString(HsmPartitionPassword))
  add(query_773773, "Description", newJString(Description))
  add(query_773773, "HsmPartitionName", newJString(HsmPartitionName))
  add(query_773773, "HsmConfigurationIdentifier",
      newJString(HsmConfigurationIdentifier))
  if Tags != nil:
    query_773773.add "Tags", Tags
  add(query_773773, "Action", newJString(Action))
  add(query_773773, "HsmServerPublicCertificate",
      newJString(HsmServerPublicCertificate))
  add(query_773773, "HsmIpAddress", newJString(HsmIpAddress))
  add(query_773773, "Version", newJString(Version))
  result = call_773772.call(nil, query_773773, nil, nil, nil)

var getCreateHsmConfiguration* = Call_GetCreateHsmConfiguration_773752(
    name: "getCreateHsmConfiguration", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=CreateHsmConfiguration",
    validator: validate_GetCreateHsmConfiguration_773753, base: "/",
    url: url_GetCreateHsmConfiguration_773754,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCreateSnapshotCopyGrant_773815 = ref object of OpenApiRestCall_772581
proc url_PostCreateSnapshotCopyGrant_773817(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_PostCreateSnapshotCopyGrant_773816(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a snapshot copy grant that permits Amazon Redshift to use a customer master key (CMK) from AWS Key Management Service (AWS KMS) to encrypt copied snapshots in a destination region.</p> <p> For more information about managing snapshot copy grants, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_773818 = query.getOrDefault("Action")
  valid_773818 = validateParameter(valid_773818, JString, required = true, default = newJString(
      "CreateSnapshotCopyGrant"))
  if valid_773818 != nil:
    section.add "Action", valid_773818
  var valid_773819 = query.getOrDefault("Version")
  valid_773819 = validateParameter(valid_773819, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_773819 != nil:
    section.add "Version", valid_773819
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_773820 = header.getOrDefault("X-Amz-Date")
  valid_773820 = validateParameter(valid_773820, JString, required = false,
                                 default = nil)
  if valid_773820 != nil:
    section.add "X-Amz-Date", valid_773820
  var valid_773821 = header.getOrDefault("X-Amz-Security-Token")
  valid_773821 = validateParameter(valid_773821, JString, required = false,
                                 default = nil)
  if valid_773821 != nil:
    section.add "X-Amz-Security-Token", valid_773821
  var valid_773822 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_773822 = validateParameter(valid_773822, JString, required = false,
                                 default = nil)
  if valid_773822 != nil:
    section.add "X-Amz-Content-Sha256", valid_773822
  var valid_773823 = header.getOrDefault("X-Amz-Algorithm")
  valid_773823 = validateParameter(valid_773823, JString, required = false,
                                 default = nil)
  if valid_773823 != nil:
    section.add "X-Amz-Algorithm", valid_773823
  var valid_773824 = header.getOrDefault("X-Amz-Signature")
  valid_773824 = validateParameter(valid_773824, JString, required = false,
                                 default = nil)
  if valid_773824 != nil:
    section.add "X-Amz-Signature", valid_773824
  var valid_773825 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_773825 = validateParameter(valid_773825, JString, required = false,
                                 default = nil)
  if valid_773825 != nil:
    section.add "X-Amz-SignedHeaders", valid_773825
  var valid_773826 = header.getOrDefault("X-Amz-Credential")
  valid_773826 = validateParameter(valid_773826, JString, required = false,
                                 default = nil)
  if valid_773826 != nil:
    section.add "X-Amz-Credential", valid_773826
  result.add "header", section
  ## parameters in `formData` object:
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   SnapshotCopyGrantName: JString (required)
  ##                        : <p>The name of the snapshot copy grant. This name must be unique in the region for the AWS account.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul>
  ##   KmsKeyId: JString
  ##           : The unique identifier of the customer master key (CMK) to which to grant Amazon Redshift permission. If no key is specified, the default key is used.
  section = newJObject()
  var valid_773827 = formData.getOrDefault("Tags")
  valid_773827 = validateParameter(valid_773827, JArray, required = false,
                                 default = nil)
  if valid_773827 != nil:
    section.add "Tags", valid_773827
  assert formData != nil, "formData argument is necessary due to required `SnapshotCopyGrantName` field"
  var valid_773828 = formData.getOrDefault("SnapshotCopyGrantName")
  valid_773828 = validateParameter(valid_773828, JString, required = true,
                                 default = nil)
  if valid_773828 != nil:
    section.add "SnapshotCopyGrantName", valid_773828
  var valid_773829 = formData.getOrDefault("KmsKeyId")
  valid_773829 = validateParameter(valid_773829, JString, required = false,
                                 default = nil)
  if valid_773829 != nil:
    section.add "KmsKeyId", valid_773829
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_773830: Call_PostCreateSnapshotCopyGrant_773815; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a snapshot copy grant that permits Amazon Redshift to use a customer master key (CMK) from AWS Key Management Service (AWS KMS) to encrypt copied snapshots in a destination region.</p> <p> For more information about managing snapshot copy grants, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ## 
  let valid = call_773830.validator(path, query, header, formData, body)
  let scheme = call_773830.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_773830.url(scheme.get, call_773830.host, call_773830.base,
                         call_773830.route, valid.getOrDefault("path"))
  result = hook(call_773830, url, valid)

proc call*(call_773831: Call_PostCreateSnapshotCopyGrant_773815;
          SnapshotCopyGrantName: string; Tags: JsonNode = nil;
          Action: string = "CreateSnapshotCopyGrant"; KmsKeyId: string = "";
          Version: string = "2012-12-01"): Recallable =
  ## postCreateSnapshotCopyGrant
  ## <p>Creates a snapshot copy grant that permits Amazon Redshift to use a customer master key (CMK) from AWS Key Management Service (AWS KMS) to encrypt copied snapshots in a destination region.</p> <p> For more information about managing snapshot copy grants, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Action: string (required)
  ##   SnapshotCopyGrantName: string (required)
  ##                        : <p>The name of the snapshot copy grant. This name must be unique in the region for the AWS account.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul>
  ##   KmsKeyId: string
  ##           : The unique identifier of the customer master key (CMK) to which to grant Amazon Redshift permission. If no key is specified, the default key is used.
  ##   Version: string (required)
  var query_773832 = newJObject()
  var formData_773833 = newJObject()
  if Tags != nil:
    formData_773833.add "Tags", Tags
  add(query_773832, "Action", newJString(Action))
  add(formData_773833, "SnapshotCopyGrantName", newJString(SnapshotCopyGrantName))
  add(formData_773833, "KmsKeyId", newJString(KmsKeyId))
  add(query_773832, "Version", newJString(Version))
  result = call_773831.call(nil, query_773832, nil, formData_773833, nil)

var postCreateSnapshotCopyGrant* = Call_PostCreateSnapshotCopyGrant_773815(
    name: "postCreateSnapshotCopyGrant", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=CreateSnapshotCopyGrant",
    validator: validate_PostCreateSnapshotCopyGrant_773816, base: "/",
    url: url_PostCreateSnapshotCopyGrant_773817,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCreateSnapshotCopyGrant_773797 = ref object of OpenApiRestCall_772581
proc url_GetCreateSnapshotCopyGrant_773799(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_GetCreateSnapshotCopyGrant_773798(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a snapshot copy grant that permits Amazon Redshift to use a customer master key (CMK) from AWS Key Management Service (AWS KMS) to encrypt copied snapshots in a destination region.</p> <p> For more information about managing snapshot copy grants, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Action: JString (required)
  ##   KmsKeyId: JString
  ##           : The unique identifier of the customer master key (CMK) to which to grant Amazon Redshift permission. If no key is specified, the default key is used.
  ##   SnapshotCopyGrantName: JString (required)
  ##                        : <p>The name of the snapshot copy grant. This name must be unique in the region for the AWS account.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul>
  ##   Version: JString (required)
  section = newJObject()
  var valid_773800 = query.getOrDefault("Tags")
  valid_773800 = validateParameter(valid_773800, JArray, required = false,
                                 default = nil)
  if valid_773800 != nil:
    section.add "Tags", valid_773800
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_773801 = query.getOrDefault("Action")
  valid_773801 = validateParameter(valid_773801, JString, required = true, default = newJString(
      "CreateSnapshotCopyGrant"))
  if valid_773801 != nil:
    section.add "Action", valid_773801
  var valid_773802 = query.getOrDefault("KmsKeyId")
  valid_773802 = validateParameter(valid_773802, JString, required = false,
                                 default = nil)
  if valid_773802 != nil:
    section.add "KmsKeyId", valid_773802
  var valid_773803 = query.getOrDefault("SnapshotCopyGrantName")
  valid_773803 = validateParameter(valid_773803, JString, required = true,
                                 default = nil)
  if valid_773803 != nil:
    section.add "SnapshotCopyGrantName", valid_773803
  var valid_773804 = query.getOrDefault("Version")
  valid_773804 = validateParameter(valid_773804, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_773804 != nil:
    section.add "Version", valid_773804
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_773805 = header.getOrDefault("X-Amz-Date")
  valid_773805 = validateParameter(valid_773805, JString, required = false,
                                 default = nil)
  if valid_773805 != nil:
    section.add "X-Amz-Date", valid_773805
  var valid_773806 = header.getOrDefault("X-Amz-Security-Token")
  valid_773806 = validateParameter(valid_773806, JString, required = false,
                                 default = nil)
  if valid_773806 != nil:
    section.add "X-Amz-Security-Token", valid_773806
  var valid_773807 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_773807 = validateParameter(valid_773807, JString, required = false,
                                 default = nil)
  if valid_773807 != nil:
    section.add "X-Amz-Content-Sha256", valid_773807
  var valid_773808 = header.getOrDefault("X-Amz-Algorithm")
  valid_773808 = validateParameter(valid_773808, JString, required = false,
                                 default = nil)
  if valid_773808 != nil:
    section.add "X-Amz-Algorithm", valid_773808
  var valid_773809 = header.getOrDefault("X-Amz-Signature")
  valid_773809 = validateParameter(valid_773809, JString, required = false,
                                 default = nil)
  if valid_773809 != nil:
    section.add "X-Amz-Signature", valid_773809
  var valid_773810 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_773810 = validateParameter(valid_773810, JString, required = false,
                                 default = nil)
  if valid_773810 != nil:
    section.add "X-Amz-SignedHeaders", valid_773810
  var valid_773811 = header.getOrDefault("X-Amz-Credential")
  valid_773811 = validateParameter(valid_773811, JString, required = false,
                                 default = nil)
  if valid_773811 != nil:
    section.add "X-Amz-Credential", valid_773811
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_773812: Call_GetCreateSnapshotCopyGrant_773797; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a snapshot copy grant that permits Amazon Redshift to use a customer master key (CMK) from AWS Key Management Service (AWS KMS) to encrypt copied snapshots in a destination region.</p> <p> For more information about managing snapshot copy grants, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ## 
  let valid = call_773812.validator(path, query, header, formData, body)
  let scheme = call_773812.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_773812.url(scheme.get, call_773812.host, call_773812.base,
                         call_773812.route, valid.getOrDefault("path"))
  result = hook(call_773812, url, valid)

proc call*(call_773813: Call_GetCreateSnapshotCopyGrant_773797;
          SnapshotCopyGrantName: string; Tags: JsonNode = nil;
          Action: string = "CreateSnapshotCopyGrant"; KmsKeyId: string = "";
          Version: string = "2012-12-01"): Recallable =
  ## getCreateSnapshotCopyGrant
  ## <p>Creates a snapshot copy grant that permits Amazon Redshift to use a customer master key (CMK) from AWS Key Management Service (AWS KMS) to encrypt copied snapshots in a destination region.</p> <p> For more information about managing snapshot copy grants, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Action: string (required)
  ##   KmsKeyId: string
  ##           : The unique identifier of the customer master key (CMK) to which to grant Amazon Redshift permission. If no key is specified, the default key is used.
  ##   SnapshotCopyGrantName: string (required)
  ##                        : <p>The name of the snapshot copy grant. This name must be unique in the region for the AWS account.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul>
  ##   Version: string (required)
  var query_773814 = newJObject()
  if Tags != nil:
    query_773814.add "Tags", Tags
  add(query_773814, "Action", newJString(Action))
  add(query_773814, "KmsKeyId", newJString(KmsKeyId))
  add(query_773814, "SnapshotCopyGrantName", newJString(SnapshotCopyGrantName))
  add(query_773814, "Version", newJString(Version))
  result = call_773813.call(nil, query_773814, nil, nil, nil)

var getCreateSnapshotCopyGrant* = Call_GetCreateSnapshotCopyGrant_773797(
    name: "getCreateSnapshotCopyGrant", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=CreateSnapshotCopyGrant",
    validator: validate_GetCreateSnapshotCopyGrant_773798, base: "/",
    url: url_GetCreateSnapshotCopyGrant_773799,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCreateSnapshotSchedule_773855 = ref object of OpenApiRestCall_772581
proc url_PostCreateSnapshotSchedule_773857(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_PostCreateSnapshotSchedule_773856(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Creates a new snapshot schedule.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_773858 = query.getOrDefault("Action")
  valid_773858 = validateParameter(valid_773858, JString, required = true,
                                 default = newJString("CreateSnapshotSchedule"))
  if valid_773858 != nil:
    section.add "Action", valid_773858
  var valid_773859 = query.getOrDefault("Version")
  valid_773859 = validateParameter(valid_773859, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_773859 != nil:
    section.add "Version", valid_773859
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_773860 = header.getOrDefault("X-Amz-Date")
  valid_773860 = validateParameter(valid_773860, JString, required = false,
                                 default = nil)
  if valid_773860 != nil:
    section.add "X-Amz-Date", valid_773860
  var valid_773861 = header.getOrDefault("X-Amz-Security-Token")
  valid_773861 = validateParameter(valid_773861, JString, required = false,
                                 default = nil)
  if valid_773861 != nil:
    section.add "X-Amz-Security-Token", valid_773861
  var valid_773862 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_773862 = validateParameter(valid_773862, JString, required = false,
                                 default = nil)
  if valid_773862 != nil:
    section.add "X-Amz-Content-Sha256", valid_773862
  var valid_773863 = header.getOrDefault("X-Amz-Algorithm")
  valid_773863 = validateParameter(valid_773863, JString, required = false,
                                 default = nil)
  if valid_773863 != nil:
    section.add "X-Amz-Algorithm", valid_773863
  var valid_773864 = header.getOrDefault("X-Amz-Signature")
  valid_773864 = validateParameter(valid_773864, JString, required = false,
                                 default = nil)
  if valid_773864 != nil:
    section.add "X-Amz-Signature", valid_773864
  var valid_773865 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_773865 = validateParameter(valid_773865, JString, required = false,
                                 default = nil)
  if valid_773865 != nil:
    section.add "X-Amz-SignedHeaders", valid_773865
  var valid_773866 = header.getOrDefault("X-Amz-Credential")
  valid_773866 = validateParameter(valid_773866, JString, required = false,
                                 default = nil)
  if valid_773866 != nil:
    section.add "X-Amz-Credential", valid_773866
  result.add "header", section
  ## parameters in `formData` object:
  ##   ScheduleDefinitions: JArray
  ##                      : The definition of the snapshot schedule. The definition is made up of schedule expressions, for example "cron(30 12 *)" or "rate(12 hours)". 
  ##   DryRun: JBool
  ##         : <p/>
  ##   Tags: JArray
  ##       : An optional set of tags you can use to search for the schedule.
  ##   ScheduleDescription: JString
  ##                      : The description of the snapshot schedule.
  ##   ScheduleIdentifier: JString
  ##                     : A unique identifier for a snapshot schedule. Only alphanumeric characters are allowed for the identifier.
  ##   NextInvocations: JInt
  ##                  : <p/>
  section = newJObject()
  var valid_773867 = formData.getOrDefault("ScheduleDefinitions")
  valid_773867 = validateParameter(valid_773867, JArray, required = false,
                                 default = nil)
  if valid_773867 != nil:
    section.add "ScheduleDefinitions", valid_773867
  var valid_773868 = formData.getOrDefault("DryRun")
  valid_773868 = validateParameter(valid_773868, JBool, required = false, default = nil)
  if valid_773868 != nil:
    section.add "DryRun", valid_773868
  var valid_773869 = formData.getOrDefault("Tags")
  valid_773869 = validateParameter(valid_773869, JArray, required = false,
                                 default = nil)
  if valid_773869 != nil:
    section.add "Tags", valid_773869
  var valid_773870 = formData.getOrDefault("ScheduleDescription")
  valid_773870 = validateParameter(valid_773870, JString, required = false,
                                 default = nil)
  if valid_773870 != nil:
    section.add "ScheduleDescription", valid_773870
  var valid_773871 = formData.getOrDefault("ScheduleIdentifier")
  valid_773871 = validateParameter(valid_773871, JString, required = false,
                                 default = nil)
  if valid_773871 != nil:
    section.add "ScheduleIdentifier", valid_773871
  var valid_773872 = formData.getOrDefault("NextInvocations")
  valid_773872 = validateParameter(valid_773872, JInt, required = false, default = nil)
  if valid_773872 != nil:
    section.add "NextInvocations", valid_773872
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_773873: Call_PostCreateSnapshotSchedule_773855; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a new snapshot schedule.
  ## 
  let valid = call_773873.validator(path, query, header, formData, body)
  let scheme = call_773873.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_773873.url(scheme.get, call_773873.host, call_773873.base,
                         call_773873.route, valid.getOrDefault("path"))
  result = hook(call_773873, url, valid)

proc call*(call_773874: Call_PostCreateSnapshotSchedule_773855;
          ScheduleDefinitions: JsonNode = nil; DryRun: bool = false;
          Tags: JsonNode = nil; ScheduleDescription: string = "";
          Action: string = "CreateSnapshotSchedule";
          ScheduleIdentifier: string = ""; NextInvocations: int = 0;
          Version: string = "2012-12-01"): Recallable =
  ## postCreateSnapshotSchedule
  ## Creates a new snapshot schedule.
  ##   ScheduleDefinitions: JArray
  ##                      : The definition of the snapshot schedule. The definition is made up of schedule expressions, for example "cron(30 12 *)" or "rate(12 hours)". 
  ##   DryRun: bool
  ##         : <p/>
  ##   Tags: JArray
  ##       : An optional set of tags you can use to search for the schedule.
  ##   ScheduleDescription: string
  ##                      : The description of the snapshot schedule.
  ##   Action: string (required)
  ##   ScheduleIdentifier: string
  ##                     : A unique identifier for a snapshot schedule. Only alphanumeric characters are allowed for the identifier.
  ##   NextInvocations: int
  ##                  : <p/>
  ##   Version: string (required)
  var query_773875 = newJObject()
  var formData_773876 = newJObject()
  if ScheduleDefinitions != nil:
    formData_773876.add "ScheduleDefinitions", ScheduleDefinitions
  add(formData_773876, "DryRun", newJBool(DryRun))
  if Tags != nil:
    formData_773876.add "Tags", Tags
  add(formData_773876, "ScheduleDescription", newJString(ScheduleDescription))
  add(query_773875, "Action", newJString(Action))
  add(formData_773876, "ScheduleIdentifier", newJString(ScheduleIdentifier))
  add(formData_773876, "NextInvocations", newJInt(NextInvocations))
  add(query_773875, "Version", newJString(Version))
  result = call_773874.call(nil, query_773875, nil, formData_773876, nil)

var postCreateSnapshotSchedule* = Call_PostCreateSnapshotSchedule_773855(
    name: "postCreateSnapshotSchedule", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=CreateSnapshotSchedule",
    validator: validate_PostCreateSnapshotSchedule_773856, base: "/",
    url: url_PostCreateSnapshotSchedule_773857,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCreateSnapshotSchedule_773834 = ref object of OpenApiRestCall_772581
proc url_GetCreateSnapshotSchedule_773836(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_GetCreateSnapshotSchedule_773835(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Creates a new snapshot schedule.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   DryRun: JBool
  ##         : <p/>
  ##   ScheduleDefinitions: JArray
  ##                      : The definition of the snapshot schedule. The definition is made up of schedule expressions, for example "cron(30 12 *)" or "rate(12 hours)". 
  ##   Tags: JArray
  ##       : An optional set of tags you can use to search for the schedule.
  ##   Action: JString (required)
  ##   ScheduleIdentifier: JString
  ##                     : A unique identifier for a snapshot schedule. Only alphanumeric characters are allowed for the identifier.
  ##   ScheduleDescription: JString
  ##                      : The description of the snapshot schedule.
  ##   NextInvocations: JInt
  ##                  : <p/>
  ##   Version: JString (required)
  section = newJObject()
  var valid_773837 = query.getOrDefault("DryRun")
  valid_773837 = validateParameter(valid_773837, JBool, required = false, default = nil)
  if valid_773837 != nil:
    section.add "DryRun", valid_773837
  var valid_773838 = query.getOrDefault("ScheduleDefinitions")
  valid_773838 = validateParameter(valid_773838, JArray, required = false,
                                 default = nil)
  if valid_773838 != nil:
    section.add "ScheduleDefinitions", valid_773838
  var valid_773839 = query.getOrDefault("Tags")
  valid_773839 = validateParameter(valid_773839, JArray, required = false,
                                 default = nil)
  if valid_773839 != nil:
    section.add "Tags", valid_773839
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_773840 = query.getOrDefault("Action")
  valid_773840 = validateParameter(valid_773840, JString, required = true,
                                 default = newJString("CreateSnapshotSchedule"))
  if valid_773840 != nil:
    section.add "Action", valid_773840
  var valid_773841 = query.getOrDefault("ScheduleIdentifier")
  valid_773841 = validateParameter(valid_773841, JString, required = false,
                                 default = nil)
  if valid_773841 != nil:
    section.add "ScheduleIdentifier", valid_773841
  var valid_773842 = query.getOrDefault("ScheduleDescription")
  valid_773842 = validateParameter(valid_773842, JString, required = false,
                                 default = nil)
  if valid_773842 != nil:
    section.add "ScheduleDescription", valid_773842
  var valid_773843 = query.getOrDefault("NextInvocations")
  valid_773843 = validateParameter(valid_773843, JInt, required = false, default = nil)
  if valid_773843 != nil:
    section.add "NextInvocations", valid_773843
  var valid_773844 = query.getOrDefault("Version")
  valid_773844 = validateParameter(valid_773844, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_773844 != nil:
    section.add "Version", valid_773844
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_773845 = header.getOrDefault("X-Amz-Date")
  valid_773845 = validateParameter(valid_773845, JString, required = false,
                                 default = nil)
  if valid_773845 != nil:
    section.add "X-Amz-Date", valid_773845
  var valid_773846 = header.getOrDefault("X-Amz-Security-Token")
  valid_773846 = validateParameter(valid_773846, JString, required = false,
                                 default = nil)
  if valid_773846 != nil:
    section.add "X-Amz-Security-Token", valid_773846
  var valid_773847 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_773847 = validateParameter(valid_773847, JString, required = false,
                                 default = nil)
  if valid_773847 != nil:
    section.add "X-Amz-Content-Sha256", valid_773847
  var valid_773848 = header.getOrDefault("X-Amz-Algorithm")
  valid_773848 = validateParameter(valid_773848, JString, required = false,
                                 default = nil)
  if valid_773848 != nil:
    section.add "X-Amz-Algorithm", valid_773848
  var valid_773849 = header.getOrDefault("X-Amz-Signature")
  valid_773849 = validateParameter(valid_773849, JString, required = false,
                                 default = nil)
  if valid_773849 != nil:
    section.add "X-Amz-Signature", valid_773849
  var valid_773850 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_773850 = validateParameter(valid_773850, JString, required = false,
                                 default = nil)
  if valid_773850 != nil:
    section.add "X-Amz-SignedHeaders", valid_773850
  var valid_773851 = header.getOrDefault("X-Amz-Credential")
  valid_773851 = validateParameter(valid_773851, JString, required = false,
                                 default = nil)
  if valid_773851 != nil:
    section.add "X-Amz-Credential", valid_773851
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_773852: Call_GetCreateSnapshotSchedule_773834; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a new snapshot schedule.
  ## 
  let valid = call_773852.validator(path, query, header, formData, body)
  let scheme = call_773852.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_773852.url(scheme.get, call_773852.host, call_773852.base,
                         call_773852.route, valid.getOrDefault("path"))
  result = hook(call_773852, url, valid)

proc call*(call_773853: Call_GetCreateSnapshotSchedule_773834;
          DryRun: bool = false; ScheduleDefinitions: JsonNode = nil;
          Tags: JsonNode = nil; Action: string = "CreateSnapshotSchedule";
          ScheduleIdentifier: string = ""; ScheduleDescription: string = "";
          NextInvocations: int = 0; Version: string = "2012-12-01"): Recallable =
  ## getCreateSnapshotSchedule
  ## Creates a new snapshot schedule.
  ##   DryRun: bool
  ##         : <p/>
  ##   ScheduleDefinitions: JArray
  ##                      : The definition of the snapshot schedule. The definition is made up of schedule expressions, for example "cron(30 12 *)" or "rate(12 hours)". 
  ##   Tags: JArray
  ##       : An optional set of tags you can use to search for the schedule.
  ##   Action: string (required)
  ##   ScheduleIdentifier: string
  ##                     : A unique identifier for a snapshot schedule. Only alphanumeric characters are allowed for the identifier.
  ##   ScheduleDescription: string
  ##                      : The description of the snapshot schedule.
  ##   NextInvocations: int
  ##                  : <p/>
  ##   Version: string (required)
  var query_773854 = newJObject()
  add(query_773854, "DryRun", newJBool(DryRun))
  if ScheduleDefinitions != nil:
    query_773854.add "ScheduleDefinitions", ScheduleDefinitions
  if Tags != nil:
    query_773854.add "Tags", Tags
  add(query_773854, "Action", newJString(Action))
  add(query_773854, "ScheduleIdentifier", newJString(ScheduleIdentifier))
  add(query_773854, "ScheduleDescription", newJString(ScheduleDescription))
  add(query_773854, "NextInvocations", newJInt(NextInvocations))
  add(query_773854, "Version", newJString(Version))
  result = call_773853.call(nil, query_773854, nil, nil, nil)

var getCreateSnapshotSchedule* = Call_GetCreateSnapshotSchedule_773834(
    name: "getCreateSnapshotSchedule", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=CreateSnapshotSchedule",
    validator: validate_GetCreateSnapshotSchedule_773835, base: "/",
    url: url_GetCreateSnapshotSchedule_773836,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCreateTags_773894 = ref object of OpenApiRestCall_772581
proc url_PostCreateTags_773896(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_PostCreateTags_773895(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode): JsonNode =
  ## <p>Adds one or more tags to a specified resource.</p> <p>A resource can have up to 50 tags. If you try to create more than 50 tags for a resource, you will receive an error and the attempt will fail.</p> <p>If you specify a key that already exists for the resource, the value for that key will be updated with the new value.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_773897 = query.getOrDefault("Action")
  valid_773897 = validateParameter(valid_773897, JString, required = true,
                                 default = newJString("CreateTags"))
  if valid_773897 != nil:
    section.add "Action", valid_773897
  var valid_773898 = query.getOrDefault("Version")
  valid_773898 = validateParameter(valid_773898, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_773898 != nil:
    section.add "Version", valid_773898
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_773899 = header.getOrDefault("X-Amz-Date")
  valid_773899 = validateParameter(valid_773899, JString, required = false,
                                 default = nil)
  if valid_773899 != nil:
    section.add "X-Amz-Date", valid_773899
  var valid_773900 = header.getOrDefault("X-Amz-Security-Token")
  valid_773900 = validateParameter(valid_773900, JString, required = false,
                                 default = nil)
  if valid_773900 != nil:
    section.add "X-Amz-Security-Token", valid_773900
  var valid_773901 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_773901 = validateParameter(valid_773901, JString, required = false,
                                 default = nil)
  if valid_773901 != nil:
    section.add "X-Amz-Content-Sha256", valid_773901
  var valid_773902 = header.getOrDefault("X-Amz-Algorithm")
  valid_773902 = validateParameter(valid_773902, JString, required = false,
                                 default = nil)
  if valid_773902 != nil:
    section.add "X-Amz-Algorithm", valid_773902
  var valid_773903 = header.getOrDefault("X-Amz-Signature")
  valid_773903 = validateParameter(valid_773903, JString, required = false,
                                 default = nil)
  if valid_773903 != nil:
    section.add "X-Amz-Signature", valid_773903
  var valid_773904 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_773904 = validateParameter(valid_773904, JString, required = false,
                                 default = nil)
  if valid_773904 != nil:
    section.add "X-Amz-SignedHeaders", valid_773904
  var valid_773905 = header.getOrDefault("X-Amz-Credential")
  valid_773905 = validateParameter(valid_773905, JString, required = false,
                                 default = nil)
  if valid_773905 != nil:
    section.add "X-Amz-Credential", valid_773905
  result.add "header", section
  ## parameters in `formData` object:
  ##   Tags: JArray (required)
  ##       : One or more name/value pairs to add as tags to the specified resource. Each tag name is passed in with the parameter <code>Key</code> and the corresponding value is passed in with the parameter <code>Value</code>. The <code>Key</code> and <code>Value</code> parameters are separated by a comma (,). Separate multiple tags with a space. For example, <code>--tags "Key"="owner","Value"="admin" "Key"="environment","Value"="test" "Key"="version","Value"="1.0"</code>. 
  ##   ResourceName: JString (required)
  ##               : The Amazon Resource Name (ARN) to which you want to add the tag or tags. For example, <code>arn:aws:redshift:us-east-1:123456789:cluster:t1</code>. 
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `Tags` field"
  var valid_773906 = formData.getOrDefault("Tags")
  valid_773906 = validateParameter(valid_773906, JArray, required = true, default = nil)
  if valid_773906 != nil:
    section.add "Tags", valid_773906
  var valid_773907 = formData.getOrDefault("ResourceName")
  valid_773907 = validateParameter(valid_773907, JString, required = true,
                                 default = nil)
  if valid_773907 != nil:
    section.add "ResourceName", valid_773907
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_773908: Call_PostCreateTags_773894; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Adds one or more tags to a specified resource.</p> <p>A resource can have up to 50 tags. If you try to create more than 50 tags for a resource, you will receive an error and the attempt will fail.</p> <p>If you specify a key that already exists for the resource, the value for that key will be updated with the new value.</p>
  ## 
  let valid = call_773908.validator(path, query, header, formData, body)
  let scheme = call_773908.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_773908.url(scheme.get, call_773908.host, call_773908.base,
                         call_773908.route, valid.getOrDefault("path"))
  result = hook(call_773908, url, valid)

proc call*(call_773909: Call_PostCreateTags_773894; Tags: JsonNode;
          ResourceName: string; Action: string = "CreateTags";
          Version: string = "2012-12-01"): Recallable =
  ## postCreateTags
  ## <p>Adds one or more tags to a specified resource.</p> <p>A resource can have up to 50 tags. If you try to create more than 50 tags for a resource, you will receive an error and the attempt will fail.</p> <p>If you specify a key that already exists for the resource, the value for that key will be updated with the new value.</p>
  ##   Tags: JArray (required)
  ##       : One or more name/value pairs to add as tags to the specified resource. Each tag name is passed in with the parameter <code>Key</code> and the corresponding value is passed in with the parameter <code>Value</code>. The <code>Key</code> and <code>Value</code> parameters are separated by a comma (,). Separate multiple tags with a space. For example, <code>--tags "Key"="owner","Value"="admin" "Key"="environment","Value"="test" "Key"="version","Value"="1.0"</code>. 
  ##   Action: string (required)
  ##   ResourceName: string (required)
  ##               : The Amazon Resource Name (ARN) to which you want to add the tag or tags. For example, <code>arn:aws:redshift:us-east-1:123456789:cluster:t1</code>. 
  ##   Version: string (required)
  var query_773910 = newJObject()
  var formData_773911 = newJObject()
  if Tags != nil:
    formData_773911.add "Tags", Tags
  add(query_773910, "Action", newJString(Action))
  add(formData_773911, "ResourceName", newJString(ResourceName))
  add(query_773910, "Version", newJString(Version))
  result = call_773909.call(nil, query_773910, nil, formData_773911, nil)

var postCreateTags* = Call_PostCreateTags_773894(name: "postCreateTags",
    meth: HttpMethod.HttpPost, host: "redshift.amazonaws.com",
    route: "/#Action=CreateTags", validator: validate_PostCreateTags_773895,
    base: "/", url: url_PostCreateTags_773896, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCreateTags_773877 = ref object of OpenApiRestCall_772581
proc url_GetCreateTags_773879(protocol: Scheme; host: string; base: string;
                             route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_GetCreateTags_773878(path: JsonNode; query: JsonNode; header: JsonNode;
                                  formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Adds one or more tags to a specified resource.</p> <p>A resource can have up to 50 tags. If you try to create more than 50 tags for a resource, you will receive an error and the attempt will fail.</p> <p>If you specify a key that already exists for the resource, the value for that key will be updated with the new value.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Tags: JArray (required)
  ##       : One or more name/value pairs to add as tags to the specified resource. Each tag name is passed in with the parameter <code>Key</code> and the corresponding value is passed in with the parameter <code>Value</code>. The <code>Key</code> and <code>Value</code> parameters are separated by a comma (,). Separate multiple tags with a space. For example, <code>--tags "Key"="owner","Value"="admin" "Key"="environment","Value"="test" "Key"="version","Value"="1.0"</code>. 
  ##   ResourceName: JString (required)
  ##               : The Amazon Resource Name (ARN) to which you want to add the tag or tags. For example, <code>arn:aws:redshift:us-east-1:123456789:cluster:t1</code>. 
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Tags` field"
  var valid_773880 = query.getOrDefault("Tags")
  valid_773880 = validateParameter(valid_773880, JArray, required = true, default = nil)
  if valid_773880 != nil:
    section.add "Tags", valid_773880
  var valid_773881 = query.getOrDefault("ResourceName")
  valid_773881 = validateParameter(valid_773881, JString, required = true,
                                 default = nil)
  if valid_773881 != nil:
    section.add "ResourceName", valid_773881
  var valid_773882 = query.getOrDefault("Action")
  valid_773882 = validateParameter(valid_773882, JString, required = true,
                                 default = newJString("CreateTags"))
  if valid_773882 != nil:
    section.add "Action", valid_773882
  var valid_773883 = query.getOrDefault("Version")
  valid_773883 = validateParameter(valid_773883, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_773883 != nil:
    section.add "Version", valid_773883
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_773884 = header.getOrDefault("X-Amz-Date")
  valid_773884 = validateParameter(valid_773884, JString, required = false,
                                 default = nil)
  if valid_773884 != nil:
    section.add "X-Amz-Date", valid_773884
  var valid_773885 = header.getOrDefault("X-Amz-Security-Token")
  valid_773885 = validateParameter(valid_773885, JString, required = false,
                                 default = nil)
  if valid_773885 != nil:
    section.add "X-Amz-Security-Token", valid_773885
  var valid_773886 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_773886 = validateParameter(valid_773886, JString, required = false,
                                 default = nil)
  if valid_773886 != nil:
    section.add "X-Amz-Content-Sha256", valid_773886
  var valid_773887 = header.getOrDefault("X-Amz-Algorithm")
  valid_773887 = validateParameter(valid_773887, JString, required = false,
                                 default = nil)
  if valid_773887 != nil:
    section.add "X-Amz-Algorithm", valid_773887
  var valid_773888 = header.getOrDefault("X-Amz-Signature")
  valid_773888 = validateParameter(valid_773888, JString, required = false,
                                 default = nil)
  if valid_773888 != nil:
    section.add "X-Amz-Signature", valid_773888
  var valid_773889 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_773889 = validateParameter(valid_773889, JString, required = false,
                                 default = nil)
  if valid_773889 != nil:
    section.add "X-Amz-SignedHeaders", valid_773889
  var valid_773890 = header.getOrDefault("X-Amz-Credential")
  valid_773890 = validateParameter(valid_773890, JString, required = false,
                                 default = nil)
  if valid_773890 != nil:
    section.add "X-Amz-Credential", valid_773890
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_773891: Call_GetCreateTags_773877; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Adds one or more tags to a specified resource.</p> <p>A resource can have up to 50 tags. If you try to create more than 50 tags for a resource, you will receive an error and the attempt will fail.</p> <p>If you specify a key that already exists for the resource, the value for that key will be updated with the new value.</p>
  ## 
  let valid = call_773891.validator(path, query, header, formData, body)
  let scheme = call_773891.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_773891.url(scheme.get, call_773891.host, call_773891.base,
                         call_773891.route, valid.getOrDefault("path"))
  result = hook(call_773891, url, valid)

proc call*(call_773892: Call_GetCreateTags_773877; Tags: JsonNode;
          ResourceName: string; Action: string = "CreateTags";
          Version: string = "2012-12-01"): Recallable =
  ## getCreateTags
  ## <p>Adds one or more tags to a specified resource.</p> <p>A resource can have up to 50 tags. If you try to create more than 50 tags for a resource, you will receive an error and the attempt will fail.</p> <p>If you specify a key that already exists for the resource, the value for that key will be updated with the new value.</p>
  ##   Tags: JArray (required)
  ##       : One or more name/value pairs to add as tags to the specified resource. Each tag name is passed in with the parameter <code>Key</code> and the corresponding value is passed in with the parameter <code>Value</code>. The <code>Key</code> and <code>Value</code> parameters are separated by a comma (,). Separate multiple tags with a space. For example, <code>--tags "Key"="owner","Value"="admin" "Key"="environment","Value"="test" "Key"="version","Value"="1.0"</code>. 
  ##   ResourceName: string (required)
  ##               : The Amazon Resource Name (ARN) to which you want to add the tag or tags. For example, <code>arn:aws:redshift:us-east-1:123456789:cluster:t1</code>. 
  ##   Action: string (required)
  ##   Version: string (required)
  var query_773893 = newJObject()
  if Tags != nil:
    query_773893.add "Tags", Tags
  add(query_773893, "ResourceName", newJString(ResourceName))
  add(query_773893, "Action", newJString(Action))
  add(query_773893, "Version", newJString(Version))
  result = call_773892.call(nil, query_773893, nil, nil, nil)

var getCreateTags* = Call_GetCreateTags_773877(name: "getCreateTags",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=CreateTags", validator: validate_GetCreateTags_773878,
    base: "/", url: url_GetCreateTags_773879, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDeleteCluster_773931 = ref object of OpenApiRestCall_772581
proc url_PostDeleteCluster_773933(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_PostDeleteCluster_773932(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## <p>Deletes a previously provisioned cluster. A successful response from the web service indicates that the request was received correctly. Use <a>DescribeClusters</a> to monitor the status of the deletion. The delete operation cannot be canceled or reverted once submitted. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you want to shut down the cluster and retain it for future use, set <i>SkipFinalClusterSnapshot</i> to <code>false</code> and specify a name for <i>FinalClusterSnapshotIdentifier</i>. You can later restore this snapshot to resume using the cluster. If a final cluster snapshot is requested, the status of the cluster will be "final-snapshot" while the snapshot is being taken, then it's "deleting" once Amazon Redshift begins deleting the cluster. </p> <p> For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_773934 = query.getOrDefault("Action")
  valid_773934 = validateParameter(valid_773934, JString, required = true,
                                 default = newJString("DeleteCluster"))
  if valid_773934 != nil:
    section.add "Action", valid_773934
  var valid_773935 = query.getOrDefault("Version")
  valid_773935 = validateParameter(valid_773935, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_773935 != nil:
    section.add "Version", valid_773935
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_773936 = header.getOrDefault("X-Amz-Date")
  valid_773936 = validateParameter(valid_773936, JString, required = false,
                                 default = nil)
  if valid_773936 != nil:
    section.add "X-Amz-Date", valid_773936
  var valid_773937 = header.getOrDefault("X-Amz-Security-Token")
  valid_773937 = validateParameter(valid_773937, JString, required = false,
                                 default = nil)
  if valid_773937 != nil:
    section.add "X-Amz-Security-Token", valid_773937
  var valid_773938 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_773938 = validateParameter(valid_773938, JString, required = false,
                                 default = nil)
  if valid_773938 != nil:
    section.add "X-Amz-Content-Sha256", valid_773938
  var valid_773939 = header.getOrDefault("X-Amz-Algorithm")
  valid_773939 = validateParameter(valid_773939, JString, required = false,
                                 default = nil)
  if valid_773939 != nil:
    section.add "X-Amz-Algorithm", valid_773939
  var valid_773940 = header.getOrDefault("X-Amz-Signature")
  valid_773940 = validateParameter(valid_773940, JString, required = false,
                                 default = nil)
  if valid_773940 != nil:
    section.add "X-Amz-Signature", valid_773940
  var valid_773941 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_773941 = validateParameter(valid_773941, JString, required = false,
                                 default = nil)
  if valid_773941 != nil:
    section.add "X-Amz-SignedHeaders", valid_773941
  var valid_773942 = header.getOrDefault("X-Amz-Credential")
  valid_773942 = validateParameter(valid_773942, JString, required = false,
                                 default = nil)
  if valid_773942 != nil:
    section.add "X-Amz-Credential", valid_773942
  result.add "header", section
  ## parameters in `formData` object:
  ##   FinalClusterSnapshotIdentifier: JString
  ##                                 : <p>The identifier of the final snapshot that is to be created immediately before deleting the cluster. If this parameter is provided, <i>SkipFinalClusterSnapshot</i> must be <code>false</code>. </p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   FinalClusterSnapshotRetentionPeriod: JInt
  ##                                      : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The identifier of the cluster to be deleted.</p> <p>Constraints:</p> <ul> <li> <p>Must contain lowercase characters.</p> </li> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   SkipFinalClusterSnapshot: JBool
  ##                           : <p>Determines whether a final snapshot of the cluster is created before Amazon Redshift deletes the cluster. If <code>true</code>, a final cluster snapshot is not created. If <code>false</code>, a final cluster snapshot is created before the cluster is deleted. </p> <note> <p>The <i>FinalClusterSnapshotIdentifier</i> parameter must be specified if <i>SkipFinalClusterSnapshot</i> is <code>false</code>.</p> </note> <p>Default: <code>false</code> </p>
  section = newJObject()
  var valid_773943 = formData.getOrDefault("FinalClusterSnapshotIdentifier")
  valid_773943 = validateParameter(valid_773943, JString, required = false,
                                 default = nil)
  if valid_773943 != nil:
    section.add "FinalClusterSnapshotIdentifier", valid_773943
  var valid_773944 = formData.getOrDefault("FinalClusterSnapshotRetentionPeriod")
  valid_773944 = validateParameter(valid_773944, JInt, required = false, default = nil)
  if valid_773944 != nil:
    section.add "FinalClusterSnapshotRetentionPeriod", valid_773944
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_773945 = formData.getOrDefault("ClusterIdentifier")
  valid_773945 = validateParameter(valid_773945, JString, required = true,
                                 default = nil)
  if valid_773945 != nil:
    section.add "ClusterIdentifier", valid_773945
  var valid_773946 = formData.getOrDefault("SkipFinalClusterSnapshot")
  valid_773946 = validateParameter(valid_773946, JBool, required = false, default = nil)
  if valid_773946 != nil:
    section.add "SkipFinalClusterSnapshot", valid_773946
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_773947: Call_PostDeleteCluster_773931; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Deletes a previously provisioned cluster. A successful response from the web service indicates that the request was received correctly. Use <a>DescribeClusters</a> to monitor the status of the deletion. The delete operation cannot be canceled or reverted once submitted. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you want to shut down the cluster and retain it for future use, set <i>SkipFinalClusterSnapshot</i> to <code>false</code> and specify a name for <i>FinalClusterSnapshotIdentifier</i>. You can later restore this snapshot to resume using the cluster. If a final cluster snapshot is requested, the status of the cluster will be "final-snapshot" while the snapshot is being taken, then it's "deleting" once Amazon Redshift begins deleting the cluster. </p> <p> For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_773947.validator(path, query, header, formData, body)
  let scheme = call_773947.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_773947.url(scheme.get, call_773947.host, call_773947.base,
                         call_773947.route, valid.getOrDefault("path"))
  result = hook(call_773947, url, valid)

proc call*(call_773948: Call_PostDeleteCluster_773931; ClusterIdentifier: string;
          FinalClusterSnapshotIdentifier: string = "";
          Action: string = "DeleteCluster";
          FinalClusterSnapshotRetentionPeriod: int = 0;
          SkipFinalClusterSnapshot: bool = false; Version: string = "2012-12-01"): Recallable =
  ## postDeleteCluster
  ## <p>Deletes a previously provisioned cluster. A successful response from the web service indicates that the request was received correctly. Use <a>DescribeClusters</a> to monitor the status of the deletion. The delete operation cannot be canceled or reverted once submitted. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you want to shut down the cluster and retain it for future use, set <i>SkipFinalClusterSnapshot</i> to <code>false</code> and specify a name for <i>FinalClusterSnapshotIdentifier</i>. You can later restore this snapshot to resume using the cluster. If a final cluster snapshot is requested, the status of the cluster will be "final-snapshot" while the snapshot is being taken, then it's "deleting" once Amazon Redshift begins deleting the cluster. </p> <p> For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   FinalClusterSnapshotIdentifier: string
  ##                                 : <p>The identifier of the final snapshot that is to be created immediately before deleting the cluster. If this parameter is provided, <i>SkipFinalClusterSnapshot</i> must be <code>false</code>. </p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   Action: string (required)
  ##   FinalClusterSnapshotRetentionPeriod: int
  ##                                      : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The identifier of the cluster to be deleted.</p> <p>Constraints:</p> <ul> <li> <p>Must contain lowercase characters.</p> </li> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   SkipFinalClusterSnapshot: bool
  ##                           : <p>Determines whether a final snapshot of the cluster is created before Amazon Redshift deletes the cluster. If <code>true</code>, a final cluster snapshot is not created. If <code>false</code>, a final cluster snapshot is created before the cluster is deleted. </p> <note> <p>The <i>FinalClusterSnapshotIdentifier</i> parameter must be specified if <i>SkipFinalClusterSnapshot</i> is <code>false</code>.</p> </note> <p>Default: <code>false</code> </p>
  ##   Version: string (required)
  var query_773949 = newJObject()
  var formData_773950 = newJObject()
  add(formData_773950, "FinalClusterSnapshotIdentifier",
      newJString(FinalClusterSnapshotIdentifier))
  add(query_773949, "Action", newJString(Action))
  add(formData_773950, "FinalClusterSnapshotRetentionPeriod",
      newJInt(FinalClusterSnapshotRetentionPeriod))
  add(formData_773950, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_773950, "SkipFinalClusterSnapshot",
      newJBool(SkipFinalClusterSnapshot))
  add(query_773949, "Version", newJString(Version))
  result = call_773948.call(nil, query_773949, nil, formData_773950, nil)

var postDeleteCluster* = Call_PostDeleteCluster_773931(name: "postDeleteCluster",
    meth: HttpMethod.HttpPost, host: "redshift.amazonaws.com",
    route: "/#Action=DeleteCluster", validator: validate_PostDeleteCluster_773932,
    base: "/", url: url_PostDeleteCluster_773933,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeleteCluster_773912 = ref object of OpenApiRestCall_772581
proc url_GetDeleteCluster_773914(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_GetDeleteCluster_773913(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## <p>Deletes a previously provisioned cluster. A successful response from the web service indicates that the request was received correctly. Use <a>DescribeClusters</a> to monitor the status of the deletion. The delete operation cannot be canceled or reverted once submitted. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you want to shut down the cluster and retain it for future use, set <i>SkipFinalClusterSnapshot</i> to <code>false</code> and specify a name for <i>FinalClusterSnapshotIdentifier</i>. You can later restore this snapshot to resume using the cluster. If a final cluster snapshot is requested, the status of the cluster will be "final-snapshot" while the snapshot is being taken, then it's "deleting" once Amazon Redshift begins deleting the cluster. </p> <p> For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   FinalClusterSnapshotRetentionPeriod: JInt
  ##                                      : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The identifier of the cluster to be deleted.</p> <p>Constraints:</p> <ul> <li> <p>Must contain lowercase characters.</p> </li> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   SkipFinalClusterSnapshot: JBool
  ##                           : <p>Determines whether a final snapshot of the cluster is created before Amazon Redshift deletes the cluster. If <code>true</code>, a final cluster snapshot is not created. If <code>false</code>, a final cluster snapshot is created before the cluster is deleted. </p> <note> <p>The <i>FinalClusterSnapshotIdentifier</i> parameter must be specified if <i>SkipFinalClusterSnapshot</i> is <code>false</code>.</p> </note> <p>Default: <code>false</code> </p>
  ##   FinalClusterSnapshotIdentifier: JString
  ##                                 : <p>The identifier of the final snapshot that is to be created immediately before deleting the cluster. If this parameter is provided, <i>SkipFinalClusterSnapshot</i> must be <code>false</code>. </p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   Version: JString (required)
  section = newJObject()
  var valid_773915 = query.getOrDefault("FinalClusterSnapshotRetentionPeriod")
  valid_773915 = validateParameter(valid_773915, JInt, required = false, default = nil)
  if valid_773915 != nil:
    section.add "FinalClusterSnapshotRetentionPeriod", valid_773915
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_773916 = query.getOrDefault("Action")
  valid_773916 = validateParameter(valid_773916, JString, required = true,
                                 default = newJString("DeleteCluster"))
  if valid_773916 != nil:
    section.add "Action", valid_773916
  var valid_773917 = query.getOrDefault("ClusterIdentifier")
  valid_773917 = validateParameter(valid_773917, JString, required = true,
                                 default = nil)
  if valid_773917 != nil:
    section.add "ClusterIdentifier", valid_773917
  var valid_773918 = query.getOrDefault("SkipFinalClusterSnapshot")
  valid_773918 = validateParameter(valid_773918, JBool, required = false, default = nil)
  if valid_773918 != nil:
    section.add "SkipFinalClusterSnapshot", valid_773918
  var valid_773919 = query.getOrDefault("FinalClusterSnapshotIdentifier")
  valid_773919 = validateParameter(valid_773919, JString, required = false,
                                 default = nil)
  if valid_773919 != nil:
    section.add "FinalClusterSnapshotIdentifier", valid_773919
  var valid_773920 = query.getOrDefault("Version")
  valid_773920 = validateParameter(valid_773920, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_773920 != nil:
    section.add "Version", valid_773920
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_773921 = header.getOrDefault("X-Amz-Date")
  valid_773921 = validateParameter(valid_773921, JString, required = false,
                                 default = nil)
  if valid_773921 != nil:
    section.add "X-Amz-Date", valid_773921
  var valid_773922 = header.getOrDefault("X-Amz-Security-Token")
  valid_773922 = validateParameter(valid_773922, JString, required = false,
                                 default = nil)
  if valid_773922 != nil:
    section.add "X-Amz-Security-Token", valid_773922
  var valid_773923 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_773923 = validateParameter(valid_773923, JString, required = false,
                                 default = nil)
  if valid_773923 != nil:
    section.add "X-Amz-Content-Sha256", valid_773923
  var valid_773924 = header.getOrDefault("X-Amz-Algorithm")
  valid_773924 = validateParameter(valid_773924, JString, required = false,
                                 default = nil)
  if valid_773924 != nil:
    section.add "X-Amz-Algorithm", valid_773924
  var valid_773925 = header.getOrDefault("X-Amz-Signature")
  valid_773925 = validateParameter(valid_773925, JString, required = false,
                                 default = nil)
  if valid_773925 != nil:
    section.add "X-Amz-Signature", valid_773925
  var valid_773926 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_773926 = validateParameter(valid_773926, JString, required = false,
                                 default = nil)
  if valid_773926 != nil:
    section.add "X-Amz-SignedHeaders", valid_773926
  var valid_773927 = header.getOrDefault("X-Amz-Credential")
  valid_773927 = validateParameter(valid_773927, JString, required = false,
                                 default = nil)
  if valid_773927 != nil:
    section.add "X-Amz-Credential", valid_773927
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_773928: Call_GetDeleteCluster_773912; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Deletes a previously provisioned cluster. A successful response from the web service indicates that the request was received correctly. Use <a>DescribeClusters</a> to monitor the status of the deletion. The delete operation cannot be canceled or reverted once submitted. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you want to shut down the cluster and retain it for future use, set <i>SkipFinalClusterSnapshot</i> to <code>false</code> and specify a name for <i>FinalClusterSnapshotIdentifier</i>. You can later restore this snapshot to resume using the cluster. If a final cluster snapshot is requested, the status of the cluster will be "final-snapshot" while the snapshot is being taken, then it's "deleting" once Amazon Redshift begins deleting the cluster. </p> <p> For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_773928.validator(path, query, header, formData, body)
  let scheme = call_773928.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_773928.url(scheme.get, call_773928.host, call_773928.base,
                         call_773928.route, valid.getOrDefault("path"))
  result = hook(call_773928, url, valid)

proc call*(call_773929: Call_GetDeleteCluster_773912; ClusterIdentifier: string;
          FinalClusterSnapshotRetentionPeriod: int = 0;
          Action: string = "DeleteCluster"; SkipFinalClusterSnapshot: bool = false;
          FinalClusterSnapshotIdentifier: string = "";
          Version: string = "2012-12-01"): Recallable =
  ## getDeleteCluster
  ## <p>Deletes a previously provisioned cluster. A successful response from the web service indicates that the request was received correctly. Use <a>DescribeClusters</a> to monitor the status of the deletion. The delete operation cannot be canceled or reverted once submitted. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you want to shut down the cluster and retain it for future use, set <i>SkipFinalClusterSnapshot</i> to <code>false</code> and specify a name for <i>FinalClusterSnapshotIdentifier</i>. You can later restore this snapshot to resume using the cluster. If a final cluster snapshot is requested, the status of the cluster will be "final-snapshot" while the snapshot is being taken, then it's "deleting" once Amazon Redshift begins deleting the cluster. </p> <p> For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   FinalClusterSnapshotRetentionPeriod: int
  ##                                      : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The identifier of the cluster to be deleted.</p> <p>Constraints:</p> <ul> <li> <p>Must contain lowercase characters.</p> </li> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   SkipFinalClusterSnapshot: bool
  ##                           : <p>Determines whether a final snapshot of the cluster is created before Amazon Redshift deletes the cluster. If <code>true</code>, a final cluster snapshot is not created. If <code>false</code>, a final cluster snapshot is created before the cluster is deleted. </p> <note> <p>The <i>FinalClusterSnapshotIdentifier</i> parameter must be specified if <i>SkipFinalClusterSnapshot</i> is <code>false</code>.</p> </note> <p>Default: <code>false</code> </p>
  ##   FinalClusterSnapshotIdentifier: string
  ##                                 : <p>The identifier of the final snapshot that is to be created immediately before deleting the cluster. If this parameter is provided, <i>SkipFinalClusterSnapshot</i> must be <code>false</code>. </p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   Version: string (required)
  var query_773930 = newJObject()
  add(query_773930, "FinalClusterSnapshotRetentionPeriod",
      newJInt(FinalClusterSnapshotRetentionPeriod))
  add(query_773930, "Action", newJString(Action))
  add(query_773930, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_773930, "SkipFinalClusterSnapshot", newJBool(SkipFinalClusterSnapshot))
  add(query_773930, "FinalClusterSnapshotIdentifier",
      newJString(FinalClusterSnapshotIdentifier))
  add(query_773930, "Version", newJString(Version))
  result = call_773929.call(nil, query_773930, nil, nil, nil)

var getDeleteCluster* = Call_GetDeleteCluster_773912(name: "getDeleteCluster",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=DeleteCluster", validator: validate_GetDeleteCluster_773913,
    base: "/", url: url_GetDeleteCluster_773914,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDeleteClusterParameterGroup_773967 = ref object of OpenApiRestCall_772581
proc url_PostDeleteClusterParameterGroup_773969(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_PostDeleteClusterParameterGroup_773968(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Deletes a specified Amazon Redshift parameter group.</p> <note> <p>You cannot delete a parameter group if it is associated with a cluster.</p> </note>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_773970 = query.getOrDefault("Action")
  valid_773970 = validateParameter(valid_773970, JString, required = true, default = newJString(
      "DeleteClusterParameterGroup"))
  if valid_773970 != nil:
    section.add "Action", valid_773970
  var valid_773971 = query.getOrDefault("Version")
  valid_773971 = validateParameter(valid_773971, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_773971 != nil:
    section.add "Version", valid_773971
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_773972 = header.getOrDefault("X-Amz-Date")
  valid_773972 = validateParameter(valid_773972, JString, required = false,
                                 default = nil)
  if valid_773972 != nil:
    section.add "X-Amz-Date", valid_773972
  var valid_773973 = header.getOrDefault("X-Amz-Security-Token")
  valid_773973 = validateParameter(valid_773973, JString, required = false,
                                 default = nil)
  if valid_773973 != nil:
    section.add "X-Amz-Security-Token", valid_773973
  var valid_773974 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_773974 = validateParameter(valid_773974, JString, required = false,
                                 default = nil)
  if valid_773974 != nil:
    section.add "X-Amz-Content-Sha256", valid_773974
  var valid_773975 = header.getOrDefault("X-Amz-Algorithm")
  valid_773975 = validateParameter(valid_773975, JString, required = false,
                                 default = nil)
  if valid_773975 != nil:
    section.add "X-Amz-Algorithm", valid_773975
  var valid_773976 = header.getOrDefault("X-Amz-Signature")
  valid_773976 = validateParameter(valid_773976, JString, required = false,
                                 default = nil)
  if valid_773976 != nil:
    section.add "X-Amz-Signature", valid_773976
  var valid_773977 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_773977 = validateParameter(valid_773977, JString, required = false,
                                 default = nil)
  if valid_773977 != nil:
    section.add "X-Amz-SignedHeaders", valid_773977
  var valid_773978 = header.getOrDefault("X-Amz-Credential")
  valid_773978 = validateParameter(valid_773978, JString, required = false,
                                 default = nil)
  if valid_773978 != nil:
    section.add "X-Amz-Credential", valid_773978
  result.add "header", section
  ## parameters in `formData` object:
  ##   ParameterGroupName: JString (required)
  ##                     : <p>The name of the parameter group to be deleted.</p> <p>Constraints:</p> <ul> <li> <p>Must be the name of an existing cluster parameter group.</p> </li> <li> <p>Cannot delete a default cluster parameter group.</p> </li> </ul>
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ParameterGroupName` field"
  var valid_773979 = formData.getOrDefault("ParameterGroupName")
  valid_773979 = validateParameter(valid_773979, JString, required = true,
                                 default = nil)
  if valid_773979 != nil:
    section.add "ParameterGroupName", valid_773979
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_773980: Call_PostDeleteClusterParameterGroup_773967;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Deletes a specified Amazon Redshift parameter group.</p> <note> <p>You cannot delete a parameter group if it is associated with a cluster.</p> </note>
  ## 
  let valid = call_773980.validator(path, query, header, formData, body)
  let scheme = call_773980.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_773980.url(scheme.get, call_773980.host, call_773980.base,
                         call_773980.route, valid.getOrDefault("path"))
  result = hook(call_773980, url, valid)

proc call*(call_773981: Call_PostDeleteClusterParameterGroup_773967;
          ParameterGroupName: string;
          Action: string = "DeleteClusterParameterGroup";
          Version: string = "2012-12-01"): Recallable =
  ## postDeleteClusterParameterGroup
  ## <p>Deletes a specified Amazon Redshift parameter group.</p> <note> <p>You cannot delete a parameter group if it is associated with a cluster.</p> </note>
  ##   ParameterGroupName: string (required)
  ##                     : <p>The name of the parameter group to be deleted.</p> <p>Constraints:</p> <ul> <li> <p>Must be the name of an existing cluster parameter group.</p> </li> <li> <p>Cannot delete a default cluster parameter group.</p> </li> </ul>
  ##   Action: string (required)
  ##   Version: string (required)
  var query_773982 = newJObject()
  var formData_773983 = newJObject()
  add(formData_773983, "ParameterGroupName", newJString(ParameterGroupName))
  add(query_773982, "Action", newJString(Action))
  add(query_773982, "Version", newJString(Version))
  result = call_773981.call(nil, query_773982, nil, formData_773983, nil)

var postDeleteClusterParameterGroup* = Call_PostDeleteClusterParameterGroup_773967(
    name: "postDeleteClusterParameterGroup", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteClusterParameterGroup",
    validator: validate_PostDeleteClusterParameterGroup_773968, base: "/",
    url: url_PostDeleteClusterParameterGroup_773969,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeleteClusterParameterGroup_773951 = ref object of OpenApiRestCall_772581
proc url_GetDeleteClusterParameterGroup_773953(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_GetDeleteClusterParameterGroup_773952(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Deletes a specified Amazon Redshift parameter group.</p> <note> <p>You cannot delete a parameter group if it is associated with a cluster.</p> </note>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ParameterGroupName: JString (required)
  ##                     : <p>The name of the parameter group to be deleted.</p> <p>Constraints:</p> <ul> <li> <p>Must be the name of an existing cluster parameter group.</p> </li> <li> <p>Cannot delete a default cluster parameter group.</p> </li> </ul>
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `ParameterGroupName` field"
  var valid_773954 = query.getOrDefault("ParameterGroupName")
  valid_773954 = validateParameter(valid_773954, JString, required = true,
                                 default = nil)
  if valid_773954 != nil:
    section.add "ParameterGroupName", valid_773954
  var valid_773955 = query.getOrDefault("Action")
  valid_773955 = validateParameter(valid_773955, JString, required = true, default = newJString(
      "DeleteClusterParameterGroup"))
  if valid_773955 != nil:
    section.add "Action", valid_773955
  var valid_773956 = query.getOrDefault("Version")
  valid_773956 = validateParameter(valid_773956, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_773956 != nil:
    section.add "Version", valid_773956
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_773957 = header.getOrDefault("X-Amz-Date")
  valid_773957 = validateParameter(valid_773957, JString, required = false,
                                 default = nil)
  if valid_773957 != nil:
    section.add "X-Amz-Date", valid_773957
  var valid_773958 = header.getOrDefault("X-Amz-Security-Token")
  valid_773958 = validateParameter(valid_773958, JString, required = false,
                                 default = nil)
  if valid_773958 != nil:
    section.add "X-Amz-Security-Token", valid_773958
  var valid_773959 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_773959 = validateParameter(valid_773959, JString, required = false,
                                 default = nil)
  if valid_773959 != nil:
    section.add "X-Amz-Content-Sha256", valid_773959
  var valid_773960 = header.getOrDefault("X-Amz-Algorithm")
  valid_773960 = validateParameter(valid_773960, JString, required = false,
                                 default = nil)
  if valid_773960 != nil:
    section.add "X-Amz-Algorithm", valid_773960
  var valid_773961 = header.getOrDefault("X-Amz-Signature")
  valid_773961 = validateParameter(valid_773961, JString, required = false,
                                 default = nil)
  if valid_773961 != nil:
    section.add "X-Amz-Signature", valid_773961
  var valid_773962 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_773962 = validateParameter(valid_773962, JString, required = false,
                                 default = nil)
  if valid_773962 != nil:
    section.add "X-Amz-SignedHeaders", valid_773962
  var valid_773963 = header.getOrDefault("X-Amz-Credential")
  valid_773963 = validateParameter(valid_773963, JString, required = false,
                                 default = nil)
  if valid_773963 != nil:
    section.add "X-Amz-Credential", valid_773963
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_773964: Call_GetDeleteClusterParameterGroup_773951; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Deletes a specified Amazon Redshift parameter group.</p> <note> <p>You cannot delete a parameter group if it is associated with a cluster.</p> </note>
  ## 
  let valid = call_773964.validator(path, query, header, formData, body)
  let scheme = call_773964.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_773964.url(scheme.get, call_773964.host, call_773964.base,
                         call_773964.route, valid.getOrDefault("path"))
  result = hook(call_773964, url, valid)

proc call*(call_773965: Call_GetDeleteClusterParameterGroup_773951;
          ParameterGroupName: string;
          Action: string = "DeleteClusterParameterGroup";
          Version: string = "2012-12-01"): Recallable =
  ## getDeleteClusterParameterGroup
  ## <p>Deletes a specified Amazon Redshift parameter group.</p> <note> <p>You cannot delete a parameter group if it is associated with a cluster.</p> </note>
  ##   ParameterGroupName: string (required)
  ##                     : <p>The name of the parameter group to be deleted.</p> <p>Constraints:</p> <ul> <li> <p>Must be the name of an existing cluster parameter group.</p> </li> <li> <p>Cannot delete a default cluster parameter group.</p> </li> </ul>
  ##   Action: string (required)
  ##   Version: string (required)
  var query_773966 = newJObject()
  add(query_773966, "ParameterGroupName", newJString(ParameterGroupName))
  add(query_773966, "Action", newJString(Action))
  add(query_773966, "Version", newJString(Version))
  result = call_773965.call(nil, query_773966, nil, nil, nil)

var getDeleteClusterParameterGroup* = Call_GetDeleteClusterParameterGroup_773951(
    name: "getDeleteClusterParameterGroup", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteClusterParameterGroup",
    validator: validate_GetDeleteClusterParameterGroup_773952, base: "/",
    url: url_GetDeleteClusterParameterGroup_773953,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDeleteClusterSecurityGroup_774000 = ref object of OpenApiRestCall_772581
proc url_PostDeleteClusterSecurityGroup_774002(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_PostDeleteClusterSecurityGroup_774001(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Deletes an Amazon Redshift security group.</p> <note> <p>You cannot delete a security group that is associated with any clusters. You cannot delete the default security group.</p> </note> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_774003 = query.getOrDefault("Action")
  valid_774003 = validateParameter(valid_774003, JString, required = true, default = newJString(
      "DeleteClusterSecurityGroup"))
  if valid_774003 != nil:
    section.add "Action", valid_774003
  var valid_774004 = query.getOrDefault("Version")
  valid_774004 = validateParameter(valid_774004, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_774004 != nil:
    section.add "Version", valid_774004
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_774005 = header.getOrDefault("X-Amz-Date")
  valid_774005 = validateParameter(valid_774005, JString, required = false,
                                 default = nil)
  if valid_774005 != nil:
    section.add "X-Amz-Date", valid_774005
  var valid_774006 = header.getOrDefault("X-Amz-Security-Token")
  valid_774006 = validateParameter(valid_774006, JString, required = false,
                                 default = nil)
  if valid_774006 != nil:
    section.add "X-Amz-Security-Token", valid_774006
  var valid_774007 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_774007 = validateParameter(valid_774007, JString, required = false,
                                 default = nil)
  if valid_774007 != nil:
    section.add "X-Amz-Content-Sha256", valid_774007
  var valid_774008 = header.getOrDefault("X-Amz-Algorithm")
  valid_774008 = validateParameter(valid_774008, JString, required = false,
                                 default = nil)
  if valid_774008 != nil:
    section.add "X-Amz-Algorithm", valid_774008
  var valid_774009 = header.getOrDefault("X-Amz-Signature")
  valid_774009 = validateParameter(valid_774009, JString, required = false,
                                 default = nil)
  if valid_774009 != nil:
    section.add "X-Amz-Signature", valid_774009
  var valid_774010 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_774010 = validateParameter(valid_774010, JString, required = false,
                                 default = nil)
  if valid_774010 != nil:
    section.add "X-Amz-SignedHeaders", valid_774010
  var valid_774011 = header.getOrDefault("X-Amz-Credential")
  valid_774011 = validateParameter(valid_774011, JString, required = false,
                                 default = nil)
  if valid_774011 != nil:
    section.add "X-Amz-Credential", valid_774011
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterSecurityGroupName: JString (required)
  ##                           : The name of the cluster security group to be deleted.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterSecurityGroupName` field"
  var valid_774012 = formData.getOrDefault("ClusterSecurityGroupName")
  valid_774012 = validateParameter(valid_774012, JString, required = true,
                                 default = nil)
  if valid_774012 != nil:
    section.add "ClusterSecurityGroupName", valid_774012
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_774013: Call_PostDeleteClusterSecurityGroup_774000; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Deletes an Amazon Redshift security group.</p> <note> <p>You cannot delete a security group that is associated with any clusters. You cannot delete the default security group.</p> </note> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_774013.validator(path, query, header, formData, body)
  let scheme = call_774013.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_774013.url(scheme.get, call_774013.host, call_774013.base,
                         call_774013.route, valid.getOrDefault("path"))
  result = hook(call_774013, url, valid)

proc call*(call_774014: Call_PostDeleteClusterSecurityGroup_774000;
          ClusterSecurityGroupName: string;
          Action: string = "DeleteClusterSecurityGroup";
          Version: string = "2012-12-01"): Recallable =
  ## postDeleteClusterSecurityGroup
  ## <p>Deletes an Amazon Redshift security group.</p> <note> <p>You cannot delete a security group that is associated with any clusters. You cannot delete the default security group.</p> </note> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   Action: string (required)
  ##   Version: string (required)
  ##   ClusterSecurityGroupName: string (required)
  ##                           : The name of the cluster security group to be deleted.
  var query_774015 = newJObject()
  var formData_774016 = newJObject()
  add(query_774015, "Action", newJString(Action))
  add(query_774015, "Version", newJString(Version))
  add(formData_774016, "ClusterSecurityGroupName",
      newJString(ClusterSecurityGroupName))
  result = call_774014.call(nil, query_774015, nil, formData_774016, nil)

var postDeleteClusterSecurityGroup* = Call_PostDeleteClusterSecurityGroup_774000(
    name: "postDeleteClusterSecurityGroup", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteClusterSecurityGroup",
    validator: validate_PostDeleteClusterSecurityGroup_774001, base: "/",
    url: url_PostDeleteClusterSecurityGroup_774002,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeleteClusterSecurityGroup_773984 = ref object of OpenApiRestCall_772581
proc url_GetDeleteClusterSecurityGroup_773986(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_GetDeleteClusterSecurityGroup_773985(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Deletes an Amazon Redshift security group.</p> <note> <p>You cannot delete a security group that is associated with any clusters. You cannot delete the default security group.</p> </note> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ClusterSecurityGroupName: JString (required)
  ##                           : The name of the cluster security group to be deleted.
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `ClusterSecurityGroupName` field"
  var valid_773987 = query.getOrDefault("ClusterSecurityGroupName")
  valid_773987 = validateParameter(valid_773987, JString, required = true,
                                 default = nil)
  if valid_773987 != nil:
    section.add "ClusterSecurityGroupName", valid_773987
  var valid_773988 = query.getOrDefault("Action")
  valid_773988 = validateParameter(valid_773988, JString, required = true, default = newJString(
      "DeleteClusterSecurityGroup"))
  if valid_773988 != nil:
    section.add "Action", valid_773988
  var valid_773989 = query.getOrDefault("Version")
  valid_773989 = validateParameter(valid_773989, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_773989 != nil:
    section.add "Version", valid_773989
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_773990 = header.getOrDefault("X-Amz-Date")
  valid_773990 = validateParameter(valid_773990, JString, required = false,
                                 default = nil)
  if valid_773990 != nil:
    section.add "X-Amz-Date", valid_773990
  var valid_773991 = header.getOrDefault("X-Amz-Security-Token")
  valid_773991 = validateParameter(valid_773991, JString, required = false,
                                 default = nil)
  if valid_773991 != nil:
    section.add "X-Amz-Security-Token", valid_773991
  var valid_773992 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_773992 = validateParameter(valid_773992, JString, required = false,
                                 default = nil)
  if valid_773992 != nil:
    section.add "X-Amz-Content-Sha256", valid_773992
  var valid_773993 = header.getOrDefault("X-Amz-Algorithm")
  valid_773993 = validateParameter(valid_773993, JString, required = false,
                                 default = nil)
  if valid_773993 != nil:
    section.add "X-Amz-Algorithm", valid_773993
  var valid_773994 = header.getOrDefault("X-Amz-Signature")
  valid_773994 = validateParameter(valid_773994, JString, required = false,
                                 default = nil)
  if valid_773994 != nil:
    section.add "X-Amz-Signature", valid_773994
  var valid_773995 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_773995 = validateParameter(valid_773995, JString, required = false,
                                 default = nil)
  if valid_773995 != nil:
    section.add "X-Amz-SignedHeaders", valid_773995
  var valid_773996 = header.getOrDefault("X-Amz-Credential")
  valid_773996 = validateParameter(valid_773996, JString, required = false,
                                 default = nil)
  if valid_773996 != nil:
    section.add "X-Amz-Credential", valid_773996
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_773997: Call_GetDeleteClusterSecurityGroup_773984; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Deletes an Amazon Redshift security group.</p> <note> <p>You cannot delete a security group that is associated with any clusters. You cannot delete the default security group.</p> </note> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_773997.validator(path, query, header, formData, body)
  let scheme = call_773997.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_773997.url(scheme.get, call_773997.host, call_773997.base,
                         call_773997.route, valid.getOrDefault("path"))
  result = hook(call_773997, url, valid)

proc call*(call_773998: Call_GetDeleteClusterSecurityGroup_773984;
          ClusterSecurityGroupName: string;
          Action: string = "DeleteClusterSecurityGroup";
          Version: string = "2012-12-01"): Recallable =
  ## getDeleteClusterSecurityGroup
  ## <p>Deletes an Amazon Redshift security group.</p> <note> <p>You cannot delete a security group that is associated with any clusters. You cannot delete the default security group.</p> </note> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   ClusterSecurityGroupName: string (required)
  ##                           : The name of the cluster security group to be deleted.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_773999 = newJObject()
  add(query_773999, "ClusterSecurityGroupName",
      newJString(ClusterSecurityGroupName))
  add(query_773999, "Action", newJString(Action))
  add(query_773999, "Version", newJString(Version))
  result = call_773998.call(nil, query_773999, nil, nil, nil)

var getDeleteClusterSecurityGroup* = Call_GetDeleteClusterSecurityGroup_773984(
    name: "getDeleteClusterSecurityGroup", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteClusterSecurityGroup",
    validator: validate_GetDeleteClusterSecurityGroup_773985, base: "/",
    url: url_GetDeleteClusterSecurityGroup_773986,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDeleteClusterSnapshot_774034 = ref object of OpenApiRestCall_772581
proc url_PostDeleteClusterSnapshot_774036(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_PostDeleteClusterSnapshot_774035(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Deletes the specified manual snapshot. The snapshot must be in the <code>available</code> state, with no other users authorized to access the snapshot. </p> <p>Unlike automated snapshots, manual snapshots are retained even after you delete your cluster. Amazon Redshift does not delete your manual snapshots. You must delete manual snapshot explicitly to avoid getting charged. If other accounts are authorized to access the snapshot, you must revoke all of the authorizations before you can delete the snapshot.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_774037 = query.getOrDefault("Action")
  valid_774037 = validateParameter(valid_774037, JString, required = true,
                                 default = newJString("DeleteClusterSnapshot"))
  if valid_774037 != nil:
    section.add "Action", valid_774037
  var valid_774038 = query.getOrDefault("Version")
  valid_774038 = validateParameter(valid_774038, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_774038 != nil:
    section.add "Version", valid_774038
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_774039 = header.getOrDefault("X-Amz-Date")
  valid_774039 = validateParameter(valid_774039, JString, required = false,
                                 default = nil)
  if valid_774039 != nil:
    section.add "X-Amz-Date", valid_774039
  var valid_774040 = header.getOrDefault("X-Amz-Security-Token")
  valid_774040 = validateParameter(valid_774040, JString, required = false,
                                 default = nil)
  if valid_774040 != nil:
    section.add "X-Amz-Security-Token", valid_774040
  var valid_774041 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_774041 = validateParameter(valid_774041, JString, required = false,
                                 default = nil)
  if valid_774041 != nil:
    section.add "X-Amz-Content-Sha256", valid_774041
  var valid_774042 = header.getOrDefault("X-Amz-Algorithm")
  valid_774042 = validateParameter(valid_774042, JString, required = false,
                                 default = nil)
  if valid_774042 != nil:
    section.add "X-Amz-Algorithm", valid_774042
  var valid_774043 = header.getOrDefault("X-Amz-Signature")
  valid_774043 = validateParameter(valid_774043, JString, required = false,
                                 default = nil)
  if valid_774043 != nil:
    section.add "X-Amz-Signature", valid_774043
  var valid_774044 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_774044 = validateParameter(valid_774044, JString, required = false,
                                 default = nil)
  if valid_774044 != nil:
    section.add "X-Amz-SignedHeaders", valid_774044
  var valid_774045 = header.getOrDefault("X-Amz-Credential")
  valid_774045 = validateParameter(valid_774045, JString, required = false,
                                 default = nil)
  if valid_774045 != nil:
    section.add "X-Amz-Credential", valid_774045
  result.add "header", section
  ## parameters in `formData` object:
  ##   SnapshotClusterIdentifier: JString
  ##                            : <p>The unique identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.</p> <p>Constraints: Must be the name of valid cluster.</p>
  ##   SnapshotIdentifier: JString (required)
  ##                     : <p>The unique identifier of the manual snapshot to be deleted.</p> <p>Constraints: Must be the name of an existing snapshot that is in the <code>available</code>, <code>failed</code>, or <code>cancelled</code> state.</p>
  section = newJObject()
  var valid_774046 = formData.getOrDefault("SnapshotClusterIdentifier")
  valid_774046 = validateParameter(valid_774046, JString, required = false,
                                 default = nil)
  if valid_774046 != nil:
    section.add "SnapshotClusterIdentifier", valid_774046
  assert formData != nil, "formData argument is necessary due to required `SnapshotIdentifier` field"
  var valid_774047 = formData.getOrDefault("SnapshotIdentifier")
  valid_774047 = validateParameter(valid_774047, JString, required = true,
                                 default = nil)
  if valid_774047 != nil:
    section.add "SnapshotIdentifier", valid_774047
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_774048: Call_PostDeleteClusterSnapshot_774034; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Deletes the specified manual snapshot. The snapshot must be in the <code>available</code> state, with no other users authorized to access the snapshot. </p> <p>Unlike automated snapshots, manual snapshots are retained even after you delete your cluster. Amazon Redshift does not delete your manual snapshots. You must delete manual snapshot explicitly to avoid getting charged. If other accounts are authorized to access the snapshot, you must revoke all of the authorizations before you can delete the snapshot.</p>
  ## 
  let valid = call_774048.validator(path, query, header, formData, body)
  let scheme = call_774048.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_774048.url(scheme.get, call_774048.host, call_774048.base,
                         call_774048.route, valid.getOrDefault("path"))
  result = hook(call_774048, url, valid)

proc call*(call_774049: Call_PostDeleteClusterSnapshot_774034;
          SnapshotIdentifier: string; SnapshotClusterIdentifier: string = "";
          Action: string = "DeleteClusterSnapshot"; Version: string = "2012-12-01"): Recallable =
  ## postDeleteClusterSnapshot
  ## <p>Deletes the specified manual snapshot. The snapshot must be in the <code>available</code> state, with no other users authorized to access the snapshot. </p> <p>Unlike automated snapshots, manual snapshots are retained even after you delete your cluster. Amazon Redshift does not delete your manual snapshots. You must delete manual snapshot explicitly to avoid getting charged. If other accounts are authorized to access the snapshot, you must revoke all of the authorizations before you can delete the snapshot.</p>
  ##   SnapshotClusterIdentifier: string
  ##                            : <p>The unique identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.</p> <p>Constraints: Must be the name of valid cluster.</p>
  ##   Action: string (required)
  ##   SnapshotIdentifier: string (required)
  ##                     : <p>The unique identifier of the manual snapshot to be deleted.</p> <p>Constraints: Must be the name of an existing snapshot that is in the <code>available</code>, <code>failed</code>, or <code>cancelled</code> state.</p>
  ##   Version: string (required)
  var query_774050 = newJObject()
  var formData_774051 = newJObject()
  add(formData_774051, "SnapshotClusterIdentifier",
      newJString(SnapshotClusterIdentifier))
  add(query_774050, "Action", newJString(Action))
  add(formData_774051, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_774050, "Version", newJString(Version))
  result = call_774049.call(nil, query_774050, nil, formData_774051, nil)

var postDeleteClusterSnapshot* = Call_PostDeleteClusterSnapshot_774034(
    name: "postDeleteClusterSnapshot", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteClusterSnapshot",
    validator: validate_PostDeleteClusterSnapshot_774035, base: "/",
    url: url_PostDeleteClusterSnapshot_774036,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeleteClusterSnapshot_774017 = ref object of OpenApiRestCall_772581
proc url_GetDeleteClusterSnapshot_774019(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_GetDeleteClusterSnapshot_774018(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Deletes the specified manual snapshot. The snapshot must be in the <code>available</code> state, with no other users authorized to access the snapshot. </p> <p>Unlike automated snapshots, manual snapshots are retained even after you delete your cluster. Amazon Redshift does not delete your manual snapshots. You must delete manual snapshot explicitly to avoid getting charged. If other accounts are authorized to access the snapshot, you must revoke all of the authorizations before you can delete the snapshot.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   SnapshotClusterIdentifier: JString
  ##                            : <p>The unique identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.</p> <p>Constraints: Must be the name of valid cluster.</p>
  ##   SnapshotIdentifier: JString (required)
  ##                     : <p>The unique identifier of the manual snapshot to be deleted.</p> <p>Constraints: Must be the name of an existing snapshot that is in the <code>available</code>, <code>failed</code>, or <code>cancelled</code> state.</p>
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_774020 = query.getOrDefault("Action")
  valid_774020 = validateParameter(valid_774020, JString, required = true,
                                 default = newJString("DeleteClusterSnapshot"))
  if valid_774020 != nil:
    section.add "Action", valid_774020
  var valid_774021 = query.getOrDefault("SnapshotClusterIdentifier")
  valid_774021 = validateParameter(valid_774021, JString, required = false,
                                 default = nil)
  if valid_774021 != nil:
    section.add "SnapshotClusterIdentifier", valid_774021
  var valid_774022 = query.getOrDefault("SnapshotIdentifier")
  valid_774022 = validateParameter(valid_774022, JString, required = true,
                                 default = nil)
  if valid_774022 != nil:
    section.add "SnapshotIdentifier", valid_774022
  var valid_774023 = query.getOrDefault("Version")
  valid_774023 = validateParameter(valid_774023, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_774023 != nil:
    section.add "Version", valid_774023
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_774024 = header.getOrDefault("X-Amz-Date")
  valid_774024 = validateParameter(valid_774024, JString, required = false,
                                 default = nil)
  if valid_774024 != nil:
    section.add "X-Amz-Date", valid_774024
  var valid_774025 = header.getOrDefault("X-Amz-Security-Token")
  valid_774025 = validateParameter(valid_774025, JString, required = false,
                                 default = nil)
  if valid_774025 != nil:
    section.add "X-Amz-Security-Token", valid_774025
  var valid_774026 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_774026 = validateParameter(valid_774026, JString, required = false,
                                 default = nil)
  if valid_774026 != nil:
    section.add "X-Amz-Content-Sha256", valid_774026
  var valid_774027 = header.getOrDefault("X-Amz-Algorithm")
  valid_774027 = validateParameter(valid_774027, JString, required = false,
                                 default = nil)
  if valid_774027 != nil:
    section.add "X-Amz-Algorithm", valid_774027
  var valid_774028 = header.getOrDefault("X-Amz-Signature")
  valid_774028 = validateParameter(valid_774028, JString, required = false,
                                 default = nil)
  if valid_774028 != nil:
    section.add "X-Amz-Signature", valid_774028
  var valid_774029 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_774029 = validateParameter(valid_774029, JString, required = false,
                                 default = nil)
  if valid_774029 != nil:
    section.add "X-Amz-SignedHeaders", valid_774029
  var valid_774030 = header.getOrDefault("X-Amz-Credential")
  valid_774030 = validateParameter(valid_774030, JString, required = false,
                                 default = nil)
  if valid_774030 != nil:
    section.add "X-Amz-Credential", valid_774030
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_774031: Call_GetDeleteClusterSnapshot_774017; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Deletes the specified manual snapshot. The snapshot must be in the <code>available</code> state, with no other users authorized to access the snapshot. </p> <p>Unlike automated snapshots, manual snapshots are retained even after you delete your cluster. Amazon Redshift does not delete your manual snapshots. You must delete manual snapshot explicitly to avoid getting charged. If other accounts are authorized to access the snapshot, you must revoke all of the authorizations before you can delete the snapshot.</p>
  ## 
  let valid = call_774031.validator(path, query, header, formData, body)
  let scheme = call_774031.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_774031.url(scheme.get, call_774031.host, call_774031.base,
                         call_774031.route, valid.getOrDefault("path"))
  result = hook(call_774031, url, valid)

proc call*(call_774032: Call_GetDeleteClusterSnapshot_774017;
          SnapshotIdentifier: string; Action: string = "DeleteClusterSnapshot";
          SnapshotClusterIdentifier: string = ""; Version: string = "2012-12-01"): Recallable =
  ## getDeleteClusterSnapshot
  ## <p>Deletes the specified manual snapshot. The snapshot must be in the <code>available</code> state, with no other users authorized to access the snapshot. </p> <p>Unlike automated snapshots, manual snapshots are retained even after you delete your cluster. Amazon Redshift does not delete your manual snapshots. You must delete manual snapshot explicitly to avoid getting charged. If other accounts are authorized to access the snapshot, you must revoke all of the authorizations before you can delete the snapshot.</p>
  ##   Action: string (required)
  ##   SnapshotClusterIdentifier: string
  ##                            : <p>The unique identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.</p> <p>Constraints: Must be the name of valid cluster.</p>
  ##   SnapshotIdentifier: string (required)
  ##                     : <p>The unique identifier of the manual snapshot to be deleted.</p> <p>Constraints: Must be the name of an existing snapshot that is in the <code>available</code>, <code>failed</code>, or <code>cancelled</code> state.</p>
  ##   Version: string (required)
  var query_774033 = newJObject()
  add(query_774033, "Action", newJString(Action))
  add(query_774033, "SnapshotClusterIdentifier",
      newJString(SnapshotClusterIdentifier))
  add(query_774033, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_774033, "Version", newJString(Version))
  result = call_774032.call(nil, query_774033, nil, nil, nil)

var getDeleteClusterSnapshot* = Call_GetDeleteClusterSnapshot_774017(
    name: "getDeleteClusterSnapshot", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteClusterSnapshot",
    validator: validate_GetDeleteClusterSnapshot_774018, base: "/",
    url: url_GetDeleteClusterSnapshot_774019, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDeleteClusterSubnetGroup_774068 = ref object of OpenApiRestCall_772581
proc url_PostDeleteClusterSubnetGroup_774070(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_PostDeleteClusterSubnetGroup_774069(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes the specified cluster subnet group.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_774071 = query.getOrDefault("Action")
  valid_774071 = validateParameter(valid_774071, JString, required = true, default = newJString(
      "DeleteClusterSubnetGroup"))
  if valid_774071 != nil:
    section.add "Action", valid_774071
  var valid_774072 = query.getOrDefault("Version")
  valid_774072 = validateParameter(valid_774072, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_774072 != nil:
    section.add "Version", valid_774072
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_774073 = header.getOrDefault("X-Amz-Date")
  valid_774073 = validateParameter(valid_774073, JString, required = false,
                                 default = nil)
  if valid_774073 != nil:
    section.add "X-Amz-Date", valid_774073
  var valid_774074 = header.getOrDefault("X-Amz-Security-Token")
  valid_774074 = validateParameter(valid_774074, JString, required = false,
                                 default = nil)
  if valid_774074 != nil:
    section.add "X-Amz-Security-Token", valid_774074
  var valid_774075 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_774075 = validateParameter(valid_774075, JString, required = false,
                                 default = nil)
  if valid_774075 != nil:
    section.add "X-Amz-Content-Sha256", valid_774075
  var valid_774076 = header.getOrDefault("X-Amz-Algorithm")
  valid_774076 = validateParameter(valid_774076, JString, required = false,
                                 default = nil)
  if valid_774076 != nil:
    section.add "X-Amz-Algorithm", valid_774076
  var valid_774077 = header.getOrDefault("X-Amz-Signature")
  valid_774077 = validateParameter(valid_774077, JString, required = false,
                                 default = nil)
  if valid_774077 != nil:
    section.add "X-Amz-Signature", valid_774077
  var valid_774078 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_774078 = validateParameter(valid_774078, JString, required = false,
                                 default = nil)
  if valid_774078 != nil:
    section.add "X-Amz-SignedHeaders", valid_774078
  var valid_774079 = header.getOrDefault("X-Amz-Credential")
  valid_774079 = validateParameter(valid_774079, JString, required = false,
                                 default = nil)
  if valid_774079 != nil:
    section.add "X-Amz-Credential", valid_774079
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterSubnetGroupName: JString (required)
  ##                         : The name of the cluster subnet group name to be deleted.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterSubnetGroupName` field"
  var valid_774080 = formData.getOrDefault("ClusterSubnetGroupName")
  valid_774080 = validateParameter(valid_774080, JString, required = true,
                                 default = nil)
  if valid_774080 != nil:
    section.add "ClusterSubnetGroupName", valid_774080
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_774081: Call_PostDeleteClusterSubnetGroup_774068; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes the specified cluster subnet group.
  ## 
  let valid = call_774081.validator(path, query, header, formData, body)
  let scheme = call_774081.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_774081.url(scheme.get, call_774081.host, call_774081.base,
                         call_774081.route, valid.getOrDefault("path"))
  result = hook(call_774081, url, valid)

proc call*(call_774082: Call_PostDeleteClusterSubnetGroup_774068;
          ClusterSubnetGroupName: string;
          Action: string = "DeleteClusterSubnetGroup";
          Version: string = "2012-12-01"): Recallable =
  ## postDeleteClusterSubnetGroup
  ## Deletes the specified cluster subnet group.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   ClusterSubnetGroupName: string (required)
  ##                         : The name of the cluster subnet group name to be deleted.
  var query_774083 = newJObject()
  var formData_774084 = newJObject()
  add(query_774083, "Action", newJString(Action))
  add(query_774083, "Version", newJString(Version))
  add(formData_774084, "ClusterSubnetGroupName",
      newJString(ClusterSubnetGroupName))
  result = call_774082.call(nil, query_774083, nil, formData_774084, nil)

var postDeleteClusterSubnetGroup* = Call_PostDeleteClusterSubnetGroup_774068(
    name: "postDeleteClusterSubnetGroup", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteClusterSubnetGroup",
    validator: validate_PostDeleteClusterSubnetGroup_774069, base: "/",
    url: url_PostDeleteClusterSubnetGroup_774070,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeleteClusterSubnetGroup_774052 = ref object of OpenApiRestCall_772581
proc url_GetDeleteClusterSubnetGroup_774054(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_GetDeleteClusterSubnetGroup_774053(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes the specified cluster subnet group.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ClusterSubnetGroupName: JString (required)
  ##                         : The name of the cluster subnet group name to be deleted.
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `ClusterSubnetGroupName` field"
  var valid_774055 = query.getOrDefault("ClusterSubnetGroupName")
  valid_774055 = validateParameter(valid_774055, JString, required = true,
                                 default = nil)
  if valid_774055 != nil:
    section.add "ClusterSubnetGroupName", valid_774055
  var valid_774056 = query.getOrDefault("Action")
  valid_774056 = validateParameter(valid_774056, JString, required = true, default = newJString(
      "DeleteClusterSubnetGroup"))
  if valid_774056 != nil:
    section.add "Action", valid_774056
  var valid_774057 = query.getOrDefault("Version")
  valid_774057 = validateParameter(valid_774057, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_774057 != nil:
    section.add "Version", valid_774057
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_774058 = header.getOrDefault("X-Amz-Date")
  valid_774058 = validateParameter(valid_774058, JString, required = false,
                                 default = nil)
  if valid_774058 != nil:
    section.add "X-Amz-Date", valid_774058
  var valid_774059 = header.getOrDefault("X-Amz-Security-Token")
  valid_774059 = validateParameter(valid_774059, JString, required = false,
                                 default = nil)
  if valid_774059 != nil:
    section.add "X-Amz-Security-Token", valid_774059
  var valid_774060 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_774060 = validateParameter(valid_774060, JString, required = false,
                                 default = nil)
  if valid_774060 != nil:
    section.add "X-Amz-Content-Sha256", valid_774060
  var valid_774061 = header.getOrDefault("X-Amz-Algorithm")
  valid_774061 = validateParameter(valid_774061, JString, required = false,
                                 default = nil)
  if valid_774061 != nil:
    section.add "X-Amz-Algorithm", valid_774061
  var valid_774062 = header.getOrDefault("X-Amz-Signature")
  valid_774062 = validateParameter(valid_774062, JString, required = false,
                                 default = nil)
  if valid_774062 != nil:
    section.add "X-Amz-Signature", valid_774062
  var valid_774063 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_774063 = validateParameter(valid_774063, JString, required = false,
                                 default = nil)
  if valid_774063 != nil:
    section.add "X-Amz-SignedHeaders", valid_774063
  var valid_774064 = header.getOrDefault("X-Amz-Credential")
  valid_774064 = validateParameter(valid_774064, JString, required = false,
                                 default = nil)
  if valid_774064 != nil:
    section.add "X-Amz-Credential", valid_774064
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_774065: Call_GetDeleteClusterSubnetGroup_774052; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes the specified cluster subnet group.
  ## 
  let valid = call_774065.validator(path, query, header, formData, body)
  let scheme = call_774065.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_774065.url(scheme.get, call_774065.host, call_774065.base,
                         call_774065.route, valid.getOrDefault("path"))
  result = hook(call_774065, url, valid)

proc call*(call_774066: Call_GetDeleteClusterSubnetGroup_774052;
          ClusterSubnetGroupName: string;
          Action: string = "DeleteClusterSubnetGroup";
          Version: string = "2012-12-01"): Recallable =
  ## getDeleteClusterSubnetGroup
  ## Deletes the specified cluster subnet group.
  ##   ClusterSubnetGroupName: string (required)
  ##                         : The name of the cluster subnet group name to be deleted.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_774067 = newJObject()
  add(query_774067, "ClusterSubnetGroupName", newJString(ClusterSubnetGroupName))
  add(query_774067, "Action", newJString(Action))
  add(query_774067, "Version", newJString(Version))
  result = call_774066.call(nil, query_774067, nil, nil, nil)

var getDeleteClusterSubnetGroup* = Call_GetDeleteClusterSubnetGroup_774052(
    name: "getDeleteClusterSubnetGroup", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteClusterSubnetGroup",
    validator: validate_GetDeleteClusterSubnetGroup_774053, base: "/",
    url: url_GetDeleteClusterSubnetGroup_774054,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDeleteEventSubscription_774101 = ref object of OpenApiRestCall_772581
proc url_PostDeleteEventSubscription_774103(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_PostDeleteEventSubscription_774102(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes an Amazon Redshift event notification subscription.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_774104 = query.getOrDefault("Action")
  valid_774104 = validateParameter(valid_774104, JString, required = true, default = newJString(
      "DeleteEventSubscription"))
  if valid_774104 != nil:
    section.add "Action", valid_774104
  var valid_774105 = query.getOrDefault("Version")
  valid_774105 = validateParameter(valid_774105, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_774105 != nil:
    section.add "Version", valid_774105
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_774106 = header.getOrDefault("X-Amz-Date")
  valid_774106 = validateParameter(valid_774106, JString, required = false,
                                 default = nil)
  if valid_774106 != nil:
    section.add "X-Amz-Date", valid_774106
  var valid_774107 = header.getOrDefault("X-Amz-Security-Token")
  valid_774107 = validateParameter(valid_774107, JString, required = false,
                                 default = nil)
  if valid_774107 != nil:
    section.add "X-Amz-Security-Token", valid_774107
  var valid_774108 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_774108 = validateParameter(valid_774108, JString, required = false,
                                 default = nil)
  if valid_774108 != nil:
    section.add "X-Amz-Content-Sha256", valid_774108
  var valid_774109 = header.getOrDefault("X-Amz-Algorithm")
  valid_774109 = validateParameter(valid_774109, JString, required = false,
                                 default = nil)
  if valid_774109 != nil:
    section.add "X-Amz-Algorithm", valid_774109
  var valid_774110 = header.getOrDefault("X-Amz-Signature")
  valid_774110 = validateParameter(valid_774110, JString, required = false,
                                 default = nil)
  if valid_774110 != nil:
    section.add "X-Amz-Signature", valid_774110
  var valid_774111 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_774111 = validateParameter(valid_774111, JString, required = false,
                                 default = nil)
  if valid_774111 != nil:
    section.add "X-Amz-SignedHeaders", valid_774111
  var valid_774112 = header.getOrDefault("X-Amz-Credential")
  valid_774112 = validateParameter(valid_774112, JString, required = false,
                                 default = nil)
  if valid_774112 != nil:
    section.add "X-Amz-Credential", valid_774112
  result.add "header", section
  ## parameters in `formData` object:
  ##   SubscriptionName: JString (required)
  ##                   : The name of the Amazon Redshift event notification subscription to be deleted.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `SubscriptionName` field"
  var valid_774113 = formData.getOrDefault("SubscriptionName")
  valid_774113 = validateParameter(valid_774113, JString, required = true,
                                 default = nil)
  if valid_774113 != nil:
    section.add "SubscriptionName", valid_774113
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_774114: Call_PostDeleteEventSubscription_774101; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes an Amazon Redshift event notification subscription.
  ## 
  let valid = call_774114.validator(path, query, header, formData, body)
  let scheme = call_774114.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_774114.url(scheme.get, call_774114.host, call_774114.base,
                         call_774114.route, valid.getOrDefault("path"))
  result = hook(call_774114, url, valid)

proc call*(call_774115: Call_PostDeleteEventSubscription_774101;
          SubscriptionName: string; Action: string = "DeleteEventSubscription";
          Version: string = "2012-12-01"): Recallable =
  ## postDeleteEventSubscription
  ## Deletes an Amazon Redshift event notification subscription.
  ##   SubscriptionName: string (required)
  ##                   : The name of the Amazon Redshift event notification subscription to be deleted.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_774116 = newJObject()
  var formData_774117 = newJObject()
  add(formData_774117, "SubscriptionName", newJString(SubscriptionName))
  add(query_774116, "Action", newJString(Action))
  add(query_774116, "Version", newJString(Version))
  result = call_774115.call(nil, query_774116, nil, formData_774117, nil)

var postDeleteEventSubscription* = Call_PostDeleteEventSubscription_774101(
    name: "postDeleteEventSubscription", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteEventSubscription",
    validator: validate_PostDeleteEventSubscription_774102, base: "/",
    url: url_PostDeleteEventSubscription_774103,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeleteEventSubscription_774085 = ref object of OpenApiRestCall_772581
proc url_GetDeleteEventSubscription_774087(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_GetDeleteEventSubscription_774086(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes an Amazon Redshift event notification subscription.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   SubscriptionName: JString (required)
  ##                   : The name of the Amazon Redshift event notification subscription to be deleted.
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_774088 = query.getOrDefault("Action")
  valid_774088 = validateParameter(valid_774088, JString, required = true, default = newJString(
      "DeleteEventSubscription"))
  if valid_774088 != nil:
    section.add "Action", valid_774088
  var valid_774089 = query.getOrDefault("SubscriptionName")
  valid_774089 = validateParameter(valid_774089, JString, required = true,
                                 default = nil)
  if valid_774089 != nil:
    section.add "SubscriptionName", valid_774089
  var valid_774090 = query.getOrDefault("Version")
  valid_774090 = validateParameter(valid_774090, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_774090 != nil:
    section.add "Version", valid_774090
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_774091 = header.getOrDefault("X-Amz-Date")
  valid_774091 = validateParameter(valid_774091, JString, required = false,
                                 default = nil)
  if valid_774091 != nil:
    section.add "X-Amz-Date", valid_774091
  var valid_774092 = header.getOrDefault("X-Amz-Security-Token")
  valid_774092 = validateParameter(valid_774092, JString, required = false,
                                 default = nil)
  if valid_774092 != nil:
    section.add "X-Amz-Security-Token", valid_774092
  var valid_774093 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_774093 = validateParameter(valid_774093, JString, required = false,
                                 default = nil)
  if valid_774093 != nil:
    section.add "X-Amz-Content-Sha256", valid_774093
  var valid_774094 = header.getOrDefault("X-Amz-Algorithm")
  valid_774094 = validateParameter(valid_774094, JString, required = false,
                                 default = nil)
  if valid_774094 != nil:
    section.add "X-Amz-Algorithm", valid_774094
  var valid_774095 = header.getOrDefault("X-Amz-Signature")
  valid_774095 = validateParameter(valid_774095, JString, required = false,
                                 default = nil)
  if valid_774095 != nil:
    section.add "X-Amz-Signature", valid_774095
  var valid_774096 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_774096 = validateParameter(valid_774096, JString, required = false,
                                 default = nil)
  if valid_774096 != nil:
    section.add "X-Amz-SignedHeaders", valid_774096
  var valid_774097 = header.getOrDefault("X-Amz-Credential")
  valid_774097 = validateParameter(valid_774097, JString, required = false,
                                 default = nil)
  if valid_774097 != nil:
    section.add "X-Amz-Credential", valid_774097
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_774098: Call_GetDeleteEventSubscription_774085; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes an Amazon Redshift event notification subscription.
  ## 
  let valid = call_774098.validator(path, query, header, formData, body)
  let scheme = call_774098.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_774098.url(scheme.get, call_774098.host, call_774098.base,
                         call_774098.route, valid.getOrDefault("path"))
  result = hook(call_774098, url, valid)

proc call*(call_774099: Call_GetDeleteEventSubscription_774085;
          SubscriptionName: string; Action: string = "DeleteEventSubscription";
          Version: string = "2012-12-01"): Recallable =
  ## getDeleteEventSubscription
  ## Deletes an Amazon Redshift event notification subscription.
  ##   Action: string (required)
  ##   SubscriptionName: string (required)
  ##                   : The name of the Amazon Redshift event notification subscription to be deleted.
  ##   Version: string (required)
  var query_774100 = newJObject()
  add(query_774100, "Action", newJString(Action))
  add(query_774100, "SubscriptionName", newJString(SubscriptionName))
  add(query_774100, "Version", newJString(Version))
  result = call_774099.call(nil, query_774100, nil, nil, nil)

var getDeleteEventSubscription* = Call_GetDeleteEventSubscription_774085(
    name: "getDeleteEventSubscription", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteEventSubscription",
    validator: validate_GetDeleteEventSubscription_774086, base: "/",
    url: url_GetDeleteEventSubscription_774087,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDeleteHsmClientCertificate_774134 = ref object of OpenApiRestCall_772581
proc url_PostDeleteHsmClientCertificate_774136(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_PostDeleteHsmClientCertificate_774135(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes the specified HSM client certificate.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_774137 = query.getOrDefault("Action")
  valid_774137 = validateParameter(valid_774137, JString, required = true, default = newJString(
      "DeleteHsmClientCertificate"))
  if valid_774137 != nil:
    section.add "Action", valid_774137
  var valid_774138 = query.getOrDefault("Version")
  valid_774138 = validateParameter(valid_774138, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_774138 != nil:
    section.add "Version", valid_774138
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_774139 = header.getOrDefault("X-Amz-Date")
  valid_774139 = validateParameter(valid_774139, JString, required = false,
                                 default = nil)
  if valid_774139 != nil:
    section.add "X-Amz-Date", valid_774139
  var valid_774140 = header.getOrDefault("X-Amz-Security-Token")
  valid_774140 = validateParameter(valid_774140, JString, required = false,
                                 default = nil)
  if valid_774140 != nil:
    section.add "X-Amz-Security-Token", valid_774140
  var valid_774141 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_774141 = validateParameter(valid_774141, JString, required = false,
                                 default = nil)
  if valid_774141 != nil:
    section.add "X-Amz-Content-Sha256", valid_774141
  var valid_774142 = header.getOrDefault("X-Amz-Algorithm")
  valid_774142 = validateParameter(valid_774142, JString, required = false,
                                 default = nil)
  if valid_774142 != nil:
    section.add "X-Amz-Algorithm", valid_774142
  var valid_774143 = header.getOrDefault("X-Amz-Signature")
  valid_774143 = validateParameter(valid_774143, JString, required = false,
                                 default = nil)
  if valid_774143 != nil:
    section.add "X-Amz-Signature", valid_774143
  var valid_774144 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_774144 = validateParameter(valid_774144, JString, required = false,
                                 default = nil)
  if valid_774144 != nil:
    section.add "X-Amz-SignedHeaders", valid_774144
  var valid_774145 = header.getOrDefault("X-Amz-Credential")
  valid_774145 = validateParameter(valid_774145, JString, required = false,
                                 default = nil)
  if valid_774145 != nil:
    section.add "X-Amz-Credential", valid_774145
  result.add "header", section
  ## parameters in `formData` object:
  ##   HsmClientCertificateIdentifier: JString (required)
  ##                                 : The identifier of the HSM client certificate to be deleted.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `HsmClientCertificateIdentifier` field"
  var valid_774146 = formData.getOrDefault("HsmClientCertificateIdentifier")
  valid_774146 = validateParameter(valid_774146, JString, required = true,
                                 default = nil)
  if valid_774146 != nil:
    section.add "HsmClientCertificateIdentifier", valid_774146
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_774147: Call_PostDeleteHsmClientCertificate_774134; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes the specified HSM client certificate.
  ## 
  let valid = call_774147.validator(path, query, header, formData, body)
  let scheme = call_774147.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_774147.url(scheme.get, call_774147.host, call_774147.base,
                         call_774147.route, valid.getOrDefault("path"))
  result = hook(call_774147, url, valid)

proc call*(call_774148: Call_PostDeleteHsmClientCertificate_774134;
          HsmClientCertificateIdentifier: string;
          Action: string = "DeleteHsmClientCertificate";
          Version: string = "2012-12-01"): Recallable =
  ## postDeleteHsmClientCertificate
  ## Deletes the specified HSM client certificate.
  ##   Action: string (required)
  ##   HsmClientCertificateIdentifier: string (required)
  ##                                 : The identifier of the HSM client certificate to be deleted.
  ##   Version: string (required)
  var query_774149 = newJObject()
  var formData_774150 = newJObject()
  add(query_774149, "Action", newJString(Action))
  add(formData_774150, "HsmClientCertificateIdentifier",
      newJString(HsmClientCertificateIdentifier))
  add(query_774149, "Version", newJString(Version))
  result = call_774148.call(nil, query_774149, nil, formData_774150, nil)

var postDeleteHsmClientCertificate* = Call_PostDeleteHsmClientCertificate_774134(
    name: "postDeleteHsmClientCertificate", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteHsmClientCertificate",
    validator: validate_PostDeleteHsmClientCertificate_774135, base: "/",
    url: url_PostDeleteHsmClientCertificate_774136,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeleteHsmClientCertificate_774118 = ref object of OpenApiRestCall_772581
proc url_GetDeleteHsmClientCertificate_774120(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_GetDeleteHsmClientCertificate_774119(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes the specified HSM client certificate.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   HsmClientCertificateIdentifier: JString (required)
  ##                                 : The identifier of the HSM client certificate to be deleted.
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `HsmClientCertificateIdentifier` field"
  var valid_774121 = query.getOrDefault("HsmClientCertificateIdentifier")
  valid_774121 = validateParameter(valid_774121, JString, required = true,
                                 default = nil)
  if valid_774121 != nil:
    section.add "HsmClientCertificateIdentifier", valid_774121
  var valid_774122 = query.getOrDefault("Action")
  valid_774122 = validateParameter(valid_774122, JString, required = true, default = newJString(
      "DeleteHsmClientCertificate"))
  if valid_774122 != nil:
    section.add "Action", valid_774122
  var valid_774123 = query.getOrDefault("Version")
  valid_774123 = validateParameter(valid_774123, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_774123 != nil:
    section.add "Version", valid_774123
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_774124 = header.getOrDefault("X-Amz-Date")
  valid_774124 = validateParameter(valid_774124, JString, required = false,
                                 default = nil)
  if valid_774124 != nil:
    section.add "X-Amz-Date", valid_774124
  var valid_774125 = header.getOrDefault("X-Amz-Security-Token")
  valid_774125 = validateParameter(valid_774125, JString, required = false,
                                 default = nil)
  if valid_774125 != nil:
    section.add "X-Amz-Security-Token", valid_774125
  var valid_774126 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_774126 = validateParameter(valid_774126, JString, required = false,
                                 default = nil)
  if valid_774126 != nil:
    section.add "X-Amz-Content-Sha256", valid_774126
  var valid_774127 = header.getOrDefault("X-Amz-Algorithm")
  valid_774127 = validateParameter(valid_774127, JString, required = false,
                                 default = nil)
  if valid_774127 != nil:
    section.add "X-Amz-Algorithm", valid_774127
  var valid_774128 = header.getOrDefault("X-Amz-Signature")
  valid_774128 = validateParameter(valid_774128, JString, required = false,
                                 default = nil)
  if valid_774128 != nil:
    section.add "X-Amz-Signature", valid_774128
  var valid_774129 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_774129 = validateParameter(valid_774129, JString, required = false,
                                 default = nil)
  if valid_774129 != nil:
    section.add "X-Amz-SignedHeaders", valid_774129
  var valid_774130 = header.getOrDefault("X-Amz-Credential")
  valid_774130 = validateParameter(valid_774130, JString, required = false,
                                 default = nil)
  if valid_774130 != nil:
    section.add "X-Amz-Credential", valid_774130
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_774131: Call_GetDeleteHsmClientCertificate_774118; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes the specified HSM client certificate.
  ## 
  let valid = call_774131.validator(path, query, header, formData, body)
  let scheme = call_774131.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_774131.url(scheme.get, call_774131.host, call_774131.base,
                         call_774131.route, valid.getOrDefault("path"))
  result = hook(call_774131, url, valid)

proc call*(call_774132: Call_GetDeleteHsmClientCertificate_774118;
          HsmClientCertificateIdentifier: string;
          Action: string = "DeleteHsmClientCertificate";
          Version: string = "2012-12-01"): Recallable =
  ## getDeleteHsmClientCertificate
  ## Deletes the specified HSM client certificate.
  ##   HsmClientCertificateIdentifier: string (required)
  ##                                 : The identifier of the HSM client certificate to be deleted.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_774133 = newJObject()
  add(query_774133, "HsmClientCertificateIdentifier",
      newJString(HsmClientCertificateIdentifier))
  add(query_774133, "Action", newJString(Action))
  add(query_774133, "Version", newJString(Version))
  result = call_774132.call(nil, query_774133, nil, nil, nil)

var getDeleteHsmClientCertificate* = Call_GetDeleteHsmClientCertificate_774118(
    name: "getDeleteHsmClientCertificate", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteHsmClientCertificate",
    validator: validate_GetDeleteHsmClientCertificate_774119, base: "/",
    url: url_GetDeleteHsmClientCertificate_774120,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDeleteHsmConfiguration_774167 = ref object of OpenApiRestCall_772581
proc url_PostDeleteHsmConfiguration_774169(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_PostDeleteHsmConfiguration_774168(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes the specified Amazon Redshift HSM configuration.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_774170 = query.getOrDefault("Action")
  valid_774170 = validateParameter(valid_774170, JString, required = true,
                                 default = newJString("DeleteHsmConfiguration"))
  if valid_774170 != nil:
    section.add "Action", valid_774170
  var valid_774171 = query.getOrDefault("Version")
  valid_774171 = validateParameter(valid_774171, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_774171 != nil:
    section.add "Version", valid_774171
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_774172 = header.getOrDefault("X-Amz-Date")
  valid_774172 = validateParameter(valid_774172, JString, required = false,
                                 default = nil)
  if valid_774172 != nil:
    section.add "X-Amz-Date", valid_774172
  var valid_774173 = header.getOrDefault("X-Amz-Security-Token")
  valid_774173 = validateParameter(valid_774173, JString, required = false,
                                 default = nil)
  if valid_774173 != nil:
    section.add "X-Amz-Security-Token", valid_774173
  var valid_774174 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_774174 = validateParameter(valid_774174, JString, required = false,
                                 default = nil)
  if valid_774174 != nil:
    section.add "X-Amz-Content-Sha256", valid_774174
  var valid_774175 = header.getOrDefault("X-Amz-Algorithm")
  valid_774175 = validateParameter(valid_774175, JString, required = false,
                                 default = nil)
  if valid_774175 != nil:
    section.add "X-Amz-Algorithm", valid_774175
  var valid_774176 = header.getOrDefault("X-Amz-Signature")
  valid_774176 = validateParameter(valid_774176, JString, required = false,
                                 default = nil)
  if valid_774176 != nil:
    section.add "X-Amz-Signature", valid_774176
  var valid_774177 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_774177 = validateParameter(valid_774177, JString, required = false,
                                 default = nil)
  if valid_774177 != nil:
    section.add "X-Amz-SignedHeaders", valid_774177
  var valid_774178 = header.getOrDefault("X-Amz-Credential")
  valid_774178 = validateParameter(valid_774178, JString, required = false,
                                 default = nil)
  if valid_774178 != nil:
    section.add "X-Amz-Credential", valid_774178
  result.add "header", section
  ## parameters in `formData` object:
  ##   HsmConfigurationIdentifier: JString (required)
  ##                             : The identifier of the Amazon Redshift HSM configuration to be deleted.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `HsmConfigurationIdentifier` field"
  var valid_774179 = formData.getOrDefault("HsmConfigurationIdentifier")
  valid_774179 = validateParameter(valid_774179, JString, required = true,
                                 default = nil)
  if valid_774179 != nil:
    section.add "HsmConfigurationIdentifier", valid_774179
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_774180: Call_PostDeleteHsmConfiguration_774167; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes the specified Amazon Redshift HSM configuration.
  ## 
  let valid = call_774180.validator(path, query, header, formData, body)
  let scheme = call_774180.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_774180.url(scheme.get, call_774180.host, call_774180.base,
                         call_774180.route, valid.getOrDefault("path"))
  result = hook(call_774180, url, valid)

proc call*(call_774181: Call_PostDeleteHsmConfiguration_774167;
          HsmConfigurationIdentifier: string;
          Action: string = "DeleteHsmConfiguration"; Version: string = "2012-12-01"): Recallable =
  ## postDeleteHsmConfiguration
  ## Deletes the specified Amazon Redshift HSM configuration.
  ##   HsmConfigurationIdentifier: string (required)
  ##                             : The identifier of the Amazon Redshift HSM configuration to be deleted.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_774182 = newJObject()
  var formData_774183 = newJObject()
  add(formData_774183, "HsmConfigurationIdentifier",
      newJString(HsmConfigurationIdentifier))
  add(query_774182, "Action", newJString(Action))
  add(query_774182, "Version", newJString(Version))
  result = call_774181.call(nil, query_774182, nil, formData_774183, nil)

var postDeleteHsmConfiguration* = Call_PostDeleteHsmConfiguration_774167(
    name: "postDeleteHsmConfiguration", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteHsmConfiguration",
    validator: validate_PostDeleteHsmConfiguration_774168, base: "/",
    url: url_PostDeleteHsmConfiguration_774169,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeleteHsmConfiguration_774151 = ref object of OpenApiRestCall_772581
proc url_GetDeleteHsmConfiguration_774153(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_GetDeleteHsmConfiguration_774152(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes the specified Amazon Redshift HSM configuration.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   HsmConfigurationIdentifier: JString (required)
  ##                             : The identifier of the Amazon Redshift HSM configuration to be deleted.
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `HsmConfigurationIdentifier` field"
  var valid_774154 = query.getOrDefault("HsmConfigurationIdentifier")
  valid_774154 = validateParameter(valid_774154, JString, required = true,
                                 default = nil)
  if valid_774154 != nil:
    section.add "HsmConfigurationIdentifier", valid_774154
  var valid_774155 = query.getOrDefault("Action")
  valid_774155 = validateParameter(valid_774155, JString, required = true,
                                 default = newJString("DeleteHsmConfiguration"))
  if valid_774155 != nil:
    section.add "Action", valid_774155
  var valid_774156 = query.getOrDefault("Version")
  valid_774156 = validateParameter(valid_774156, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_774156 != nil:
    section.add "Version", valid_774156
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_774157 = header.getOrDefault("X-Amz-Date")
  valid_774157 = validateParameter(valid_774157, JString, required = false,
                                 default = nil)
  if valid_774157 != nil:
    section.add "X-Amz-Date", valid_774157
  var valid_774158 = header.getOrDefault("X-Amz-Security-Token")
  valid_774158 = validateParameter(valid_774158, JString, required = false,
                                 default = nil)
  if valid_774158 != nil:
    section.add "X-Amz-Security-Token", valid_774158
  var valid_774159 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_774159 = validateParameter(valid_774159, JString, required = false,
                                 default = nil)
  if valid_774159 != nil:
    section.add "X-Amz-Content-Sha256", valid_774159
  var valid_774160 = header.getOrDefault("X-Amz-Algorithm")
  valid_774160 = validateParameter(valid_774160, JString, required = false,
                                 default = nil)
  if valid_774160 != nil:
    section.add "X-Amz-Algorithm", valid_774160
  var valid_774161 = header.getOrDefault("X-Amz-Signature")
  valid_774161 = validateParameter(valid_774161, JString, required = false,
                                 default = nil)
  if valid_774161 != nil:
    section.add "X-Amz-Signature", valid_774161
  var valid_774162 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_774162 = validateParameter(valid_774162, JString, required = false,
                                 default = nil)
  if valid_774162 != nil:
    section.add "X-Amz-SignedHeaders", valid_774162
  var valid_774163 = header.getOrDefault("X-Amz-Credential")
  valid_774163 = validateParameter(valid_774163, JString, required = false,
                                 default = nil)
  if valid_774163 != nil:
    section.add "X-Amz-Credential", valid_774163
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_774164: Call_GetDeleteHsmConfiguration_774151; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes the specified Amazon Redshift HSM configuration.
  ## 
  let valid = call_774164.validator(path, query, header, formData, body)
  let scheme = call_774164.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_774164.url(scheme.get, call_774164.host, call_774164.base,
                         call_774164.route, valid.getOrDefault("path"))
  result = hook(call_774164, url, valid)

proc call*(call_774165: Call_GetDeleteHsmConfiguration_774151;
          HsmConfigurationIdentifier: string;
          Action: string = "DeleteHsmConfiguration"; Version: string = "2012-12-01"): Recallable =
  ## getDeleteHsmConfiguration
  ## Deletes the specified Amazon Redshift HSM configuration.
  ##   HsmConfigurationIdentifier: string (required)
  ##                             : The identifier of the Amazon Redshift HSM configuration to be deleted.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_774166 = newJObject()
  add(query_774166, "HsmConfigurationIdentifier",
      newJString(HsmConfigurationIdentifier))
  add(query_774166, "Action", newJString(Action))
  add(query_774166, "Version", newJString(Version))
  result = call_774165.call(nil, query_774166, nil, nil, nil)

var getDeleteHsmConfiguration* = Call_GetDeleteHsmConfiguration_774151(
    name: "getDeleteHsmConfiguration", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteHsmConfiguration",
    validator: validate_GetDeleteHsmConfiguration_774152, base: "/",
    url: url_GetDeleteHsmConfiguration_774153,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDeleteSnapshotCopyGrant_774200 = ref object of OpenApiRestCall_772581
proc url_PostDeleteSnapshotCopyGrant_774202(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_PostDeleteSnapshotCopyGrant_774201(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes the specified snapshot copy grant.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_774203 = query.getOrDefault("Action")
  valid_774203 = validateParameter(valid_774203, JString, required = true, default = newJString(
      "DeleteSnapshotCopyGrant"))
  if valid_774203 != nil:
    section.add "Action", valid_774203
  var valid_774204 = query.getOrDefault("Version")
  valid_774204 = validateParameter(valid_774204, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_774204 != nil:
    section.add "Version", valid_774204
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_774205 = header.getOrDefault("X-Amz-Date")
  valid_774205 = validateParameter(valid_774205, JString, required = false,
                                 default = nil)
  if valid_774205 != nil:
    section.add "X-Amz-Date", valid_774205
  var valid_774206 = header.getOrDefault("X-Amz-Security-Token")
  valid_774206 = validateParameter(valid_774206, JString, required = false,
                                 default = nil)
  if valid_774206 != nil:
    section.add "X-Amz-Security-Token", valid_774206
  var valid_774207 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_774207 = validateParameter(valid_774207, JString, required = false,
                                 default = nil)
  if valid_774207 != nil:
    section.add "X-Amz-Content-Sha256", valid_774207
  var valid_774208 = header.getOrDefault("X-Amz-Algorithm")
  valid_774208 = validateParameter(valid_774208, JString, required = false,
                                 default = nil)
  if valid_774208 != nil:
    section.add "X-Amz-Algorithm", valid_774208
  var valid_774209 = header.getOrDefault("X-Amz-Signature")
  valid_774209 = validateParameter(valid_774209, JString, required = false,
                                 default = nil)
  if valid_774209 != nil:
    section.add "X-Amz-Signature", valid_774209
  var valid_774210 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_774210 = validateParameter(valid_774210, JString, required = false,
                                 default = nil)
  if valid_774210 != nil:
    section.add "X-Amz-SignedHeaders", valid_774210
  var valid_774211 = header.getOrDefault("X-Amz-Credential")
  valid_774211 = validateParameter(valid_774211, JString, required = false,
                                 default = nil)
  if valid_774211 != nil:
    section.add "X-Amz-Credential", valid_774211
  result.add "header", section
  ## parameters in `formData` object:
  ##   SnapshotCopyGrantName: JString (required)
  ##                        : The name of the snapshot copy grant to delete.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `SnapshotCopyGrantName` field"
  var valid_774212 = formData.getOrDefault("SnapshotCopyGrantName")
  valid_774212 = validateParameter(valid_774212, JString, required = true,
                                 default = nil)
  if valid_774212 != nil:
    section.add "SnapshotCopyGrantName", valid_774212
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_774213: Call_PostDeleteSnapshotCopyGrant_774200; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes the specified snapshot copy grant.
  ## 
  let valid = call_774213.validator(path, query, header, formData, body)
  let scheme = call_774213.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_774213.url(scheme.get, call_774213.host, call_774213.base,
                         call_774213.route, valid.getOrDefault("path"))
  result = hook(call_774213, url, valid)

proc call*(call_774214: Call_PostDeleteSnapshotCopyGrant_774200;
          SnapshotCopyGrantName: string;
          Action: string = "DeleteSnapshotCopyGrant"; Version: string = "2012-12-01"): Recallable =
  ## postDeleteSnapshotCopyGrant
  ## Deletes the specified snapshot copy grant.
  ##   Action: string (required)
  ##   SnapshotCopyGrantName: string (required)
  ##                        : The name of the snapshot copy grant to delete.
  ##   Version: string (required)
  var query_774215 = newJObject()
  var formData_774216 = newJObject()
  add(query_774215, "Action", newJString(Action))
  add(formData_774216, "SnapshotCopyGrantName", newJString(SnapshotCopyGrantName))
  add(query_774215, "Version", newJString(Version))
  result = call_774214.call(nil, query_774215, nil, formData_774216, nil)

var postDeleteSnapshotCopyGrant* = Call_PostDeleteSnapshotCopyGrant_774200(
    name: "postDeleteSnapshotCopyGrant", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteSnapshotCopyGrant",
    validator: validate_PostDeleteSnapshotCopyGrant_774201, base: "/",
    url: url_PostDeleteSnapshotCopyGrant_774202,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeleteSnapshotCopyGrant_774184 = ref object of OpenApiRestCall_772581
proc url_GetDeleteSnapshotCopyGrant_774186(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_GetDeleteSnapshotCopyGrant_774185(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes the specified snapshot copy grant.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   SnapshotCopyGrantName: JString (required)
  ##                        : The name of the snapshot copy grant to delete.
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_774187 = query.getOrDefault("Action")
  valid_774187 = validateParameter(valid_774187, JString, required = true, default = newJString(
      "DeleteSnapshotCopyGrant"))
  if valid_774187 != nil:
    section.add "Action", valid_774187
  var valid_774188 = query.getOrDefault("SnapshotCopyGrantName")
  valid_774188 = validateParameter(valid_774188, JString, required = true,
                                 default = nil)
  if valid_774188 != nil:
    section.add "SnapshotCopyGrantName", valid_774188
  var valid_774189 = query.getOrDefault("Version")
  valid_774189 = validateParameter(valid_774189, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_774189 != nil:
    section.add "Version", valid_774189
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_774190 = header.getOrDefault("X-Amz-Date")
  valid_774190 = validateParameter(valid_774190, JString, required = false,
                                 default = nil)
  if valid_774190 != nil:
    section.add "X-Amz-Date", valid_774190
  var valid_774191 = header.getOrDefault("X-Amz-Security-Token")
  valid_774191 = validateParameter(valid_774191, JString, required = false,
                                 default = nil)
  if valid_774191 != nil:
    section.add "X-Amz-Security-Token", valid_774191
  var valid_774192 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_774192 = validateParameter(valid_774192, JString, required = false,
                                 default = nil)
  if valid_774192 != nil:
    section.add "X-Amz-Content-Sha256", valid_774192
  var valid_774193 = header.getOrDefault("X-Amz-Algorithm")
  valid_774193 = validateParameter(valid_774193, JString, required = false,
                                 default = nil)
  if valid_774193 != nil:
    section.add "X-Amz-Algorithm", valid_774193
  var valid_774194 = header.getOrDefault("X-Amz-Signature")
  valid_774194 = validateParameter(valid_774194, JString, required = false,
                                 default = nil)
  if valid_774194 != nil:
    section.add "X-Amz-Signature", valid_774194
  var valid_774195 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_774195 = validateParameter(valid_774195, JString, required = false,
                                 default = nil)
  if valid_774195 != nil:
    section.add "X-Amz-SignedHeaders", valid_774195
  var valid_774196 = header.getOrDefault("X-Amz-Credential")
  valid_774196 = validateParameter(valid_774196, JString, required = false,
                                 default = nil)
  if valid_774196 != nil:
    section.add "X-Amz-Credential", valid_774196
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_774197: Call_GetDeleteSnapshotCopyGrant_774184; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes the specified snapshot copy grant.
  ## 
  let valid = call_774197.validator(path, query, header, formData, body)
  let scheme = call_774197.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_774197.url(scheme.get, call_774197.host, call_774197.base,
                         call_774197.route, valid.getOrDefault("path"))
  result = hook(call_774197, url, valid)

proc call*(call_774198: Call_GetDeleteSnapshotCopyGrant_774184;
          SnapshotCopyGrantName: string;
          Action: string = "DeleteSnapshotCopyGrant"; Version: string = "2012-12-01"): Recallable =
  ## getDeleteSnapshotCopyGrant
  ## Deletes the specified snapshot copy grant.
  ##   Action: string (required)
  ##   SnapshotCopyGrantName: string (required)
  ##                        : The name of the snapshot copy grant to delete.
  ##   Version: string (required)
  var query_774199 = newJObject()
  add(query_774199, "Action", newJString(Action))
  add(query_774199, "SnapshotCopyGrantName", newJString(SnapshotCopyGrantName))
  add(query_774199, "Version", newJString(Version))
  result = call_774198.call(nil, query_774199, nil, nil, nil)

var getDeleteSnapshotCopyGrant* = Call_GetDeleteSnapshotCopyGrant_774184(
    name: "getDeleteSnapshotCopyGrant", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteSnapshotCopyGrant",
    validator: validate_GetDeleteSnapshotCopyGrant_774185, base: "/",
    url: url_GetDeleteSnapshotCopyGrant_774186,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDeleteSnapshotSchedule_774233 = ref object of OpenApiRestCall_772581
proc url_PostDeleteSnapshotSchedule_774235(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_PostDeleteSnapshotSchedule_774234(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a snapshot schedule.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_774236 = query.getOrDefault("Action")
  valid_774236 = validateParameter(valid_774236, JString, required = true,
                                 default = newJString("DeleteSnapshotSchedule"))
  if valid_774236 != nil:
    section.add "Action", valid_774236
  var valid_774237 = query.getOrDefault("Version")
  valid_774237 = validateParameter(valid_774237, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_774237 != nil:
    section.add "Version", valid_774237
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_774238 = header.getOrDefault("X-Amz-Date")
  valid_774238 = validateParameter(valid_774238, JString, required = false,
                                 default = nil)
  if valid_774238 != nil:
    section.add "X-Amz-Date", valid_774238
  var valid_774239 = header.getOrDefault("X-Amz-Security-Token")
  valid_774239 = validateParameter(valid_774239, JString, required = false,
                                 default = nil)
  if valid_774239 != nil:
    section.add "X-Amz-Security-Token", valid_774239
  var valid_774240 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_774240 = validateParameter(valid_774240, JString, required = false,
                                 default = nil)
  if valid_774240 != nil:
    section.add "X-Amz-Content-Sha256", valid_774240
  var valid_774241 = header.getOrDefault("X-Amz-Algorithm")
  valid_774241 = validateParameter(valid_774241, JString, required = false,
                                 default = nil)
  if valid_774241 != nil:
    section.add "X-Amz-Algorithm", valid_774241
  var valid_774242 = header.getOrDefault("X-Amz-Signature")
  valid_774242 = validateParameter(valid_774242, JString, required = false,
                                 default = nil)
  if valid_774242 != nil:
    section.add "X-Amz-Signature", valid_774242
  var valid_774243 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_774243 = validateParameter(valid_774243, JString, required = false,
                                 default = nil)
  if valid_774243 != nil:
    section.add "X-Amz-SignedHeaders", valid_774243
  var valid_774244 = header.getOrDefault("X-Amz-Credential")
  valid_774244 = validateParameter(valid_774244, JString, required = false,
                                 default = nil)
  if valid_774244 != nil:
    section.add "X-Amz-Credential", valid_774244
  result.add "header", section
  ## parameters in `formData` object:
  ##   ScheduleIdentifier: JString (required)
  ##                     : A unique identifier of the snapshot schedule to delete.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ScheduleIdentifier` field"
  var valid_774245 = formData.getOrDefault("ScheduleIdentifier")
  valid_774245 = validateParameter(valid_774245, JString, required = true,
                                 default = nil)
  if valid_774245 != nil:
    section.add "ScheduleIdentifier", valid_774245
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_774246: Call_PostDeleteSnapshotSchedule_774233; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a snapshot schedule.
  ## 
  let valid = call_774246.validator(path, query, header, formData, body)
  let scheme = call_774246.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_774246.url(scheme.get, call_774246.host, call_774246.base,
                         call_774246.route, valid.getOrDefault("path"))
  result = hook(call_774246, url, valid)

proc call*(call_774247: Call_PostDeleteSnapshotSchedule_774233;
          ScheduleIdentifier: string; Action: string = "DeleteSnapshotSchedule";
          Version: string = "2012-12-01"): Recallable =
  ## postDeleteSnapshotSchedule
  ## Deletes a snapshot schedule.
  ##   Action: string (required)
  ##   ScheduleIdentifier: string (required)
  ##                     : A unique identifier of the snapshot schedule to delete.
  ##   Version: string (required)
  var query_774248 = newJObject()
  var formData_774249 = newJObject()
  add(query_774248, "Action", newJString(Action))
  add(formData_774249, "ScheduleIdentifier", newJString(ScheduleIdentifier))
  add(query_774248, "Version", newJString(Version))
  result = call_774247.call(nil, query_774248, nil, formData_774249, nil)

var postDeleteSnapshotSchedule* = Call_PostDeleteSnapshotSchedule_774233(
    name: "postDeleteSnapshotSchedule", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteSnapshotSchedule",
    validator: validate_PostDeleteSnapshotSchedule_774234, base: "/",
    url: url_PostDeleteSnapshotSchedule_774235,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeleteSnapshotSchedule_774217 = ref object of OpenApiRestCall_772581
proc url_GetDeleteSnapshotSchedule_774219(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_GetDeleteSnapshotSchedule_774218(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a snapshot schedule.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   ScheduleIdentifier: JString (required)
  ##                     : A unique identifier of the snapshot schedule to delete.
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_774220 = query.getOrDefault("Action")
  valid_774220 = validateParameter(valid_774220, JString, required = true,
                                 default = newJString("DeleteSnapshotSchedule"))
  if valid_774220 != nil:
    section.add "Action", valid_774220
  var valid_774221 = query.getOrDefault("ScheduleIdentifier")
  valid_774221 = validateParameter(valid_774221, JString, required = true,
                                 default = nil)
  if valid_774221 != nil:
    section.add "ScheduleIdentifier", valid_774221
  var valid_774222 = query.getOrDefault("Version")
  valid_774222 = validateParameter(valid_774222, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_774222 != nil:
    section.add "Version", valid_774222
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_774223 = header.getOrDefault("X-Amz-Date")
  valid_774223 = validateParameter(valid_774223, JString, required = false,
                                 default = nil)
  if valid_774223 != nil:
    section.add "X-Amz-Date", valid_774223
  var valid_774224 = header.getOrDefault("X-Amz-Security-Token")
  valid_774224 = validateParameter(valid_774224, JString, required = false,
                                 default = nil)
  if valid_774224 != nil:
    section.add "X-Amz-Security-Token", valid_774224
  var valid_774225 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_774225 = validateParameter(valid_774225, JString, required = false,
                                 default = nil)
  if valid_774225 != nil:
    section.add "X-Amz-Content-Sha256", valid_774225
  var valid_774226 = header.getOrDefault("X-Amz-Algorithm")
  valid_774226 = validateParameter(valid_774226, JString, required = false,
                                 default = nil)
  if valid_774226 != nil:
    section.add "X-Amz-Algorithm", valid_774226
  var valid_774227 = header.getOrDefault("X-Amz-Signature")
  valid_774227 = validateParameter(valid_774227, JString, required = false,
                                 default = nil)
  if valid_774227 != nil:
    section.add "X-Amz-Signature", valid_774227
  var valid_774228 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_774228 = validateParameter(valid_774228, JString, required = false,
                                 default = nil)
  if valid_774228 != nil:
    section.add "X-Amz-SignedHeaders", valid_774228
  var valid_774229 = header.getOrDefault("X-Amz-Credential")
  valid_774229 = validateParameter(valid_774229, JString, required = false,
                                 default = nil)
  if valid_774229 != nil:
    section.add "X-Amz-Credential", valid_774229
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_774230: Call_GetDeleteSnapshotSchedule_774217; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a snapshot schedule.
  ## 
  let valid = call_774230.validator(path, query, header, formData, body)
  let scheme = call_774230.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_774230.url(scheme.get, call_774230.host, call_774230.base,
                         call_774230.route, valid.getOrDefault("path"))
  result = hook(call_774230, url, valid)

proc call*(call_774231: Call_GetDeleteSnapshotSchedule_774217;
          ScheduleIdentifier: string; Action: string = "DeleteSnapshotSchedule";
          Version: string = "2012-12-01"): Recallable =
  ## getDeleteSnapshotSchedule
  ## Deletes a snapshot schedule.
  ##   Action: string (required)
  ##   ScheduleIdentifier: string (required)
  ##                     : A unique identifier of the snapshot schedule to delete.
  ##   Version: string (required)
  var query_774232 = newJObject()
  add(query_774232, "Action", newJString(Action))
  add(query_774232, "ScheduleIdentifier", newJString(ScheduleIdentifier))
  add(query_774232, "Version", newJString(Version))
  result = call_774231.call(nil, query_774232, nil, nil, nil)

var getDeleteSnapshotSchedule* = Call_GetDeleteSnapshotSchedule_774217(
    name: "getDeleteSnapshotSchedule", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteSnapshotSchedule",
    validator: validate_GetDeleteSnapshotSchedule_774218, base: "/",
    url: url_GetDeleteSnapshotSchedule_774219,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDeleteTags_774267 = ref object of OpenApiRestCall_772581
proc url_PostDeleteTags_774269(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_PostDeleteTags_774268(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode): JsonNode =
  ## Deletes a tag or tags from a resource. You must provide the ARN of the resource from which you want to delete the tag or tags.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_774270 = query.getOrDefault("Action")
  valid_774270 = validateParameter(valid_774270, JString, required = true,
                                 default = newJString("DeleteTags"))
  if valid_774270 != nil:
    section.add "Action", valid_774270
  var valid_774271 = query.getOrDefault("Version")
  valid_774271 = validateParameter(valid_774271, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_774271 != nil:
    section.add "Version", valid_774271
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_774272 = header.getOrDefault("X-Amz-Date")
  valid_774272 = validateParameter(valid_774272, JString, required = false,
                                 default = nil)
  if valid_774272 != nil:
    section.add "X-Amz-Date", valid_774272
  var valid_774273 = header.getOrDefault("X-Amz-Security-Token")
  valid_774273 = validateParameter(valid_774273, JString, required = false,
                                 default = nil)
  if valid_774273 != nil:
    section.add "X-Amz-Security-Token", valid_774273
  var valid_774274 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_774274 = validateParameter(valid_774274, JString, required = false,
                                 default = nil)
  if valid_774274 != nil:
    section.add "X-Amz-Content-Sha256", valid_774274
  var valid_774275 = header.getOrDefault("X-Amz-Algorithm")
  valid_774275 = validateParameter(valid_774275, JString, required = false,
                                 default = nil)
  if valid_774275 != nil:
    section.add "X-Amz-Algorithm", valid_774275
  var valid_774276 = header.getOrDefault("X-Amz-Signature")
  valid_774276 = validateParameter(valid_774276, JString, required = false,
                                 default = nil)
  if valid_774276 != nil:
    section.add "X-Amz-Signature", valid_774276
  var valid_774277 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_774277 = validateParameter(valid_774277, JString, required = false,
                                 default = nil)
  if valid_774277 != nil:
    section.add "X-Amz-SignedHeaders", valid_774277
  var valid_774278 = header.getOrDefault("X-Amz-Credential")
  valid_774278 = validateParameter(valid_774278, JString, required = false,
                                 default = nil)
  if valid_774278 != nil:
    section.add "X-Amz-Credential", valid_774278
  result.add "header", section
  ## parameters in `formData` object:
  ##   TagKeys: JArray (required)
  ##          : The tag key that you want to delete.
  ##   ResourceName: JString (required)
  ##               : The Amazon Resource Name (ARN) from which you want to remove the tag or tags. For example, <code>arn:aws:redshift:us-east-1:123456789:cluster:t1</code>. 
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `TagKeys` field"
  var valid_774279 = formData.getOrDefault("TagKeys")
  valid_774279 = validateParameter(valid_774279, JArray, required = true, default = nil)
  if valid_774279 != nil:
    section.add "TagKeys", valid_774279
  var valid_774280 = formData.getOrDefault("ResourceName")
  valid_774280 = validateParameter(valid_774280, JString, required = true,
                                 default = nil)
  if valid_774280 != nil:
    section.add "ResourceName", valid_774280
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_774281: Call_PostDeleteTags_774267; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a tag or tags from a resource. You must provide the ARN of the resource from which you want to delete the tag or tags.
  ## 
  let valid = call_774281.validator(path, query, header, formData, body)
  let scheme = call_774281.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_774281.url(scheme.get, call_774281.host, call_774281.base,
                         call_774281.route, valid.getOrDefault("path"))
  result = hook(call_774281, url, valid)

proc call*(call_774282: Call_PostDeleteTags_774267; TagKeys: JsonNode;
          ResourceName: string; Action: string = "DeleteTags";
          Version: string = "2012-12-01"): Recallable =
  ## postDeleteTags
  ## Deletes a tag or tags from a resource. You must provide the ARN of the resource from which you want to delete the tag or tags.
  ##   Action: string (required)
  ##   TagKeys: JArray (required)
  ##          : The tag key that you want to delete.
  ##   ResourceName: string (required)
  ##               : The Amazon Resource Name (ARN) from which you want to remove the tag or tags. For example, <code>arn:aws:redshift:us-east-1:123456789:cluster:t1</code>. 
  ##   Version: string (required)
  var query_774283 = newJObject()
  var formData_774284 = newJObject()
  add(query_774283, "Action", newJString(Action))
  if TagKeys != nil:
    formData_774284.add "TagKeys", TagKeys
  add(formData_774284, "ResourceName", newJString(ResourceName))
  add(query_774283, "Version", newJString(Version))
  result = call_774282.call(nil, query_774283, nil, formData_774284, nil)

var postDeleteTags* = Call_PostDeleteTags_774267(name: "postDeleteTags",
    meth: HttpMethod.HttpPost, host: "redshift.amazonaws.com",
    route: "/#Action=DeleteTags", validator: validate_PostDeleteTags_774268,
    base: "/", url: url_PostDeleteTags_774269, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeleteTags_774250 = ref object of OpenApiRestCall_772581
proc url_GetDeleteTags_774252(protocol: Scheme; host: string; base: string;
                             route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_GetDeleteTags_774251(path: JsonNode; query: JsonNode; header: JsonNode;
                                  formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a tag or tags from a resource. You must provide the ARN of the resource from which you want to delete the tag or tags.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ResourceName: JString (required)
  ##               : The Amazon Resource Name (ARN) from which you want to remove the tag or tags. For example, <code>arn:aws:redshift:us-east-1:123456789:cluster:t1</code>. 
  ##   Action: JString (required)
  ##   TagKeys: JArray (required)
  ##          : The tag key that you want to delete.
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `ResourceName` field"
  var valid_774253 = query.getOrDefault("ResourceName")
  valid_774253 = validateParameter(valid_774253, JString, required = true,
                                 default = nil)
  if valid_774253 != nil:
    section.add "ResourceName", valid_774253
  var valid_774254 = query.getOrDefault("Action")
  valid_774254 = validateParameter(valid_774254, JString, required = true,
                                 default = newJString("DeleteTags"))
  if valid_774254 != nil:
    section.add "Action", valid_774254
  var valid_774255 = query.getOrDefault("TagKeys")
  valid_774255 = validateParameter(valid_774255, JArray, required = true, default = nil)
  if valid_774255 != nil:
    section.add "TagKeys", valid_774255
  var valid_774256 = query.getOrDefault("Version")
  valid_774256 = validateParameter(valid_774256, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_774256 != nil:
    section.add "Version", valid_774256
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_774257 = header.getOrDefault("X-Amz-Date")
  valid_774257 = validateParameter(valid_774257, JString, required = false,
                                 default = nil)
  if valid_774257 != nil:
    section.add "X-Amz-Date", valid_774257
  var valid_774258 = header.getOrDefault("X-Amz-Security-Token")
  valid_774258 = validateParameter(valid_774258, JString, required = false,
                                 default = nil)
  if valid_774258 != nil:
    section.add "X-Amz-Security-Token", valid_774258
  var valid_774259 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_774259 = validateParameter(valid_774259, JString, required = false,
                                 default = nil)
  if valid_774259 != nil:
    section.add "X-Amz-Content-Sha256", valid_774259
  var valid_774260 = header.getOrDefault("X-Amz-Algorithm")
  valid_774260 = validateParameter(valid_774260, JString, required = false,
                                 default = nil)
  if valid_774260 != nil:
    section.add "X-Amz-Algorithm", valid_774260
  var valid_774261 = header.getOrDefault("X-Amz-Signature")
  valid_774261 = validateParameter(valid_774261, JString, required = false,
                                 default = nil)
  if valid_774261 != nil:
    section.add "X-Amz-Signature", valid_774261
  var valid_774262 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_774262 = validateParameter(valid_774262, JString, required = false,
                                 default = nil)
  if valid_774262 != nil:
    section.add "X-Amz-SignedHeaders", valid_774262
  var valid_774263 = header.getOrDefault("X-Amz-Credential")
  valid_774263 = validateParameter(valid_774263, JString, required = false,
                                 default = nil)
  if valid_774263 != nil:
    section.add "X-Amz-Credential", valid_774263
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_774264: Call_GetDeleteTags_774250; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a tag or tags from a resource. You must provide the ARN of the resource from which you want to delete the tag or tags.
  ## 
  let valid = call_774264.validator(path, query, header, formData, body)
  let scheme = call_774264.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_774264.url(scheme.get, call_774264.host, call_774264.base,
                         call_774264.route, valid.getOrDefault("path"))
  result = hook(call_774264, url, valid)

proc call*(call_774265: Call_GetDeleteTags_774250; ResourceName: string;
          TagKeys: JsonNode; Action: string = "DeleteTags";
          Version: string = "2012-12-01"): Recallable =
  ## getDeleteTags
  ## Deletes a tag or tags from a resource. You must provide the ARN of the resource from which you want to delete the tag or tags.
  ##   ResourceName: string (required)
  ##               : The Amazon Resource Name (ARN) from which you want to remove the tag or tags. For example, <code>arn:aws:redshift:us-east-1:123456789:cluster:t1</code>. 
  ##   Action: string (required)
  ##   TagKeys: JArray (required)
  ##          : The tag key that you want to delete.
  ##   Version: string (required)
  var query_774266 = newJObject()
  add(query_774266, "ResourceName", newJString(ResourceName))
  add(query_774266, "Action", newJString(Action))
  if TagKeys != nil:
    query_774266.add "TagKeys", TagKeys
  add(query_774266, "Version", newJString(Version))
  result = call_774265.call(nil, query_774266, nil, nil, nil)

var getDeleteTags* = Call_GetDeleteTags_774250(name: "getDeleteTags",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=DeleteTags", validator: validate_GetDeleteTags_774251,
    base: "/", url: url_GetDeleteTags_774252, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeAccountAttributes_774301 = ref object of OpenApiRestCall_772581
proc url_PostDescribeAccountAttributes_774303(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_PostDescribeAccountAttributes_774302(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns a list of attributes attached to an account
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_774304 = query.getOrDefault("Action")
  valid_774304 = validateParameter(valid_774304, JString, required = true, default = newJString(
      "DescribeAccountAttributes"))
  if valid_774304 != nil:
    section.add "Action", valid_774304
  var valid_774305 = query.getOrDefault("Version")
  valid_774305 = validateParameter(valid_774305, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_774305 != nil:
    section.add "Version", valid_774305
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_774306 = header.getOrDefault("X-Amz-Date")
  valid_774306 = validateParameter(valid_774306, JString, required = false,
                                 default = nil)
  if valid_774306 != nil:
    section.add "X-Amz-Date", valid_774306
  var valid_774307 = header.getOrDefault("X-Amz-Security-Token")
  valid_774307 = validateParameter(valid_774307, JString, required = false,
                                 default = nil)
  if valid_774307 != nil:
    section.add "X-Amz-Security-Token", valid_774307
  var valid_774308 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_774308 = validateParameter(valid_774308, JString, required = false,
                                 default = nil)
  if valid_774308 != nil:
    section.add "X-Amz-Content-Sha256", valid_774308
  var valid_774309 = header.getOrDefault("X-Amz-Algorithm")
  valid_774309 = validateParameter(valid_774309, JString, required = false,
                                 default = nil)
  if valid_774309 != nil:
    section.add "X-Amz-Algorithm", valid_774309
  var valid_774310 = header.getOrDefault("X-Amz-Signature")
  valid_774310 = validateParameter(valid_774310, JString, required = false,
                                 default = nil)
  if valid_774310 != nil:
    section.add "X-Amz-Signature", valid_774310
  var valid_774311 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_774311 = validateParameter(valid_774311, JString, required = false,
                                 default = nil)
  if valid_774311 != nil:
    section.add "X-Amz-SignedHeaders", valid_774311
  var valid_774312 = header.getOrDefault("X-Amz-Credential")
  valid_774312 = validateParameter(valid_774312, JString, required = false,
                                 default = nil)
  if valid_774312 != nil:
    section.add "X-Amz-Credential", valid_774312
  result.add "header", section
  ## parameters in `formData` object:
  ##   AttributeNames: JArray
  ##                 : A list of attribute names.
  section = newJObject()
  var valid_774313 = formData.getOrDefault("AttributeNames")
  valid_774313 = validateParameter(valid_774313, JArray, required = false,
                                 default = nil)
  if valid_774313 != nil:
    section.add "AttributeNames", valid_774313
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_774314: Call_PostDescribeAccountAttributes_774301; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns a list of attributes attached to an account
  ## 
  let valid = call_774314.validator(path, query, header, formData, body)
  let scheme = call_774314.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_774314.url(scheme.get, call_774314.host, call_774314.base,
                         call_774314.route, valid.getOrDefault("path"))
  result = hook(call_774314, url, valid)

proc call*(call_774315: Call_PostDescribeAccountAttributes_774301;
          Action: string = "DescribeAccountAttributes";
          AttributeNames: JsonNode = nil; Version: string = "2012-12-01"): Recallable =
  ## postDescribeAccountAttributes
  ## Returns a list of attributes attached to an account
  ##   Action: string (required)
  ##   AttributeNames: JArray
  ##                 : A list of attribute names.
  ##   Version: string (required)
  var query_774316 = newJObject()
  var formData_774317 = newJObject()
  add(query_774316, "Action", newJString(Action))
  if AttributeNames != nil:
    formData_774317.add "AttributeNames", AttributeNames
  add(query_774316, "Version", newJString(Version))
  result = call_774315.call(nil, query_774316, nil, formData_774317, nil)

var postDescribeAccountAttributes* = Call_PostDescribeAccountAttributes_774301(
    name: "postDescribeAccountAttributes", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeAccountAttributes",
    validator: validate_PostDescribeAccountAttributes_774302, base: "/",
    url: url_PostDescribeAccountAttributes_774303,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeAccountAttributes_774285 = ref object of OpenApiRestCall_772581
proc url_GetDescribeAccountAttributes_774287(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_GetDescribeAccountAttributes_774286(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns a list of attributes attached to an account
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   AttributeNames: JArray
  ##                 : A list of attribute names.
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_774288 = query.getOrDefault("AttributeNames")
  valid_774288 = validateParameter(valid_774288, JArray, required = false,
                                 default = nil)
  if valid_774288 != nil:
    section.add "AttributeNames", valid_774288
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_774289 = query.getOrDefault("Action")
  valid_774289 = validateParameter(valid_774289, JString, required = true, default = newJString(
      "DescribeAccountAttributes"))
  if valid_774289 != nil:
    section.add "Action", valid_774289
  var valid_774290 = query.getOrDefault("Version")
  valid_774290 = validateParameter(valid_774290, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_774290 != nil:
    section.add "Version", valid_774290
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_774291 = header.getOrDefault("X-Amz-Date")
  valid_774291 = validateParameter(valid_774291, JString, required = false,
                                 default = nil)
  if valid_774291 != nil:
    section.add "X-Amz-Date", valid_774291
  var valid_774292 = header.getOrDefault("X-Amz-Security-Token")
  valid_774292 = validateParameter(valid_774292, JString, required = false,
                                 default = nil)
  if valid_774292 != nil:
    section.add "X-Amz-Security-Token", valid_774292
  var valid_774293 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_774293 = validateParameter(valid_774293, JString, required = false,
                                 default = nil)
  if valid_774293 != nil:
    section.add "X-Amz-Content-Sha256", valid_774293
  var valid_774294 = header.getOrDefault("X-Amz-Algorithm")
  valid_774294 = validateParameter(valid_774294, JString, required = false,
                                 default = nil)
  if valid_774294 != nil:
    section.add "X-Amz-Algorithm", valid_774294
  var valid_774295 = header.getOrDefault("X-Amz-Signature")
  valid_774295 = validateParameter(valid_774295, JString, required = false,
                                 default = nil)
  if valid_774295 != nil:
    section.add "X-Amz-Signature", valid_774295
  var valid_774296 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_774296 = validateParameter(valid_774296, JString, required = false,
                                 default = nil)
  if valid_774296 != nil:
    section.add "X-Amz-SignedHeaders", valid_774296
  var valid_774297 = header.getOrDefault("X-Amz-Credential")
  valid_774297 = validateParameter(valid_774297, JString, required = false,
                                 default = nil)
  if valid_774297 != nil:
    section.add "X-Amz-Credential", valid_774297
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_774298: Call_GetDescribeAccountAttributes_774285; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns a list of attributes attached to an account
  ## 
  let valid = call_774298.validator(path, query, header, formData, body)
  let scheme = call_774298.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_774298.url(scheme.get, call_774298.host, call_774298.base,
                         call_774298.route, valid.getOrDefault("path"))
  result = hook(call_774298, url, valid)

proc call*(call_774299: Call_GetDescribeAccountAttributes_774285;
          AttributeNames: JsonNode = nil;
          Action: string = "DescribeAccountAttributes";
          Version: string = "2012-12-01"): Recallable =
  ## getDescribeAccountAttributes
  ## Returns a list of attributes attached to an account
  ##   AttributeNames: JArray
  ##                 : A list of attribute names.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_774300 = newJObject()
  if AttributeNames != nil:
    query_774300.add "AttributeNames", AttributeNames
  add(query_774300, "Action", newJString(Action))
  add(query_774300, "Version", newJString(Version))
  result = call_774299.call(nil, query_774300, nil, nil, nil)

var getDescribeAccountAttributes* = Call_GetDescribeAccountAttributes_774285(
    name: "getDescribeAccountAttributes", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeAccountAttributes",
    validator: validate_GetDescribeAccountAttributes_774286, base: "/",
    url: url_GetDescribeAccountAttributes_774287,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeClusterDbRevisions_774336 = ref object of OpenApiRestCall_772581
proc url_PostDescribeClusterDbRevisions_774338(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_PostDescribeClusterDbRevisions_774337(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns an array of <code>ClusterDbRevision</code> objects.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_774339 = query.getOrDefault("Action")
  valid_774339 = validateParameter(valid_774339, JString, required = true, default = newJString(
      "DescribeClusterDbRevisions"))
  if valid_774339 != nil:
    section.add "Action", valid_774339
  var valid_774340 = query.getOrDefault("Version")
  valid_774340 = validateParameter(valid_774340, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_774340 != nil:
    section.add "Version", valid_774340
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_774341 = header.getOrDefault("X-Amz-Date")
  valid_774341 = validateParameter(valid_774341, JString, required = false,
                                 default = nil)
  if valid_774341 != nil:
    section.add "X-Amz-Date", valid_774341
  var valid_774342 = header.getOrDefault("X-Amz-Security-Token")
  valid_774342 = validateParameter(valid_774342, JString, required = false,
                                 default = nil)
  if valid_774342 != nil:
    section.add "X-Amz-Security-Token", valid_774342
  var valid_774343 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_774343 = validateParameter(valid_774343, JString, required = false,
                                 default = nil)
  if valid_774343 != nil:
    section.add "X-Amz-Content-Sha256", valid_774343
  var valid_774344 = header.getOrDefault("X-Amz-Algorithm")
  valid_774344 = validateParameter(valid_774344, JString, required = false,
                                 default = nil)
  if valid_774344 != nil:
    section.add "X-Amz-Algorithm", valid_774344
  var valid_774345 = header.getOrDefault("X-Amz-Signature")
  valid_774345 = validateParameter(valid_774345, JString, required = false,
                                 default = nil)
  if valid_774345 != nil:
    section.add "X-Amz-Signature", valid_774345
  var valid_774346 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_774346 = validateParameter(valid_774346, JString, required = false,
                                 default = nil)
  if valid_774346 != nil:
    section.add "X-Amz-SignedHeaders", valid_774346
  var valid_774347 = header.getOrDefault("X-Amz-Credential")
  valid_774347 = validateParameter(valid_774347, JString, required = false,
                                 default = nil)
  if valid_774347 != nil:
    section.add "X-Amz-Credential", valid_774347
  result.add "header", section
  ## parameters in `formData` object:
  ##   Marker: JString
  ##         : <p>An optional parameter that specifies the starting point for returning a set of response records. When the results of a <code>DescribeClusterDbRevisions</code> request exceed the value specified in <code>MaxRecords</code>, Amazon Redshift returns a value in the <code>marker</code> field of the response. You can retrieve the next set of response records by providing the returned <code>marker</code> value in the <code>marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <code>ClusterIdentifier</code> parameter, or the <code>marker</code> parameter, but not both.</p>
  ##   ClusterIdentifier: JString
  ##                    : A unique identifier for a cluster whose <code>ClusterDbRevisions</code> you are requesting. This parameter is case sensitive. All clusters defined for an account are returned by default.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified MaxRecords value, a value is returned in the <code>marker</code> field of the response. You can retrieve the next set of response records by providing the returned <code>marker</code> value in the <code>marker</code> parameter and retrying the request. </p> <p>Default: 100</p> <p>Constraints: minimum 20, maximum 100.</p>
  section = newJObject()
  var valid_774348 = formData.getOrDefault("Marker")
  valid_774348 = validateParameter(valid_774348, JString, required = false,
                                 default = nil)
  if valid_774348 != nil:
    section.add "Marker", valid_774348
  var valid_774349 = formData.getOrDefault("ClusterIdentifier")
  valid_774349 = validateParameter(valid_774349, JString, required = false,
                                 default = nil)
  if valid_774349 != nil:
    section.add "ClusterIdentifier", valid_774349
  var valid_774350 = formData.getOrDefault("MaxRecords")
  valid_774350 = validateParameter(valid_774350, JInt, required = false, default = nil)
  if valid_774350 != nil:
    section.add "MaxRecords", valid_774350
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_774351: Call_PostDescribeClusterDbRevisions_774336; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns an array of <code>ClusterDbRevision</code> objects.
  ## 
  let valid = call_774351.validator(path, query, header, formData, body)
  let scheme = call_774351.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_774351.url(scheme.get, call_774351.host, call_774351.base,
                         call_774351.route, valid.getOrDefault("path"))
  result = hook(call_774351, url, valid)

proc call*(call_774352: Call_PostDescribeClusterDbRevisions_774336;
          Marker: string = ""; Action: string = "DescribeClusterDbRevisions";
          ClusterIdentifier: string = ""; MaxRecords: int = 0;
          Version: string = "2012-12-01"): Recallable =
  ## postDescribeClusterDbRevisions
  ## Returns an array of <code>ClusterDbRevision</code> objects.
  ##   Marker: string
  ##         : <p>An optional parameter that specifies the starting point for returning a set of response records. When the results of a <code>DescribeClusterDbRevisions</code> request exceed the value specified in <code>MaxRecords</code>, Amazon Redshift returns a value in the <code>marker</code> field of the response. You can retrieve the next set of response records by providing the returned <code>marker</code> value in the <code>marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <code>ClusterIdentifier</code> parameter, or the <code>marker</code> parameter, but not both.</p>
  ##   Action: string (required)
  ##   ClusterIdentifier: string
  ##                    : A unique identifier for a cluster whose <code>ClusterDbRevisions</code> you are requesting. This parameter is case sensitive. All clusters defined for an account are returned by default.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified MaxRecords value, a value is returned in the <code>marker</code> field of the response. You can retrieve the next set of response records by providing the returned <code>marker</code> value in the <code>marker</code> parameter and retrying the request. </p> <p>Default: 100</p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Version: string (required)
  var query_774353 = newJObject()
  var formData_774354 = newJObject()
  add(formData_774354, "Marker", newJString(Marker))
  add(query_774353, "Action", newJString(Action))
  add(formData_774354, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_774354, "MaxRecords", newJInt(MaxRecords))
  add(query_774353, "Version", newJString(Version))
  result = call_774352.call(nil, query_774353, nil, formData_774354, nil)

var postDescribeClusterDbRevisions* = Call_PostDescribeClusterDbRevisions_774336(
    name: "postDescribeClusterDbRevisions", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusterDbRevisions",
    validator: validate_PostDescribeClusterDbRevisions_774337, base: "/",
    url: url_PostDescribeClusterDbRevisions_774338,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeClusterDbRevisions_774318 = ref object of OpenApiRestCall_772581
proc url_GetDescribeClusterDbRevisions_774320(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_GetDescribeClusterDbRevisions_774319(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns an array of <code>ClusterDbRevision</code> objects.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified MaxRecords value, a value is returned in the <code>marker</code> field of the response. You can retrieve the next set of response records by providing the returned <code>marker</code> value in the <code>marker</code> parameter and retrying the request. </p> <p>Default: 100</p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString
  ##                    : A unique identifier for a cluster whose <code>ClusterDbRevisions</code> you are requesting. This parameter is case sensitive. All clusters defined for an account are returned by default.
  ##   Marker: JString
  ##         : <p>An optional parameter that specifies the starting point for returning a set of response records. When the results of a <code>DescribeClusterDbRevisions</code> request exceed the value specified in <code>MaxRecords</code>, Amazon Redshift returns a value in the <code>marker</code> field of the response. You can retrieve the next set of response records by providing the returned <code>marker</code> value in the <code>marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <code>ClusterIdentifier</code> parameter, or the <code>marker</code> parameter, but not both.</p>
  ##   Version: JString (required)
  section = newJObject()
  var valid_774321 = query.getOrDefault("MaxRecords")
  valid_774321 = validateParameter(valid_774321, JInt, required = false, default = nil)
  if valid_774321 != nil:
    section.add "MaxRecords", valid_774321
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_774322 = query.getOrDefault("Action")
  valid_774322 = validateParameter(valid_774322, JString, required = true, default = newJString(
      "DescribeClusterDbRevisions"))
  if valid_774322 != nil:
    section.add "Action", valid_774322
  var valid_774323 = query.getOrDefault("ClusterIdentifier")
  valid_774323 = validateParameter(valid_774323, JString, required = false,
                                 default = nil)
  if valid_774323 != nil:
    section.add "ClusterIdentifier", valid_774323
  var valid_774324 = query.getOrDefault("Marker")
  valid_774324 = validateParameter(valid_774324, JString, required = false,
                                 default = nil)
  if valid_774324 != nil:
    section.add "Marker", valid_774324
  var valid_774325 = query.getOrDefault("Version")
  valid_774325 = validateParameter(valid_774325, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_774325 != nil:
    section.add "Version", valid_774325
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_774326 = header.getOrDefault("X-Amz-Date")
  valid_774326 = validateParameter(valid_774326, JString, required = false,
                                 default = nil)
  if valid_774326 != nil:
    section.add "X-Amz-Date", valid_774326
  var valid_774327 = header.getOrDefault("X-Amz-Security-Token")
  valid_774327 = validateParameter(valid_774327, JString, required = false,
                                 default = nil)
  if valid_774327 != nil:
    section.add "X-Amz-Security-Token", valid_774327
  var valid_774328 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_774328 = validateParameter(valid_774328, JString, required = false,
                                 default = nil)
  if valid_774328 != nil:
    section.add "X-Amz-Content-Sha256", valid_774328
  var valid_774329 = header.getOrDefault("X-Amz-Algorithm")
  valid_774329 = validateParameter(valid_774329, JString, required = false,
                                 default = nil)
  if valid_774329 != nil:
    section.add "X-Amz-Algorithm", valid_774329
  var valid_774330 = header.getOrDefault("X-Amz-Signature")
  valid_774330 = validateParameter(valid_774330, JString, required = false,
                                 default = nil)
  if valid_774330 != nil:
    section.add "X-Amz-Signature", valid_774330
  var valid_774331 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_774331 = validateParameter(valid_774331, JString, required = false,
                                 default = nil)
  if valid_774331 != nil:
    section.add "X-Amz-SignedHeaders", valid_774331
  var valid_774332 = header.getOrDefault("X-Amz-Credential")
  valid_774332 = validateParameter(valid_774332, JString, required = false,
                                 default = nil)
  if valid_774332 != nil:
    section.add "X-Amz-Credential", valid_774332
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_774333: Call_GetDescribeClusterDbRevisions_774318; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns an array of <code>ClusterDbRevision</code> objects.
  ## 
  let valid = call_774333.validator(path, query, header, formData, body)
  let scheme = call_774333.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_774333.url(scheme.get, call_774333.host, call_774333.base,
                         call_774333.route, valid.getOrDefault("path"))
  result = hook(call_774333, url, valid)

proc call*(call_774334: Call_GetDescribeClusterDbRevisions_774318;
          MaxRecords: int = 0; Action: string = "DescribeClusterDbRevisions";
          ClusterIdentifier: string = ""; Marker: string = "";
          Version: string = "2012-12-01"): Recallable =
  ## getDescribeClusterDbRevisions
  ## Returns an array of <code>ClusterDbRevision</code> objects.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified MaxRecords value, a value is returned in the <code>marker</code> field of the response. You can retrieve the next set of response records by providing the returned <code>marker</code> value in the <code>marker</code> parameter and retrying the request. </p> <p>Default: 100</p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Action: string (required)
  ##   ClusterIdentifier: string
  ##                    : A unique identifier for a cluster whose <code>ClusterDbRevisions</code> you are requesting. This parameter is case sensitive. All clusters defined for an account are returned by default.
  ##   Marker: string
  ##         : <p>An optional parameter that specifies the starting point for returning a set of response records. When the results of a <code>DescribeClusterDbRevisions</code> request exceed the value specified in <code>MaxRecords</code>, Amazon Redshift returns a value in the <code>marker</code> field of the response. You can retrieve the next set of response records by providing the returned <code>marker</code> value in the <code>marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <code>ClusterIdentifier</code> parameter, or the <code>marker</code> parameter, but not both.</p>
  ##   Version: string (required)
  var query_774335 = newJObject()
  add(query_774335, "MaxRecords", newJInt(MaxRecords))
  add(query_774335, "Action", newJString(Action))
  add(query_774335, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_774335, "Marker", newJString(Marker))
  add(query_774335, "Version", newJString(Version))
  result = call_774334.call(nil, query_774335, nil, nil, nil)

var getDescribeClusterDbRevisions* = Call_GetDescribeClusterDbRevisions_774318(
    name: "getDescribeClusterDbRevisions", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusterDbRevisions",
    validator: validate_GetDescribeClusterDbRevisions_774319, base: "/",
    url: url_GetDescribeClusterDbRevisions_774320,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeClusterParameterGroups_774375 = ref object of OpenApiRestCall_772581
proc url_PostDescribeClusterParameterGroups_774377(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_PostDescribeClusterParameterGroups_774376(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns a list of Amazon Redshift parameter groups, including parameter groups you created and the default parameter group. For each parameter group, the response includes the parameter group name, description, and parameter group family name. You can optionally specify a name to retrieve the description of a specific parameter group.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all parameter groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all parameter groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, parameter groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_774378 = query.getOrDefault("Action")
  valid_774378 = validateParameter(valid_774378, JString, required = true, default = newJString(
      "DescribeClusterParameterGroups"))
  if valid_774378 != nil:
    section.add "Action", valid_774378
  var valid_774379 = query.getOrDefault("Version")
  valid_774379 = validateParameter(valid_774379, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_774379 != nil:
    section.add "Version", valid_774379
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_774380 = header.getOrDefault("X-Amz-Date")
  valid_774380 = validateParameter(valid_774380, JString, required = false,
                                 default = nil)
  if valid_774380 != nil:
    section.add "X-Amz-Date", valid_774380
  var valid_774381 = header.getOrDefault("X-Amz-Security-Token")
  valid_774381 = validateParameter(valid_774381, JString, required = false,
                                 default = nil)
  if valid_774381 != nil:
    section.add "X-Amz-Security-Token", valid_774381
  var valid_774382 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_774382 = validateParameter(valid_774382, JString, required = false,
                                 default = nil)
  if valid_774382 != nil:
    section.add "X-Amz-Content-Sha256", valid_774382
  var valid_774383 = header.getOrDefault("X-Amz-Algorithm")
  valid_774383 = validateParameter(valid_774383, JString, required = false,
                                 default = nil)
  if valid_774383 != nil:
    section.add "X-Amz-Algorithm", valid_774383
  var valid_774384 = header.getOrDefault("X-Amz-Signature")
  valid_774384 = validateParameter(valid_774384, JString, required = false,
                                 default = nil)
  if valid_774384 != nil:
    section.add "X-Amz-Signature", valid_774384
  var valid_774385 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_774385 = validateParameter(valid_774385, JString, required = false,
                                 default = nil)
  if valid_774385 != nil:
    section.add "X-Amz-SignedHeaders", valid_774385
  var valid_774386 = header.getOrDefault("X-Amz-Credential")
  valid_774386 = validateParameter(valid_774386, JString, required = false,
                                 default = nil)
  if valid_774386 != nil:
    section.add "X-Amz-Credential", valid_774386
  result.add "header", section
  ## parameters in `formData` object:
  ##   ParameterGroupName: JString
  ##                     : The name of a specific parameter group for which to return details. By default, details about all parameter groups and the default parameter group are returned.
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterParameterGroups</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster parameter groups that are associated with the specified key or keys. For example, suppose that you have parameter groups that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the parameter groups that have either or both of these tag keys associated with them.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster parameter groups that are associated with the specified tag value or values. For example, suppose that you have parameter groups that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the parameter groups that have either or both of these tag values associated with them.
  section = newJObject()
  var valid_774387 = formData.getOrDefault("ParameterGroupName")
  valid_774387 = validateParameter(valid_774387, JString, required = false,
                                 default = nil)
  if valid_774387 != nil:
    section.add "ParameterGroupName", valid_774387
  var valid_774388 = formData.getOrDefault("Marker")
  valid_774388 = validateParameter(valid_774388, JString, required = false,
                                 default = nil)
  if valid_774388 != nil:
    section.add "Marker", valid_774388
  var valid_774389 = formData.getOrDefault("TagKeys")
  valid_774389 = validateParameter(valid_774389, JArray, required = false,
                                 default = nil)
  if valid_774389 != nil:
    section.add "TagKeys", valid_774389
  var valid_774390 = formData.getOrDefault("MaxRecords")
  valid_774390 = validateParameter(valid_774390, JInt, required = false, default = nil)
  if valid_774390 != nil:
    section.add "MaxRecords", valid_774390
  var valid_774391 = formData.getOrDefault("TagValues")
  valid_774391 = validateParameter(valid_774391, JArray, required = false,
                                 default = nil)
  if valid_774391 != nil:
    section.add "TagValues", valid_774391
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_774392: Call_PostDescribeClusterParameterGroups_774375;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Returns a list of Amazon Redshift parameter groups, including parameter groups you created and the default parameter group. For each parameter group, the response includes the parameter group name, description, and parameter group family name. You can optionally specify a name to retrieve the description of a specific parameter group.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all parameter groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all parameter groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, parameter groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_774392.validator(path, query, header, formData, body)
  let scheme = call_774392.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_774392.url(scheme.get, call_774392.host, call_774392.base,
                         call_774392.route, valid.getOrDefault("path"))
  result = hook(call_774392, url, valid)

proc call*(call_774393: Call_PostDescribeClusterParameterGroups_774375;
          ParameterGroupName: string = ""; Marker: string = "";
          Action: string = "DescribeClusterParameterGroups";
          TagKeys: JsonNode = nil; MaxRecords: int = 0; TagValues: JsonNode = nil;
          Version: string = "2012-12-01"): Recallable =
  ## postDescribeClusterParameterGroups
  ## <p>Returns a list of Amazon Redshift parameter groups, including parameter groups you created and the default parameter group. For each parameter group, the response includes the parameter group name, description, and parameter group family name. You can optionally specify a name to retrieve the description of a specific parameter group.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all parameter groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all parameter groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, parameter groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   ParameterGroupName: string
  ##                     : The name of a specific parameter group for which to return details. By default, details about all parameter groups and the default parameter group are returned.
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterParameterGroups</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Action: string (required)
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster parameter groups that are associated with the specified key or keys. For example, suppose that you have parameter groups that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the parameter groups that have either or both of these tag keys associated with them.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster parameter groups that are associated with the specified tag value or values. For example, suppose that you have parameter groups that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the parameter groups that have either or both of these tag values associated with them.
  ##   Version: string (required)
  var query_774394 = newJObject()
  var formData_774395 = newJObject()
  add(formData_774395, "ParameterGroupName", newJString(ParameterGroupName))
  add(formData_774395, "Marker", newJString(Marker))
  add(query_774394, "Action", newJString(Action))
  if TagKeys != nil:
    formData_774395.add "TagKeys", TagKeys
  add(formData_774395, "MaxRecords", newJInt(MaxRecords))
  if TagValues != nil:
    formData_774395.add "TagValues", TagValues
  add(query_774394, "Version", newJString(Version))
  result = call_774393.call(nil, query_774394, nil, formData_774395, nil)

var postDescribeClusterParameterGroups* = Call_PostDescribeClusterParameterGroups_774375(
    name: "postDescribeClusterParameterGroups", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeClusterParameterGroups",
    validator: validate_PostDescribeClusterParameterGroups_774376, base: "/",
    url: url_PostDescribeClusterParameterGroups_774377,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeClusterParameterGroups_774355 = ref object of OpenApiRestCall_772581
proc url_GetDescribeClusterParameterGroups_774357(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_GetDescribeClusterParameterGroups_774356(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns a list of Amazon Redshift parameter groups, including parameter groups you created and the default parameter group. For each parameter group, the response includes the parameter group name, description, and parameter group family name. You can optionally specify a name to retrieve the description of a specific parameter group.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all parameter groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all parameter groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, parameter groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster parameter groups that are associated with the specified tag value or values. For example, suppose that you have parameter groups that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the parameter groups that have either or both of these tag values associated with them.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   ParameterGroupName: JString
  ##                     : The name of a specific parameter group for which to return details. By default, details about all parameter groups and the default parameter group are returned.
  ##   Action: JString (required)
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterParameterGroups</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster parameter groups that are associated with the specified key or keys. For example, suppose that you have parameter groups that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the parameter groups that have either or both of these tag keys associated with them.
  ##   Version: JString (required)
  section = newJObject()
  var valid_774358 = query.getOrDefault("TagValues")
  valid_774358 = validateParameter(valid_774358, JArray, required = false,
                                 default = nil)
  if valid_774358 != nil:
    section.add "TagValues", valid_774358
  var valid_774359 = query.getOrDefault("MaxRecords")
  valid_774359 = validateParameter(valid_774359, JInt, required = false, default = nil)
  if valid_774359 != nil:
    section.add "MaxRecords", valid_774359
  var valid_774360 = query.getOrDefault("ParameterGroupName")
  valid_774360 = validateParameter(valid_774360, JString, required = false,
                                 default = nil)
  if valid_774360 != nil:
    section.add "ParameterGroupName", valid_774360
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_774361 = query.getOrDefault("Action")
  valid_774361 = validateParameter(valid_774361, JString, required = true, default = newJString(
      "DescribeClusterParameterGroups"))
  if valid_774361 != nil:
    section.add "Action", valid_774361
  var valid_774362 = query.getOrDefault("Marker")
  valid_774362 = validateParameter(valid_774362, JString, required = false,
                                 default = nil)
  if valid_774362 != nil:
    section.add "Marker", valid_774362
  var valid_774363 = query.getOrDefault("TagKeys")
  valid_774363 = validateParameter(valid_774363, JArray, required = false,
                                 default = nil)
  if valid_774363 != nil:
    section.add "TagKeys", valid_774363
  var valid_774364 = query.getOrDefault("Version")
  valid_774364 = validateParameter(valid_774364, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_774364 != nil:
    section.add "Version", valid_774364
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_774365 = header.getOrDefault("X-Amz-Date")
  valid_774365 = validateParameter(valid_774365, JString, required = false,
                                 default = nil)
  if valid_774365 != nil:
    section.add "X-Amz-Date", valid_774365
  var valid_774366 = header.getOrDefault("X-Amz-Security-Token")
  valid_774366 = validateParameter(valid_774366, JString, required = false,
                                 default = nil)
  if valid_774366 != nil:
    section.add "X-Amz-Security-Token", valid_774366
  var valid_774367 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_774367 = validateParameter(valid_774367, JString, required = false,
                                 default = nil)
  if valid_774367 != nil:
    section.add "X-Amz-Content-Sha256", valid_774367
  var valid_774368 = header.getOrDefault("X-Amz-Algorithm")
  valid_774368 = validateParameter(valid_774368, JString, required = false,
                                 default = nil)
  if valid_774368 != nil:
    section.add "X-Amz-Algorithm", valid_774368
  var valid_774369 = header.getOrDefault("X-Amz-Signature")
  valid_774369 = validateParameter(valid_774369, JString, required = false,
                                 default = nil)
  if valid_774369 != nil:
    section.add "X-Amz-Signature", valid_774369
  var valid_774370 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_774370 = validateParameter(valid_774370, JString, required = false,
                                 default = nil)
  if valid_774370 != nil:
    section.add "X-Amz-SignedHeaders", valid_774370
  var valid_774371 = header.getOrDefault("X-Amz-Credential")
  valid_774371 = validateParameter(valid_774371, JString, required = false,
                                 default = nil)
  if valid_774371 != nil:
    section.add "X-Amz-Credential", valid_774371
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_774372: Call_GetDescribeClusterParameterGroups_774355;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Returns a list of Amazon Redshift parameter groups, including parameter groups you created and the default parameter group. For each parameter group, the response includes the parameter group name, description, and parameter group family name. You can optionally specify a name to retrieve the description of a specific parameter group.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all parameter groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all parameter groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, parameter groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_774372.validator(path, query, header, formData, body)
  let scheme = call_774372.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_774372.url(scheme.get, call_774372.host, call_774372.base,
                         call_774372.route, valid.getOrDefault("path"))
  result = hook(call_774372, url, valid)

proc call*(call_774373: Call_GetDescribeClusterParameterGroups_774355;
          TagValues: JsonNode = nil; MaxRecords: int = 0;
          ParameterGroupName: string = "";
          Action: string = "DescribeClusterParameterGroups"; Marker: string = "";
          TagKeys: JsonNode = nil; Version: string = "2012-12-01"): Recallable =
  ## getDescribeClusterParameterGroups
  ## <p>Returns a list of Amazon Redshift parameter groups, including parameter groups you created and the default parameter group. For each parameter group, the response includes the parameter group name, description, and parameter group family name. You can optionally specify a name to retrieve the description of a specific parameter group.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all parameter groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all parameter groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, parameter groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster parameter groups that are associated with the specified tag value or values. For example, suppose that you have parameter groups that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the parameter groups that have either or both of these tag values associated with them.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   ParameterGroupName: string
  ##                     : The name of a specific parameter group for which to return details. By default, details about all parameter groups and the default parameter group are returned.
  ##   Action: string (required)
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterParameterGroups</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster parameter groups that are associated with the specified key or keys. For example, suppose that you have parameter groups that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the parameter groups that have either or both of these tag keys associated with them.
  ##   Version: string (required)
  var query_774374 = newJObject()
  if TagValues != nil:
    query_774374.add "TagValues", TagValues
  add(query_774374, "MaxRecords", newJInt(MaxRecords))
  add(query_774374, "ParameterGroupName", newJString(ParameterGroupName))
  add(query_774374, "Action", newJString(Action))
  add(query_774374, "Marker", newJString(Marker))
  if TagKeys != nil:
    query_774374.add "TagKeys", TagKeys
  add(query_774374, "Version", newJString(Version))
  result = call_774373.call(nil, query_774374, nil, nil, nil)

var getDescribeClusterParameterGroups* = Call_GetDescribeClusterParameterGroups_774355(
    name: "getDescribeClusterParameterGroups", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeClusterParameterGroups",
    validator: validate_GetDescribeClusterParameterGroups_774356, base: "/",
    url: url_GetDescribeClusterParameterGroups_774357,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeClusterParameters_774415 = ref object of OpenApiRestCall_772581
proc url_PostDescribeClusterParameters_774417(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_PostDescribeClusterParameters_774416(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns a detailed list of parameters contained within the specified Amazon Redshift parameter group. For each parameter the response includes information such as parameter name, description, data type, value, whether the parameter value is modifiable, and so on.</p> <p>You can specify <i>source</i> filter to retrieve parameters of only specific type. For example, to retrieve parameters that were modified by a user action such as from <a>ModifyClusterParameterGroup</a>, you can specify <i>source</i> equal to <i>user</i>.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_774418 = query.getOrDefault("Action")
  valid_774418 = validateParameter(valid_774418, JString, required = true, default = newJString(
      "DescribeClusterParameters"))
  if valid_774418 != nil:
    section.add "Action", valid_774418
  var valid_774419 = query.getOrDefault("Version")
  valid_774419 = validateParameter(valid_774419, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_774419 != nil:
    section.add "Version", valid_774419
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_774420 = header.getOrDefault("X-Amz-Date")
  valid_774420 = validateParameter(valid_774420, JString, required = false,
                                 default = nil)
  if valid_774420 != nil:
    section.add "X-Amz-Date", valid_774420
  var valid_774421 = header.getOrDefault("X-Amz-Security-Token")
  valid_774421 = validateParameter(valid_774421, JString, required = false,
                                 default = nil)
  if valid_774421 != nil:
    section.add "X-Amz-Security-Token", valid_774421
  var valid_774422 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_774422 = validateParameter(valid_774422, JString, required = false,
                                 default = nil)
  if valid_774422 != nil:
    section.add "X-Amz-Content-Sha256", valid_774422
  var valid_774423 = header.getOrDefault("X-Amz-Algorithm")
  valid_774423 = validateParameter(valid_774423, JString, required = false,
                                 default = nil)
  if valid_774423 != nil:
    section.add "X-Amz-Algorithm", valid_774423
  var valid_774424 = header.getOrDefault("X-Amz-Signature")
  valid_774424 = validateParameter(valid_774424, JString, required = false,
                                 default = nil)
  if valid_774424 != nil:
    section.add "X-Amz-Signature", valid_774424
  var valid_774425 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_774425 = validateParameter(valid_774425, JString, required = false,
                                 default = nil)
  if valid_774425 != nil:
    section.add "X-Amz-SignedHeaders", valid_774425
  var valid_774426 = header.getOrDefault("X-Amz-Credential")
  valid_774426 = validateParameter(valid_774426, JString, required = false,
                                 default = nil)
  if valid_774426 != nil:
    section.add "X-Amz-Credential", valid_774426
  result.add "header", section
  ## parameters in `formData` object:
  ##   ParameterGroupName: JString (required)
  ##                     : The name of a cluster parameter group for which to return details.
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterParameters</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Source: JString
  ##         : <p>The parameter types to return. Specify <code>user</code> to show parameters that are different form the default. Similarly, specify <code>engine-default</code> to show parameters that are the same as the default parameter group. </p> <p>Default: All parameter types returned.</p> <p>Valid Values: <code>user</code> | <code>engine-default</code> </p>
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ParameterGroupName` field"
  var valid_774427 = formData.getOrDefault("ParameterGroupName")
  valid_774427 = validateParameter(valid_774427, JString, required = true,
                                 default = nil)
  if valid_774427 != nil:
    section.add "ParameterGroupName", valid_774427
  var valid_774428 = formData.getOrDefault("Marker")
  valid_774428 = validateParameter(valid_774428, JString, required = false,
                                 default = nil)
  if valid_774428 != nil:
    section.add "Marker", valid_774428
  var valid_774429 = formData.getOrDefault("MaxRecords")
  valid_774429 = validateParameter(valid_774429, JInt, required = false, default = nil)
  if valid_774429 != nil:
    section.add "MaxRecords", valid_774429
  var valid_774430 = formData.getOrDefault("Source")
  valid_774430 = validateParameter(valid_774430, JString, required = false,
                                 default = nil)
  if valid_774430 != nil:
    section.add "Source", valid_774430
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_774431: Call_PostDescribeClusterParameters_774415; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns a detailed list of parameters contained within the specified Amazon Redshift parameter group. For each parameter the response includes information such as parameter name, description, data type, value, whether the parameter value is modifiable, and so on.</p> <p>You can specify <i>source</i> filter to retrieve parameters of only specific type. For example, to retrieve parameters that were modified by a user action such as from <a>ModifyClusterParameterGroup</a>, you can specify <i>source</i> equal to <i>user</i>.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_774431.validator(path, query, header, formData, body)
  let scheme = call_774431.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_774431.url(scheme.get, call_774431.host, call_774431.base,
                         call_774431.route, valid.getOrDefault("path"))
  result = hook(call_774431, url, valid)

proc call*(call_774432: Call_PostDescribeClusterParameters_774415;
          ParameterGroupName: string; Marker: string = "";
          Action: string = "DescribeClusterParameters"; MaxRecords: int = 0;
          Version: string = "2012-12-01"; Source: string = ""): Recallable =
  ## postDescribeClusterParameters
  ## <p>Returns a detailed list of parameters contained within the specified Amazon Redshift parameter group. For each parameter the response includes information such as parameter name, description, data type, value, whether the parameter value is modifiable, and so on.</p> <p>You can specify <i>source</i> filter to retrieve parameters of only specific type. For example, to retrieve parameters that were modified by a user action such as from <a>ModifyClusterParameterGroup</a>, you can specify <i>source</i> equal to <i>user</i>.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   ParameterGroupName: string (required)
  ##                     : The name of a cluster parameter group for which to return details.
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterParameters</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Action: string (required)
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Version: string (required)
  ##   Source: string
  ##         : <p>The parameter types to return. Specify <code>user</code> to show parameters that are different form the default. Similarly, specify <code>engine-default</code> to show parameters that are the same as the default parameter group. </p> <p>Default: All parameter types returned.</p> <p>Valid Values: <code>user</code> | <code>engine-default</code> </p>
  var query_774433 = newJObject()
  var formData_774434 = newJObject()
  add(formData_774434, "ParameterGroupName", newJString(ParameterGroupName))
  add(formData_774434, "Marker", newJString(Marker))
  add(query_774433, "Action", newJString(Action))
  add(formData_774434, "MaxRecords", newJInt(MaxRecords))
  add(query_774433, "Version", newJString(Version))
  add(formData_774434, "Source", newJString(Source))
  result = call_774432.call(nil, query_774433, nil, formData_774434, nil)

var postDescribeClusterParameters* = Call_PostDescribeClusterParameters_774415(
    name: "postDescribeClusterParameters", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusterParameters",
    validator: validate_PostDescribeClusterParameters_774416, base: "/",
    url: url_PostDescribeClusterParameters_774417,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeClusterParameters_774396 = ref object of OpenApiRestCall_772581
proc url_GetDescribeClusterParameters_774398(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_GetDescribeClusterParameters_774397(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns a detailed list of parameters contained within the specified Amazon Redshift parameter group. For each parameter the response includes information such as parameter name, description, data type, value, whether the parameter value is modifiable, and so on.</p> <p>You can specify <i>source</i> filter to retrieve parameters of only specific type. For example, to retrieve parameters that were modified by a user action such as from <a>ModifyClusterParameterGroup</a>, you can specify <i>source</i> equal to <i>user</i>.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   ParameterGroupName: JString (required)
  ##                     : The name of a cluster parameter group for which to return details.
  ##   Action: JString (required)
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterParameters</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Source: JString
  ##         : <p>The parameter types to return. Specify <code>user</code> to show parameters that are different form the default. Similarly, specify <code>engine-default</code> to show parameters that are the same as the default parameter group. </p> <p>Default: All parameter types returned.</p> <p>Valid Values: <code>user</code> | <code>engine-default</code> </p>
  ##   Version: JString (required)
  section = newJObject()
  var valid_774399 = query.getOrDefault("MaxRecords")
  valid_774399 = validateParameter(valid_774399, JInt, required = false, default = nil)
  if valid_774399 != nil:
    section.add "MaxRecords", valid_774399
  assert query != nil, "query argument is necessary due to required `ParameterGroupName` field"
  var valid_774400 = query.getOrDefault("ParameterGroupName")
  valid_774400 = validateParameter(valid_774400, JString, required = true,
                                 default = nil)
  if valid_774400 != nil:
    section.add "ParameterGroupName", valid_774400
  var valid_774401 = query.getOrDefault("Action")
  valid_774401 = validateParameter(valid_774401, JString, required = true, default = newJString(
      "DescribeClusterParameters"))
  if valid_774401 != nil:
    section.add "Action", valid_774401
  var valid_774402 = query.getOrDefault("Marker")
  valid_774402 = validateParameter(valid_774402, JString, required = false,
                                 default = nil)
  if valid_774402 != nil:
    section.add "Marker", valid_774402
  var valid_774403 = query.getOrDefault("Source")
  valid_774403 = validateParameter(valid_774403, JString, required = false,
                                 default = nil)
  if valid_774403 != nil:
    section.add "Source", valid_774403
  var valid_774404 = query.getOrDefault("Version")
  valid_774404 = validateParameter(valid_774404, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_774404 != nil:
    section.add "Version", valid_774404
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_774405 = header.getOrDefault("X-Amz-Date")
  valid_774405 = validateParameter(valid_774405, JString, required = false,
                                 default = nil)
  if valid_774405 != nil:
    section.add "X-Amz-Date", valid_774405
  var valid_774406 = header.getOrDefault("X-Amz-Security-Token")
  valid_774406 = validateParameter(valid_774406, JString, required = false,
                                 default = nil)
  if valid_774406 != nil:
    section.add "X-Amz-Security-Token", valid_774406
  var valid_774407 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_774407 = validateParameter(valid_774407, JString, required = false,
                                 default = nil)
  if valid_774407 != nil:
    section.add "X-Amz-Content-Sha256", valid_774407
  var valid_774408 = header.getOrDefault("X-Amz-Algorithm")
  valid_774408 = validateParameter(valid_774408, JString, required = false,
                                 default = nil)
  if valid_774408 != nil:
    section.add "X-Amz-Algorithm", valid_774408
  var valid_774409 = header.getOrDefault("X-Amz-Signature")
  valid_774409 = validateParameter(valid_774409, JString, required = false,
                                 default = nil)
  if valid_774409 != nil:
    section.add "X-Amz-Signature", valid_774409
  var valid_774410 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_774410 = validateParameter(valid_774410, JString, required = false,
                                 default = nil)
  if valid_774410 != nil:
    section.add "X-Amz-SignedHeaders", valid_774410
  var valid_774411 = header.getOrDefault("X-Amz-Credential")
  valid_774411 = validateParameter(valid_774411, JString, required = false,
                                 default = nil)
  if valid_774411 != nil:
    section.add "X-Amz-Credential", valid_774411
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_774412: Call_GetDescribeClusterParameters_774396; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns a detailed list of parameters contained within the specified Amazon Redshift parameter group. For each parameter the response includes information such as parameter name, description, data type, value, whether the parameter value is modifiable, and so on.</p> <p>You can specify <i>source</i> filter to retrieve parameters of only specific type. For example, to retrieve parameters that were modified by a user action such as from <a>ModifyClusterParameterGroup</a>, you can specify <i>source</i> equal to <i>user</i>.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_774412.validator(path, query, header, formData, body)
  let scheme = call_774412.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_774412.url(scheme.get, call_774412.host, call_774412.base,
                         call_774412.route, valid.getOrDefault("path"))
  result = hook(call_774412, url, valid)

proc call*(call_774413: Call_GetDescribeClusterParameters_774396;
          ParameterGroupName: string; MaxRecords: int = 0;
          Action: string = "DescribeClusterParameters"; Marker: string = "";
          Source: string = ""; Version: string = "2012-12-01"): Recallable =
  ## getDescribeClusterParameters
  ## <p>Returns a detailed list of parameters contained within the specified Amazon Redshift parameter group. For each parameter the response includes information such as parameter name, description, data type, value, whether the parameter value is modifiable, and so on.</p> <p>You can specify <i>source</i> filter to retrieve parameters of only specific type. For example, to retrieve parameters that were modified by a user action such as from <a>ModifyClusterParameterGroup</a>, you can specify <i>source</i> equal to <i>user</i>.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   ParameterGroupName: string (required)
  ##                     : The name of a cluster parameter group for which to return details.
  ##   Action: string (required)
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterParameters</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Source: string
  ##         : <p>The parameter types to return. Specify <code>user</code> to show parameters that are different form the default. Similarly, specify <code>engine-default</code> to show parameters that are the same as the default parameter group. </p> <p>Default: All parameter types returned.</p> <p>Valid Values: <code>user</code> | <code>engine-default</code> </p>
  ##   Version: string (required)
  var query_774414 = newJObject()
  add(query_774414, "MaxRecords", newJInt(MaxRecords))
  add(query_774414, "ParameterGroupName", newJString(ParameterGroupName))
  add(query_774414, "Action", newJString(Action))
  add(query_774414, "Marker", newJString(Marker))
  add(query_774414, "Source", newJString(Source))
  add(query_774414, "Version", newJString(Version))
  result = call_774413.call(nil, query_774414, nil, nil, nil)

var getDescribeClusterParameters* = Call_GetDescribeClusterParameters_774396(
    name: "getDescribeClusterParameters", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusterParameters",
    validator: validate_GetDescribeClusterParameters_774397, base: "/",
    url: url_GetDescribeClusterParameters_774398,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeClusterSecurityGroups_774455 = ref object of OpenApiRestCall_772581
proc url_PostDescribeClusterSecurityGroups_774457(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_PostDescribeClusterSecurityGroups_774456(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns information about Amazon Redshift security groups. If the name of a security group is specified, the response will contain only information about only that security group.</p> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all security groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all security groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, security groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_774458 = query.getOrDefault("Action")
  valid_774458 = validateParameter(valid_774458, JString, required = true, default = newJString(
      "DescribeClusterSecurityGroups"))
  if valid_774458 != nil:
    section.add "Action", valid_774458
  var valid_774459 = query.getOrDefault("Version")
  valid_774459 = validateParameter(valid_774459, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_774459 != nil:
    section.add "Version", valid_774459
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_774460 = header.getOrDefault("X-Amz-Date")
  valid_774460 = validateParameter(valid_774460, JString, required = false,
                                 default = nil)
  if valid_774460 != nil:
    section.add "X-Amz-Date", valid_774460
  var valid_774461 = header.getOrDefault("X-Amz-Security-Token")
  valid_774461 = validateParameter(valid_774461, JString, required = false,
                                 default = nil)
  if valid_774461 != nil:
    section.add "X-Amz-Security-Token", valid_774461
  var valid_774462 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_774462 = validateParameter(valid_774462, JString, required = false,
                                 default = nil)
  if valid_774462 != nil:
    section.add "X-Amz-Content-Sha256", valid_774462
  var valid_774463 = header.getOrDefault("X-Amz-Algorithm")
  valid_774463 = validateParameter(valid_774463, JString, required = false,
                                 default = nil)
  if valid_774463 != nil:
    section.add "X-Amz-Algorithm", valid_774463
  var valid_774464 = header.getOrDefault("X-Amz-Signature")
  valid_774464 = validateParameter(valid_774464, JString, required = false,
                                 default = nil)
  if valid_774464 != nil:
    section.add "X-Amz-Signature", valid_774464
  var valid_774465 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_774465 = validateParameter(valid_774465, JString, required = false,
                                 default = nil)
  if valid_774465 != nil:
    section.add "X-Amz-SignedHeaders", valid_774465
  var valid_774466 = header.getOrDefault("X-Amz-Credential")
  valid_774466 = validateParameter(valid_774466, JString, required = false,
                                 default = nil)
  if valid_774466 != nil:
    section.add "X-Amz-Credential", valid_774466
  result.add "header", section
  ## parameters in `formData` object:
  ##   Marker: JString
  ##         : <p>An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterSecurityGroups</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <b>ClusterSecurityGroupName</b> parameter or the <b>Marker</b> parameter, but not both. </p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster security groups that are associated with the specified key or keys. For example, suppose that you have security groups that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the security groups that have either or both of these tag keys associated with them.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster security groups that are associated with the specified tag value or values. For example, suppose that you have security groups that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the security groups that have either or both of these tag values associated with them.
  ##   ClusterSecurityGroupName: JString
  ##                           : <p>The name of a cluster security group for which you are requesting details. You can specify either the <b>Marker</b> parameter or a <b>ClusterSecurityGroupName</b> parameter, but not both. </p> <p> Example: <code>securitygroup1</code> </p>
  section = newJObject()
  var valid_774467 = formData.getOrDefault("Marker")
  valid_774467 = validateParameter(valid_774467, JString, required = false,
                                 default = nil)
  if valid_774467 != nil:
    section.add "Marker", valid_774467
  var valid_774468 = formData.getOrDefault("TagKeys")
  valid_774468 = validateParameter(valid_774468, JArray, required = false,
                                 default = nil)
  if valid_774468 != nil:
    section.add "TagKeys", valid_774468
  var valid_774469 = formData.getOrDefault("MaxRecords")
  valid_774469 = validateParameter(valid_774469, JInt, required = false, default = nil)
  if valid_774469 != nil:
    section.add "MaxRecords", valid_774469
  var valid_774470 = formData.getOrDefault("TagValues")
  valid_774470 = validateParameter(valid_774470, JArray, required = false,
                                 default = nil)
  if valid_774470 != nil:
    section.add "TagValues", valid_774470
  var valid_774471 = formData.getOrDefault("ClusterSecurityGroupName")
  valid_774471 = validateParameter(valid_774471, JString, required = false,
                                 default = nil)
  if valid_774471 != nil:
    section.add "ClusterSecurityGroupName", valid_774471
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_774472: Call_PostDescribeClusterSecurityGroups_774455;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Returns information about Amazon Redshift security groups. If the name of a security group is specified, the response will contain only information about only that security group.</p> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all security groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all security groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, security groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_774472.validator(path, query, header, formData, body)
  let scheme = call_774472.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_774472.url(scheme.get, call_774472.host, call_774472.base,
                         call_774472.route, valid.getOrDefault("path"))
  result = hook(call_774472, url, valid)

proc call*(call_774473: Call_PostDescribeClusterSecurityGroups_774455;
          Marker: string = ""; Action: string = "DescribeClusterSecurityGroups";
          TagKeys: JsonNode = nil; MaxRecords: int = 0; TagValues: JsonNode = nil;
          Version: string = "2012-12-01"; ClusterSecurityGroupName: string = ""): Recallable =
  ## postDescribeClusterSecurityGroups
  ## <p>Returns information about Amazon Redshift security groups. If the name of a security group is specified, the response will contain only information about only that security group.</p> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all security groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all security groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, security groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   Marker: string
  ##         : <p>An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterSecurityGroups</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <b>ClusterSecurityGroupName</b> parameter or the <b>Marker</b> parameter, but not both. </p>
  ##   Action: string (required)
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster security groups that are associated with the specified key or keys. For example, suppose that you have security groups that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the security groups that have either or both of these tag keys associated with them.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster security groups that are associated with the specified tag value or values. For example, suppose that you have security groups that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the security groups that have either or both of these tag values associated with them.
  ##   Version: string (required)
  ##   ClusterSecurityGroupName: string
  ##                           : <p>The name of a cluster security group for which you are requesting details. You can specify either the <b>Marker</b> parameter or a <b>ClusterSecurityGroupName</b> parameter, but not both. </p> <p> Example: <code>securitygroup1</code> </p>
  var query_774474 = newJObject()
  var formData_774475 = newJObject()
  add(formData_774475, "Marker", newJString(Marker))
  add(query_774474, "Action", newJString(Action))
  if TagKeys != nil:
    formData_774475.add "TagKeys", TagKeys
  add(formData_774475, "MaxRecords", newJInt(MaxRecords))
  if TagValues != nil:
    formData_774475.add "TagValues", TagValues
  add(query_774474, "Version", newJString(Version))
  add(formData_774475, "ClusterSecurityGroupName",
      newJString(ClusterSecurityGroupName))
  result = call_774473.call(nil, query_774474, nil, formData_774475, nil)

var postDescribeClusterSecurityGroups* = Call_PostDescribeClusterSecurityGroups_774455(
    name: "postDescribeClusterSecurityGroups", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeClusterSecurityGroups",
    validator: validate_PostDescribeClusterSecurityGroups_774456, base: "/",
    url: url_PostDescribeClusterSecurityGroups_774457,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeClusterSecurityGroups_774435 = ref object of OpenApiRestCall_772581
proc url_GetDescribeClusterSecurityGroups_774437(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_GetDescribeClusterSecurityGroups_774436(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns information about Amazon Redshift security groups. If the name of a security group is specified, the response will contain only information about only that security group.</p> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all security groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all security groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, security groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster security groups that are associated with the specified tag value or values. For example, suppose that you have security groups that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the security groups that have either or both of these tag values associated with them.
  ##   ClusterSecurityGroupName: JString
  ##                           : <p>The name of a cluster security group for which you are requesting details. You can specify either the <b>Marker</b> parameter or a <b>ClusterSecurityGroupName</b> parameter, but not both. </p> <p> Example: <code>securitygroup1</code> </p>
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Action: JString (required)
  ##   Marker: JString
  ##         : <p>An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterSecurityGroups</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <b>ClusterSecurityGroupName</b> parameter or the <b>Marker</b> parameter, but not both. </p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster security groups that are associated with the specified key or keys. For example, suppose that you have security groups that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the security groups that have either or both of these tag keys associated with them.
  ##   Version: JString (required)
  section = newJObject()
  var valid_774438 = query.getOrDefault("TagValues")
  valid_774438 = validateParameter(valid_774438, JArray, required = false,
                                 default = nil)
  if valid_774438 != nil:
    section.add "TagValues", valid_774438
  var valid_774439 = query.getOrDefault("ClusterSecurityGroupName")
  valid_774439 = validateParameter(valid_774439, JString, required = false,
                                 default = nil)
  if valid_774439 != nil:
    section.add "ClusterSecurityGroupName", valid_774439
  var valid_774440 = query.getOrDefault("MaxRecords")
  valid_774440 = validateParameter(valid_774440, JInt, required = false, default = nil)
  if valid_774440 != nil:
    section.add "MaxRecords", valid_774440
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_774441 = query.getOrDefault("Action")
  valid_774441 = validateParameter(valid_774441, JString, required = true, default = newJString(
      "DescribeClusterSecurityGroups"))
  if valid_774441 != nil:
    section.add "Action", valid_774441
  var valid_774442 = query.getOrDefault("Marker")
  valid_774442 = validateParameter(valid_774442, JString, required = false,
                                 default = nil)
  if valid_774442 != nil:
    section.add "Marker", valid_774442
  var valid_774443 = query.getOrDefault("TagKeys")
  valid_774443 = validateParameter(valid_774443, JArray, required = false,
                                 default = nil)
  if valid_774443 != nil:
    section.add "TagKeys", valid_774443
  var valid_774444 = query.getOrDefault("Version")
  valid_774444 = validateParameter(valid_774444, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_774444 != nil:
    section.add "Version", valid_774444
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_774445 = header.getOrDefault("X-Amz-Date")
  valid_774445 = validateParameter(valid_774445, JString, required = false,
                                 default = nil)
  if valid_774445 != nil:
    section.add "X-Amz-Date", valid_774445
  var valid_774446 = header.getOrDefault("X-Amz-Security-Token")
  valid_774446 = validateParameter(valid_774446, JString, required = false,
                                 default = nil)
  if valid_774446 != nil:
    section.add "X-Amz-Security-Token", valid_774446
  var valid_774447 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_774447 = validateParameter(valid_774447, JString, required = false,
                                 default = nil)
  if valid_774447 != nil:
    section.add "X-Amz-Content-Sha256", valid_774447
  var valid_774448 = header.getOrDefault("X-Amz-Algorithm")
  valid_774448 = validateParameter(valid_774448, JString, required = false,
                                 default = nil)
  if valid_774448 != nil:
    section.add "X-Amz-Algorithm", valid_774448
  var valid_774449 = header.getOrDefault("X-Amz-Signature")
  valid_774449 = validateParameter(valid_774449, JString, required = false,
                                 default = nil)
  if valid_774449 != nil:
    section.add "X-Amz-Signature", valid_774449
  var valid_774450 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_774450 = validateParameter(valid_774450, JString, required = false,
                                 default = nil)
  if valid_774450 != nil:
    section.add "X-Amz-SignedHeaders", valid_774450
  var valid_774451 = header.getOrDefault("X-Amz-Credential")
  valid_774451 = validateParameter(valid_774451, JString, required = false,
                                 default = nil)
  if valid_774451 != nil:
    section.add "X-Amz-Credential", valid_774451
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_774452: Call_GetDescribeClusterSecurityGroups_774435;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Returns information about Amazon Redshift security groups. If the name of a security group is specified, the response will contain only information about only that security group.</p> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all security groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all security groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, security groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_774452.validator(path, query, header, formData, body)
  let scheme = call_774452.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_774452.url(scheme.get, call_774452.host, call_774452.base,
                         call_774452.route, valid.getOrDefault("path"))
  result = hook(call_774452, url, valid)

proc call*(call_774453: Call_GetDescribeClusterSecurityGroups_774435;
          TagValues: JsonNode = nil; ClusterSecurityGroupName: string = "";
          MaxRecords: int = 0; Action: string = "DescribeClusterSecurityGroups";
          Marker: string = ""; TagKeys: JsonNode = nil; Version: string = "2012-12-01"): Recallable =
  ## getDescribeClusterSecurityGroups
  ## <p>Returns information about Amazon Redshift security groups. If the name of a security group is specified, the response will contain only information about only that security group.</p> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all security groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all security groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, security groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster security groups that are associated with the specified tag value or values. For example, suppose that you have security groups that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the security groups that have either or both of these tag values associated with them.
  ##   ClusterSecurityGroupName: string
  ##                           : <p>The name of a cluster security group for which you are requesting details. You can specify either the <b>Marker</b> parameter or a <b>ClusterSecurityGroupName</b> parameter, but not both. </p> <p> Example: <code>securitygroup1</code> </p>
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Action: string (required)
  ##   Marker: string
  ##         : <p>An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterSecurityGroups</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <b>ClusterSecurityGroupName</b> parameter or the <b>Marker</b> parameter, but not both. </p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster security groups that are associated with the specified key or keys. For example, suppose that you have security groups that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the security groups that have either or both of these tag keys associated with them.
  ##   Version: string (required)
  var query_774454 = newJObject()
  if TagValues != nil:
    query_774454.add "TagValues", TagValues
  add(query_774454, "ClusterSecurityGroupName",
      newJString(ClusterSecurityGroupName))
  add(query_774454, "MaxRecords", newJInt(MaxRecords))
  add(query_774454, "Action", newJString(Action))
  add(query_774454, "Marker", newJString(Marker))
  if TagKeys != nil:
    query_774454.add "TagKeys", TagKeys
  add(query_774454, "Version", newJString(Version))
  result = call_774453.call(nil, query_774454, nil, nil, nil)

var getDescribeClusterSecurityGroups* = Call_GetDescribeClusterSecurityGroups_774435(
    name: "getDescribeClusterSecurityGroups", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeClusterSecurityGroups",
    validator: validate_GetDescribeClusterSecurityGroups_774436, base: "/",
    url: url_GetDescribeClusterSecurityGroups_774437,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeClusterSnapshots_774503 = ref object of OpenApiRestCall_772581
proc url_PostDescribeClusterSnapshots_774505(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_PostDescribeClusterSnapshots_774504(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns one or more snapshot objects, which contain metadata about your cluster snapshots. By default, this operation returns information about all snapshots of all clusters that are owned by you AWS customer account. No information is returned for snapshots owned by inactive AWS customer accounts.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all snapshots that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all snapshots that have any combination of those values are returned. Only snapshots that you own are returned in the response; shared snapshots are not returned with the tag key and tag value request parameters.</p> <p>If both tag keys and values are omitted from the request, snapshots are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_774506 = query.getOrDefault("Action")
  valid_774506 = validateParameter(valid_774506, JString, required = true, default = newJString(
      "DescribeClusterSnapshots"))
  if valid_774506 != nil:
    section.add "Action", valid_774506
  var valid_774507 = query.getOrDefault("Version")
  valid_774507 = validateParameter(valid_774507, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_774507 != nil:
    section.add "Version", valid_774507
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_774508 = header.getOrDefault("X-Amz-Date")
  valid_774508 = validateParameter(valid_774508, JString, required = false,
                                 default = nil)
  if valid_774508 != nil:
    section.add "X-Amz-Date", valid_774508
  var valid_774509 = header.getOrDefault("X-Amz-Security-Token")
  valid_774509 = validateParameter(valid_774509, JString, required = false,
                                 default = nil)
  if valid_774509 != nil:
    section.add "X-Amz-Security-Token", valid_774509
  var valid_774510 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_774510 = validateParameter(valid_774510, JString, required = false,
                                 default = nil)
  if valid_774510 != nil:
    section.add "X-Amz-Content-Sha256", valid_774510
  var valid_774511 = header.getOrDefault("X-Amz-Algorithm")
  valid_774511 = validateParameter(valid_774511, JString, required = false,
                                 default = nil)
  if valid_774511 != nil:
    section.add "X-Amz-Algorithm", valid_774511
  var valid_774512 = header.getOrDefault("X-Amz-Signature")
  valid_774512 = validateParameter(valid_774512, JString, required = false,
                                 default = nil)
  if valid_774512 != nil:
    section.add "X-Amz-Signature", valid_774512
  var valid_774513 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_774513 = validateParameter(valid_774513, JString, required = false,
                                 default = nil)
  if valid_774513 != nil:
    section.add "X-Amz-SignedHeaders", valid_774513
  var valid_774514 = header.getOrDefault("X-Amz-Credential")
  valid_774514 = validateParameter(valid_774514, JString, required = false,
                                 default = nil)
  if valid_774514 != nil:
    section.add "X-Amz-Credential", valid_774514
  result.add "header", section
  ## parameters in `formData` object:
  ##   SortingEntities: JArray
  ##                  : <p/>
  ##   SnapshotType: JString
  ##               : <p>The type of snapshots for which you are requesting information. By default, snapshots of all types are returned.</p> <p>Valid Values: <code>automated</code> | <code>manual</code> </p>
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterSnapshots</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   StartTime: JString
  ##            : <p>A value that requests only snapshots created at or after the specified time. The time value is specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2012-07-16T18:00:00Z</code> </p>
  ##   OwnerAccount: JString
  ##               : The AWS customer account used to create or copy the snapshot. Use this field to filter the results to snapshots owned by a particular account. To describe snapshots you own, either specify your AWS customer account, or do not specify the parameter.
  ##   ClusterIdentifier: JString
  ##                    : The identifier of the cluster which generated the requested snapshots.
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster snapshots that are associated with the specified key or keys. For example, suppose that you have snapshots that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the snapshots that have either or both of these tag keys associated with them.
  ##   EndTime: JString
  ##          : <p>A time value that requests only snapshots created at or before the specified time. The time value is specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2012-07-16T18:00:00Z</code> </p>
  ##   ClusterExists: JBool
  ##                : <p>A value that indicates whether to return snapshots only for an existing cluster. You can perform table-level restore only by using a snapshot of an existing cluster, that is, a cluster that has not been deleted. Values for this parameter work as follows: </p> <ul> <li> <p>If <code>ClusterExists</code> is set to <code>true</code>, <code>ClusterIdentifier</code> is required.</p> </li> <li> <p>If <code>ClusterExists</code> is set to <code>false</code> and <code>ClusterIdentifier</code> isn't specified, all snapshots associated with deleted clusters (orphaned snapshots) are returned. </p> </li> <li> <p>If <code>ClusterExists</code> is set to <code>false</code> and <code>ClusterIdentifier</code> is specified for a deleted cluster, snapshots associated with that cluster are returned.</p> </li> <li> <p>If <code>ClusterExists</code> is set to <code>false</code> and <code>ClusterIdentifier</code> is specified for an existing cluster, no snapshots are returned. </p> </li> </ul>
  ##   SnapshotIdentifier: JString
  ##                     : The snapshot identifier of the snapshot about which to return information.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster snapshots that are associated with the specified tag value or values. For example, suppose that you have snapshots that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the snapshots that have either or both of these tag values associated with them.
  section = newJObject()
  var valid_774515 = formData.getOrDefault("SortingEntities")
  valid_774515 = validateParameter(valid_774515, JArray, required = false,
                                 default = nil)
  if valid_774515 != nil:
    section.add "SortingEntities", valid_774515
  var valid_774516 = formData.getOrDefault("SnapshotType")
  valid_774516 = validateParameter(valid_774516, JString, required = false,
                                 default = nil)
  if valid_774516 != nil:
    section.add "SnapshotType", valid_774516
  var valid_774517 = formData.getOrDefault("Marker")
  valid_774517 = validateParameter(valid_774517, JString, required = false,
                                 default = nil)
  if valid_774517 != nil:
    section.add "Marker", valid_774517
  var valid_774518 = formData.getOrDefault("StartTime")
  valid_774518 = validateParameter(valid_774518, JString, required = false,
                                 default = nil)
  if valid_774518 != nil:
    section.add "StartTime", valid_774518
  var valid_774519 = formData.getOrDefault("OwnerAccount")
  valid_774519 = validateParameter(valid_774519, JString, required = false,
                                 default = nil)
  if valid_774519 != nil:
    section.add "OwnerAccount", valid_774519
  var valid_774520 = formData.getOrDefault("ClusterIdentifier")
  valid_774520 = validateParameter(valid_774520, JString, required = false,
                                 default = nil)
  if valid_774520 != nil:
    section.add "ClusterIdentifier", valid_774520
  var valid_774521 = formData.getOrDefault("TagKeys")
  valid_774521 = validateParameter(valid_774521, JArray, required = false,
                                 default = nil)
  if valid_774521 != nil:
    section.add "TagKeys", valid_774521
  var valid_774522 = formData.getOrDefault("EndTime")
  valid_774522 = validateParameter(valid_774522, JString, required = false,
                                 default = nil)
  if valid_774522 != nil:
    section.add "EndTime", valid_774522
  var valid_774523 = formData.getOrDefault("ClusterExists")
  valid_774523 = validateParameter(valid_774523, JBool, required = false, default = nil)
  if valid_774523 != nil:
    section.add "ClusterExists", valid_774523
  var valid_774524 = formData.getOrDefault("SnapshotIdentifier")
  valid_774524 = validateParameter(valid_774524, JString, required = false,
                                 default = nil)
  if valid_774524 != nil:
    section.add "SnapshotIdentifier", valid_774524
  var valid_774525 = formData.getOrDefault("MaxRecords")
  valid_774525 = validateParameter(valid_774525, JInt, required = false, default = nil)
  if valid_774525 != nil:
    section.add "MaxRecords", valid_774525
  var valid_774526 = formData.getOrDefault("TagValues")
  valid_774526 = validateParameter(valid_774526, JArray, required = false,
                                 default = nil)
  if valid_774526 != nil:
    section.add "TagValues", valid_774526
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_774527: Call_PostDescribeClusterSnapshots_774503; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns one or more snapshot objects, which contain metadata about your cluster snapshots. By default, this operation returns information about all snapshots of all clusters that are owned by you AWS customer account. No information is returned for snapshots owned by inactive AWS customer accounts.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all snapshots that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all snapshots that have any combination of those values are returned. Only snapshots that you own are returned in the response; shared snapshots are not returned with the tag key and tag value request parameters.</p> <p>If both tag keys and values are omitted from the request, snapshots are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_774527.validator(path, query, header, formData, body)
  let scheme = call_774527.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_774527.url(scheme.get, call_774527.host, call_774527.base,
                         call_774527.route, valid.getOrDefault("path"))
  result = hook(call_774527, url, valid)

proc call*(call_774528: Call_PostDescribeClusterSnapshots_774503;
          SortingEntities: JsonNode = nil; SnapshotType: string = "";
          Marker: string = ""; StartTime: string = "";
          Action: string = "DescribeClusterSnapshots"; OwnerAccount: string = "";
          ClusterIdentifier: string = ""; TagKeys: JsonNode = nil; EndTime: string = "";
          ClusterExists: bool = false; SnapshotIdentifier: string = "";
          MaxRecords: int = 0; TagValues: JsonNode = nil; Version: string = "2012-12-01"): Recallable =
  ## postDescribeClusterSnapshots
  ## <p>Returns one or more snapshot objects, which contain metadata about your cluster snapshots. By default, this operation returns information about all snapshots of all clusters that are owned by you AWS customer account. No information is returned for snapshots owned by inactive AWS customer accounts.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all snapshots that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all snapshots that have any combination of those values are returned. Only snapshots that you own are returned in the response; shared snapshots are not returned with the tag key and tag value request parameters.</p> <p>If both tag keys and values are omitted from the request, snapshots are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   SortingEntities: JArray
  ##                  : <p/>
  ##   SnapshotType: string
  ##               : <p>The type of snapshots for which you are requesting information. By default, snapshots of all types are returned.</p> <p>Valid Values: <code>automated</code> | <code>manual</code> </p>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterSnapshots</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   StartTime: string
  ##            : <p>A value that requests only snapshots created at or after the specified time. The time value is specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2012-07-16T18:00:00Z</code> </p>
  ##   Action: string (required)
  ##   OwnerAccount: string
  ##               : The AWS customer account used to create or copy the snapshot. Use this field to filter the results to snapshots owned by a particular account. To describe snapshots you own, either specify your AWS customer account, or do not specify the parameter.
  ##   ClusterIdentifier: string
  ##                    : The identifier of the cluster which generated the requested snapshots.
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster snapshots that are associated with the specified key or keys. For example, suppose that you have snapshots that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the snapshots that have either or both of these tag keys associated with them.
  ##   EndTime: string
  ##          : <p>A time value that requests only snapshots created at or before the specified time. The time value is specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2012-07-16T18:00:00Z</code> </p>
  ##   ClusterExists: bool
  ##                : <p>A value that indicates whether to return snapshots only for an existing cluster. You can perform table-level restore only by using a snapshot of an existing cluster, that is, a cluster that has not been deleted. Values for this parameter work as follows: </p> <ul> <li> <p>If <code>ClusterExists</code> is set to <code>true</code>, <code>ClusterIdentifier</code> is required.</p> </li> <li> <p>If <code>ClusterExists</code> is set to <code>false</code> and <code>ClusterIdentifier</code> isn't specified, all snapshots associated with deleted clusters (orphaned snapshots) are returned. </p> </li> <li> <p>If <code>ClusterExists</code> is set to <code>false</code> and <code>ClusterIdentifier</code> is specified for a deleted cluster, snapshots associated with that cluster are returned.</p> </li> <li> <p>If <code>ClusterExists</code> is set to <code>false</code> and <code>ClusterIdentifier</code> is specified for an existing cluster, no snapshots are returned. </p> </li> </ul>
  ##   SnapshotIdentifier: string
  ##                     : The snapshot identifier of the snapshot about which to return information.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster snapshots that are associated with the specified tag value or values. For example, suppose that you have snapshots that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the snapshots that have either or both of these tag values associated with them.
  ##   Version: string (required)
  var query_774529 = newJObject()
  var formData_774530 = newJObject()
  if SortingEntities != nil:
    formData_774530.add "SortingEntities", SortingEntities
  add(formData_774530, "SnapshotType", newJString(SnapshotType))
  add(formData_774530, "Marker", newJString(Marker))
  add(formData_774530, "StartTime", newJString(StartTime))
  add(query_774529, "Action", newJString(Action))
  add(formData_774530, "OwnerAccount", newJString(OwnerAccount))
  add(formData_774530, "ClusterIdentifier", newJString(ClusterIdentifier))
  if TagKeys != nil:
    formData_774530.add "TagKeys", TagKeys
  add(formData_774530, "EndTime", newJString(EndTime))
  add(formData_774530, "ClusterExists", newJBool(ClusterExists))
  add(formData_774530, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(formData_774530, "MaxRecords", newJInt(MaxRecords))
  if TagValues != nil:
    formData_774530.add "TagValues", TagValues
  add(query_774529, "Version", newJString(Version))
  result = call_774528.call(nil, query_774529, nil, formData_774530, nil)

var postDescribeClusterSnapshots* = Call_PostDescribeClusterSnapshots_774503(
    name: "postDescribeClusterSnapshots", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusterSnapshots",
    validator: validate_PostDescribeClusterSnapshots_774504, base: "/",
    url: url_PostDescribeClusterSnapshots_774505,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeClusterSnapshots_774476 = ref object of OpenApiRestCall_772581
proc url_GetDescribeClusterSnapshots_774478(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_GetDescribeClusterSnapshots_774477(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns one or more snapshot objects, which contain metadata about your cluster snapshots. By default, this operation returns information about all snapshots of all clusters that are owned by you AWS customer account. No information is returned for snapshots owned by inactive AWS customer accounts.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all snapshots that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all snapshots that have any combination of those values are returned. Only snapshots that you own are returned in the response; shared snapshots are not returned with the tag key and tag value request parameters.</p> <p>If both tag keys and values are omitted from the request, snapshots are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster snapshots that are associated with the specified tag value or values. For example, suppose that you have snapshots that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the snapshots that have either or both of these tag values associated with them.
  ##   SortingEntities: JArray
  ##                  : <p/>
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   StartTime: JString
  ##            : <p>A value that requests only snapshots created at or after the specified time. The time value is specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2012-07-16T18:00:00Z</code> </p>
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString
  ##                    : The identifier of the cluster which generated the requested snapshots.
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterSnapshots</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   OwnerAccount: JString
  ##               : The AWS customer account used to create or copy the snapshot. Use this field to filter the results to snapshots owned by a particular account. To describe snapshots you own, either specify your AWS customer account, or do not specify the parameter.
  ##   ClusterExists: JBool
  ##                : <p>A value that indicates whether to return snapshots only for an existing cluster. You can perform table-level restore only by using a snapshot of an existing cluster, that is, a cluster that has not been deleted. Values for this parameter work as follows: </p> <ul> <li> <p>If <code>ClusterExists</code> is set to <code>true</code>, <code>ClusterIdentifier</code> is required.</p> </li> <li> <p>If <code>ClusterExists</code> is set to <code>false</code> and <code>ClusterIdentifier</code> isn't specified, all snapshots associated with deleted clusters (orphaned snapshots) are returned. </p> </li> <li> <p>If <code>ClusterExists</code> is set to <code>false</code> and <code>ClusterIdentifier</code> is specified for a deleted cluster, snapshots associated with that cluster are returned.</p> </li> <li> <p>If <code>ClusterExists</code> is set to <code>false</code> and <code>ClusterIdentifier</code> is specified for an existing cluster, no snapshots are returned. </p> </li> </ul>
  ##   SnapshotIdentifier: JString
  ##                     : The snapshot identifier of the snapshot about which to return information.
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster snapshots that are associated with the specified key or keys. For example, suppose that you have snapshots that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the snapshots that have either or both of these tag keys associated with them.
  ##   SnapshotType: JString
  ##               : <p>The type of snapshots for which you are requesting information. By default, snapshots of all types are returned.</p> <p>Valid Values: <code>automated</code> | <code>manual</code> </p>
  ##   EndTime: JString
  ##          : <p>A time value that requests only snapshots created at or before the specified time. The time value is specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2012-07-16T18:00:00Z</code> </p>
  ##   Version: JString (required)
  section = newJObject()
  var valid_774479 = query.getOrDefault("TagValues")
  valid_774479 = validateParameter(valid_774479, JArray, required = false,
                                 default = nil)
  if valid_774479 != nil:
    section.add "TagValues", valid_774479
  var valid_774480 = query.getOrDefault("SortingEntities")
  valid_774480 = validateParameter(valid_774480, JArray, required = false,
                                 default = nil)
  if valid_774480 != nil:
    section.add "SortingEntities", valid_774480
  var valid_774481 = query.getOrDefault("MaxRecords")
  valid_774481 = validateParameter(valid_774481, JInt, required = false, default = nil)
  if valid_774481 != nil:
    section.add "MaxRecords", valid_774481
  var valid_774482 = query.getOrDefault("StartTime")
  valid_774482 = validateParameter(valid_774482, JString, required = false,
                                 default = nil)
  if valid_774482 != nil:
    section.add "StartTime", valid_774482
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_774483 = query.getOrDefault("Action")
  valid_774483 = validateParameter(valid_774483, JString, required = true, default = newJString(
      "DescribeClusterSnapshots"))
  if valid_774483 != nil:
    section.add "Action", valid_774483
  var valid_774484 = query.getOrDefault("ClusterIdentifier")
  valid_774484 = validateParameter(valid_774484, JString, required = false,
                                 default = nil)
  if valid_774484 != nil:
    section.add "ClusterIdentifier", valid_774484
  var valid_774485 = query.getOrDefault("Marker")
  valid_774485 = validateParameter(valid_774485, JString, required = false,
                                 default = nil)
  if valid_774485 != nil:
    section.add "Marker", valid_774485
  var valid_774486 = query.getOrDefault("OwnerAccount")
  valid_774486 = validateParameter(valid_774486, JString, required = false,
                                 default = nil)
  if valid_774486 != nil:
    section.add "OwnerAccount", valid_774486
  var valid_774487 = query.getOrDefault("ClusterExists")
  valid_774487 = validateParameter(valid_774487, JBool, required = false, default = nil)
  if valid_774487 != nil:
    section.add "ClusterExists", valid_774487
  var valid_774488 = query.getOrDefault("SnapshotIdentifier")
  valid_774488 = validateParameter(valid_774488, JString, required = false,
                                 default = nil)
  if valid_774488 != nil:
    section.add "SnapshotIdentifier", valid_774488
  var valid_774489 = query.getOrDefault("TagKeys")
  valid_774489 = validateParameter(valid_774489, JArray, required = false,
                                 default = nil)
  if valid_774489 != nil:
    section.add "TagKeys", valid_774489
  var valid_774490 = query.getOrDefault("SnapshotType")
  valid_774490 = validateParameter(valid_774490, JString, required = false,
                                 default = nil)
  if valid_774490 != nil:
    section.add "SnapshotType", valid_774490
  var valid_774491 = query.getOrDefault("EndTime")
  valid_774491 = validateParameter(valid_774491, JString, required = false,
                                 default = nil)
  if valid_774491 != nil:
    section.add "EndTime", valid_774491
  var valid_774492 = query.getOrDefault("Version")
  valid_774492 = validateParameter(valid_774492, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_774492 != nil:
    section.add "Version", valid_774492
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_774493 = header.getOrDefault("X-Amz-Date")
  valid_774493 = validateParameter(valid_774493, JString, required = false,
                                 default = nil)
  if valid_774493 != nil:
    section.add "X-Amz-Date", valid_774493
  var valid_774494 = header.getOrDefault("X-Amz-Security-Token")
  valid_774494 = validateParameter(valid_774494, JString, required = false,
                                 default = nil)
  if valid_774494 != nil:
    section.add "X-Amz-Security-Token", valid_774494
  var valid_774495 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_774495 = validateParameter(valid_774495, JString, required = false,
                                 default = nil)
  if valid_774495 != nil:
    section.add "X-Amz-Content-Sha256", valid_774495
  var valid_774496 = header.getOrDefault("X-Amz-Algorithm")
  valid_774496 = validateParameter(valid_774496, JString, required = false,
                                 default = nil)
  if valid_774496 != nil:
    section.add "X-Amz-Algorithm", valid_774496
  var valid_774497 = header.getOrDefault("X-Amz-Signature")
  valid_774497 = validateParameter(valid_774497, JString, required = false,
                                 default = nil)
  if valid_774497 != nil:
    section.add "X-Amz-Signature", valid_774497
  var valid_774498 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_774498 = validateParameter(valid_774498, JString, required = false,
                                 default = nil)
  if valid_774498 != nil:
    section.add "X-Amz-SignedHeaders", valid_774498
  var valid_774499 = header.getOrDefault("X-Amz-Credential")
  valid_774499 = validateParameter(valid_774499, JString, required = false,
                                 default = nil)
  if valid_774499 != nil:
    section.add "X-Amz-Credential", valid_774499
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_774500: Call_GetDescribeClusterSnapshots_774476; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns one or more snapshot objects, which contain metadata about your cluster snapshots. By default, this operation returns information about all snapshots of all clusters that are owned by you AWS customer account. No information is returned for snapshots owned by inactive AWS customer accounts.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all snapshots that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all snapshots that have any combination of those values are returned. Only snapshots that you own are returned in the response; shared snapshots are not returned with the tag key and tag value request parameters.</p> <p>If both tag keys and values are omitted from the request, snapshots are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_774500.validator(path, query, header, formData, body)
  let scheme = call_774500.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_774500.url(scheme.get, call_774500.host, call_774500.base,
                         call_774500.route, valid.getOrDefault("path"))
  result = hook(call_774500, url, valid)

proc call*(call_774501: Call_GetDescribeClusterSnapshots_774476;
          TagValues: JsonNode = nil; SortingEntities: JsonNode = nil;
          MaxRecords: int = 0; StartTime: string = "";
          Action: string = "DescribeClusterSnapshots";
          ClusterIdentifier: string = ""; Marker: string = "";
          OwnerAccount: string = ""; ClusterExists: bool = false;
          SnapshotIdentifier: string = ""; TagKeys: JsonNode = nil;
          SnapshotType: string = ""; EndTime: string = "";
          Version: string = "2012-12-01"): Recallable =
  ## getDescribeClusterSnapshots
  ## <p>Returns one or more snapshot objects, which contain metadata about your cluster snapshots. By default, this operation returns information about all snapshots of all clusters that are owned by you AWS customer account. No information is returned for snapshots owned by inactive AWS customer accounts.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all snapshots that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all snapshots that have any combination of those values are returned. Only snapshots that you own are returned in the response; shared snapshots are not returned with the tag key and tag value request parameters.</p> <p>If both tag keys and values are omitted from the request, snapshots are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster snapshots that are associated with the specified tag value or values. For example, suppose that you have snapshots that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the snapshots that have either or both of these tag values associated with them.
  ##   SortingEntities: JArray
  ##                  : <p/>
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   StartTime: string
  ##            : <p>A value that requests only snapshots created at or after the specified time. The time value is specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2012-07-16T18:00:00Z</code> </p>
  ##   Action: string (required)
  ##   ClusterIdentifier: string
  ##                    : The identifier of the cluster which generated the requested snapshots.
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterSnapshots</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   OwnerAccount: string
  ##               : The AWS customer account used to create or copy the snapshot. Use this field to filter the results to snapshots owned by a particular account. To describe snapshots you own, either specify your AWS customer account, or do not specify the parameter.
  ##   ClusterExists: bool
  ##                : <p>A value that indicates whether to return snapshots only for an existing cluster. You can perform table-level restore only by using a snapshot of an existing cluster, that is, a cluster that has not been deleted. Values for this parameter work as follows: </p> <ul> <li> <p>If <code>ClusterExists</code> is set to <code>true</code>, <code>ClusterIdentifier</code> is required.</p> </li> <li> <p>If <code>ClusterExists</code> is set to <code>false</code> and <code>ClusterIdentifier</code> isn't specified, all snapshots associated with deleted clusters (orphaned snapshots) are returned. </p> </li> <li> <p>If <code>ClusterExists</code> is set to <code>false</code> and <code>ClusterIdentifier</code> is specified for a deleted cluster, snapshots associated with that cluster are returned.</p> </li> <li> <p>If <code>ClusterExists</code> is set to <code>false</code> and <code>ClusterIdentifier</code> is specified for an existing cluster, no snapshots are returned. </p> </li> </ul>
  ##   SnapshotIdentifier: string
  ##                     : The snapshot identifier of the snapshot about which to return information.
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster snapshots that are associated with the specified key or keys. For example, suppose that you have snapshots that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the snapshots that have either or both of these tag keys associated with them.
  ##   SnapshotType: string
  ##               : <p>The type of snapshots for which you are requesting information. By default, snapshots of all types are returned.</p> <p>Valid Values: <code>automated</code> | <code>manual</code> </p>
  ##   EndTime: string
  ##          : <p>A time value that requests only snapshots created at or before the specified time. The time value is specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2012-07-16T18:00:00Z</code> </p>
  ##   Version: string (required)
  var query_774502 = newJObject()
  if TagValues != nil:
    query_774502.add "TagValues", TagValues
  if SortingEntities != nil:
    query_774502.add "SortingEntities", SortingEntities
  add(query_774502, "MaxRecords", newJInt(MaxRecords))
  add(query_774502, "StartTime", newJString(StartTime))
  add(query_774502, "Action", newJString(Action))
  add(query_774502, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_774502, "Marker", newJString(Marker))
  add(query_774502, "OwnerAccount", newJString(OwnerAccount))
  add(query_774502, "ClusterExists", newJBool(ClusterExists))
  add(query_774502, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  if TagKeys != nil:
    query_774502.add "TagKeys", TagKeys
  add(query_774502, "SnapshotType", newJString(SnapshotType))
  add(query_774502, "EndTime", newJString(EndTime))
  add(query_774502, "Version", newJString(Version))
  result = call_774501.call(nil, query_774502, nil, nil, nil)

var getDescribeClusterSnapshots* = Call_GetDescribeClusterSnapshots_774476(
    name: "getDescribeClusterSnapshots", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusterSnapshots",
    validator: validate_GetDescribeClusterSnapshots_774477, base: "/",
    url: url_GetDescribeClusterSnapshots_774478,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeClusterSubnetGroups_774551 = ref object of OpenApiRestCall_772581
proc url_PostDescribeClusterSubnetGroups_774553(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_PostDescribeClusterSubnetGroups_774552(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns one or more cluster subnet group objects, which contain metadata about your cluster subnet groups. By default, this operation returns information about all cluster subnet groups that are defined in you AWS account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all subnet groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all subnet groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, subnet groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_774554 = query.getOrDefault("Action")
  valid_774554 = validateParameter(valid_774554, JString, required = true, default = newJString(
      "DescribeClusterSubnetGroups"))
  if valid_774554 != nil:
    section.add "Action", valid_774554
  var valid_774555 = query.getOrDefault("Version")
  valid_774555 = validateParameter(valid_774555, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_774555 != nil:
    section.add "Version", valid_774555
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_774556 = header.getOrDefault("X-Amz-Date")
  valid_774556 = validateParameter(valid_774556, JString, required = false,
                                 default = nil)
  if valid_774556 != nil:
    section.add "X-Amz-Date", valid_774556
  var valid_774557 = header.getOrDefault("X-Amz-Security-Token")
  valid_774557 = validateParameter(valid_774557, JString, required = false,
                                 default = nil)
  if valid_774557 != nil:
    section.add "X-Amz-Security-Token", valid_774557
  var valid_774558 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_774558 = validateParameter(valid_774558, JString, required = false,
                                 default = nil)
  if valid_774558 != nil:
    section.add "X-Amz-Content-Sha256", valid_774558
  var valid_774559 = header.getOrDefault("X-Amz-Algorithm")
  valid_774559 = validateParameter(valid_774559, JString, required = false,
                                 default = nil)
  if valid_774559 != nil:
    section.add "X-Amz-Algorithm", valid_774559
  var valid_774560 = header.getOrDefault("X-Amz-Signature")
  valid_774560 = validateParameter(valid_774560, JString, required = false,
                                 default = nil)
  if valid_774560 != nil:
    section.add "X-Amz-Signature", valid_774560
  var valid_774561 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_774561 = validateParameter(valid_774561, JString, required = false,
                                 default = nil)
  if valid_774561 != nil:
    section.add "X-Amz-SignedHeaders", valid_774561
  var valid_774562 = header.getOrDefault("X-Amz-Credential")
  valid_774562 = validateParameter(valid_774562, JString, required = false,
                                 default = nil)
  if valid_774562 != nil:
    section.add "X-Amz-Credential", valid_774562
  result.add "header", section
  ## parameters in `formData` object:
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterSubnetGroups</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster subnet groups that are associated with the specified key or keys. For example, suppose that you have subnet groups that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the subnet groups that have either or both of these tag keys associated with them.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster subnet groups that are associated with the specified tag value or values. For example, suppose that you have subnet groups that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the subnet groups that have either or both of these tag values associated with them.
  ##   ClusterSubnetGroupName: JString
  ##                         : The name of the cluster subnet group for which information is requested.
  section = newJObject()
  var valid_774563 = formData.getOrDefault("Marker")
  valid_774563 = validateParameter(valid_774563, JString, required = false,
                                 default = nil)
  if valid_774563 != nil:
    section.add "Marker", valid_774563
  var valid_774564 = formData.getOrDefault("TagKeys")
  valid_774564 = validateParameter(valid_774564, JArray, required = false,
                                 default = nil)
  if valid_774564 != nil:
    section.add "TagKeys", valid_774564
  var valid_774565 = formData.getOrDefault("MaxRecords")
  valid_774565 = validateParameter(valid_774565, JInt, required = false, default = nil)
  if valid_774565 != nil:
    section.add "MaxRecords", valid_774565
  var valid_774566 = formData.getOrDefault("TagValues")
  valid_774566 = validateParameter(valid_774566, JArray, required = false,
                                 default = nil)
  if valid_774566 != nil:
    section.add "TagValues", valid_774566
  var valid_774567 = formData.getOrDefault("ClusterSubnetGroupName")
  valid_774567 = validateParameter(valid_774567, JString, required = false,
                                 default = nil)
  if valid_774567 != nil:
    section.add "ClusterSubnetGroupName", valid_774567
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_774568: Call_PostDescribeClusterSubnetGroups_774551;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Returns one or more cluster subnet group objects, which contain metadata about your cluster subnet groups. By default, this operation returns information about all cluster subnet groups that are defined in you AWS account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all subnet groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all subnet groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, subnet groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_774568.validator(path, query, header, formData, body)
  let scheme = call_774568.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_774568.url(scheme.get, call_774568.host, call_774568.base,
                         call_774568.route, valid.getOrDefault("path"))
  result = hook(call_774568, url, valid)

proc call*(call_774569: Call_PostDescribeClusterSubnetGroups_774551;
          Marker: string = ""; Action: string = "DescribeClusterSubnetGroups";
          TagKeys: JsonNode = nil; MaxRecords: int = 0; TagValues: JsonNode = nil;
          Version: string = "2012-12-01"; ClusterSubnetGroupName: string = ""): Recallable =
  ## postDescribeClusterSubnetGroups
  ## <p>Returns one or more cluster subnet group objects, which contain metadata about your cluster subnet groups. By default, this operation returns information about all cluster subnet groups that are defined in you AWS account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all subnet groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all subnet groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, subnet groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterSubnetGroups</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Action: string (required)
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster subnet groups that are associated with the specified key or keys. For example, suppose that you have subnet groups that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the subnet groups that have either or both of these tag keys associated with them.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster subnet groups that are associated with the specified tag value or values. For example, suppose that you have subnet groups that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the subnet groups that have either or both of these tag values associated with them.
  ##   Version: string (required)
  ##   ClusterSubnetGroupName: string
  ##                         : The name of the cluster subnet group for which information is requested.
  var query_774570 = newJObject()
  var formData_774571 = newJObject()
  add(formData_774571, "Marker", newJString(Marker))
  add(query_774570, "Action", newJString(Action))
  if TagKeys != nil:
    formData_774571.add "TagKeys", TagKeys
  add(formData_774571, "MaxRecords", newJInt(MaxRecords))
  if TagValues != nil:
    formData_774571.add "TagValues", TagValues
  add(query_774570, "Version", newJString(Version))
  add(formData_774571, "ClusterSubnetGroupName",
      newJString(ClusterSubnetGroupName))
  result = call_774569.call(nil, query_774570, nil, formData_774571, nil)

var postDescribeClusterSubnetGroups* = Call_PostDescribeClusterSubnetGroups_774551(
    name: "postDescribeClusterSubnetGroups", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusterSubnetGroups",
    validator: validate_PostDescribeClusterSubnetGroups_774552, base: "/",
    url: url_PostDescribeClusterSubnetGroups_774553,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeClusterSubnetGroups_774531 = ref object of OpenApiRestCall_772581
proc url_GetDescribeClusterSubnetGroups_774533(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_GetDescribeClusterSubnetGroups_774532(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns one or more cluster subnet group objects, which contain metadata about your cluster subnet groups. By default, this operation returns information about all cluster subnet groups that are defined in you AWS account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all subnet groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all subnet groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, subnet groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster subnet groups that are associated with the specified tag value or values. For example, suppose that you have subnet groups that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the subnet groups that have either or both of these tag values associated with them.
  ##   ClusterSubnetGroupName: JString
  ##                         : The name of the cluster subnet group for which information is requested.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Action: JString (required)
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterSubnetGroups</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster subnet groups that are associated with the specified key or keys. For example, suppose that you have subnet groups that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the subnet groups that have either or both of these tag keys associated with them.
  ##   Version: JString (required)
  section = newJObject()
  var valid_774534 = query.getOrDefault("TagValues")
  valid_774534 = validateParameter(valid_774534, JArray, required = false,
                                 default = nil)
  if valid_774534 != nil:
    section.add "TagValues", valid_774534
  var valid_774535 = query.getOrDefault("ClusterSubnetGroupName")
  valid_774535 = validateParameter(valid_774535, JString, required = false,
                                 default = nil)
  if valid_774535 != nil:
    section.add "ClusterSubnetGroupName", valid_774535
  var valid_774536 = query.getOrDefault("MaxRecords")
  valid_774536 = validateParameter(valid_774536, JInt, required = false, default = nil)
  if valid_774536 != nil:
    section.add "MaxRecords", valid_774536
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_774537 = query.getOrDefault("Action")
  valid_774537 = validateParameter(valid_774537, JString, required = true, default = newJString(
      "DescribeClusterSubnetGroups"))
  if valid_774537 != nil:
    section.add "Action", valid_774537
  var valid_774538 = query.getOrDefault("Marker")
  valid_774538 = validateParameter(valid_774538, JString, required = false,
                                 default = nil)
  if valid_774538 != nil:
    section.add "Marker", valid_774538
  var valid_774539 = query.getOrDefault("TagKeys")
  valid_774539 = validateParameter(valid_774539, JArray, required = false,
                                 default = nil)
  if valid_774539 != nil:
    section.add "TagKeys", valid_774539
  var valid_774540 = query.getOrDefault("Version")
  valid_774540 = validateParameter(valid_774540, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_774540 != nil:
    section.add "Version", valid_774540
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_774541 = header.getOrDefault("X-Amz-Date")
  valid_774541 = validateParameter(valid_774541, JString, required = false,
                                 default = nil)
  if valid_774541 != nil:
    section.add "X-Amz-Date", valid_774541
  var valid_774542 = header.getOrDefault("X-Amz-Security-Token")
  valid_774542 = validateParameter(valid_774542, JString, required = false,
                                 default = nil)
  if valid_774542 != nil:
    section.add "X-Amz-Security-Token", valid_774542
  var valid_774543 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_774543 = validateParameter(valid_774543, JString, required = false,
                                 default = nil)
  if valid_774543 != nil:
    section.add "X-Amz-Content-Sha256", valid_774543
  var valid_774544 = header.getOrDefault("X-Amz-Algorithm")
  valid_774544 = validateParameter(valid_774544, JString, required = false,
                                 default = nil)
  if valid_774544 != nil:
    section.add "X-Amz-Algorithm", valid_774544
  var valid_774545 = header.getOrDefault("X-Amz-Signature")
  valid_774545 = validateParameter(valid_774545, JString, required = false,
                                 default = nil)
  if valid_774545 != nil:
    section.add "X-Amz-Signature", valid_774545
  var valid_774546 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_774546 = validateParameter(valid_774546, JString, required = false,
                                 default = nil)
  if valid_774546 != nil:
    section.add "X-Amz-SignedHeaders", valid_774546
  var valid_774547 = header.getOrDefault("X-Amz-Credential")
  valid_774547 = validateParameter(valid_774547, JString, required = false,
                                 default = nil)
  if valid_774547 != nil:
    section.add "X-Amz-Credential", valid_774547
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_774548: Call_GetDescribeClusterSubnetGroups_774531; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns one or more cluster subnet group objects, which contain metadata about your cluster subnet groups. By default, this operation returns information about all cluster subnet groups that are defined in you AWS account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all subnet groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all subnet groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, subnet groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_774548.validator(path, query, header, formData, body)
  let scheme = call_774548.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_774548.url(scheme.get, call_774548.host, call_774548.base,
                         call_774548.route, valid.getOrDefault("path"))
  result = hook(call_774548, url, valid)

proc call*(call_774549: Call_GetDescribeClusterSubnetGroups_774531;
          TagValues: JsonNode = nil; ClusterSubnetGroupName: string = "";
          MaxRecords: int = 0; Action: string = "DescribeClusterSubnetGroups";
          Marker: string = ""; TagKeys: JsonNode = nil; Version: string = "2012-12-01"): Recallable =
  ## getDescribeClusterSubnetGroups
  ## <p>Returns one or more cluster subnet group objects, which contain metadata about your cluster subnet groups. By default, this operation returns information about all cluster subnet groups that are defined in you AWS account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all subnet groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all subnet groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, subnet groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster subnet groups that are associated with the specified tag value or values. For example, suppose that you have subnet groups that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the subnet groups that have either or both of these tag values associated with them.
  ##   ClusterSubnetGroupName: string
  ##                         : The name of the cluster subnet group for which information is requested.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Action: string (required)
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterSubnetGroups</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster subnet groups that are associated with the specified key or keys. For example, suppose that you have subnet groups that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the subnet groups that have either or both of these tag keys associated with them.
  ##   Version: string (required)
  var query_774550 = newJObject()
  if TagValues != nil:
    query_774550.add "TagValues", TagValues
  add(query_774550, "ClusterSubnetGroupName", newJString(ClusterSubnetGroupName))
  add(query_774550, "MaxRecords", newJInt(MaxRecords))
  add(query_774550, "Action", newJString(Action))
  add(query_774550, "Marker", newJString(Marker))
  if TagKeys != nil:
    query_774550.add "TagKeys", TagKeys
  add(query_774550, "Version", newJString(Version))
  result = call_774549.call(nil, query_774550, nil, nil, nil)

var getDescribeClusterSubnetGroups* = Call_GetDescribeClusterSubnetGroups_774531(
    name: "getDescribeClusterSubnetGroups", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusterSubnetGroups",
    validator: validate_GetDescribeClusterSubnetGroups_774532, base: "/",
    url: url_GetDescribeClusterSubnetGroups_774533,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeClusterTracks_774590 = ref object of OpenApiRestCall_772581
proc url_PostDescribeClusterTracks_774592(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_PostDescribeClusterTracks_774591(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns a list of all the available maintenance tracks.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_774593 = query.getOrDefault("Action")
  valid_774593 = validateParameter(valid_774593, JString, required = true,
                                 default = newJString("DescribeClusterTracks"))
  if valid_774593 != nil:
    section.add "Action", valid_774593
  var valid_774594 = query.getOrDefault("Version")
  valid_774594 = validateParameter(valid_774594, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_774594 != nil:
    section.add "Version", valid_774594
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_774595 = header.getOrDefault("X-Amz-Date")
  valid_774595 = validateParameter(valid_774595, JString, required = false,
                                 default = nil)
  if valid_774595 != nil:
    section.add "X-Amz-Date", valid_774595
  var valid_774596 = header.getOrDefault("X-Amz-Security-Token")
  valid_774596 = validateParameter(valid_774596, JString, required = false,
                                 default = nil)
  if valid_774596 != nil:
    section.add "X-Amz-Security-Token", valid_774596
  var valid_774597 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_774597 = validateParameter(valid_774597, JString, required = false,
                                 default = nil)
  if valid_774597 != nil:
    section.add "X-Amz-Content-Sha256", valid_774597
  var valid_774598 = header.getOrDefault("X-Amz-Algorithm")
  valid_774598 = validateParameter(valid_774598, JString, required = false,
                                 default = nil)
  if valid_774598 != nil:
    section.add "X-Amz-Algorithm", valid_774598
  var valid_774599 = header.getOrDefault("X-Amz-Signature")
  valid_774599 = validateParameter(valid_774599, JString, required = false,
                                 default = nil)
  if valid_774599 != nil:
    section.add "X-Amz-Signature", valid_774599
  var valid_774600 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_774600 = validateParameter(valid_774600, JString, required = false,
                                 default = nil)
  if valid_774600 != nil:
    section.add "X-Amz-SignedHeaders", valid_774600
  var valid_774601 = header.getOrDefault("X-Amz-Credential")
  valid_774601 = validateParameter(valid_774601, JString, required = false,
                                 default = nil)
  if valid_774601 != nil:
    section.add "X-Amz-Credential", valid_774601
  result.add "header", section
  ## parameters in `formData` object:
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <code>DescribeClusterTracks</code> request exceed the value specified in <code>MaxRecords</code>, Amazon Redshift returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   MaxRecords: JInt
  ##             : An integer value for the maximum number of maintenance tracks to return.
  ##   MaintenanceTrackName: JString
  ##                       : The name of the maintenance track. 
  section = newJObject()
  var valid_774602 = formData.getOrDefault("Marker")
  valid_774602 = validateParameter(valid_774602, JString, required = false,
                                 default = nil)
  if valid_774602 != nil:
    section.add "Marker", valid_774602
  var valid_774603 = formData.getOrDefault("MaxRecords")
  valid_774603 = validateParameter(valid_774603, JInt, required = false, default = nil)
  if valid_774603 != nil:
    section.add "MaxRecords", valid_774603
  var valid_774604 = formData.getOrDefault("MaintenanceTrackName")
  valid_774604 = validateParameter(valid_774604, JString, required = false,
                                 default = nil)
  if valid_774604 != nil:
    section.add "MaintenanceTrackName", valid_774604
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_774605: Call_PostDescribeClusterTracks_774590; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns a list of all the available maintenance tracks.
  ## 
  let valid = call_774605.validator(path, query, header, formData, body)
  let scheme = call_774605.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_774605.url(scheme.get, call_774605.host, call_774605.base,
                         call_774605.route, valid.getOrDefault("path"))
  result = hook(call_774605, url, valid)

proc call*(call_774606: Call_PostDescribeClusterTracks_774590; Marker: string = "";
          Action: string = "DescribeClusterTracks"; MaxRecords: int = 0;
          Version: string = "2012-12-01"; MaintenanceTrackName: string = ""): Recallable =
  ## postDescribeClusterTracks
  ## Returns a list of all the available maintenance tracks.
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <code>DescribeClusterTracks</code> request exceed the value specified in <code>MaxRecords</code>, Amazon Redshift returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Action: string (required)
  ##   MaxRecords: int
  ##             : An integer value for the maximum number of maintenance tracks to return.
  ##   Version: string (required)
  ##   MaintenanceTrackName: string
  ##                       : The name of the maintenance track. 
  var query_774607 = newJObject()
  var formData_774608 = newJObject()
  add(formData_774608, "Marker", newJString(Marker))
  add(query_774607, "Action", newJString(Action))
  add(formData_774608, "MaxRecords", newJInt(MaxRecords))
  add(query_774607, "Version", newJString(Version))
  add(formData_774608, "MaintenanceTrackName", newJString(MaintenanceTrackName))
  result = call_774606.call(nil, query_774607, nil, formData_774608, nil)

var postDescribeClusterTracks* = Call_PostDescribeClusterTracks_774590(
    name: "postDescribeClusterTracks", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusterTracks",
    validator: validate_PostDescribeClusterTracks_774591, base: "/",
    url: url_PostDescribeClusterTracks_774592,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeClusterTracks_774572 = ref object of OpenApiRestCall_772581
proc url_GetDescribeClusterTracks_774574(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_GetDescribeClusterTracks_774573(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns a list of all the available maintenance tracks.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   MaintenanceTrackName: JString
  ##                       : The name of the maintenance track. 
  ##   MaxRecords: JInt
  ##             : An integer value for the maximum number of maintenance tracks to return.
  ##   Action: JString (required)
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <code>DescribeClusterTracks</code> request exceed the value specified in <code>MaxRecords</code>, Amazon Redshift returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Version: JString (required)
  section = newJObject()
  var valid_774575 = query.getOrDefault("MaintenanceTrackName")
  valid_774575 = validateParameter(valid_774575, JString, required = false,
                                 default = nil)
  if valid_774575 != nil:
    section.add "MaintenanceTrackName", valid_774575
  var valid_774576 = query.getOrDefault("MaxRecords")
  valid_774576 = validateParameter(valid_774576, JInt, required = false, default = nil)
  if valid_774576 != nil:
    section.add "MaxRecords", valid_774576
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_774577 = query.getOrDefault("Action")
  valid_774577 = validateParameter(valid_774577, JString, required = true,
                                 default = newJString("DescribeClusterTracks"))
  if valid_774577 != nil:
    section.add "Action", valid_774577
  var valid_774578 = query.getOrDefault("Marker")
  valid_774578 = validateParameter(valid_774578, JString, required = false,
                                 default = nil)
  if valid_774578 != nil:
    section.add "Marker", valid_774578
  var valid_774579 = query.getOrDefault("Version")
  valid_774579 = validateParameter(valid_774579, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_774579 != nil:
    section.add "Version", valid_774579
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_774580 = header.getOrDefault("X-Amz-Date")
  valid_774580 = validateParameter(valid_774580, JString, required = false,
                                 default = nil)
  if valid_774580 != nil:
    section.add "X-Amz-Date", valid_774580
  var valid_774581 = header.getOrDefault("X-Amz-Security-Token")
  valid_774581 = validateParameter(valid_774581, JString, required = false,
                                 default = nil)
  if valid_774581 != nil:
    section.add "X-Amz-Security-Token", valid_774581
  var valid_774582 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_774582 = validateParameter(valid_774582, JString, required = false,
                                 default = nil)
  if valid_774582 != nil:
    section.add "X-Amz-Content-Sha256", valid_774582
  var valid_774583 = header.getOrDefault("X-Amz-Algorithm")
  valid_774583 = validateParameter(valid_774583, JString, required = false,
                                 default = nil)
  if valid_774583 != nil:
    section.add "X-Amz-Algorithm", valid_774583
  var valid_774584 = header.getOrDefault("X-Amz-Signature")
  valid_774584 = validateParameter(valid_774584, JString, required = false,
                                 default = nil)
  if valid_774584 != nil:
    section.add "X-Amz-Signature", valid_774584
  var valid_774585 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_774585 = validateParameter(valid_774585, JString, required = false,
                                 default = nil)
  if valid_774585 != nil:
    section.add "X-Amz-SignedHeaders", valid_774585
  var valid_774586 = header.getOrDefault("X-Amz-Credential")
  valid_774586 = validateParameter(valid_774586, JString, required = false,
                                 default = nil)
  if valid_774586 != nil:
    section.add "X-Amz-Credential", valid_774586
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_774587: Call_GetDescribeClusterTracks_774572; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns a list of all the available maintenance tracks.
  ## 
  let valid = call_774587.validator(path, query, header, formData, body)
  let scheme = call_774587.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_774587.url(scheme.get, call_774587.host, call_774587.base,
                         call_774587.route, valid.getOrDefault("path"))
  result = hook(call_774587, url, valid)

proc call*(call_774588: Call_GetDescribeClusterTracks_774572;
          MaintenanceTrackName: string = ""; MaxRecords: int = 0;
          Action: string = "DescribeClusterTracks"; Marker: string = "";
          Version: string = "2012-12-01"): Recallable =
  ## getDescribeClusterTracks
  ## Returns a list of all the available maintenance tracks.
  ##   MaintenanceTrackName: string
  ##                       : The name of the maintenance track. 
  ##   MaxRecords: int
  ##             : An integer value for the maximum number of maintenance tracks to return.
  ##   Action: string (required)
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <code>DescribeClusterTracks</code> request exceed the value specified in <code>MaxRecords</code>, Amazon Redshift returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Version: string (required)
  var query_774589 = newJObject()
  add(query_774589, "MaintenanceTrackName", newJString(MaintenanceTrackName))
  add(query_774589, "MaxRecords", newJInt(MaxRecords))
  add(query_774589, "Action", newJString(Action))
  add(query_774589, "Marker", newJString(Marker))
  add(query_774589, "Version", newJString(Version))
  result = call_774588.call(nil, query_774589, nil, nil, nil)

var getDescribeClusterTracks* = Call_GetDescribeClusterTracks_774572(
    name: "getDescribeClusterTracks", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusterTracks",
    validator: validate_GetDescribeClusterTracks_774573, base: "/",
    url: url_GetDescribeClusterTracks_774574, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeClusterVersions_774628 = ref object of OpenApiRestCall_772581
proc url_PostDescribeClusterVersions_774630(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_PostDescribeClusterVersions_774629(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns descriptions of the available Amazon Redshift cluster versions. You can call this operation even before creating any clusters to learn more about the Amazon Redshift versions. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_774631 = query.getOrDefault("Action")
  valid_774631 = validateParameter(valid_774631, JString, required = true, default = newJString(
      "DescribeClusterVersions"))
  if valid_774631 != nil:
    section.add "Action", valid_774631
  var valid_774632 = query.getOrDefault("Version")
  valid_774632 = validateParameter(valid_774632, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_774632 != nil:
    section.add "Version", valid_774632
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_774633 = header.getOrDefault("X-Amz-Date")
  valid_774633 = validateParameter(valid_774633, JString, required = false,
                                 default = nil)
  if valid_774633 != nil:
    section.add "X-Amz-Date", valid_774633
  var valid_774634 = header.getOrDefault("X-Amz-Security-Token")
  valid_774634 = validateParameter(valid_774634, JString, required = false,
                                 default = nil)
  if valid_774634 != nil:
    section.add "X-Amz-Security-Token", valid_774634
  var valid_774635 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_774635 = validateParameter(valid_774635, JString, required = false,
                                 default = nil)
  if valid_774635 != nil:
    section.add "X-Amz-Content-Sha256", valid_774635
  var valid_774636 = header.getOrDefault("X-Amz-Algorithm")
  valid_774636 = validateParameter(valid_774636, JString, required = false,
                                 default = nil)
  if valid_774636 != nil:
    section.add "X-Amz-Algorithm", valid_774636
  var valid_774637 = header.getOrDefault("X-Amz-Signature")
  valid_774637 = validateParameter(valid_774637, JString, required = false,
                                 default = nil)
  if valid_774637 != nil:
    section.add "X-Amz-Signature", valid_774637
  var valid_774638 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_774638 = validateParameter(valid_774638, JString, required = false,
                                 default = nil)
  if valid_774638 != nil:
    section.add "X-Amz-SignedHeaders", valid_774638
  var valid_774639 = header.getOrDefault("X-Amz-Credential")
  valid_774639 = validateParameter(valid_774639, JString, required = false,
                                 default = nil)
  if valid_774639 != nil:
    section.add "X-Amz-Credential", valid_774639
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterVersion: JString
  ##                 : <p>The specific cluster version to return.</p> <p>Example: <code>1.0</code> </p>
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterVersions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   ClusterParameterGroupFamily: JString
  ##                              : <p>The name of a specific cluster parameter group family to return details for.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters</p> </li> <li> <p>First character must be a letter</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens</p> </li> </ul>
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  section = newJObject()
  var valid_774640 = formData.getOrDefault("ClusterVersion")
  valid_774640 = validateParameter(valid_774640, JString, required = false,
                                 default = nil)
  if valid_774640 != nil:
    section.add "ClusterVersion", valid_774640
  var valid_774641 = formData.getOrDefault("Marker")
  valid_774641 = validateParameter(valid_774641, JString, required = false,
                                 default = nil)
  if valid_774641 != nil:
    section.add "Marker", valid_774641
  var valid_774642 = formData.getOrDefault("ClusterParameterGroupFamily")
  valid_774642 = validateParameter(valid_774642, JString, required = false,
                                 default = nil)
  if valid_774642 != nil:
    section.add "ClusterParameterGroupFamily", valid_774642
  var valid_774643 = formData.getOrDefault("MaxRecords")
  valid_774643 = validateParameter(valid_774643, JInt, required = false, default = nil)
  if valid_774643 != nil:
    section.add "MaxRecords", valid_774643
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_774644: Call_PostDescribeClusterVersions_774628; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns descriptions of the available Amazon Redshift cluster versions. You can call this operation even before creating any clusters to learn more about the Amazon Redshift versions. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.
  ## 
  let valid = call_774644.validator(path, query, header, formData, body)
  let scheme = call_774644.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_774644.url(scheme.get, call_774644.host, call_774644.base,
                         call_774644.route, valid.getOrDefault("path"))
  result = hook(call_774644, url, valid)

proc call*(call_774645: Call_PostDescribeClusterVersions_774628;
          ClusterVersion: string = ""; Marker: string = "";
          Action: string = "DescribeClusterVersions";
          ClusterParameterGroupFamily: string = ""; MaxRecords: int = 0;
          Version: string = "2012-12-01"): Recallable =
  ## postDescribeClusterVersions
  ## Returns descriptions of the available Amazon Redshift cluster versions. You can call this operation even before creating any clusters to learn more about the Amazon Redshift versions. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.
  ##   ClusterVersion: string
  ##                 : <p>The specific cluster version to return.</p> <p>Example: <code>1.0</code> </p>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterVersions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Action: string (required)
  ##   ClusterParameterGroupFamily: string
  ##                              : <p>The name of a specific cluster parameter group family to return details for.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters</p> </li> <li> <p>First character must be a letter</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens</p> </li> </ul>
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Version: string (required)
  var query_774646 = newJObject()
  var formData_774647 = newJObject()
  add(formData_774647, "ClusterVersion", newJString(ClusterVersion))
  add(formData_774647, "Marker", newJString(Marker))
  add(query_774646, "Action", newJString(Action))
  add(formData_774647, "ClusterParameterGroupFamily",
      newJString(ClusterParameterGroupFamily))
  add(formData_774647, "MaxRecords", newJInt(MaxRecords))
  add(query_774646, "Version", newJString(Version))
  result = call_774645.call(nil, query_774646, nil, formData_774647, nil)

var postDescribeClusterVersions* = Call_PostDescribeClusterVersions_774628(
    name: "postDescribeClusterVersions", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusterVersions",
    validator: validate_PostDescribeClusterVersions_774629, base: "/",
    url: url_PostDescribeClusterVersions_774630,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeClusterVersions_774609 = ref object of OpenApiRestCall_772581
proc url_GetDescribeClusterVersions_774611(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_GetDescribeClusterVersions_774610(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns descriptions of the available Amazon Redshift cluster versions. You can call this operation even before creating any clusters to learn more about the Amazon Redshift versions. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Action: JString (required)
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterVersions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   ClusterVersion: JString
  ##                 : <p>The specific cluster version to return.</p> <p>Example: <code>1.0</code> </p>
  ##   Version: JString (required)
  ##   ClusterParameterGroupFamily: JString
  ##                              : <p>The name of a specific cluster parameter group family to return details for.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters</p> </li> <li> <p>First character must be a letter</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens</p> </li> </ul>
  section = newJObject()
  var valid_774612 = query.getOrDefault("MaxRecords")
  valid_774612 = validateParameter(valid_774612, JInt, required = false, default = nil)
  if valid_774612 != nil:
    section.add "MaxRecords", valid_774612
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_774613 = query.getOrDefault("Action")
  valid_774613 = validateParameter(valid_774613, JString, required = true, default = newJString(
      "DescribeClusterVersions"))
  if valid_774613 != nil:
    section.add "Action", valid_774613
  var valid_774614 = query.getOrDefault("Marker")
  valid_774614 = validateParameter(valid_774614, JString, required = false,
                                 default = nil)
  if valid_774614 != nil:
    section.add "Marker", valid_774614
  var valid_774615 = query.getOrDefault("ClusterVersion")
  valid_774615 = validateParameter(valid_774615, JString, required = false,
                                 default = nil)
  if valid_774615 != nil:
    section.add "ClusterVersion", valid_774615
  var valid_774616 = query.getOrDefault("Version")
  valid_774616 = validateParameter(valid_774616, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_774616 != nil:
    section.add "Version", valid_774616
  var valid_774617 = query.getOrDefault("ClusterParameterGroupFamily")
  valid_774617 = validateParameter(valid_774617, JString, required = false,
                                 default = nil)
  if valid_774617 != nil:
    section.add "ClusterParameterGroupFamily", valid_774617
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_774618 = header.getOrDefault("X-Amz-Date")
  valid_774618 = validateParameter(valid_774618, JString, required = false,
                                 default = nil)
  if valid_774618 != nil:
    section.add "X-Amz-Date", valid_774618
  var valid_774619 = header.getOrDefault("X-Amz-Security-Token")
  valid_774619 = validateParameter(valid_774619, JString, required = false,
                                 default = nil)
  if valid_774619 != nil:
    section.add "X-Amz-Security-Token", valid_774619
  var valid_774620 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_774620 = validateParameter(valid_774620, JString, required = false,
                                 default = nil)
  if valid_774620 != nil:
    section.add "X-Amz-Content-Sha256", valid_774620
  var valid_774621 = header.getOrDefault("X-Amz-Algorithm")
  valid_774621 = validateParameter(valid_774621, JString, required = false,
                                 default = nil)
  if valid_774621 != nil:
    section.add "X-Amz-Algorithm", valid_774621
  var valid_774622 = header.getOrDefault("X-Amz-Signature")
  valid_774622 = validateParameter(valid_774622, JString, required = false,
                                 default = nil)
  if valid_774622 != nil:
    section.add "X-Amz-Signature", valid_774622
  var valid_774623 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_774623 = validateParameter(valid_774623, JString, required = false,
                                 default = nil)
  if valid_774623 != nil:
    section.add "X-Amz-SignedHeaders", valid_774623
  var valid_774624 = header.getOrDefault("X-Amz-Credential")
  valid_774624 = validateParameter(valid_774624, JString, required = false,
                                 default = nil)
  if valid_774624 != nil:
    section.add "X-Amz-Credential", valid_774624
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_774625: Call_GetDescribeClusterVersions_774609; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns descriptions of the available Amazon Redshift cluster versions. You can call this operation even before creating any clusters to learn more about the Amazon Redshift versions. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.
  ## 
  let valid = call_774625.validator(path, query, header, formData, body)
  let scheme = call_774625.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_774625.url(scheme.get, call_774625.host, call_774625.base,
                         call_774625.route, valid.getOrDefault("path"))
  result = hook(call_774625, url, valid)

proc call*(call_774626: Call_GetDescribeClusterVersions_774609;
          MaxRecords: int = 0; Action: string = "DescribeClusterVersions";
          Marker: string = ""; ClusterVersion: string = "";
          Version: string = "2012-12-01"; ClusterParameterGroupFamily: string = ""): Recallable =
  ## getDescribeClusterVersions
  ## Returns descriptions of the available Amazon Redshift cluster versions. You can call this operation even before creating any clusters to learn more about the Amazon Redshift versions. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Action: string (required)
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterVersions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   ClusterVersion: string
  ##                 : <p>The specific cluster version to return.</p> <p>Example: <code>1.0</code> </p>
  ##   Version: string (required)
  ##   ClusterParameterGroupFamily: string
  ##                              : <p>The name of a specific cluster parameter group family to return details for.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters</p> </li> <li> <p>First character must be a letter</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens</p> </li> </ul>
  var query_774627 = newJObject()
  add(query_774627, "MaxRecords", newJInt(MaxRecords))
  add(query_774627, "Action", newJString(Action))
  add(query_774627, "Marker", newJString(Marker))
  add(query_774627, "ClusterVersion", newJString(ClusterVersion))
  add(query_774627, "Version", newJString(Version))
  add(query_774627, "ClusterParameterGroupFamily",
      newJString(ClusterParameterGroupFamily))
  result = call_774626.call(nil, query_774627, nil, nil, nil)

var getDescribeClusterVersions* = Call_GetDescribeClusterVersions_774609(
    name: "getDescribeClusterVersions", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusterVersions",
    validator: validate_GetDescribeClusterVersions_774610, base: "/",
    url: url_GetDescribeClusterVersions_774611,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeClusters_774668 = ref object of OpenApiRestCall_772581
proc url_PostDescribeClusters_774670(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_PostDescribeClusters_774669(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns properties of provisioned clusters including general cluster properties, cluster database properties, maintenance and backup properties, and security and access properties. This operation supports pagination. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all clusters that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all clusters that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, clusters are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_774671 = query.getOrDefault("Action")
  valid_774671 = validateParameter(valid_774671, JString, required = true,
                                 default = newJString("DescribeClusters"))
  if valid_774671 != nil:
    section.add "Action", valid_774671
  var valid_774672 = query.getOrDefault("Version")
  valid_774672 = validateParameter(valid_774672, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_774672 != nil:
    section.add "Version", valid_774672
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_774673 = header.getOrDefault("X-Amz-Date")
  valid_774673 = validateParameter(valid_774673, JString, required = false,
                                 default = nil)
  if valid_774673 != nil:
    section.add "X-Amz-Date", valid_774673
  var valid_774674 = header.getOrDefault("X-Amz-Security-Token")
  valid_774674 = validateParameter(valid_774674, JString, required = false,
                                 default = nil)
  if valid_774674 != nil:
    section.add "X-Amz-Security-Token", valid_774674
  var valid_774675 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_774675 = validateParameter(valid_774675, JString, required = false,
                                 default = nil)
  if valid_774675 != nil:
    section.add "X-Amz-Content-Sha256", valid_774675
  var valid_774676 = header.getOrDefault("X-Amz-Algorithm")
  valid_774676 = validateParameter(valid_774676, JString, required = false,
                                 default = nil)
  if valid_774676 != nil:
    section.add "X-Amz-Algorithm", valid_774676
  var valid_774677 = header.getOrDefault("X-Amz-Signature")
  valid_774677 = validateParameter(valid_774677, JString, required = false,
                                 default = nil)
  if valid_774677 != nil:
    section.add "X-Amz-Signature", valid_774677
  var valid_774678 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_774678 = validateParameter(valid_774678, JString, required = false,
                                 default = nil)
  if valid_774678 != nil:
    section.add "X-Amz-SignedHeaders", valid_774678
  var valid_774679 = header.getOrDefault("X-Amz-Credential")
  valid_774679 = validateParameter(valid_774679, JString, required = false,
                                 default = nil)
  if valid_774679 != nil:
    section.add "X-Amz-Credential", valid_774679
  result.add "header", section
  ## parameters in `formData` object:
  ##   Marker: JString
  ##         : <p>An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusters</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <b>ClusterIdentifier</b> parameter or the <b>Marker</b> parameter, but not both. </p>
  ##   ClusterIdentifier: JString
  ##                    : <p>The unique identifier of a cluster whose properties you are requesting. This parameter is case sensitive.</p> <p>The default is that all clusters defined for an account are returned.</p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching clusters that are associated with the specified key or keys. For example, suppose that you have clusters that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the clusters that have either or both of these tag keys associated with them.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching clusters that are associated with the specified tag value or values. For example, suppose that you have clusters that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the clusters that have either or both of these tag values associated with them.
  section = newJObject()
  var valid_774680 = formData.getOrDefault("Marker")
  valid_774680 = validateParameter(valid_774680, JString, required = false,
                                 default = nil)
  if valid_774680 != nil:
    section.add "Marker", valid_774680
  var valid_774681 = formData.getOrDefault("ClusterIdentifier")
  valid_774681 = validateParameter(valid_774681, JString, required = false,
                                 default = nil)
  if valid_774681 != nil:
    section.add "ClusterIdentifier", valid_774681
  var valid_774682 = formData.getOrDefault("TagKeys")
  valid_774682 = validateParameter(valid_774682, JArray, required = false,
                                 default = nil)
  if valid_774682 != nil:
    section.add "TagKeys", valid_774682
  var valid_774683 = formData.getOrDefault("MaxRecords")
  valid_774683 = validateParameter(valid_774683, JInt, required = false, default = nil)
  if valid_774683 != nil:
    section.add "MaxRecords", valid_774683
  var valid_774684 = formData.getOrDefault("TagValues")
  valid_774684 = validateParameter(valid_774684, JArray, required = false,
                                 default = nil)
  if valid_774684 != nil:
    section.add "TagValues", valid_774684
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_774685: Call_PostDescribeClusters_774668; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns properties of provisioned clusters including general cluster properties, cluster database properties, maintenance and backup properties, and security and access properties. This operation supports pagination. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all clusters that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all clusters that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, clusters are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_774685.validator(path, query, header, formData, body)
  let scheme = call_774685.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_774685.url(scheme.get, call_774685.host, call_774685.base,
                         call_774685.route, valid.getOrDefault("path"))
  result = hook(call_774685, url, valid)

proc call*(call_774686: Call_PostDescribeClusters_774668; Marker: string = "";
          Action: string = "DescribeClusters"; ClusterIdentifier: string = "";
          TagKeys: JsonNode = nil; MaxRecords: int = 0; TagValues: JsonNode = nil;
          Version: string = "2012-12-01"): Recallable =
  ## postDescribeClusters
  ## <p>Returns properties of provisioned clusters including general cluster properties, cluster database properties, maintenance and backup properties, and security and access properties. This operation supports pagination. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all clusters that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all clusters that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, clusters are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   Marker: string
  ##         : <p>An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusters</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <b>ClusterIdentifier</b> parameter or the <b>Marker</b> parameter, but not both. </p>
  ##   Action: string (required)
  ##   ClusterIdentifier: string
  ##                    : <p>The unique identifier of a cluster whose properties you are requesting. This parameter is case sensitive.</p> <p>The default is that all clusters defined for an account are returned.</p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching clusters that are associated with the specified key or keys. For example, suppose that you have clusters that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the clusters that have either or both of these tag keys associated with them.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching clusters that are associated with the specified tag value or values. For example, suppose that you have clusters that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the clusters that have either or both of these tag values associated with them.
  ##   Version: string (required)
  var query_774687 = newJObject()
  var formData_774688 = newJObject()
  add(formData_774688, "Marker", newJString(Marker))
  add(query_774687, "Action", newJString(Action))
  add(formData_774688, "ClusterIdentifier", newJString(ClusterIdentifier))
  if TagKeys != nil:
    formData_774688.add "TagKeys", TagKeys
  add(formData_774688, "MaxRecords", newJInt(MaxRecords))
  if TagValues != nil:
    formData_774688.add "TagValues", TagValues
  add(query_774687, "Version", newJString(Version))
  result = call_774686.call(nil, query_774687, nil, formData_774688, nil)

var postDescribeClusters* = Call_PostDescribeClusters_774668(
    name: "postDescribeClusters", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusters",
    validator: validate_PostDescribeClusters_774669, base: "/",
    url: url_PostDescribeClusters_774670, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeClusters_774648 = ref object of OpenApiRestCall_772581
proc url_GetDescribeClusters_774650(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_GetDescribeClusters_774649(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## <p>Returns properties of provisioned clusters including general cluster properties, cluster database properties, maintenance and backup properties, and security and access properties. This operation supports pagination. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all clusters that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all clusters that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, clusters are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching clusters that are associated with the specified tag value or values. For example, suppose that you have clusters that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the clusters that have either or both of these tag values associated with them.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString
  ##                    : <p>The unique identifier of a cluster whose properties you are requesting. This parameter is case sensitive.</p> <p>The default is that all clusters defined for an account are returned.</p>
  ##   Marker: JString
  ##         : <p>An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusters</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <b>ClusterIdentifier</b> parameter or the <b>Marker</b> parameter, but not both. </p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching clusters that are associated with the specified key or keys. For example, suppose that you have clusters that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the clusters that have either or both of these tag keys associated with them.
  ##   Version: JString (required)
  section = newJObject()
  var valid_774651 = query.getOrDefault("TagValues")
  valid_774651 = validateParameter(valid_774651, JArray, required = false,
                                 default = nil)
  if valid_774651 != nil:
    section.add "TagValues", valid_774651
  var valid_774652 = query.getOrDefault("MaxRecords")
  valid_774652 = validateParameter(valid_774652, JInt, required = false, default = nil)
  if valid_774652 != nil:
    section.add "MaxRecords", valid_774652
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_774653 = query.getOrDefault("Action")
  valid_774653 = validateParameter(valid_774653, JString, required = true,
                                 default = newJString("DescribeClusters"))
  if valid_774653 != nil:
    section.add "Action", valid_774653
  var valid_774654 = query.getOrDefault("ClusterIdentifier")
  valid_774654 = validateParameter(valid_774654, JString, required = false,
                                 default = nil)
  if valid_774654 != nil:
    section.add "ClusterIdentifier", valid_774654
  var valid_774655 = query.getOrDefault("Marker")
  valid_774655 = validateParameter(valid_774655, JString, required = false,
                                 default = nil)
  if valid_774655 != nil:
    section.add "Marker", valid_774655
  var valid_774656 = query.getOrDefault("TagKeys")
  valid_774656 = validateParameter(valid_774656, JArray, required = false,
                                 default = nil)
  if valid_774656 != nil:
    section.add "TagKeys", valid_774656
  var valid_774657 = query.getOrDefault("Version")
  valid_774657 = validateParameter(valid_774657, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_774657 != nil:
    section.add "Version", valid_774657
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_774658 = header.getOrDefault("X-Amz-Date")
  valid_774658 = validateParameter(valid_774658, JString, required = false,
                                 default = nil)
  if valid_774658 != nil:
    section.add "X-Amz-Date", valid_774658
  var valid_774659 = header.getOrDefault("X-Amz-Security-Token")
  valid_774659 = validateParameter(valid_774659, JString, required = false,
                                 default = nil)
  if valid_774659 != nil:
    section.add "X-Amz-Security-Token", valid_774659
  var valid_774660 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_774660 = validateParameter(valid_774660, JString, required = false,
                                 default = nil)
  if valid_774660 != nil:
    section.add "X-Amz-Content-Sha256", valid_774660
  var valid_774661 = header.getOrDefault("X-Amz-Algorithm")
  valid_774661 = validateParameter(valid_774661, JString, required = false,
                                 default = nil)
  if valid_774661 != nil:
    section.add "X-Amz-Algorithm", valid_774661
  var valid_774662 = header.getOrDefault("X-Amz-Signature")
  valid_774662 = validateParameter(valid_774662, JString, required = false,
                                 default = nil)
  if valid_774662 != nil:
    section.add "X-Amz-Signature", valid_774662
  var valid_774663 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_774663 = validateParameter(valid_774663, JString, required = false,
                                 default = nil)
  if valid_774663 != nil:
    section.add "X-Amz-SignedHeaders", valid_774663
  var valid_774664 = header.getOrDefault("X-Amz-Credential")
  valid_774664 = validateParameter(valid_774664, JString, required = false,
                                 default = nil)
  if valid_774664 != nil:
    section.add "X-Amz-Credential", valid_774664
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_774665: Call_GetDescribeClusters_774648; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns properties of provisioned clusters including general cluster properties, cluster database properties, maintenance and backup properties, and security and access properties. This operation supports pagination. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all clusters that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all clusters that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, clusters are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_774665.validator(path, query, header, formData, body)
  let scheme = call_774665.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_774665.url(scheme.get, call_774665.host, call_774665.base,
                         call_774665.route, valid.getOrDefault("path"))
  result = hook(call_774665, url, valid)

proc call*(call_774666: Call_GetDescribeClusters_774648; TagValues: JsonNode = nil;
          MaxRecords: int = 0; Action: string = "DescribeClusters";
          ClusterIdentifier: string = ""; Marker: string = ""; TagKeys: JsonNode = nil;
          Version: string = "2012-12-01"): Recallable =
  ## getDescribeClusters
  ## <p>Returns properties of provisioned clusters including general cluster properties, cluster database properties, maintenance and backup properties, and security and access properties. This operation supports pagination. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all clusters that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all clusters that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, clusters are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching clusters that are associated with the specified tag value or values. For example, suppose that you have clusters that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the clusters that have either or both of these tag values associated with them.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Action: string (required)
  ##   ClusterIdentifier: string
  ##                    : <p>The unique identifier of a cluster whose properties you are requesting. This parameter is case sensitive.</p> <p>The default is that all clusters defined for an account are returned.</p>
  ##   Marker: string
  ##         : <p>An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusters</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <b>ClusterIdentifier</b> parameter or the <b>Marker</b> parameter, but not both. </p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching clusters that are associated with the specified key or keys. For example, suppose that you have clusters that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the clusters that have either or both of these tag keys associated with them.
  ##   Version: string (required)
  var query_774667 = newJObject()
  if TagValues != nil:
    query_774667.add "TagValues", TagValues
  add(query_774667, "MaxRecords", newJInt(MaxRecords))
  add(query_774667, "Action", newJString(Action))
  add(query_774667, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_774667, "Marker", newJString(Marker))
  if TagKeys != nil:
    query_774667.add "TagKeys", TagKeys
  add(query_774667, "Version", newJString(Version))
  result = call_774666.call(nil, query_774667, nil, nil, nil)

var getDescribeClusters* = Call_GetDescribeClusters_774648(
    name: "getDescribeClusters", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusters",
    validator: validate_GetDescribeClusters_774649, base: "/",
    url: url_GetDescribeClusters_774650, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeDefaultClusterParameters_774707 = ref object of OpenApiRestCall_772581
proc url_PostDescribeDefaultClusterParameters_774709(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_PostDescribeDefaultClusterParameters_774708(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns a list of parameter settings for the specified parameter group family.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_774710 = query.getOrDefault("Action")
  valid_774710 = validateParameter(valid_774710, JString, required = true, default = newJString(
      "DescribeDefaultClusterParameters"))
  if valid_774710 != nil:
    section.add "Action", valid_774710
  var valid_774711 = query.getOrDefault("Version")
  valid_774711 = validateParameter(valid_774711, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_774711 != nil:
    section.add "Version", valid_774711
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_774712 = header.getOrDefault("X-Amz-Date")
  valid_774712 = validateParameter(valid_774712, JString, required = false,
                                 default = nil)
  if valid_774712 != nil:
    section.add "X-Amz-Date", valid_774712
  var valid_774713 = header.getOrDefault("X-Amz-Security-Token")
  valid_774713 = validateParameter(valid_774713, JString, required = false,
                                 default = nil)
  if valid_774713 != nil:
    section.add "X-Amz-Security-Token", valid_774713
  var valid_774714 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_774714 = validateParameter(valid_774714, JString, required = false,
                                 default = nil)
  if valid_774714 != nil:
    section.add "X-Amz-Content-Sha256", valid_774714
  var valid_774715 = header.getOrDefault("X-Amz-Algorithm")
  valid_774715 = validateParameter(valid_774715, JString, required = false,
                                 default = nil)
  if valid_774715 != nil:
    section.add "X-Amz-Algorithm", valid_774715
  var valid_774716 = header.getOrDefault("X-Amz-Signature")
  valid_774716 = validateParameter(valid_774716, JString, required = false,
                                 default = nil)
  if valid_774716 != nil:
    section.add "X-Amz-Signature", valid_774716
  var valid_774717 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_774717 = validateParameter(valid_774717, JString, required = false,
                                 default = nil)
  if valid_774717 != nil:
    section.add "X-Amz-SignedHeaders", valid_774717
  var valid_774718 = header.getOrDefault("X-Amz-Credential")
  valid_774718 = validateParameter(valid_774718, JString, required = false,
                                 default = nil)
  if valid_774718 != nil:
    section.add "X-Amz-Credential", valid_774718
  result.add "header", section
  ## parameters in `formData` object:
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeDefaultClusterParameters</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   ParameterGroupFamily: JString (required)
  ##                       : The name of the cluster parameter group family.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  section = newJObject()
  var valid_774719 = formData.getOrDefault("Marker")
  valid_774719 = validateParameter(valid_774719, JString, required = false,
                                 default = nil)
  if valid_774719 != nil:
    section.add "Marker", valid_774719
  assert formData != nil, "formData argument is necessary due to required `ParameterGroupFamily` field"
  var valid_774720 = formData.getOrDefault("ParameterGroupFamily")
  valid_774720 = validateParameter(valid_774720, JString, required = true,
                                 default = nil)
  if valid_774720 != nil:
    section.add "ParameterGroupFamily", valid_774720
  var valid_774721 = formData.getOrDefault("MaxRecords")
  valid_774721 = validateParameter(valid_774721, JInt, required = false, default = nil)
  if valid_774721 != nil:
    section.add "MaxRecords", valid_774721
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_774722: Call_PostDescribeDefaultClusterParameters_774707;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Returns a list of parameter settings for the specified parameter group family.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_774722.validator(path, query, header, formData, body)
  let scheme = call_774722.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_774722.url(scheme.get, call_774722.host, call_774722.base,
                         call_774722.route, valid.getOrDefault("path"))
  result = hook(call_774722, url, valid)

proc call*(call_774723: Call_PostDescribeDefaultClusterParameters_774707;
          ParameterGroupFamily: string; Marker: string = "";
          Action: string = "DescribeDefaultClusterParameters"; MaxRecords: int = 0;
          Version: string = "2012-12-01"): Recallable =
  ## postDescribeDefaultClusterParameters
  ## <p>Returns a list of parameter settings for the specified parameter group family.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeDefaultClusterParameters</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Action: string (required)
  ##   ParameterGroupFamily: string (required)
  ##                       : The name of the cluster parameter group family.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Version: string (required)
  var query_774724 = newJObject()
  var formData_774725 = newJObject()
  add(formData_774725, "Marker", newJString(Marker))
  add(query_774724, "Action", newJString(Action))
  add(formData_774725, "ParameterGroupFamily", newJString(ParameterGroupFamily))
  add(formData_774725, "MaxRecords", newJInt(MaxRecords))
  add(query_774724, "Version", newJString(Version))
  result = call_774723.call(nil, query_774724, nil, formData_774725, nil)

var postDescribeDefaultClusterParameters* = Call_PostDescribeDefaultClusterParameters_774707(
    name: "postDescribeDefaultClusterParameters", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeDefaultClusterParameters",
    validator: validate_PostDescribeDefaultClusterParameters_774708, base: "/",
    url: url_PostDescribeDefaultClusterParameters_774709,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeDefaultClusterParameters_774689 = ref object of OpenApiRestCall_772581
proc url_GetDescribeDefaultClusterParameters_774691(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_GetDescribeDefaultClusterParameters_774690(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns a list of parameter settings for the specified parameter group family.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Action: JString (required)
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeDefaultClusterParameters</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   ParameterGroupFamily: JString (required)
  ##                       : The name of the cluster parameter group family.
  ##   Version: JString (required)
  section = newJObject()
  var valid_774692 = query.getOrDefault("MaxRecords")
  valid_774692 = validateParameter(valid_774692, JInt, required = false, default = nil)
  if valid_774692 != nil:
    section.add "MaxRecords", valid_774692
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_774693 = query.getOrDefault("Action")
  valid_774693 = validateParameter(valid_774693, JString, required = true, default = newJString(
      "DescribeDefaultClusterParameters"))
  if valid_774693 != nil:
    section.add "Action", valid_774693
  var valid_774694 = query.getOrDefault("Marker")
  valid_774694 = validateParameter(valid_774694, JString, required = false,
                                 default = nil)
  if valid_774694 != nil:
    section.add "Marker", valid_774694
  var valid_774695 = query.getOrDefault("ParameterGroupFamily")
  valid_774695 = validateParameter(valid_774695, JString, required = true,
                                 default = nil)
  if valid_774695 != nil:
    section.add "ParameterGroupFamily", valid_774695
  var valid_774696 = query.getOrDefault("Version")
  valid_774696 = validateParameter(valid_774696, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_774696 != nil:
    section.add "Version", valid_774696
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_774697 = header.getOrDefault("X-Amz-Date")
  valid_774697 = validateParameter(valid_774697, JString, required = false,
                                 default = nil)
  if valid_774697 != nil:
    section.add "X-Amz-Date", valid_774697
  var valid_774698 = header.getOrDefault("X-Amz-Security-Token")
  valid_774698 = validateParameter(valid_774698, JString, required = false,
                                 default = nil)
  if valid_774698 != nil:
    section.add "X-Amz-Security-Token", valid_774698
  var valid_774699 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_774699 = validateParameter(valid_774699, JString, required = false,
                                 default = nil)
  if valid_774699 != nil:
    section.add "X-Amz-Content-Sha256", valid_774699
  var valid_774700 = header.getOrDefault("X-Amz-Algorithm")
  valid_774700 = validateParameter(valid_774700, JString, required = false,
                                 default = nil)
  if valid_774700 != nil:
    section.add "X-Amz-Algorithm", valid_774700
  var valid_774701 = header.getOrDefault("X-Amz-Signature")
  valid_774701 = validateParameter(valid_774701, JString, required = false,
                                 default = nil)
  if valid_774701 != nil:
    section.add "X-Amz-Signature", valid_774701
  var valid_774702 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_774702 = validateParameter(valid_774702, JString, required = false,
                                 default = nil)
  if valid_774702 != nil:
    section.add "X-Amz-SignedHeaders", valid_774702
  var valid_774703 = header.getOrDefault("X-Amz-Credential")
  valid_774703 = validateParameter(valid_774703, JString, required = false,
                                 default = nil)
  if valid_774703 != nil:
    section.add "X-Amz-Credential", valid_774703
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_774704: Call_GetDescribeDefaultClusterParameters_774689;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Returns a list of parameter settings for the specified parameter group family.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_774704.validator(path, query, header, formData, body)
  let scheme = call_774704.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_774704.url(scheme.get, call_774704.host, call_774704.base,
                         call_774704.route, valid.getOrDefault("path"))
  result = hook(call_774704, url, valid)

proc call*(call_774705: Call_GetDescribeDefaultClusterParameters_774689;
          ParameterGroupFamily: string; MaxRecords: int = 0;
          Action: string = "DescribeDefaultClusterParameters"; Marker: string = "";
          Version: string = "2012-12-01"): Recallable =
  ## getDescribeDefaultClusterParameters
  ## <p>Returns a list of parameter settings for the specified parameter group family.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Action: string (required)
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeDefaultClusterParameters</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   ParameterGroupFamily: string (required)
  ##                       : The name of the cluster parameter group family.
  ##   Version: string (required)
  var query_774706 = newJObject()
  add(query_774706, "MaxRecords", newJInt(MaxRecords))
  add(query_774706, "Action", newJString(Action))
  add(query_774706, "Marker", newJString(Marker))
  add(query_774706, "ParameterGroupFamily", newJString(ParameterGroupFamily))
  add(query_774706, "Version", newJString(Version))
  result = call_774705.call(nil, query_774706, nil, nil, nil)

var getDescribeDefaultClusterParameters* = Call_GetDescribeDefaultClusterParameters_774689(
    name: "getDescribeDefaultClusterParameters", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeDefaultClusterParameters",
    validator: validate_GetDescribeDefaultClusterParameters_774690, base: "/",
    url: url_GetDescribeDefaultClusterParameters_774691,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeEventCategories_774742 = ref object of OpenApiRestCall_772581
proc url_PostDescribeEventCategories_774744(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_PostDescribeEventCategories_774743(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Displays a list of event categories for all event source types, or for a specified source type. For a list of the event categories and source types, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-event-notifications.html">Amazon Redshift Event Notifications</a>.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_774745 = query.getOrDefault("Action")
  valid_774745 = validateParameter(valid_774745, JString, required = true, default = newJString(
      "DescribeEventCategories"))
  if valid_774745 != nil:
    section.add "Action", valid_774745
  var valid_774746 = query.getOrDefault("Version")
  valid_774746 = validateParameter(valid_774746, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_774746 != nil:
    section.add "Version", valid_774746
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_774747 = header.getOrDefault("X-Amz-Date")
  valid_774747 = validateParameter(valid_774747, JString, required = false,
                                 default = nil)
  if valid_774747 != nil:
    section.add "X-Amz-Date", valid_774747
  var valid_774748 = header.getOrDefault("X-Amz-Security-Token")
  valid_774748 = validateParameter(valid_774748, JString, required = false,
                                 default = nil)
  if valid_774748 != nil:
    section.add "X-Amz-Security-Token", valid_774748
  var valid_774749 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_774749 = validateParameter(valid_774749, JString, required = false,
                                 default = nil)
  if valid_774749 != nil:
    section.add "X-Amz-Content-Sha256", valid_774749
  var valid_774750 = header.getOrDefault("X-Amz-Algorithm")
  valid_774750 = validateParameter(valid_774750, JString, required = false,
                                 default = nil)
  if valid_774750 != nil:
    section.add "X-Amz-Algorithm", valid_774750
  var valid_774751 = header.getOrDefault("X-Amz-Signature")
  valid_774751 = validateParameter(valid_774751, JString, required = false,
                                 default = nil)
  if valid_774751 != nil:
    section.add "X-Amz-Signature", valid_774751
  var valid_774752 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_774752 = validateParameter(valid_774752, JString, required = false,
                                 default = nil)
  if valid_774752 != nil:
    section.add "X-Amz-SignedHeaders", valid_774752
  var valid_774753 = header.getOrDefault("X-Amz-Credential")
  valid_774753 = validateParameter(valid_774753, JString, required = false,
                                 default = nil)
  if valid_774753 != nil:
    section.add "X-Amz-Credential", valid_774753
  result.add "header", section
  ## parameters in `formData` object:
  ##   SourceType: JString
  ##             : <p>The source type, such as cluster or parameter group, to which the described event categories apply.</p> <p>Valid values: cluster, cluster-snapshot, cluster-parameter-group, and cluster-security-group.</p>
  section = newJObject()
  var valid_774754 = formData.getOrDefault("SourceType")
  valid_774754 = validateParameter(valid_774754, JString, required = false,
                                 default = nil)
  if valid_774754 != nil:
    section.add "SourceType", valid_774754
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_774755: Call_PostDescribeEventCategories_774742; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Displays a list of event categories for all event source types, or for a specified source type. For a list of the event categories and source types, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-event-notifications.html">Amazon Redshift Event Notifications</a>.
  ## 
  let valid = call_774755.validator(path, query, header, formData, body)
  let scheme = call_774755.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_774755.url(scheme.get, call_774755.host, call_774755.base,
                         call_774755.route, valid.getOrDefault("path"))
  result = hook(call_774755, url, valid)

proc call*(call_774756: Call_PostDescribeEventCategories_774742;
          Action: string = "DescribeEventCategories";
          Version: string = "2012-12-01"; SourceType: string = ""): Recallable =
  ## postDescribeEventCategories
  ## Displays a list of event categories for all event source types, or for a specified source type. For a list of the event categories and source types, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-event-notifications.html">Amazon Redshift Event Notifications</a>.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   SourceType: string
  ##             : <p>The source type, such as cluster or parameter group, to which the described event categories apply.</p> <p>Valid values: cluster, cluster-snapshot, cluster-parameter-group, and cluster-security-group.</p>
  var query_774757 = newJObject()
  var formData_774758 = newJObject()
  add(query_774757, "Action", newJString(Action))
  add(query_774757, "Version", newJString(Version))
  add(formData_774758, "SourceType", newJString(SourceType))
  result = call_774756.call(nil, query_774757, nil, formData_774758, nil)

var postDescribeEventCategories* = Call_PostDescribeEventCategories_774742(
    name: "postDescribeEventCategories", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeEventCategories",
    validator: validate_PostDescribeEventCategories_774743, base: "/",
    url: url_PostDescribeEventCategories_774744,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeEventCategories_774726 = ref object of OpenApiRestCall_772581
proc url_GetDescribeEventCategories_774728(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_GetDescribeEventCategories_774727(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Displays a list of event categories for all event source types, or for a specified source type. For a list of the event categories and source types, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-event-notifications.html">Amazon Redshift Event Notifications</a>.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   SourceType: JString
  ##             : <p>The source type, such as cluster or parameter group, to which the described event categories apply.</p> <p>Valid values: cluster, cluster-snapshot, cluster-parameter-group, and cluster-security-group.</p>
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_774729 = query.getOrDefault("SourceType")
  valid_774729 = validateParameter(valid_774729, JString, required = false,
                                 default = nil)
  if valid_774729 != nil:
    section.add "SourceType", valid_774729
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_774730 = query.getOrDefault("Action")
  valid_774730 = validateParameter(valid_774730, JString, required = true, default = newJString(
      "DescribeEventCategories"))
  if valid_774730 != nil:
    section.add "Action", valid_774730
  var valid_774731 = query.getOrDefault("Version")
  valid_774731 = validateParameter(valid_774731, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_774731 != nil:
    section.add "Version", valid_774731
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_774732 = header.getOrDefault("X-Amz-Date")
  valid_774732 = validateParameter(valid_774732, JString, required = false,
                                 default = nil)
  if valid_774732 != nil:
    section.add "X-Amz-Date", valid_774732
  var valid_774733 = header.getOrDefault("X-Amz-Security-Token")
  valid_774733 = validateParameter(valid_774733, JString, required = false,
                                 default = nil)
  if valid_774733 != nil:
    section.add "X-Amz-Security-Token", valid_774733
  var valid_774734 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_774734 = validateParameter(valid_774734, JString, required = false,
                                 default = nil)
  if valid_774734 != nil:
    section.add "X-Amz-Content-Sha256", valid_774734
  var valid_774735 = header.getOrDefault("X-Amz-Algorithm")
  valid_774735 = validateParameter(valid_774735, JString, required = false,
                                 default = nil)
  if valid_774735 != nil:
    section.add "X-Amz-Algorithm", valid_774735
  var valid_774736 = header.getOrDefault("X-Amz-Signature")
  valid_774736 = validateParameter(valid_774736, JString, required = false,
                                 default = nil)
  if valid_774736 != nil:
    section.add "X-Amz-Signature", valid_774736
  var valid_774737 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_774737 = validateParameter(valid_774737, JString, required = false,
                                 default = nil)
  if valid_774737 != nil:
    section.add "X-Amz-SignedHeaders", valid_774737
  var valid_774738 = header.getOrDefault("X-Amz-Credential")
  valid_774738 = validateParameter(valid_774738, JString, required = false,
                                 default = nil)
  if valid_774738 != nil:
    section.add "X-Amz-Credential", valid_774738
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_774739: Call_GetDescribeEventCategories_774726; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Displays a list of event categories for all event source types, or for a specified source type. For a list of the event categories and source types, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-event-notifications.html">Amazon Redshift Event Notifications</a>.
  ## 
  let valid = call_774739.validator(path, query, header, formData, body)
  let scheme = call_774739.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_774739.url(scheme.get, call_774739.host, call_774739.base,
                         call_774739.route, valid.getOrDefault("path"))
  result = hook(call_774739, url, valid)

proc call*(call_774740: Call_GetDescribeEventCategories_774726;
          SourceType: string = ""; Action: string = "DescribeEventCategories";
          Version: string = "2012-12-01"): Recallable =
  ## getDescribeEventCategories
  ## Displays a list of event categories for all event source types, or for a specified source type. For a list of the event categories and source types, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-event-notifications.html">Amazon Redshift Event Notifications</a>.
  ##   SourceType: string
  ##             : <p>The source type, such as cluster or parameter group, to which the described event categories apply.</p> <p>Valid values: cluster, cluster-snapshot, cluster-parameter-group, and cluster-security-group.</p>
  ##   Action: string (required)
  ##   Version: string (required)
  var query_774741 = newJObject()
  add(query_774741, "SourceType", newJString(SourceType))
  add(query_774741, "Action", newJString(Action))
  add(query_774741, "Version", newJString(Version))
  result = call_774740.call(nil, query_774741, nil, nil, nil)

var getDescribeEventCategories* = Call_GetDescribeEventCategories_774726(
    name: "getDescribeEventCategories", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeEventCategories",
    validator: validate_GetDescribeEventCategories_774727, base: "/",
    url: url_GetDescribeEventCategories_774728,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeEventSubscriptions_774779 = ref object of OpenApiRestCall_772581
proc url_PostDescribeEventSubscriptions_774781(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_PostDescribeEventSubscriptions_774780(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Lists descriptions of all the Amazon Redshift event notification subscriptions for a customer account. If you specify a subscription name, lists the description for that subscription.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all event notification subscriptions that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all subscriptions that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, subscriptions are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_774782 = query.getOrDefault("Action")
  valid_774782 = validateParameter(valid_774782, JString, required = true, default = newJString(
      "DescribeEventSubscriptions"))
  if valid_774782 != nil:
    section.add "Action", valid_774782
  var valid_774783 = query.getOrDefault("Version")
  valid_774783 = validateParameter(valid_774783, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_774783 != nil:
    section.add "Version", valid_774783
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_774784 = header.getOrDefault("X-Amz-Date")
  valid_774784 = validateParameter(valid_774784, JString, required = false,
                                 default = nil)
  if valid_774784 != nil:
    section.add "X-Amz-Date", valid_774784
  var valid_774785 = header.getOrDefault("X-Amz-Security-Token")
  valid_774785 = validateParameter(valid_774785, JString, required = false,
                                 default = nil)
  if valid_774785 != nil:
    section.add "X-Amz-Security-Token", valid_774785
  var valid_774786 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_774786 = validateParameter(valid_774786, JString, required = false,
                                 default = nil)
  if valid_774786 != nil:
    section.add "X-Amz-Content-Sha256", valid_774786
  var valid_774787 = header.getOrDefault("X-Amz-Algorithm")
  valid_774787 = validateParameter(valid_774787, JString, required = false,
                                 default = nil)
  if valid_774787 != nil:
    section.add "X-Amz-Algorithm", valid_774787
  var valid_774788 = header.getOrDefault("X-Amz-Signature")
  valid_774788 = validateParameter(valid_774788, JString, required = false,
                                 default = nil)
  if valid_774788 != nil:
    section.add "X-Amz-Signature", valid_774788
  var valid_774789 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_774789 = validateParameter(valid_774789, JString, required = false,
                                 default = nil)
  if valid_774789 != nil:
    section.add "X-Amz-SignedHeaders", valid_774789
  var valid_774790 = header.getOrDefault("X-Amz-Credential")
  valid_774790 = validateParameter(valid_774790, JString, required = false,
                                 default = nil)
  if valid_774790 != nil:
    section.add "X-Amz-Credential", valid_774790
  result.add "header", section
  ## parameters in `formData` object:
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a DescribeEventSubscriptions request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   SubscriptionName: JString
  ##                   : The name of the Amazon Redshift event notification subscription to be described.
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching event notification subscriptions that are associated with the specified key or keys. For example, suppose that you have subscriptions that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the subscriptions that have either or both of these tag keys associated with them.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching event notification subscriptions that are associated with the specified tag value or values. For example, suppose that you have subscriptions that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the subscriptions that have either or both of these tag values associated with them.
  section = newJObject()
  var valid_774791 = formData.getOrDefault("Marker")
  valid_774791 = validateParameter(valid_774791, JString, required = false,
                                 default = nil)
  if valid_774791 != nil:
    section.add "Marker", valid_774791
  var valid_774792 = formData.getOrDefault("SubscriptionName")
  valid_774792 = validateParameter(valid_774792, JString, required = false,
                                 default = nil)
  if valid_774792 != nil:
    section.add "SubscriptionName", valid_774792
  var valid_774793 = formData.getOrDefault("TagKeys")
  valid_774793 = validateParameter(valid_774793, JArray, required = false,
                                 default = nil)
  if valid_774793 != nil:
    section.add "TagKeys", valid_774793
  var valid_774794 = formData.getOrDefault("MaxRecords")
  valid_774794 = validateParameter(valid_774794, JInt, required = false, default = nil)
  if valid_774794 != nil:
    section.add "MaxRecords", valid_774794
  var valid_774795 = formData.getOrDefault("TagValues")
  valid_774795 = validateParameter(valid_774795, JArray, required = false,
                                 default = nil)
  if valid_774795 != nil:
    section.add "TagValues", valid_774795
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_774796: Call_PostDescribeEventSubscriptions_774779; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Lists descriptions of all the Amazon Redshift event notification subscriptions for a customer account. If you specify a subscription name, lists the description for that subscription.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all event notification subscriptions that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all subscriptions that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, subscriptions are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_774796.validator(path, query, header, formData, body)
  let scheme = call_774796.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_774796.url(scheme.get, call_774796.host, call_774796.base,
                         call_774796.route, valid.getOrDefault("path"))
  result = hook(call_774796, url, valid)

proc call*(call_774797: Call_PostDescribeEventSubscriptions_774779;
          Marker: string = ""; SubscriptionName: string = "";
          Action: string = "DescribeEventSubscriptions"; TagKeys: JsonNode = nil;
          MaxRecords: int = 0; TagValues: JsonNode = nil; Version: string = "2012-12-01"): Recallable =
  ## postDescribeEventSubscriptions
  ## <p>Lists descriptions of all the Amazon Redshift event notification subscriptions for a customer account. If you specify a subscription name, lists the description for that subscription.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all event notification subscriptions that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all subscriptions that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, subscriptions are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a DescribeEventSubscriptions request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   SubscriptionName: string
  ##                   : The name of the Amazon Redshift event notification subscription to be described.
  ##   Action: string (required)
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching event notification subscriptions that are associated with the specified key or keys. For example, suppose that you have subscriptions that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the subscriptions that have either or both of these tag keys associated with them.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching event notification subscriptions that are associated with the specified tag value or values. For example, suppose that you have subscriptions that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the subscriptions that have either or both of these tag values associated with them.
  ##   Version: string (required)
  var query_774798 = newJObject()
  var formData_774799 = newJObject()
  add(formData_774799, "Marker", newJString(Marker))
  add(formData_774799, "SubscriptionName", newJString(SubscriptionName))
  add(query_774798, "Action", newJString(Action))
  if TagKeys != nil:
    formData_774799.add "TagKeys", TagKeys
  add(formData_774799, "MaxRecords", newJInt(MaxRecords))
  if TagValues != nil:
    formData_774799.add "TagValues", TagValues
  add(query_774798, "Version", newJString(Version))
  result = call_774797.call(nil, query_774798, nil, formData_774799, nil)

var postDescribeEventSubscriptions* = Call_PostDescribeEventSubscriptions_774779(
    name: "postDescribeEventSubscriptions", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeEventSubscriptions",
    validator: validate_PostDescribeEventSubscriptions_774780, base: "/",
    url: url_PostDescribeEventSubscriptions_774781,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeEventSubscriptions_774759 = ref object of OpenApiRestCall_772581
proc url_GetDescribeEventSubscriptions_774761(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_GetDescribeEventSubscriptions_774760(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Lists descriptions of all the Amazon Redshift event notification subscriptions for a customer account. If you specify a subscription name, lists the description for that subscription.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all event notification subscriptions that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all subscriptions that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, subscriptions are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching event notification subscriptions that are associated with the specified tag value or values. For example, suppose that you have subscriptions that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the subscriptions that have either or both of these tag values associated with them.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Action: JString (required)
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a DescribeEventSubscriptions request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   SubscriptionName: JString
  ##                   : The name of the Amazon Redshift event notification subscription to be described.
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching event notification subscriptions that are associated with the specified key or keys. For example, suppose that you have subscriptions that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the subscriptions that have either or both of these tag keys associated with them.
  ##   Version: JString (required)
  section = newJObject()
  var valid_774762 = query.getOrDefault("TagValues")
  valid_774762 = validateParameter(valid_774762, JArray, required = false,
                                 default = nil)
  if valid_774762 != nil:
    section.add "TagValues", valid_774762
  var valid_774763 = query.getOrDefault("MaxRecords")
  valid_774763 = validateParameter(valid_774763, JInt, required = false, default = nil)
  if valid_774763 != nil:
    section.add "MaxRecords", valid_774763
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_774764 = query.getOrDefault("Action")
  valid_774764 = validateParameter(valid_774764, JString, required = true, default = newJString(
      "DescribeEventSubscriptions"))
  if valid_774764 != nil:
    section.add "Action", valid_774764
  var valid_774765 = query.getOrDefault("Marker")
  valid_774765 = validateParameter(valid_774765, JString, required = false,
                                 default = nil)
  if valid_774765 != nil:
    section.add "Marker", valid_774765
  var valid_774766 = query.getOrDefault("SubscriptionName")
  valid_774766 = validateParameter(valid_774766, JString, required = false,
                                 default = nil)
  if valid_774766 != nil:
    section.add "SubscriptionName", valid_774766
  var valid_774767 = query.getOrDefault("TagKeys")
  valid_774767 = validateParameter(valid_774767, JArray, required = false,
                                 default = nil)
  if valid_774767 != nil:
    section.add "TagKeys", valid_774767
  var valid_774768 = query.getOrDefault("Version")
  valid_774768 = validateParameter(valid_774768, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_774768 != nil:
    section.add "Version", valid_774768
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_774769 = header.getOrDefault("X-Amz-Date")
  valid_774769 = validateParameter(valid_774769, JString, required = false,
                                 default = nil)
  if valid_774769 != nil:
    section.add "X-Amz-Date", valid_774769
  var valid_774770 = header.getOrDefault("X-Amz-Security-Token")
  valid_774770 = validateParameter(valid_774770, JString, required = false,
                                 default = nil)
  if valid_774770 != nil:
    section.add "X-Amz-Security-Token", valid_774770
  var valid_774771 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_774771 = validateParameter(valid_774771, JString, required = false,
                                 default = nil)
  if valid_774771 != nil:
    section.add "X-Amz-Content-Sha256", valid_774771
  var valid_774772 = header.getOrDefault("X-Amz-Algorithm")
  valid_774772 = validateParameter(valid_774772, JString, required = false,
                                 default = nil)
  if valid_774772 != nil:
    section.add "X-Amz-Algorithm", valid_774772
  var valid_774773 = header.getOrDefault("X-Amz-Signature")
  valid_774773 = validateParameter(valid_774773, JString, required = false,
                                 default = nil)
  if valid_774773 != nil:
    section.add "X-Amz-Signature", valid_774773
  var valid_774774 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_774774 = validateParameter(valid_774774, JString, required = false,
                                 default = nil)
  if valid_774774 != nil:
    section.add "X-Amz-SignedHeaders", valid_774774
  var valid_774775 = header.getOrDefault("X-Amz-Credential")
  valid_774775 = validateParameter(valid_774775, JString, required = false,
                                 default = nil)
  if valid_774775 != nil:
    section.add "X-Amz-Credential", valid_774775
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_774776: Call_GetDescribeEventSubscriptions_774759; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Lists descriptions of all the Amazon Redshift event notification subscriptions for a customer account. If you specify a subscription name, lists the description for that subscription.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all event notification subscriptions that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all subscriptions that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, subscriptions are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_774776.validator(path, query, header, formData, body)
  let scheme = call_774776.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_774776.url(scheme.get, call_774776.host, call_774776.base,
                         call_774776.route, valid.getOrDefault("path"))
  result = hook(call_774776, url, valid)

proc call*(call_774777: Call_GetDescribeEventSubscriptions_774759;
          TagValues: JsonNode = nil; MaxRecords: int = 0;
          Action: string = "DescribeEventSubscriptions"; Marker: string = "";
          SubscriptionName: string = ""; TagKeys: JsonNode = nil;
          Version: string = "2012-12-01"): Recallable =
  ## getDescribeEventSubscriptions
  ## <p>Lists descriptions of all the Amazon Redshift event notification subscriptions for a customer account. If you specify a subscription name, lists the description for that subscription.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all event notification subscriptions that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all subscriptions that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, subscriptions are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching event notification subscriptions that are associated with the specified tag value or values. For example, suppose that you have subscriptions that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the subscriptions that have either or both of these tag values associated with them.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Action: string (required)
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a DescribeEventSubscriptions request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   SubscriptionName: string
  ##                   : The name of the Amazon Redshift event notification subscription to be described.
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching event notification subscriptions that are associated with the specified key or keys. For example, suppose that you have subscriptions that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the subscriptions that have either or both of these tag keys associated with them.
  ##   Version: string (required)
  var query_774778 = newJObject()
  if TagValues != nil:
    query_774778.add "TagValues", TagValues
  add(query_774778, "MaxRecords", newJInt(MaxRecords))
  add(query_774778, "Action", newJString(Action))
  add(query_774778, "Marker", newJString(Marker))
  add(query_774778, "SubscriptionName", newJString(SubscriptionName))
  if TagKeys != nil:
    query_774778.add "TagKeys", TagKeys
  add(query_774778, "Version", newJString(Version))
  result = call_774777.call(nil, query_774778, nil, nil, nil)

var getDescribeEventSubscriptions* = Call_GetDescribeEventSubscriptions_774759(
    name: "getDescribeEventSubscriptions", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeEventSubscriptions",
    validator: validate_GetDescribeEventSubscriptions_774760, base: "/",
    url: url_GetDescribeEventSubscriptions_774761,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeEvents_774822 = ref object of OpenApiRestCall_772581
proc url_PostDescribeEvents_774824(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_PostDescribeEvents_774823(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Returns events related to clusters, security groups, snapshots, and parameter groups for the past 14 days. Events specific to a particular cluster, security group, snapshot or parameter group can be obtained by providing the name as a parameter. By default, the past hour of events are returned.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_774825 = query.getOrDefault("Action")
  valid_774825 = validateParameter(valid_774825, JString, required = true,
                                 default = newJString("DescribeEvents"))
  if valid_774825 != nil:
    section.add "Action", valid_774825
  var valid_774826 = query.getOrDefault("Version")
  valid_774826 = validateParameter(valid_774826, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_774826 != nil:
    section.add "Version", valid_774826
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_774827 = header.getOrDefault("X-Amz-Date")
  valid_774827 = validateParameter(valid_774827, JString, required = false,
                                 default = nil)
  if valid_774827 != nil:
    section.add "X-Amz-Date", valid_774827
  var valid_774828 = header.getOrDefault("X-Amz-Security-Token")
  valid_774828 = validateParameter(valid_774828, JString, required = false,
                                 default = nil)
  if valid_774828 != nil:
    section.add "X-Amz-Security-Token", valid_774828
  var valid_774829 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_774829 = validateParameter(valid_774829, JString, required = false,
                                 default = nil)
  if valid_774829 != nil:
    section.add "X-Amz-Content-Sha256", valid_774829
  var valid_774830 = header.getOrDefault("X-Amz-Algorithm")
  valid_774830 = validateParameter(valid_774830, JString, required = false,
                                 default = nil)
  if valid_774830 != nil:
    section.add "X-Amz-Algorithm", valid_774830
  var valid_774831 = header.getOrDefault("X-Amz-Signature")
  valid_774831 = validateParameter(valid_774831, JString, required = false,
                                 default = nil)
  if valid_774831 != nil:
    section.add "X-Amz-Signature", valid_774831
  var valid_774832 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_774832 = validateParameter(valid_774832, JString, required = false,
                                 default = nil)
  if valid_774832 != nil:
    section.add "X-Amz-SignedHeaders", valid_774832
  var valid_774833 = header.getOrDefault("X-Amz-Credential")
  valid_774833 = validateParameter(valid_774833, JString, required = false,
                                 default = nil)
  if valid_774833 != nil:
    section.add "X-Amz-Credential", valid_774833
  result.add "header", section
  ## parameters in `formData` object:
  ##   SourceIdentifier: JString
  ##                   : <p>The identifier of the event source for which events will be returned. If this parameter is not specified, then all sources are included in the response.</p> <p>Constraints:</p> <p>If <i>SourceIdentifier</i> is supplied, <i>SourceType</i> must also be provided.</p> <ul> <li> <p>Specify a cluster identifier when <i>SourceType</i> is <code>cluster</code>.</p> </li> <li> <p>Specify a cluster security group name when <i>SourceType</i> is <code>cluster-security-group</code>.</p> </li> <li> <p>Specify a cluster parameter group name when <i>SourceType</i> is <code>cluster-parameter-group</code>.</p> </li> <li> <p>Specify a cluster snapshot identifier when <i>SourceType</i> is <code>cluster-snapshot</code>.</p> </li> </ul>
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeEvents</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   StartTime: JString
  ##            : <p>The beginning of the time interval to retrieve events for, specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2009-07-08T18:00Z</code> </p>
  ##   Duration: JInt
  ##           : <p>The number of minutes prior to the time of the request for which to retrieve events. For example, if the request is sent at 18:00 and you specify a duration of 60, then only events which have occurred after 17:00 will be returned.</p> <p>Default: <code>60</code> </p>
  ##   EndTime: JString
  ##          : <p>The end of the time interval for which to retrieve events, specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2009-07-08T18:00Z</code> </p>
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   SourceType: JString
  ##             : <p>The event source to retrieve events for. If no value is specified, all events are returned.</p> <p>Constraints:</p> <p>If <i>SourceType</i> is supplied, <i>SourceIdentifier</i> must also be provided.</p> <ul> <li> <p>Specify <code>cluster</code> when <i>SourceIdentifier</i> is a cluster identifier.</p> </li> <li> <p>Specify <code>cluster-security-group</code> when <i>SourceIdentifier</i> is a cluster security group name.</p> </li> <li> <p>Specify <code>cluster-parameter-group</code> when <i>SourceIdentifier</i> is a cluster parameter group name.</p> </li> <li> <p>Specify <code>cluster-snapshot</code> when <i>SourceIdentifier</i> is a cluster snapshot identifier.</p> </li> </ul>
  section = newJObject()
  var valid_774834 = formData.getOrDefault("SourceIdentifier")
  valid_774834 = validateParameter(valid_774834, JString, required = false,
                                 default = nil)
  if valid_774834 != nil:
    section.add "SourceIdentifier", valid_774834
  var valid_774835 = formData.getOrDefault("Marker")
  valid_774835 = validateParameter(valid_774835, JString, required = false,
                                 default = nil)
  if valid_774835 != nil:
    section.add "Marker", valid_774835
  var valid_774836 = formData.getOrDefault("StartTime")
  valid_774836 = validateParameter(valid_774836, JString, required = false,
                                 default = nil)
  if valid_774836 != nil:
    section.add "StartTime", valid_774836
  var valid_774837 = formData.getOrDefault("Duration")
  valid_774837 = validateParameter(valid_774837, JInt, required = false, default = nil)
  if valid_774837 != nil:
    section.add "Duration", valid_774837
  var valid_774838 = formData.getOrDefault("EndTime")
  valid_774838 = validateParameter(valid_774838, JString, required = false,
                                 default = nil)
  if valid_774838 != nil:
    section.add "EndTime", valid_774838
  var valid_774839 = formData.getOrDefault("MaxRecords")
  valid_774839 = validateParameter(valid_774839, JInt, required = false, default = nil)
  if valid_774839 != nil:
    section.add "MaxRecords", valid_774839
  var valid_774840 = formData.getOrDefault("SourceType")
  valid_774840 = validateParameter(valid_774840, JString, required = false,
                                 default = newJString("cluster"))
  if valid_774840 != nil:
    section.add "SourceType", valid_774840
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_774841: Call_PostDescribeEvents_774822; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns events related to clusters, security groups, snapshots, and parameter groups for the past 14 days. Events specific to a particular cluster, security group, snapshot or parameter group can be obtained by providing the name as a parameter. By default, the past hour of events are returned.
  ## 
  let valid = call_774841.validator(path, query, header, formData, body)
  let scheme = call_774841.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_774841.url(scheme.get, call_774841.host, call_774841.base,
                         call_774841.route, valid.getOrDefault("path"))
  result = hook(call_774841, url, valid)

proc call*(call_774842: Call_PostDescribeEvents_774822;
          SourceIdentifier: string = ""; Marker: string = ""; StartTime: string = "";
          Action: string = "DescribeEvents"; Duration: int = 0; EndTime: string = "";
          MaxRecords: int = 0; Version: string = "2012-12-01";
          SourceType: string = "cluster"): Recallable =
  ## postDescribeEvents
  ## Returns events related to clusters, security groups, snapshots, and parameter groups for the past 14 days. Events specific to a particular cluster, security group, snapshot or parameter group can be obtained by providing the name as a parameter. By default, the past hour of events are returned.
  ##   SourceIdentifier: string
  ##                   : <p>The identifier of the event source for which events will be returned. If this parameter is not specified, then all sources are included in the response.</p> <p>Constraints:</p> <p>If <i>SourceIdentifier</i> is supplied, <i>SourceType</i> must also be provided.</p> <ul> <li> <p>Specify a cluster identifier when <i>SourceType</i> is <code>cluster</code>.</p> </li> <li> <p>Specify a cluster security group name when <i>SourceType</i> is <code>cluster-security-group</code>.</p> </li> <li> <p>Specify a cluster parameter group name when <i>SourceType</i> is <code>cluster-parameter-group</code>.</p> </li> <li> <p>Specify a cluster snapshot identifier when <i>SourceType</i> is <code>cluster-snapshot</code>.</p> </li> </ul>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeEvents</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   StartTime: string
  ##            : <p>The beginning of the time interval to retrieve events for, specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2009-07-08T18:00Z</code> </p>
  ##   Action: string (required)
  ##   Duration: int
  ##           : <p>The number of minutes prior to the time of the request for which to retrieve events. For example, if the request is sent at 18:00 and you specify a duration of 60, then only events which have occurred after 17:00 will be returned.</p> <p>Default: <code>60</code> </p>
  ##   EndTime: string
  ##          : <p>The end of the time interval for which to retrieve events, specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2009-07-08T18:00Z</code> </p>
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Version: string (required)
  ##   SourceType: string
  ##             : <p>The event source to retrieve events for. If no value is specified, all events are returned.</p> <p>Constraints:</p> <p>If <i>SourceType</i> is supplied, <i>SourceIdentifier</i> must also be provided.</p> <ul> <li> <p>Specify <code>cluster</code> when <i>SourceIdentifier</i> is a cluster identifier.</p> </li> <li> <p>Specify <code>cluster-security-group</code> when <i>SourceIdentifier</i> is a cluster security group name.</p> </li> <li> <p>Specify <code>cluster-parameter-group</code> when <i>SourceIdentifier</i> is a cluster parameter group name.</p> </li> <li> <p>Specify <code>cluster-snapshot</code> when <i>SourceIdentifier</i> is a cluster snapshot identifier.</p> </li> </ul>
  var query_774843 = newJObject()
  var formData_774844 = newJObject()
  add(formData_774844, "SourceIdentifier", newJString(SourceIdentifier))
  add(formData_774844, "Marker", newJString(Marker))
  add(formData_774844, "StartTime", newJString(StartTime))
  add(query_774843, "Action", newJString(Action))
  add(formData_774844, "Duration", newJInt(Duration))
  add(formData_774844, "EndTime", newJString(EndTime))
  add(formData_774844, "MaxRecords", newJInt(MaxRecords))
  add(query_774843, "Version", newJString(Version))
  add(formData_774844, "SourceType", newJString(SourceType))
  result = call_774842.call(nil, query_774843, nil, formData_774844, nil)

var postDescribeEvents* = Call_PostDescribeEvents_774822(
    name: "postDescribeEvents", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeEvents",
    validator: validate_PostDescribeEvents_774823, base: "/",
    url: url_PostDescribeEvents_774824, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeEvents_774800 = ref object of OpenApiRestCall_772581
proc url_GetDescribeEvents_774802(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_GetDescribeEvents_774801(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## Returns events related to clusters, security groups, snapshots, and parameter groups for the past 14 days. Events specific to a particular cluster, security group, snapshot or parameter group can be obtained by providing the name as a parameter. By default, the past hour of events are returned.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   SourceType: JString
  ##             : <p>The event source to retrieve events for. If no value is specified, all events are returned.</p> <p>Constraints:</p> <p>If <i>SourceType</i> is supplied, <i>SourceIdentifier</i> must also be provided.</p> <ul> <li> <p>Specify <code>cluster</code> when <i>SourceIdentifier</i> is a cluster identifier.</p> </li> <li> <p>Specify <code>cluster-security-group</code> when <i>SourceIdentifier</i> is a cluster security group name.</p> </li> <li> <p>Specify <code>cluster-parameter-group</code> when <i>SourceIdentifier</i> is a cluster parameter group name.</p> </li> <li> <p>Specify <code>cluster-snapshot</code> when <i>SourceIdentifier</i> is a cluster snapshot identifier.</p> </li> </ul>
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   StartTime: JString
  ##            : <p>The beginning of the time interval to retrieve events for, specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2009-07-08T18:00Z</code> </p>
  ##   Action: JString (required)
  ##   SourceIdentifier: JString
  ##                   : <p>The identifier of the event source for which events will be returned. If this parameter is not specified, then all sources are included in the response.</p> <p>Constraints:</p> <p>If <i>SourceIdentifier</i> is supplied, <i>SourceType</i> must also be provided.</p> <ul> <li> <p>Specify a cluster identifier when <i>SourceType</i> is <code>cluster</code>.</p> </li> <li> <p>Specify a cluster security group name when <i>SourceType</i> is <code>cluster-security-group</code>.</p> </li> <li> <p>Specify a cluster parameter group name when <i>SourceType</i> is <code>cluster-parameter-group</code>.</p> </li> <li> <p>Specify a cluster snapshot identifier when <i>SourceType</i> is <code>cluster-snapshot</code>.</p> </li> </ul>
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeEvents</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Duration: JInt
  ##           : <p>The number of minutes prior to the time of the request for which to retrieve events. For example, if the request is sent at 18:00 and you specify a duration of 60, then only events which have occurred after 17:00 will be returned.</p> <p>Default: <code>60</code> </p>
  ##   EndTime: JString
  ##          : <p>The end of the time interval for which to retrieve events, specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2009-07-08T18:00Z</code> </p>
  ##   Version: JString (required)
  section = newJObject()
  var valid_774803 = query.getOrDefault("SourceType")
  valid_774803 = validateParameter(valid_774803, JString, required = false,
                                 default = newJString("cluster"))
  if valid_774803 != nil:
    section.add "SourceType", valid_774803
  var valid_774804 = query.getOrDefault("MaxRecords")
  valid_774804 = validateParameter(valid_774804, JInt, required = false, default = nil)
  if valid_774804 != nil:
    section.add "MaxRecords", valid_774804
  var valid_774805 = query.getOrDefault("StartTime")
  valid_774805 = validateParameter(valid_774805, JString, required = false,
                                 default = nil)
  if valid_774805 != nil:
    section.add "StartTime", valid_774805
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_774806 = query.getOrDefault("Action")
  valid_774806 = validateParameter(valid_774806, JString, required = true,
                                 default = newJString("DescribeEvents"))
  if valid_774806 != nil:
    section.add "Action", valid_774806
  var valid_774807 = query.getOrDefault("SourceIdentifier")
  valid_774807 = validateParameter(valid_774807, JString, required = false,
                                 default = nil)
  if valid_774807 != nil:
    section.add "SourceIdentifier", valid_774807
  var valid_774808 = query.getOrDefault("Marker")
  valid_774808 = validateParameter(valid_774808, JString, required = false,
                                 default = nil)
  if valid_774808 != nil:
    section.add "Marker", valid_774808
  var valid_774809 = query.getOrDefault("Duration")
  valid_774809 = validateParameter(valid_774809, JInt, required = false, default = nil)
  if valid_774809 != nil:
    section.add "Duration", valid_774809
  var valid_774810 = query.getOrDefault("EndTime")
  valid_774810 = validateParameter(valid_774810, JString, required = false,
                                 default = nil)
  if valid_774810 != nil:
    section.add "EndTime", valid_774810
  var valid_774811 = query.getOrDefault("Version")
  valid_774811 = validateParameter(valid_774811, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_774811 != nil:
    section.add "Version", valid_774811
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_774812 = header.getOrDefault("X-Amz-Date")
  valid_774812 = validateParameter(valid_774812, JString, required = false,
                                 default = nil)
  if valid_774812 != nil:
    section.add "X-Amz-Date", valid_774812
  var valid_774813 = header.getOrDefault("X-Amz-Security-Token")
  valid_774813 = validateParameter(valid_774813, JString, required = false,
                                 default = nil)
  if valid_774813 != nil:
    section.add "X-Amz-Security-Token", valid_774813
  var valid_774814 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_774814 = validateParameter(valid_774814, JString, required = false,
                                 default = nil)
  if valid_774814 != nil:
    section.add "X-Amz-Content-Sha256", valid_774814
  var valid_774815 = header.getOrDefault("X-Amz-Algorithm")
  valid_774815 = validateParameter(valid_774815, JString, required = false,
                                 default = nil)
  if valid_774815 != nil:
    section.add "X-Amz-Algorithm", valid_774815
  var valid_774816 = header.getOrDefault("X-Amz-Signature")
  valid_774816 = validateParameter(valid_774816, JString, required = false,
                                 default = nil)
  if valid_774816 != nil:
    section.add "X-Amz-Signature", valid_774816
  var valid_774817 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_774817 = validateParameter(valid_774817, JString, required = false,
                                 default = nil)
  if valid_774817 != nil:
    section.add "X-Amz-SignedHeaders", valid_774817
  var valid_774818 = header.getOrDefault("X-Amz-Credential")
  valid_774818 = validateParameter(valid_774818, JString, required = false,
                                 default = nil)
  if valid_774818 != nil:
    section.add "X-Amz-Credential", valid_774818
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_774819: Call_GetDescribeEvents_774800; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns events related to clusters, security groups, snapshots, and parameter groups for the past 14 days. Events specific to a particular cluster, security group, snapshot or parameter group can be obtained by providing the name as a parameter. By default, the past hour of events are returned.
  ## 
  let valid = call_774819.validator(path, query, header, formData, body)
  let scheme = call_774819.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_774819.url(scheme.get, call_774819.host, call_774819.base,
                         call_774819.route, valid.getOrDefault("path"))
  result = hook(call_774819, url, valid)

proc call*(call_774820: Call_GetDescribeEvents_774800;
          SourceType: string = "cluster"; MaxRecords: int = 0; StartTime: string = "";
          Action: string = "DescribeEvents"; SourceIdentifier: string = "";
          Marker: string = ""; Duration: int = 0; EndTime: string = "";
          Version: string = "2012-12-01"): Recallable =
  ## getDescribeEvents
  ## Returns events related to clusters, security groups, snapshots, and parameter groups for the past 14 days. Events specific to a particular cluster, security group, snapshot or parameter group can be obtained by providing the name as a parameter. By default, the past hour of events are returned.
  ##   SourceType: string
  ##             : <p>The event source to retrieve events for. If no value is specified, all events are returned.</p> <p>Constraints:</p> <p>If <i>SourceType</i> is supplied, <i>SourceIdentifier</i> must also be provided.</p> <ul> <li> <p>Specify <code>cluster</code> when <i>SourceIdentifier</i> is a cluster identifier.</p> </li> <li> <p>Specify <code>cluster-security-group</code> when <i>SourceIdentifier</i> is a cluster security group name.</p> </li> <li> <p>Specify <code>cluster-parameter-group</code> when <i>SourceIdentifier</i> is a cluster parameter group name.</p> </li> <li> <p>Specify <code>cluster-snapshot</code> when <i>SourceIdentifier</i> is a cluster snapshot identifier.</p> </li> </ul>
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   StartTime: string
  ##            : <p>The beginning of the time interval to retrieve events for, specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2009-07-08T18:00Z</code> </p>
  ##   Action: string (required)
  ##   SourceIdentifier: string
  ##                   : <p>The identifier of the event source for which events will be returned. If this parameter is not specified, then all sources are included in the response.</p> <p>Constraints:</p> <p>If <i>SourceIdentifier</i> is supplied, <i>SourceType</i> must also be provided.</p> <ul> <li> <p>Specify a cluster identifier when <i>SourceType</i> is <code>cluster</code>.</p> </li> <li> <p>Specify a cluster security group name when <i>SourceType</i> is <code>cluster-security-group</code>.</p> </li> <li> <p>Specify a cluster parameter group name when <i>SourceType</i> is <code>cluster-parameter-group</code>.</p> </li> <li> <p>Specify a cluster snapshot identifier when <i>SourceType</i> is <code>cluster-snapshot</code>.</p> </li> </ul>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeEvents</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Duration: int
  ##           : <p>The number of minutes prior to the time of the request for which to retrieve events. For example, if the request is sent at 18:00 and you specify a duration of 60, then only events which have occurred after 17:00 will be returned.</p> <p>Default: <code>60</code> </p>
  ##   EndTime: string
  ##          : <p>The end of the time interval for which to retrieve events, specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2009-07-08T18:00Z</code> </p>
  ##   Version: string (required)
  var query_774821 = newJObject()
  add(query_774821, "SourceType", newJString(SourceType))
  add(query_774821, "MaxRecords", newJInt(MaxRecords))
  add(query_774821, "StartTime", newJString(StartTime))
  add(query_774821, "Action", newJString(Action))
  add(query_774821, "SourceIdentifier", newJString(SourceIdentifier))
  add(query_774821, "Marker", newJString(Marker))
  add(query_774821, "Duration", newJInt(Duration))
  add(query_774821, "EndTime", newJString(EndTime))
  add(query_774821, "Version", newJString(Version))
  result = call_774820.call(nil, query_774821, nil, nil, nil)

var getDescribeEvents* = Call_GetDescribeEvents_774800(name: "getDescribeEvents",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=DescribeEvents", validator: validate_GetDescribeEvents_774801,
    base: "/", url: url_GetDescribeEvents_774802,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeHsmClientCertificates_774865 = ref object of OpenApiRestCall_772581
proc url_PostDescribeHsmClientCertificates_774867(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_PostDescribeHsmClientCertificates_774866(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns information about the specified HSM client certificate. If no certificate ID is specified, returns information about all the HSM certificates owned by your AWS customer account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM client certificates that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all HSM client certificates that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, HSM client certificates are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_774868 = query.getOrDefault("Action")
  valid_774868 = validateParameter(valid_774868, JString, required = true, default = newJString(
      "DescribeHsmClientCertificates"))
  if valid_774868 != nil:
    section.add "Action", valid_774868
  var valid_774869 = query.getOrDefault("Version")
  valid_774869 = validateParameter(valid_774869, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_774869 != nil:
    section.add "Version", valid_774869
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_774870 = header.getOrDefault("X-Amz-Date")
  valid_774870 = validateParameter(valid_774870, JString, required = false,
                                 default = nil)
  if valid_774870 != nil:
    section.add "X-Amz-Date", valid_774870
  var valid_774871 = header.getOrDefault("X-Amz-Security-Token")
  valid_774871 = validateParameter(valid_774871, JString, required = false,
                                 default = nil)
  if valid_774871 != nil:
    section.add "X-Amz-Security-Token", valid_774871
  var valid_774872 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_774872 = validateParameter(valid_774872, JString, required = false,
                                 default = nil)
  if valid_774872 != nil:
    section.add "X-Amz-Content-Sha256", valid_774872
  var valid_774873 = header.getOrDefault("X-Amz-Algorithm")
  valid_774873 = validateParameter(valid_774873, JString, required = false,
                                 default = nil)
  if valid_774873 != nil:
    section.add "X-Amz-Algorithm", valid_774873
  var valid_774874 = header.getOrDefault("X-Amz-Signature")
  valid_774874 = validateParameter(valid_774874, JString, required = false,
                                 default = nil)
  if valid_774874 != nil:
    section.add "X-Amz-Signature", valid_774874
  var valid_774875 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_774875 = validateParameter(valid_774875, JString, required = false,
                                 default = nil)
  if valid_774875 != nil:
    section.add "X-Amz-SignedHeaders", valid_774875
  var valid_774876 = header.getOrDefault("X-Amz-Credential")
  valid_774876 = validateParameter(valid_774876, JString, required = false,
                                 default = nil)
  if valid_774876 != nil:
    section.add "X-Amz-Credential", valid_774876
  result.add "header", section
  ## parameters in `formData` object:
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeHsmClientCertificates</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   HsmClientCertificateIdentifier: JString
  ##                                 : The identifier of a specific HSM client certificate for which you want information. If no identifier is specified, information is returned for all HSM client certificates owned by your AWS customer account.
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching HSM client certificates that are associated with the specified key or keys. For example, suppose that you have HSM client certificates that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the HSM client certificates that have either or both of these tag keys associated with them.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching HSM client certificates that are associated with the specified tag value or values. For example, suppose that you have HSM client certificates that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the HSM client certificates that have either or both of these tag values associated with them.
  section = newJObject()
  var valid_774877 = formData.getOrDefault("Marker")
  valid_774877 = validateParameter(valid_774877, JString, required = false,
                                 default = nil)
  if valid_774877 != nil:
    section.add "Marker", valid_774877
  var valid_774878 = formData.getOrDefault("HsmClientCertificateIdentifier")
  valid_774878 = validateParameter(valid_774878, JString, required = false,
                                 default = nil)
  if valid_774878 != nil:
    section.add "HsmClientCertificateIdentifier", valid_774878
  var valid_774879 = formData.getOrDefault("TagKeys")
  valid_774879 = validateParameter(valid_774879, JArray, required = false,
                                 default = nil)
  if valid_774879 != nil:
    section.add "TagKeys", valid_774879
  var valid_774880 = formData.getOrDefault("MaxRecords")
  valid_774880 = validateParameter(valid_774880, JInt, required = false, default = nil)
  if valid_774880 != nil:
    section.add "MaxRecords", valid_774880
  var valid_774881 = formData.getOrDefault("TagValues")
  valid_774881 = validateParameter(valid_774881, JArray, required = false,
                                 default = nil)
  if valid_774881 != nil:
    section.add "TagValues", valid_774881
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_774882: Call_PostDescribeHsmClientCertificates_774865;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Returns information about the specified HSM client certificate. If no certificate ID is specified, returns information about all the HSM certificates owned by your AWS customer account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM client certificates that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all HSM client certificates that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, HSM client certificates are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_774882.validator(path, query, header, formData, body)
  let scheme = call_774882.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_774882.url(scheme.get, call_774882.host, call_774882.base,
                         call_774882.route, valid.getOrDefault("path"))
  result = hook(call_774882, url, valid)

proc call*(call_774883: Call_PostDescribeHsmClientCertificates_774865;
          Marker: string = ""; Action: string = "DescribeHsmClientCertificates";
          HsmClientCertificateIdentifier: string = ""; TagKeys: JsonNode = nil;
          MaxRecords: int = 0; TagValues: JsonNode = nil; Version: string = "2012-12-01"): Recallable =
  ## postDescribeHsmClientCertificates
  ## <p>Returns information about the specified HSM client certificate. If no certificate ID is specified, returns information about all the HSM certificates owned by your AWS customer account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM client certificates that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all HSM client certificates that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, HSM client certificates are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeHsmClientCertificates</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Action: string (required)
  ##   HsmClientCertificateIdentifier: string
  ##                                 : The identifier of a specific HSM client certificate for which you want information. If no identifier is specified, information is returned for all HSM client certificates owned by your AWS customer account.
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching HSM client certificates that are associated with the specified key or keys. For example, suppose that you have HSM client certificates that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the HSM client certificates that have either or both of these tag keys associated with them.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching HSM client certificates that are associated with the specified tag value or values. For example, suppose that you have HSM client certificates that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the HSM client certificates that have either or both of these tag values associated with them.
  ##   Version: string (required)
  var query_774884 = newJObject()
  var formData_774885 = newJObject()
  add(formData_774885, "Marker", newJString(Marker))
  add(query_774884, "Action", newJString(Action))
  add(formData_774885, "HsmClientCertificateIdentifier",
      newJString(HsmClientCertificateIdentifier))
  if TagKeys != nil:
    formData_774885.add "TagKeys", TagKeys
  add(formData_774885, "MaxRecords", newJInt(MaxRecords))
  if TagValues != nil:
    formData_774885.add "TagValues", TagValues
  add(query_774884, "Version", newJString(Version))
  result = call_774883.call(nil, query_774884, nil, formData_774885, nil)

var postDescribeHsmClientCertificates* = Call_PostDescribeHsmClientCertificates_774865(
    name: "postDescribeHsmClientCertificates", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeHsmClientCertificates",
    validator: validate_PostDescribeHsmClientCertificates_774866, base: "/",
    url: url_PostDescribeHsmClientCertificates_774867,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeHsmClientCertificates_774845 = ref object of OpenApiRestCall_772581
proc url_GetDescribeHsmClientCertificates_774847(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_GetDescribeHsmClientCertificates_774846(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns information about the specified HSM client certificate. If no certificate ID is specified, returns information about all the HSM certificates owned by your AWS customer account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM client certificates that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all HSM client certificates that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, HSM client certificates are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching HSM client certificates that are associated with the specified tag value or values. For example, suppose that you have HSM client certificates that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the HSM client certificates that have either or both of these tag values associated with them.
  ##   HsmClientCertificateIdentifier: JString
  ##                                 : The identifier of a specific HSM client certificate for which you want information. If no identifier is specified, information is returned for all HSM client certificates owned by your AWS customer account.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Action: JString (required)
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeHsmClientCertificates</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching HSM client certificates that are associated with the specified key or keys. For example, suppose that you have HSM client certificates that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the HSM client certificates that have either or both of these tag keys associated with them.
  ##   Version: JString (required)
  section = newJObject()
  var valid_774848 = query.getOrDefault("TagValues")
  valid_774848 = validateParameter(valid_774848, JArray, required = false,
                                 default = nil)
  if valid_774848 != nil:
    section.add "TagValues", valid_774848
  var valid_774849 = query.getOrDefault("HsmClientCertificateIdentifier")
  valid_774849 = validateParameter(valid_774849, JString, required = false,
                                 default = nil)
  if valid_774849 != nil:
    section.add "HsmClientCertificateIdentifier", valid_774849
  var valid_774850 = query.getOrDefault("MaxRecords")
  valid_774850 = validateParameter(valid_774850, JInt, required = false, default = nil)
  if valid_774850 != nil:
    section.add "MaxRecords", valid_774850
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_774851 = query.getOrDefault("Action")
  valid_774851 = validateParameter(valid_774851, JString, required = true, default = newJString(
      "DescribeHsmClientCertificates"))
  if valid_774851 != nil:
    section.add "Action", valid_774851
  var valid_774852 = query.getOrDefault("Marker")
  valid_774852 = validateParameter(valid_774852, JString, required = false,
                                 default = nil)
  if valid_774852 != nil:
    section.add "Marker", valid_774852
  var valid_774853 = query.getOrDefault("TagKeys")
  valid_774853 = validateParameter(valid_774853, JArray, required = false,
                                 default = nil)
  if valid_774853 != nil:
    section.add "TagKeys", valid_774853
  var valid_774854 = query.getOrDefault("Version")
  valid_774854 = validateParameter(valid_774854, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_774854 != nil:
    section.add "Version", valid_774854
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_774855 = header.getOrDefault("X-Amz-Date")
  valid_774855 = validateParameter(valid_774855, JString, required = false,
                                 default = nil)
  if valid_774855 != nil:
    section.add "X-Amz-Date", valid_774855
  var valid_774856 = header.getOrDefault("X-Amz-Security-Token")
  valid_774856 = validateParameter(valid_774856, JString, required = false,
                                 default = nil)
  if valid_774856 != nil:
    section.add "X-Amz-Security-Token", valid_774856
  var valid_774857 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_774857 = validateParameter(valid_774857, JString, required = false,
                                 default = nil)
  if valid_774857 != nil:
    section.add "X-Amz-Content-Sha256", valid_774857
  var valid_774858 = header.getOrDefault("X-Amz-Algorithm")
  valid_774858 = validateParameter(valid_774858, JString, required = false,
                                 default = nil)
  if valid_774858 != nil:
    section.add "X-Amz-Algorithm", valid_774858
  var valid_774859 = header.getOrDefault("X-Amz-Signature")
  valid_774859 = validateParameter(valid_774859, JString, required = false,
                                 default = nil)
  if valid_774859 != nil:
    section.add "X-Amz-Signature", valid_774859
  var valid_774860 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_774860 = validateParameter(valid_774860, JString, required = false,
                                 default = nil)
  if valid_774860 != nil:
    section.add "X-Amz-SignedHeaders", valid_774860
  var valid_774861 = header.getOrDefault("X-Amz-Credential")
  valid_774861 = validateParameter(valid_774861, JString, required = false,
                                 default = nil)
  if valid_774861 != nil:
    section.add "X-Amz-Credential", valid_774861
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_774862: Call_GetDescribeHsmClientCertificates_774845;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Returns information about the specified HSM client certificate. If no certificate ID is specified, returns information about all the HSM certificates owned by your AWS customer account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM client certificates that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all HSM client certificates that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, HSM client certificates are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_774862.validator(path, query, header, formData, body)
  let scheme = call_774862.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_774862.url(scheme.get, call_774862.host, call_774862.base,
                         call_774862.route, valid.getOrDefault("path"))
  result = hook(call_774862, url, valid)

proc call*(call_774863: Call_GetDescribeHsmClientCertificates_774845;
          TagValues: JsonNode = nil; HsmClientCertificateIdentifier: string = "";
          MaxRecords: int = 0; Action: string = "DescribeHsmClientCertificates";
          Marker: string = ""; TagKeys: JsonNode = nil; Version: string = "2012-12-01"): Recallable =
  ## getDescribeHsmClientCertificates
  ## <p>Returns information about the specified HSM client certificate. If no certificate ID is specified, returns information about all the HSM certificates owned by your AWS customer account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM client certificates that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all HSM client certificates that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, HSM client certificates are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching HSM client certificates that are associated with the specified tag value or values. For example, suppose that you have HSM client certificates that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the HSM client certificates that have either or both of these tag values associated with them.
  ##   HsmClientCertificateIdentifier: string
  ##                                 : The identifier of a specific HSM client certificate for which you want information. If no identifier is specified, information is returned for all HSM client certificates owned by your AWS customer account.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Action: string (required)
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeHsmClientCertificates</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching HSM client certificates that are associated with the specified key or keys. For example, suppose that you have HSM client certificates that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the HSM client certificates that have either or both of these tag keys associated with them.
  ##   Version: string (required)
  var query_774864 = newJObject()
  if TagValues != nil:
    query_774864.add "TagValues", TagValues
  add(query_774864, "HsmClientCertificateIdentifier",
      newJString(HsmClientCertificateIdentifier))
  add(query_774864, "MaxRecords", newJInt(MaxRecords))
  add(query_774864, "Action", newJString(Action))
  add(query_774864, "Marker", newJString(Marker))
  if TagKeys != nil:
    query_774864.add "TagKeys", TagKeys
  add(query_774864, "Version", newJString(Version))
  result = call_774863.call(nil, query_774864, nil, nil, nil)

var getDescribeHsmClientCertificates* = Call_GetDescribeHsmClientCertificates_774845(
    name: "getDescribeHsmClientCertificates", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeHsmClientCertificates",
    validator: validate_GetDescribeHsmClientCertificates_774846, base: "/",
    url: url_GetDescribeHsmClientCertificates_774847,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeHsmConfigurations_774906 = ref object of OpenApiRestCall_772581
proc url_PostDescribeHsmConfigurations_774908(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_PostDescribeHsmConfigurations_774907(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns information about the specified Amazon Redshift HSM configuration. If no configuration ID is specified, returns information about all the HSM configurations owned by your AWS customer account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM connections that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all HSM connections that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, HSM connections are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_774909 = query.getOrDefault("Action")
  valid_774909 = validateParameter(valid_774909, JString, required = true, default = newJString(
      "DescribeHsmConfigurations"))
  if valid_774909 != nil:
    section.add "Action", valid_774909
  var valid_774910 = query.getOrDefault("Version")
  valid_774910 = validateParameter(valid_774910, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_774910 != nil:
    section.add "Version", valid_774910
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_774911 = header.getOrDefault("X-Amz-Date")
  valid_774911 = validateParameter(valid_774911, JString, required = false,
                                 default = nil)
  if valid_774911 != nil:
    section.add "X-Amz-Date", valid_774911
  var valid_774912 = header.getOrDefault("X-Amz-Security-Token")
  valid_774912 = validateParameter(valid_774912, JString, required = false,
                                 default = nil)
  if valid_774912 != nil:
    section.add "X-Amz-Security-Token", valid_774912
  var valid_774913 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_774913 = validateParameter(valid_774913, JString, required = false,
                                 default = nil)
  if valid_774913 != nil:
    section.add "X-Amz-Content-Sha256", valid_774913
  var valid_774914 = header.getOrDefault("X-Amz-Algorithm")
  valid_774914 = validateParameter(valid_774914, JString, required = false,
                                 default = nil)
  if valid_774914 != nil:
    section.add "X-Amz-Algorithm", valid_774914
  var valid_774915 = header.getOrDefault("X-Amz-Signature")
  valid_774915 = validateParameter(valid_774915, JString, required = false,
                                 default = nil)
  if valid_774915 != nil:
    section.add "X-Amz-Signature", valid_774915
  var valid_774916 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_774916 = validateParameter(valid_774916, JString, required = false,
                                 default = nil)
  if valid_774916 != nil:
    section.add "X-Amz-SignedHeaders", valid_774916
  var valid_774917 = header.getOrDefault("X-Amz-Credential")
  valid_774917 = validateParameter(valid_774917, JString, required = false,
                                 default = nil)
  if valid_774917 != nil:
    section.add "X-Amz-Credential", valid_774917
  result.add "header", section
  ## parameters in `formData` object:
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeHsmConfigurations</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   HsmConfigurationIdentifier: JString
  ##                             : The identifier of a specific Amazon Redshift HSM configuration to be described. If no identifier is specified, information is returned for all HSM configurations owned by your AWS customer account.
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching HSM configurations that are associated with the specified key or keys. For example, suppose that you have HSM configurations that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the HSM configurations that have either or both of these tag keys associated with them.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching HSM configurations that are associated with the specified tag value or values. For example, suppose that you have HSM configurations that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the HSM configurations that have either or both of these tag values associated with them.
  section = newJObject()
  var valid_774918 = formData.getOrDefault("Marker")
  valid_774918 = validateParameter(valid_774918, JString, required = false,
                                 default = nil)
  if valid_774918 != nil:
    section.add "Marker", valid_774918
  var valid_774919 = formData.getOrDefault("HsmConfigurationIdentifier")
  valid_774919 = validateParameter(valid_774919, JString, required = false,
                                 default = nil)
  if valid_774919 != nil:
    section.add "HsmConfigurationIdentifier", valid_774919
  var valid_774920 = formData.getOrDefault("TagKeys")
  valid_774920 = validateParameter(valid_774920, JArray, required = false,
                                 default = nil)
  if valid_774920 != nil:
    section.add "TagKeys", valid_774920
  var valid_774921 = formData.getOrDefault("MaxRecords")
  valid_774921 = validateParameter(valid_774921, JInt, required = false, default = nil)
  if valid_774921 != nil:
    section.add "MaxRecords", valid_774921
  var valid_774922 = formData.getOrDefault("TagValues")
  valid_774922 = validateParameter(valid_774922, JArray, required = false,
                                 default = nil)
  if valid_774922 != nil:
    section.add "TagValues", valid_774922
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_774923: Call_PostDescribeHsmConfigurations_774906; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns information about the specified Amazon Redshift HSM configuration. If no configuration ID is specified, returns information about all the HSM configurations owned by your AWS customer account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM connections that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all HSM connections that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, HSM connections are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_774923.validator(path, query, header, formData, body)
  let scheme = call_774923.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_774923.url(scheme.get, call_774923.host, call_774923.base,
                         call_774923.route, valid.getOrDefault("path"))
  result = hook(call_774923, url, valid)

proc call*(call_774924: Call_PostDescribeHsmConfigurations_774906;
          Marker: string = ""; HsmConfigurationIdentifier: string = "";
          Action: string = "DescribeHsmConfigurations"; TagKeys: JsonNode = nil;
          MaxRecords: int = 0; TagValues: JsonNode = nil; Version: string = "2012-12-01"): Recallable =
  ## postDescribeHsmConfigurations
  ## <p>Returns information about the specified Amazon Redshift HSM configuration. If no configuration ID is specified, returns information about all the HSM configurations owned by your AWS customer account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM connections that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all HSM connections that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, HSM connections are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeHsmConfigurations</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   HsmConfigurationIdentifier: string
  ##                             : The identifier of a specific Amazon Redshift HSM configuration to be described. If no identifier is specified, information is returned for all HSM configurations owned by your AWS customer account.
  ##   Action: string (required)
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching HSM configurations that are associated with the specified key or keys. For example, suppose that you have HSM configurations that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the HSM configurations that have either or both of these tag keys associated with them.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching HSM configurations that are associated with the specified tag value or values. For example, suppose that you have HSM configurations that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the HSM configurations that have either or both of these tag values associated with them.
  ##   Version: string (required)
  var query_774925 = newJObject()
  var formData_774926 = newJObject()
  add(formData_774926, "Marker", newJString(Marker))
  add(formData_774926, "HsmConfigurationIdentifier",
      newJString(HsmConfigurationIdentifier))
  add(query_774925, "Action", newJString(Action))
  if TagKeys != nil:
    formData_774926.add "TagKeys", TagKeys
  add(formData_774926, "MaxRecords", newJInt(MaxRecords))
  if TagValues != nil:
    formData_774926.add "TagValues", TagValues
  add(query_774925, "Version", newJString(Version))
  result = call_774924.call(nil, query_774925, nil, formData_774926, nil)

var postDescribeHsmConfigurations* = Call_PostDescribeHsmConfigurations_774906(
    name: "postDescribeHsmConfigurations", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeHsmConfigurations",
    validator: validate_PostDescribeHsmConfigurations_774907, base: "/",
    url: url_PostDescribeHsmConfigurations_774908,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeHsmConfigurations_774886 = ref object of OpenApiRestCall_772581
proc url_GetDescribeHsmConfigurations_774888(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_GetDescribeHsmConfigurations_774887(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns information about the specified Amazon Redshift HSM configuration. If no configuration ID is specified, returns information about all the HSM configurations owned by your AWS customer account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM connections that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all HSM connections that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, HSM connections are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching HSM configurations that are associated with the specified tag value or values. For example, suppose that you have HSM configurations that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the HSM configurations that have either or both of these tag values associated with them.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   HsmConfigurationIdentifier: JString
  ##                             : The identifier of a specific Amazon Redshift HSM configuration to be described. If no identifier is specified, information is returned for all HSM configurations owned by your AWS customer account.
  ##   Action: JString (required)
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeHsmConfigurations</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching HSM configurations that are associated with the specified key or keys. For example, suppose that you have HSM configurations that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the HSM configurations that have either or both of these tag keys associated with them.
  ##   Version: JString (required)
  section = newJObject()
  var valid_774889 = query.getOrDefault("TagValues")
  valid_774889 = validateParameter(valid_774889, JArray, required = false,
                                 default = nil)
  if valid_774889 != nil:
    section.add "TagValues", valid_774889
  var valid_774890 = query.getOrDefault("MaxRecords")
  valid_774890 = validateParameter(valid_774890, JInt, required = false, default = nil)
  if valid_774890 != nil:
    section.add "MaxRecords", valid_774890
  var valid_774891 = query.getOrDefault("HsmConfigurationIdentifier")
  valid_774891 = validateParameter(valid_774891, JString, required = false,
                                 default = nil)
  if valid_774891 != nil:
    section.add "HsmConfigurationIdentifier", valid_774891
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_774892 = query.getOrDefault("Action")
  valid_774892 = validateParameter(valid_774892, JString, required = true, default = newJString(
      "DescribeHsmConfigurations"))
  if valid_774892 != nil:
    section.add "Action", valid_774892
  var valid_774893 = query.getOrDefault("Marker")
  valid_774893 = validateParameter(valid_774893, JString, required = false,
                                 default = nil)
  if valid_774893 != nil:
    section.add "Marker", valid_774893
  var valid_774894 = query.getOrDefault("TagKeys")
  valid_774894 = validateParameter(valid_774894, JArray, required = false,
                                 default = nil)
  if valid_774894 != nil:
    section.add "TagKeys", valid_774894
  var valid_774895 = query.getOrDefault("Version")
  valid_774895 = validateParameter(valid_774895, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_774895 != nil:
    section.add "Version", valid_774895
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_774896 = header.getOrDefault("X-Amz-Date")
  valid_774896 = validateParameter(valid_774896, JString, required = false,
                                 default = nil)
  if valid_774896 != nil:
    section.add "X-Amz-Date", valid_774896
  var valid_774897 = header.getOrDefault("X-Amz-Security-Token")
  valid_774897 = validateParameter(valid_774897, JString, required = false,
                                 default = nil)
  if valid_774897 != nil:
    section.add "X-Amz-Security-Token", valid_774897
  var valid_774898 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_774898 = validateParameter(valid_774898, JString, required = false,
                                 default = nil)
  if valid_774898 != nil:
    section.add "X-Amz-Content-Sha256", valid_774898
  var valid_774899 = header.getOrDefault("X-Amz-Algorithm")
  valid_774899 = validateParameter(valid_774899, JString, required = false,
                                 default = nil)
  if valid_774899 != nil:
    section.add "X-Amz-Algorithm", valid_774899
  var valid_774900 = header.getOrDefault("X-Amz-Signature")
  valid_774900 = validateParameter(valid_774900, JString, required = false,
                                 default = nil)
  if valid_774900 != nil:
    section.add "X-Amz-Signature", valid_774900
  var valid_774901 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_774901 = validateParameter(valid_774901, JString, required = false,
                                 default = nil)
  if valid_774901 != nil:
    section.add "X-Amz-SignedHeaders", valid_774901
  var valid_774902 = header.getOrDefault("X-Amz-Credential")
  valid_774902 = validateParameter(valid_774902, JString, required = false,
                                 default = nil)
  if valid_774902 != nil:
    section.add "X-Amz-Credential", valid_774902
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_774903: Call_GetDescribeHsmConfigurations_774886; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns information about the specified Amazon Redshift HSM configuration. If no configuration ID is specified, returns information about all the HSM configurations owned by your AWS customer account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM connections that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all HSM connections that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, HSM connections are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_774903.validator(path, query, header, formData, body)
  let scheme = call_774903.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_774903.url(scheme.get, call_774903.host, call_774903.base,
                         call_774903.route, valid.getOrDefault("path"))
  result = hook(call_774903, url, valid)

proc call*(call_774904: Call_GetDescribeHsmConfigurations_774886;
          TagValues: JsonNode = nil; MaxRecords: int = 0;
          HsmConfigurationIdentifier: string = "";
          Action: string = "DescribeHsmConfigurations"; Marker: string = "";
          TagKeys: JsonNode = nil; Version: string = "2012-12-01"): Recallable =
  ## getDescribeHsmConfigurations
  ## <p>Returns information about the specified Amazon Redshift HSM configuration. If no configuration ID is specified, returns information about all the HSM configurations owned by your AWS customer account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM connections that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all HSM connections that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, HSM connections are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching HSM configurations that are associated with the specified tag value or values. For example, suppose that you have HSM configurations that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the HSM configurations that have either or both of these tag values associated with them.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   HsmConfigurationIdentifier: string
  ##                             : The identifier of a specific Amazon Redshift HSM configuration to be described. If no identifier is specified, information is returned for all HSM configurations owned by your AWS customer account.
  ##   Action: string (required)
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeHsmConfigurations</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching HSM configurations that are associated with the specified key or keys. For example, suppose that you have HSM configurations that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the HSM configurations that have either or both of these tag keys associated with them.
  ##   Version: string (required)
  var query_774905 = newJObject()
  if TagValues != nil:
    query_774905.add "TagValues", TagValues
  add(query_774905, "MaxRecords", newJInt(MaxRecords))
  add(query_774905, "HsmConfigurationIdentifier",
      newJString(HsmConfigurationIdentifier))
  add(query_774905, "Action", newJString(Action))
  add(query_774905, "Marker", newJString(Marker))
  if TagKeys != nil:
    query_774905.add "TagKeys", TagKeys
  add(query_774905, "Version", newJString(Version))
  result = call_774904.call(nil, query_774905, nil, nil, nil)

var getDescribeHsmConfigurations* = Call_GetDescribeHsmConfigurations_774886(
    name: "getDescribeHsmConfigurations", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeHsmConfigurations",
    validator: validate_GetDescribeHsmConfigurations_774887, base: "/",
    url: url_GetDescribeHsmConfigurations_774888,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeLoggingStatus_774943 = ref object of OpenApiRestCall_772581
proc url_PostDescribeLoggingStatus_774945(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_PostDescribeLoggingStatus_774944(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Describes whether information, such as queries and connection attempts, is being logged for the specified Amazon Redshift cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_774946 = query.getOrDefault("Action")
  valid_774946 = validateParameter(valid_774946, JString, required = true,
                                 default = newJString("DescribeLoggingStatus"))
  if valid_774946 != nil:
    section.add "Action", valid_774946
  var valid_774947 = query.getOrDefault("Version")
  valid_774947 = validateParameter(valid_774947, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_774947 != nil:
    section.add "Version", valid_774947
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_774948 = header.getOrDefault("X-Amz-Date")
  valid_774948 = validateParameter(valid_774948, JString, required = false,
                                 default = nil)
  if valid_774948 != nil:
    section.add "X-Amz-Date", valid_774948
  var valid_774949 = header.getOrDefault("X-Amz-Security-Token")
  valid_774949 = validateParameter(valid_774949, JString, required = false,
                                 default = nil)
  if valid_774949 != nil:
    section.add "X-Amz-Security-Token", valid_774949
  var valid_774950 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_774950 = validateParameter(valid_774950, JString, required = false,
                                 default = nil)
  if valid_774950 != nil:
    section.add "X-Amz-Content-Sha256", valid_774950
  var valid_774951 = header.getOrDefault("X-Amz-Algorithm")
  valid_774951 = validateParameter(valid_774951, JString, required = false,
                                 default = nil)
  if valid_774951 != nil:
    section.add "X-Amz-Algorithm", valid_774951
  var valid_774952 = header.getOrDefault("X-Amz-Signature")
  valid_774952 = validateParameter(valid_774952, JString, required = false,
                                 default = nil)
  if valid_774952 != nil:
    section.add "X-Amz-Signature", valid_774952
  var valid_774953 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_774953 = validateParameter(valid_774953, JString, required = false,
                                 default = nil)
  if valid_774953 != nil:
    section.add "X-Amz-SignedHeaders", valid_774953
  var valid_774954 = header.getOrDefault("X-Amz-Credential")
  valid_774954 = validateParameter(valid_774954, JString, required = false,
                                 default = nil)
  if valid_774954 != nil:
    section.add "X-Amz-Credential", valid_774954
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The identifier of the cluster from which to get the logging status.</p> <p>Example: <code>examplecluster</code> </p>
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_774955 = formData.getOrDefault("ClusterIdentifier")
  valid_774955 = validateParameter(valid_774955, JString, required = true,
                                 default = nil)
  if valid_774955 != nil:
    section.add "ClusterIdentifier", valid_774955
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_774956: Call_PostDescribeLoggingStatus_774943; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Describes whether information, such as queries and connection attempts, is being logged for the specified Amazon Redshift cluster.
  ## 
  let valid = call_774956.validator(path, query, header, formData, body)
  let scheme = call_774956.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_774956.url(scheme.get, call_774956.host, call_774956.base,
                         call_774956.route, valid.getOrDefault("path"))
  result = hook(call_774956, url, valid)

proc call*(call_774957: Call_PostDescribeLoggingStatus_774943;
          ClusterIdentifier: string; Action: string = "DescribeLoggingStatus";
          Version: string = "2012-12-01"): Recallable =
  ## postDescribeLoggingStatus
  ## Describes whether information, such as queries and connection attempts, is being logged for the specified Amazon Redshift cluster.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The identifier of the cluster from which to get the logging status.</p> <p>Example: <code>examplecluster</code> </p>
  ##   Version: string (required)
  var query_774958 = newJObject()
  var formData_774959 = newJObject()
  add(query_774958, "Action", newJString(Action))
  add(formData_774959, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_774958, "Version", newJString(Version))
  result = call_774957.call(nil, query_774958, nil, formData_774959, nil)

var postDescribeLoggingStatus* = Call_PostDescribeLoggingStatus_774943(
    name: "postDescribeLoggingStatus", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeLoggingStatus",
    validator: validate_PostDescribeLoggingStatus_774944, base: "/",
    url: url_PostDescribeLoggingStatus_774945,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeLoggingStatus_774927 = ref object of OpenApiRestCall_772581
proc url_GetDescribeLoggingStatus_774929(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_GetDescribeLoggingStatus_774928(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Describes whether information, such as queries and connection attempts, is being logged for the specified Amazon Redshift cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The identifier of the cluster from which to get the logging status.</p> <p>Example: <code>examplecluster</code> </p>
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_774930 = query.getOrDefault("Action")
  valid_774930 = validateParameter(valid_774930, JString, required = true,
                                 default = newJString("DescribeLoggingStatus"))
  if valid_774930 != nil:
    section.add "Action", valid_774930
  var valid_774931 = query.getOrDefault("ClusterIdentifier")
  valid_774931 = validateParameter(valid_774931, JString, required = true,
                                 default = nil)
  if valid_774931 != nil:
    section.add "ClusterIdentifier", valid_774931
  var valid_774932 = query.getOrDefault("Version")
  valid_774932 = validateParameter(valid_774932, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_774932 != nil:
    section.add "Version", valid_774932
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_774933 = header.getOrDefault("X-Amz-Date")
  valid_774933 = validateParameter(valid_774933, JString, required = false,
                                 default = nil)
  if valid_774933 != nil:
    section.add "X-Amz-Date", valid_774933
  var valid_774934 = header.getOrDefault("X-Amz-Security-Token")
  valid_774934 = validateParameter(valid_774934, JString, required = false,
                                 default = nil)
  if valid_774934 != nil:
    section.add "X-Amz-Security-Token", valid_774934
  var valid_774935 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_774935 = validateParameter(valid_774935, JString, required = false,
                                 default = nil)
  if valid_774935 != nil:
    section.add "X-Amz-Content-Sha256", valid_774935
  var valid_774936 = header.getOrDefault("X-Amz-Algorithm")
  valid_774936 = validateParameter(valid_774936, JString, required = false,
                                 default = nil)
  if valid_774936 != nil:
    section.add "X-Amz-Algorithm", valid_774936
  var valid_774937 = header.getOrDefault("X-Amz-Signature")
  valid_774937 = validateParameter(valid_774937, JString, required = false,
                                 default = nil)
  if valid_774937 != nil:
    section.add "X-Amz-Signature", valid_774937
  var valid_774938 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_774938 = validateParameter(valid_774938, JString, required = false,
                                 default = nil)
  if valid_774938 != nil:
    section.add "X-Amz-SignedHeaders", valid_774938
  var valid_774939 = header.getOrDefault("X-Amz-Credential")
  valid_774939 = validateParameter(valid_774939, JString, required = false,
                                 default = nil)
  if valid_774939 != nil:
    section.add "X-Amz-Credential", valid_774939
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_774940: Call_GetDescribeLoggingStatus_774927; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Describes whether information, such as queries and connection attempts, is being logged for the specified Amazon Redshift cluster.
  ## 
  let valid = call_774940.validator(path, query, header, formData, body)
  let scheme = call_774940.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_774940.url(scheme.get, call_774940.host, call_774940.base,
                         call_774940.route, valid.getOrDefault("path"))
  result = hook(call_774940, url, valid)

proc call*(call_774941: Call_GetDescribeLoggingStatus_774927;
          ClusterIdentifier: string; Action: string = "DescribeLoggingStatus";
          Version: string = "2012-12-01"): Recallable =
  ## getDescribeLoggingStatus
  ## Describes whether information, such as queries and connection attempts, is being logged for the specified Amazon Redshift cluster.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The identifier of the cluster from which to get the logging status.</p> <p>Example: <code>examplecluster</code> </p>
  ##   Version: string (required)
  var query_774942 = newJObject()
  add(query_774942, "Action", newJString(Action))
  add(query_774942, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_774942, "Version", newJString(Version))
  result = call_774941.call(nil, query_774942, nil, nil, nil)

var getDescribeLoggingStatus* = Call_GetDescribeLoggingStatus_774927(
    name: "getDescribeLoggingStatus", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeLoggingStatus",
    validator: validate_GetDescribeLoggingStatus_774928, base: "/",
    url: url_GetDescribeLoggingStatus_774929, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeOrderableClusterOptions_774979 = ref object of OpenApiRestCall_772581
proc url_PostDescribeOrderableClusterOptions_774981(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_PostDescribeOrderableClusterOptions_774980(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns a list of orderable cluster options. Before you create a new cluster you can use this operation to find what options are available, such as the EC2 Availability Zones (AZ) in the specific AWS Region that you can specify, and the node types you can request. The node types differ by available storage, memory, CPU and price. With the cost involved you might want to obtain a list of cluster options in the specific region and specify values when creating a cluster. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_774982 = query.getOrDefault("Action")
  valid_774982 = validateParameter(valid_774982, JString, required = true, default = newJString(
      "DescribeOrderableClusterOptions"))
  if valid_774982 != nil:
    section.add "Action", valid_774982
  var valid_774983 = query.getOrDefault("Version")
  valid_774983 = validateParameter(valid_774983, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_774983 != nil:
    section.add "Version", valid_774983
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_774984 = header.getOrDefault("X-Amz-Date")
  valid_774984 = validateParameter(valid_774984, JString, required = false,
                                 default = nil)
  if valid_774984 != nil:
    section.add "X-Amz-Date", valid_774984
  var valid_774985 = header.getOrDefault("X-Amz-Security-Token")
  valid_774985 = validateParameter(valid_774985, JString, required = false,
                                 default = nil)
  if valid_774985 != nil:
    section.add "X-Amz-Security-Token", valid_774985
  var valid_774986 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_774986 = validateParameter(valid_774986, JString, required = false,
                                 default = nil)
  if valid_774986 != nil:
    section.add "X-Amz-Content-Sha256", valid_774986
  var valid_774987 = header.getOrDefault("X-Amz-Algorithm")
  valid_774987 = validateParameter(valid_774987, JString, required = false,
                                 default = nil)
  if valid_774987 != nil:
    section.add "X-Amz-Algorithm", valid_774987
  var valid_774988 = header.getOrDefault("X-Amz-Signature")
  valid_774988 = validateParameter(valid_774988, JString, required = false,
                                 default = nil)
  if valid_774988 != nil:
    section.add "X-Amz-Signature", valid_774988
  var valid_774989 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_774989 = validateParameter(valid_774989, JString, required = false,
                                 default = nil)
  if valid_774989 != nil:
    section.add "X-Amz-SignedHeaders", valid_774989
  var valid_774990 = header.getOrDefault("X-Amz-Credential")
  valid_774990 = validateParameter(valid_774990, JString, required = false,
                                 default = nil)
  if valid_774990 != nil:
    section.add "X-Amz-Credential", valid_774990
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterVersion: JString
  ##                 : <p>The version filter value. Specify this parameter to show only the available offerings matching the specified version.</p> <p>Default: All versions.</p> <p>Constraints: Must be one of the version returned from <a>DescribeClusterVersions</a>.</p>
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeOrderableClusterOptions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   NodeType: JString
  ##           : The node type filter value. Specify this parameter to show only the available offerings matching the specified node type.
  section = newJObject()
  var valid_774991 = formData.getOrDefault("ClusterVersion")
  valid_774991 = validateParameter(valid_774991, JString, required = false,
                                 default = nil)
  if valid_774991 != nil:
    section.add "ClusterVersion", valid_774991
  var valid_774992 = formData.getOrDefault("Marker")
  valid_774992 = validateParameter(valid_774992, JString, required = false,
                                 default = nil)
  if valid_774992 != nil:
    section.add "Marker", valid_774992
  var valid_774993 = formData.getOrDefault("MaxRecords")
  valid_774993 = validateParameter(valid_774993, JInt, required = false, default = nil)
  if valid_774993 != nil:
    section.add "MaxRecords", valid_774993
  var valid_774994 = formData.getOrDefault("NodeType")
  valid_774994 = validateParameter(valid_774994, JString, required = false,
                                 default = nil)
  if valid_774994 != nil:
    section.add "NodeType", valid_774994
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_774995: Call_PostDescribeOrderableClusterOptions_774979;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Returns a list of orderable cluster options. Before you create a new cluster you can use this operation to find what options are available, such as the EC2 Availability Zones (AZ) in the specific AWS Region that you can specify, and the node types you can request. The node types differ by available storage, memory, CPU and price. With the cost involved you might want to obtain a list of cluster options in the specific region and specify values when creating a cluster. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.
  ## 
  let valid = call_774995.validator(path, query, header, formData, body)
  let scheme = call_774995.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_774995.url(scheme.get, call_774995.host, call_774995.base,
                         call_774995.route, valid.getOrDefault("path"))
  result = hook(call_774995, url, valid)

proc call*(call_774996: Call_PostDescribeOrderableClusterOptions_774979;
          ClusterVersion: string = ""; Marker: string = "";
          Action: string = "DescribeOrderableClusterOptions"; MaxRecords: int = 0;
          Version: string = "2012-12-01"; NodeType: string = ""): Recallable =
  ## postDescribeOrderableClusterOptions
  ## Returns a list of orderable cluster options. Before you create a new cluster you can use this operation to find what options are available, such as the EC2 Availability Zones (AZ) in the specific AWS Region that you can specify, and the node types you can request. The node types differ by available storage, memory, CPU and price. With the cost involved you might want to obtain a list of cluster options in the specific region and specify values when creating a cluster. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.
  ##   ClusterVersion: string
  ##                 : <p>The version filter value. Specify this parameter to show only the available offerings matching the specified version.</p> <p>Default: All versions.</p> <p>Constraints: Must be one of the version returned from <a>DescribeClusterVersions</a>.</p>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeOrderableClusterOptions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Action: string (required)
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Version: string (required)
  ##   NodeType: string
  ##           : The node type filter value. Specify this parameter to show only the available offerings matching the specified node type.
  var query_774997 = newJObject()
  var formData_774998 = newJObject()
  add(formData_774998, "ClusterVersion", newJString(ClusterVersion))
  add(formData_774998, "Marker", newJString(Marker))
  add(query_774997, "Action", newJString(Action))
  add(formData_774998, "MaxRecords", newJInt(MaxRecords))
  add(query_774997, "Version", newJString(Version))
  add(formData_774998, "NodeType", newJString(NodeType))
  result = call_774996.call(nil, query_774997, nil, formData_774998, nil)

var postDescribeOrderableClusterOptions* = Call_PostDescribeOrderableClusterOptions_774979(
    name: "postDescribeOrderableClusterOptions", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeOrderableClusterOptions",
    validator: validate_PostDescribeOrderableClusterOptions_774980, base: "/",
    url: url_PostDescribeOrderableClusterOptions_774981,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeOrderableClusterOptions_774960 = ref object of OpenApiRestCall_772581
proc url_GetDescribeOrderableClusterOptions_774962(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_GetDescribeOrderableClusterOptions_774961(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns a list of orderable cluster options. Before you create a new cluster you can use this operation to find what options are available, such as the EC2 Availability Zones (AZ) in the specific AWS Region that you can specify, and the node types you can request. The node types differ by available storage, memory, CPU and price. With the cost involved you might want to obtain a list of cluster options in the specific region and specify values when creating a cluster. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Action: JString (required)
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeOrderableClusterOptions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   NodeType: JString
  ##           : The node type filter value. Specify this parameter to show only the available offerings matching the specified node type.
  ##   ClusterVersion: JString
  ##                 : <p>The version filter value. Specify this parameter to show only the available offerings matching the specified version.</p> <p>Default: All versions.</p> <p>Constraints: Must be one of the version returned from <a>DescribeClusterVersions</a>.</p>
  ##   Version: JString (required)
  section = newJObject()
  var valid_774963 = query.getOrDefault("MaxRecords")
  valid_774963 = validateParameter(valid_774963, JInt, required = false, default = nil)
  if valid_774963 != nil:
    section.add "MaxRecords", valid_774963
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_774964 = query.getOrDefault("Action")
  valid_774964 = validateParameter(valid_774964, JString, required = true, default = newJString(
      "DescribeOrderableClusterOptions"))
  if valid_774964 != nil:
    section.add "Action", valid_774964
  var valid_774965 = query.getOrDefault("Marker")
  valid_774965 = validateParameter(valid_774965, JString, required = false,
                                 default = nil)
  if valid_774965 != nil:
    section.add "Marker", valid_774965
  var valid_774966 = query.getOrDefault("NodeType")
  valid_774966 = validateParameter(valid_774966, JString, required = false,
                                 default = nil)
  if valid_774966 != nil:
    section.add "NodeType", valid_774966
  var valid_774967 = query.getOrDefault("ClusterVersion")
  valid_774967 = validateParameter(valid_774967, JString, required = false,
                                 default = nil)
  if valid_774967 != nil:
    section.add "ClusterVersion", valid_774967
  var valid_774968 = query.getOrDefault("Version")
  valid_774968 = validateParameter(valid_774968, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_774968 != nil:
    section.add "Version", valid_774968
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_774969 = header.getOrDefault("X-Amz-Date")
  valid_774969 = validateParameter(valid_774969, JString, required = false,
                                 default = nil)
  if valid_774969 != nil:
    section.add "X-Amz-Date", valid_774969
  var valid_774970 = header.getOrDefault("X-Amz-Security-Token")
  valid_774970 = validateParameter(valid_774970, JString, required = false,
                                 default = nil)
  if valid_774970 != nil:
    section.add "X-Amz-Security-Token", valid_774970
  var valid_774971 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_774971 = validateParameter(valid_774971, JString, required = false,
                                 default = nil)
  if valid_774971 != nil:
    section.add "X-Amz-Content-Sha256", valid_774971
  var valid_774972 = header.getOrDefault("X-Amz-Algorithm")
  valid_774972 = validateParameter(valid_774972, JString, required = false,
                                 default = nil)
  if valid_774972 != nil:
    section.add "X-Amz-Algorithm", valid_774972
  var valid_774973 = header.getOrDefault("X-Amz-Signature")
  valid_774973 = validateParameter(valid_774973, JString, required = false,
                                 default = nil)
  if valid_774973 != nil:
    section.add "X-Amz-Signature", valid_774973
  var valid_774974 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_774974 = validateParameter(valid_774974, JString, required = false,
                                 default = nil)
  if valid_774974 != nil:
    section.add "X-Amz-SignedHeaders", valid_774974
  var valid_774975 = header.getOrDefault("X-Amz-Credential")
  valid_774975 = validateParameter(valid_774975, JString, required = false,
                                 default = nil)
  if valid_774975 != nil:
    section.add "X-Amz-Credential", valid_774975
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_774976: Call_GetDescribeOrderableClusterOptions_774960;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Returns a list of orderable cluster options. Before you create a new cluster you can use this operation to find what options are available, such as the EC2 Availability Zones (AZ) in the specific AWS Region that you can specify, and the node types you can request. The node types differ by available storage, memory, CPU and price. With the cost involved you might want to obtain a list of cluster options in the specific region and specify values when creating a cluster. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.
  ## 
  let valid = call_774976.validator(path, query, header, formData, body)
  let scheme = call_774976.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_774976.url(scheme.get, call_774976.host, call_774976.base,
                         call_774976.route, valid.getOrDefault("path"))
  result = hook(call_774976, url, valid)

proc call*(call_774977: Call_GetDescribeOrderableClusterOptions_774960;
          MaxRecords: int = 0; Action: string = "DescribeOrderableClusterOptions";
          Marker: string = ""; NodeType: string = ""; ClusterVersion: string = "";
          Version: string = "2012-12-01"): Recallable =
  ## getDescribeOrderableClusterOptions
  ## Returns a list of orderable cluster options. Before you create a new cluster you can use this operation to find what options are available, such as the EC2 Availability Zones (AZ) in the specific AWS Region that you can specify, and the node types you can request. The node types differ by available storage, memory, CPU and price. With the cost involved you might want to obtain a list of cluster options in the specific region and specify values when creating a cluster. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Action: string (required)
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeOrderableClusterOptions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   NodeType: string
  ##           : The node type filter value. Specify this parameter to show only the available offerings matching the specified node type.
  ##   ClusterVersion: string
  ##                 : <p>The version filter value. Specify this parameter to show only the available offerings matching the specified version.</p> <p>Default: All versions.</p> <p>Constraints: Must be one of the version returned from <a>DescribeClusterVersions</a>.</p>
  ##   Version: string (required)
  var query_774978 = newJObject()
  add(query_774978, "MaxRecords", newJInt(MaxRecords))
  add(query_774978, "Action", newJString(Action))
  add(query_774978, "Marker", newJString(Marker))
  add(query_774978, "NodeType", newJString(NodeType))
  add(query_774978, "ClusterVersion", newJString(ClusterVersion))
  add(query_774978, "Version", newJString(Version))
  result = call_774977.call(nil, query_774978, nil, nil, nil)

var getDescribeOrderableClusterOptions* = Call_GetDescribeOrderableClusterOptions_774960(
    name: "getDescribeOrderableClusterOptions", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeOrderableClusterOptions",
    validator: validate_GetDescribeOrderableClusterOptions_774961, base: "/",
    url: url_GetDescribeOrderableClusterOptions_774962,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeReservedNodeOfferings_775017 = ref object of OpenApiRestCall_772581
proc url_PostDescribeReservedNodeOfferings_775019(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_PostDescribeReservedNodeOfferings_775018(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns a list of the available reserved node offerings by Amazon Redshift with their descriptions including the node type, the fixed and recurring costs of reserving the node and duration the node will be reserved for you. These descriptions help you determine which reserve node offering you want to purchase. You then use the unique offering ID in you call to <a>PurchaseReservedNodeOffering</a> to reserve one or more nodes for your Amazon Redshift cluster. </p> <p> For more information about reserved node offerings, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_775020 = query.getOrDefault("Action")
  valid_775020 = validateParameter(valid_775020, JString, required = true, default = newJString(
      "DescribeReservedNodeOfferings"))
  if valid_775020 != nil:
    section.add "Action", valid_775020
  var valid_775021 = query.getOrDefault("Version")
  valid_775021 = validateParameter(valid_775021, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_775021 != nil:
    section.add "Version", valid_775021
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_775022 = header.getOrDefault("X-Amz-Date")
  valid_775022 = validateParameter(valid_775022, JString, required = false,
                                 default = nil)
  if valid_775022 != nil:
    section.add "X-Amz-Date", valid_775022
  var valid_775023 = header.getOrDefault("X-Amz-Security-Token")
  valid_775023 = validateParameter(valid_775023, JString, required = false,
                                 default = nil)
  if valid_775023 != nil:
    section.add "X-Amz-Security-Token", valid_775023
  var valid_775024 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_775024 = validateParameter(valid_775024, JString, required = false,
                                 default = nil)
  if valid_775024 != nil:
    section.add "X-Amz-Content-Sha256", valid_775024
  var valid_775025 = header.getOrDefault("X-Amz-Algorithm")
  valid_775025 = validateParameter(valid_775025, JString, required = false,
                                 default = nil)
  if valid_775025 != nil:
    section.add "X-Amz-Algorithm", valid_775025
  var valid_775026 = header.getOrDefault("X-Amz-Signature")
  valid_775026 = validateParameter(valid_775026, JString, required = false,
                                 default = nil)
  if valid_775026 != nil:
    section.add "X-Amz-Signature", valid_775026
  var valid_775027 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_775027 = validateParameter(valid_775027, JString, required = false,
                                 default = nil)
  if valid_775027 != nil:
    section.add "X-Amz-SignedHeaders", valid_775027
  var valid_775028 = header.getOrDefault("X-Amz-Credential")
  valid_775028 = validateParameter(valid_775028, JString, required = false,
                                 default = nil)
  if valid_775028 != nil:
    section.add "X-Amz-Credential", valid_775028
  result.add "header", section
  ## parameters in `formData` object:
  ##   ReservedNodeOfferingId: JString
  ##                         : The unique identifier for the offering.
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeReservedNodeOfferings</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  section = newJObject()
  var valid_775029 = formData.getOrDefault("ReservedNodeOfferingId")
  valid_775029 = validateParameter(valid_775029, JString, required = false,
                                 default = nil)
  if valid_775029 != nil:
    section.add "ReservedNodeOfferingId", valid_775029
  var valid_775030 = formData.getOrDefault("Marker")
  valid_775030 = validateParameter(valid_775030, JString, required = false,
                                 default = nil)
  if valid_775030 != nil:
    section.add "Marker", valid_775030
  var valid_775031 = formData.getOrDefault("MaxRecords")
  valid_775031 = validateParameter(valid_775031, JInt, required = false, default = nil)
  if valid_775031 != nil:
    section.add "MaxRecords", valid_775031
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_775032: Call_PostDescribeReservedNodeOfferings_775017;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Returns a list of the available reserved node offerings by Amazon Redshift with their descriptions including the node type, the fixed and recurring costs of reserving the node and duration the node will be reserved for you. These descriptions help you determine which reserve node offering you want to purchase. You then use the unique offering ID in you call to <a>PurchaseReservedNodeOffering</a> to reserve one or more nodes for your Amazon Redshift cluster. </p> <p> For more information about reserved node offerings, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_775032.validator(path, query, header, formData, body)
  let scheme = call_775032.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_775032.url(scheme.get, call_775032.host, call_775032.base,
                         call_775032.route, valid.getOrDefault("path"))
  result = hook(call_775032, url, valid)

proc call*(call_775033: Call_PostDescribeReservedNodeOfferings_775017;
          ReservedNodeOfferingId: string = ""; Marker: string = "";
          Action: string = "DescribeReservedNodeOfferings"; MaxRecords: int = 0;
          Version: string = "2012-12-01"): Recallable =
  ## postDescribeReservedNodeOfferings
  ## <p>Returns a list of the available reserved node offerings by Amazon Redshift with their descriptions including the node type, the fixed and recurring costs of reserving the node and duration the node will be reserved for you. These descriptions help you determine which reserve node offering you want to purchase. You then use the unique offering ID in you call to <a>PurchaseReservedNodeOffering</a> to reserve one or more nodes for your Amazon Redshift cluster. </p> <p> For more information about reserved node offerings, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   ReservedNodeOfferingId: string
  ##                         : The unique identifier for the offering.
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeReservedNodeOfferings</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Action: string (required)
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Version: string (required)
  var query_775034 = newJObject()
  var formData_775035 = newJObject()
  add(formData_775035, "ReservedNodeOfferingId",
      newJString(ReservedNodeOfferingId))
  add(formData_775035, "Marker", newJString(Marker))
  add(query_775034, "Action", newJString(Action))
  add(formData_775035, "MaxRecords", newJInt(MaxRecords))
  add(query_775034, "Version", newJString(Version))
  result = call_775033.call(nil, query_775034, nil, formData_775035, nil)

var postDescribeReservedNodeOfferings* = Call_PostDescribeReservedNodeOfferings_775017(
    name: "postDescribeReservedNodeOfferings", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeReservedNodeOfferings",
    validator: validate_PostDescribeReservedNodeOfferings_775018, base: "/",
    url: url_PostDescribeReservedNodeOfferings_775019,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeReservedNodeOfferings_774999 = ref object of OpenApiRestCall_772581
proc url_GetDescribeReservedNodeOfferings_775001(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_GetDescribeReservedNodeOfferings_775000(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns a list of the available reserved node offerings by Amazon Redshift with their descriptions including the node type, the fixed and recurring costs of reserving the node and duration the node will be reserved for you. These descriptions help you determine which reserve node offering you want to purchase. You then use the unique offering ID in you call to <a>PurchaseReservedNodeOffering</a> to reserve one or more nodes for your Amazon Redshift cluster. </p> <p> For more information about reserved node offerings, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   ReservedNodeOfferingId: JString
  ##                         : The unique identifier for the offering.
  ##   Action: JString (required)
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeReservedNodeOfferings</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Version: JString (required)
  section = newJObject()
  var valid_775002 = query.getOrDefault("MaxRecords")
  valid_775002 = validateParameter(valid_775002, JInt, required = false, default = nil)
  if valid_775002 != nil:
    section.add "MaxRecords", valid_775002
  var valid_775003 = query.getOrDefault("ReservedNodeOfferingId")
  valid_775003 = validateParameter(valid_775003, JString, required = false,
                                 default = nil)
  if valid_775003 != nil:
    section.add "ReservedNodeOfferingId", valid_775003
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_775004 = query.getOrDefault("Action")
  valid_775004 = validateParameter(valid_775004, JString, required = true, default = newJString(
      "DescribeReservedNodeOfferings"))
  if valid_775004 != nil:
    section.add "Action", valid_775004
  var valid_775005 = query.getOrDefault("Marker")
  valid_775005 = validateParameter(valid_775005, JString, required = false,
                                 default = nil)
  if valid_775005 != nil:
    section.add "Marker", valid_775005
  var valid_775006 = query.getOrDefault("Version")
  valid_775006 = validateParameter(valid_775006, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_775006 != nil:
    section.add "Version", valid_775006
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_775007 = header.getOrDefault("X-Amz-Date")
  valid_775007 = validateParameter(valid_775007, JString, required = false,
                                 default = nil)
  if valid_775007 != nil:
    section.add "X-Amz-Date", valid_775007
  var valid_775008 = header.getOrDefault("X-Amz-Security-Token")
  valid_775008 = validateParameter(valid_775008, JString, required = false,
                                 default = nil)
  if valid_775008 != nil:
    section.add "X-Amz-Security-Token", valid_775008
  var valid_775009 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_775009 = validateParameter(valid_775009, JString, required = false,
                                 default = nil)
  if valid_775009 != nil:
    section.add "X-Amz-Content-Sha256", valid_775009
  var valid_775010 = header.getOrDefault("X-Amz-Algorithm")
  valid_775010 = validateParameter(valid_775010, JString, required = false,
                                 default = nil)
  if valid_775010 != nil:
    section.add "X-Amz-Algorithm", valid_775010
  var valid_775011 = header.getOrDefault("X-Amz-Signature")
  valid_775011 = validateParameter(valid_775011, JString, required = false,
                                 default = nil)
  if valid_775011 != nil:
    section.add "X-Amz-Signature", valid_775011
  var valid_775012 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_775012 = validateParameter(valid_775012, JString, required = false,
                                 default = nil)
  if valid_775012 != nil:
    section.add "X-Amz-SignedHeaders", valid_775012
  var valid_775013 = header.getOrDefault("X-Amz-Credential")
  valid_775013 = validateParameter(valid_775013, JString, required = false,
                                 default = nil)
  if valid_775013 != nil:
    section.add "X-Amz-Credential", valid_775013
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_775014: Call_GetDescribeReservedNodeOfferings_774999;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Returns a list of the available reserved node offerings by Amazon Redshift with their descriptions including the node type, the fixed and recurring costs of reserving the node and duration the node will be reserved for you. These descriptions help you determine which reserve node offering you want to purchase. You then use the unique offering ID in you call to <a>PurchaseReservedNodeOffering</a> to reserve one or more nodes for your Amazon Redshift cluster. </p> <p> For more information about reserved node offerings, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_775014.validator(path, query, header, formData, body)
  let scheme = call_775014.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_775014.url(scheme.get, call_775014.host, call_775014.base,
                         call_775014.route, valid.getOrDefault("path"))
  result = hook(call_775014, url, valid)

proc call*(call_775015: Call_GetDescribeReservedNodeOfferings_774999;
          MaxRecords: int = 0; ReservedNodeOfferingId: string = "";
          Action: string = "DescribeReservedNodeOfferings"; Marker: string = "";
          Version: string = "2012-12-01"): Recallable =
  ## getDescribeReservedNodeOfferings
  ## <p>Returns a list of the available reserved node offerings by Amazon Redshift with their descriptions including the node type, the fixed and recurring costs of reserving the node and duration the node will be reserved for you. These descriptions help you determine which reserve node offering you want to purchase. You then use the unique offering ID in you call to <a>PurchaseReservedNodeOffering</a> to reserve one or more nodes for your Amazon Redshift cluster. </p> <p> For more information about reserved node offerings, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   ReservedNodeOfferingId: string
  ##                         : The unique identifier for the offering.
  ##   Action: string (required)
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeReservedNodeOfferings</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Version: string (required)
  var query_775016 = newJObject()
  add(query_775016, "MaxRecords", newJInt(MaxRecords))
  add(query_775016, "ReservedNodeOfferingId", newJString(ReservedNodeOfferingId))
  add(query_775016, "Action", newJString(Action))
  add(query_775016, "Marker", newJString(Marker))
  add(query_775016, "Version", newJString(Version))
  result = call_775015.call(nil, query_775016, nil, nil, nil)

var getDescribeReservedNodeOfferings* = Call_GetDescribeReservedNodeOfferings_774999(
    name: "getDescribeReservedNodeOfferings", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeReservedNodeOfferings",
    validator: validate_GetDescribeReservedNodeOfferings_775000, base: "/",
    url: url_GetDescribeReservedNodeOfferings_775001,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeReservedNodes_775054 = ref object of OpenApiRestCall_772581
proc url_PostDescribeReservedNodes_775056(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_PostDescribeReservedNodes_775055(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns the descriptions of the reserved nodes.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_775057 = query.getOrDefault("Action")
  valid_775057 = validateParameter(valid_775057, JString, required = true,
                                 default = newJString("DescribeReservedNodes"))
  if valid_775057 != nil:
    section.add "Action", valid_775057
  var valid_775058 = query.getOrDefault("Version")
  valid_775058 = validateParameter(valid_775058, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_775058 != nil:
    section.add "Version", valid_775058
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_775059 = header.getOrDefault("X-Amz-Date")
  valid_775059 = validateParameter(valid_775059, JString, required = false,
                                 default = nil)
  if valid_775059 != nil:
    section.add "X-Amz-Date", valid_775059
  var valid_775060 = header.getOrDefault("X-Amz-Security-Token")
  valid_775060 = validateParameter(valid_775060, JString, required = false,
                                 default = nil)
  if valid_775060 != nil:
    section.add "X-Amz-Security-Token", valid_775060
  var valid_775061 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_775061 = validateParameter(valid_775061, JString, required = false,
                                 default = nil)
  if valid_775061 != nil:
    section.add "X-Amz-Content-Sha256", valid_775061
  var valid_775062 = header.getOrDefault("X-Amz-Algorithm")
  valid_775062 = validateParameter(valid_775062, JString, required = false,
                                 default = nil)
  if valid_775062 != nil:
    section.add "X-Amz-Algorithm", valid_775062
  var valid_775063 = header.getOrDefault("X-Amz-Signature")
  valid_775063 = validateParameter(valid_775063, JString, required = false,
                                 default = nil)
  if valid_775063 != nil:
    section.add "X-Amz-Signature", valid_775063
  var valid_775064 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_775064 = validateParameter(valid_775064, JString, required = false,
                                 default = nil)
  if valid_775064 != nil:
    section.add "X-Amz-SignedHeaders", valid_775064
  var valid_775065 = header.getOrDefault("X-Amz-Credential")
  valid_775065 = validateParameter(valid_775065, JString, required = false,
                                 default = nil)
  if valid_775065 != nil:
    section.add "X-Amz-Credential", valid_775065
  result.add "header", section
  ## parameters in `formData` object:
  ##   ReservedNodeId: JString
  ##                 : Identifier for the node reservation.
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeReservedNodes</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  section = newJObject()
  var valid_775066 = formData.getOrDefault("ReservedNodeId")
  valid_775066 = validateParameter(valid_775066, JString, required = false,
                                 default = nil)
  if valid_775066 != nil:
    section.add "ReservedNodeId", valid_775066
  var valid_775067 = formData.getOrDefault("Marker")
  valid_775067 = validateParameter(valid_775067, JString, required = false,
                                 default = nil)
  if valid_775067 != nil:
    section.add "Marker", valid_775067
  var valid_775068 = formData.getOrDefault("MaxRecords")
  valid_775068 = validateParameter(valid_775068, JInt, required = false, default = nil)
  if valid_775068 != nil:
    section.add "MaxRecords", valid_775068
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_775069: Call_PostDescribeReservedNodes_775054; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns the descriptions of the reserved nodes.
  ## 
  let valid = call_775069.validator(path, query, header, formData, body)
  let scheme = call_775069.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_775069.url(scheme.get, call_775069.host, call_775069.base,
                         call_775069.route, valid.getOrDefault("path"))
  result = hook(call_775069, url, valid)

proc call*(call_775070: Call_PostDescribeReservedNodes_775054;
          ReservedNodeId: string = ""; Marker: string = "";
          Action: string = "DescribeReservedNodes"; MaxRecords: int = 0;
          Version: string = "2012-12-01"): Recallable =
  ## postDescribeReservedNodes
  ## Returns the descriptions of the reserved nodes.
  ##   ReservedNodeId: string
  ##                 : Identifier for the node reservation.
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeReservedNodes</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Action: string (required)
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Version: string (required)
  var query_775071 = newJObject()
  var formData_775072 = newJObject()
  add(formData_775072, "ReservedNodeId", newJString(ReservedNodeId))
  add(formData_775072, "Marker", newJString(Marker))
  add(query_775071, "Action", newJString(Action))
  add(formData_775072, "MaxRecords", newJInt(MaxRecords))
  add(query_775071, "Version", newJString(Version))
  result = call_775070.call(nil, query_775071, nil, formData_775072, nil)

var postDescribeReservedNodes* = Call_PostDescribeReservedNodes_775054(
    name: "postDescribeReservedNodes", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeReservedNodes",
    validator: validate_PostDescribeReservedNodes_775055, base: "/",
    url: url_PostDescribeReservedNodes_775056,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeReservedNodes_775036 = ref object of OpenApiRestCall_772581
proc url_GetDescribeReservedNodes_775038(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_GetDescribeReservedNodes_775037(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns the descriptions of the reserved nodes.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Action: JString (required)
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeReservedNodes</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Version: JString (required)
  ##   ReservedNodeId: JString
  ##                 : Identifier for the node reservation.
  section = newJObject()
  var valid_775039 = query.getOrDefault("MaxRecords")
  valid_775039 = validateParameter(valid_775039, JInt, required = false, default = nil)
  if valid_775039 != nil:
    section.add "MaxRecords", valid_775039
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_775040 = query.getOrDefault("Action")
  valid_775040 = validateParameter(valid_775040, JString, required = true,
                                 default = newJString("DescribeReservedNodes"))
  if valid_775040 != nil:
    section.add "Action", valid_775040
  var valid_775041 = query.getOrDefault("Marker")
  valid_775041 = validateParameter(valid_775041, JString, required = false,
                                 default = nil)
  if valid_775041 != nil:
    section.add "Marker", valid_775041
  var valid_775042 = query.getOrDefault("Version")
  valid_775042 = validateParameter(valid_775042, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_775042 != nil:
    section.add "Version", valid_775042
  var valid_775043 = query.getOrDefault("ReservedNodeId")
  valid_775043 = validateParameter(valid_775043, JString, required = false,
                                 default = nil)
  if valid_775043 != nil:
    section.add "ReservedNodeId", valid_775043
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_775044 = header.getOrDefault("X-Amz-Date")
  valid_775044 = validateParameter(valid_775044, JString, required = false,
                                 default = nil)
  if valid_775044 != nil:
    section.add "X-Amz-Date", valid_775044
  var valid_775045 = header.getOrDefault("X-Amz-Security-Token")
  valid_775045 = validateParameter(valid_775045, JString, required = false,
                                 default = nil)
  if valid_775045 != nil:
    section.add "X-Amz-Security-Token", valid_775045
  var valid_775046 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_775046 = validateParameter(valid_775046, JString, required = false,
                                 default = nil)
  if valid_775046 != nil:
    section.add "X-Amz-Content-Sha256", valid_775046
  var valid_775047 = header.getOrDefault("X-Amz-Algorithm")
  valid_775047 = validateParameter(valid_775047, JString, required = false,
                                 default = nil)
  if valid_775047 != nil:
    section.add "X-Amz-Algorithm", valid_775047
  var valid_775048 = header.getOrDefault("X-Amz-Signature")
  valid_775048 = validateParameter(valid_775048, JString, required = false,
                                 default = nil)
  if valid_775048 != nil:
    section.add "X-Amz-Signature", valid_775048
  var valid_775049 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_775049 = validateParameter(valid_775049, JString, required = false,
                                 default = nil)
  if valid_775049 != nil:
    section.add "X-Amz-SignedHeaders", valid_775049
  var valid_775050 = header.getOrDefault("X-Amz-Credential")
  valid_775050 = validateParameter(valid_775050, JString, required = false,
                                 default = nil)
  if valid_775050 != nil:
    section.add "X-Amz-Credential", valid_775050
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_775051: Call_GetDescribeReservedNodes_775036; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns the descriptions of the reserved nodes.
  ## 
  let valid = call_775051.validator(path, query, header, formData, body)
  let scheme = call_775051.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_775051.url(scheme.get, call_775051.host, call_775051.base,
                         call_775051.route, valid.getOrDefault("path"))
  result = hook(call_775051, url, valid)

proc call*(call_775052: Call_GetDescribeReservedNodes_775036; MaxRecords: int = 0;
          Action: string = "DescribeReservedNodes"; Marker: string = "";
          Version: string = "2012-12-01"; ReservedNodeId: string = ""): Recallable =
  ## getDescribeReservedNodes
  ## Returns the descriptions of the reserved nodes.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Action: string (required)
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeReservedNodes</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Version: string (required)
  ##   ReservedNodeId: string
  ##                 : Identifier for the node reservation.
  var query_775053 = newJObject()
  add(query_775053, "MaxRecords", newJInt(MaxRecords))
  add(query_775053, "Action", newJString(Action))
  add(query_775053, "Marker", newJString(Marker))
  add(query_775053, "Version", newJString(Version))
  add(query_775053, "ReservedNodeId", newJString(ReservedNodeId))
  result = call_775052.call(nil, query_775053, nil, nil, nil)

var getDescribeReservedNodes* = Call_GetDescribeReservedNodes_775036(
    name: "getDescribeReservedNodes", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeReservedNodes",
    validator: validate_GetDescribeReservedNodes_775037, base: "/",
    url: url_GetDescribeReservedNodes_775038, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeResize_775089 = ref object of OpenApiRestCall_772581
proc url_PostDescribeResize_775091(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_PostDescribeResize_775090(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## <p>Returns information about the last resize operation for the specified cluster. If no resize operation has ever been initiated for the specified cluster, a <code>HTTP 404</code> error is returned. If a resize operation was initiated and completed, the status of the resize remains as <code>SUCCEEDED</code> until the next resize. </p> <p>A resize operation can be requested using <a>ModifyCluster</a> and specifying a different number or type of nodes for the cluster. </p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_775092 = query.getOrDefault("Action")
  valid_775092 = validateParameter(valid_775092, JString, required = true,
                                 default = newJString("DescribeResize"))
  if valid_775092 != nil:
    section.add "Action", valid_775092
  var valid_775093 = query.getOrDefault("Version")
  valid_775093 = validateParameter(valid_775093, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_775093 != nil:
    section.add "Version", valid_775093
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_775094 = header.getOrDefault("X-Amz-Date")
  valid_775094 = validateParameter(valid_775094, JString, required = false,
                                 default = nil)
  if valid_775094 != nil:
    section.add "X-Amz-Date", valid_775094
  var valid_775095 = header.getOrDefault("X-Amz-Security-Token")
  valid_775095 = validateParameter(valid_775095, JString, required = false,
                                 default = nil)
  if valid_775095 != nil:
    section.add "X-Amz-Security-Token", valid_775095
  var valid_775096 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_775096 = validateParameter(valid_775096, JString, required = false,
                                 default = nil)
  if valid_775096 != nil:
    section.add "X-Amz-Content-Sha256", valid_775096
  var valid_775097 = header.getOrDefault("X-Amz-Algorithm")
  valid_775097 = validateParameter(valid_775097, JString, required = false,
                                 default = nil)
  if valid_775097 != nil:
    section.add "X-Amz-Algorithm", valid_775097
  var valid_775098 = header.getOrDefault("X-Amz-Signature")
  valid_775098 = validateParameter(valid_775098, JString, required = false,
                                 default = nil)
  if valid_775098 != nil:
    section.add "X-Amz-Signature", valid_775098
  var valid_775099 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_775099 = validateParameter(valid_775099, JString, required = false,
                                 default = nil)
  if valid_775099 != nil:
    section.add "X-Amz-SignedHeaders", valid_775099
  var valid_775100 = header.getOrDefault("X-Amz-Credential")
  valid_775100 = validateParameter(valid_775100, JString, required = false,
                                 default = nil)
  if valid_775100 != nil:
    section.add "X-Amz-Credential", valid_775100
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of a cluster whose resize progress you are requesting. This parameter is case-sensitive.</p> <p>By default, resize operations for all clusters defined for an AWS account are returned.</p>
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_775101 = formData.getOrDefault("ClusterIdentifier")
  valid_775101 = validateParameter(valid_775101, JString, required = true,
                                 default = nil)
  if valid_775101 != nil:
    section.add "ClusterIdentifier", valid_775101
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_775102: Call_PostDescribeResize_775089; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns information about the last resize operation for the specified cluster. If no resize operation has ever been initiated for the specified cluster, a <code>HTTP 404</code> error is returned. If a resize operation was initiated and completed, the status of the resize remains as <code>SUCCEEDED</code> until the next resize. </p> <p>A resize operation can be requested using <a>ModifyCluster</a> and specifying a different number or type of nodes for the cluster. </p>
  ## 
  let valid = call_775102.validator(path, query, header, formData, body)
  let scheme = call_775102.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_775102.url(scheme.get, call_775102.host, call_775102.base,
                         call_775102.route, valid.getOrDefault("path"))
  result = hook(call_775102, url, valid)

proc call*(call_775103: Call_PostDescribeResize_775089; ClusterIdentifier: string;
          Action: string = "DescribeResize"; Version: string = "2012-12-01"): Recallable =
  ## postDescribeResize
  ## <p>Returns information about the last resize operation for the specified cluster. If no resize operation has ever been initiated for the specified cluster, a <code>HTTP 404</code> error is returned. If a resize operation was initiated and completed, the status of the resize remains as <code>SUCCEEDED</code> until the next resize. </p> <p>A resize operation can be requested using <a>ModifyCluster</a> and specifying a different number or type of nodes for the cluster. </p>
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of a cluster whose resize progress you are requesting. This parameter is case-sensitive.</p> <p>By default, resize operations for all clusters defined for an AWS account are returned.</p>
  ##   Version: string (required)
  var query_775104 = newJObject()
  var formData_775105 = newJObject()
  add(query_775104, "Action", newJString(Action))
  add(formData_775105, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_775104, "Version", newJString(Version))
  result = call_775103.call(nil, query_775104, nil, formData_775105, nil)

var postDescribeResize* = Call_PostDescribeResize_775089(
    name: "postDescribeResize", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeResize",
    validator: validate_PostDescribeResize_775090, base: "/",
    url: url_PostDescribeResize_775091, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeResize_775073 = ref object of OpenApiRestCall_772581
proc url_GetDescribeResize_775075(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_GetDescribeResize_775074(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## <p>Returns information about the last resize operation for the specified cluster. If no resize operation has ever been initiated for the specified cluster, a <code>HTTP 404</code> error is returned. If a resize operation was initiated and completed, the status of the resize remains as <code>SUCCEEDED</code> until the next resize. </p> <p>A resize operation can be requested using <a>ModifyCluster</a> and specifying a different number or type of nodes for the cluster. </p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of a cluster whose resize progress you are requesting. This parameter is case-sensitive.</p> <p>By default, resize operations for all clusters defined for an AWS account are returned.</p>
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_775076 = query.getOrDefault("Action")
  valid_775076 = validateParameter(valid_775076, JString, required = true,
                                 default = newJString("DescribeResize"))
  if valid_775076 != nil:
    section.add "Action", valid_775076
  var valid_775077 = query.getOrDefault("ClusterIdentifier")
  valid_775077 = validateParameter(valid_775077, JString, required = true,
                                 default = nil)
  if valid_775077 != nil:
    section.add "ClusterIdentifier", valid_775077
  var valid_775078 = query.getOrDefault("Version")
  valid_775078 = validateParameter(valid_775078, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_775078 != nil:
    section.add "Version", valid_775078
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_775079 = header.getOrDefault("X-Amz-Date")
  valid_775079 = validateParameter(valid_775079, JString, required = false,
                                 default = nil)
  if valid_775079 != nil:
    section.add "X-Amz-Date", valid_775079
  var valid_775080 = header.getOrDefault("X-Amz-Security-Token")
  valid_775080 = validateParameter(valid_775080, JString, required = false,
                                 default = nil)
  if valid_775080 != nil:
    section.add "X-Amz-Security-Token", valid_775080
  var valid_775081 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_775081 = validateParameter(valid_775081, JString, required = false,
                                 default = nil)
  if valid_775081 != nil:
    section.add "X-Amz-Content-Sha256", valid_775081
  var valid_775082 = header.getOrDefault("X-Amz-Algorithm")
  valid_775082 = validateParameter(valid_775082, JString, required = false,
                                 default = nil)
  if valid_775082 != nil:
    section.add "X-Amz-Algorithm", valid_775082
  var valid_775083 = header.getOrDefault("X-Amz-Signature")
  valid_775083 = validateParameter(valid_775083, JString, required = false,
                                 default = nil)
  if valid_775083 != nil:
    section.add "X-Amz-Signature", valid_775083
  var valid_775084 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_775084 = validateParameter(valid_775084, JString, required = false,
                                 default = nil)
  if valid_775084 != nil:
    section.add "X-Amz-SignedHeaders", valid_775084
  var valid_775085 = header.getOrDefault("X-Amz-Credential")
  valid_775085 = validateParameter(valid_775085, JString, required = false,
                                 default = nil)
  if valid_775085 != nil:
    section.add "X-Amz-Credential", valid_775085
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_775086: Call_GetDescribeResize_775073; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns information about the last resize operation for the specified cluster. If no resize operation has ever been initiated for the specified cluster, a <code>HTTP 404</code> error is returned. If a resize operation was initiated and completed, the status of the resize remains as <code>SUCCEEDED</code> until the next resize. </p> <p>A resize operation can be requested using <a>ModifyCluster</a> and specifying a different number or type of nodes for the cluster. </p>
  ## 
  let valid = call_775086.validator(path, query, header, formData, body)
  let scheme = call_775086.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_775086.url(scheme.get, call_775086.host, call_775086.base,
                         call_775086.route, valid.getOrDefault("path"))
  result = hook(call_775086, url, valid)

proc call*(call_775087: Call_GetDescribeResize_775073; ClusterIdentifier: string;
          Action: string = "DescribeResize"; Version: string = "2012-12-01"): Recallable =
  ## getDescribeResize
  ## <p>Returns information about the last resize operation for the specified cluster. If no resize operation has ever been initiated for the specified cluster, a <code>HTTP 404</code> error is returned. If a resize operation was initiated and completed, the status of the resize remains as <code>SUCCEEDED</code> until the next resize. </p> <p>A resize operation can be requested using <a>ModifyCluster</a> and specifying a different number or type of nodes for the cluster. </p>
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of a cluster whose resize progress you are requesting. This parameter is case-sensitive.</p> <p>By default, resize operations for all clusters defined for an AWS account are returned.</p>
  ##   Version: string (required)
  var query_775088 = newJObject()
  add(query_775088, "Action", newJString(Action))
  add(query_775088, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_775088, "Version", newJString(Version))
  result = call_775087.call(nil, query_775088, nil, nil, nil)

var getDescribeResize* = Call_GetDescribeResize_775073(name: "getDescribeResize",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=DescribeResize", validator: validate_GetDescribeResize_775074,
    base: "/", url: url_GetDescribeResize_775075,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeSnapshotCopyGrants_775126 = ref object of OpenApiRestCall_772581
proc url_PostDescribeSnapshotCopyGrants_775128(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_PostDescribeSnapshotCopyGrants_775127(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns a list of snapshot copy grants owned by the AWS account in the destination region.</p> <p> For more information about managing snapshot copy grants, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_775129 = query.getOrDefault("Action")
  valid_775129 = validateParameter(valid_775129, JString, required = true, default = newJString(
      "DescribeSnapshotCopyGrants"))
  if valid_775129 != nil:
    section.add "Action", valid_775129
  var valid_775130 = query.getOrDefault("Version")
  valid_775130 = validateParameter(valid_775130, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_775130 != nil:
    section.add "Version", valid_775130
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_775131 = header.getOrDefault("X-Amz-Date")
  valid_775131 = validateParameter(valid_775131, JString, required = false,
                                 default = nil)
  if valid_775131 != nil:
    section.add "X-Amz-Date", valid_775131
  var valid_775132 = header.getOrDefault("X-Amz-Security-Token")
  valid_775132 = validateParameter(valid_775132, JString, required = false,
                                 default = nil)
  if valid_775132 != nil:
    section.add "X-Amz-Security-Token", valid_775132
  var valid_775133 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_775133 = validateParameter(valid_775133, JString, required = false,
                                 default = nil)
  if valid_775133 != nil:
    section.add "X-Amz-Content-Sha256", valid_775133
  var valid_775134 = header.getOrDefault("X-Amz-Algorithm")
  valid_775134 = validateParameter(valid_775134, JString, required = false,
                                 default = nil)
  if valid_775134 != nil:
    section.add "X-Amz-Algorithm", valid_775134
  var valid_775135 = header.getOrDefault("X-Amz-Signature")
  valid_775135 = validateParameter(valid_775135, JString, required = false,
                                 default = nil)
  if valid_775135 != nil:
    section.add "X-Amz-Signature", valid_775135
  var valid_775136 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_775136 = validateParameter(valid_775136, JString, required = false,
                                 default = nil)
  if valid_775136 != nil:
    section.add "X-Amz-SignedHeaders", valid_775136
  var valid_775137 = header.getOrDefault("X-Amz-Credential")
  valid_775137 = validateParameter(valid_775137, JString, required = false,
                                 default = nil)
  if valid_775137 != nil:
    section.add "X-Amz-Credential", valid_775137
  result.add "header", section
  ## parameters in `formData` object:
  ##   Marker: JString
  ##         : <p>An optional parameter that specifies the starting point to return a set of response records. When the results of a <code>DescribeSnapshotCopyGrant</code> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <b>SnapshotCopyGrantName</b> parameter or the <b>Marker</b> parameter, but not both. </p>
  ##   SnapshotCopyGrantName: JString
  ##                        : The name of the snapshot copy grant.
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching resources that are associated with the specified key or keys. For example, suppose that you have resources tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with all resources that have either or both of these tag keys associated with them.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching resources that are associated with the specified value or values. For example, suppose that you have resources tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with all resources that have either or both of these tag values associated with them.
  section = newJObject()
  var valid_775138 = formData.getOrDefault("Marker")
  valid_775138 = validateParameter(valid_775138, JString, required = false,
                                 default = nil)
  if valid_775138 != nil:
    section.add "Marker", valid_775138
  var valid_775139 = formData.getOrDefault("SnapshotCopyGrantName")
  valid_775139 = validateParameter(valid_775139, JString, required = false,
                                 default = nil)
  if valid_775139 != nil:
    section.add "SnapshotCopyGrantName", valid_775139
  var valid_775140 = formData.getOrDefault("TagKeys")
  valid_775140 = validateParameter(valid_775140, JArray, required = false,
                                 default = nil)
  if valid_775140 != nil:
    section.add "TagKeys", valid_775140
  var valid_775141 = formData.getOrDefault("MaxRecords")
  valid_775141 = validateParameter(valid_775141, JInt, required = false, default = nil)
  if valid_775141 != nil:
    section.add "MaxRecords", valid_775141
  var valid_775142 = formData.getOrDefault("TagValues")
  valid_775142 = validateParameter(valid_775142, JArray, required = false,
                                 default = nil)
  if valid_775142 != nil:
    section.add "TagValues", valid_775142
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_775143: Call_PostDescribeSnapshotCopyGrants_775126; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns a list of snapshot copy grants owned by the AWS account in the destination region.</p> <p> For more information about managing snapshot copy grants, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ## 
  let valid = call_775143.validator(path, query, header, formData, body)
  let scheme = call_775143.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_775143.url(scheme.get, call_775143.host, call_775143.base,
                         call_775143.route, valid.getOrDefault("path"))
  result = hook(call_775143, url, valid)

proc call*(call_775144: Call_PostDescribeSnapshotCopyGrants_775126;
          Marker: string = ""; Action: string = "DescribeSnapshotCopyGrants";
          SnapshotCopyGrantName: string = ""; TagKeys: JsonNode = nil;
          MaxRecords: int = 0; TagValues: JsonNode = nil; Version: string = "2012-12-01"): Recallable =
  ## postDescribeSnapshotCopyGrants
  ## <p>Returns a list of snapshot copy grants owned by the AWS account in the destination region.</p> <p> For more information about managing snapshot copy grants, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ##   Marker: string
  ##         : <p>An optional parameter that specifies the starting point to return a set of response records. When the results of a <code>DescribeSnapshotCopyGrant</code> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <b>SnapshotCopyGrantName</b> parameter or the <b>Marker</b> parameter, but not both. </p>
  ##   Action: string (required)
  ##   SnapshotCopyGrantName: string
  ##                        : The name of the snapshot copy grant.
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching resources that are associated with the specified key or keys. For example, suppose that you have resources tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with all resources that have either or both of these tag keys associated with them.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching resources that are associated with the specified value or values. For example, suppose that you have resources tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with all resources that have either or both of these tag values associated with them.
  ##   Version: string (required)
  var query_775145 = newJObject()
  var formData_775146 = newJObject()
  add(formData_775146, "Marker", newJString(Marker))
  add(query_775145, "Action", newJString(Action))
  add(formData_775146, "SnapshotCopyGrantName", newJString(SnapshotCopyGrantName))
  if TagKeys != nil:
    formData_775146.add "TagKeys", TagKeys
  add(formData_775146, "MaxRecords", newJInt(MaxRecords))
  if TagValues != nil:
    formData_775146.add "TagValues", TagValues
  add(query_775145, "Version", newJString(Version))
  result = call_775144.call(nil, query_775145, nil, formData_775146, nil)

var postDescribeSnapshotCopyGrants* = Call_PostDescribeSnapshotCopyGrants_775126(
    name: "postDescribeSnapshotCopyGrants", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeSnapshotCopyGrants",
    validator: validate_PostDescribeSnapshotCopyGrants_775127, base: "/",
    url: url_PostDescribeSnapshotCopyGrants_775128,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeSnapshotCopyGrants_775106 = ref object of OpenApiRestCall_772581
proc url_GetDescribeSnapshotCopyGrants_775108(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_GetDescribeSnapshotCopyGrants_775107(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns a list of snapshot copy grants owned by the AWS account in the destination region.</p> <p> For more information about managing snapshot copy grants, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching resources that are associated with the specified value or values. For example, suppose that you have resources tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with all resources that have either or both of these tag values associated with them.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Action: JString (required)
  ##   Marker: JString
  ##         : <p>An optional parameter that specifies the starting point to return a set of response records. When the results of a <code>DescribeSnapshotCopyGrant</code> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <b>SnapshotCopyGrantName</b> parameter or the <b>Marker</b> parameter, but not both. </p>
  ##   SnapshotCopyGrantName: JString
  ##                        : The name of the snapshot copy grant.
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching resources that are associated with the specified key or keys. For example, suppose that you have resources tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with all resources that have either or both of these tag keys associated with them.
  ##   Version: JString (required)
  section = newJObject()
  var valid_775109 = query.getOrDefault("TagValues")
  valid_775109 = validateParameter(valid_775109, JArray, required = false,
                                 default = nil)
  if valid_775109 != nil:
    section.add "TagValues", valid_775109
  var valid_775110 = query.getOrDefault("MaxRecords")
  valid_775110 = validateParameter(valid_775110, JInt, required = false, default = nil)
  if valid_775110 != nil:
    section.add "MaxRecords", valid_775110
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_775111 = query.getOrDefault("Action")
  valid_775111 = validateParameter(valid_775111, JString, required = true, default = newJString(
      "DescribeSnapshotCopyGrants"))
  if valid_775111 != nil:
    section.add "Action", valid_775111
  var valid_775112 = query.getOrDefault("Marker")
  valid_775112 = validateParameter(valid_775112, JString, required = false,
                                 default = nil)
  if valid_775112 != nil:
    section.add "Marker", valid_775112
  var valid_775113 = query.getOrDefault("SnapshotCopyGrantName")
  valid_775113 = validateParameter(valid_775113, JString, required = false,
                                 default = nil)
  if valid_775113 != nil:
    section.add "SnapshotCopyGrantName", valid_775113
  var valid_775114 = query.getOrDefault("TagKeys")
  valid_775114 = validateParameter(valid_775114, JArray, required = false,
                                 default = nil)
  if valid_775114 != nil:
    section.add "TagKeys", valid_775114
  var valid_775115 = query.getOrDefault("Version")
  valid_775115 = validateParameter(valid_775115, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_775115 != nil:
    section.add "Version", valid_775115
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_775116 = header.getOrDefault("X-Amz-Date")
  valid_775116 = validateParameter(valid_775116, JString, required = false,
                                 default = nil)
  if valid_775116 != nil:
    section.add "X-Amz-Date", valid_775116
  var valid_775117 = header.getOrDefault("X-Amz-Security-Token")
  valid_775117 = validateParameter(valid_775117, JString, required = false,
                                 default = nil)
  if valid_775117 != nil:
    section.add "X-Amz-Security-Token", valid_775117
  var valid_775118 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_775118 = validateParameter(valid_775118, JString, required = false,
                                 default = nil)
  if valid_775118 != nil:
    section.add "X-Amz-Content-Sha256", valid_775118
  var valid_775119 = header.getOrDefault("X-Amz-Algorithm")
  valid_775119 = validateParameter(valid_775119, JString, required = false,
                                 default = nil)
  if valid_775119 != nil:
    section.add "X-Amz-Algorithm", valid_775119
  var valid_775120 = header.getOrDefault("X-Amz-Signature")
  valid_775120 = validateParameter(valid_775120, JString, required = false,
                                 default = nil)
  if valid_775120 != nil:
    section.add "X-Amz-Signature", valid_775120
  var valid_775121 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_775121 = validateParameter(valid_775121, JString, required = false,
                                 default = nil)
  if valid_775121 != nil:
    section.add "X-Amz-SignedHeaders", valid_775121
  var valid_775122 = header.getOrDefault("X-Amz-Credential")
  valid_775122 = validateParameter(valid_775122, JString, required = false,
                                 default = nil)
  if valid_775122 != nil:
    section.add "X-Amz-Credential", valid_775122
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_775123: Call_GetDescribeSnapshotCopyGrants_775106; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns a list of snapshot copy grants owned by the AWS account in the destination region.</p> <p> For more information about managing snapshot copy grants, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ## 
  let valid = call_775123.validator(path, query, header, formData, body)
  let scheme = call_775123.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_775123.url(scheme.get, call_775123.host, call_775123.base,
                         call_775123.route, valid.getOrDefault("path"))
  result = hook(call_775123, url, valid)

proc call*(call_775124: Call_GetDescribeSnapshotCopyGrants_775106;
          TagValues: JsonNode = nil; MaxRecords: int = 0;
          Action: string = "DescribeSnapshotCopyGrants"; Marker: string = "";
          SnapshotCopyGrantName: string = ""; TagKeys: JsonNode = nil;
          Version: string = "2012-12-01"): Recallable =
  ## getDescribeSnapshotCopyGrants
  ## <p>Returns a list of snapshot copy grants owned by the AWS account in the destination region.</p> <p> For more information about managing snapshot copy grants, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching resources that are associated with the specified value or values. For example, suppose that you have resources tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with all resources that have either or both of these tag values associated with them.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Action: string (required)
  ##   Marker: string
  ##         : <p>An optional parameter that specifies the starting point to return a set of response records. When the results of a <code>DescribeSnapshotCopyGrant</code> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <b>SnapshotCopyGrantName</b> parameter or the <b>Marker</b> parameter, but not both. </p>
  ##   SnapshotCopyGrantName: string
  ##                        : The name of the snapshot copy grant.
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching resources that are associated with the specified key or keys. For example, suppose that you have resources tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with all resources that have either or both of these tag keys associated with them.
  ##   Version: string (required)
  var query_775125 = newJObject()
  if TagValues != nil:
    query_775125.add "TagValues", TagValues
  add(query_775125, "MaxRecords", newJInt(MaxRecords))
  add(query_775125, "Action", newJString(Action))
  add(query_775125, "Marker", newJString(Marker))
  add(query_775125, "SnapshotCopyGrantName", newJString(SnapshotCopyGrantName))
  if TagKeys != nil:
    query_775125.add "TagKeys", TagKeys
  add(query_775125, "Version", newJString(Version))
  result = call_775124.call(nil, query_775125, nil, nil, nil)

var getDescribeSnapshotCopyGrants* = Call_GetDescribeSnapshotCopyGrants_775106(
    name: "getDescribeSnapshotCopyGrants", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeSnapshotCopyGrants",
    validator: validate_GetDescribeSnapshotCopyGrants_775107, base: "/",
    url: url_GetDescribeSnapshotCopyGrants_775108,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeSnapshotSchedules_775168 = ref object of OpenApiRestCall_772581
proc url_PostDescribeSnapshotSchedules_775170(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_PostDescribeSnapshotSchedules_775169(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns a list of snapshot schedules. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_775171 = query.getOrDefault("Action")
  valid_775171 = validateParameter(valid_775171, JString, required = true, default = newJString(
      "DescribeSnapshotSchedules"))
  if valid_775171 != nil:
    section.add "Action", valid_775171
  var valid_775172 = query.getOrDefault("Version")
  valid_775172 = validateParameter(valid_775172, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_775172 != nil:
    section.add "Version", valid_775172
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_775173 = header.getOrDefault("X-Amz-Date")
  valid_775173 = validateParameter(valid_775173, JString, required = false,
                                 default = nil)
  if valid_775173 != nil:
    section.add "X-Amz-Date", valid_775173
  var valid_775174 = header.getOrDefault("X-Amz-Security-Token")
  valid_775174 = validateParameter(valid_775174, JString, required = false,
                                 default = nil)
  if valid_775174 != nil:
    section.add "X-Amz-Security-Token", valid_775174
  var valid_775175 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_775175 = validateParameter(valid_775175, JString, required = false,
                                 default = nil)
  if valid_775175 != nil:
    section.add "X-Amz-Content-Sha256", valid_775175
  var valid_775176 = header.getOrDefault("X-Amz-Algorithm")
  valid_775176 = validateParameter(valid_775176, JString, required = false,
                                 default = nil)
  if valid_775176 != nil:
    section.add "X-Amz-Algorithm", valid_775176
  var valid_775177 = header.getOrDefault("X-Amz-Signature")
  valid_775177 = validateParameter(valid_775177, JString, required = false,
                                 default = nil)
  if valid_775177 != nil:
    section.add "X-Amz-Signature", valid_775177
  var valid_775178 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_775178 = validateParameter(valid_775178, JString, required = false,
                                 default = nil)
  if valid_775178 != nil:
    section.add "X-Amz-SignedHeaders", valid_775178
  var valid_775179 = header.getOrDefault("X-Amz-Credential")
  valid_775179 = validateParameter(valid_775179, JString, required = false,
                                 default = nil)
  if valid_775179 != nil:
    section.add "X-Amz-Credential", valid_775179
  result.add "header", section
  ## parameters in `formData` object:
  ##   Marker: JString
  ##         : A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned marker value in the <code>marker</code> parameter and retrying the command. If the <code>marker</code> field is empty, all response records have been retrieved for the request.
  ##   ClusterIdentifier: JString
  ##                    : The unique identifier for the cluster whose snapshot schedules you want to view.
  ##   ScheduleIdentifier: JString
  ##                     : A unique identifier for a snapshot schedule.
  ##   TagKeys: JArray
  ##          : The key value for a snapshot schedule tag.
  ##   MaxRecords: JInt
  ##             : The maximum number or response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned <code>marker</code> value.
  ##   TagValues: JArray
  ##            : The value corresponding to the key of the snapshot schedule tag.
  section = newJObject()
  var valid_775180 = formData.getOrDefault("Marker")
  valid_775180 = validateParameter(valid_775180, JString, required = false,
                                 default = nil)
  if valid_775180 != nil:
    section.add "Marker", valid_775180
  var valid_775181 = formData.getOrDefault("ClusterIdentifier")
  valid_775181 = validateParameter(valid_775181, JString, required = false,
                                 default = nil)
  if valid_775181 != nil:
    section.add "ClusterIdentifier", valid_775181
  var valid_775182 = formData.getOrDefault("ScheduleIdentifier")
  valid_775182 = validateParameter(valid_775182, JString, required = false,
                                 default = nil)
  if valid_775182 != nil:
    section.add "ScheduleIdentifier", valid_775182
  var valid_775183 = formData.getOrDefault("TagKeys")
  valid_775183 = validateParameter(valid_775183, JArray, required = false,
                                 default = nil)
  if valid_775183 != nil:
    section.add "TagKeys", valid_775183
  var valid_775184 = formData.getOrDefault("MaxRecords")
  valid_775184 = validateParameter(valid_775184, JInt, required = false, default = nil)
  if valid_775184 != nil:
    section.add "MaxRecords", valid_775184
  var valid_775185 = formData.getOrDefault("TagValues")
  valid_775185 = validateParameter(valid_775185, JArray, required = false,
                                 default = nil)
  if valid_775185 != nil:
    section.add "TagValues", valid_775185
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_775186: Call_PostDescribeSnapshotSchedules_775168; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns a list of snapshot schedules. 
  ## 
  let valid = call_775186.validator(path, query, header, formData, body)
  let scheme = call_775186.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_775186.url(scheme.get, call_775186.host, call_775186.base,
                         call_775186.route, valid.getOrDefault("path"))
  result = hook(call_775186, url, valid)

proc call*(call_775187: Call_PostDescribeSnapshotSchedules_775168;
          Marker: string = ""; Action: string = "DescribeSnapshotSchedules";
          ClusterIdentifier: string = ""; ScheduleIdentifier: string = "";
          TagKeys: JsonNode = nil; MaxRecords: int = 0; TagValues: JsonNode = nil;
          Version: string = "2012-12-01"): Recallable =
  ## postDescribeSnapshotSchedules
  ## Returns a list of snapshot schedules. 
  ##   Marker: string
  ##         : A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned marker value in the <code>marker</code> parameter and retrying the command. If the <code>marker</code> field is empty, all response records have been retrieved for the request.
  ##   Action: string (required)
  ##   ClusterIdentifier: string
  ##                    : The unique identifier for the cluster whose snapshot schedules you want to view.
  ##   ScheduleIdentifier: string
  ##                     : A unique identifier for a snapshot schedule.
  ##   TagKeys: JArray
  ##          : The key value for a snapshot schedule tag.
  ##   MaxRecords: int
  ##             : The maximum number or response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned <code>marker</code> value.
  ##   TagValues: JArray
  ##            : The value corresponding to the key of the snapshot schedule tag.
  ##   Version: string (required)
  var query_775188 = newJObject()
  var formData_775189 = newJObject()
  add(formData_775189, "Marker", newJString(Marker))
  add(query_775188, "Action", newJString(Action))
  add(formData_775189, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_775189, "ScheduleIdentifier", newJString(ScheduleIdentifier))
  if TagKeys != nil:
    formData_775189.add "TagKeys", TagKeys
  add(formData_775189, "MaxRecords", newJInt(MaxRecords))
  if TagValues != nil:
    formData_775189.add "TagValues", TagValues
  add(query_775188, "Version", newJString(Version))
  result = call_775187.call(nil, query_775188, nil, formData_775189, nil)

var postDescribeSnapshotSchedules* = Call_PostDescribeSnapshotSchedules_775168(
    name: "postDescribeSnapshotSchedules", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeSnapshotSchedules",
    validator: validate_PostDescribeSnapshotSchedules_775169, base: "/",
    url: url_PostDescribeSnapshotSchedules_775170,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeSnapshotSchedules_775147 = ref object of OpenApiRestCall_772581
proc url_GetDescribeSnapshotSchedules_775149(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_GetDescribeSnapshotSchedules_775148(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns a list of snapshot schedules. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   TagValues: JArray
  ##            : The value corresponding to the key of the snapshot schedule tag.
  ##   MaxRecords: JInt
  ##             : The maximum number or response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned <code>marker</code> value.
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString
  ##                    : The unique identifier for the cluster whose snapshot schedules you want to view.
  ##   ScheduleIdentifier: JString
  ##                     : A unique identifier for a snapshot schedule.
  ##   Marker: JString
  ##         : A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned marker value in the <code>marker</code> parameter and retrying the command. If the <code>marker</code> field is empty, all response records have been retrieved for the request.
  ##   TagKeys: JArray
  ##          : The key value for a snapshot schedule tag.
  ##   Version: JString (required)
  section = newJObject()
  var valid_775150 = query.getOrDefault("TagValues")
  valid_775150 = validateParameter(valid_775150, JArray, required = false,
                                 default = nil)
  if valid_775150 != nil:
    section.add "TagValues", valid_775150
  var valid_775151 = query.getOrDefault("MaxRecords")
  valid_775151 = validateParameter(valid_775151, JInt, required = false, default = nil)
  if valid_775151 != nil:
    section.add "MaxRecords", valid_775151
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_775152 = query.getOrDefault("Action")
  valid_775152 = validateParameter(valid_775152, JString, required = true, default = newJString(
      "DescribeSnapshotSchedules"))
  if valid_775152 != nil:
    section.add "Action", valid_775152
  var valid_775153 = query.getOrDefault("ClusterIdentifier")
  valid_775153 = validateParameter(valid_775153, JString, required = false,
                                 default = nil)
  if valid_775153 != nil:
    section.add "ClusterIdentifier", valid_775153
  var valid_775154 = query.getOrDefault("ScheduleIdentifier")
  valid_775154 = validateParameter(valid_775154, JString, required = false,
                                 default = nil)
  if valid_775154 != nil:
    section.add "ScheduleIdentifier", valid_775154
  var valid_775155 = query.getOrDefault("Marker")
  valid_775155 = validateParameter(valid_775155, JString, required = false,
                                 default = nil)
  if valid_775155 != nil:
    section.add "Marker", valid_775155
  var valid_775156 = query.getOrDefault("TagKeys")
  valid_775156 = validateParameter(valid_775156, JArray, required = false,
                                 default = nil)
  if valid_775156 != nil:
    section.add "TagKeys", valid_775156
  var valid_775157 = query.getOrDefault("Version")
  valid_775157 = validateParameter(valid_775157, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_775157 != nil:
    section.add "Version", valid_775157
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_775158 = header.getOrDefault("X-Amz-Date")
  valid_775158 = validateParameter(valid_775158, JString, required = false,
                                 default = nil)
  if valid_775158 != nil:
    section.add "X-Amz-Date", valid_775158
  var valid_775159 = header.getOrDefault("X-Amz-Security-Token")
  valid_775159 = validateParameter(valid_775159, JString, required = false,
                                 default = nil)
  if valid_775159 != nil:
    section.add "X-Amz-Security-Token", valid_775159
  var valid_775160 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_775160 = validateParameter(valid_775160, JString, required = false,
                                 default = nil)
  if valid_775160 != nil:
    section.add "X-Amz-Content-Sha256", valid_775160
  var valid_775161 = header.getOrDefault("X-Amz-Algorithm")
  valid_775161 = validateParameter(valid_775161, JString, required = false,
                                 default = nil)
  if valid_775161 != nil:
    section.add "X-Amz-Algorithm", valid_775161
  var valid_775162 = header.getOrDefault("X-Amz-Signature")
  valid_775162 = validateParameter(valid_775162, JString, required = false,
                                 default = nil)
  if valid_775162 != nil:
    section.add "X-Amz-Signature", valid_775162
  var valid_775163 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_775163 = validateParameter(valid_775163, JString, required = false,
                                 default = nil)
  if valid_775163 != nil:
    section.add "X-Amz-SignedHeaders", valid_775163
  var valid_775164 = header.getOrDefault("X-Amz-Credential")
  valid_775164 = validateParameter(valid_775164, JString, required = false,
                                 default = nil)
  if valid_775164 != nil:
    section.add "X-Amz-Credential", valid_775164
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_775165: Call_GetDescribeSnapshotSchedules_775147; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns a list of snapshot schedules. 
  ## 
  let valid = call_775165.validator(path, query, header, formData, body)
  let scheme = call_775165.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_775165.url(scheme.get, call_775165.host, call_775165.base,
                         call_775165.route, valid.getOrDefault("path"))
  result = hook(call_775165, url, valid)

proc call*(call_775166: Call_GetDescribeSnapshotSchedules_775147;
          TagValues: JsonNode = nil; MaxRecords: int = 0;
          Action: string = "DescribeSnapshotSchedules";
          ClusterIdentifier: string = ""; ScheduleIdentifier: string = "";
          Marker: string = ""; TagKeys: JsonNode = nil; Version: string = "2012-12-01"): Recallable =
  ## getDescribeSnapshotSchedules
  ## Returns a list of snapshot schedules. 
  ##   TagValues: JArray
  ##            : The value corresponding to the key of the snapshot schedule tag.
  ##   MaxRecords: int
  ##             : The maximum number or response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned <code>marker</code> value.
  ##   Action: string (required)
  ##   ClusterIdentifier: string
  ##                    : The unique identifier for the cluster whose snapshot schedules you want to view.
  ##   ScheduleIdentifier: string
  ##                     : A unique identifier for a snapshot schedule.
  ##   Marker: string
  ##         : A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned marker value in the <code>marker</code> parameter and retrying the command. If the <code>marker</code> field is empty, all response records have been retrieved for the request.
  ##   TagKeys: JArray
  ##          : The key value for a snapshot schedule tag.
  ##   Version: string (required)
  var query_775167 = newJObject()
  if TagValues != nil:
    query_775167.add "TagValues", TagValues
  add(query_775167, "MaxRecords", newJInt(MaxRecords))
  add(query_775167, "Action", newJString(Action))
  add(query_775167, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_775167, "ScheduleIdentifier", newJString(ScheduleIdentifier))
  add(query_775167, "Marker", newJString(Marker))
  if TagKeys != nil:
    query_775167.add "TagKeys", TagKeys
  add(query_775167, "Version", newJString(Version))
  result = call_775166.call(nil, query_775167, nil, nil, nil)

var getDescribeSnapshotSchedules* = Call_GetDescribeSnapshotSchedules_775147(
    name: "getDescribeSnapshotSchedules", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeSnapshotSchedules",
    validator: validate_GetDescribeSnapshotSchedules_775148, base: "/",
    url: url_GetDescribeSnapshotSchedules_775149,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeStorage_775205 = ref object of OpenApiRestCall_772581
proc url_PostDescribeStorage_775207(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_PostDescribeStorage_775206(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Returns the total amount of snapshot usage and provisioned storage in megabytes.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_775208 = query.getOrDefault("Action")
  valid_775208 = validateParameter(valid_775208, JString, required = true,
                                 default = newJString("DescribeStorage"))
  if valid_775208 != nil:
    section.add "Action", valid_775208
  var valid_775209 = query.getOrDefault("Version")
  valid_775209 = validateParameter(valid_775209, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_775209 != nil:
    section.add "Version", valid_775209
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_775210 = header.getOrDefault("X-Amz-Date")
  valid_775210 = validateParameter(valid_775210, JString, required = false,
                                 default = nil)
  if valid_775210 != nil:
    section.add "X-Amz-Date", valid_775210
  var valid_775211 = header.getOrDefault("X-Amz-Security-Token")
  valid_775211 = validateParameter(valid_775211, JString, required = false,
                                 default = nil)
  if valid_775211 != nil:
    section.add "X-Amz-Security-Token", valid_775211
  var valid_775212 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_775212 = validateParameter(valid_775212, JString, required = false,
                                 default = nil)
  if valid_775212 != nil:
    section.add "X-Amz-Content-Sha256", valid_775212
  var valid_775213 = header.getOrDefault("X-Amz-Algorithm")
  valid_775213 = validateParameter(valid_775213, JString, required = false,
                                 default = nil)
  if valid_775213 != nil:
    section.add "X-Amz-Algorithm", valid_775213
  var valid_775214 = header.getOrDefault("X-Amz-Signature")
  valid_775214 = validateParameter(valid_775214, JString, required = false,
                                 default = nil)
  if valid_775214 != nil:
    section.add "X-Amz-Signature", valid_775214
  var valid_775215 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_775215 = validateParameter(valid_775215, JString, required = false,
                                 default = nil)
  if valid_775215 != nil:
    section.add "X-Amz-SignedHeaders", valid_775215
  var valid_775216 = header.getOrDefault("X-Amz-Credential")
  valid_775216 = validateParameter(valid_775216, JString, required = false,
                                 default = nil)
  if valid_775216 != nil:
    section.add "X-Amz-Credential", valid_775216
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_775217: Call_PostDescribeStorage_775205; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns the total amount of snapshot usage and provisioned storage in megabytes.
  ## 
  let valid = call_775217.validator(path, query, header, formData, body)
  let scheme = call_775217.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_775217.url(scheme.get, call_775217.host, call_775217.base,
                         call_775217.route, valid.getOrDefault("path"))
  result = hook(call_775217, url, valid)

proc call*(call_775218: Call_PostDescribeStorage_775205;
          Action: string = "DescribeStorage"; Version: string = "2012-12-01"): Recallable =
  ## postDescribeStorage
  ## Returns the total amount of snapshot usage and provisioned storage in megabytes.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_775219 = newJObject()
  add(query_775219, "Action", newJString(Action))
  add(query_775219, "Version", newJString(Version))
  result = call_775218.call(nil, query_775219, nil, nil, nil)

var postDescribeStorage* = Call_PostDescribeStorage_775205(
    name: "postDescribeStorage", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeStorage",
    validator: validate_PostDescribeStorage_775206, base: "/",
    url: url_PostDescribeStorage_775207, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeStorage_775190 = ref object of OpenApiRestCall_772581
proc url_GetDescribeStorage_775192(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_GetDescribeStorage_775191(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Returns the total amount of snapshot usage and provisioned storage in megabytes.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_775193 = query.getOrDefault("Action")
  valid_775193 = validateParameter(valid_775193, JString, required = true,
                                 default = newJString("DescribeStorage"))
  if valid_775193 != nil:
    section.add "Action", valid_775193
  var valid_775194 = query.getOrDefault("Version")
  valid_775194 = validateParameter(valid_775194, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_775194 != nil:
    section.add "Version", valid_775194
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_775195 = header.getOrDefault("X-Amz-Date")
  valid_775195 = validateParameter(valid_775195, JString, required = false,
                                 default = nil)
  if valid_775195 != nil:
    section.add "X-Amz-Date", valid_775195
  var valid_775196 = header.getOrDefault("X-Amz-Security-Token")
  valid_775196 = validateParameter(valid_775196, JString, required = false,
                                 default = nil)
  if valid_775196 != nil:
    section.add "X-Amz-Security-Token", valid_775196
  var valid_775197 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_775197 = validateParameter(valid_775197, JString, required = false,
                                 default = nil)
  if valid_775197 != nil:
    section.add "X-Amz-Content-Sha256", valid_775197
  var valid_775198 = header.getOrDefault("X-Amz-Algorithm")
  valid_775198 = validateParameter(valid_775198, JString, required = false,
                                 default = nil)
  if valid_775198 != nil:
    section.add "X-Amz-Algorithm", valid_775198
  var valid_775199 = header.getOrDefault("X-Amz-Signature")
  valid_775199 = validateParameter(valid_775199, JString, required = false,
                                 default = nil)
  if valid_775199 != nil:
    section.add "X-Amz-Signature", valid_775199
  var valid_775200 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_775200 = validateParameter(valid_775200, JString, required = false,
                                 default = nil)
  if valid_775200 != nil:
    section.add "X-Amz-SignedHeaders", valid_775200
  var valid_775201 = header.getOrDefault("X-Amz-Credential")
  valid_775201 = validateParameter(valid_775201, JString, required = false,
                                 default = nil)
  if valid_775201 != nil:
    section.add "X-Amz-Credential", valid_775201
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_775202: Call_GetDescribeStorage_775190; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns the total amount of snapshot usage and provisioned storage in megabytes.
  ## 
  let valid = call_775202.validator(path, query, header, formData, body)
  let scheme = call_775202.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_775202.url(scheme.get, call_775202.host, call_775202.base,
                         call_775202.route, valid.getOrDefault("path"))
  result = hook(call_775202, url, valid)

proc call*(call_775203: Call_GetDescribeStorage_775190;
          Action: string = "DescribeStorage"; Version: string = "2012-12-01"): Recallable =
  ## getDescribeStorage
  ## Returns the total amount of snapshot usage and provisioned storage in megabytes.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_775204 = newJObject()
  add(query_775204, "Action", newJString(Action))
  add(query_775204, "Version", newJString(Version))
  result = call_775203.call(nil, query_775204, nil, nil, nil)

var getDescribeStorage* = Call_GetDescribeStorage_775190(
    name: "getDescribeStorage", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeStorage",
    validator: validate_GetDescribeStorage_775191, base: "/",
    url: url_GetDescribeStorage_775192, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeTableRestoreStatus_775239 = ref object of OpenApiRestCall_772581
proc url_PostDescribeTableRestoreStatus_775241(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_PostDescribeTableRestoreStatus_775240(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists the status of one or more table restore requests made using the <a>RestoreTableFromClusterSnapshot</a> API action. If you don't specify a value for the <code>TableRestoreRequestId</code> parameter, then <code>DescribeTableRestoreStatus</code> returns the status of all table restore requests ordered by the date and time of the request in ascending order. Otherwise <code>DescribeTableRestoreStatus</code> returns the status of the table specified by <code>TableRestoreRequestId</code>.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_775242 = query.getOrDefault("Action")
  valid_775242 = validateParameter(valid_775242, JString, required = true, default = newJString(
      "DescribeTableRestoreStatus"))
  if valid_775242 != nil:
    section.add "Action", valid_775242
  var valid_775243 = query.getOrDefault("Version")
  valid_775243 = validateParameter(valid_775243, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_775243 != nil:
    section.add "Version", valid_775243
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_775244 = header.getOrDefault("X-Amz-Date")
  valid_775244 = validateParameter(valid_775244, JString, required = false,
                                 default = nil)
  if valid_775244 != nil:
    section.add "X-Amz-Date", valid_775244
  var valid_775245 = header.getOrDefault("X-Amz-Security-Token")
  valid_775245 = validateParameter(valid_775245, JString, required = false,
                                 default = nil)
  if valid_775245 != nil:
    section.add "X-Amz-Security-Token", valid_775245
  var valid_775246 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_775246 = validateParameter(valid_775246, JString, required = false,
                                 default = nil)
  if valid_775246 != nil:
    section.add "X-Amz-Content-Sha256", valid_775246
  var valid_775247 = header.getOrDefault("X-Amz-Algorithm")
  valid_775247 = validateParameter(valid_775247, JString, required = false,
                                 default = nil)
  if valid_775247 != nil:
    section.add "X-Amz-Algorithm", valid_775247
  var valid_775248 = header.getOrDefault("X-Amz-Signature")
  valid_775248 = validateParameter(valid_775248, JString, required = false,
                                 default = nil)
  if valid_775248 != nil:
    section.add "X-Amz-Signature", valid_775248
  var valid_775249 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_775249 = validateParameter(valid_775249, JString, required = false,
                                 default = nil)
  if valid_775249 != nil:
    section.add "X-Amz-SignedHeaders", valid_775249
  var valid_775250 = header.getOrDefault("X-Amz-Credential")
  valid_775250 = validateParameter(valid_775250, JString, required = false,
                                 default = nil)
  if valid_775250 != nil:
    section.add "X-Amz-Credential", valid_775250
  result.add "header", section
  ## parameters in `formData` object:
  ##   TableRestoreRequestId: JString
  ##                        : The identifier of the table restore request to return status for. If you don't specify a <code>TableRestoreRequestId</code> value, then <code>DescribeTableRestoreStatus</code> returns the status of all in-progress table restore requests.
  ##   Marker: JString
  ##         : An optional pagination token provided by a previous <code>DescribeTableRestoreStatus</code> request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by the <code>MaxRecords</code> parameter.
  ##   ClusterIdentifier: JString
  ##                    : The Amazon Redshift cluster that the table is being restored to.
  ##   MaxRecords: JInt
  ##             : The maximum number of records to include in the response. If more records exist than the specified <code>MaxRecords</code> value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.
  section = newJObject()
  var valid_775251 = formData.getOrDefault("TableRestoreRequestId")
  valid_775251 = validateParameter(valid_775251, JString, required = false,
                                 default = nil)
  if valid_775251 != nil:
    section.add "TableRestoreRequestId", valid_775251
  var valid_775252 = formData.getOrDefault("Marker")
  valid_775252 = validateParameter(valid_775252, JString, required = false,
                                 default = nil)
  if valid_775252 != nil:
    section.add "Marker", valid_775252
  var valid_775253 = formData.getOrDefault("ClusterIdentifier")
  valid_775253 = validateParameter(valid_775253, JString, required = false,
                                 default = nil)
  if valid_775253 != nil:
    section.add "ClusterIdentifier", valid_775253
  var valid_775254 = formData.getOrDefault("MaxRecords")
  valid_775254 = validateParameter(valid_775254, JInt, required = false, default = nil)
  if valid_775254 != nil:
    section.add "MaxRecords", valid_775254
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_775255: Call_PostDescribeTableRestoreStatus_775239; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the status of one or more table restore requests made using the <a>RestoreTableFromClusterSnapshot</a> API action. If you don't specify a value for the <code>TableRestoreRequestId</code> parameter, then <code>DescribeTableRestoreStatus</code> returns the status of all table restore requests ordered by the date and time of the request in ascending order. Otherwise <code>DescribeTableRestoreStatus</code> returns the status of the table specified by <code>TableRestoreRequestId</code>.
  ## 
  let valid = call_775255.validator(path, query, header, formData, body)
  let scheme = call_775255.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_775255.url(scheme.get, call_775255.host, call_775255.base,
                         call_775255.route, valid.getOrDefault("path"))
  result = hook(call_775255, url, valid)

proc call*(call_775256: Call_PostDescribeTableRestoreStatus_775239;
          TableRestoreRequestId: string = ""; Marker: string = "";
          Action: string = "DescribeTableRestoreStatus";
          ClusterIdentifier: string = ""; MaxRecords: int = 0;
          Version: string = "2012-12-01"): Recallable =
  ## postDescribeTableRestoreStatus
  ## Lists the status of one or more table restore requests made using the <a>RestoreTableFromClusterSnapshot</a> API action. If you don't specify a value for the <code>TableRestoreRequestId</code> parameter, then <code>DescribeTableRestoreStatus</code> returns the status of all table restore requests ordered by the date and time of the request in ascending order. Otherwise <code>DescribeTableRestoreStatus</code> returns the status of the table specified by <code>TableRestoreRequestId</code>.
  ##   TableRestoreRequestId: string
  ##                        : The identifier of the table restore request to return status for. If you don't specify a <code>TableRestoreRequestId</code> value, then <code>DescribeTableRestoreStatus</code> returns the status of all in-progress table restore requests.
  ##   Marker: string
  ##         : An optional pagination token provided by a previous <code>DescribeTableRestoreStatus</code> request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by the <code>MaxRecords</code> parameter.
  ##   Action: string (required)
  ##   ClusterIdentifier: string
  ##                    : The Amazon Redshift cluster that the table is being restored to.
  ##   MaxRecords: int
  ##             : The maximum number of records to include in the response. If more records exist than the specified <code>MaxRecords</code> value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.
  ##   Version: string (required)
  var query_775257 = newJObject()
  var formData_775258 = newJObject()
  add(formData_775258, "TableRestoreRequestId", newJString(TableRestoreRequestId))
  add(formData_775258, "Marker", newJString(Marker))
  add(query_775257, "Action", newJString(Action))
  add(formData_775258, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_775258, "MaxRecords", newJInt(MaxRecords))
  add(query_775257, "Version", newJString(Version))
  result = call_775256.call(nil, query_775257, nil, formData_775258, nil)

var postDescribeTableRestoreStatus* = Call_PostDescribeTableRestoreStatus_775239(
    name: "postDescribeTableRestoreStatus", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeTableRestoreStatus",
    validator: validate_PostDescribeTableRestoreStatus_775240, base: "/",
    url: url_PostDescribeTableRestoreStatus_775241,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeTableRestoreStatus_775220 = ref object of OpenApiRestCall_772581
proc url_GetDescribeTableRestoreStatus_775222(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_GetDescribeTableRestoreStatus_775221(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists the status of one or more table restore requests made using the <a>RestoreTableFromClusterSnapshot</a> API action. If you don't specify a value for the <code>TableRestoreRequestId</code> parameter, then <code>DescribeTableRestoreStatus</code> returns the status of all table restore requests ordered by the date and time of the request in ascending order. Otherwise <code>DescribeTableRestoreStatus</code> returns the status of the table specified by <code>TableRestoreRequestId</code>.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   MaxRecords: JInt
  ##             : The maximum number of records to include in the response. If more records exist than the specified <code>MaxRecords</code> value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString
  ##                    : The Amazon Redshift cluster that the table is being restored to.
  ##   Marker: JString
  ##         : An optional pagination token provided by a previous <code>DescribeTableRestoreStatus</code> request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by the <code>MaxRecords</code> parameter.
  ##   Version: JString (required)
  ##   TableRestoreRequestId: JString
  ##                        : The identifier of the table restore request to return status for. If you don't specify a <code>TableRestoreRequestId</code> value, then <code>DescribeTableRestoreStatus</code> returns the status of all in-progress table restore requests.
  section = newJObject()
  var valid_775223 = query.getOrDefault("MaxRecords")
  valid_775223 = validateParameter(valid_775223, JInt, required = false, default = nil)
  if valid_775223 != nil:
    section.add "MaxRecords", valid_775223
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_775224 = query.getOrDefault("Action")
  valid_775224 = validateParameter(valid_775224, JString, required = true, default = newJString(
      "DescribeTableRestoreStatus"))
  if valid_775224 != nil:
    section.add "Action", valid_775224
  var valid_775225 = query.getOrDefault("ClusterIdentifier")
  valid_775225 = validateParameter(valid_775225, JString, required = false,
                                 default = nil)
  if valid_775225 != nil:
    section.add "ClusterIdentifier", valid_775225
  var valid_775226 = query.getOrDefault("Marker")
  valid_775226 = validateParameter(valid_775226, JString, required = false,
                                 default = nil)
  if valid_775226 != nil:
    section.add "Marker", valid_775226
  var valid_775227 = query.getOrDefault("Version")
  valid_775227 = validateParameter(valid_775227, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_775227 != nil:
    section.add "Version", valid_775227
  var valid_775228 = query.getOrDefault("TableRestoreRequestId")
  valid_775228 = validateParameter(valid_775228, JString, required = false,
                                 default = nil)
  if valid_775228 != nil:
    section.add "TableRestoreRequestId", valid_775228
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_775229 = header.getOrDefault("X-Amz-Date")
  valid_775229 = validateParameter(valid_775229, JString, required = false,
                                 default = nil)
  if valid_775229 != nil:
    section.add "X-Amz-Date", valid_775229
  var valid_775230 = header.getOrDefault("X-Amz-Security-Token")
  valid_775230 = validateParameter(valid_775230, JString, required = false,
                                 default = nil)
  if valid_775230 != nil:
    section.add "X-Amz-Security-Token", valid_775230
  var valid_775231 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_775231 = validateParameter(valid_775231, JString, required = false,
                                 default = nil)
  if valid_775231 != nil:
    section.add "X-Amz-Content-Sha256", valid_775231
  var valid_775232 = header.getOrDefault("X-Amz-Algorithm")
  valid_775232 = validateParameter(valid_775232, JString, required = false,
                                 default = nil)
  if valid_775232 != nil:
    section.add "X-Amz-Algorithm", valid_775232
  var valid_775233 = header.getOrDefault("X-Amz-Signature")
  valid_775233 = validateParameter(valid_775233, JString, required = false,
                                 default = nil)
  if valid_775233 != nil:
    section.add "X-Amz-Signature", valid_775233
  var valid_775234 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_775234 = validateParameter(valid_775234, JString, required = false,
                                 default = nil)
  if valid_775234 != nil:
    section.add "X-Amz-SignedHeaders", valid_775234
  var valid_775235 = header.getOrDefault("X-Amz-Credential")
  valid_775235 = validateParameter(valid_775235, JString, required = false,
                                 default = nil)
  if valid_775235 != nil:
    section.add "X-Amz-Credential", valid_775235
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_775236: Call_GetDescribeTableRestoreStatus_775220; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the status of one or more table restore requests made using the <a>RestoreTableFromClusterSnapshot</a> API action. If you don't specify a value for the <code>TableRestoreRequestId</code> parameter, then <code>DescribeTableRestoreStatus</code> returns the status of all table restore requests ordered by the date and time of the request in ascending order. Otherwise <code>DescribeTableRestoreStatus</code> returns the status of the table specified by <code>TableRestoreRequestId</code>.
  ## 
  let valid = call_775236.validator(path, query, header, formData, body)
  let scheme = call_775236.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_775236.url(scheme.get, call_775236.host, call_775236.base,
                         call_775236.route, valid.getOrDefault("path"))
  result = hook(call_775236, url, valid)

proc call*(call_775237: Call_GetDescribeTableRestoreStatus_775220;
          MaxRecords: int = 0; Action: string = "DescribeTableRestoreStatus";
          ClusterIdentifier: string = ""; Marker: string = "";
          Version: string = "2012-12-01"; TableRestoreRequestId: string = ""): Recallable =
  ## getDescribeTableRestoreStatus
  ## Lists the status of one or more table restore requests made using the <a>RestoreTableFromClusterSnapshot</a> API action. If you don't specify a value for the <code>TableRestoreRequestId</code> parameter, then <code>DescribeTableRestoreStatus</code> returns the status of all table restore requests ordered by the date and time of the request in ascending order. Otherwise <code>DescribeTableRestoreStatus</code> returns the status of the table specified by <code>TableRestoreRequestId</code>.
  ##   MaxRecords: int
  ##             : The maximum number of records to include in the response. If more records exist than the specified <code>MaxRecords</code> value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.
  ##   Action: string (required)
  ##   ClusterIdentifier: string
  ##                    : The Amazon Redshift cluster that the table is being restored to.
  ##   Marker: string
  ##         : An optional pagination token provided by a previous <code>DescribeTableRestoreStatus</code> request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by the <code>MaxRecords</code> parameter.
  ##   Version: string (required)
  ##   TableRestoreRequestId: string
  ##                        : The identifier of the table restore request to return status for. If you don't specify a <code>TableRestoreRequestId</code> value, then <code>DescribeTableRestoreStatus</code> returns the status of all in-progress table restore requests.
  var query_775238 = newJObject()
  add(query_775238, "MaxRecords", newJInt(MaxRecords))
  add(query_775238, "Action", newJString(Action))
  add(query_775238, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_775238, "Marker", newJString(Marker))
  add(query_775238, "Version", newJString(Version))
  add(query_775238, "TableRestoreRequestId", newJString(TableRestoreRequestId))
  result = call_775237.call(nil, query_775238, nil, nil, nil)

var getDescribeTableRestoreStatus* = Call_GetDescribeTableRestoreStatus_775220(
    name: "getDescribeTableRestoreStatus", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeTableRestoreStatus",
    validator: validate_GetDescribeTableRestoreStatus_775221, base: "/",
    url: url_GetDescribeTableRestoreStatus_775222,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeTags_775280 = ref object of OpenApiRestCall_772581
proc url_PostDescribeTags_775282(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_PostDescribeTags_775281(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## <p>Returns a list of tags. You can return tags from a specific resource by specifying an ARN, or you can return all tags for a given type of resource, such as clusters, snapshots, and so on.</p> <p>The following are limitations for <code>DescribeTags</code>: </p> <ul> <li> <p>You cannot specify an ARN and a resource-type value together in the same request.</p> </li> <li> <p>You cannot use the <code>MaxRecords</code> and <code>Marker</code> parameters together with the ARN parameter.</p> </li> <li> <p>The <code>MaxRecords</code> parameter can be a range from 10 to 50 results to return in a request.</p> </li> </ul> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all resources that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all resources that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, resources are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_775283 = query.getOrDefault("Action")
  valid_775283 = validateParameter(valid_775283, JString, required = true,
                                 default = newJString("DescribeTags"))
  if valid_775283 != nil:
    section.add "Action", valid_775283
  var valid_775284 = query.getOrDefault("Version")
  valid_775284 = validateParameter(valid_775284, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_775284 != nil:
    section.add "Version", valid_775284
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_775285 = header.getOrDefault("X-Amz-Date")
  valid_775285 = validateParameter(valid_775285, JString, required = false,
                                 default = nil)
  if valid_775285 != nil:
    section.add "X-Amz-Date", valid_775285
  var valid_775286 = header.getOrDefault("X-Amz-Security-Token")
  valid_775286 = validateParameter(valid_775286, JString, required = false,
                                 default = nil)
  if valid_775286 != nil:
    section.add "X-Amz-Security-Token", valid_775286
  var valid_775287 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_775287 = validateParameter(valid_775287, JString, required = false,
                                 default = nil)
  if valid_775287 != nil:
    section.add "X-Amz-Content-Sha256", valid_775287
  var valid_775288 = header.getOrDefault("X-Amz-Algorithm")
  valid_775288 = validateParameter(valid_775288, JString, required = false,
                                 default = nil)
  if valid_775288 != nil:
    section.add "X-Amz-Algorithm", valid_775288
  var valid_775289 = header.getOrDefault("X-Amz-Signature")
  valid_775289 = validateParameter(valid_775289, JString, required = false,
                                 default = nil)
  if valid_775289 != nil:
    section.add "X-Amz-Signature", valid_775289
  var valid_775290 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_775290 = validateParameter(valid_775290, JString, required = false,
                                 default = nil)
  if valid_775290 != nil:
    section.add "X-Amz-SignedHeaders", valid_775290
  var valid_775291 = header.getOrDefault("X-Amz-Credential")
  valid_775291 = validateParameter(valid_775291, JString, required = false,
                                 default = nil)
  if valid_775291 != nil:
    section.add "X-Amz-Credential", valid_775291
  result.add "header", section
  ## parameters in `formData` object:
  ##   Marker: JString
  ##         : A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned marker value in the <code>marker</code> parameter and retrying the command. If the <code>marker</code> field is empty, all response records have been retrieved for the request. 
  ##   ResourceType: JString
  ##               : <p>The type of resource with which you want to view tags. Valid resource types are: </p> <ul> <li> <p>Cluster</p> </li> <li> <p>CIDR/IP</p> </li> <li> <p>EC2 security group</p> </li> <li> <p>Snapshot</p> </li> <li> <p>Cluster security group</p> </li> <li> <p>Subnet group</p> </li> <li> <p>HSM connection</p> </li> <li> <p>HSM certificate</p> </li> <li> <p>Parameter group</p> </li> <li> <p>Snapshot copy grant</p> </li> </ul> <p>For more information about Amazon Redshift resource types and constructing ARNs, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-overview.html#redshift-iam-access-control-specify-actions">Specifying Policy Elements: Actions, Effects, Resources, and Principals</a> in the Amazon Redshift Cluster Management Guide. </p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching resources that are associated with the specified key or keys. For example, suppose that you have resources tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with all resources that have either or both of these tag keys associated with them.
  ##   ResourceName: JString
  ##               : The Amazon Resource Name (ARN) for which you want to describe the tag or tags. For example, <code>arn:aws:redshift:us-east-1:123456789:cluster:t1</code>. 
  ##   MaxRecords: JInt
  ##             : The maximum number or response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned <code>marker</code> value. 
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching resources that are associated with the specified value or values. For example, suppose that you have resources tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with all resources that have either or both of these tag values associated with them.
  section = newJObject()
  var valid_775292 = formData.getOrDefault("Marker")
  valid_775292 = validateParameter(valid_775292, JString, required = false,
                                 default = nil)
  if valid_775292 != nil:
    section.add "Marker", valid_775292
  var valid_775293 = formData.getOrDefault("ResourceType")
  valid_775293 = validateParameter(valid_775293, JString, required = false,
                                 default = nil)
  if valid_775293 != nil:
    section.add "ResourceType", valid_775293
  var valid_775294 = formData.getOrDefault("TagKeys")
  valid_775294 = validateParameter(valid_775294, JArray, required = false,
                                 default = nil)
  if valid_775294 != nil:
    section.add "TagKeys", valid_775294
  var valid_775295 = formData.getOrDefault("ResourceName")
  valid_775295 = validateParameter(valid_775295, JString, required = false,
                                 default = nil)
  if valid_775295 != nil:
    section.add "ResourceName", valid_775295
  var valid_775296 = formData.getOrDefault("MaxRecords")
  valid_775296 = validateParameter(valid_775296, JInt, required = false, default = nil)
  if valid_775296 != nil:
    section.add "MaxRecords", valid_775296
  var valid_775297 = formData.getOrDefault("TagValues")
  valid_775297 = validateParameter(valid_775297, JArray, required = false,
                                 default = nil)
  if valid_775297 != nil:
    section.add "TagValues", valid_775297
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_775298: Call_PostDescribeTags_775280; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns a list of tags. You can return tags from a specific resource by specifying an ARN, or you can return all tags for a given type of resource, such as clusters, snapshots, and so on.</p> <p>The following are limitations for <code>DescribeTags</code>: </p> <ul> <li> <p>You cannot specify an ARN and a resource-type value together in the same request.</p> </li> <li> <p>You cannot use the <code>MaxRecords</code> and <code>Marker</code> parameters together with the ARN parameter.</p> </li> <li> <p>The <code>MaxRecords</code> parameter can be a range from 10 to 50 results to return in a request.</p> </li> </ul> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all resources that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all resources that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, resources are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_775298.validator(path, query, header, formData, body)
  let scheme = call_775298.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_775298.url(scheme.get, call_775298.host, call_775298.base,
                         call_775298.route, valid.getOrDefault("path"))
  result = hook(call_775298, url, valid)

proc call*(call_775299: Call_PostDescribeTags_775280; Marker: string = "";
          Action: string = "DescribeTags"; ResourceType: string = "";
          TagKeys: JsonNode = nil; ResourceName: string = ""; MaxRecords: int = 0;
          TagValues: JsonNode = nil; Version: string = "2012-12-01"): Recallable =
  ## postDescribeTags
  ## <p>Returns a list of tags. You can return tags from a specific resource by specifying an ARN, or you can return all tags for a given type of resource, such as clusters, snapshots, and so on.</p> <p>The following are limitations for <code>DescribeTags</code>: </p> <ul> <li> <p>You cannot specify an ARN and a resource-type value together in the same request.</p> </li> <li> <p>You cannot use the <code>MaxRecords</code> and <code>Marker</code> parameters together with the ARN parameter.</p> </li> <li> <p>The <code>MaxRecords</code> parameter can be a range from 10 to 50 results to return in a request.</p> </li> </ul> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all resources that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all resources that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, resources are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   Marker: string
  ##         : A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned marker value in the <code>marker</code> parameter and retrying the command. If the <code>marker</code> field is empty, all response records have been retrieved for the request. 
  ##   Action: string (required)
  ##   ResourceType: string
  ##               : <p>The type of resource with which you want to view tags. Valid resource types are: </p> <ul> <li> <p>Cluster</p> </li> <li> <p>CIDR/IP</p> </li> <li> <p>EC2 security group</p> </li> <li> <p>Snapshot</p> </li> <li> <p>Cluster security group</p> </li> <li> <p>Subnet group</p> </li> <li> <p>HSM connection</p> </li> <li> <p>HSM certificate</p> </li> <li> <p>Parameter group</p> </li> <li> <p>Snapshot copy grant</p> </li> </ul> <p>For more information about Amazon Redshift resource types and constructing ARNs, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-overview.html#redshift-iam-access-control-specify-actions">Specifying Policy Elements: Actions, Effects, Resources, and Principals</a> in the Amazon Redshift Cluster Management Guide. </p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching resources that are associated with the specified key or keys. For example, suppose that you have resources tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with all resources that have either or both of these tag keys associated with them.
  ##   ResourceName: string
  ##               : The Amazon Resource Name (ARN) for which you want to describe the tag or tags. For example, <code>arn:aws:redshift:us-east-1:123456789:cluster:t1</code>. 
  ##   MaxRecords: int
  ##             : The maximum number or response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned <code>marker</code> value. 
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching resources that are associated with the specified value or values. For example, suppose that you have resources tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with all resources that have either or both of these tag values associated with them.
  ##   Version: string (required)
  var query_775300 = newJObject()
  var formData_775301 = newJObject()
  add(formData_775301, "Marker", newJString(Marker))
  add(query_775300, "Action", newJString(Action))
  add(formData_775301, "ResourceType", newJString(ResourceType))
  if TagKeys != nil:
    formData_775301.add "TagKeys", TagKeys
  add(formData_775301, "ResourceName", newJString(ResourceName))
  add(formData_775301, "MaxRecords", newJInt(MaxRecords))
  if TagValues != nil:
    formData_775301.add "TagValues", TagValues
  add(query_775300, "Version", newJString(Version))
  result = call_775299.call(nil, query_775300, nil, formData_775301, nil)

var postDescribeTags* = Call_PostDescribeTags_775280(name: "postDescribeTags",
    meth: HttpMethod.HttpPost, host: "redshift.amazonaws.com",
    route: "/#Action=DescribeTags", validator: validate_PostDescribeTags_775281,
    base: "/", url: url_PostDescribeTags_775282,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeTags_775259 = ref object of OpenApiRestCall_772581
proc url_GetDescribeTags_775261(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_GetDescribeTags_775260(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## <p>Returns a list of tags. You can return tags from a specific resource by specifying an ARN, or you can return all tags for a given type of resource, such as clusters, snapshots, and so on.</p> <p>The following are limitations for <code>DescribeTags</code>: </p> <ul> <li> <p>You cannot specify an ARN and a resource-type value together in the same request.</p> </li> <li> <p>You cannot use the <code>MaxRecords</code> and <code>Marker</code> parameters together with the ARN parameter.</p> </li> <li> <p>The <code>MaxRecords</code> parameter can be a range from 10 to 50 results to return in a request.</p> </li> </ul> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all resources that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all resources that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, resources are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching resources that are associated with the specified value or values. For example, suppose that you have resources tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with all resources that have either or both of these tag values associated with them.
  ##   MaxRecords: JInt
  ##             : The maximum number or response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned <code>marker</code> value. 
  ##   ResourceName: JString
  ##               : The Amazon Resource Name (ARN) for which you want to describe the tag or tags. For example, <code>arn:aws:redshift:us-east-1:123456789:cluster:t1</code>. 
  ##   Action: JString (required)
  ##   Marker: JString
  ##         : A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned marker value in the <code>marker</code> parameter and retrying the command. If the <code>marker</code> field is empty, all response records have been retrieved for the request. 
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching resources that are associated with the specified key or keys. For example, suppose that you have resources tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with all resources that have either or both of these tag keys associated with them.
  ##   ResourceType: JString
  ##               : <p>The type of resource with which you want to view tags. Valid resource types are: </p> <ul> <li> <p>Cluster</p> </li> <li> <p>CIDR/IP</p> </li> <li> <p>EC2 security group</p> </li> <li> <p>Snapshot</p> </li> <li> <p>Cluster security group</p> </li> <li> <p>Subnet group</p> </li> <li> <p>HSM connection</p> </li> <li> <p>HSM certificate</p> </li> <li> <p>Parameter group</p> </li> <li> <p>Snapshot copy grant</p> </li> </ul> <p>For more information about Amazon Redshift resource types and constructing ARNs, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-overview.html#redshift-iam-access-control-specify-actions">Specifying Policy Elements: Actions, Effects, Resources, and Principals</a> in the Amazon Redshift Cluster Management Guide. </p>
  ##   Version: JString (required)
  section = newJObject()
  var valid_775262 = query.getOrDefault("TagValues")
  valid_775262 = validateParameter(valid_775262, JArray, required = false,
                                 default = nil)
  if valid_775262 != nil:
    section.add "TagValues", valid_775262
  var valid_775263 = query.getOrDefault("MaxRecords")
  valid_775263 = validateParameter(valid_775263, JInt, required = false, default = nil)
  if valid_775263 != nil:
    section.add "MaxRecords", valid_775263
  var valid_775264 = query.getOrDefault("ResourceName")
  valid_775264 = validateParameter(valid_775264, JString, required = false,
                                 default = nil)
  if valid_775264 != nil:
    section.add "ResourceName", valid_775264
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_775265 = query.getOrDefault("Action")
  valid_775265 = validateParameter(valid_775265, JString, required = true,
                                 default = newJString("DescribeTags"))
  if valid_775265 != nil:
    section.add "Action", valid_775265
  var valid_775266 = query.getOrDefault("Marker")
  valid_775266 = validateParameter(valid_775266, JString, required = false,
                                 default = nil)
  if valid_775266 != nil:
    section.add "Marker", valid_775266
  var valid_775267 = query.getOrDefault("TagKeys")
  valid_775267 = validateParameter(valid_775267, JArray, required = false,
                                 default = nil)
  if valid_775267 != nil:
    section.add "TagKeys", valid_775267
  var valid_775268 = query.getOrDefault("ResourceType")
  valid_775268 = validateParameter(valid_775268, JString, required = false,
                                 default = nil)
  if valid_775268 != nil:
    section.add "ResourceType", valid_775268
  var valid_775269 = query.getOrDefault("Version")
  valid_775269 = validateParameter(valid_775269, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_775269 != nil:
    section.add "Version", valid_775269
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_775270 = header.getOrDefault("X-Amz-Date")
  valid_775270 = validateParameter(valid_775270, JString, required = false,
                                 default = nil)
  if valid_775270 != nil:
    section.add "X-Amz-Date", valid_775270
  var valid_775271 = header.getOrDefault("X-Amz-Security-Token")
  valid_775271 = validateParameter(valid_775271, JString, required = false,
                                 default = nil)
  if valid_775271 != nil:
    section.add "X-Amz-Security-Token", valid_775271
  var valid_775272 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_775272 = validateParameter(valid_775272, JString, required = false,
                                 default = nil)
  if valid_775272 != nil:
    section.add "X-Amz-Content-Sha256", valid_775272
  var valid_775273 = header.getOrDefault("X-Amz-Algorithm")
  valid_775273 = validateParameter(valid_775273, JString, required = false,
                                 default = nil)
  if valid_775273 != nil:
    section.add "X-Amz-Algorithm", valid_775273
  var valid_775274 = header.getOrDefault("X-Amz-Signature")
  valid_775274 = validateParameter(valid_775274, JString, required = false,
                                 default = nil)
  if valid_775274 != nil:
    section.add "X-Amz-Signature", valid_775274
  var valid_775275 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_775275 = validateParameter(valid_775275, JString, required = false,
                                 default = nil)
  if valid_775275 != nil:
    section.add "X-Amz-SignedHeaders", valid_775275
  var valid_775276 = header.getOrDefault("X-Amz-Credential")
  valid_775276 = validateParameter(valid_775276, JString, required = false,
                                 default = nil)
  if valid_775276 != nil:
    section.add "X-Amz-Credential", valid_775276
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_775277: Call_GetDescribeTags_775259; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns a list of tags. You can return tags from a specific resource by specifying an ARN, or you can return all tags for a given type of resource, such as clusters, snapshots, and so on.</p> <p>The following are limitations for <code>DescribeTags</code>: </p> <ul> <li> <p>You cannot specify an ARN and a resource-type value together in the same request.</p> </li> <li> <p>You cannot use the <code>MaxRecords</code> and <code>Marker</code> parameters together with the ARN parameter.</p> </li> <li> <p>The <code>MaxRecords</code> parameter can be a range from 10 to 50 results to return in a request.</p> </li> </ul> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all resources that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all resources that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, resources are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_775277.validator(path, query, header, formData, body)
  let scheme = call_775277.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_775277.url(scheme.get, call_775277.host, call_775277.base,
                         call_775277.route, valid.getOrDefault("path"))
  result = hook(call_775277, url, valid)

proc call*(call_775278: Call_GetDescribeTags_775259; TagValues: JsonNode = nil;
          MaxRecords: int = 0; ResourceName: string = "";
          Action: string = "DescribeTags"; Marker: string = ""; TagKeys: JsonNode = nil;
          ResourceType: string = ""; Version: string = "2012-12-01"): Recallable =
  ## getDescribeTags
  ## <p>Returns a list of tags. You can return tags from a specific resource by specifying an ARN, or you can return all tags for a given type of resource, such as clusters, snapshots, and so on.</p> <p>The following are limitations for <code>DescribeTags</code>: </p> <ul> <li> <p>You cannot specify an ARN and a resource-type value together in the same request.</p> </li> <li> <p>You cannot use the <code>MaxRecords</code> and <code>Marker</code> parameters together with the ARN parameter.</p> </li> <li> <p>The <code>MaxRecords</code> parameter can be a range from 10 to 50 results to return in a request.</p> </li> </ul> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all resources that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all resources that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, resources are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching resources that are associated with the specified value or values. For example, suppose that you have resources tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with all resources that have either or both of these tag values associated with them.
  ##   MaxRecords: int
  ##             : The maximum number or response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned <code>marker</code> value. 
  ##   ResourceName: string
  ##               : The Amazon Resource Name (ARN) for which you want to describe the tag or tags. For example, <code>arn:aws:redshift:us-east-1:123456789:cluster:t1</code>. 
  ##   Action: string (required)
  ##   Marker: string
  ##         : A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned marker value in the <code>marker</code> parameter and retrying the command. If the <code>marker</code> field is empty, all response records have been retrieved for the request. 
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching resources that are associated with the specified key or keys. For example, suppose that you have resources tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with all resources that have either or both of these tag keys associated with them.
  ##   ResourceType: string
  ##               : <p>The type of resource with which you want to view tags. Valid resource types are: </p> <ul> <li> <p>Cluster</p> </li> <li> <p>CIDR/IP</p> </li> <li> <p>EC2 security group</p> </li> <li> <p>Snapshot</p> </li> <li> <p>Cluster security group</p> </li> <li> <p>Subnet group</p> </li> <li> <p>HSM connection</p> </li> <li> <p>HSM certificate</p> </li> <li> <p>Parameter group</p> </li> <li> <p>Snapshot copy grant</p> </li> </ul> <p>For more information about Amazon Redshift resource types and constructing ARNs, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-overview.html#redshift-iam-access-control-specify-actions">Specifying Policy Elements: Actions, Effects, Resources, and Principals</a> in the Amazon Redshift Cluster Management Guide. </p>
  ##   Version: string (required)
  var query_775279 = newJObject()
  if TagValues != nil:
    query_775279.add "TagValues", TagValues
  add(query_775279, "MaxRecords", newJInt(MaxRecords))
  add(query_775279, "ResourceName", newJString(ResourceName))
  add(query_775279, "Action", newJString(Action))
  add(query_775279, "Marker", newJString(Marker))
  if TagKeys != nil:
    query_775279.add "TagKeys", TagKeys
  add(query_775279, "ResourceType", newJString(ResourceType))
  add(query_775279, "Version", newJString(Version))
  result = call_775278.call(nil, query_775279, nil, nil, nil)

var getDescribeTags* = Call_GetDescribeTags_775259(name: "getDescribeTags",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=DescribeTags", validator: validate_GetDescribeTags_775260,
    base: "/", url: url_GetDescribeTags_775261, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDisableLogging_775318 = ref object of OpenApiRestCall_772581
proc url_PostDisableLogging_775320(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_PostDisableLogging_775319(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Stops logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_775321 = query.getOrDefault("Action")
  valid_775321 = validateParameter(valid_775321, JString, required = true,
                                 default = newJString("DisableLogging"))
  if valid_775321 != nil:
    section.add "Action", valid_775321
  var valid_775322 = query.getOrDefault("Version")
  valid_775322 = validateParameter(valid_775322, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_775322 != nil:
    section.add "Version", valid_775322
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_775323 = header.getOrDefault("X-Amz-Date")
  valid_775323 = validateParameter(valid_775323, JString, required = false,
                                 default = nil)
  if valid_775323 != nil:
    section.add "X-Amz-Date", valid_775323
  var valid_775324 = header.getOrDefault("X-Amz-Security-Token")
  valid_775324 = validateParameter(valid_775324, JString, required = false,
                                 default = nil)
  if valid_775324 != nil:
    section.add "X-Amz-Security-Token", valid_775324
  var valid_775325 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_775325 = validateParameter(valid_775325, JString, required = false,
                                 default = nil)
  if valid_775325 != nil:
    section.add "X-Amz-Content-Sha256", valid_775325
  var valid_775326 = header.getOrDefault("X-Amz-Algorithm")
  valid_775326 = validateParameter(valid_775326, JString, required = false,
                                 default = nil)
  if valid_775326 != nil:
    section.add "X-Amz-Algorithm", valid_775326
  var valid_775327 = header.getOrDefault("X-Amz-Signature")
  valid_775327 = validateParameter(valid_775327, JString, required = false,
                                 default = nil)
  if valid_775327 != nil:
    section.add "X-Amz-Signature", valid_775327
  var valid_775328 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_775328 = validateParameter(valid_775328, JString, required = false,
                                 default = nil)
  if valid_775328 != nil:
    section.add "X-Amz-SignedHeaders", valid_775328
  var valid_775329 = header.getOrDefault("X-Amz-Credential")
  valid_775329 = validateParameter(valid_775329, JString, required = false,
                                 default = nil)
  if valid_775329 != nil:
    section.add "X-Amz-Credential", valid_775329
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The identifier of the cluster on which logging is to be stopped.</p> <p>Example: <code>examplecluster</code> </p>
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_775330 = formData.getOrDefault("ClusterIdentifier")
  valid_775330 = validateParameter(valid_775330, JString, required = true,
                                 default = nil)
  if valid_775330 != nil:
    section.add "ClusterIdentifier", valid_775330
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_775331: Call_PostDisableLogging_775318; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Stops logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
  ## 
  let valid = call_775331.validator(path, query, header, formData, body)
  let scheme = call_775331.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_775331.url(scheme.get, call_775331.host, call_775331.base,
                         call_775331.route, valid.getOrDefault("path"))
  result = hook(call_775331, url, valid)

proc call*(call_775332: Call_PostDisableLogging_775318; ClusterIdentifier: string;
          Action: string = "DisableLogging"; Version: string = "2012-12-01"): Recallable =
  ## postDisableLogging
  ## Stops logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The identifier of the cluster on which logging is to be stopped.</p> <p>Example: <code>examplecluster</code> </p>
  ##   Version: string (required)
  var query_775333 = newJObject()
  var formData_775334 = newJObject()
  add(query_775333, "Action", newJString(Action))
  add(formData_775334, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_775333, "Version", newJString(Version))
  result = call_775332.call(nil, query_775333, nil, formData_775334, nil)

var postDisableLogging* = Call_PostDisableLogging_775318(
    name: "postDisableLogging", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DisableLogging",
    validator: validate_PostDisableLogging_775319, base: "/",
    url: url_PostDisableLogging_775320, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDisableLogging_775302 = ref object of OpenApiRestCall_772581
proc url_GetDisableLogging_775304(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_GetDisableLogging_775303(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## Stops logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The identifier of the cluster on which logging is to be stopped.</p> <p>Example: <code>examplecluster</code> </p>
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_775305 = query.getOrDefault("Action")
  valid_775305 = validateParameter(valid_775305, JString, required = true,
                                 default = newJString("DisableLogging"))
  if valid_775305 != nil:
    section.add "Action", valid_775305
  var valid_775306 = query.getOrDefault("ClusterIdentifier")
  valid_775306 = validateParameter(valid_775306, JString, required = true,
                                 default = nil)
  if valid_775306 != nil:
    section.add "ClusterIdentifier", valid_775306
  var valid_775307 = query.getOrDefault("Version")
  valid_775307 = validateParameter(valid_775307, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_775307 != nil:
    section.add "Version", valid_775307
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_775308 = header.getOrDefault("X-Amz-Date")
  valid_775308 = validateParameter(valid_775308, JString, required = false,
                                 default = nil)
  if valid_775308 != nil:
    section.add "X-Amz-Date", valid_775308
  var valid_775309 = header.getOrDefault("X-Amz-Security-Token")
  valid_775309 = validateParameter(valid_775309, JString, required = false,
                                 default = nil)
  if valid_775309 != nil:
    section.add "X-Amz-Security-Token", valid_775309
  var valid_775310 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_775310 = validateParameter(valid_775310, JString, required = false,
                                 default = nil)
  if valid_775310 != nil:
    section.add "X-Amz-Content-Sha256", valid_775310
  var valid_775311 = header.getOrDefault("X-Amz-Algorithm")
  valid_775311 = validateParameter(valid_775311, JString, required = false,
                                 default = nil)
  if valid_775311 != nil:
    section.add "X-Amz-Algorithm", valid_775311
  var valid_775312 = header.getOrDefault("X-Amz-Signature")
  valid_775312 = validateParameter(valid_775312, JString, required = false,
                                 default = nil)
  if valid_775312 != nil:
    section.add "X-Amz-Signature", valid_775312
  var valid_775313 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_775313 = validateParameter(valid_775313, JString, required = false,
                                 default = nil)
  if valid_775313 != nil:
    section.add "X-Amz-SignedHeaders", valid_775313
  var valid_775314 = header.getOrDefault("X-Amz-Credential")
  valid_775314 = validateParameter(valid_775314, JString, required = false,
                                 default = nil)
  if valid_775314 != nil:
    section.add "X-Amz-Credential", valid_775314
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_775315: Call_GetDisableLogging_775302; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Stops logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
  ## 
  let valid = call_775315.validator(path, query, header, formData, body)
  let scheme = call_775315.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_775315.url(scheme.get, call_775315.host, call_775315.base,
                         call_775315.route, valid.getOrDefault("path"))
  result = hook(call_775315, url, valid)

proc call*(call_775316: Call_GetDisableLogging_775302; ClusterIdentifier: string;
          Action: string = "DisableLogging"; Version: string = "2012-12-01"): Recallable =
  ## getDisableLogging
  ## Stops logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The identifier of the cluster on which logging is to be stopped.</p> <p>Example: <code>examplecluster</code> </p>
  ##   Version: string (required)
  var query_775317 = newJObject()
  add(query_775317, "Action", newJString(Action))
  add(query_775317, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_775317, "Version", newJString(Version))
  result = call_775316.call(nil, query_775317, nil, nil, nil)

var getDisableLogging* = Call_GetDisableLogging_775302(name: "getDisableLogging",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=DisableLogging", validator: validate_GetDisableLogging_775303,
    base: "/", url: url_GetDisableLogging_775304,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDisableSnapshotCopy_775351 = ref object of OpenApiRestCall_772581
proc url_PostDisableSnapshotCopy_775353(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_PostDisableSnapshotCopy_775352(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Disables the automatic copying of snapshots from one region to another region for a specified cluster.</p> <p>If your cluster and its snapshots are encrypted using a customer master key (CMK) from AWS KMS, use <a>DeleteSnapshotCopyGrant</a> to delete the grant that grants Amazon Redshift permission to the CMK in the destination region. </p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_775354 = query.getOrDefault("Action")
  valid_775354 = validateParameter(valid_775354, JString, required = true,
                                 default = newJString("DisableSnapshotCopy"))
  if valid_775354 != nil:
    section.add "Action", valid_775354
  var valid_775355 = query.getOrDefault("Version")
  valid_775355 = validateParameter(valid_775355, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_775355 != nil:
    section.add "Version", valid_775355
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_775356 = header.getOrDefault("X-Amz-Date")
  valid_775356 = validateParameter(valid_775356, JString, required = false,
                                 default = nil)
  if valid_775356 != nil:
    section.add "X-Amz-Date", valid_775356
  var valid_775357 = header.getOrDefault("X-Amz-Security-Token")
  valid_775357 = validateParameter(valid_775357, JString, required = false,
                                 default = nil)
  if valid_775357 != nil:
    section.add "X-Amz-Security-Token", valid_775357
  var valid_775358 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_775358 = validateParameter(valid_775358, JString, required = false,
                                 default = nil)
  if valid_775358 != nil:
    section.add "X-Amz-Content-Sha256", valid_775358
  var valid_775359 = header.getOrDefault("X-Amz-Algorithm")
  valid_775359 = validateParameter(valid_775359, JString, required = false,
                                 default = nil)
  if valid_775359 != nil:
    section.add "X-Amz-Algorithm", valid_775359
  var valid_775360 = header.getOrDefault("X-Amz-Signature")
  valid_775360 = validateParameter(valid_775360, JString, required = false,
                                 default = nil)
  if valid_775360 != nil:
    section.add "X-Amz-Signature", valid_775360
  var valid_775361 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_775361 = validateParameter(valid_775361, JString, required = false,
                                 default = nil)
  if valid_775361 != nil:
    section.add "X-Amz-SignedHeaders", valid_775361
  var valid_775362 = header.getOrDefault("X-Amz-Credential")
  valid_775362 = validateParameter(valid_775362, JString, required = false,
                                 default = nil)
  if valid_775362 != nil:
    section.add "X-Amz-Credential", valid_775362
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of the source cluster that you want to disable copying of snapshots to a destination region.</p> <p>Constraints: Must be the valid name of an existing cluster that has cross-region snapshot copy enabled.</p>
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_775363 = formData.getOrDefault("ClusterIdentifier")
  valid_775363 = validateParameter(valid_775363, JString, required = true,
                                 default = nil)
  if valid_775363 != nil:
    section.add "ClusterIdentifier", valid_775363
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_775364: Call_PostDisableSnapshotCopy_775351; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Disables the automatic copying of snapshots from one region to another region for a specified cluster.</p> <p>If your cluster and its snapshots are encrypted using a customer master key (CMK) from AWS KMS, use <a>DeleteSnapshotCopyGrant</a> to delete the grant that grants Amazon Redshift permission to the CMK in the destination region. </p>
  ## 
  let valid = call_775364.validator(path, query, header, formData, body)
  let scheme = call_775364.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_775364.url(scheme.get, call_775364.host, call_775364.base,
                         call_775364.route, valid.getOrDefault("path"))
  result = hook(call_775364, url, valid)

proc call*(call_775365: Call_PostDisableSnapshotCopy_775351;
          ClusterIdentifier: string; Action: string = "DisableSnapshotCopy";
          Version: string = "2012-12-01"): Recallable =
  ## postDisableSnapshotCopy
  ## <p>Disables the automatic copying of snapshots from one region to another region for a specified cluster.</p> <p>If your cluster and its snapshots are encrypted using a customer master key (CMK) from AWS KMS, use <a>DeleteSnapshotCopyGrant</a> to delete the grant that grants Amazon Redshift permission to the CMK in the destination region. </p>
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of the source cluster that you want to disable copying of snapshots to a destination region.</p> <p>Constraints: Must be the valid name of an existing cluster that has cross-region snapshot copy enabled.</p>
  ##   Version: string (required)
  var query_775366 = newJObject()
  var formData_775367 = newJObject()
  add(query_775366, "Action", newJString(Action))
  add(formData_775367, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_775366, "Version", newJString(Version))
  result = call_775365.call(nil, query_775366, nil, formData_775367, nil)

var postDisableSnapshotCopy* = Call_PostDisableSnapshotCopy_775351(
    name: "postDisableSnapshotCopy", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DisableSnapshotCopy",
    validator: validate_PostDisableSnapshotCopy_775352, base: "/",
    url: url_PostDisableSnapshotCopy_775353, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDisableSnapshotCopy_775335 = ref object of OpenApiRestCall_772581
proc url_GetDisableSnapshotCopy_775337(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_GetDisableSnapshotCopy_775336(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Disables the automatic copying of snapshots from one region to another region for a specified cluster.</p> <p>If your cluster and its snapshots are encrypted using a customer master key (CMK) from AWS KMS, use <a>DeleteSnapshotCopyGrant</a> to delete the grant that grants Amazon Redshift permission to the CMK in the destination region. </p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of the source cluster that you want to disable copying of snapshots to a destination region.</p> <p>Constraints: Must be the valid name of an existing cluster that has cross-region snapshot copy enabled.</p>
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_775338 = query.getOrDefault("Action")
  valid_775338 = validateParameter(valid_775338, JString, required = true,
                                 default = newJString("DisableSnapshotCopy"))
  if valid_775338 != nil:
    section.add "Action", valid_775338
  var valid_775339 = query.getOrDefault("ClusterIdentifier")
  valid_775339 = validateParameter(valid_775339, JString, required = true,
                                 default = nil)
  if valid_775339 != nil:
    section.add "ClusterIdentifier", valid_775339
  var valid_775340 = query.getOrDefault("Version")
  valid_775340 = validateParameter(valid_775340, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_775340 != nil:
    section.add "Version", valid_775340
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_775341 = header.getOrDefault("X-Amz-Date")
  valid_775341 = validateParameter(valid_775341, JString, required = false,
                                 default = nil)
  if valid_775341 != nil:
    section.add "X-Amz-Date", valid_775341
  var valid_775342 = header.getOrDefault("X-Amz-Security-Token")
  valid_775342 = validateParameter(valid_775342, JString, required = false,
                                 default = nil)
  if valid_775342 != nil:
    section.add "X-Amz-Security-Token", valid_775342
  var valid_775343 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_775343 = validateParameter(valid_775343, JString, required = false,
                                 default = nil)
  if valid_775343 != nil:
    section.add "X-Amz-Content-Sha256", valid_775343
  var valid_775344 = header.getOrDefault("X-Amz-Algorithm")
  valid_775344 = validateParameter(valid_775344, JString, required = false,
                                 default = nil)
  if valid_775344 != nil:
    section.add "X-Amz-Algorithm", valid_775344
  var valid_775345 = header.getOrDefault("X-Amz-Signature")
  valid_775345 = validateParameter(valid_775345, JString, required = false,
                                 default = nil)
  if valid_775345 != nil:
    section.add "X-Amz-Signature", valid_775345
  var valid_775346 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_775346 = validateParameter(valid_775346, JString, required = false,
                                 default = nil)
  if valid_775346 != nil:
    section.add "X-Amz-SignedHeaders", valid_775346
  var valid_775347 = header.getOrDefault("X-Amz-Credential")
  valid_775347 = validateParameter(valid_775347, JString, required = false,
                                 default = nil)
  if valid_775347 != nil:
    section.add "X-Amz-Credential", valid_775347
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_775348: Call_GetDisableSnapshotCopy_775335; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Disables the automatic copying of snapshots from one region to another region for a specified cluster.</p> <p>If your cluster and its snapshots are encrypted using a customer master key (CMK) from AWS KMS, use <a>DeleteSnapshotCopyGrant</a> to delete the grant that grants Amazon Redshift permission to the CMK in the destination region. </p>
  ## 
  let valid = call_775348.validator(path, query, header, formData, body)
  let scheme = call_775348.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_775348.url(scheme.get, call_775348.host, call_775348.base,
                         call_775348.route, valid.getOrDefault("path"))
  result = hook(call_775348, url, valid)

proc call*(call_775349: Call_GetDisableSnapshotCopy_775335;
          ClusterIdentifier: string; Action: string = "DisableSnapshotCopy";
          Version: string = "2012-12-01"): Recallable =
  ## getDisableSnapshotCopy
  ## <p>Disables the automatic copying of snapshots from one region to another region for a specified cluster.</p> <p>If your cluster and its snapshots are encrypted using a customer master key (CMK) from AWS KMS, use <a>DeleteSnapshotCopyGrant</a> to delete the grant that grants Amazon Redshift permission to the CMK in the destination region. </p>
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of the source cluster that you want to disable copying of snapshots to a destination region.</p> <p>Constraints: Must be the valid name of an existing cluster that has cross-region snapshot copy enabled.</p>
  ##   Version: string (required)
  var query_775350 = newJObject()
  add(query_775350, "Action", newJString(Action))
  add(query_775350, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_775350, "Version", newJString(Version))
  result = call_775349.call(nil, query_775350, nil, nil, nil)

var getDisableSnapshotCopy* = Call_GetDisableSnapshotCopy_775335(
    name: "getDisableSnapshotCopy", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DisableSnapshotCopy",
    validator: validate_GetDisableSnapshotCopy_775336, base: "/",
    url: url_GetDisableSnapshotCopy_775337, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostEnableLogging_775386 = ref object of OpenApiRestCall_772581
proc url_PostEnableLogging_775388(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_PostEnableLogging_775387(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## Starts logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_775389 = query.getOrDefault("Action")
  valid_775389 = validateParameter(valid_775389, JString, required = true,
                                 default = newJString("EnableLogging"))
  if valid_775389 != nil:
    section.add "Action", valid_775389
  var valid_775390 = query.getOrDefault("Version")
  valid_775390 = validateParameter(valid_775390, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_775390 != nil:
    section.add "Version", valid_775390
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_775391 = header.getOrDefault("X-Amz-Date")
  valid_775391 = validateParameter(valid_775391, JString, required = false,
                                 default = nil)
  if valid_775391 != nil:
    section.add "X-Amz-Date", valid_775391
  var valid_775392 = header.getOrDefault("X-Amz-Security-Token")
  valid_775392 = validateParameter(valid_775392, JString, required = false,
                                 default = nil)
  if valid_775392 != nil:
    section.add "X-Amz-Security-Token", valid_775392
  var valid_775393 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_775393 = validateParameter(valid_775393, JString, required = false,
                                 default = nil)
  if valid_775393 != nil:
    section.add "X-Amz-Content-Sha256", valid_775393
  var valid_775394 = header.getOrDefault("X-Amz-Algorithm")
  valid_775394 = validateParameter(valid_775394, JString, required = false,
                                 default = nil)
  if valid_775394 != nil:
    section.add "X-Amz-Algorithm", valid_775394
  var valid_775395 = header.getOrDefault("X-Amz-Signature")
  valid_775395 = validateParameter(valid_775395, JString, required = false,
                                 default = nil)
  if valid_775395 != nil:
    section.add "X-Amz-Signature", valid_775395
  var valid_775396 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_775396 = validateParameter(valid_775396, JString, required = false,
                                 default = nil)
  if valid_775396 != nil:
    section.add "X-Amz-SignedHeaders", valid_775396
  var valid_775397 = header.getOrDefault("X-Amz-Credential")
  valid_775397 = validateParameter(valid_775397, JString, required = false,
                                 default = nil)
  if valid_775397 != nil:
    section.add "X-Amz-Credential", valid_775397
  result.add "header", section
  ## parameters in `formData` object:
  ##   S3KeyPrefix: JString
  ##              : <p>The prefix applied to the log file names.</p> <p>Constraints:</p> <ul> <li> <p>Cannot exceed 512 characters</p> </li> <li> <p>Cannot contain spaces( ), double quotes ("), single quotes ('), a backslash (\), or control characters. The hexadecimal codes for invalid characters are: </p> <ul> <li> <p>x00 to x20</p> </li> <li> <p>x22</p> </li> <li> <p>x27</p> </li> <li> <p>x5c</p> </li> <li> <p>x7f or larger</p> </li> </ul> </li> </ul>
  ##   BucketName: JString (required)
  ##             : <p>The name of an existing S3 bucket where the log files are to be stored.</p> <p>Constraints:</p> <ul> <li> <p>Must be in the same region as the cluster</p> </li> <li> <p>The cluster must have read bucket and put object permissions</p> </li> </ul>
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The identifier of the cluster on which logging is to be started.</p> <p>Example: <code>examplecluster</code> </p>
  section = newJObject()
  var valid_775398 = formData.getOrDefault("S3KeyPrefix")
  valid_775398 = validateParameter(valid_775398, JString, required = false,
                                 default = nil)
  if valid_775398 != nil:
    section.add "S3KeyPrefix", valid_775398
  assert formData != nil,
        "formData argument is necessary due to required `BucketName` field"
  var valid_775399 = formData.getOrDefault("BucketName")
  valid_775399 = validateParameter(valid_775399, JString, required = true,
                                 default = nil)
  if valid_775399 != nil:
    section.add "BucketName", valid_775399
  var valid_775400 = formData.getOrDefault("ClusterIdentifier")
  valid_775400 = validateParameter(valid_775400, JString, required = true,
                                 default = nil)
  if valid_775400 != nil:
    section.add "ClusterIdentifier", valid_775400
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_775401: Call_PostEnableLogging_775386; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Starts logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
  ## 
  let valid = call_775401.validator(path, query, header, formData, body)
  let scheme = call_775401.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_775401.url(scheme.get, call_775401.host, call_775401.base,
                         call_775401.route, valid.getOrDefault("path"))
  result = hook(call_775401, url, valid)

proc call*(call_775402: Call_PostEnableLogging_775386; BucketName: string;
          ClusterIdentifier: string; S3KeyPrefix: string = "";
          Action: string = "EnableLogging"; Version: string = "2012-12-01"): Recallable =
  ## postEnableLogging
  ## Starts logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
  ##   S3KeyPrefix: string
  ##              : <p>The prefix applied to the log file names.</p> <p>Constraints:</p> <ul> <li> <p>Cannot exceed 512 characters</p> </li> <li> <p>Cannot contain spaces( ), double quotes ("), single quotes ('), a backslash (\), or control characters. The hexadecimal codes for invalid characters are: </p> <ul> <li> <p>x00 to x20</p> </li> <li> <p>x22</p> </li> <li> <p>x27</p> </li> <li> <p>x5c</p> </li> <li> <p>x7f or larger</p> </li> </ul> </li> </ul>
  ##   BucketName: string (required)
  ##             : <p>The name of an existing S3 bucket where the log files are to be stored.</p> <p>Constraints:</p> <ul> <li> <p>Must be in the same region as the cluster</p> </li> <li> <p>The cluster must have read bucket and put object permissions</p> </li> </ul>
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The identifier of the cluster on which logging is to be started.</p> <p>Example: <code>examplecluster</code> </p>
  ##   Version: string (required)
  var query_775403 = newJObject()
  var formData_775404 = newJObject()
  add(formData_775404, "S3KeyPrefix", newJString(S3KeyPrefix))
  add(formData_775404, "BucketName", newJString(BucketName))
  add(query_775403, "Action", newJString(Action))
  add(formData_775404, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_775403, "Version", newJString(Version))
  result = call_775402.call(nil, query_775403, nil, formData_775404, nil)

var postEnableLogging* = Call_PostEnableLogging_775386(name: "postEnableLogging",
    meth: HttpMethod.HttpPost, host: "redshift.amazonaws.com",
    route: "/#Action=EnableLogging", validator: validate_PostEnableLogging_775387,
    base: "/", url: url_PostEnableLogging_775388,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetEnableLogging_775368 = ref object of OpenApiRestCall_772581
proc url_GetEnableLogging_775370(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_GetEnableLogging_775369(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Starts logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   S3KeyPrefix: JString
  ##              : <p>The prefix applied to the log file names.</p> <p>Constraints:</p> <ul> <li> <p>Cannot exceed 512 characters</p> </li> <li> <p>Cannot contain spaces( ), double quotes ("), single quotes ('), a backslash (\), or control characters. The hexadecimal codes for invalid characters are: </p> <ul> <li> <p>x00 to x20</p> </li> <li> <p>x22</p> </li> <li> <p>x27</p> </li> <li> <p>x5c</p> </li> <li> <p>x7f or larger</p> </li> </ul> </li> </ul>
  ##   BucketName: JString (required)
  ##             : <p>The name of an existing S3 bucket where the log files are to be stored.</p> <p>Constraints:</p> <ul> <li> <p>Must be in the same region as the cluster</p> </li> <li> <p>The cluster must have read bucket and put object permissions</p> </li> </ul>
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The identifier of the cluster on which logging is to be started.</p> <p>Example: <code>examplecluster</code> </p>
  ##   Version: JString (required)
  section = newJObject()
  var valid_775371 = query.getOrDefault("S3KeyPrefix")
  valid_775371 = validateParameter(valid_775371, JString, required = false,
                                 default = nil)
  if valid_775371 != nil:
    section.add "S3KeyPrefix", valid_775371
  assert query != nil,
        "query argument is necessary due to required `BucketName` field"
  var valid_775372 = query.getOrDefault("BucketName")
  valid_775372 = validateParameter(valid_775372, JString, required = true,
                                 default = nil)
  if valid_775372 != nil:
    section.add "BucketName", valid_775372
  var valid_775373 = query.getOrDefault("Action")
  valid_775373 = validateParameter(valid_775373, JString, required = true,
                                 default = newJString("EnableLogging"))
  if valid_775373 != nil:
    section.add "Action", valid_775373
  var valid_775374 = query.getOrDefault("ClusterIdentifier")
  valid_775374 = validateParameter(valid_775374, JString, required = true,
                                 default = nil)
  if valid_775374 != nil:
    section.add "ClusterIdentifier", valid_775374
  var valid_775375 = query.getOrDefault("Version")
  valid_775375 = validateParameter(valid_775375, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_775375 != nil:
    section.add "Version", valid_775375
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_775376 = header.getOrDefault("X-Amz-Date")
  valid_775376 = validateParameter(valid_775376, JString, required = false,
                                 default = nil)
  if valid_775376 != nil:
    section.add "X-Amz-Date", valid_775376
  var valid_775377 = header.getOrDefault("X-Amz-Security-Token")
  valid_775377 = validateParameter(valid_775377, JString, required = false,
                                 default = nil)
  if valid_775377 != nil:
    section.add "X-Amz-Security-Token", valid_775377
  var valid_775378 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_775378 = validateParameter(valid_775378, JString, required = false,
                                 default = nil)
  if valid_775378 != nil:
    section.add "X-Amz-Content-Sha256", valid_775378
  var valid_775379 = header.getOrDefault("X-Amz-Algorithm")
  valid_775379 = validateParameter(valid_775379, JString, required = false,
                                 default = nil)
  if valid_775379 != nil:
    section.add "X-Amz-Algorithm", valid_775379
  var valid_775380 = header.getOrDefault("X-Amz-Signature")
  valid_775380 = validateParameter(valid_775380, JString, required = false,
                                 default = nil)
  if valid_775380 != nil:
    section.add "X-Amz-Signature", valid_775380
  var valid_775381 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_775381 = validateParameter(valid_775381, JString, required = false,
                                 default = nil)
  if valid_775381 != nil:
    section.add "X-Amz-SignedHeaders", valid_775381
  var valid_775382 = header.getOrDefault("X-Amz-Credential")
  valid_775382 = validateParameter(valid_775382, JString, required = false,
                                 default = nil)
  if valid_775382 != nil:
    section.add "X-Amz-Credential", valid_775382
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_775383: Call_GetEnableLogging_775368; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Starts logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
  ## 
  let valid = call_775383.validator(path, query, header, formData, body)
  let scheme = call_775383.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_775383.url(scheme.get, call_775383.host, call_775383.base,
                         call_775383.route, valid.getOrDefault("path"))
  result = hook(call_775383, url, valid)

proc call*(call_775384: Call_GetEnableLogging_775368; BucketName: string;
          ClusterIdentifier: string; S3KeyPrefix: string = "";
          Action: string = "EnableLogging"; Version: string = "2012-12-01"): Recallable =
  ## getEnableLogging
  ## Starts logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
  ##   S3KeyPrefix: string
  ##              : <p>The prefix applied to the log file names.</p> <p>Constraints:</p> <ul> <li> <p>Cannot exceed 512 characters</p> </li> <li> <p>Cannot contain spaces( ), double quotes ("), single quotes ('), a backslash (\), or control characters. The hexadecimal codes for invalid characters are: </p> <ul> <li> <p>x00 to x20</p> </li> <li> <p>x22</p> </li> <li> <p>x27</p> </li> <li> <p>x5c</p> </li> <li> <p>x7f or larger</p> </li> </ul> </li> </ul>
  ##   BucketName: string (required)
  ##             : <p>The name of an existing S3 bucket where the log files are to be stored.</p> <p>Constraints:</p> <ul> <li> <p>Must be in the same region as the cluster</p> </li> <li> <p>The cluster must have read bucket and put object permissions</p> </li> </ul>
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The identifier of the cluster on which logging is to be started.</p> <p>Example: <code>examplecluster</code> </p>
  ##   Version: string (required)
  var query_775385 = newJObject()
  add(query_775385, "S3KeyPrefix", newJString(S3KeyPrefix))
  add(query_775385, "BucketName", newJString(BucketName))
  add(query_775385, "Action", newJString(Action))
  add(query_775385, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_775385, "Version", newJString(Version))
  result = call_775384.call(nil, query_775385, nil, nil, nil)

var getEnableLogging* = Call_GetEnableLogging_775368(name: "getEnableLogging",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=EnableLogging", validator: validate_GetEnableLogging_775369,
    base: "/", url: url_GetEnableLogging_775370,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostEnableSnapshotCopy_775425 = ref object of OpenApiRestCall_772581
proc url_PostEnableSnapshotCopy_775427(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_PostEnableSnapshotCopy_775426(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Enables the automatic copy of snapshots from one region to another region for a specified cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_775428 = query.getOrDefault("Action")
  valid_775428 = validateParameter(valid_775428, JString, required = true,
                                 default = newJString("EnableSnapshotCopy"))
  if valid_775428 != nil:
    section.add "Action", valid_775428
  var valid_775429 = query.getOrDefault("Version")
  valid_775429 = validateParameter(valid_775429, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_775429 != nil:
    section.add "Version", valid_775429
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_775430 = header.getOrDefault("X-Amz-Date")
  valid_775430 = validateParameter(valid_775430, JString, required = false,
                                 default = nil)
  if valid_775430 != nil:
    section.add "X-Amz-Date", valid_775430
  var valid_775431 = header.getOrDefault("X-Amz-Security-Token")
  valid_775431 = validateParameter(valid_775431, JString, required = false,
                                 default = nil)
  if valid_775431 != nil:
    section.add "X-Amz-Security-Token", valid_775431
  var valid_775432 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_775432 = validateParameter(valid_775432, JString, required = false,
                                 default = nil)
  if valid_775432 != nil:
    section.add "X-Amz-Content-Sha256", valid_775432
  var valid_775433 = header.getOrDefault("X-Amz-Algorithm")
  valid_775433 = validateParameter(valid_775433, JString, required = false,
                                 default = nil)
  if valid_775433 != nil:
    section.add "X-Amz-Algorithm", valid_775433
  var valid_775434 = header.getOrDefault("X-Amz-Signature")
  valid_775434 = validateParameter(valid_775434, JString, required = false,
                                 default = nil)
  if valid_775434 != nil:
    section.add "X-Amz-Signature", valid_775434
  var valid_775435 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_775435 = validateParameter(valid_775435, JString, required = false,
                                 default = nil)
  if valid_775435 != nil:
    section.add "X-Amz-SignedHeaders", valid_775435
  var valid_775436 = header.getOrDefault("X-Amz-Credential")
  valid_775436 = validateParameter(valid_775436, JString, required = false,
                                 default = nil)
  if valid_775436 != nil:
    section.add "X-Amz-Credential", valid_775436
  result.add "header", section
  ## parameters in `formData` object:
  ##   RetentionPeriod: JInt
  ##                  : <p>The number of days to retain automated snapshots in the destination region after they are copied from the source region.</p> <p>Default: 7.</p> <p>Constraints: Must be at least 1 and no more than 35.</p>
  ##   SnapshotCopyGrantName: JString
  ##                        : The name of the snapshot copy grant to use when snapshots of an AWS KMS-encrypted cluster are copied to the destination region.
  ##   DestinationRegion: JString (required)
  ##                    : <p>The destination AWS Region that you want to copy snapshots to.</p> <p>Constraints: Must be the name of a valid AWS Region. For more information, see <a 
  ## href="https://docs.aws.amazon.com/general/latest/gr/rande.html#redshift_region">Regions and Endpoints</a> in the Amazon Web Services General Reference. </p>
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of the source cluster to copy snapshots from.</p> <p>Constraints: Must be the valid name of an existing cluster that does not already have cross-region snapshot copy enabled.</p>
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The number of days to retain newly copied snapshots in the destination AWS Region after they are copied from the source AWS Region. If the value is -1, the manual snapshot is retained indefinitely. </p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  section = newJObject()
  var valid_775437 = formData.getOrDefault("RetentionPeriod")
  valid_775437 = validateParameter(valid_775437, JInt, required = false, default = nil)
  if valid_775437 != nil:
    section.add "RetentionPeriod", valid_775437
  var valid_775438 = formData.getOrDefault("SnapshotCopyGrantName")
  valid_775438 = validateParameter(valid_775438, JString, required = false,
                                 default = nil)
  if valid_775438 != nil:
    section.add "SnapshotCopyGrantName", valid_775438
  assert formData != nil, "formData argument is necessary due to required `DestinationRegion` field"
  var valid_775439 = formData.getOrDefault("DestinationRegion")
  valid_775439 = validateParameter(valid_775439, JString, required = true,
                                 default = nil)
  if valid_775439 != nil:
    section.add "DestinationRegion", valid_775439
  var valid_775440 = formData.getOrDefault("ClusterIdentifier")
  valid_775440 = validateParameter(valid_775440, JString, required = true,
                                 default = nil)
  if valid_775440 != nil:
    section.add "ClusterIdentifier", valid_775440
  var valid_775441 = formData.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_775441 = validateParameter(valid_775441, JInt, required = false, default = nil)
  if valid_775441 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_775441
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_775442: Call_PostEnableSnapshotCopy_775425; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Enables the automatic copy of snapshots from one region to another region for a specified cluster.
  ## 
  let valid = call_775442.validator(path, query, header, formData, body)
  let scheme = call_775442.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_775442.url(scheme.get, call_775442.host, call_775442.base,
                         call_775442.route, valid.getOrDefault("path"))
  result = hook(call_775442, url, valid)

proc call*(call_775443: Call_PostEnableSnapshotCopy_775425;
          DestinationRegion: string; ClusterIdentifier: string;
          RetentionPeriod: int = 0; Action: string = "EnableSnapshotCopy";
          SnapshotCopyGrantName: string = "";
          ManualSnapshotRetentionPeriod: int = 0; Version: string = "2012-12-01"): Recallable =
  ## postEnableSnapshotCopy
  ## Enables the automatic copy of snapshots from one region to another region for a specified cluster.
  ##   RetentionPeriod: int
  ##                  : <p>The number of days to retain automated snapshots in the destination region after they are copied from the source region.</p> <p>Default: 7.</p> <p>Constraints: Must be at least 1 and no more than 35.</p>
  ##   Action: string (required)
  ##   SnapshotCopyGrantName: string
  ##                        : The name of the snapshot copy grant to use when snapshots of an AWS KMS-encrypted cluster are copied to the destination region.
  ##   DestinationRegion: string (required)
  ##                    : <p>The destination AWS Region that you want to copy snapshots to.</p> <p>Constraints: Must be the name of a valid AWS Region. For more information, see <a 
  ## href="https://docs.aws.amazon.com/general/latest/gr/rande.html#redshift_region">Regions and Endpoints</a> in the Amazon Web Services General Reference. </p>
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of the source cluster to copy snapshots from.</p> <p>Constraints: Must be the valid name of an existing cluster that does not already have cross-region snapshot copy enabled.</p>
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The number of days to retain newly copied snapshots in the destination AWS Region after they are copied from the source AWS Region. If the value is -1, the manual snapshot is retained indefinitely. </p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  ##   Version: string (required)
  var query_775444 = newJObject()
  var formData_775445 = newJObject()
  add(formData_775445, "RetentionPeriod", newJInt(RetentionPeriod))
  add(query_775444, "Action", newJString(Action))
  add(formData_775445, "SnapshotCopyGrantName", newJString(SnapshotCopyGrantName))
  add(formData_775445, "DestinationRegion", newJString(DestinationRegion))
  add(formData_775445, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_775445, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  add(query_775444, "Version", newJString(Version))
  result = call_775443.call(nil, query_775444, nil, formData_775445, nil)

var postEnableSnapshotCopy* = Call_PostEnableSnapshotCopy_775425(
    name: "postEnableSnapshotCopy", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=EnableSnapshotCopy",
    validator: validate_PostEnableSnapshotCopy_775426, base: "/",
    url: url_PostEnableSnapshotCopy_775427, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetEnableSnapshotCopy_775405 = ref object of OpenApiRestCall_772581
proc url_GetEnableSnapshotCopy_775407(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_GetEnableSnapshotCopy_775406(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Enables the automatic copy of snapshots from one region to another region for a specified cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   DestinationRegion: JString (required)
  ##                    : <p>The destination AWS Region that you want to copy snapshots to.</p> <p>Constraints: Must be the name of a valid AWS Region. For more information, see <a 
  ## href="https://docs.aws.amazon.com/general/latest/gr/rande.html#redshift_region">Regions and Endpoints</a> in the Amazon Web Services General Reference. </p>
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of the source cluster to copy snapshots from.</p> <p>Constraints: Must be the valid name of an existing cluster that does not already have cross-region snapshot copy enabled.</p>
  ##   SnapshotCopyGrantName: JString
  ##                        : The name of the snapshot copy grant to use when snapshots of an AWS KMS-encrypted cluster are copied to the destination region.
  ##   RetentionPeriod: JInt
  ##                  : <p>The number of days to retain automated snapshots in the destination region after they are copied from the source region.</p> <p>Default: 7.</p> <p>Constraints: Must be at least 1 and no more than 35.</p>
  ##   Version: JString (required)
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The number of days to retain newly copied snapshots in the destination AWS Region after they are copied from the source AWS Region. If the value is -1, the manual snapshot is retained indefinitely. </p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `DestinationRegion` field"
  var valid_775408 = query.getOrDefault("DestinationRegion")
  valid_775408 = validateParameter(valid_775408, JString, required = true,
                                 default = nil)
  if valid_775408 != nil:
    section.add "DestinationRegion", valid_775408
  var valid_775409 = query.getOrDefault("Action")
  valid_775409 = validateParameter(valid_775409, JString, required = true,
                                 default = newJString("EnableSnapshotCopy"))
  if valid_775409 != nil:
    section.add "Action", valid_775409
  var valid_775410 = query.getOrDefault("ClusterIdentifier")
  valid_775410 = validateParameter(valid_775410, JString, required = true,
                                 default = nil)
  if valid_775410 != nil:
    section.add "ClusterIdentifier", valid_775410
  var valid_775411 = query.getOrDefault("SnapshotCopyGrantName")
  valid_775411 = validateParameter(valid_775411, JString, required = false,
                                 default = nil)
  if valid_775411 != nil:
    section.add "SnapshotCopyGrantName", valid_775411
  var valid_775412 = query.getOrDefault("RetentionPeriod")
  valid_775412 = validateParameter(valid_775412, JInt, required = false, default = nil)
  if valid_775412 != nil:
    section.add "RetentionPeriod", valid_775412
  var valid_775413 = query.getOrDefault("Version")
  valid_775413 = validateParameter(valid_775413, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_775413 != nil:
    section.add "Version", valid_775413
  var valid_775414 = query.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_775414 = validateParameter(valid_775414, JInt, required = false, default = nil)
  if valid_775414 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_775414
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_775415 = header.getOrDefault("X-Amz-Date")
  valid_775415 = validateParameter(valid_775415, JString, required = false,
                                 default = nil)
  if valid_775415 != nil:
    section.add "X-Amz-Date", valid_775415
  var valid_775416 = header.getOrDefault("X-Amz-Security-Token")
  valid_775416 = validateParameter(valid_775416, JString, required = false,
                                 default = nil)
  if valid_775416 != nil:
    section.add "X-Amz-Security-Token", valid_775416
  var valid_775417 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_775417 = validateParameter(valid_775417, JString, required = false,
                                 default = nil)
  if valid_775417 != nil:
    section.add "X-Amz-Content-Sha256", valid_775417
  var valid_775418 = header.getOrDefault("X-Amz-Algorithm")
  valid_775418 = validateParameter(valid_775418, JString, required = false,
                                 default = nil)
  if valid_775418 != nil:
    section.add "X-Amz-Algorithm", valid_775418
  var valid_775419 = header.getOrDefault("X-Amz-Signature")
  valid_775419 = validateParameter(valid_775419, JString, required = false,
                                 default = nil)
  if valid_775419 != nil:
    section.add "X-Amz-Signature", valid_775419
  var valid_775420 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_775420 = validateParameter(valid_775420, JString, required = false,
                                 default = nil)
  if valid_775420 != nil:
    section.add "X-Amz-SignedHeaders", valid_775420
  var valid_775421 = header.getOrDefault("X-Amz-Credential")
  valid_775421 = validateParameter(valid_775421, JString, required = false,
                                 default = nil)
  if valid_775421 != nil:
    section.add "X-Amz-Credential", valid_775421
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_775422: Call_GetEnableSnapshotCopy_775405; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Enables the automatic copy of snapshots from one region to another region for a specified cluster.
  ## 
  let valid = call_775422.validator(path, query, header, formData, body)
  let scheme = call_775422.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_775422.url(scheme.get, call_775422.host, call_775422.base,
                         call_775422.route, valid.getOrDefault("path"))
  result = hook(call_775422, url, valid)

proc call*(call_775423: Call_GetEnableSnapshotCopy_775405;
          DestinationRegion: string; ClusterIdentifier: string;
          Action: string = "EnableSnapshotCopy"; SnapshotCopyGrantName: string = "";
          RetentionPeriod: int = 0; Version: string = "2012-12-01";
          ManualSnapshotRetentionPeriod: int = 0): Recallable =
  ## getEnableSnapshotCopy
  ## Enables the automatic copy of snapshots from one region to another region for a specified cluster.
  ##   DestinationRegion: string (required)
  ##                    : <p>The destination AWS Region that you want to copy snapshots to.</p> <p>Constraints: Must be the name of a valid AWS Region. For more information, see <a 
  ## href="https://docs.aws.amazon.com/general/latest/gr/rande.html#redshift_region">Regions and Endpoints</a> in the Amazon Web Services General Reference. </p>
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of the source cluster to copy snapshots from.</p> <p>Constraints: Must be the valid name of an existing cluster that does not already have cross-region snapshot copy enabled.</p>
  ##   SnapshotCopyGrantName: string
  ##                        : The name of the snapshot copy grant to use when snapshots of an AWS KMS-encrypted cluster are copied to the destination region.
  ##   RetentionPeriod: int
  ##                  : <p>The number of days to retain automated snapshots in the destination region after they are copied from the source region.</p> <p>Default: 7.</p> <p>Constraints: Must be at least 1 and no more than 35.</p>
  ##   Version: string (required)
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The number of days to retain newly copied snapshots in the destination AWS Region after they are copied from the source AWS Region. If the value is -1, the manual snapshot is retained indefinitely. </p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  var query_775424 = newJObject()
  add(query_775424, "DestinationRegion", newJString(DestinationRegion))
  add(query_775424, "Action", newJString(Action))
  add(query_775424, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_775424, "SnapshotCopyGrantName", newJString(SnapshotCopyGrantName))
  add(query_775424, "RetentionPeriod", newJInt(RetentionPeriod))
  add(query_775424, "Version", newJString(Version))
  add(query_775424, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  result = call_775423.call(nil, query_775424, nil, nil, nil)

var getEnableSnapshotCopy* = Call_GetEnableSnapshotCopy_775405(
    name: "getEnableSnapshotCopy", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=EnableSnapshotCopy",
    validator: validate_GetEnableSnapshotCopy_775406, base: "/",
    url: url_GetEnableSnapshotCopy_775407, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostGetClusterCredentials_775467 = ref object of OpenApiRestCall_772581
proc url_PostGetClusterCredentials_775469(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_PostGetClusterCredentials_775468(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns a database user name and temporary password with temporary authorization to log on to an Amazon Redshift database. The action returns the database user name prefixed with <code>IAM:</code> if <code>AutoCreate</code> is <code>False</code> or <code>IAMA:</code> if <code>AutoCreate</code> is <code>True</code>. You can optionally specify one or more database user groups that the user will join at log on. By default, the temporary credentials expire in 900 seconds. You can optionally specify a duration between 900 seconds (15 minutes) and 3600 seconds (60 minutes). For more information, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/generating-user-credentials.html">Using IAM Authentication to Generate Database User Credentials</a> in the Amazon Redshift Cluster Management Guide.</p> <p>The AWS Identity and Access Management (IAM)user or role that executes GetClusterCredentials must have an IAM policy attached that allows access to all necessary actions and resources. For more information about permissions, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-identity-based.html#redshift-policy-resources.getclustercredentials-resources">Resource Policies for GetClusterCredentials</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If the <code>DbGroups</code> parameter is specified, the IAM policy must allow the <code>redshift:JoinGroup</code> action with access to the listed <code>dbgroups</code>. </p> <p>In addition, if the <code>AutoCreate</code> parameter is set to <code>True</code>, then the policy must include the <code>redshift:CreateClusterUser</code> privilege.</p> <p>If the <code>DbName</code> parameter is specified, the IAM policy must allow access to the resource <code>dbname</code> for the specified database name. </p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_775470 = query.getOrDefault("Action")
  valid_775470 = validateParameter(valid_775470, JString, required = true,
                                 default = newJString("GetClusterCredentials"))
  if valid_775470 != nil:
    section.add "Action", valid_775470
  var valid_775471 = query.getOrDefault("Version")
  valid_775471 = validateParameter(valid_775471, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_775471 != nil:
    section.add "Version", valid_775471
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_775472 = header.getOrDefault("X-Amz-Date")
  valid_775472 = validateParameter(valid_775472, JString, required = false,
                                 default = nil)
  if valid_775472 != nil:
    section.add "X-Amz-Date", valid_775472
  var valid_775473 = header.getOrDefault("X-Amz-Security-Token")
  valid_775473 = validateParameter(valid_775473, JString, required = false,
                                 default = nil)
  if valid_775473 != nil:
    section.add "X-Amz-Security-Token", valid_775473
  var valid_775474 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_775474 = validateParameter(valid_775474, JString, required = false,
                                 default = nil)
  if valid_775474 != nil:
    section.add "X-Amz-Content-Sha256", valid_775474
  var valid_775475 = header.getOrDefault("X-Amz-Algorithm")
  valid_775475 = validateParameter(valid_775475, JString, required = false,
                                 default = nil)
  if valid_775475 != nil:
    section.add "X-Amz-Algorithm", valid_775475
  var valid_775476 = header.getOrDefault("X-Amz-Signature")
  valid_775476 = validateParameter(valid_775476, JString, required = false,
                                 default = nil)
  if valid_775476 != nil:
    section.add "X-Amz-Signature", valid_775476
  var valid_775477 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_775477 = validateParameter(valid_775477, JString, required = false,
                                 default = nil)
  if valid_775477 != nil:
    section.add "X-Amz-SignedHeaders", valid_775477
  var valid_775478 = header.getOrDefault("X-Amz-Credential")
  valid_775478 = validateParameter(valid_775478, JString, required = false,
                                 default = nil)
  if valid_775478 != nil:
    section.add "X-Amz-Credential", valid_775478
  result.add "header", section
  ## parameters in `formData` object:
  ##   DbUser: JString (required)
  ##         : <p>The name of a database user. If a user name matching <code>DbUser</code> exists in the database, the temporary user credentials have the same permissions as the existing user. If <code>DbUser</code> doesn't exist in the database and <code>Autocreate</code> is <code>True</code>, a new user is created using the value for <code>DbUser</code> with PUBLIC permissions. If a database user matching the value for <code>DbUser</code> doesn't exist and <code>Autocreate</code> is <code>False</code>, then the command succeeds but the connection attempt will fail because the user doesn't exist in the database.</p> <p>For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/r_CREATE_USER.html">CREATE USER</a> in the Amazon Redshift Database Developer Guide. </p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 64 alphanumeric characters or hyphens. The user name can't be <code>PUBLIC</code>.</p> </li> <li> <p>Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Must not contain a colon ( : ) or slash ( / ). </p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p> </li> </ul>
  ##   AutoCreate: JBool
  ##             : Create a database user with the name specified for the user named in <code>DbUser</code> if one does not exist.
  ##   ClusterIdentifier: JString (required)
  ##                    : The unique identifier of the cluster that contains the database for which your are requesting credentials. This parameter is case sensitive.
  ##   DbName: JString
  ##         : <p>The name of a database that <code>DbUser</code> is authorized to log on to. If <code>DbName</code> is not specified, <code>DbUser</code> can log on to any existing database.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 64 alphanumeric characters or hyphens</p> </li> <li> <p>Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Must not contain a colon ( : ) or slash ( / ). </p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p> </li> </ul>
  ##   DbGroups: JArray
  ##           : <p>A list of the names of existing database groups that the user named in <code>DbUser</code> will join for the current session, in addition to any group memberships for an existing user. If not specified, a new user is added only to PUBLIC.</p> <p>Database group name constraints</p> <ul> <li> <p>Must be 1 to 64 alphanumeric characters or hyphens</p> </li> <li> <p>Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Must not contain a colon ( : ) or slash ( / ). </p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p> </li> </ul>
  ##   DurationSeconds: JInt
  ##                  : <p>The number of seconds until the returned temporary password expires.</p> <p>Constraint: minimum 900, maximum 3600.</p> <p>Default: 900</p>
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `DbUser` field"
  var valid_775479 = formData.getOrDefault("DbUser")
  valid_775479 = validateParameter(valid_775479, JString, required = true,
                                 default = nil)
  if valid_775479 != nil:
    section.add "DbUser", valid_775479
  var valid_775480 = formData.getOrDefault("AutoCreate")
  valid_775480 = validateParameter(valid_775480, JBool, required = false, default = nil)
  if valid_775480 != nil:
    section.add "AutoCreate", valid_775480
  var valid_775481 = formData.getOrDefault("ClusterIdentifier")
  valid_775481 = validateParameter(valid_775481, JString, required = true,
                                 default = nil)
  if valid_775481 != nil:
    section.add "ClusterIdentifier", valid_775481
  var valid_775482 = formData.getOrDefault("DbName")
  valid_775482 = validateParameter(valid_775482, JString, required = false,
                                 default = nil)
  if valid_775482 != nil:
    section.add "DbName", valid_775482
  var valid_775483 = formData.getOrDefault("DbGroups")
  valid_775483 = validateParameter(valid_775483, JArray, required = false,
                                 default = nil)
  if valid_775483 != nil:
    section.add "DbGroups", valid_775483
  var valid_775484 = formData.getOrDefault("DurationSeconds")
  valid_775484 = validateParameter(valid_775484, JInt, required = false, default = nil)
  if valid_775484 != nil:
    section.add "DurationSeconds", valid_775484
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_775485: Call_PostGetClusterCredentials_775467; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns a database user name and temporary password with temporary authorization to log on to an Amazon Redshift database. The action returns the database user name prefixed with <code>IAM:</code> if <code>AutoCreate</code> is <code>False</code> or <code>IAMA:</code> if <code>AutoCreate</code> is <code>True</code>. You can optionally specify one or more database user groups that the user will join at log on. By default, the temporary credentials expire in 900 seconds. You can optionally specify a duration between 900 seconds (15 minutes) and 3600 seconds (60 minutes). For more information, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/generating-user-credentials.html">Using IAM Authentication to Generate Database User Credentials</a> in the Amazon Redshift Cluster Management Guide.</p> <p>The AWS Identity and Access Management (IAM)user or role that executes GetClusterCredentials must have an IAM policy attached that allows access to all necessary actions and resources. For more information about permissions, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-identity-based.html#redshift-policy-resources.getclustercredentials-resources">Resource Policies for GetClusterCredentials</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If the <code>DbGroups</code> parameter is specified, the IAM policy must allow the <code>redshift:JoinGroup</code> action with access to the listed <code>dbgroups</code>. </p> <p>In addition, if the <code>AutoCreate</code> parameter is set to <code>True</code>, then the policy must include the <code>redshift:CreateClusterUser</code> privilege.</p> <p>If the <code>DbName</code> parameter is specified, the IAM policy must allow access to the resource <code>dbname</code> for the specified database name. </p>
  ## 
  let valid = call_775485.validator(path, query, header, formData, body)
  let scheme = call_775485.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_775485.url(scheme.get, call_775485.host, call_775485.base,
                         call_775485.route, valid.getOrDefault("path"))
  result = hook(call_775485, url, valid)

proc call*(call_775486: Call_PostGetClusterCredentials_775467; DbUser: string;
          ClusterIdentifier: string; Action: string = "GetClusterCredentials";
          AutoCreate: bool = false; DbName: string = ""; DbGroups: JsonNode = nil;
          Version: string = "2012-12-01"; DurationSeconds: int = 0): Recallable =
  ## postGetClusterCredentials
  ## <p>Returns a database user name and temporary password with temporary authorization to log on to an Amazon Redshift database. The action returns the database user name prefixed with <code>IAM:</code> if <code>AutoCreate</code> is <code>False</code> or <code>IAMA:</code> if <code>AutoCreate</code> is <code>True</code>. You can optionally specify one or more database user groups that the user will join at log on. By default, the temporary credentials expire in 900 seconds. You can optionally specify a duration between 900 seconds (15 minutes) and 3600 seconds (60 minutes). For more information, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/generating-user-credentials.html">Using IAM Authentication to Generate Database User Credentials</a> in the Amazon Redshift Cluster Management Guide.</p> <p>The AWS Identity and Access Management (IAM)user or role that executes GetClusterCredentials must have an IAM policy attached that allows access to all necessary actions and resources. For more information about permissions, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-identity-based.html#redshift-policy-resources.getclustercredentials-resources">Resource Policies for GetClusterCredentials</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If the <code>DbGroups</code> parameter is specified, the IAM policy must allow the <code>redshift:JoinGroup</code> action with access to the listed <code>dbgroups</code>. </p> <p>In addition, if the <code>AutoCreate</code> parameter is set to <code>True</code>, then the policy must include the <code>redshift:CreateClusterUser</code> privilege.</p> <p>If the <code>DbName</code> parameter is specified, the IAM policy must allow access to the resource <code>dbname</code> for the specified database name. </p>
  ##   DbUser: string (required)
  ##         : <p>The name of a database user. If a user name matching <code>DbUser</code> exists in the database, the temporary user credentials have the same permissions as the existing user. If <code>DbUser</code> doesn't exist in the database and <code>Autocreate</code> is <code>True</code>, a new user is created using the value for <code>DbUser</code> with PUBLIC permissions. If a database user matching the value for <code>DbUser</code> doesn't exist and <code>Autocreate</code> is <code>False</code>, then the command succeeds but the connection attempt will fail because the user doesn't exist in the database.</p> <p>For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/r_CREATE_USER.html">CREATE USER</a> in the Amazon Redshift Database Developer Guide. </p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 64 alphanumeric characters or hyphens. The user name can't be <code>PUBLIC</code>.</p> </li> <li> <p>Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Must not contain a colon ( : ) or slash ( / ). </p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p> </li> </ul>
  ##   Action: string (required)
  ##   AutoCreate: bool
  ##             : Create a database user with the name specified for the user named in <code>DbUser</code> if one does not exist.
  ##   ClusterIdentifier: string (required)
  ##                    : The unique identifier of the cluster that contains the database for which your are requesting credentials. This parameter is case sensitive.
  ##   DbName: string
  ##         : <p>The name of a database that <code>DbUser</code> is authorized to log on to. If <code>DbName</code> is not specified, <code>DbUser</code> can log on to any existing database.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 64 alphanumeric characters or hyphens</p> </li> <li> <p>Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Must not contain a colon ( : ) or slash ( / ). </p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p> </li> </ul>
  ##   DbGroups: JArray
  ##           : <p>A list of the names of existing database groups that the user named in <code>DbUser</code> will join for the current session, in addition to any group memberships for an existing user. If not specified, a new user is added only to PUBLIC.</p> <p>Database group name constraints</p> <ul> <li> <p>Must be 1 to 64 alphanumeric characters or hyphens</p> </li> <li> <p>Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Must not contain a colon ( : ) or slash ( / ). </p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p> </li> </ul>
  ##   Version: string (required)
  ##   DurationSeconds: int
  ##                  : <p>The number of seconds until the returned temporary password expires.</p> <p>Constraint: minimum 900, maximum 3600.</p> <p>Default: 900</p>
  var query_775487 = newJObject()
  var formData_775488 = newJObject()
  add(formData_775488, "DbUser", newJString(DbUser))
  add(query_775487, "Action", newJString(Action))
  add(formData_775488, "AutoCreate", newJBool(AutoCreate))
  add(formData_775488, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_775488, "DbName", newJString(DbName))
  if DbGroups != nil:
    formData_775488.add "DbGroups", DbGroups
  add(query_775487, "Version", newJString(Version))
  add(formData_775488, "DurationSeconds", newJInt(DurationSeconds))
  result = call_775486.call(nil, query_775487, nil, formData_775488, nil)

var postGetClusterCredentials* = Call_PostGetClusterCredentials_775467(
    name: "postGetClusterCredentials", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=GetClusterCredentials",
    validator: validate_PostGetClusterCredentials_775468, base: "/",
    url: url_PostGetClusterCredentials_775469,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetGetClusterCredentials_775446 = ref object of OpenApiRestCall_772581
proc url_GetGetClusterCredentials_775448(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_GetGetClusterCredentials_775447(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns a database user name and temporary password with temporary authorization to log on to an Amazon Redshift database. The action returns the database user name prefixed with <code>IAM:</code> if <code>AutoCreate</code> is <code>False</code> or <code>IAMA:</code> if <code>AutoCreate</code> is <code>True</code>. You can optionally specify one or more database user groups that the user will join at log on. By default, the temporary credentials expire in 900 seconds. You can optionally specify a duration between 900 seconds (15 minutes) and 3600 seconds (60 minutes). For more information, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/generating-user-credentials.html">Using IAM Authentication to Generate Database User Credentials</a> in the Amazon Redshift Cluster Management Guide.</p> <p>The AWS Identity and Access Management (IAM)user or role that executes GetClusterCredentials must have an IAM policy attached that allows access to all necessary actions and resources. For more information about permissions, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-identity-based.html#redshift-policy-resources.getclustercredentials-resources">Resource Policies for GetClusterCredentials</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If the <code>DbGroups</code> parameter is specified, the IAM policy must allow the <code>redshift:JoinGroup</code> action with access to the listed <code>dbgroups</code>. </p> <p>In addition, if the <code>AutoCreate</code> parameter is set to <code>True</code>, then the policy must include the <code>redshift:CreateClusterUser</code> privilege.</p> <p>If the <code>DbName</code> parameter is specified, the IAM policy must allow access to the resource <code>dbname</code> for the specified database name. </p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   DbGroups: JArray
  ##           : <p>A list of the names of existing database groups that the user named in <code>DbUser</code> will join for the current session, in addition to any group memberships for an existing user. If not specified, a new user is added only to PUBLIC.</p> <p>Database group name constraints</p> <ul> <li> <p>Must be 1 to 64 alphanumeric characters or hyphens</p> </li> <li> <p>Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Must not contain a colon ( : ) or slash ( / ). </p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p> </li> </ul>
  ##   DurationSeconds: JInt
  ##                  : <p>The number of seconds until the returned temporary password expires.</p> <p>Constraint: minimum 900, maximum 3600.</p> <p>Default: 900</p>
  ##   DbName: JString
  ##         : <p>The name of a database that <code>DbUser</code> is authorized to log on to. If <code>DbName</code> is not specified, <code>DbUser</code> can log on to any existing database.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 64 alphanumeric characters or hyphens</p> </li> <li> <p>Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Must not contain a colon ( : ) or slash ( / ). </p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p> </li> </ul>
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : The unique identifier of the cluster that contains the database for which your are requesting credentials. This parameter is case sensitive.
  ##   AutoCreate: JBool
  ##             : Create a database user with the name specified for the user named in <code>DbUser</code> if one does not exist.
  ##   DbUser: JString (required)
  ##         : <p>The name of a database user. If a user name matching <code>DbUser</code> exists in the database, the temporary user credentials have the same permissions as the existing user. If <code>DbUser</code> doesn't exist in the database and <code>Autocreate</code> is <code>True</code>, a new user is created using the value for <code>DbUser</code> with PUBLIC permissions. If a database user matching the value for <code>DbUser</code> doesn't exist and <code>Autocreate</code> is <code>False</code>, then the command succeeds but the connection attempt will fail because the user doesn't exist in the database.</p> <p>For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/r_CREATE_USER.html">CREATE USER</a> in the Amazon Redshift Database Developer Guide. </p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 64 alphanumeric characters or hyphens. The user name can't be <code>PUBLIC</code>.</p> </li> <li> <p>Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Must not contain a colon ( : ) or slash ( / ). </p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p> </li> </ul>
  ##   Version: JString (required)
  section = newJObject()
  var valid_775449 = query.getOrDefault("DbGroups")
  valid_775449 = validateParameter(valid_775449, JArray, required = false,
                                 default = nil)
  if valid_775449 != nil:
    section.add "DbGroups", valid_775449
  var valid_775450 = query.getOrDefault("DurationSeconds")
  valid_775450 = validateParameter(valid_775450, JInt, required = false, default = nil)
  if valid_775450 != nil:
    section.add "DurationSeconds", valid_775450
  var valid_775451 = query.getOrDefault("DbName")
  valid_775451 = validateParameter(valid_775451, JString, required = false,
                                 default = nil)
  if valid_775451 != nil:
    section.add "DbName", valid_775451
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_775452 = query.getOrDefault("Action")
  valid_775452 = validateParameter(valid_775452, JString, required = true,
                                 default = newJString("GetClusterCredentials"))
  if valid_775452 != nil:
    section.add "Action", valid_775452
  var valid_775453 = query.getOrDefault("ClusterIdentifier")
  valid_775453 = validateParameter(valid_775453, JString, required = true,
                                 default = nil)
  if valid_775453 != nil:
    section.add "ClusterIdentifier", valid_775453
  var valid_775454 = query.getOrDefault("AutoCreate")
  valid_775454 = validateParameter(valid_775454, JBool, required = false, default = nil)
  if valid_775454 != nil:
    section.add "AutoCreate", valid_775454
  var valid_775455 = query.getOrDefault("DbUser")
  valid_775455 = validateParameter(valid_775455, JString, required = true,
                                 default = nil)
  if valid_775455 != nil:
    section.add "DbUser", valid_775455
  var valid_775456 = query.getOrDefault("Version")
  valid_775456 = validateParameter(valid_775456, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_775456 != nil:
    section.add "Version", valid_775456
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_775457 = header.getOrDefault("X-Amz-Date")
  valid_775457 = validateParameter(valid_775457, JString, required = false,
                                 default = nil)
  if valid_775457 != nil:
    section.add "X-Amz-Date", valid_775457
  var valid_775458 = header.getOrDefault("X-Amz-Security-Token")
  valid_775458 = validateParameter(valid_775458, JString, required = false,
                                 default = nil)
  if valid_775458 != nil:
    section.add "X-Amz-Security-Token", valid_775458
  var valid_775459 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_775459 = validateParameter(valid_775459, JString, required = false,
                                 default = nil)
  if valid_775459 != nil:
    section.add "X-Amz-Content-Sha256", valid_775459
  var valid_775460 = header.getOrDefault("X-Amz-Algorithm")
  valid_775460 = validateParameter(valid_775460, JString, required = false,
                                 default = nil)
  if valid_775460 != nil:
    section.add "X-Amz-Algorithm", valid_775460
  var valid_775461 = header.getOrDefault("X-Amz-Signature")
  valid_775461 = validateParameter(valid_775461, JString, required = false,
                                 default = nil)
  if valid_775461 != nil:
    section.add "X-Amz-Signature", valid_775461
  var valid_775462 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_775462 = validateParameter(valid_775462, JString, required = false,
                                 default = nil)
  if valid_775462 != nil:
    section.add "X-Amz-SignedHeaders", valid_775462
  var valid_775463 = header.getOrDefault("X-Amz-Credential")
  valid_775463 = validateParameter(valid_775463, JString, required = false,
                                 default = nil)
  if valid_775463 != nil:
    section.add "X-Amz-Credential", valid_775463
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_775464: Call_GetGetClusterCredentials_775446; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns a database user name and temporary password with temporary authorization to log on to an Amazon Redshift database. The action returns the database user name prefixed with <code>IAM:</code> if <code>AutoCreate</code> is <code>False</code> or <code>IAMA:</code> if <code>AutoCreate</code> is <code>True</code>. You can optionally specify one or more database user groups that the user will join at log on. By default, the temporary credentials expire in 900 seconds. You can optionally specify a duration between 900 seconds (15 minutes) and 3600 seconds (60 minutes). For more information, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/generating-user-credentials.html">Using IAM Authentication to Generate Database User Credentials</a> in the Amazon Redshift Cluster Management Guide.</p> <p>The AWS Identity and Access Management (IAM)user or role that executes GetClusterCredentials must have an IAM policy attached that allows access to all necessary actions and resources. For more information about permissions, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-identity-based.html#redshift-policy-resources.getclustercredentials-resources">Resource Policies for GetClusterCredentials</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If the <code>DbGroups</code> parameter is specified, the IAM policy must allow the <code>redshift:JoinGroup</code> action with access to the listed <code>dbgroups</code>. </p> <p>In addition, if the <code>AutoCreate</code> parameter is set to <code>True</code>, then the policy must include the <code>redshift:CreateClusterUser</code> privilege.</p> <p>If the <code>DbName</code> parameter is specified, the IAM policy must allow access to the resource <code>dbname</code> for the specified database name. </p>
  ## 
  let valid = call_775464.validator(path, query, header, formData, body)
  let scheme = call_775464.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_775464.url(scheme.get, call_775464.host, call_775464.base,
                         call_775464.route, valid.getOrDefault("path"))
  result = hook(call_775464, url, valid)

proc call*(call_775465: Call_GetGetClusterCredentials_775446;
          ClusterIdentifier: string; DbUser: string; DbGroups: JsonNode = nil;
          DurationSeconds: int = 0; DbName: string = "";
          Action: string = "GetClusterCredentials"; AutoCreate: bool = false;
          Version: string = "2012-12-01"): Recallable =
  ## getGetClusterCredentials
  ## <p>Returns a database user name and temporary password with temporary authorization to log on to an Amazon Redshift database. The action returns the database user name prefixed with <code>IAM:</code> if <code>AutoCreate</code> is <code>False</code> or <code>IAMA:</code> if <code>AutoCreate</code> is <code>True</code>. You can optionally specify one or more database user groups that the user will join at log on. By default, the temporary credentials expire in 900 seconds. You can optionally specify a duration between 900 seconds (15 minutes) and 3600 seconds (60 minutes). For more information, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/generating-user-credentials.html">Using IAM Authentication to Generate Database User Credentials</a> in the Amazon Redshift Cluster Management Guide.</p> <p>The AWS Identity and Access Management (IAM)user or role that executes GetClusterCredentials must have an IAM policy attached that allows access to all necessary actions and resources. For more information about permissions, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-identity-based.html#redshift-policy-resources.getclustercredentials-resources">Resource Policies for GetClusterCredentials</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If the <code>DbGroups</code> parameter is specified, the IAM policy must allow the <code>redshift:JoinGroup</code> action with access to the listed <code>dbgroups</code>. </p> <p>In addition, if the <code>AutoCreate</code> parameter is set to <code>True</code>, then the policy must include the <code>redshift:CreateClusterUser</code> privilege.</p> <p>If the <code>DbName</code> parameter is specified, the IAM policy must allow access to the resource <code>dbname</code> for the specified database name. </p>
  ##   DbGroups: JArray
  ##           : <p>A list of the names of existing database groups that the user named in <code>DbUser</code> will join for the current session, in addition to any group memberships for an existing user. If not specified, a new user is added only to PUBLIC.</p> <p>Database group name constraints</p> <ul> <li> <p>Must be 1 to 64 alphanumeric characters or hyphens</p> </li> <li> <p>Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Must not contain a colon ( : ) or slash ( / ). </p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p> </li> </ul>
  ##   DurationSeconds: int
  ##                  : <p>The number of seconds until the returned temporary password expires.</p> <p>Constraint: minimum 900, maximum 3600.</p> <p>Default: 900</p>
  ##   DbName: string
  ##         : <p>The name of a database that <code>DbUser</code> is authorized to log on to. If <code>DbName</code> is not specified, <code>DbUser</code> can log on to any existing database.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 64 alphanumeric characters or hyphens</p> </li> <li> <p>Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Must not contain a colon ( : ) or slash ( / ). </p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p> </li> </ul>
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : The unique identifier of the cluster that contains the database for which your are requesting credentials. This parameter is case sensitive.
  ##   AutoCreate: bool
  ##             : Create a database user with the name specified for the user named in <code>DbUser</code> if one does not exist.
  ##   DbUser: string (required)
  ##         : <p>The name of a database user. If a user name matching <code>DbUser</code> exists in the database, the temporary user credentials have the same permissions as the existing user. If <code>DbUser</code> doesn't exist in the database and <code>Autocreate</code> is <code>True</code>, a new user is created using the value for <code>DbUser</code> with PUBLIC permissions. If a database user matching the value for <code>DbUser</code> doesn't exist and <code>Autocreate</code> is <code>False</code>, then the command succeeds but the connection attempt will fail because the user doesn't exist in the database.</p> <p>For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/r_CREATE_USER.html">CREATE USER</a> in the Amazon Redshift Database Developer Guide. </p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 64 alphanumeric characters or hyphens. The user name can't be <code>PUBLIC</code>.</p> </li> <li> <p>Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Must not contain a colon ( : ) or slash ( / ). </p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p> </li> </ul>
  ##   Version: string (required)
  var query_775466 = newJObject()
  if DbGroups != nil:
    query_775466.add "DbGroups", DbGroups
  add(query_775466, "DurationSeconds", newJInt(DurationSeconds))
  add(query_775466, "DbName", newJString(DbName))
  add(query_775466, "Action", newJString(Action))
  add(query_775466, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_775466, "AutoCreate", newJBool(AutoCreate))
  add(query_775466, "DbUser", newJString(DbUser))
  add(query_775466, "Version", newJString(Version))
  result = call_775465.call(nil, query_775466, nil, nil, nil)

var getGetClusterCredentials* = Call_GetGetClusterCredentials_775446(
    name: "getGetClusterCredentials", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=GetClusterCredentials",
    validator: validate_GetGetClusterCredentials_775447, base: "/",
    url: url_GetGetClusterCredentials_775448, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostGetReservedNodeExchangeOfferings_775507 = ref object of OpenApiRestCall_772581
proc url_PostGetReservedNodeExchangeOfferings_775509(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_PostGetReservedNodeExchangeOfferings_775508(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns an array of DC2 ReservedNodeOfferings that matches the payment type, term, and usage price of the given DC1 reserved node.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_775510 = query.getOrDefault("Action")
  valid_775510 = validateParameter(valid_775510, JString, required = true, default = newJString(
      "GetReservedNodeExchangeOfferings"))
  if valid_775510 != nil:
    section.add "Action", valid_775510
  var valid_775511 = query.getOrDefault("Version")
  valid_775511 = validateParameter(valid_775511, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_775511 != nil:
    section.add "Version", valid_775511
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_775512 = header.getOrDefault("X-Amz-Date")
  valid_775512 = validateParameter(valid_775512, JString, required = false,
                                 default = nil)
  if valid_775512 != nil:
    section.add "X-Amz-Date", valid_775512
  var valid_775513 = header.getOrDefault("X-Amz-Security-Token")
  valid_775513 = validateParameter(valid_775513, JString, required = false,
                                 default = nil)
  if valid_775513 != nil:
    section.add "X-Amz-Security-Token", valid_775513
  var valid_775514 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_775514 = validateParameter(valid_775514, JString, required = false,
                                 default = nil)
  if valid_775514 != nil:
    section.add "X-Amz-Content-Sha256", valid_775514
  var valid_775515 = header.getOrDefault("X-Amz-Algorithm")
  valid_775515 = validateParameter(valid_775515, JString, required = false,
                                 default = nil)
  if valid_775515 != nil:
    section.add "X-Amz-Algorithm", valid_775515
  var valid_775516 = header.getOrDefault("X-Amz-Signature")
  valid_775516 = validateParameter(valid_775516, JString, required = false,
                                 default = nil)
  if valid_775516 != nil:
    section.add "X-Amz-Signature", valid_775516
  var valid_775517 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_775517 = validateParameter(valid_775517, JString, required = false,
                                 default = nil)
  if valid_775517 != nil:
    section.add "X-Amz-SignedHeaders", valid_775517
  var valid_775518 = header.getOrDefault("X-Amz-Credential")
  valid_775518 = validateParameter(valid_775518, JString, required = false,
                                 default = nil)
  if valid_775518 != nil:
    section.add "X-Amz-Credential", valid_775518
  result.add "header", section
  ## parameters in `formData` object:
  ##   ReservedNodeId: JString (required)
  ##                 : A string representing the node identifier for the DC1 Reserved Node to be exchanged.
  ##   Marker: JString
  ##         : A value that indicates the starting point for the next set of ReservedNodeOfferings.
  ##   MaxRecords: JInt
  ##             : An integer setting the maximum number of ReservedNodeOfferings to retrieve.
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `ReservedNodeId` field"
  var valid_775519 = formData.getOrDefault("ReservedNodeId")
  valid_775519 = validateParameter(valid_775519, JString, required = true,
                                 default = nil)
  if valid_775519 != nil:
    section.add "ReservedNodeId", valid_775519
  var valid_775520 = formData.getOrDefault("Marker")
  valid_775520 = validateParameter(valid_775520, JString, required = false,
                                 default = nil)
  if valid_775520 != nil:
    section.add "Marker", valid_775520
  var valid_775521 = formData.getOrDefault("MaxRecords")
  valid_775521 = validateParameter(valid_775521, JInt, required = false, default = nil)
  if valid_775521 != nil:
    section.add "MaxRecords", valid_775521
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_775522: Call_PostGetReservedNodeExchangeOfferings_775507;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Returns an array of DC2 ReservedNodeOfferings that matches the payment type, term, and usage price of the given DC1 reserved node.
  ## 
  let valid = call_775522.validator(path, query, header, formData, body)
  let scheme = call_775522.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_775522.url(scheme.get, call_775522.host, call_775522.base,
                         call_775522.route, valid.getOrDefault("path"))
  result = hook(call_775522, url, valid)

proc call*(call_775523: Call_PostGetReservedNodeExchangeOfferings_775507;
          ReservedNodeId: string; Marker: string = "";
          Action: string = "GetReservedNodeExchangeOfferings"; MaxRecords: int = 0;
          Version: string = "2012-12-01"): Recallable =
  ## postGetReservedNodeExchangeOfferings
  ## Returns an array of DC2 ReservedNodeOfferings that matches the payment type, term, and usage price of the given DC1 reserved node.
  ##   ReservedNodeId: string (required)
  ##                 : A string representing the node identifier for the DC1 Reserved Node to be exchanged.
  ##   Marker: string
  ##         : A value that indicates the starting point for the next set of ReservedNodeOfferings.
  ##   Action: string (required)
  ##   MaxRecords: int
  ##             : An integer setting the maximum number of ReservedNodeOfferings to retrieve.
  ##   Version: string (required)
  var query_775524 = newJObject()
  var formData_775525 = newJObject()
  add(formData_775525, "ReservedNodeId", newJString(ReservedNodeId))
  add(formData_775525, "Marker", newJString(Marker))
  add(query_775524, "Action", newJString(Action))
  add(formData_775525, "MaxRecords", newJInt(MaxRecords))
  add(query_775524, "Version", newJString(Version))
  result = call_775523.call(nil, query_775524, nil, formData_775525, nil)

var postGetReservedNodeExchangeOfferings* = Call_PostGetReservedNodeExchangeOfferings_775507(
    name: "postGetReservedNodeExchangeOfferings", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=GetReservedNodeExchangeOfferings",
    validator: validate_PostGetReservedNodeExchangeOfferings_775508, base: "/",
    url: url_PostGetReservedNodeExchangeOfferings_775509,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetGetReservedNodeExchangeOfferings_775489 = ref object of OpenApiRestCall_772581
proc url_GetGetReservedNodeExchangeOfferings_775491(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_GetGetReservedNodeExchangeOfferings_775490(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns an array of DC2 ReservedNodeOfferings that matches the payment type, term, and usage price of the given DC1 reserved node.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   MaxRecords: JInt
  ##             : An integer setting the maximum number of ReservedNodeOfferings to retrieve.
  ##   Action: JString (required)
  ##   Marker: JString
  ##         : A value that indicates the starting point for the next set of ReservedNodeOfferings.
  ##   Version: JString (required)
  ##   ReservedNodeId: JString (required)
  ##                 : A string representing the node identifier for the DC1 Reserved Node to be exchanged.
  section = newJObject()
  var valid_775492 = query.getOrDefault("MaxRecords")
  valid_775492 = validateParameter(valid_775492, JInt, required = false, default = nil)
  if valid_775492 != nil:
    section.add "MaxRecords", valid_775492
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_775493 = query.getOrDefault("Action")
  valid_775493 = validateParameter(valid_775493, JString, required = true, default = newJString(
      "GetReservedNodeExchangeOfferings"))
  if valid_775493 != nil:
    section.add "Action", valid_775493
  var valid_775494 = query.getOrDefault("Marker")
  valid_775494 = validateParameter(valid_775494, JString, required = false,
                                 default = nil)
  if valid_775494 != nil:
    section.add "Marker", valid_775494
  var valid_775495 = query.getOrDefault("Version")
  valid_775495 = validateParameter(valid_775495, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_775495 != nil:
    section.add "Version", valid_775495
  var valid_775496 = query.getOrDefault("ReservedNodeId")
  valid_775496 = validateParameter(valid_775496, JString, required = true,
                                 default = nil)
  if valid_775496 != nil:
    section.add "ReservedNodeId", valid_775496
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_775497 = header.getOrDefault("X-Amz-Date")
  valid_775497 = validateParameter(valid_775497, JString, required = false,
                                 default = nil)
  if valid_775497 != nil:
    section.add "X-Amz-Date", valid_775497
  var valid_775498 = header.getOrDefault("X-Amz-Security-Token")
  valid_775498 = validateParameter(valid_775498, JString, required = false,
                                 default = nil)
  if valid_775498 != nil:
    section.add "X-Amz-Security-Token", valid_775498
  var valid_775499 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_775499 = validateParameter(valid_775499, JString, required = false,
                                 default = nil)
  if valid_775499 != nil:
    section.add "X-Amz-Content-Sha256", valid_775499
  var valid_775500 = header.getOrDefault("X-Amz-Algorithm")
  valid_775500 = validateParameter(valid_775500, JString, required = false,
                                 default = nil)
  if valid_775500 != nil:
    section.add "X-Amz-Algorithm", valid_775500
  var valid_775501 = header.getOrDefault("X-Amz-Signature")
  valid_775501 = validateParameter(valid_775501, JString, required = false,
                                 default = nil)
  if valid_775501 != nil:
    section.add "X-Amz-Signature", valid_775501
  var valid_775502 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_775502 = validateParameter(valid_775502, JString, required = false,
                                 default = nil)
  if valid_775502 != nil:
    section.add "X-Amz-SignedHeaders", valid_775502
  var valid_775503 = header.getOrDefault("X-Amz-Credential")
  valid_775503 = validateParameter(valid_775503, JString, required = false,
                                 default = nil)
  if valid_775503 != nil:
    section.add "X-Amz-Credential", valid_775503
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_775504: Call_GetGetReservedNodeExchangeOfferings_775489;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Returns an array of DC2 ReservedNodeOfferings that matches the payment type, term, and usage price of the given DC1 reserved node.
  ## 
  let valid = call_775504.validator(path, query, header, formData, body)
  let scheme = call_775504.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_775504.url(scheme.get, call_775504.host, call_775504.base,
                         call_775504.route, valid.getOrDefault("path"))
  result = hook(call_775504, url, valid)

proc call*(call_775505: Call_GetGetReservedNodeExchangeOfferings_775489;
          ReservedNodeId: string; MaxRecords: int = 0;
          Action: string = "GetReservedNodeExchangeOfferings"; Marker: string = "";
          Version: string = "2012-12-01"): Recallable =
  ## getGetReservedNodeExchangeOfferings
  ## Returns an array of DC2 ReservedNodeOfferings that matches the payment type, term, and usage price of the given DC1 reserved node.
  ##   MaxRecords: int
  ##             : An integer setting the maximum number of ReservedNodeOfferings to retrieve.
  ##   Action: string (required)
  ##   Marker: string
  ##         : A value that indicates the starting point for the next set of ReservedNodeOfferings.
  ##   Version: string (required)
  ##   ReservedNodeId: string (required)
  ##                 : A string representing the node identifier for the DC1 Reserved Node to be exchanged.
  var query_775506 = newJObject()
  add(query_775506, "MaxRecords", newJInt(MaxRecords))
  add(query_775506, "Action", newJString(Action))
  add(query_775506, "Marker", newJString(Marker))
  add(query_775506, "Version", newJString(Version))
  add(query_775506, "ReservedNodeId", newJString(ReservedNodeId))
  result = call_775505.call(nil, query_775506, nil, nil, nil)

var getGetReservedNodeExchangeOfferings* = Call_GetGetReservedNodeExchangeOfferings_775489(
    name: "getGetReservedNodeExchangeOfferings", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=GetReservedNodeExchangeOfferings",
    validator: validate_GetGetReservedNodeExchangeOfferings_775490, base: "/",
    url: url_GetGetReservedNodeExchangeOfferings_775491,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostModifyCluster_775563 = ref object of OpenApiRestCall_772581
proc url_PostModifyCluster_775565(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_PostModifyCluster_775564(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## <p>Modifies the settings for a cluster. For example, you can add another security or parameter group, update the preferred maintenance window, or change the master user password. Resetting a cluster password or modifying the security groups associated with a cluster do not need a reboot. However, modifying a parameter group requires a reboot for parameters to take effect. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>You can also change node type and the number of nodes to scale up or down the cluster. When resizing a cluster, you must specify both the number of nodes and the node type even if one of the parameters does not change.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_775566 = query.getOrDefault("Action")
  valid_775566 = validateParameter(valid_775566, JString, required = true,
                                 default = newJString("ModifyCluster"))
  if valid_775566 != nil:
    section.add "Action", valid_775566
  var valid_775567 = query.getOrDefault("Version")
  valid_775567 = validateParameter(valid_775567, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_775567 != nil:
    section.add "Version", valid_775567
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_775568 = header.getOrDefault("X-Amz-Date")
  valid_775568 = validateParameter(valid_775568, JString, required = false,
                                 default = nil)
  if valid_775568 != nil:
    section.add "X-Amz-Date", valid_775568
  var valid_775569 = header.getOrDefault("X-Amz-Security-Token")
  valid_775569 = validateParameter(valid_775569, JString, required = false,
                                 default = nil)
  if valid_775569 != nil:
    section.add "X-Amz-Security-Token", valid_775569
  var valid_775570 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_775570 = validateParameter(valid_775570, JString, required = false,
                                 default = nil)
  if valid_775570 != nil:
    section.add "X-Amz-Content-Sha256", valid_775570
  var valid_775571 = header.getOrDefault("X-Amz-Algorithm")
  valid_775571 = validateParameter(valid_775571, JString, required = false,
                                 default = nil)
  if valid_775571 != nil:
    section.add "X-Amz-Algorithm", valid_775571
  var valid_775572 = header.getOrDefault("X-Amz-Signature")
  valid_775572 = validateParameter(valid_775572, JString, required = false,
                                 default = nil)
  if valid_775572 != nil:
    section.add "X-Amz-Signature", valid_775572
  var valid_775573 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_775573 = validateParameter(valid_775573, JString, required = false,
                                 default = nil)
  if valid_775573 != nil:
    section.add "X-Amz-SignedHeaders", valid_775573
  var valid_775574 = header.getOrDefault("X-Amz-Credential")
  valid_775574 = validateParameter(valid_775574, JString, required = false,
                                 default = nil)
  if valid_775574 != nil:
    section.add "X-Amz-Credential", valid_775574
  result.add "header", section
  ## parameters in `formData` object:
  ##   EnhancedVpcRouting: JBool
  ##                     : <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p> <p>Default: false</p>
  ##   VpcSecurityGroupIds: JArray
  ##                      : A list of virtual private cloud (VPC) security groups to be associated with the cluster. This change is asynchronously applied as soon as possible.
  ##   ClusterVersion: JString
  ##                 : <p>The new version number of the Amazon Redshift engine to upgrade to.</p> <p>For major version upgrades, if a non-default cluster parameter group is currently in use, a new cluster parameter group in the cluster parameter group family for the new version must be specified. The new cluster parameter group can be the default for that cluster parameter group family. For more information about parameters and parameter groups, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>Example: <code>1.0</code> </p>
  ##   ClusterType: JString
  ##              : <p>The new cluster type.</p> <p>When you submit your cluster resize request, your existing cluster goes into a read-only mode. After Amazon Redshift provisions a new cluster based on your resize requirements, there will be outage for a period while the old cluster is deleted and your connection is switched to the new cluster. You can use <a>DescribeResize</a> to track the progress of the resize request. </p> <p>Valid Values: <code> multi-node | single-node </code> </p>
  ##   MasterUserPassword: JString
  ##                     : <p>The new password for the cluster master user. This change is asynchronously applied as soon as possible. Between the time of the request and the completion of the request, the <code>MasterUserPassword</code> element exists in the <code>PendingModifiedValues</code> element of the operation response. </p> <note> <p>Operations never return the password, so this operation provides a way to regain access to the master user account for a cluster if the password is lost.</p> </note> <p>Default: Uses existing setting.</p> <p>Constraints:</p> <ul> <li> <p>Must be between 8 and 64 characters in length.</p> </li> <li> <p>Must contain at least one uppercase letter.</p> </li> <li> <p>Must contain at least one lowercase letter.</p> </li> <li> <p>Must contain one number.</p> </li> <li> <p>Can be any printable ASCII character (ASCII code 33 to 126) except ' (single quote), " (double quote), \, /, @, or space.</p> </li> </ul>
  ##   ClusterSecurityGroups: JArray
  ##                        : <p>A list of cluster security groups to be authorized on this cluster. This change is asynchronously applied as soon as possible.</p> <p>Security groups currently associated with the cluster, and not in the list of groups to apply, will be revoked from the cluster.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens</p> </li> <li> <p>First character must be a letter</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens</p> </li> </ul>
  ##   Encrypted: JBool
  ##            : Indicates whether the cluster is encrypted. If the cluster is encrypted and you provide a value for the <code>KmsKeyId</code> parameter, we will encrypt the cluster with the provided <code>KmsKeyId</code>. If you don't provide a <code>KmsKeyId</code>, we will encrypt with the default key. In the China region we will use legacy encryption if you specify that the cluster is encrypted.
  ##   HsmConfigurationIdentifier: JString
  ##                             : Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
  ##   HsmClientCertificateIdentifier: JString
  ##                                 : Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM.
  ##   PubliclyAccessible: JBool
  ##                     : If <code>true</code>, the cluster can be accessed from a public network. Only clusters in VPCs can be set to be publicly available.
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of the cluster to be modified.</p> <p>Example: <code>examplecluster</code> </p>
  ##   NumberOfNodes: JInt
  ##                : <p>The new number of nodes of the cluster. If you specify a new number of nodes, you must also specify the node type parameter.</p> <p>When you submit your request to resize a cluster, Amazon Redshift sets access permissions for the cluster to read-only. After Amazon Redshift provisions a new cluster according to your resize requirements, there will be a temporary outage while the old cluster is deleted and your connection is switched to the new cluster. When the new connection is complete, the original access permissions for the cluster are restored. You can use <a>DescribeResize</a> to track the progress of the resize request. </p> <p>Valid Values: Integer greater than <code>0</code>.</p>
  ##   ClusterParameterGroupName: JString
  ##                            : <p>The name of the cluster parameter group to apply to this cluster. This change is applied only after the cluster is rebooted. To reboot a cluster use <a>RebootCluster</a>. </p> <p>Default: Uses existing setting.</p> <p>Constraints: The cluster parameter group must be in the same parameter group family that matches the cluster version.</p>
  ##   KmsKeyId: JString
  ##           : The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster.
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The default for number of days that a newly created manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. This value doesn't retroactively change the retention periods of existing manual snapshots.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  ##   ElasticIp: JString
  ##            : <p>The Elastic IP (EIP) address for the cluster.</p> <p>Constraints: The cluster must be provisioned in EC2-VPC and publicly-accessible through an Internet gateway. For more information about provisioning clusters in EC2-VPC, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#cluster-platforms">Supported Platforms to Launch Your Cluster</a> in the Amazon Redshift Cluster Management Guide.</p>
  ##   NewClusterIdentifier: JString
  ##                       : <p>The new identifier for the cluster.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul> <p>Example: <code>examplecluster</code> </p>
  ##   AllowVersionUpgrade: JBool
  ##                      : <p>If <code>true</code>, major version upgrades will be applied automatically to the cluster during the maintenance window. </p> <p>Default: <code>false</code> </p>
  ##   AutomatedSnapshotRetentionPeriod: JInt
  ##                                   : <p>The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p> <p>If you decrease the automated snapshot retention period from its current value, existing automated snapshots that fall outside of the new retention period will be immediately deleted.</p> <p>Default: Uses existing setting.</p> <p>Constraints: Must be a value from 0 to 35.</p>
  ##   NodeType: JString
  ##           : <p>The new node type of the cluster. If you specify a new node type, you must also specify the number of nodes parameter.</p> <p>When you submit your request to resize a cluster, Amazon Redshift sets access permissions for the cluster to read-only. After Amazon Redshift provisions a new cluster according to your resize requirements, there will be a temporary outage while the old cluster is deleted and your connection is switched to the new cluster. When the new connection is complete, the original access permissions for the cluster are restored. You can use <a>DescribeResize</a> to track the progress of the resize request. </p> <p>Valid Values: <code>ds2.xlarge</code> | <code>ds2.8xlarge</code> | <code>dc1.large</code> | <code>dc1.8xlarge</code> | <code>dc2.large</code> | <code>dc2.8xlarge</code> </p>
  ##   MaintenanceTrackName: JString
  ##                       : The name for the maintenance track that you want to assign for the cluster. This name change is asynchronous. The new track name stays in the <code>PendingModifiedValues</code> for the cluster until the next maintenance window. When the maintenance track changes, the cluster is switched to the latest cluster release available for the maintenance track. At this point, the maintenance track name is applied.
  ##   PreferredMaintenanceWindow: JString
  ##                             : <p>The weekly time range (in UTC) during which system maintenance can occur, if necessary. If system maintenance is necessary during the window, it may result in an outage.</p> <p>This maintenance window change is made immediately. If the new maintenance window indicates the current time, there must be at least 120 minutes between the current time and end of the window in order to ensure that pending changes are applied.</p> <p>Default: Uses existing setting.</p> <p>Format: ddd:hh24:mi-ddd:hh24:mi, for example <code>wed:07:30-wed:08:00</code>.</p> <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p> <p>Constraints: Must be at least 30 minutes.</p>
  section = newJObject()
  var valid_775575 = formData.getOrDefault("EnhancedVpcRouting")
  valid_775575 = validateParameter(valid_775575, JBool, required = false, default = nil)
  if valid_775575 != nil:
    section.add "EnhancedVpcRouting", valid_775575
  var valid_775576 = formData.getOrDefault("VpcSecurityGroupIds")
  valid_775576 = validateParameter(valid_775576, JArray, required = false,
                                 default = nil)
  if valid_775576 != nil:
    section.add "VpcSecurityGroupIds", valid_775576
  var valid_775577 = formData.getOrDefault("ClusterVersion")
  valid_775577 = validateParameter(valid_775577, JString, required = false,
                                 default = nil)
  if valid_775577 != nil:
    section.add "ClusterVersion", valid_775577
  var valid_775578 = formData.getOrDefault("ClusterType")
  valid_775578 = validateParameter(valid_775578, JString, required = false,
                                 default = nil)
  if valid_775578 != nil:
    section.add "ClusterType", valid_775578
  var valid_775579 = formData.getOrDefault("MasterUserPassword")
  valid_775579 = validateParameter(valid_775579, JString, required = false,
                                 default = nil)
  if valid_775579 != nil:
    section.add "MasterUserPassword", valid_775579
  var valid_775580 = formData.getOrDefault("ClusterSecurityGroups")
  valid_775580 = validateParameter(valid_775580, JArray, required = false,
                                 default = nil)
  if valid_775580 != nil:
    section.add "ClusterSecurityGroups", valid_775580
  var valid_775581 = formData.getOrDefault("Encrypted")
  valid_775581 = validateParameter(valid_775581, JBool, required = false, default = nil)
  if valid_775581 != nil:
    section.add "Encrypted", valid_775581
  var valid_775582 = formData.getOrDefault("HsmConfigurationIdentifier")
  valid_775582 = validateParameter(valid_775582, JString, required = false,
                                 default = nil)
  if valid_775582 != nil:
    section.add "HsmConfigurationIdentifier", valid_775582
  var valid_775583 = formData.getOrDefault("HsmClientCertificateIdentifier")
  valid_775583 = validateParameter(valid_775583, JString, required = false,
                                 default = nil)
  if valid_775583 != nil:
    section.add "HsmClientCertificateIdentifier", valid_775583
  var valid_775584 = formData.getOrDefault("PubliclyAccessible")
  valid_775584 = validateParameter(valid_775584, JBool, required = false, default = nil)
  if valid_775584 != nil:
    section.add "PubliclyAccessible", valid_775584
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_775585 = formData.getOrDefault("ClusterIdentifier")
  valid_775585 = validateParameter(valid_775585, JString, required = true,
                                 default = nil)
  if valid_775585 != nil:
    section.add "ClusterIdentifier", valid_775585
  var valid_775586 = formData.getOrDefault("NumberOfNodes")
  valid_775586 = validateParameter(valid_775586, JInt, required = false, default = nil)
  if valid_775586 != nil:
    section.add "NumberOfNodes", valid_775586
  var valid_775587 = formData.getOrDefault("ClusterParameterGroupName")
  valid_775587 = validateParameter(valid_775587, JString, required = false,
                                 default = nil)
  if valid_775587 != nil:
    section.add "ClusterParameterGroupName", valid_775587
  var valid_775588 = formData.getOrDefault("KmsKeyId")
  valid_775588 = validateParameter(valid_775588, JString, required = false,
                                 default = nil)
  if valid_775588 != nil:
    section.add "KmsKeyId", valid_775588
  var valid_775589 = formData.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_775589 = validateParameter(valid_775589, JInt, required = false, default = nil)
  if valid_775589 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_775589
  var valid_775590 = formData.getOrDefault("ElasticIp")
  valid_775590 = validateParameter(valid_775590, JString, required = false,
                                 default = nil)
  if valid_775590 != nil:
    section.add "ElasticIp", valid_775590
  var valid_775591 = formData.getOrDefault("NewClusterIdentifier")
  valid_775591 = validateParameter(valid_775591, JString, required = false,
                                 default = nil)
  if valid_775591 != nil:
    section.add "NewClusterIdentifier", valid_775591
  var valid_775592 = formData.getOrDefault("AllowVersionUpgrade")
  valid_775592 = validateParameter(valid_775592, JBool, required = false, default = nil)
  if valid_775592 != nil:
    section.add "AllowVersionUpgrade", valid_775592
  var valid_775593 = formData.getOrDefault("AutomatedSnapshotRetentionPeriod")
  valid_775593 = validateParameter(valid_775593, JInt, required = false, default = nil)
  if valid_775593 != nil:
    section.add "AutomatedSnapshotRetentionPeriod", valid_775593
  var valid_775594 = formData.getOrDefault("NodeType")
  valid_775594 = validateParameter(valid_775594, JString, required = false,
                                 default = nil)
  if valid_775594 != nil:
    section.add "NodeType", valid_775594
  var valid_775595 = formData.getOrDefault("MaintenanceTrackName")
  valid_775595 = validateParameter(valid_775595, JString, required = false,
                                 default = nil)
  if valid_775595 != nil:
    section.add "MaintenanceTrackName", valid_775595
  var valid_775596 = formData.getOrDefault("PreferredMaintenanceWindow")
  valid_775596 = validateParameter(valid_775596, JString, required = false,
                                 default = nil)
  if valid_775596 != nil:
    section.add "PreferredMaintenanceWindow", valid_775596
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_775597: Call_PostModifyCluster_775563; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Modifies the settings for a cluster. For example, you can add another security or parameter group, update the preferred maintenance window, or change the master user password. Resetting a cluster password or modifying the security groups associated with a cluster do not need a reboot. However, modifying a parameter group requires a reboot for parameters to take effect. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>You can also change node type and the number of nodes to scale up or down the cluster. When resizing a cluster, you must specify both the number of nodes and the node type even if one of the parameters does not change.</p>
  ## 
  let valid = call_775597.validator(path, query, header, formData, body)
  let scheme = call_775597.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_775597.url(scheme.get, call_775597.host, call_775597.base,
                         call_775597.route, valid.getOrDefault("path"))
  result = hook(call_775597, url, valid)

proc call*(call_775598: Call_PostModifyCluster_775563; ClusterIdentifier: string;
          EnhancedVpcRouting: bool = false; VpcSecurityGroupIds: JsonNode = nil;
          ClusterVersion: string = ""; ClusterType: string = "";
          MasterUserPassword: string = ""; ClusterSecurityGroups: JsonNode = nil;
          Encrypted: bool = false; HsmConfigurationIdentifier: string = "";
          Action: string = "ModifyCluster";
          HsmClientCertificateIdentifier: string = "";
          PubliclyAccessible: bool = false; NumberOfNodes: int = 0;
          ClusterParameterGroupName: string = ""; KmsKeyId: string = "";
          ManualSnapshotRetentionPeriod: int = 0; ElasticIp: string = "";
          NewClusterIdentifier: string = ""; AllowVersionUpgrade: bool = false;
          AutomatedSnapshotRetentionPeriod: int = 0; Version: string = "2012-12-01";
          NodeType: string = ""; MaintenanceTrackName: string = "";
          PreferredMaintenanceWindow: string = ""): Recallable =
  ## postModifyCluster
  ## <p>Modifies the settings for a cluster. For example, you can add another security or parameter group, update the preferred maintenance window, or change the master user password. Resetting a cluster password or modifying the security groups associated with a cluster do not need a reboot. However, modifying a parameter group requires a reboot for parameters to take effect. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>You can also change node type and the number of nodes to scale up or down the cluster. When resizing a cluster, you must specify both the number of nodes and the node type even if one of the parameters does not change.</p>
  ##   EnhancedVpcRouting: bool
  ##                     : <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p> <p>Default: false</p>
  ##   VpcSecurityGroupIds: JArray
  ##                      : A list of virtual private cloud (VPC) security groups to be associated with the cluster. This change is asynchronously applied as soon as possible.
  ##   ClusterVersion: string
  ##                 : <p>The new version number of the Amazon Redshift engine to upgrade to.</p> <p>For major version upgrades, if a non-default cluster parameter group is currently in use, a new cluster parameter group in the cluster parameter group family for the new version must be specified. The new cluster parameter group can be the default for that cluster parameter group family. For more information about parameters and parameter groups, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>Example: <code>1.0</code> </p>
  ##   ClusterType: string
  ##              : <p>The new cluster type.</p> <p>When you submit your cluster resize request, your existing cluster goes into a read-only mode. After Amazon Redshift provisions a new cluster based on your resize requirements, there will be outage for a period while the old cluster is deleted and your connection is switched to the new cluster. You can use <a>DescribeResize</a> to track the progress of the resize request. </p> <p>Valid Values: <code> multi-node | single-node </code> </p>
  ##   MasterUserPassword: string
  ##                     : <p>The new password for the cluster master user. This change is asynchronously applied as soon as possible. Between the time of the request and the completion of the request, the <code>MasterUserPassword</code> element exists in the <code>PendingModifiedValues</code> element of the operation response. </p> <note> <p>Operations never return the password, so this operation provides a way to regain access to the master user account for a cluster if the password is lost.</p> </note> <p>Default: Uses existing setting.</p> <p>Constraints:</p> <ul> <li> <p>Must be between 8 and 64 characters in length.</p> </li> <li> <p>Must contain at least one uppercase letter.</p> </li> <li> <p>Must contain at least one lowercase letter.</p> </li> <li> <p>Must contain one number.</p> </li> <li> <p>Can be any printable ASCII character (ASCII code 33 to 126) except ' (single quote), " (double quote), \, /, @, or space.</p> </li> </ul>
  ##   ClusterSecurityGroups: JArray
  ##                        : <p>A list of cluster security groups to be authorized on this cluster. This change is asynchronously applied as soon as possible.</p> <p>Security groups currently associated with the cluster, and not in the list of groups to apply, will be revoked from the cluster.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens</p> </li> <li> <p>First character must be a letter</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens</p> </li> </ul>
  ##   Encrypted: bool
  ##            : Indicates whether the cluster is encrypted. If the cluster is encrypted and you provide a value for the <code>KmsKeyId</code> parameter, we will encrypt the cluster with the provided <code>KmsKeyId</code>. If you don't provide a <code>KmsKeyId</code>, we will encrypt with the default key. In the China region we will use legacy encryption if you specify that the cluster is encrypted.
  ##   HsmConfigurationIdentifier: string
  ##                             : Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
  ##   Action: string (required)
  ##   HsmClientCertificateIdentifier: string
  ##                                 : Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM.
  ##   PubliclyAccessible: bool
  ##                     : If <code>true</code>, the cluster can be accessed from a public network. Only clusters in VPCs can be set to be publicly available.
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of the cluster to be modified.</p> <p>Example: <code>examplecluster</code> </p>
  ##   NumberOfNodes: int
  ##                : <p>The new number of nodes of the cluster. If you specify a new number of nodes, you must also specify the node type parameter.</p> <p>When you submit your request to resize a cluster, Amazon Redshift sets access permissions for the cluster to read-only. After Amazon Redshift provisions a new cluster according to your resize requirements, there will be a temporary outage while the old cluster is deleted and your connection is switched to the new cluster. When the new connection is complete, the original access permissions for the cluster are restored. You can use <a>DescribeResize</a> to track the progress of the resize request. </p> <p>Valid Values: Integer greater than <code>0</code>.</p>
  ##   ClusterParameterGroupName: string
  ##                            : <p>The name of the cluster parameter group to apply to this cluster. This change is applied only after the cluster is rebooted. To reboot a cluster use <a>RebootCluster</a>. </p> <p>Default: Uses existing setting.</p> <p>Constraints: The cluster parameter group must be in the same parameter group family that matches the cluster version.</p>
  ##   KmsKeyId: string
  ##           : The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster.
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The default for number of days that a newly created manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. This value doesn't retroactively change the retention periods of existing manual snapshots.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  ##   ElasticIp: string
  ##            : <p>The Elastic IP (EIP) address for the cluster.</p> <p>Constraints: The cluster must be provisioned in EC2-VPC and publicly-accessible through an Internet gateway. For more information about provisioning clusters in EC2-VPC, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#cluster-platforms">Supported Platforms to Launch Your Cluster</a> in the Amazon Redshift Cluster Management Guide.</p>
  ##   NewClusterIdentifier: string
  ##                       : <p>The new identifier for the cluster.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul> <p>Example: <code>examplecluster</code> </p>
  ##   AllowVersionUpgrade: bool
  ##                      : <p>If <code>true</code>, major version upgrades will be applied automatically to the cluster during the maintenance window. </p> <p>Default: <code>false</code> </p>
  ##   AutomatedSnapshotRetentionPeriod: int
  ##                                   : <p>The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p> <p>If you decrease the automated snapshot retention period from its current value, existing automated snapshots that fall outside of the new retention period will be immediately deleted.</p> <p>Default: Uses existing setting.</p> <p>Constraints: Must be a value from 0 to 35.</p>
  ##   Version: string (required)
  ##   NodeType: string
  ##           : <p>The new node type of the cluster. If you specify a new node type, you must also specify the number of nodes parameter.</p> <p>When you submit your request to resize a cluster, Amazon Redshift sets access permissions for the cluster to read-only. After Amazon Redshift provisions a new cluster according to your resize requirements, there will be a temporary outage while the old cluster is deleted and your connection is switched to the new cluster. When the new connection is complete, the original access permissions for the cluster are restored. You can use <a>DescribeResize</a> to track the progress of the resize request. </p> <p>Valid Values: <code>ds2.xlarge</code> | <code>ds2.8xlarge</code> | <code>dc1.large</code> | <code>dc1.8xlarge</code> | <code>dc2.large</code> | <code>dc2.8xlarge</code> </p>
  ##   MaintenanceTrackName: string
  ##                       : The name for the maintenance track that you want to assign for the cluster. This name change is asynchronous. The new track name stays in the <code>PendingModifiedValues</code> for the cluster until the next maintenance window. When the maintenance track changes, the cluster is switched to the latest cluster release available for the maintenance track. At this point, the maintenance track name is applied.
  ##   PreferredMaintenanceWindow: string
  ##                             : <p>The weekly time range (in UTC) during which system maintenance can occur, if necessary. If system maintenance is necessary during the window, it may result in an outage.</p> <p>This maintenance window change is made immediately. If the new maintenance window indicates the current time, there must be at least 120 minutes between the current time and end of the window in order to ensure that pending changes are applied.</p> <p>Default: Uses existing setting.</p> <p>Format: ddd:hh24:mi-ddd:hh24:mi, for example <code>wed:07:30-wed:08:00</code>.</p> <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p> <p>Constraints: Must be at least 30 minutes.</p>
  var query_775599 = newJObject()
  var formData_775600 = newJObject()
  add(formData_775600, "EnhancedVpcRouting", newJBool(EnhancedVpcRouting))
  if VpcSecurityGroupIds != nil:
    formData_775600.add "VpcSecurityGroupIds", VpcSecurityGroupIds
  add(formData_775600, "ClusterVersion", newJString(ClusterVersion))
  add(formData_775600, "ClusterType", newJString(ClusterType))
  add(formData_775600, "MasterUserPassword", newJString(MasterUserPassword))
  if ClusterSecurityGroups != nil:
    formData_775600.add "ClusterSecurityGroups", ClusterSecurityGroups
  add(formData_775600, "Encrypted", newJBool(Encrypted))
  add(formData_775600, "HsmConfigurationIdentifier",
      newJString(HsmConfigurationIdentifier))
  add(query_775599, "Action", newJString(Action))
  add(formData_775600, "HsmClientCertificateIdentifier",
      newJString(HsmClientCertificateIdentifier))
  add(formData_775600, "PubliclyAccessible", newJBool(PubliclyAccessible))
  add(formData_775600, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_775600, "NumberOfNodes", newJInt(NumberOfNodes))
  add(formData_775600, "ClusterParameterGroupName",
      newJString(ClusterParameterGroupName))
  add(formData_775600, "KmsKeyId", newJString(KmsKeyId))
  add(formData_775600, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  add(formData_775600, "ElasticIp", newJString(ElasticIp))
  add(formData_775600, "NewClusterIdentifier", newJString(NewClusterIdentifier))
  add(formData_775600, "AllowVersionUpgrade", newJBool(AllowVersionUpgrade))
  add(formData_775600, "AutomatedSnapshotRetentionPeriod",
      newJInt(AutomatedSnapshotRetentionPeriod))
  add(query_775599, "Version", newJString(Version))
  add(formData_775600, "NodeType", newJString(NodeType))
  add(formData_775600, "MaintenanceTrackName", newJString(MaintenanceTrackName))
  add(formData_775600, "PreferredMaintenanceWindow",
      newJString(PreferredMaintenanceWindow))
  result = call_775598.call(nil, query_775599, nil, formData_775600, nil)

var postModifyCluster* = Call_PostModifyCluster_775563(name: "postModifyCluster",
    meth: HttpMethod.HttpPost, host: "redshift.amazonaws.com",
    route: "/#Action=ModifyCluster", validator: validate_PostModifyCluster_775564,
    base: "/", url: url_PostModifyCluster_775565,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetModifyCluster_775526 = ref object of OpenApiRestCall_772581
proc url_GetModifyCluster_775528(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_GetModifyCluster_775527(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## <p>Modifies the settings for a cluster. For example, you can add another security or parameter group, update the preferred maintenance window, or change the master user password. Resetting a cluster password or modifying the security groups associated with a cluster do not need a reboot. However, modifying a parameter group requires a reboot for parameters to take effect. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>You can also change node type and the number of nodes to scale up or down the cluster. When resizing a cluster, you must specify both the number of nodes and the node type even if one of the parameters does not change.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ClusterSecurityGroups: JArray
  ##                        : <p>A list of cluster security groups to be authorized on this cluster. This change is asynchronously applied as soon as possible.</p> <p>Security groups currently associated with the cluster, and not in the list of groups to apply, will be revoked from the cluster.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens</p> </li> <li> <p>First character must be a letter</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens</p> </li> </ul>
  ##   HsmClientCertificateIdentifier: JString
  ##                                 : Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM.
  ##   PreferredMaintenanceWindow: JString
  ##                             : <p>The weekly time range (in UTC) during which system maintenance can occur, if necessary. If system maintenance is necessary during the window, it may result in an outage.</p> <p>This maintenance window change is made immediately. If the new maintenance window indicates the current time, there must be at least 120 minutes between the current time and end of the window in order to ensure that pending changes are applied.</p> <p>Default: Uses existing setting.</p> <p>Format: ddd:hh24:mi-ddd:hh24:mi, for example <code>wed:07:30-wed:08:00</code>.</p> <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p> <p>Constraints: Must be at least 30 minutes.</p>
  ##   Encrypted: JBool
  ##            : Indicates whether the cluster is encrypted. If the cluster is encrypted and you provide a value for the <code>KmsKeyId</code> parameter, we will encrypt the cluster with the provided <code>KmsKeyId</code>. If you don't provide a <code>KmsKeyId</code>, we will encrypt with the default key. In the China region we will use legacy encryption if you specify that the cluster is encrypted.
  ##   MaintenanceTrackName: JString
  ##                       : The name for the maintenance track that you want to assign for the cluster. This name change is asynchronous. The new track name stays in the <code>PendingModifiedValues</code> for the cluster until the next maintenance window. When the maintenance track changes, the cluster is switched to the latest cluster release available for the maintenance track. At this point, the maintenance track name is applied.
  ##   MasterUserPassword: JString
  ##                     : <p>The new password for the cluster master user. This change is asynchronously applied as soon as possible. Between the time of the request and the completion of the request, the <code>MasterUserPassword</code> element exists in the <code>PendingModifiedValues</code> element of the operation response. </p> <note> <p>Operations never return the password, so this operation provides a way to regain access to the master user account for a cluster if the password is lost.</p> </note> <p>Default: Uses existing setting.</p> <p>Constraints:</p> <ul> <li> <p>Must be between 8 and 64 characters in length.</p> </li> <li> <p>Must contain at least one uppercase letter.</p> </li> <li> <p>Must contain at least one lowercase letter.</p> </li> <li> <p>Must contain one number.</p> </li> <li> <p>Can be any printable ASCII character (ASCII code 33 to 126) except ' (single quote), " (double quote), \, /, @, or space.</p> </li> </ul>
  ##   AllowVersionUpgrade: JBool
  ##                      : <p>If <code>true</code>, major version upgrades will be applied automatically to the cluster during the maintenance window. </p> <p>Default: <code>false</code> </p>
  ##   EnhancedVpcRouting: JBool
  ##                     : <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p> <p>Default: false</p>
  ##   VpcSecurityGroupIds: JArray
  ##                      : A list of virtual private cloud (VPC) security groups to be associated with the cluster. This change is asynchronously applied as soon as possible.
  ##   ClusterParameterGroupName: JString
  ##                            : <p>The name of the cluster parameter group to apply to this cluster. This change is applied only after the cluster is rebooted. To reboot a cluster use <a>RebootCluster</a>. </p> <p>Default: Uses existing setting.</p> <p>Constraints: The cluster parameter group must be in the same parameter group family that matches the cluster version.</p>
  ##   HsmConfigurationIdentifier: JString
  ##                             : Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
  ##   NewClusterIdentifier: JString
  ##                       : <p>The new identifier for the cluster.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul> <p>Example: <code>examplecluster</code> </p>
  ##   ElasticIp: JString
  ##            : <p>The Elastic IP (EIP) address for the cluster.</p> <p>Constraints: The cluster must be provisioned in EC2-VPC and publicly-accessible through an Internet gateway. For more information about provisioning clusters in EC2-VPC, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#cluster-platforms">Supported Platforms to Launch Your Cluster</a> in the Amazon Redshift Cluster Management Guide.</p>
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of the cluster to be modified.</p> <p>Example: <code>examplecluster</code> </p>
  ##   Action: JString (required)
  ##   KmsKeyId: JString
  ##           : The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster.
  ##   PubliclyAccessible: JBool
  ##                     : If <code>true</code>, the cluster can be accessed from a public network. Only clusters in VPCs can be set to be publicly available.
  ##   NumberOfNodes: JInt
  ##                : <p>The new number of nodes of the cluster. If you specify a new number of nodes, you must also specify the node type parameter.</p> <p>When you submit your request to resize a cluster, Amazon Redshift sets access permissions for the cluster to read-only. After Amazon Redshift provisions a new cluster according to your resize requirements, there will be a temporary outage while the old cluster is deleted and your connection is switched to the new cluster. When the new connection is complete, the original access permissions for the cluster are restored. You can use <a>DescribeResize</a> to track the progress of the resize request. </p> <p>Valid Values: Integer greater than <code>0</code>.</p>
  ##   AutomatedSnapshotRetentionPeriod: JInt
  ##                                   : <p>The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p> <p>If you decrease the automated snapshot retention period from its current value, existing automated snapshots that fall outside of the new retention period will be immediately deleted.</p> <p>Default: Uses existing setting.</p> <p>Constraints: Must be a value from 0 to 35.</p>
  ##   NodeType: JString
  ##           : <p>The new node type of the cluster. If you specify a new node type, you must also specify the number of nodes parameter.</p> <p>When you submit your request to resize a cluster, Amazon Redshift sets access permissions for the cluster to read-only. After Amazon Redshift provisions a new cluster according to your resize requirements, there will be a temporary outage while the old cluster is deleted and your connection is switched to the new cluster. When the new connection is complete, the original access permissions for the cluster are restored. You can use <a>DescribeResize</a> to track the progress of the resize request. </p> <p>Valid Values: <code>ds2.xlarge</code> | <code>ds2.8xlarge</code> | <code>dc1.large</code> | <code>dc1.8xlarge</code> | <code>dc2.large</code> | <code>dc2.8xlarge</code> </p>
  ##   ClusterVersion: JString
  ##                 : <p>The new version number of the Amazon Redshift engine to upgrade to.</p> <p>For major version upgrades, if a non-default cluster parameter group is currently in use, a new cluster parameter group in the cluster parameter group family for the new version must be specified. The new cluster parameter group can be the default for that cluster parameter group family. For more information about parameters and parameter groups, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>Example: <code>1.0</code> </p>
  ##   Version: JString (required)
  ##   ClusterType: JString
  ##              : <p>The new cluster type.</p> <p>When you submit your cluster resize request, your existing cluster goes into a read-only mode. After Amazon Redshift provisions a new cluster based on your resize requirements, there will be outage for a period while the old cluster is deleted and your connection is switched to the new cluster. You can use <a>DescribeResize</a> to track the progress of the resize request. </p> <p>Valid Values: <code> multi-node | single-node </code> </p>
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The default for number of days that a newly created manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. This value doesn't retroactively change the retention periods of existing manual snapshots.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  section = newJObject()
  var valid_775529 = query.getOrDefault("ClusterSecurityGroups")
  valid_775529 = validateParameter(valid_775529, JArray, required = false,
                                 default = nil)
  if valid_775529 != nil:
    section.add "ClusterSecurityGroups", valid_775529
  var valid_775530 = query.getOrDefault("HsmClientCertificateIdentifier")
  valid_775530 = validateParameter(valid_775530, JString, required = false,
                                 default = nil)
  if valid_775530 != nil:
    section.add "HsmClientCertificateIdentifier", valid_775530
  var valid_775531 = query.getOrDefault("PreferredMaintenanceWindow")
  valid_775531 = validateParameter(valid_775531, JString, required = false,
                                 default = nil)
  if valid_775531 != nil:
    section.add "PreferredMaintenanceWindow", valid_775531
  var valid_775532 = query.getOrDefault("Encrypted")
  valid_775532 = validateParameter(valid_775532, JBool, required = false, default = nil)
  if valid_775532 != nil:
    section.add "Encrypted", valid_775532
  var valid_775533 = query.getOrDefault("MaintenanceTrackName")
  valid_775533 = validateParameter(valid_775533, JString, required = false,
                                 default = nil)
  if valid_775533 != nil:
    section.add "MaintenanceTrackName", valid_775533
  var valid_775534 = query.getOrDefault("MasterUserPassword")
  valid_775534 = validateParameter(valid_775534, JString, required = false,
                                 default = nil)
  if valid_775534 != nil:
    section.add "MasterUserPassword", valid_775534
  var valid_775535 = query.getOrDefault("AllowVersionUpgrade")
  valid_775535 = validateParameter(valid_775535, JBool, required = false, default = nil)
  if valid_775535 != nil:
    section.add "AllowVersionUpgrade", valid_775535
  var valid_775536 = query.getOrDefault("EnhancedVpcRouting")
  valid_775536 = validateParameter(valid_775536, JBool, required = false, default = nil)
  if valid_775536 != nil:
    section.add "EnhancedVpcRouting", valid_775536
  var valid_775537 = query.getOrDefault("VpcSecurityGroupIds")
  valid_775537 = validateParameter(valid_775537, JArray, required = false,
                                 default = nil)
  if valid_775537 != nil:
    section.add "VpcSecurityGroupIds", valid_775537
  var valid_775538 = query.getOrDefault("ClusterParameterGroupName")
  valid_775538 = validateParameter(valid_775538, JString, required = false,
                                 default = nil)
  if valid_775538 != nil:
    section.add "ClusterParameterGroupName", valid_775538
  var valid_775539 = query.getOrDefault("HsmConfigurationIdentifier")
  valid_775539 = validateParameter(valid_775539, JString, required = false,
                                 default = nil)
  if valid_775539 != nil:
    section.add "HsmConfigurationIdentifier", valid_775539
  var valid_775540 = query.getOrDefault("NewClusterIdentifier")
  valid_775540 = validateParameter(valid_775540, JString, required = false,
                                 default = nil)
  if valid_775540 != nil:
    section.add "NewClusterIdentifier", valid_775540
  var valid_775541 = query.getOrDefault("ElasticIp")
  valid_775541 = validateParameter(valid_775541, JString, required = false,
                                 default = nil)
  if valid_775541 != nil:
    section.add "ElasticIp", valid_775541
  assert query != nil,
        "query argument is necessary due to required `ClusterIdentifier` field"
  var valid_775542 = query.getOrDefault("ClusterIdentifier")
  valid_775542 = validateParameter(valid_775542, JString, required = true,
                                 default = nil)
  if valid_775542 != nil:
    section.add "ClusterIdentifier", valid_775542
  var valid_775543 = query.getOrDefault("Action")
  valid_775543 = validateParameter(valid_775543, JString, required = true,
                                 default = newJString("ModifyCluster"))
  if valid_775543 != nil:
    section.add "Action", valid_775543
  var valid_775544 = query.getOrDefault("KmsKeyId")
  valid_775544 = validateParameter(valid_775544, JString, required = false,
                                 default = nil)
  if valid_775544 != nil:
    section.add "KmsKeyId", valid_775544
  var valid_775545 = query.getOrDefault("PubliclyAccessible")
  valid_775545 = validateParameter(valid_775545, JBool, required = false, default = nil)
  if valid_775545 != nil:
    section.add "PubliclyAccessible", valid_775545
  var valid_775546 = query.getOrDefault("NumberOfNodes")
  valid_775546 = validateParameter(valid_775546, JInt, required = false, default = nil)
  if valid_775546 != nil:
    section.add "NumberOfNodes", valid_775546
  var valid_775547 = query.getOrDefault("AutomatedSnapshotRetentionPeriod")
  valid_775547 = validateParameter(valid_775547, JInt, required = false, default = nil)
  if valid_775547 != nil:
    section.add "AutomatedSnapshotRetentionPeriod", valid_775547
  var valid_775548 = query.getOrDefault("NodeType")
  valid_775548 = validateParameter(valid_775548, JString, required = false,
                                 default = nil)
  if valid_775548 != nil:
    section.add "NodeType", valid_775548
  var valid_775549 = query.getOrDefault("ClusterVersion")
  valid_775549 = validateParameter(valid_775549, JString, required = false,
                                 default = nil)
  if valid_775549 != nil:
    section.add "ClusterVersion", valid_775549
  var valid_775550 = query.getOrDefault("Version")
  valid_775550 = validateParameter(valid_775550, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_775550 != nil:
    section.add "Version", valid_775550
  var valid_775551 = query.getOrDefault("ClusterType")
  valid_775551 = validateParameter(valid_775551, JString, required = false,
                                 default = nil)
  if valid_775551 != nil:
    section.add "ClusterType", valid_775551
  var valid_775552 = query.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_775552 = validateParameter(valid_775552, JInt, required = false, default = nil)
  if valid_775552 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_775552
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_775553 = header.getOrDefault("X-Amz-Date")
  valid_775553 = validateParameter(valid_775553, JString, required = false,
                                 default = nil)
  if valid_775553 != nil:
    section.add "X-Amz-Date", valid_775553
  var valid_775554 = header.getOrDefault("X-Amz-Security-Token")
  valid_775554 = validateParameter(valid_775554, JString, required = false,
                                 default = nil)
  if valid_775554 != nil:
    section.add "X-Amz-Security-Token", valid_775554
  var valid_775555 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_775555 = validateParameter(valid_775555, JString, required = false,
                                 default = nil)
  if valid_775555 != nil:
    section.add "X-Amz-Content-Sha256", valid_775555
  var valid_775556 = header.getOrDefault("X-Amz-Algorithm")
  valid_775556 = validateParameter(valid_775556, JString, required = false,
                                 default = nil)
  if valid_775556 != nil:
    section.add "X-Amz-Algorithm", valid_775556
  var valid_775557 = header.getOrDefault("X-Amz-Signature")
  valid_775557 = validateParameter(valid_775557, JString, required = false,
                                 default = nil)
  if valid_775557 != nil:
    section.add "X-Amz-Signature", valid_775557
  var valid_775558 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_775558 = validateParameter(valid_775558, JString, required = false,
                                 default = nil)
  if valid_775558 != nil:
    section.add "X-Amz-SignedHeaders", valid_775558
  var valid_775559 = header.getOrDefault("X-Amz-Credential")
  valid_775559 = validateParameter(valid_775559, JString, required = false,
                                 default = nil)
  if valid_775559 != nil:
    section.add "X-Amz-Credential", valid_775559
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_775560: Call_GetModifyCluster_775526; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Modifies the settings for a cluster. For example, you can add another security or parameter group, update the preferred maintenance window, or change the master user password. Resetting a cluster password or modifying the security groups associated with a cluster do not need a reboot. However, modifying a parameter group requires a reboot for parameters to take effect. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>You can also change node type and the number of nodes to scale up or down the cluster. When resizing a cluster, you must specify both the number of nodes and the node type even if one of the parameters does not change.</p>
  ## 
  let valid = call_775560.validator(path, query, header, formData, body)
  let scheme = call_775560.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_775560.url(scheme.get, call_775560.host, call_775560.base,
                         call_775560.route, valid.getOrDefault("path"))
  result = hook(call_775560, url, valid)

proc call*(call_775561: Call_GetModifyCluster_775526; ClusterIdentifier: string;
          ClusterSecurityGroups: JsonNode = nil;
          HsmClientCertificateIdentifier: string = "";
          PreferredMaintenanceWindow: string = ""; Encrypted: bool = false;
          MaintenanceTrackName: string = ""; MasterUserPassword: string = "";
          AllowVersionUpgrade: bool = false; EnhancedVpcRouting: bool = false;
          VpcSecurityGroupIds: JsonNode = nil;
          ClusterParameterGroupName: string = "";
          HsmConfigurationIdentifier: string = "";
          NewClusterIdentifier: string = ""; ElasticIp: string = "";
          Action: string = "ModifyCluster"; KmsKeyId: string = "";
          PubliclyAccessible: bool = false; NumberOfNodes: int = 0;
          AutomatedSnapshotRetentionPeriod: int = 0; NodeType: string = "";
          ClusterVersion: string = ""; Version: string = "2012-12-01";
          ClusterType: string = ""; ManualSnapshotRetentionPeriod: int = 0): Recallable =
  ## getModifyCluster
  ## <p>Modifies the settings for a cluster. For example, you can add another security or parameter group, update the preferred maintenance window, or change the master user password. Resetting a cluster password or modifying the security groups associated with a cluster do not need a reboot. However, modifying a parameter group requires a reboot for parameters to take effect. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>You can also change node type and the number of nodes to scale up or down the cluster. When resizing a cluster, you must specify both the number of nodes and the node type even if one of the parameters does not change.</p>
  ##   ClusterSecurityGroups: JArray
  ##                        : <p>A list of cluster security groups to be authorized on this cluster. This change is asynchronously applied as soon as possible.</p> <p>Security groups currently associated with the cluster, and not in the list of groups to apply, will be revoked from the cluster.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens</p> </li> <li> <p>First character must be a letter</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens</p> </li> </ul>
  ##   HsmClientCertificateIdentifier: string
  ##                                 : Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM.
  ##   PreferredMaintenanceWindow: string
  ##                             : <p>The weekly time range (in UTC) during which system maintenance can occur, if necessary. If system maintenance is necessary during the window, it may result in an outage.</p> <p>This maintenance window change is made immediately. If the new maintenance window indicates the current time, there must be at least 120 minutes between the current time and end of the window in order to ensure that pending changes are applied.</p> <p>Default: Uses existing setting.</p> <p>Format: ddd:hh24:mi-ddd:hh24:mi, for example <code>wed:07:30-wed:08:00</code>.</p> <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p> <p>Constraints: Must be at least 30 minutes.</p>
  ##   Encrypted: bool
  ##            : Indicates whether the cluster is encrypted. If the cluster is encrypted and you provide a value for the <code>KmsKeyId</code> parameter, we will encrypt the cluster with the provided <code>KmsKeyId</code>. If you don't provide a <code>KmsKeyId</code>, we will encrypt with the default key. In the China region we will use legacy encryption if you specify that the cluster is encrypted.
  ##   MaintenanceTrackName: string
  ##                       : The name for the maintenance track that you want to assign for the cluster. This name change is asynchronous. The new track name stays in the <code>PendingModifiedValues</code> for the cluster until the next maintenance window. When the maintenance track changes, the cluster is switched to the latest cluster release available for the maintenance track. At this point, the maintenance track name is applied.
  ##   MasterUserPassword: string
  ##                     : <p>The new password for the cluster master user. This change is asynchronously applied as soon as possible. Between the time of the request and the completion of the request, the <code>MasterUserPassword</code> element exists in the <code>PendingModifiedValues</code> element of the operation response. </p> <note> <p>Operations never return the password, so this operation provides a way to regain access to the master user account for a cluster if the password is lost.</p> </note> <p>Default: Uses existing setting.</p> <p>Constraints:</p> <ul> <li> <p>Must be between 8 and 64 characters in length.</p> </li> <li> <p>Must contain at least one uppercase letter.</p> </li> <li> <p>Must contain at least one lowercase letter.</p> </li> <li> <p>Must contain one number.</p> </li> <li> <p>Can be any printable ASCII character (ASCII code 33 to 126) except ' (single quote), " (double quote), \, /, @, or space.</p> </li> </ul>
  ##   AllowVersionUpgrade: bool
  ##                      : <p>If <code>true</code>, major version upgrades will be applied automatically to the cluster during the maintenance window. </p> <p>Default: <code>false</code> </p>
  ##   EnhancedVpcRouting: bool
  ##                     : <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p> <p>Default: false</p>
  ##   VpcSecurityGroupIds: JArray
  ##                      : A list of virtual private cloud (VPC) security groups to be associated with the cluster. This change is asynchronously applied as soon as possible.
  ##   ClusterParameterGroupName: string
  ##                            : <p>The name of the cluster parameter group to apply to this cluster. This change is applied only after the cluster is rebooted. To reboot a cluster use <a>RebootCluster</a>. </p> <p>Default: Uses existing setting.</p> <p>Constraints: The cluster parameter group must be in the same parameter group family that matches the cluster version.</p>
  ##   HsmConfigurationIdentifier: string
  ##                             : Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
  ##   NewClusterIdentifier: string
  ##                       : <p>The new identifier for the cluster.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul> <p>Example: <code>examplecluster</code> </p>
  ##   ElasticIp: string
  ##            : <p>The Elastic IP (EIP) address for the cluster.</p> <p>Constraints: The cluster must be provisioned in EC2-VPC and publicly-accessible through an Internet gateway. For more information about provisioning clusters in EC2-VPC, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#cluster-platforms">Supported Platforms to Launch Your Cluster</a> in the Amazon Redshift Cluster Management Guide.</p>
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of the cluster to be modified.</p> <p>Example: <code>examplecluster</code> </p>
  ##   Action: string (required)
  ##   KmsKeyId: string
  ##           : The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster.
  ##   PubliclyAccessible: bool
  ##                     : If <code>true</code>, the cluster can be accessed from a public network. Only clusters in VPCs can be set to be publicly available.
  ##   NumberOfNodes: int
  ##                : <p>The new number of nodes of the cluster. If you specify a new number of nodes, you must also specify the node type parameter.</p> <p>When you submit your request to resize a cluster, Amazon Redshift sets access permissions for the cluster to read-only. After Amazon Redshift provisions a new cluster according to your resize requirements, there will be a temporary outage while the old cluster is deleted and your connection is switched to the new cluster. When the new connection is complete, the original access permissions for the cluster are restored. You can use <a>DescribeResize</a> to track the progress of the resize request. </p> <p>Valid Values: Integer greater than <code>0</code>.</p>
  ##   AutomatedSnapshotRetentionPeriod: int
  ##                                   : <p>The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p> <p>If you decrease the automated snapshot retention period from its current value, existing automated snapshots that fall outside of the new retention period will be immediately deleted.</p> <p>Default: Uses existing setting.</p> <p>Constraints: Must be a value from 0 to 35.</p>
  ##   NodeType: string
  ##           : <p>The new node type of the cluster. If you specify a new node type, you must also specify the number of nodes parameter.</p> <p>When you submit your request to resize a cluster, Amazon Redshift sets access permissions for the cluster to read-only. After Amazon Redshift provisions a new cluster according to your resize requirements, there will be a temporary outage while the old cluster is deleted and your connection is switched to the new cluster. When the new connection is complete, the original access permissions for the cluster are restored. You can use <a>DescribeResize</a> to track the progress of the resize request. </p> <p>Valid Values: <code>ds2.xlarge</code> | <code>ds2.8xlarge</code> | <code>dc1.large</code> | <code>dc1.8xlarge</code> | <code>dc2.large</code> | <code>dc2.8xlarge</code> </p>
  ##   ClusterVersion: string
  ##                 : <p>The new version number of the Amazon Redshift engine to upgrade to.</p> <p>For major version upgrades, if a non-default cluster parameter group is currently in use, a new cluster parameter group in the cluster parameter group family for the new version must be specified. The new cluster parameter group can be the default for that cluster parameter group family. For more information about parameters and parameter groups, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>Example: <code>1.0</code> </p>
  ##   Version: string (required)
  ##   ClusterType: string
  ##              : <p>The new cluster type.</p> <p>When you submit your cluster resize request, your existing cluster goes into a read-only mode. After Amazon Redshift provisions a new cluster based on your resize requirements, there will be outage for a period while the old cluster is deleted and your connection is switched to the new cluster. You can use <a>DescribeResize</a> to track the progress of the resize request. </p> <p>Valid Values: <code> multi-node | single-node </code> </p>
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The default for number of days that a newly created manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. This value doesn't retroactively change the retention periods of existing manual snapshots.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  var query_775562 = newJObject()
  if ClusterSecurityGroups != nil:
    query_775562.add "ClusterSecurityGroups", ClusterSecurityGroups
  add(query_775562, "HsmClientCertificateIdentifier",
      newJString(HsmClientCertificateIdentifier))
  add(query_775562, "PreferredMaintenanceWindow",
      newJString(PreferredMaintenanceWindow))
  add(query_775562, "Encrypted", newJBool(Encrypted))
  add(query_775562, "MaintenanceTrackName", newJString(MaintenanceTrackName))
  add(query_775562, "MasterUserPassword", newJString(MasterUserPassword))
  add(query_775562, "AllowVersionUpgrade", newJBool(AllowVersionUpgrade))
  add(query_775562, "EnhancedVpcRouting", newJBool(EnhancedVpcRouting))
  if VpcSecurityGroupIds != nil:
    query_775562.add "VpcSecurityGroupIds", VpcSecurityGroupIds
  add(query_775562, "ClusterParameterGroupName",
      newJString(ClusterParameterGroupName))
  add(query_775562, "HsmConfigurationIdentifier",
      newJString(HsmConfigurationIdentifier))
  add(query_775562, "NewClusterIdentifier", newJString(NewClusterIdentifier))
  add(query_775562, "ElasticIp", newJString(ElasticIp))
  add(query_775562, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_775562, "Action", newJString(Action))
  add(query_775562, "KmsKeyId", newJString(KmsKeyId))
  add(query_775562, "PubliclyAccessible", newJBool(PubliclyAccessible))
  add(query_775562, "NumberOfNodes", newJInt(NumberOfNodes))
  add(query_775562, "AutomatedSnapshotRetentionPeriod",
      newJInt(AutomatedSnapshotRetentionPeriod))
  add(query_775562, "NodeType", newJString(NodeType))
  add(query_775562, "ClusterVersion", newJString(ClusterVersion))
  add(query_775562, "Version", newJString(Version))
  add(query_775562, "ClusterType", newJString(ClusterType))
  add(query_775562, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  result = call_775561.call(nil, query_775562, nil, nil, nil)

var getModifyCluster* = Call_GetModifyCluster_775526(name: "getModifyCluster",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=ModifyCluster", validator: validate_GetModifyCluster_775527,
    base: "/", url: url_GetModifyCluster_775528,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostModifyClusterDbRevision_775618 = ref object of OpenApiRestCall_772581
proc url_PostModifyClusterDbRevision_775620(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_PostModifyClusterDbRevision_775619(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies the database revision of a cluster. The database revision is a unique revision of the database running in a cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_775621 = query.getOrDefault("Action")
  valid_775621 = validateParameter(valid_775621, JString, required = true, default = newJString(
      "ModifyClusterDbRevision"))
  if valid_775621 != nil:
    section.add "Action", valid_775621
  var valid_775622 = query.getOrDefault("Version")
  valid_775622 = validateParameter(valid_775622, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_775622 != nil:
    section.add "Version", valid_775622
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_775623 = header.getOrDefault("X-Amz-Date")
  valid_775623 = validateParameter(valid_775623, JString, required = false,
                                 default = nil)
  if valid_775623 != nil:
    section.add "X-Amz-Date", valid_775623
  var valid_775624 = header.getOrDefault("X-Amz-Security-Token")
  valid_775624 = validateParameter(valid_775624, JString, required = false,
                                 default = nil)
  if valid_775624 != nil:
    section.add "X-Amz-Security-Token", valid_775624
  var valid_775625 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_775625 = validateParameter(valid_775625, JString, required = false,
                                 default = nil)
  if valid_775625 != nil:
    section.add "X-Amz-Content-Sha256", valid_775625
  var valid_775626 = header.getOrDefault("X-Amz-Algorithm")
  valid_775626 = validateParameter(valid_775626, JString, required = false,
                                 default = nil)
  if valid_775626 != nil:
    section.add "X-Amz-Algorithm", valid_775626
  var valid_775627 = header.getOrDefault("X-Amz-Signature")
  valid_775627 = validateParameter(valid_775627, JString, required = false,
                                 default = nil)
  if valid_775627 != nil:
    section.add "X-Amz-Signature", valid_775627
  var valid_775628 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_775628 = validateParameter(valid_775628, JString, required = false,
                                 default = nil)
  if valid_775628 != nil:
    section.add "X-Amz-SignedHeaders", valid_775628
  var valid_775629 = header.getOrDefault("X-Amz-Credential")
  valid_775629 = validateParameter(valid_775629, JString, required = false,
                                 default = nil)
  if valid_775629 != nil:
    section.add "X-Amz-Credential", valid_775629
  result.add "header", section
  ## parameters in `formData` object:
  ##   RevisionTarget: JString (required)
  ##                 : The identifier of the database revision. You can retrieve this value from the response to the <a>DescribeClusterDbRevisions</a> request.
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of a cluster whose database revision you want to modify. </p> <p>Example: <code>examplecluster</code> </p>
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `RevisionTarget` field"
  var valid_775630 = formData.getOrDefault("RevisionTarget")
  valid_775630 = validateParameter(valid_775630, JString, required = true,
                                 default = nil)
  if valid_775630 != nil:
    section.add "RevisionTarget", valid_775630
  var valid_775631 = formData.getOrDefault("ClusterIdentifier")
  valid_775631 = validateParameter(valid_775631, JString, required = true,
                                 default = nil)
  if valid_775631 != nil:
    section.add "ClusterIdentifier", valid_775631
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_775632: Call_PostModifyClusterDbRevision_775618; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Modifies the database revision of a cluster. The database revision is a unique revision of the database running in a cluster.
  ## 
  let valid = call_775632.validator(path, query, header, formData, body)
  let scheme = call_775632.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_775632.url(scheme.get, call_775632.host, call_775632.base,
                         call_775632.route, valid.getOrDefault("path"))
  result = hook(call_775632, url, valid)

proc call*(call_775633: Call_PostModifyClusterDbRevision_775618;
          RevisionTarget: string; ClusterIdentifier: string;
          Action: string = "ModifyClusterDbRevision"; Version: string = "2012-12-01"): Recallable =
  ## postModifyClusterDbRevision
  ## Modifies the database revision of a cluster. The database revision is a unique revision of the database running in a cluster.
  ##   RevisionTarget: string (required)
  ##                 : The identifier of the database revision. You can retrieve this value from the response to the <a>DescribeClusterDbRevisions</a> request.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of a cluster whose database revision you want to modify. </p> <p>Example: <code>examplecluster</code> </p>
  ##   Version: string (required)
  var query_775634 = newJObject()
  var formData_775635 = newJObject()
  add(formData_775635, "RevisionTarget", newJString(RevisionTarget))
  add(query_775634, "Action", newJString(Action))
  add(formData_775635, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_775634, "Version", newJString(Version))
  result = call_775633.call(nil, query_775634, nil, formData_775635, nil)

var postModifyClusterDbRevision* = Call_PostModifyClusterDbRevision_775618(
    name: "postModifyClusterDbRevision", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyClusterDbRevision",
    validator: validate_PostModifyClusterDbRevision_775619, base: "/",
    url: url_PostModifyClusterDbRevision_775620,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetModifyClusterDbRevision_775601 = ref object of OpenApiRestCall_772581
proc url_GetModifyClusterDbRevision_775603(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_GetModifyClusterDbRevision_775602(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies the database revision of a cluster. The database revision is a unique revision of the database running in a cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   RevisionTarget: JString (required)
  ##                 : The identifier of the database revision. You can retrieve this value from the response to the <a>DescribeClusterDbRevisions</a> request.
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of a cluster whose database revision you want to modify. </p> <p>Example: <code>examplecluster</code> </p>
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `RevisionTarget` field"
  var valid_775604 = query.getOrDefault("RevisionTarget")
  valid_775604 = validateParameter(valid_775604, JString, required = true,
                                 default = nil)
  if valid_775604 != nil:
    section.add "RevisionTarget", valid_775604
  var valid_775605 = query.getOrDefault("Action")
  valid_775605 = validateParameter(valid_775605, JString, required = true, default = newJString(
      "ModifyClusterDbRevision"))
  if valid_775605 != nil:
    section.add "Action", valid_775605
  var valid_775606 = query.getOrDefault("ClusterIdentifier")
  valid_775606 = validateParameter(valid_775606, JString, required = true,
                                 default = nil)
  if valid_775606 != nil:
    section.add "ClusterIdentifier", valid_775606
  var valid_775607 = query.getOrDefault("Version")
  valid_775607 = validateParameter(valid_775607, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_775607 != nil:
    section.add "Version", valid_775607
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_775608 = header.getOrDefault("X-Amz-Date")
  valid_775608 = validateParameter(valid_775608, JString, required = false,
                                 default = nil)
  if valid_775608 != nil:
    section.add "X-Amz-Date", valid_775608
  var valid_775609 = header.getOrDefault("X-Amz-Security-Token")
  valid_775609 = validateParameter(valid_775609, JString, required = false,
                                 default = nil)
  if valid_775609 != nil:
    section.add "X-Amz-Security-Token", valid_775609
  var valid_775610 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_775610 = validateParameter(valid_775610, JString, required = false,
                                 default = nil)
  if valid_775610 != nil:
    section.add "X-Amz-Content-Sha256", valid_775610
  var valid_775611 = header.getOrDefault("X-Amz-Algorithm")
  valid_775611 = validateParameter(valid_775611, JString, required = false,
                                 default = nil)
  if valid_775611 != nil:
    section.add "X-Amz-Algorithm", valid_775611
  var valid_775612 = header.getOrDefault("X-Amz-Signature")
  valid_775612 = validateParameter(valid_775612, JString, required = false,
                                 default = nil)
  if valid_775612 != nil:
    section.add "X-Amz-Signature", valid_775612
  var valid_775613 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_775613 = validateParameter(valid_775613, JString, required = false,
                                 default = nil)
  if valid_775613 != nil:
    section.add "X-Amz-SignedHeaders", valid_775613
  var valid_775614 = header.getOrDefault("X-Amz-Credential")
  valid_775614 = validateParameter(valid_775614, JString, required = false,
                                 default = nil)
  if valid_775614 != nil:
    section.add "X-Amz-Credential", valid_775614
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_775615: Call_GetModifyClusterDbRevision_775601; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Modifies the database revision of a cluster. The database revision is a unique revision of the database running in a cluster.
  ## 
  let valid = call_775615.validator(path, query, header, formData, body)
  let scheme = call_775615.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_775615.url(scheme.get, call_775615.host, call_775615.base,
                         call_775615.route, valid.getOrDefault("path"))
  result = hook(call_775615, url, valid)

proc call*(call_775616: Call_GetModifyClusterDbRevision_775601;
          RevisionTarget: string; ClusterIdentifier: string;
          Action: string = "ModifyClusterDbRevision"; Version: string = "2012-12-01"): Recallable =
  ## getModifyClusterDbRevision
  ## Modifies the database revision of a cluster. The database revision is a unique revision of the database running in a cluster.
  ##   RevisionTarget: string (required)
  ##                 : The identifier of the database revision. You can retrieve this value from the response to the <a>DescribeClusterDbRevisions</a> request.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of a cluster whose database revision you want to modify. </p> <p>Example: <code>examplecluster</code> </p>
  ##   Version: string (required)
  var query_775617 = newJObject()
  add(query_775617, "RevisionTarget", newJString(RevisionTarget))
  add(query_775617, "Action", newJString(Action))
  add(query_775617, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_775617, "Version", newJString(Version))
  result = call_775616.call(nil, query_775617, nil, nil, nil)

var getModifyClusterDbRevision* = Call_GetModifyClusterDbRevision_775601(
    name: "getModifyClusterDbRevision", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyClusterDbRevision",
    validator: validate_GetModifyClusterDbRevision_775602, base: "/",
    url: url_GetModifyClusterDbRevision_775603,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostModifyClusterIamRoles_775654 = ref object of OpenApiRestCall_772581
proc url_PostModifyClusterIamRoles_775656(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_PostModifyClusterIamRoles_775655(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Modifies the list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services.</p> <p>A cluster can have up to 10 IAM roles associated at any time.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_775657 = query.getOrDefault("Action")
  valid_775657 = validateParameter(valid_775657, JString, required = true,
                                 default = newJString("ModifyClusterIamRoles"))
  if valid_775657 != nil:
    section.add "Action", valid_775657
  var valid_775658 = query.getOrDefault("Version")
  valid_775658 = validateParameter(valid_775658, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_775658 != nil:
    section.add "Version", valid_775658
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_775659 = header.getOrDefault("X-Amz-Date")
  valid_775659 = validateParameter(valid_775659, JString, required = false,
                                 default = nil)
  if valid_775659 != nil:
    section.add "X-Amz-Date", valid_775659
  var valid_775660 = header.getOrDefault("X-Amz-Security-Token")
  valid_775660 = validateParameter(valid_775660, JString, required = false,
                                 default = nil)
  if valid_775660 != nil:
    section.add "X-Amz-Security-Token", valid_775660
  var valid_775661 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_775661 = validateParameter(valid_775661, JString, required = false,
                                 default = nil)
  if valid_775661 != nil:
    section.add "X-Amz-Content-Sha256", valid_775661
  var valid_775662 = header.getOrDefault("X-Amz-Algorithm")
  valid_775662 = validateParameter(valid_775662, JString, required = false,
                                 default = nil)
  if valid_775662 != nil:
    section.add "X-Amz-Algorithm", valid_775662
  var valid_775663 = header.getOrDefault("X-Amz-Signature")
  valid_775663 = validateParameter(valid_775663, JString, required = false,
                                 default = nil)
  if valid_775663 != nil:
    section.add "X-Amz-Signature", valid_775663
  var valid_775664 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_775664 = validateParameter(valid_775664, JString, required = false,
                                 default = nil)
  if valid_775664 != nil:
    section.add "X-Amz-SignedHeaders", valid_775664
  var valid_775665 = header.getOrDefault("X-Amz-Credential")
  valid_775665 = validateParameter(valid_775665, JString, required = false,
                                 default = nil)
  if valid_775665 != nil:
    section.add "X-Amz-Credential", valid_775665
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : The unique identifier of the cluster for which you want to associate or disassociate IAM roles.
  ##   AddIamRoles: JArray
  ##              : Zero or more IAM roles to associate with the cluster. The roles must be in their Amazon Resource Name (ARN) format. You can associate up to 10 IAM roles with a single cluster in a single request.
  ##   RemoveIamRoles: JArray
  ##                 : Zero or more IAM roles in ARN format to disassociate from the cluster. You can disassociate up to 10 IAM roles from a single cluster in a single request.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_775666 = formData.getOrDefault("ClusterIdentifier")
  valid_775666 = validateParameter(valid_775666, JString, required = true,
                                 default = nil)
  if valid_775666 != nil:
    section.add "ClusterIdentifier", valid_775666
  var valid_775667 = formData.getOrDefault("AddIamRoles")
  valid_775667 = validateParameter(valid_775667, JArray, required = false,
                                 default = nil)
  if valid_775667 != nil:
    section.add "AddIamRoles", valid_775667
  var valid_775668 = formData.getOrDefault("RemoveIamRoles")
  valid_775668 = validateParameter(valid_775668, JArray, required = false,
                                 default = nil)
  if valid_775668 != nil:
    section.add "RemoveIamRoles", valid_775668
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_775669: Call_PostModifyClusterIamRoles_775654; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Modifies the list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services.</p> <p>A cluster can have up to 10 IAM roles associated at any time.</p>
  ## 
  let valid = call_775669.validator(path, query, header, formData, body)
  let scheme = call_775669.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_775669.url(scheme.get, call_775669.host, call_775669.base,
                         call_775669.route, valid.getOrDefault("path"))
  result = hook(call_775669, url, valid)

proc call*(call_775670: Call_PostModifyClusterIamRoles_775654;
          ClusterIdentifier: string; Action: string = "ModifyClusterIamRoles";
          AddIamRoles: JsonNode = nil; RemoveIamRoles: JsonNode = nil;
          Version: string = "2012-12-01"): Recallable =
  ## postModifyClusterIamRoles
  ## <p>Modifies the list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services.</p> <p>A cluster can have up to 10 IAM roles associated at any time.</p>
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : The unique identifier of the cluster for which you want to associate or disassociate IAM roles.
  ##   AddIamRoles: JArray
  ##              : Zero or more IAM roles to associate with the cluster. The roles must be in their Amazon Resource Name (ARN) format. You can associate up to 10 IAM roles with a single cluster in a single request.
  ##   RemoveIamRoles: JArray
  ##                 : Zero or more IAM roles in ARN format to disassociate from the cluster. You can disassociate up to 10 IAM roles from a single cluster in a single request.
  ##   Version: string (required)
  var query_775671 = newJObject()
  var formData_775672 = newJObject()
  add(query_775671, "Action", newJString(Action))
  add(formData_775672, "ClusterIdentifier", newJString(ClusterIdentifier))
  if AddIamRoles != nil:
    formData_775672.add "AddIamRoles", AddIamRoles
  if RemoveIamRoles != nil:
    formData_775672.add "RemoveIamRoles", RemoveIamRoles
  add(query_775671, "Version", newJString(Version))
  result = call_775670.call(nil, query_775671, nil, formData_775672, nil)

var postModifyClusterIamRoles* = Call_PostModifyClusterIamRoles_775654(
    name: "postModifyClusterIamRoles", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyClusterIamRoles",
    validator: validate_PostModifyClusterIamRoles_775655, base: "/",
    url: url_PostModifyClusterIamRoles_775656,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetModifyClusterIamRoles_775636 = ref object of OpenApiRestCall_772581
proc url_GetModifyClusterIamRoles_775638(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_GetModifyClusterIamRoles_775637(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Modifies the list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services.</p> <p>A cluster can have up to 10 IAM roles associated at any time.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   AddIamRoles: JArray
  ##              : Zero or more IAM roles to associate with the cluster. The roles must be in their Amazon Resource Name (ARN) format. You can associate up to 10 IAM roles with a single cluster in a single request.
  ##   RemoveIamRoles: JArray
  ##                 : Zero or more IAM roles in ARN format to disassociate from the cluster. You can disassociate up to 10 IAM roles from a single cluster in a single request.
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : The unique identifier of the cluster for which you want to associate or disassociate IAM roles.
  ##   Version: JString (required)
  section = newJObject()
  var valid_775639 = query.getOrDefault("AddIamRoles")
  valid_775639 = validateParameter(valid_775639, JArray, required = false,
                                 default = nil)
  if valid_775639 != nil:
    section.add "AddIamRoles", valid_775639
  var valid_775640 = query.getOrDefault("RemoveIamRoles")
  valid_775640 = validateParameter(valid_775640, JArray, required = false,
                                 default = nil)
  if valid_775640 != nil:
    section.add "RemoveIamRoles", valid_775640
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_775641 = query.getOrDefault("Action")
  valid_775641 = validateParameter(valid_775641, JString, required = true,
                                 default = newJString("ModifyClusterIamRoles"))
  if valid_775641 != nil:
    section.add "Action", valid_775641
  var valid_775642 = query.getOrDefault("ClusterIdentifier")
  valid_775642 = validateParameter(valid_775642, JString, required = true,
                                 default = nil)
  if valid_775642 != nil:
    section.add "ClusterIdentifier", valid_775642
  var valid_775643 = query.getOrDefault("Version")
  valid_775643 = validateParameter(valid_775643, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_775643 != nil:
    section.add "Version", valid_775643
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_775644 = header.getOrDefault("X-Amz-Date")
  valid_775644 = validateParameter(valid_775644, JString, required = false,
                                 default = nil)
  if valid_775644 != nil:
    section.add "X-Amz-Date", valid_775644
  var valid_775645 = header.getOrDefault("X-Amz-Security-Token")
  valid_775645 = validateParameter(valid_775645, JString, required = false,
                                 default = nil)
  if valid_775645 != nil:
    section.add "X-Amz-Security-Token", valid_775645
  var valid_775646 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_775646 = validateParameter(valid_775646, JString, required = false,
                                 default = nil)
  if valid_775646 != nil:
    section.add "X-Amz-Content-Sha256", valid_775646
  var valid_775647 = header.getOrDefault("X-Amz-Algorithm")
  valid_775647 = validateParameter(valid_775647, JString, required = false,
                                 default = nil)
  if valid_775647 != nil:
    section.add "X-Amz-Algorithm", valid_775647
  var valid_775648 = header.getOrDefault("X-Amz-Signature")
  valid_775648 = validateParameter(valid_775648, JString, required = false,
                                 default = nil)
  if valid_775648 != nil:
    section.add "X-Amz-Signature", valid_775648
  var valid_775649 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_775649 = validateParameter(valid_775649, JString, required = false,
                                 default = nil)
  if valid_775649 != nil:
    section.add "X-Amz-SignedHeaders", valid_775649
  var valid_775650 = header.getOrDefault("X-Amz-Credential")
  valid_775650 = validateParameter(valid_775650, JString, required = false,
                                 default = nil)
  if valid_775650 != nil:
    section.add "X-Amz-Credential", valid_775650
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_775651: Call_GetModifyClusterIamRoles_775636; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Modifies the list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services.</p> <p>A cluster can have up to 10 IAM roles associated at any time.</p>
  ## 
  let valid = call_775651.validator(path, query, header, formData, body)
  let scheme = call_775651.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_775651.url(scheme.get, call_775651.host, call_775651.base,
                         call_775651.route, valid.getOrDefault("path"))
  result = hook(call_775651, url, valid)

proc call*(call_775652: Call_GetModifyClusterIamRoles_775636;
          ClusterIdentifier: string; AddIamRoles: JsonNode = nil;
          RemoveIamRoles: JsonNode = nil; Action: string = "ModifyClusterIamRoles";
          Version: string = "2012-12-01"): Recallable =
  ## getModifyClusterIamRoles
  ## <p>Modifies the list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services.</p> <p>A cluster can have up to 10 IAM roles associated at any time.</p>
  ##   AddIamRoles: JArray
  ##              : Zero or more IAM roles to associate with the cluster. The roles must be in their Amazon Resource Name (ARN) format. You can associate up to 10 IAM roles with a single cluster in a single request.
  ##   RemoveIamRoles: JArray
  ##                 : Zero or more IAM roles in ARN format to disassociate from the cluster. You can disassociate up to 10 IAM roles from a single cluster in a single request.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : The unique identifier of the cluster for which you want to associate or disassociate IAM roles.
  ##   Version: string (required)
  var query_775653 = newJObject()
  if AddIamRoles != nil:
    query_775653.add "AddIamRoles", AddIamRoles
  if RemoveIamRoles != nil:
    query_775653.add "RemoveIamRoles", RemoveIamRoles
  add(query_775653, "Action", newJString(Action))
  add(query_775653, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_775653, "Version", newJString(Version))
  result = call_775652.call(nil, query_775653, nil, nil, nil)

var getModifyClusterIamRoles* = Call_GetModifyClusterIamRoles_775636(
    name: "getModifyClusterIamRoles", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyClusterIamRoles",
    validator: validate_GetModifyClusterIamRoles_775637, base: "/",
    url: url_GetModifyClusterIamRoles_775638, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostModifyClusterMaintenance_775694 = ref object of OpenApiRestCall_772581
proc url_PostModifyClusterMaintenance_775696(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_PostModifyClusterMaintenance_775695(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies the maintenance settings of a cluster. For example, you can defer a maintenance window. You can also update or cancel a deferment. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_775697 = query.getOrDefault("Action")
  valid_775697 = validateParameter(valid_775697, JString, required = true, default = newJString(
      "ModifyClusterMaintenance"))
  if valid_775697 != nil:
    section.add "Action", valid_775697
  var valid_775698 = query.getOrDefault("Version")
  valid_775698 = validateParameter(valid_775698, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_775698 != nil:
    section.add "Version", valid_775698
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_775699 = header.getOrDefault("X-Amz-Date")
  valid_775699 = validateParameter(valid_775699, JString, required = false,
                                 default = nil)
  if valid_775699 != nil:
    section.add "X-Amz-Date", valid_775699
  var valid_775700 = header.getOrDefault("X-Amz-Security-Token")
  valid_775700 = validateParameter(valid_775700, JString, required = false,
                                 default = nil)
  if valid_775700 != nil:
    section.add "X-Amz-Security-Token", valid_775700
  var valid_775701 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_775701 = validateParameter(valid_775701, JString, required = false,
                                 default = nil)
  if valid_775701 != nil:
    section.add "X-Amz-Content-Sha256", valid_775701
  var valid_775702 = header.getOrDefault("X-Amz-Algorithm")
  valid_775702 = validateParameter(valid_775702, JString, required = false,
                                 default = nil)
  if valid_775702 != nil:
    section.add "X-Amz-Algorithm", valid_775702
  var valid_775703 = header.getOrDefault("X-Amz-Signature")
  valid_775703 = validateParameter(valid_775703, JString, required = false,
                                 default = nil)
  if valid_775703 != nil:
    section.add "X-Amz-Signature", valid_775703
  var valid_775704 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_775704 = validateParameter(valid_775704, JString, required = false,
                                 default = nil)
  if valid_775704 != nil:
    section.add "X-Amz-SignedHeaders", valid_775704
  var valid_775705 = header.getOrDefault("X-Amz-Credential")
  valid_775705 = validateParameter(valid_775705, JString, required = false,
                                 default = nil)
  if valid_775705 != nil:
    section.add "X-Amz-Credential", valid_775705
  result.add "header", section
  ## parameters in `formData` object:
  ##   DeferMaintenanceDuration: JInt
  ##                           : An integer indicating the duration of the maintenance window in days. If you specify a duration, you can't specify an end time. The duration must be 45 days or less.
  ##   DeferMaintenanceIdentifier: JString
  ##                             : A unique identifier for the deferred maintenance window.
  ##   DeferMaintenanceStartTime: JString
  ##                            : A timestamp indicating the start time for the deferred maintenance window.
  ##   ClusterIdentifier: JString (required)
  ##                    : A unique identifier for the cluster.
  ##   DeferMaintenanceEndTime: JString
  ##                          : A timestamp indicating end time for the deferred maintenance window. If you specify an end time, you can't specify a duration.
  ##   DeferMaintenance: JBool
  ##                   : A boolean indicating whether to enable the deferred maintenance window. 
  section = newJObject()
  var valid_775706 = formData.getOrDefault("DeferMaintenanceDuration")
  valid_775706 = validateParameter(valid_775706, JInt, required = false, default = nil)
  if valid_775706 != nil:
    section.add "DeferMaintenanceDuration", valid_775706
  var valid_775707 = formData.getOrDefault("DeferMaintenanceIdentifier")
  valid_775707 = validateParameter(valid_775707, JString, required = false,
                                 default = nil)
  if valid_775707 != nil:
    section.add "DeferMaintenanceIdentifier", valid_775707
  var valid_775708 = formData.getOrDefault("DeferMaintenanceStartTime")
  valid_775708 = validateParameter(valid_775708, JString, required = false,
                                 default = nil)
  if valid_775708 != nil:
    section.add "DeferMaintenanceStartTime", valid_775708
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_775709 = formData.getOrDefault("ClusterIdentifier")
  valid_775709 = validateParameter(valid_775709, JString, required = true,
                                 default = nil)
  if valid_775709 != nil:
    section.add "ClusterIdentifier", valid_775709
  var valid_775710 = formData.getOrDefault("DeferMaintenanceEndTime")
  valid_775710 = validateParameter(valid_775710, JString, required = false,
                                 default = nil)
  if valid_775710 != nil:
    section.add "DeferMaintenanceEndTime", valid_775710
  var valid_775711 = formData.getOrDefault("DeferMaintenance")
  valid_775711 = validateParameter(valid_775711, JBool, required = false, default = nil)
  if valid_775711 != nil:
    section.add "DeferMaintenance", valid_775711
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_775712: Call_PostModifyClusterMaintenance_775694; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Modifies the maintenance settings of a cluster. For example, you can defer a maintenance window. You can also update or cancel a deferment. 
  ## 
  let valid = call_775712.validator(path, query, header, formData, body)
  let scheme = call_775712.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_775712.url(scheme.get, call_775712.host, call_775712.base,
                         call_775712.route, valid.getOrDefault("path"))
  result = hook(call_775712, url, valid)

proc call*(call_775713: Call_PostModifyClusterMaintenance_775694;
          ClusterIdentifier: string; DeferMaintenanceDuration: int = 0;
          DeferMaintenanceIdentifier: string = "";
          Action: string = "ModifyClusterMaintenance";
          DeferMaintenanceStartTime: string = "";
          DeferMaintenanceEndTime: string = ""; DeferMaintenance: bool = false;
          Version: string = "2012-12-01"): Recallable =
  ## postModifyClusterMaintenance
  ## Modifies the maintenance settings of a cluster. For example, you can defer a maintenance window. You can also update or cancel a deferment. 
  ##   DeferMaintenanceDuration: int
  ##                           : An integer indicating the duration of the maintenance window in days. If you specify a duration, you can't specify an end time. The duration must be 45 days or less.
  ##   DeferMaintenanceIdentifier: string
  ##                             : A unique identifier for the deferred maintenance window.
  ##   Action: string (required)
  ##   DeferMaintenanceStartTime: string
  ##                            : A timestamp indicating the start time for the deferred maintenance window.
  ##   ClusterIdentifier: string (required)
  ##                    : A unique identifier for the cluster.
  ##   DeferMaintenanceEndTime: string
  ##                          : A timestamp indicating end time for the deferred maintenance window. If you specify an end time, you can't specify a duration.
  ##   DeferMaintenance: bool
  ##                   : A boolean indicating whether to enable the deferred maintenance window. 
  ##   Version: string (required)
  var query_775714 = newJObject()
  var formData_775715 = newJObject()
  add(formData_775715, "DeferMaintenanceDuration",
      newJInt(DeferMaintenanceDuration))
  add(formData_775715, "DeferMaintenanceIdentifier",
      newJString(DeferMaintenanceIdentifier))
  add(query_775714, "Action", newJString(Action))
  add(formData_775715, "DeferMaintenanceStartTime",
      newJString(DeferMaintenanceStartTime))
  add(formData_775715, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_775715, "DeferMaintenanceEndTime",
      newJString(DeferMaintenanceEndTime))
  add(formData_775715, "DeferMaintenance", newJBool(DeferMaintenance))
  add(query_775714, "Version", newJString(Version))
  result = call_775713.call(nil, query_775714, nil, formData_775715, nil)

var postModifyClusterMaintenance* = Call_PostModifyClusterMaintenance_775694(
    name: "postModifyClusterMaintenance", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyClusterMaintenance",
    validator: validate_PostModifyClusterMaintenance_775695, base: "/",
    url: url_PostModifyClusterMaintenance_775696,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetModifyClusterMaintenance_775673 = ref object of OpenApiRestCall_772581
proc url_GetModifyClusterMaintenance_775675(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_GetModifyClusterMaintenance_775674(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies the maintenance settings of a cluster. For example, you can defer a maintenance window. You can also update or cancel a deferment. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   DeferMaintenanceStartTime: JString
  ##                            : A timestamp indicating the start time for the deferred maintenance window.
  ##   DeferMaintenanceDuration: JInt
  ##                           : An integer indicating the duration of the maintenance window in days. If you specify a duration, you can't specify an end time. The duration must be 45 days or less.
  ##   DeferMaintenanceEndTime: JString
  ##                          : A timestamp indicating end time for the deferred maintenance window. If you specify an end time, you can't specify a duration.
  ##   DeferMaintenanceIdentifier: JString
  ##                             : A unique identifier for the deferred maintenance window.
  ##   DeferMaintenance: JBool
  ##                   : A boolean indicating whether to enable the deferred maintenance window. 
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : A unique identifier for the cluster.
  ##   Version: JString (required)
  section = newJObject()
  var valid_775676 = query.getOrDefault("DeferMaintenanceStartTime")
  valid_775676 = validateParameter(valid_775676, JString, required = false,
                                 default = nil)
  if valid_775676 != nil:
    section.add "DeferMaintenanceStartTime", valid_775676
  var valid_775677 = query.getOrDefault("DeferMaintenanceDuration")
  valid_775677 = validateParameter(valid_775677, JInt, required = false, default = nil)
  if valid_775677 != nil:
    section.add "DeferMaintenanceDuration", valid_775677
  var valid_775678 = query.getOrDefault("DeferMaintenanceEndTime")
  valid_775678 = validateParameter(valid_775678, JString, required = false,
                                 default = nil)
  if valid_775678 != nil:
    section.add "DeferMaintenanceEndTime", valid_775678
  var valid_775679 = query.getOrDefault("DeferMaintenanceIdentifier")
  valid_775679 = validateParameter(valid_775679, JString, required = false,
                                 default = nil)
  if valid_775679 != nil:
    section.add "DeferMaintenanceIdentifier", valid_775679
  var valid_775680 = query.getOrDefault("DeferMaintenance")
  valid_775680 = validateParameter(valid_775680, JBool, required = false, default = nil)
  if valid_775680 != nil:
    section.add "DeferMaintenance", valid_775680
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_775681 = query.getOrDefault("Action")
  valid_775681 = validateParameter(valid_775681, JString, required = true, default = newJString(
      "ModifyClusterMaintenance"))
  if valid_775681 != nil:
    section.add "Action", valid_775681
  var valid_775682 = query.getOrDefault("ClusterIdentifier")
  valid_775682 = validateParameter(valid_775682, JString, required = true,
                                 default = nil)
  if valid_775682 != nil:
    section.add "ClusterIdentifier", valid_775682
  var valid_775683 = query.getOrDefault("Version")
  valid_775683 = validateParameter(valid_775683, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_775683 != nil:
    section.add "Version", valid_775683
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_775684 = header.getOrDefault("X-Amz-Date")
  valid_775684 = validateParameter(valid_775684, JString, required = false,
                                 default = nil)
  if valid_775684 != nil:
    section.add "X-Amz-Date", valid_775684
  var valid_775685 = header.getOrDefault("X-Amz-Security-Token")
  valid_775685 = validateParameter(valid_775685, JString, required = false,
                                 default = nil)
  if valid_775685 != nil:
    section.add "X-Amz-Security-Token", valid_775685
  var valid_775686 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_775686 = validateParameter(valid_775686, JString, required = false,
                                 default = nil)
  if valid_775686 != nil:
    section.add "X-Amz-Content-Sha256", valid_775686
  var valid_775687 = header.getOrDefault("X-Amz-Algorithm")
  valid_775687 = validateParameter(valid_775687, JString, required = false,
                                 default = nil)
  if valid_775687 != nil:
    section.add "X-Amz-Algorithm", valid_775687
  var valid_775688 = header.getOrDefault("X-Amz-Signature")
  valid_775688 = validateParameter(valid_775688, JString, required = false,
                                 default = nil)
  if valid_775688 != nil:
    section.add "X-Amz-Signature", valid_775688
  var valid_775689 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_775689 = validateParameter(valid_775689, JString, required = false,
                                 default = nil)
  if valid_775689 != nil:
    section.add "X-Amz-SignedHeaders", valid_775689
  var valid_775690 = header.getOrDefault("X-Amz-Credential")
  valid_775690 = validateParameter(valid_775690, JString, required = false,
                                 default = nil)
  if valid_775690 != nil:
    section.add "X-Amz-Credential", valid_775690
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_775691: Call_GetModifyClusterMaintenance_775673; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Modifies the maintenance settings of a cluster. For example, you can defer a maintenance window. You can also update or cancel a deferment. 
  ## 
  let valid = call_775691.validator(path, query, header, formData, body)
  let scheme = call_775691.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_775691.url(scheme.get, call_775691.host, call_775691.base,
                         call_775691.route, valid.getOrDefault("path"))
  result = hook(call_775691, url, valid)

proc call*(call_775692: Call_GetModifyClusterMaintenance_775673;
          ClusterIdentifier: string; DeferMaintenanceStartTime: string = "";
          DeferMaintenanceDuration: int = 0; DeferMaintenanceEndTime: string = "";
          DeferMaintenanceIdentifier: string = ""; DeferMaintenance: bool = false;
          Action: string = "ModifyClusterMaintenance";
          Version: string = "2012-12-01"): Recallable =
  ## getModifyClusterMaintenance
  ## Modifies the maintenance settings of a cluster. For example, you can defer a maintenance window. You can also update or cancel a deferment. 
  ##   DeferMaintenanceStartTime: string
  ##                            : A timestamp indicating the start time for the deferred maintenance window.
  ##   DeferMaintenanceDuration: int
  ##                           : An integer indicating the duration of the maintenance window in days. If you specify a duration, you can't specify an end time. The duration must be 45 days or less.
  ##   DeferMaintenanceEndTime: string
  ##                          : A timestamp indicating end time for the deferred maintenance window. If you specify an end time, you can't specify a duration.
  ##   DeferMaintenanceIdentifier: string
  ##                             : A unique identifier for the deferred maintenance window.
  ##   DeferMaintenance: bool
  ##                   : A boolean indicating whether to enable the deferred maintenance window. 
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : A unique identifier for the cluster.
  ##   Version: string (required)
  var query_775693 = newJObject()
  add(query_775693, "DeferMaintenanceStartTime",
      newJString(DeferMaintenanceStartTime))
  add(query_775693, "DeferMaintenanceDuration", newJInt(DeferMaintenanceDuration))
  add(query_775693, "DeferMaintenanceEndTime", newJString(DeferMaintenanceEndTime))
  add(query_775693, "DeferMaintenanceIdentifier",
      newJString(DeferMaintenanceIdentifier))
  add(query_775693, "DeferMaintenance", newJBool(DeferMaintenance))
  add(query_775693, "Action", newJString(Action))
  add(query_775693, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_775693, "Version", newJString(Version))
  result = call_775692.call(nil, query_775693, nil, nil, nil)

var getModifyClusterMaintenance* = Call_GetModifyClusterMaintenance_775673(
    name: "getModifyClusterMaintenance", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyClusterMaintenance",
    validator: validate_GetModifyClusterMaintenance_775674, base: "/",
    url: url_GetModifyClusterMaintenance_775675,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostModifyClusterParameterGroup_775733 = ref object of OpenApiRestCall_772581
proc url_PostModifyClusterParameterGroup_775735(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_PostModifyClusterParameterGroup_775734(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Modifies the parameters of a parameter group.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_775736 = query.getOrDefault("Action")
  valid_775736 = validateParameter(valid_775736, JString, required = true, default = newJString(
      "ModifyClusterParameterGroup"))
  if valid_775736 != nil:
    section.add "Action", valid_775736
  var valid_775737 = query.getOrDefault("Version")
  valid_775737 = validateParameter(valid_775737, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_775737 != nil:
    section.add "Version", valid_775737
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_775738 = header.getOrDefault("X-Amz-Date")
  valid_775738 = validateParameter(valid_775738, JString, required = false,
                                 default = nil)
  if valid_775738 != nil:
    section.add "X-Amz-Date", valid_775738
  var valid_775739 = header.getOrDefault("X-Amz-Security-Token")
  valid_775739 = validateParameter(valid_775739, JString, required = false,
                                 default = nil)
  if valid_775739 != nil:
    section.add "X-Amz-Security-Token", valid_775739
  var valid_775740 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_775740 = validateParameter(valid_775740, JString, required = false,
                                 default = nil)
  if valid_775740 != nil:
    section.add "X-Amz-Content-Sha256", valid_775740
  var valid_775741 = header.getOrDefault("X-Amz-Algorithm")
  valid_775741 = validateParameter(valid_775741, JString, required = false,
                                 default = nil)
  if valid_775741 != nil:
    section.add "X-Amz-Algorithm", valid_775741
  var valid_775742 = header.getOrDefault("X-Amz-Signature")
  valid_775742 = validateParameter(valid_775742, JString, required = false,
                                 default = nil)
  if valid_775742 != nil:
    section.add "X-Amz-Signature", valid_775742
  var valid_775743 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_775743 = validateParameter(valid_775743, JString, required = false,
                                 default = nil)
  if valid_775743 != nil:
    section.add "X-Amz-SignedHeaders", valid_775743
  var valid_775744 = header.getOrDefault("X-Amz-Credential")
  valid_775744 = validateParameter(valid_775744, JString, required = false,
                                 default = nil)
  if valid_775744 != nil:
    section.add "X-Amz-Credential", valid_775744
  result.add "header", section
  ## parameters in `formData` object:
  ##   ParameterGroupName: JString (required)
  ##                     : The name of the parameter group to be modified.
  ##   Parameters: JArray (required)
  ##             : <p>An array of parameters to be modified. A maximum of 20 parameters can be modified in a single request.</p> <p>For each parameter to be modified, you must supply at least the parameter name and parameter value; other name-value pairs of the parameter are optional.</p> <p>For the workload management (WLM) configuration, you must supply all the name-value pairs in the wlm_json_configuration parameter.</p>
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ParameterGroupName` field"
  var valid_775745 = formData.getOrDefault("ParameterGroupName")
  valid_775745 = validateParameter(valid_775745, JString, required = true,
                                 default = nil)
  if valid_775745 != nil:
    section.add "ParameterGroupName", valid_775745
  var valid_775746 = formData.getOrDefault("Parameters")
  valid_775746 = validateParameter(valid_775746, JArray, required = true, default = nil)
  if valid_775746 != nil:
    section.add "Parameters", valid_775746
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_775747: Call_PostModifyClusterParameterGroup_775733;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Modifies the parameters of a parameter group.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_775747.validator(path, query, header, formData, body)
  let scheme = call_775747.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_775747.url(scheme.get, call_775747.host, call_775747.base,
                         call_775747.route, valid.getOrDefault("path"))
  result = hook(call_775747, url, valid)

proc call*(call_775748: Call_PostModifyClusterParameterGroup_775733;
          ParameterGroupName: string; Parameters: JsonNode;
          Action: string = "ModifyClusterParameterGroup";
          Version: string = "2012-12-01"): Recallable =
  ## postModifyClusterParameterGroup
  ## <p>Modifies the parameters of a parameter group.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   ParameterGroupName: string (required)
  ##                     : The name of the parameter group to be modified.
  ##   Parameters: JArray (required)
  ##             : <p>An array of parameters to be modified. A maximum of 20 parameters can be modified in a single request.</p> <p>For each parameter to be modified, you must supply at least the parameter name and parameter value; other name-value pairs of the parameter are optional.</p> <p>For the workload management (WLM) configuration, you must supply all the name-value pairs in the wlm_json_configuration parameter.</p>
  ##   Action: string (required)
  ##   Version: string (required)
  var query_775749 = newJObject()
  var formData_775750 = newJObject()
  add(formData_775750, "ParameterGroupName", newJString(ParameterGroupName))
  if Parameters != nil:
    formData_775750.add "Parameters", Parameters
  add(query_775749, "Action", newJString(Action))
  add(query_775749, "Version", newJString(Version))
  result = call_775748.call(nil, query_775749, nil, formData_775750, nil)

var postModifyClusterParameterGroup* = Call_PostModifyClusterParameterGroup_775733(
    name: "postModifyClusterParameterGroup", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyClusterParameterGroup",
    validator: validate_PostModifyClusterParameterGroup_775734, base: "/",
    url: url_PostModifyClusterParameterGroup_775735,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetModifyClusterParameterGroup_775716 = ref object of OpenApiRestCall_772581
proc url_GetModifyClusterParameterGroup_775718(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_GetModifyClusterParameterGroup_775717(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Modifies the parameters of a parameter group.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ParameterGroupName: JString (required)
  ##                     : The name of the parameter group to be modified.
  ##   Parameters: JArray (required)
  ##             : <p>An array of parameters to be modified. A maximum of 20 parameters can be modified in a single request.</p> <p>For each parameter to be modified, you must supply at least the parameter name and parameter value; other name-value pairs of the parameter are optional.</p> <p>For the workload management (WLM) configuration, you must supply all the name-value pairs in the wlm_json_configuration parameter.</p>
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `ParameterGroupName` field"
  var valid_775719 = query.getOrDefault("ParameterGroupName")
  valid_775719 = validateParameter(valid_775719, JString, required = true,
                                 default = nil)
  if valid_775719 != nil:
    section.add "ParameterGroupName", valid_775719
  var valid_775720 = query.getOrDefault("Parameters")
  valid_775720 = validateParameter(valid_775720, JArray, required = true, default = nil)
  if valid_775720 != nil:
    section.add "Parameters", valid_775720
  var valid_775721 = query.getOrDefault("Action")
  valid_775721 = validateParameter(valid_775721, JString, required = true, default = newJString(
      "ModifyClusterParameterGroup"))
  if valid_775721 != nil:
    section.add "Action", valid_775721
  var valid_775722 = query.getOrDefault("Version")
  valid_775722 = validateParameter(valid_775722, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_775722 != nil:
    section.add "Version", valid_775722
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_775723 = header.getOrDefault("X-Amz-Date")
  valid_775723 = validateParameter(valid_775723, JString, required = false,
                                 default = nil)
  if valid_775723 != nil:
    section.add "X-Amz-Date", valid_775723
  var valid_775724 = header.getOrDefault("X-Amz-Security-Token")
  valid_775724 = validateParameter(valid_775724, JString, required = false,
                                 default = nil)
  if valid_775724 != nil:
    section.add "X-Amz-Security-Token", valid_775724
  var valid_775725 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_775725 = validateParameter(valid_775725, JString, required = false,
                                 default = nil)
  if valid_775725 != nil:
    section.add "X-Amz-Content-Sha256", valid_775725
  var valid_775726 = header.getOrDefault("X-Amz-Algorithm")
  valid_775726 = validateParameter(valid_775726, JString, required = false,
                                 default = nil)
  if valid_775726 != nil:
    section.add "X-Amz-Algorithm", valid_775726
  var valid_775727 = header.getOrDefault("X-Amz-Signature")
  valid_775727 = validateParameter(valid_775727, JString, required = false,
                                 default = nil)
  if valid_775727 != nil:
    section.add "X-Amz-Signature", valid_775727
  var valid_775728 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_775728 = validateParameter(valid_775728, JString, required = false,
                                 default = nil)
  if valid_775728 != nil:
    section.add "X-Amz-SignedHeaders", valid_775728
  var valid_775729 = header.getOrDefault("X-Amz-Credential")
  valid_775729 = validateParameter(valid_775729, JString, required = false,
                                 default = nil)
  if valid_775729 != nil:
    section.add "X-Amz-Credential", valid_775729
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_775730: Call_GetModifyClusterParameterGroup_775716; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Modifies the parameters of a parameter group.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_775730.validator(path, query, header, formData, body)
  let scheme = call_775730.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_775730.url(scheme.get, call_775730.host, call_775730.base,
                         call_775730.route, valid.getOrDefault("path"))
  result = hook(call_775730, url, valid)

proc call*(call_775731: Call_GetModifyClusterParameterGroup_775716;
          ParameterGroupName: string; Parameters: JsonNode;
          Action: string = "ModifyClusterParameterGroup";
          Version: string = "2012-12-01"): Recallable =
  ## getModifyClusterParameterGroup
  ## <p>Modifies the parameters of a parameter group.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   ParameterGroupName: string (required)
  ##                     : The name of the parameter group to be modified.
  ##   Parameters: JArray (required)
  ##             : <p>An array of parameters to be modified. A maximum of 20 parameters can be modified in a single request.</p> <p>For each parameter to be modified, you must supply at least the parameter name and parameter value; other name-value pairs of the parameter are optional.</p> <p>For the workload management (WLM) configuration, you must supply all the name-value pairs in the wlm_json_configuration parameter.</p>
  ##   Action: string (required)
  ##   Version: string (required)
  var query_775732 = newJObject()
  add(query_775732, "ParameterGroupName", newJString(ParameterGroupName))
  if Parameters != nil:
    query_775732.add "Parameters", Parameters
  add(query_775732, "Action", newJString(Action))
  add(query_775732, "Version", newJString(Version))
  result = call_775731.call(nil, query_775732, nil, nil, nil)

var getModifyClusterParameterGroup* = Call_GetModifyClusterParameterGroup_775716(
    name: "getModifyClusterParameterGroup", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyClusterParameterGroup",
    validator: validate_GetModifyClusterParameterGroup_775717, base: "/",
    url: url_GetModifyClusterParameterGroup_775718,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostModifyClusterSnapshot_775769 = ref object of OpenApiRestCall_772581
proc url_PostModifyClusterSnapshot_775771(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_PostModifyClusterSnapshot_775770(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies the settings for a snapshot.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_775772 = query.getOrDefault("Action")
  valid_775772 = validateParameter(valid_775772, JString, required = true,
                                 default = newJString("ModifyClusterSnapshot"))
  if valid_775772 != nil:
    section.add "Action", valid_775772
  var valid_775773 = query.getOrDefault("Version")
  valid_775773 = validateParameter(valid_775773, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_775773 != nil:
    section.add "Version", valid_775773
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_775774 = header.getOrDefault("X-Amz-Date")
  valid_775774 = validateParameter(valid_775774, JString, required = false,
                                 default = nil)
  if valid_775774 != nil:
    section.add "X-Amz-Date", valid_775774
  var valid_775775 = header.getOrDefault("X-Amz-Security-Token")
  valid_775775 = validateParameter(valid_775775, JString, required = false,
                                 default = nil)
  if valid_775775 != nil:
    section.add "X-Amz-Security-Token", valid_775775
  var valid_775776 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_775776 = validateParameter(valid_775776, JString, required = false,
                                 default = nil)
  if valid_775776 != nil:
    section.add "X-Amz-Content-Sha256", valid_775776
  var valid_775777 = header.getOrDefault("X-Amz-Algorithm")
  valid_775777 = validateParameter(valid_775777, JString, required = false,
                                 default = nil)
  if valid_775777 != nil:
    section.add "X-Amz-Algorithm", valid_775777
  var valid_775778 = header.getOrDefault("X-Amz-Signature")
  valid_775778 = validateParameter(valid_775778, JString, required = false,
                                 default = nil)
  if valid_775778 != nil:
    section.add "X-Amz-Signature", valid_775778
  var valid_775779 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_775779 = validateParameter(valid_775779, JString, required = false,
                                 default = nil)
  if valid_775779 != nil:
    section.add "X-Amz-SignedHeaders", valid_775779
  var valid_775780 = header.getOrDefault("X-Amz-Credential")
  valid_775780 = validateParameter(valid_775780, JString, required = false,
                                 default = nil)
  if valid_775780 != nil:
    section.add "X-Amz-Credential", valid_775780
  result.add "header", section
  ## parameters in `formData` object:
  ##   Force: JBool
  ##        : A Boolean option to override an exception if the retention period has already passed.
  ##   SnapshotIdentifier: JString (required)
  ##                     : The identifier of the snapshot whose setting you want to modify.
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely.</p> <p>If the manual snapshot falls outside of the new retention period, you can specify the force option to immediately delete the snapshot.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  section = newJObject()
  var valid_775781 = formData.getOrDefault("Force")
  valid_775781 = validateParameter(valid_775781, JBool, required = false, default = nil)
  if valid_775781 != nil:
    section.add "Force", valid_775781
  assert formData != nil, "formData argument is necessary due to required `SnapshotIdentifier` field"
  var valid_775782 = formData.getOrDefault("SnapshotIdentifier")
  valid_775782 = validateParameter(valid_775782, JString, required = true,
                                 default = nil)
  if valid_775782 != nil:
    section.add "SnapshotIdentifier", valid_775782
  var valid_775783 = formData.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_775783 = validateParameter(valid_775783, JInt, required = false, default = nil)
  if valid_775783 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_775783
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_775784: Call_PostModifyClusterSnapshot_775769; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Modifies the settings for a snapshot.
  ## 
  let valid = call_775784.validator(path, query, header, formData, body)
  let scheme = call_775784.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_775784.url(scheme.get, call_775784.host, call_775784.base,
                         call_775784.route, valid.getOrDefault("path"))
  result = hook(call_775784, url, valid)

proc call*(call_775785: Call_PostModifyClusterSnapshot_775769;
          SnapshotIdentifier: string; Force: bool = false;
          Action: string = "ModifyClusterSnapshot";
          ManualSnapshotRetentionPeriod: int = 0; Version: string = "2012-12-01"): Recallable =
  ## postModifyClusterSnapshot
  ## Modifies the settings for a snapshot.
  ##   Force: bool
  ##        : A Boolean option to override an exception if the retention period has already passed.
  ##   Action: string (required)
  ##   SnapshotIdentifier: string (required)
  ##                     : The identifier of the snapshot whose setting you want to modify.
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely.</p> <p>If the manual snapshot falls outside of the new retention period, you can specify the force option to immediately delete the snapshot.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  ##   Version: string (required)
  var query_775786 = newJObject()
  var formData_775787 = newJObject()
  add(formData_775787, "Force", newJBool(Force))
  add(query_775786, "Action", newJString(Action))
  add(formData_775787, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(formData_775787, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  add(query_775786, "Version", newJString(Version))
  result = call_775785.call(nil, query_775786, nil, formData_775787, nil)

var postModifyClusterSnapshot* = Call_PostModifyClusterSnapshot_775769(
    name: "postModifyClusterSnapshot", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyClusterSnapshot",
    validator: validate_PostModifyClusterSnapshot_775770, base: "/",
    url: url_PostModifyClusterSnapshot_775771,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetModifyClusterSnapshot_775751 = ref object of OpenApiRestCall_772581
proc url_GetModifyClusterSnapshot_775753(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_GetModifyClusterSnapshot_775752(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies the settings for a snapshot.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   SnapshotIdentifier: JString (required)
  ##                     : The identifier of the snapshot whose setting you want to modify.
  ##   Version: JString (required)
  ##   Force: JBool
  ##        : A Boolean option to override an exception if the retention period has already passed.
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely.</p> <p>If the manual snapshot falls outside of the new retention period, you can specify the force option to immediately delete the snapshot.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_775754 = query.getOrDefault("Action")
  valid_775754 = validateParameter(valid_775754, JString, required = true,
                                 default = newJString("ModifyClusterSnapshot"))
  if valid_775754 != nil:
    section.add "Action", valid_775754
  var valid_775755 = query.getOrDefault("SnapshotIdentifier")
  valid_775755 = validateParameter(valid_775755, JString, required = true,
                                 default = nil)
  if valid_775755 != nil:
    section.add "SnapshotIdentifier", valid_775755
  var valid_775756 = query.getOrDefault("Version")
  valid_775756 = validateParameter(valid_775756, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_775756 != nil:
    section.add "Version", valid_775756
  var valid_775757 = query.getOrDefault("Force")
  valid_775757 = validateParameter(valid_775757, JBool, required = false, default = nil)
  if valid_775757 != nil:
    section.add "Force", valid_775757
  var valid_775758 = query.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_775758 = validateParameter(valid_775758, JInt, required = false, default = nil)
  if valid_775758 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_775758
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_775759 = header.getOrDefault("X-Amz-Date")
  valid_775759 = validateParameter(valid_775759, JString, required = false,
                                 default = nil)
  if valid_775759 != nil:
    section.add "X-Amz-Date", valid_775759
  var valid_775760 = header.getOrDefault("X-Amz-Security-Token")
  valid_775760 = validateParameter(valid_775760, JString, required = false,
                                 default = nil)
  if valid_775760 != nil:
    section.add "X-Amz-Security-Token", valid_775760
  var valid_775761 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_775761 = validateParameter(valid_775761, JString, required = false,
                                 default = nil)
  if valid_775761 != nil:
    section.add "X-Amz-Content-Sha256", valid_775761
  var valid_775762 = header.getOrDefault("X-Amz-Algorithm")
  valid_775762 = validateParameter(valid_775762, JString, required = false,
                                 default = nil)
  if valid_775762 != nil:
    section.add "X-Amz-Algorithm", valid_775762
  var valid_775763 = header.getOrDefault("X-Amz-Signature")
  valid_775763 = validateParameter(valid_775763, JString, required = false,
                                 default = nil)
  if valid_775763 != nil:
    section.add "X-Amz-Signature", valid_775763
  var valid_775764 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_775764 = validateParameter(valid_775764, JString, required = false,
                                 default = nil)
  if valid_775764 != nil:
    section.add "X-Amz-SignedHeaders", valid_775764
  var valid_775765 = header.getOrDefault("X-Amz-Credential")
  valid_775765 = validateParameter(valid_775765, JString, required = false,
                                 default = nil)
  if valid_775765 != nil:
    section.add "X-Amz-Credential", valid_775765
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_775766: Call_GetModifyClusterSnapshot_775751; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Modifies the settings for a snapshot.
  ## 
  let valid = call_775766.validator(path, query, header, formData, body)
  let scheme = call_775766.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_775766.url(scheme.get, call_775766.host, call_775766.base,
                         call_775766.route, valid.getOrDefault("path"))
  result = hook(call_775766, url, valid)

proc call*(call_775767: Call_GetModifyClusterSnapshot_775751;
          SnapshotIdentifier: string; Action: string = "ModifyClusterSnapshot";
          Version: string = "2012-12-01"; Force: bool = false;
          ManualSnapshotRetentionPeriod: int = 0): Recallable =
  ## getModifyClusterSnapshot
  ## Modifies the settings for a snapshot.
  ##   Action: string (required)
  ##   SnapshotIdentifier: string (required)
  ##                     : The identifier of the snapshot whose setting you want to modify.
  ##   Version: string (required)
  ##   Force: bool
  ##        : A Boolean option to override an exception if the retention period has already passed.
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely.</p> <p>If the manual snapshot falls outside of the new retention period, you can specify the force option to immediately delete the snapshot.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  var query_775768 = newJObject()
  add(query_775768, "Action", newJString(Action))
  add(query_775768, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_775768, "Version", newJString(Version))
  add(query_775768, "Force", newJBool(Force))
  add(query_775768, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  result = call_775767.call(nil, query_775768, nil, nil, nil)

var getModifyClusterSnapshot* = Call_GetModifyClusterSnapshot_775751(
    name: "getModifyClusterSnapshot", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyClusterSnapshot",
    validator: validate_GetModifyClusterSnapshot_775752, base: "/",
    url: url_GetModifyClusterSnapshot_775753, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostModifyClusterSnapshotSchedule_775806 = ref object of OpenApiRestCall_772581
proc url_PostModifyClusterSnapshotSchedule_775808(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_PostModifyClusterSnapshotSchedule_775807(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies a snapshot schedule for a cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_775809 = query.getOrDefault("Action")
  valid_775809 = validateParameter(valid_775809, JString, required = true, default = newJString(
      "ModifyClusterSnapshotSchedule"))
  if valid_775809 != nil:
    section.add "Action", valid_775809
  var valid_775810 = query.getOrDefault("Version")
  valid_775810 = validateParameter(valid_775810, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_775810 != nil:
    section.add "Version", valid_775810
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_775811 = header.getOrDefault("X-Amz-Date")
  valid_775811 = validateParameter(valid_775811, JString, required = false,
                                 default = nil)
  if valid_775811 != nil:
    section.add "X-Amz-Date", valid_775811
  var valid_775812 = header.getOrDefault("X-Amz-Security-Token")
  valid_775812 = validateParameter(valid_775812, JString, required = false,
                                 default = nil)
  if valid_775812 != nil:
    section.add "X-Amz-Security-Token", valid_775812
  var valid_775813 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_775813 = validateParameter(valid_775813, JString, required = false,
                                 default = nil)
  if valid_775813 != nil:
    section.add "X-Amz-Content-Sha256", valid_775813
  var valid_775814 = header.getOrDefault("X-Amz-Algorithm")
  valid_775814 = validateParameter(valid_775814, JString, required = false,
                                 default = nil)
  if valid_775814 != nil:
    section.add "X-Amz-Algorithm", valid_775814
  var valid_775815 = header.getOrDefault("X-Amz-Signature")
  valid_775815 = validateParameter(valid_775815, JString, required = false,
                                 default = nil)
  if valid_775815 != nil:
    section.add "X-Amz-Signature", valid_775815
  var valid_775816 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_775816 = validateParameter(valid_775816, JString, required = false,
                                 default = nil)
  if valid_775816 != nil:
    section.add "X-Amz-SignedHeaders", valid_775816
  var valid_775817 = header.getOrDefault("X-Amz-Credential")
  valid_775817 = validateParameter(valid_775817, JString, required = false,
                                 default = nil)
  if valid_775817 != nil:
    section.add "X-Amz-Credential", valid_775817
  result.add "header", section
  ## parameters in `formData` object:
  ##   DisassociateSchedule: JBool
  ##                       : A boolean to indicate whether to remove the assoiciation between the cluster and the schedule.
  ##   ClusterIdentifier: JString (required)
  ##                    : A unique identifier for the cluster whose snapshot schedule you want to modify. 
  ##   ScheduleIdentifier: JString
  ##                     : A unique alphanumeric identifier for the schedule that you want to associate with the cluster.
  section = newJObject()
  var valid_775818 = formData.getOrDefault("DisassociateSchedule")
  valid_775818 = validateParameter(valid_775818, JBool, required = false, default = nil)
  if valid_775818 != nil:
    section.add "DisassociateSchedule", valid_775818
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_775819 = formData.getOrDefault("ClusterIdentifier")
  valid_775819 = validateParameter(valid_775819, JString, required = true,
                                 default = nil)
  if valid_775819 != nil:
    section.add "ClusterIdentifier", valid_775819
  var valid_775820 = formData.getOrDefault("ScheduleIdentifier")
  valid_775820 = validateParameter(valid_775820, JString, required = false,
                                 default = nil)
  if valid_775820 != nil:
    section.add "ScheduleIdentifier", valid_775820
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_775821: Call_PostModifyClusterSnapshotSchedule_775806;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Modifies a snapshot schedule for a cluster.
  ## 
  let valid = call_775821.validator(path, query, header, formData, body)
  let scheme = call_775821.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_775821.url(scheme.get, call_775821.host, call_775821.base,
                         call_775821.route, valid.getOrDefault("path"))
  result = hook(call_775821, url, valid)

proc call*(call_775822: Call_PostModifyClusterSnapshotSchedule_775806;
          ClusterIdentifier: string; DisassociateSchedule: bool = false;
          Action: string = "ModifyClusterSnapshotSchedule";
          ScheduleIdentifier: string = ""; Version: string = "2012-12-01"): Recallable =
  ## postModifyClusterSnapshotSchedule
  ## Modifies a snapshot schedule for a cluster.
  ##   DisassociateSchedule: bool
  ##                       : A boolean to indicate whether to remove the assoiciation between the cluster and the schedule.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : A unique identifier for the cluster whose snapshot schedule you want to modify. 
  ##   ScheduleIdentifier: string
  ##                     : A unique alphanumeric identifier for the schedule that you want to associate with the cluster.
  ##   Version: string (required)
  var query_775823 = newJObject()
  var formData_775824 = newJObject()
  add(formData_775824, "DisassociateSchedule", newJBool(DisassociateSchedule))
  add(query_775823, "Action", newJString(Action))
  add(formData_775824, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_775824, "ScheduleIdentifier", newJString(ScheduleIdentifier))
  add(query_775823, "Version", newJString(Version))
  result = call_775822.call(nil, query_775823, nil, formData_775824, nil)

var postModifyClusterSnapshotSchedule* = Call_PostModifyClusterSnapshotSchedule_775806(
    name: "postModifyClusterSnapshotSchedule", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=ModifyClusterSnapshotSchedule",
    validator: validate_PostModifyClusterSnapshotSchedule_775807, base: "/",
    url: url_PostModifyClusterSnapshotSchedule_775808,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetModifyClusterSnapshotSchedule_775788 = ref object of OpenApiRestCall_772581
proc url_GetModifyClusterSnapshotSchedule_775790(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_GetModifyClusterSnapshotSchedule_775789(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies a snapshot schedule for a cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : A unique identifier for the cluster whose snapshot schedule you want to modify. 
  ##   ScheduleIdentifier: JString
  ##                     : A unique alphanumeric identifier for the schedule that you want to associate with the cluster.
  ##   DisassociateSchedule: JBool
  ##                       : A boolean to indicate whether to remove the assoiciation between the cluster and the schedule.
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_775791 = query.getOrDefault("Action")
  valid_775791 = validateParameter(valid_775791, JString, required = true, default = newJString(
      "ModifyClusterSnapshotSchedule"))
  if valid_775791 != nil:
    section.add "Action", valid_775791
  var valid_775792 = query.getOrDefault("ClusterIdentifier")
  valid_775792 = validateParameter(valid_775792, JString, required = true,
                                 default = nil)
  if valid_775792 != nil:
    section.add "ClusterIdentifier", valid_775792
  var valid_775793 = query.getOrDefault("ScheduleIdentifier")
  valid_775793 = validateParameter(valid_775793, JString, required = false,
                                 default = nil)
  if valid_775793 != nil:
    section.add "ScheduleIdentifier", valid_775793
  var valid_775794 = query.getOrDefault("DisassociateSchedule")
  valid_775794 = validateParameter(valid_775794, JBool, required = false, default = nil)
  if valid_775794 != nil:
    section.add "DisassociateSchedule", valid_775794
  var valid_775795 = query.getOrDefault("Version")
  valid_775795 = validateParameter(valid_775795, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_775795 != nil:
    section.add "Version", valid_775795
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_775796 = header.getOrDefault("X-Amz-Date")
  valid_775796 = validateParameter(valid_775796, JString, required = false,
                                 default = nil)
  if valid_775796 != nil:
    section.add "X-Amz-Date", valid_775796
  var valid_775797 = header.getOrDefault("X-Amz-Security-Token")
  valid_775797 = validateParameter(valid_775797, JString, required = false,
                                 default = nil)
  if valid_775797 != nil:
    section.add "X-Amz-Security-Token", valid_775797
  var valid_775798 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_775798 = validateParameter(valid_775798, JString, required = false,
                                 default = nil)
  if valid_775798 != nil:
    section.add "X-Amz-Content-Sha256", valid_775798
  var valid_775799 = header.getOrDefault("X-Amz-Algorithm")
  valid_775799 = validateParameter(valid_775799, JString, required = false,
                                 default = nil)
  if valid_775799 != nil:
    section.add "X-Amz-Algorithm", valid_775799
  var valid_775800 = header.getOrDefault("X-Amz-Signature")
  valid_775800 = validateParameter(valid_775800, JString, required = false,
                                 default = nil)
  if valid_775800 != nil:
    section.add "X-Amz-Signature", valid_775800
  var valid_775801 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_775801 = validateParameter(valid_775801, JString, required = false,
                                 default = nil)
  if valid_775801 != nil:
    section.add "X-Amz-SignedHeaders", valid_775801
  var valid_775802 = header.getOrDefault("X-Amz-Credential")
  valid_775802 = validateParameter(valid_775802, JString, required = false,
                                 default = nil)
  if valid_775802 != nil:
    section.add "X-Amz-Credential", valid_775802
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_775803: Call_GetModifyClusterSnapshotSchedule_775788;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Modifies a snapshot schedule for a cluster.
  ## 
  let valid = call_775803.validator(path, query, header, formData, body)
  let scheme = call_775803.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_775803.url(scheme.get, call_775803.host, call_775803.base,
                         call_775803.route, valid.getOrDefault("path"))
  result = hook(call_775803, url, valid)

proc call*(call_775804: Call_GetModifyClusterSnapshotSchedule_775788;
          ClusterIdentifier: string;
          Action: string = "ModifyClusterSnapshotSchedule";
          ScheduleIdentifier: string = ""; DisassociateSchedule: bool = false;
          Version: string = "2012-12-01"): Recallable =
  ## getModifyClusterSnapshotSchedule
  ## Modifies a snapshot schedule for a cluster.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : A unique identifier for the cluster whose snapshot schedule you want to modify. 
  ##   ScheduleIdentifier: string
  ##                     : A unique alphanumeric identifier for the schedule that you want to associate with the cluster.
  ##   DisassociateSchedule: bool
  ##                       : A boolean to indicate whether to remove the assoiciation between the cluster and the schedule.
  ##   Version: string (required)
  var query_775805 = newJObject()
  add(query_775805, "Action", newJString(Action))
  add(query_775805, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_775805, "ScheduleIdentifier", newJString(ScheduleIdentifier))
  add(query_775805, "DisassociateSchedule", newJBool(DisassociateSchedule))
  add(query_775805, "Version", newJString(Version))
  result = call_775804.call(nil, query_775805, nil, nil, nil)

var getModifyClusterSnapshotSchedule* = Call_GetModifyClusterSnapshotSchedule_775788(
    name: "getModifyClusterSnapshotSchedule", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=ModifyClusterSnapshotSchedule",
    validator: validate_GetModifyClusterSnapshotSchedule_775789, base: "/",
    url: url_GetModifyClusterSnapshotSchedule_775790,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostModifyClusterSubnetGroup_775843 = ref object of OpenApiRestCall_772581
proc url_PostModifyClusterSubnetGroup_775845(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_PostModifyClusterSubnetGroup_775844(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies a cluster subnet group to include the specified list of VPC subnets. The operation replaces the existing list of subnets with the new list of subnets.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_775846 = query.getOrDefault("Action")
  valid_775846 = validateParameter(valid_775846, JString, required = true, default = newJString(
      "ModifyClusterSubnetGroup"))
  if valid_775846 != nil:
    section.add "Action", valid_775846
  var valid_775847 = query.getOrDefault("Version")
  valid_775847 = validateParameter(valid_775847, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_775847 != nil:
    section.add "Version", valid_775847
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_775848 = header.getOrDefault("X-Amz-Date")
  valid_775848 = validateParameter(valid_775848, JString, required = false,
                                 default = nil)
  if valid_775848 != nil:
    section.add "X-Amz-Date", valid_775848
  var valid_775849 = header.getOrDefault("X-Amz-Security-Token")
  valid_775849 = validateParameter(valid_775849, JString, required = false,
                                 default = nil)
  if valid_775849 != nil:
    section.add "X-Amz-Security-Token", valid_775849
  var valid_775850 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_775850 = validateParameter(valid_775850, JString, required = false,
                                 default = nil)
  if valid_775850 != nil:
    section.add "X-Amz-Content-Sha256", valid_775850
  var valid_775851 = header.getOrDefault("X-Amz-Algorithm")
  valid_775851 = validateParameter(valid_775851, JString, required = false,
                                 default = nil)
  if valid_775851 != nil:
    section.add "X-Amz-Algorithm", valid_775851
  var valid_775852 = header.getOrDefault("X-Amz-Signature")
  valid_775852 = validateParameter(valid_775852, JString, required = false,
                                 default = nil)
  if valid_775852 != nil:
    section.add "X-Amz-Signature", valid_775852
  var valid_775853 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_775853 = validateParameter(valid_775853, JString, required = false,
                                 default = nil)
  if valid_775853 != nil:
    section.add "X-Amz-SignedHeaders", valid_775853
  var valid_775854 = header.getOrDefault("X-Amz-Credential")
  valid_775854 = validateParameter(valid_775854, JString, required = false,
                                 default = nil)
  if valid_775854 != nil:
    section.add "X-Amz-Credential", valid_775854
  result.add "header", section
  ## parameters in `formData` object:
  ##   SubnetIds: JArray (required)
  ##            : An array of VPC subnet IDs. A maximum of 20 subnets can be modified in a single request.
  ##   Description: JString
  ##              : A text description of the subnet group to be modified.
  ##   ClusterSubnetGroupName: JString (required)
  ##                         : The name of the subnet group to be modified.
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `SubnetIds` field"
  var valid_775855 = formData.getOrDefault("SubnetIds")
  valid_775855 = validateParameter(valid_775855, JArray, required = true, default = nil)
  if valid_775855 != nil:
    section.add "SubnetIds", valid_775855
  var valid_775856 = formData.getOrDefault("Description")
  valid_775856 = validateParameter(valid_775856, JString, required = false,
                                 default = nil)
  if valid_775856 != nil:
    section.add "Description", valid_775856
  var valid_775857 = formData.getOrDefault("ClusterSubnetGroupName")
  valid_775857 = validateParameter(valid_775857, JString, required = true,
                                 default = nil)
  if valid_775857 != nil:
    section.add "ClusterSubnetGroupName", valid_775857
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_775858: Call_PostModifyClusterSubnetGroup_775843; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Modifies a cluster subnet group to include the specified list of VPC subnets. The operation replaces the existing list of subnets with the new list of subnets.
  ## 
  let valid = call_775858.validator(path, query, header, formData, body)
  let scheme = call_775858.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_775858.url(scheme.get, call_775858.host, call_775858.base,
                         call_775858.route, valid.getOrDefault("path"))
  result = hook(call_775858, url, valid)

proc call*(call_775859: Call_PostModifyClusterSubnetGroup_775843;
          SubnetIds: JsonNode; ClusterSubnetGroupName: string;
          Action: string = "ModifyClusterSubnetGroup";
          Version: string = "2012-12-01"; Description: string = ""): Recallable =
  ## postModifyClusterSubnetGroup
  ## Modifies a cluster subnet group to include the specified list of VPC subnets. The operation replaces the existing list of subnets with the new list of subnets.
  ##   SubnetIds: JArray (required)
  ##            : An array of VPC subnet IDs. A maximum of 20 subnets can be modified in a single request.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   Description: string
  ##              : A text description of the subnet group to be modified.
  ##   ClusterSubnetGroupName: string (required)
  ##                         : The name of the subnet group to be modified.
  var query_775860 = newJObject()
  var formData_775861 = newJObject()
  if SubnetIds != nil:
    formData_775861.add "SubnetIds", SubnetIds
  add(query_775860, "Action", newJString(Action))
  add(query_775860, "Version", newJString(Version))
  add(formData_775861, "Description", newJString(Description))
  add(formData_775861, "ClusterSubnetGroupName",
      newJString(ClusterSubnetGroupName))
  result = call_775859.call(nil, query_775860, nil, formData_775861, nil)

var postModifyClusterSubnetGroup* = Call_PostModifyClusterSubnetGroup_775843(
    name: "postModifyClusterSubnetGroup", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyClusterSubnetGroup",
    validator: validate_PostModifyClusterSubnetGroup_775844, base: "/",
    url: url_PostModifyClusterSubnetGroup_775845,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetModifyClusterSubnetGroup_775825 = ref object of OpenApiRestCall_772581
proc url_GetModifyClusterSubnetGroup_775827(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_GetModifyClusterSubnetGroup_775826(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies a cluster subnet group to include the specified list of VPC subnets. The operation replaces the existing list of subnets with the new list of subnets.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ClusterSubnetGroupName: JString (required)
  ##                         : The name of the subnet group to be modified.
  ##   Description: JString
  ##              : A text description of the subnet group to be modified.
  ##   Action: JString (required)
  ##   SubnetIds: JArray (required)
  ##            : An array of VPC subnet IDs. A maximum of 20 subnets can be modified in a single request.
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `ClusterSubnetGroupName` field"
  var valid_775828 = query.getOrDefault("ClusterSubnetGroupName")
  valid_775828 = validateParameter(valid_775828, JString, required = true,
                                 default = nil)
  if valid_775828 != nil:
    section.add "ClusterSubnetGroupName", valid_775828
  var valid_775829 = query.getOrDefault("Description")
  valid_775829 = validateParameter(valid_775829, JString, required = false,
                                 default = nil)
  if valid_775829 != nil:
    section.add "Description", valid_775829
  var valid_775830 = query.getOrDefault("Action")
  valid_775830 = validateParameter(valid_775830, JString, required = true, default = newJString(
      "ModifyClusterSubnetGroup"))
  if valid_775830 != nil:
    section.add "Action", valid_775830
  var valid_775831 = query.getOrDefault("SubnetIds")
  valid_775831 = validateParameter(valid_775831, JArray, required = true, default = nil)
  if valid_775831 != nil:
    section.add "SubnetIds", valid_775831
  var valid_775832 = query.getOrDefault("Version")
  valid_775832 = validateParameter(valid_775832, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_775832 != nil:
    section.add "Version", valid_775832
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_775833 = header.getOrDefault("X-Amz-Date")
  valid_775833 = validateParameter(valid_775833, JString, required = false,
                                 default = nil)
  if valid_775833 != nil:
    section.add "X-Amz-Date", valid_775833
  var valid_775834 = header.getOrDefault("X-Amz-Security-Token")
  valid_775834 = validateParameter(valid_775834, JString, required = false,
                                 default = nil)
  if valid_775834 != nil:
    section.add "X-Amz-Security-Token", valid_775834
  var valid_775835 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_775835 = validateParameter(valid_775835, JString, required = false,
                                 default = nil)
  if valid_775835 != nil:
    section.add "X-Amz-Content-Sha256", valid_775835
  var valid_775836 = header.getOrDefault("X-Amz-Algorithm")
  valid_775836 = validateParameter(valid_775836, JString, required = false,
                                 default = nil)
  if valid_775836 != nil:
    section.add "X-Amz-Algorithm", valid_775836
  var valid_775837 = header.getOrDefault("X-Amz-Signature")
  valid_775837 = validateParameter(valid_775837, JString, required = false,
                                 default = nil)
  if valid_775837 != nil:
    section.add "X-Amz-Signature", valid_775837
  var valid_775838 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_775838 = validateParameter(valid_775838, JString, required = false,
                                 default = nil)
  if valid_775838 != nil:
    section.add "X-Amz-SignedHeaders", valid_775838
  var valid_775839 = header.getOrDefault("X-Amz-Credential")
  valid_775839 = validateParameter(valid_775839, JString, required = false,
                                 default = nil)
  if valid_775839 != nil:
    section.add "X-Amz-Credential", valid_775839
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_775840: Call_GetModifyClusterSubnetGroup_775825; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Modifies a cluster subnet group to include the specified list of VPC subnets. The operation replaces the existing list of subnets with the new list of subnets.
  ## 
  let valid = call_775840.validator(path, query, header, formData, body)
  let scheme = call_775840.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_775840.url(scheme.get, call_775840.host, call_775840.base,
                         call_775840.route, valid.getOrDefault("path"))
  result = hook(call_775840, url, valid)

proc call*(call_775841: Call_GetModifyClusterSubnetGroup_775825;
          ClusterSubnetGroupName: string; SubnetIds: JsonNode;
          Description: string = ""; Action: string = "ModifyClusterSubnetGroup";
          Version: string = "2012-12-01"): Recallable =
  ## getModifyClusterSubnetGroup
  ## Modifies a cluster subnet group to include the specified list of VPC subnets. The operation replaces the existing list of subnets with the new list of subnets.
  ##   ClusterSubnetGroupName: string (required)
  ##                         : The name of the subnet group to be modified.
  ##   Description: string
  ##              : A text description of the subnet group to be modified.
  ##   Action: string (required)
  ##   SubnetIds: JArray (required)
  ##            : An array of VPC subnet IDs. A maximum of 20 subnets can be modified in a single request.
  ##   Version: string (required)
  var query_775842 = newJObject()
  add(query_775842, "ClusterSubnetGroupName", newJString(ClusterSubnetGroupName))
  add(query_775842, "Description", newJString(Description))
  add(query_775842, "Action", newJString(Action))
  if SubnetIds != nil:
    query_775842.add "SubnetIds", SubnetIds
  add(query_775842, "Version", newJString(Version))
  result = call_775841.call(nil, query_775842, nil, nil, nil)

var getModifyClusterSubnetGroup* = Call_GetModifyClusterSubnetGroup_775825(
    name: "getModifyClusterSubnetGroup", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyClusterSubnetGroup",
    validator: validate_GetModifyClusterSubnetGroup_775826, base: "/",
    url: url_GetModifyClusterSubnetGroup_775827,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostModifyEventSubscription_775884 = ref object of OpenApiRestCall_772581
proc url_PostModifyEventSubscription_775886(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_PostModifyEventSubscription_775885(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies an existing Amazon Redshift event notification subscription.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_775887 = query.getOrDefault("Action")
  valid_775887 = validateParameter(valid_775887, JString, required = true, default = newJString(
      "ModifyEventSubscription"))
  if valid_775887 != nil:
    section.add "Action", valid_775887
  var valid_775888 = query.getOrDefault("Version")
  valid_775888 = validateParameter(valid_775888, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_775888 != nil:
    section.add "Version", valid_775888
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_775889 = header.getOrDefault("X-Amz-Date")
  valid_775889 = validateParameter(valid_775889, JString, required = false,
                                 default = nil)
  if valid_775889 != nil:
    section.add "X-Amz-Date", valid_775889
  var valid_775890 = header.getOrDefault("X-Amz-Security-Token")
  valid_775890 = validateParameter(valid_775890, JString, required = false,
                                 default = nil)
  if valid_775890 != nil:
    section.add "X-Amz-Security-Token", valid_775890
  var valid_775891 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_775891 = validateParameter(valid_775891, JString, required = false,
                                 default = nil)
  if valid_775891 != nil:
    section.add "X-Amz-Content-Sha256", valid_775891
  var valid_775892 = header.getOrDefault("X-Amz-Algorithm")
  valid_775892 = validateParameter(valid_775892, JString, required = false,
                                 default = nil)
  if valid_775892 != nil:
    section.add "X-Amz-Algorithm", valid_775892
  var valid_775893 = header.getOrDefault("X-Amz-Signature")
  valid_775893 = validateParameter(valid_775893, JString, required = false,
                                 default = nil)
  if valid_775893 != nil:
    section.add "X-Amz-Signature", valid_775893
  var valid_775894 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_775894 = validateParameter(valid_775894, JString, required = false,
                                 default = nil)
  if valid_775894 != nil:
    section.add "X-Amz-SignedHeaders", valid_775894
  var valid_775895 = header.getOrDefault("X-Amz-Credential")
  valid_775895 = validateParameter(valid_775895, JString, required = false,
                                 default = nil)
  if valid_775895 != nil:
    section.add "X-Amz-Credential", valid_775895
  result.add "header", section
  ## parameters in `formData` object:
  ##   Enabled: JBool
  ##          : A Boolean value indicating if the subscription is enabled. <code>true</code> indicates the subscription is enabled 
  ##   EventCategories: JArray
  ##                  : <p>Specifies the Amazon Redshift event categories to be published by the event notification subscription.</p> <p>Values: configuration, management, monitoring, security</p>
  ##   SnsTopicArn: JString
  ##              : The Amazon Resource Name (ARN) of the SNS topic to be used by the event notification subscription.
  ##   Severity: JString
  ##           : <p>Specifies the Amazon Redshift event severity to be published by the event notification subscription.</p> <p>Values: ERROR, INFO</p>
  ##   SourceIds: JArray
  ##            : <p>A list of one or more identifiers of Amazon Redshift source objects. All of the objects must be of the same type as was specified in the source type parameter. The event subscription will return only events generated by the specified objects. If not specified, then events are returned for all objects within the source type specified.</p> <p>Example: my-cluster-1, my-cluster-2</p> <p>Example: my-snapshot-20131010</p>
  ##   SubscriptionName: JString (required)
  ##                   : The name of the modified Amazon Redshift event notification subscription.
  ##   SourceType: JString
  ##             : <p>The type of source that will be generating the events. For example, if you want to be notified of events generated by a cluster, you would set this parameter to cluster. If this value is not specified, events are returned for all Amazon Redshift objects in your AWS account. You must specify a source type in order to specify source IDs.</p> <p>Valid values: cluster, cluster-parameter-group, cluster-security-group, and cluster-snapshot.</p>
  section = newJObject()
  var valid_775896 = formData.getOrDefault("Enabled")
  valid_775896 = validateParameter(valid_775896, JBool, required = false, default = nil)
  if valid_775896 != nil:
    section.add "Enabled", valid_775896
  var valid_775897 = formData.getOrDefault("EventCategories")
  valid_775897 = validateParameter(valid_775897, JArray, required = false,
                                 default = nil)
  if valid_775897 != nil:
    section.add "EventCategories", valid_775897
  var valid_775898 = formData.getOrDefault("SnsTopicArn")
  valid_775898 = validateParameter(valid_775898, JString, required = false,
                                 default = nil)
  if valid_775898 != nil:
    section.add "SnsTopicArn", valid_775898
  var valid_775899 = formData.getOrDefault("Severity")
  valid_775899 = validateParameter(valid_775899, JString, required = false,
                                 default = nil)
  if valid_775899 != nil:
    section.add "Severity", valid_775899
  var valid_775900 = formData.getOrDefault("SourceIds")
  valid_775900 = validateParameter(valid_775900, JArray, required = false,
                                 default = nil)
  if valid_775900 != nil:
    section.add "SourceIds", valid_775900
  assert formData != nil, "formData argument is necessary due to required `SubscriptionName` field"
  var valid_775901 = formData.getOrDefault("SubscriptionName")
  valid_775901 = validateParameter(valid_775901, JString, required = true,
                                 default = nil)
  if valid_775901 != nil:
    section.add "SubscriptionName", valid_775901
  var valid_775902 = formData.getOrDefault("SourceType")
  valid_775902 = validateParameter(valid_775902, JString, required = false,
                                 default = nil)
  if valid_775902 != nil:
    section.add "SourceType", valid_775902
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_775903: Call_PostModifyEventSubscription_775884; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Modifies an existing Amazon Redshift event notification subscription.
  ## 
  let valid = call_775903.validator(path, query, header, formData, body)
  let scheme = call_775903.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_775903.url(scheme.get, call_775903.host, call_775903.base,
                         call_775903.route, valid.getOrDefault("path"))
  result = hook(call_775903, url, valid)

proc call*(call_775904: Call_PostModifyEventSubscription_775884;
          SubscriptionName: string; Enabled: bool = false;
          EventCategories: JsonNode = nil; SnsTopicArn: string = "";
          Severity: string = ""; SourceIds: JsonNode = nil;
          Action: string = "ModifyEventSubscription";
          Version: string = "2012-12-01"; SourceType: string = ""): Recallable =
  ## postModifyEventSubscription
  ## Modifies an existing Amazon Redshift event notification subscription.
  ##   Enabled: bool
  ##          : A Boolean value indicating if the subscription is enabled. <code>true</code> indicates the subscription is enabled 
  ##   EventCategories: JArray
  ##                  : <p>Specifies the Amazon Redshift event categories to be published by the event notification subscription.</p> <p>Values: configuration, management, monitoring, security</p>
  ##   SnsTopicArn: string
  ##              : The Amazon Resource Name (ARN) of the SNS topic to be used by the event notification subscription.
  ##   Severity: string
  ##           : <p>Specifies the Amazon Redshift event severity to be published by the event notification subscription.</p> <p>Values: ERROR, INFO</p>
  ##   SourceIds: JArray
  ##            : <p>A list of one or more identifiers of Amazon Redshift source objects. All of the objects must be of the same type as was specified in the source type parameter. The event subscription will return only events generated by the specified objects. If not specified, then events are returned for all objects within the source type specified.</p> <p>Example: my-cluster-1, my-cluster-2</p> <p>Example: my-snapshot-20131010</p>
  ##   SubscriptionName: string (required)
  ##                   : The name of the modified Amazon Redshift event notification subscription.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   SourceType: string
  ##             : <p>The type of source that will be generating the events. For example, if you want to be notified of events generated by a cluster, you would set this parameter to cluster. If this value is not specified, events are returned for all Amazon Redshift objects in your AWS account. You must specify a source type in order to specify source IDs.</p> <p>Valid values: cluster, cluster-parameter-group, cluster-security-group, and cluster-snapshot.</p>
  var query_775905 = newJObject()
  var formData_775906 = newJObject()
  add(formData_775906, "Enabled", newJBool(Enabled))
  if EventCategories != nil:
    formData_775906.add "EventCategories", EventCategories
  add(formData_775906, "SnsTopicArn", newJString(SnsTopicArn))
  add(formData_775906, "Severity", newJString(Severity))
  if SourceIds != nil:
    formData_775906.add "SourceIds", SourceIds
  add(formData_775906, "SubscriptionName", newJString(SubscriptionName))
  add(query_775905, "Action", newJString(Action))
  add(query_775905, "Version", newJString(Version))
  add(formData_775906, "SourceType", newJString(SourceType))
  result = call_775904.call(nil, query_775905, nil, formData_775906, nil)

var postModifyEventSubscription* = Call_PostModifyEventSubscription_775884(
    name: "postModifyEventSubscription", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyEventSubscription",
    validator: validate_PostModifyEventSubscription_775885, base: "/",
    url: url_PostModifyEventSubscription_775886,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetModifyEventSubscription_775862 = ref object of OpenApiRestCall_772581
proc url_GetModifyEventSubscription_775864(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_GetModifyEventSubscription_775863(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies an existing Amazon Redshift event notification subscription.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   SourceType: JString
  ##             : <p>The type of source that will be generating the events. For example, if you want to be notified of events generated by a cluster, you would set this parameter to cluster. If this value is not specified, events are returned for all Amazon Redshift objects in your AWS account. You must specify a source type in order to specify source IDs.</p> <p>Valid values: cluster, cluster-parameter-group, cluster-security-group, and cluster-snapshot.</p>
  ##   SourceIds: JArray
  ##            : <p>A list of one or more identifiers of Amazon Redshift source objects. All of the objects must be of the same type as was specified in the source type parameter. The event subscription will return only events generated by the specified objects. If not specified, then events are returned for all objects within the source type specified.</p> <p>Example: my-cluster-1, my-cluster-2</p> <p>Example: my-snapshot-20131010</p>
  ##   Enabled: JBool
  ##          : A Boolean value indicating if the subscription is enabled. <code>true</code> indicates the subscription is enabled 
  ##   Action: JString (required)
  ##   SnsTopicArn: JString
  ##              : The Amazon Resource Name (ARN) of the SNS topic to be used by the event notification subscription.
  ##   EventCategories: JArray
  ##                  : <p>Specifies the Amazon Redshift event categories to be published by the event notification subscription.</p> <p>Values: configuration, management, monitoring, security</p>
  ##   SubscriptionName: JString (required)
  ##                   : The name of the modified Amazon Redshift event notification subscription.
  ##   Severity: JString
  ##           : <p>Specifies the Amazon Redshift event severity to be published by the event notification subscription.</p> <p>Values: ERROR, INFO</p>
  ##   Version: JString (required)
  section = newJObject()
  var valid_775865 = query.getOrDefault("SourceType")
  valid_775865 = validateParameter(valid_775865, JString, required = false,
                                 default = nil)
  if valid_775865 != nil:
    section.add "SourceType", valid_775865
  var valid_775866 = query.getOrDefault("SourceIds")
  valid_775866 = validateParameter(valid_775866, JArray, required = false,
                                 default = nil)
  if valid_775866 != nil:
    section.add "SourceIds", valid_775866
  var valid_775867 = query.getOrDefault("Enabled")
  valid_775867 = validateParameter(valid_775867, JBool, required = false, default = nil)
  if valid_775867 != nil:
    section.add "Enabled", valid_775867
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_775868 = query.getOrDefault("Action")
  valid_775868 = validateParameter(valid_775868, JString, required = true, default = newJString(
      "ModifyEventSubscription"))
  if valid_775868 != nil:
    section.add "Action", valid_775868
  var valid_775869 = query.getOrDefault("SnsTopicArn")
  valid_775869 = validateParameter(valid_775869, JString, required = false,
                                 default = nil)
  if valid_775869 != nil:
    section.add "SnsTopicArn", valid_775869
  var valid_775870 = query.getOrDefault("EventCategories")
  valid_775870 = validateParameter(valid_775870, JArray, required = false,
                                 default = nil)
  if valid_775870 != nil:
    section.add "EventCategories", valid_775870
  var valid_775871 = query.getOrDefault("SubscriptionName")
  valid_775871 = validateParameter(valid_775871, JString, required = true,
                                 default = nil)
  if valid_775871 != nil:
    section.add "SubscriptionName", valid_775871
  var valid_775872 = query.getOrDefault("Severity")
  valid_775872 = validateParameter(valid_775872, JString, required = false,
                                 default = nil)
  if valid_775872 != nil:
    section.add "Severity", valid_775872
  var valid_775873 = query.getOrDefault("Version")
  valid_775873 = validateParameter(valid_775873, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_775873 != nil:
    section.add "Version", valid_775873
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_775874 = header.getOrDefault("X-Amz-Date")
  valid_775874 = validateParameter(valid_775874, JString, required = false,
                                 default = nil)
  if valid_775874 != nil:
    section.add "X-Amz-Date", valid_775874
  var valid_775875 = header.getOrDefault("X-Amz-Security-Token")
  valid_775875 = validateParameter(valid_775875, JString, required = false,
                                 default = nil)
  if valid_775875 != nil:
    section.add "X-Amz-Security-Token", valid_775875
  var valid_775876 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_775876 = validateParameter(valid_775876, JString, required = false,
                                 default = nil)
  if valid_775876 != nil:
    section.add "X-Amz-Content-Sha256", valid_775876
  var valid_775877 = header.getOrDefault("X-Amz-Algorithm")
  valid_775877 = validateParameter(valid_775877, JString, required = false,
                                 default = nil)
  if valid_775877 != nil:
    section.add "X-Amz-Algorithm", valid_775877
  var valid_775878 = header.getOrDefault("X-Amz-Signature")
  valid_775878 = validateParameter(valid_775878, JString, required = false,
                                 default = nil)
  if valid_775878 != nil:
    section.add "X-Amz-Signature", valid_775878
  var valid_775879 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_775879 = validateParameter(valid_775879, JString, required = false,
                                 default = nil)
  if valid_775879 != nil:
    section.add "X-Amz-SignedHeaders", valid_775879
  var valid_775880 = header.getOrDefault("X-Amz-Credential")
  valid_775880 = validateParameter(valid_775880, JString, required = false,
                                 default = nil)
  if valid_775880 != nil:
    section.add "X-Amz-Credential", valid_775880
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_775881: Call_GetModifyEventSubscription_775862; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Modifies an existing Amazon Redshift event notification subscription.
  ## 
  let valid = call_775881.validator(path, query, header, formData, body)
  let scheme = call_775881.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_775881.url(scheme.get, call_775881.host, call_775881.base,
                         call_775881.route, valid.getOrDefault("path"))
  result = hook(call_775881, url, valid)

proc call*(call_775882: Call_GetModifyEventSubscription_775862;
          SubscriptionName: string; SourceType: string = "";
          SourceIds: JsonNode = nil; Enabled: bool = false;
          Action: string = "ModifyEventSubscription"; SnsTopicArn: string = "";
          EventCategories: JsonNode = nil; Severity: string = "";
          Version: string = "2012-12-01"): Recallable =
  ## getModifyEventSubscription
  ## Modifies an existing Amazon Redshift event notification subscription.
  ##   SourceType: string
  ##             : <p>The type of source that will be generating the events. For example, if you want to be notified of events generated by a cluster, you would set this parameter to cluster. If this value is not specified, events are returned for all Amazon Redshift objects in your AWS account. You must specify a source type in order to specify source IDs.</p> <p>Valid values: cluster, cluster-parameter-group, cluster-security-group, and cluster-snapshot.</p>
  ##   SourceIds: JArray
  ##            : <p>A list of one or more identifiers of Amazon Redshift source objects. All of the objects must be of the same type as was specified in the source type parameter. The event subscription will return only events generated by the specified objects. If not specified, then events are returned for all objects within the source type specified.</p> <p>Example: my-cluster-1, my-cluster-2</p> <p>Example: my-snapshot-20131010</p>
  ##   Enabled: bool
  ##          : A Boolean value indicating if the subscription is enabled. <code>true</code> indicates the subscription is enabled 
  ##   Action: string (required)
  ##   SnsTopicArn: string
  ##              : The Amazon Resource Name (ARN) of the SNS topic to be used by the event notification subscription.
  ##   EventCategories: JArray
  ##                  : <p>Specifies the Amazon Redshift event categories to be published by the event notification subscription.</p> <p>Values: configuration, management, monitoring, security</p>
  ##   SubscriptionName: string (required)
  ##                   : The name of the modified Amazon Redshift event notification subscription.
  ##   Severity: string
  ##           : <p>Specifies the Amazon Redshift event severity to be published by the event notification subscription.</p> <p>Values: ERROR, INFO</p>
  ##   Version: string (required)
  var query_775883 = newJObject()
  add(query_775883, "SourceType", newJString(SourceType))
  if SourceIds != nil:
    query_775883.add "SourceIds", SourceIds
  add(query_775883, "Enabled", newJBool(Enabled))
  add(query_775883, "Action", newJString(Action))
  add(query_775883, "SnsTopicArn", newJString(SnsTopicArn))
  if EventCategories != nil:
    query_775883.add "EventCategories", EventCategories
  add(query_775883, "SubscriptionName", newJString(SubscriptionName))
  add(query_775883, "Severity", newJString(Severity))
  add(query_775883, "Version", newJString(Version))
  result = call_775882.call(nil, query_775883, nil, nil, nil)

var getModifyEventSubscription* = Call_GetModifyEventSubscription_775862(
    name: "getModifyEventSubscription", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyEventSubscription",
    validator: validate_GetModifyEventSubscription_775863, base: "/",
    url: url_GetModifyEventSubscription_775864,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostModifySnapshotCopyRetentionPeriod_775925 = ref object of OpenApiRestCall_772581
proc url_PostModifySnapshotCopyRetentionPeriod_775927(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_PostModifySnapshotCopyRetentionPeriod_775926(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies the number of days to retain snapshots in the destination AWS Region after they are copied from the source AWS Region. By default, this operation only changes the retention period of copied automated snapshots. The retention periods for both new and existing copied automated snapshots are updated with the new retention period. You can set the manual option to change only the retention periods of copied manual snapshots. If you set this option, only newly copied manual snapshots have the new retention period. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_775928 = query.getOrDefault("Action")
  valid_775928 = validateParameter(valid_775928, JString, required = true, default = newJString(
      "ModifySnapshotCopyRetentionPeriod"))
  if valid_775928 != nil:
    section.add "Action", valid_775928
  var valid_775929 = query.getOrDefault("Version")
  valid_775929 = validateParameter(valid_775929, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_775929 != nil:
    section.add "Version", valid_775929
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_775930 = header.getOrDefault("X-Amz-Date")
  valid_775930 = validateParameter(valid_775930, JString, required = false,
                                 default = nil)
  if valid_775930 != nil:
    section.add "X-Amz-Date", valid_775930
  var valid_775931 = header.getOrDefault("X-Amz-Security-Token")
  valid_775931 = validateParameter(valid_775931, JString, required = false,
                                 default = nil)
  if valid_775931 != nil:
    section.add "X-Amz-Security-Token", valid_775931
  var valid_775932 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_775932 = validateParameter(valid_775932, JString, required = false,
                                 default = nil)
  if valid_775932 != nil:
    section.add "X-Amz-Content-Sha256", valid_775932
  var valid_775933 = header.getOrDefault("X-Amz-Algorithm")
  valid_775933 = validateParameter(valid_775933, JString, required = false,
                                 default = nil)
  if valid_775933 != nil:
    section.add "X-Amz-Algorithm", valid_775933
  var valid_775934 = header.getOrDefault("X-Amz-Signature")
  valid_775934 = validateParameter(valid_775934, JString, required = false,
                                 default = nil)
  if valid_775934 != nil:
    section.add "X-Amz-Signature", valid_775934
  var valid_775935 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_775935 = validateParameter(valid_775935, JString, required = false,
                                 default = nil)
  if valid_775935 != nil:
    section.add "X-Amz-SignedHeaders", valid_775935
  var valid_775936 = header.getOrDefault("X-Amz-Credential")
  valid_775936 = validateParameter(valid_775936, JString, required = false,
                                 default = nil)
  if valid_775936 != nil:
    section.add "X-Amz-Credential", valid_775936
  result.add "header", section
  ## parameters in `formData` object:
  ##   Manual: JBool
  ##         : Indicates whether to apply the snapshot retention period to newly copied manual snapshots instead of automated snapshots.
  ##   RetentionPeriod: JInt (required)
  ##                  : <p>The number of days to retain automated snapshots in the destination AWS Region after they are copied from the source AWS Region.</p> <p>By default, this only changes the retention period of copied automated snapshots. </p> <p>If you decrease the retention period for automated snapshots that are copied to a destination AWS Region, Amazon Redshift deletes any existing automated snapshots that were copied to the destination AWS Region and that fall outside of the new retention period.</p> <p>Constraints: Must be at least 1 and no more than 35 for automated snapshots. </p> <p>If you specify the <code>manual</code> option, only newly copied manual snapshots will have the new retention period. </p> <p>If you specify the value of -1 newly copied manual snapshots are retained indefinitely.</p> <p>Constraints: The number of days must be either -1 or an integer between 1 and 3,653 for manual snapshots.</p>
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of the cluster for which you want to change the retention period for either automated or manual snapshots that are copied to a destination AWS Region.</p> <p>Constraints: Must be the valid name of an existing cluster that has cross-region snapshot copy enabled.</p>
  section = newJObject()
  var valid_775937 = formData.getOrDefault("Manual")
  valid_775937 = validateParameter(valid_775937, JBool, required = false, default = nil)
  if valid_775937 != nil:
    section.add "Manual", valid_775937
  assert formData != nil, "formData argument is necessary due to required `RetentionPeriod` field"
  var valid_775938 = formData.getOrDefault("RetentionPeriod")
  valid_775938 = validateParameter(valid_775938, JInt, required = true, default = nil)
  if valid_775938 != nil:
    section.add "RetentionPeriod", valid_775938
  var valid_775939 = formData.getOrDefault("ClusterIdentifier")
  valid_775939 = validateParameter(valid_775939, JString, required = true,
                                 default = nil)
  if valid_775939 != nil:
    section.add "ClusterIdentifier", valid_775939
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_775940: Call_PostModifySnapshotCopyRetentionPeriod_775925;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Modifies the number of days to retain snapshots in the destination AWS Region after they are copied from the source AWS Region. By default, this operation only changes the retention period of copied automated snapshots. The retention periods for both new and existing copied automated snapshots are updated with the new retention period. You can set the manual option to change only the retention periods of copied manual snapshots. If you set this option, only newly copied manual snapshots have the new retention period. 
  ## 
  let valid = call_775940.validator(path, query, header, formData, body)
  let scheme = call_775940.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_775940.url(scheme.get, call_775940.host, call_775940.base,
                         call_775940.route, valid.getOrDefault("path"))
  result = hook(call_775940, url, valid)

proc call*(call_775941: Call_PostModifySnapshotCopyRetentionPeriod_775925;
          RetentionPeriod: int; ClusterIdentifier: string; Manual: bool = false;
          Action: string = "ModifySnapshotCopyRetentionPeriod";
          Version: string = "2012-12-01"): Recallable =
  ## postModifySnapshotCopyRetentionPeriod
  ## Modifies the number of days to retain snapshots in the destination AWS Region after they are copied from the source AWS Region. By default, this operation only changes the retention period of copied automated snapshots. The retention periods for both new and existing copied automated snapshots are updated with the new retention period. You can set the manual option to change only the retention periods of copied manual snapshots. If you set this option, only newly copied manual snapshots have the new retention period. 
  ##   Manual: bool
  ##         : Indicates whether to apply the snapshot retention period to newly copied manual snapshots instead of automated snapshots.
  ##   RetentionPeriod: int (required)
  ##                  : <p>The number of days to retain automated snapshots in the destination AWS Region after they are copied from the source AWS Region.</p> <p>By default, this only changes the retention period of copied automated snapshots. </p> <p>If you decrease the retention period for automated snapshots that are copied to a destination AWS Region, Amazon Redshift deletes any existing automated snapshots that were copied to the destination AWS Region and that fall outside of the new retention period.</p> <p>Constraints: Must be at least 1 and no more than 35 for automated snapshots. </p> <p>If you specify the <code>manual</code> option, only newly copied manual snapshots will have the new retention period. </p> <p>If you specify the value of -1 newly copied manual snapshots are retained indefinitely.</p> <p>Constraints: The number of days must be either -1 or an integer between 1 and 3,653 for manual snapshots.</p>
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of the cluster for which you want to change the retention period for either automated or manual snapshots that are copied to a destination AWS Region.</p> <p>Constraints: Must be the valid name of an existing cluster that has cross-region snapshot copy enabled.</p>
  ##   Version: string (required)
  var query_775942 = newJObject()
  var formData_775943 = newJObject()
  add(formData_775943, "Manual", newJBool(Manual))
  add(formData_775943, "RetentionPeriod", newJInt(RetentionPeriod))
  add(query_775942, "Action", newJString(Action))
  add(formData_775943, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_775942, "Version", newJString(Version))
  result = call_775941.call(nil, query_775942, nil, formData_775943, nil)

var postModifySnapshotCopyRetentionPeriod* = Call_PostModifySnapshotCopyRetentionPeriod_775925(
    name: "postModifySnapshotCopyRetentionPeriod", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=ModifySnapshotCopyRetentionPeriod",
    validator: validate_PostModifySnapshotCopyRetentionPeriod_775926, base: "/",
    url: url_PostModifySnapshotCopyRetentionPeriod_775927,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetModifySnapshotCopyRetentionPeriod_775907 = ref object of OpenApiRestCall_772581
proc url_GetModifySnapshotCopyRetentionPeriod_775909(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_GetModifySnapshotCopyRetentionPeriod_775908(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies the number of days to retain snapshots in the destination AWS Region after they are copied from the source AWS Region. By default, this operation only changes the retention period of copied automated snapshots. The retention periods for both new and existing copied automated snapshots are updated with the new retention period. You can set the manual option to change only the retention periods of copied manual snapshots. If you set this option, only newly copied manual snapshots have the new retention period. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Manual: JBool
  ##         : Indicates whether to apply the snapshot retention period to newly copied manual snapshots instead of automated snapshots.
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of the cluster for which you want to change the retention period for either automated or manual snapshots that are copied to a destination AWS Region.</p> <p>Constraints: Must be the valid name of an existing cluster that has cross-region snapshot copy enabled.</p>
  ##   RetentionPeriod: JInt (required)
  ##                  : <p>The number of days to retain automated snapshots in the destination AWS Region after they are copied from the source AWS Region.</p> <p>By default, this only changes the retention period of copied automated snapshots. </p> <p>If you decrease the retention period for automated snapshots that are copied to a destination AWS Region, Amazon Redshift deletes any existing automated snapshots that were copied to the destination AWS Region and that fall outside of the new retention period.</p> <p>Constraints: Must be at least 1 and no more than 35 for automated snapshots. </p> <p>If you specify the <code>manual</code> option, only newly copied manual snapshots will have the new retention period. </p> <p>If you specify the value of -1 newly copied manual snapshots are retained indefinitely.</p> <p>Constraints: The number of days must be either -1 or an integer between 1 and 3,653 for manual snapshots.</p>
  ##   Version: JString (required)
  section = newJObject()
  var valid_775910 = query.getOrDefault("Manual")
  valid_775910 = validateParameter(valid_775910, JBool, required = false, default = nil)
  if valid_775910 != nil:
    section.add "Manual", valid_775910
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_775911 = query.getOrDefault("Action")
  valid_775911 = validateParameter(valid_775911, JString, required = true, default = newJString(
      "ModifySnapshotCopyRetentionPeriod"))
  if valid_775911 != nil:
    section.add "Action", valid_775911
  var valid_775912 = query.getOrDefault("ClusterIdentifier")
  valid_775912 = validateParameter(valid_775912, JString, required = true,
                                 default = nil)
  if valid_775912 != nil:
    section.add "ClusterIdentifier", valid_775912
  var valid_775913 = query.getOrDefault("RetentionPeriod")
  valid_775913 = validateParameter(valid_775913, JInt, required = true, default = nil)
  if valid_775913 != nil:
    section.add "RetentionPeriod", valid_775913
  var valid_775914 = query.getOrDefault("Version")
  valid_775914 = validateParameter(valid_775914, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_775914 != nil:
    section.add "Version", valid_775914
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_775915 = header.getOrDefault("X-Amz-Date")
  valid_775915 = validateParameter(valid_775915, JString, required = false,
                                 default = nil)
  if valid_775915 != nil:
    section.add "X-Amz-Date", valid_775915
  var valid_775916 = header.getOrDefault("X-Amz-Security-Token")
  valid_775916 = validateParameter(valid_775916, JString, required = false,
                                 default = nil)
  if valid_775916 != nil:
    section.add "X-Amz-Security-Token", valid_775916
  var valid_775917 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_775917 = validateParameter(valid_775917, JString, required = false,
                                 default = nil)
  if valid_775917 != nil:
    section.add "X-Amz-Content-Sha256", valid_775917
  var valid_775918 = header.getOrDefault("X-Amz-Algorithm")
  valid_775918 = validateParameter(valid_775918, JString, required = false,
                                 default = nil)
  if valid_775918 != nil:
    section.add "X-Amz-Algorithm", valid_775918
  var valid_775919 = header.getOrDefault("X-Amz-Signature")
  valid_775919 = validateParameter(valid_775919, JString, required = false,
                                 default = nil)
  if valid_775919 != nil:
    section.add "X-Amz-Signature", valid_775919
  var valid_775920 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_775920 = validateParameter(valid_775920, JString, required = false,
                                 default = nil)
  if valid_775920 != nil:
    section.add "X-Amz-SignedHeaders", valid_775920
  var valid_775921 = header.getOrDefault("X-Amz-Credential")
  valid_775921 = validateParameter(valid_775921, JString, required = false,
                                 default = nil)
  if valid_775921 != nil:
    section.add "X-Amz-Credential", valid_775921
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_775922: Call_GetModifySnapshotCopyRetentionPeriod_775907;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Modifies the number of days to retain snapshots in the destination AWS Region after they are copied from the source AWS Region. By default, this operation only changes the retention period of copied automated snapshots. The retention periods for both new and existing copied automated snapshots are updated with the new retention period. You can set the manual option to change only the retention periods of copied manual snapshots. If you set this option, only newly copied manual snapshots have the new retention period. 
  ## 
  let valid = call_775922.validator(path, query, header, formData, body)
  let scheme = call_775922.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_775922.url(scheme.get, call_775922.host, call_775922.base,
                         call_775922.route, valid.getOrDefault("path"))
  result = hook(call_775922, url, valid)

proc call*(call_775923: Call_GetModifySnapshotCopyRetentionPeriod_775907;
          ClusterIdentifier: string; RetentionPeriod: int; Manual: bool = false;
          Action: string = "ModifySnapshotCopyRetentionPeriod";
          Version: string = "2012-12-01"): Recallable =
  ## getModifySnapshotCopyRetentionPeriod
  ## Modifies the number of days to retain snapshots in the destination AWS Region after they are copied from the source AWS Region. By default, this operation only changes the retention period of copied automated snapshots. The retention periods for both new and existing copied automated snapshots are updated with the new retention period. You can set the manual option to change only the retention periods of copied manual snapshots. If you set this option, only newly copied manual snapshots have the new retention period. 
  ##   Manual: bool
  ##         : Indicates whether to apply the snapshot retention period to newly copied manual snapshots instead of automated snapshots.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of the cluster for which you want to change the retention period for either automated or manual snapshots that are copied to a destination AWS Region.</p> <p>Constraints: Must be the valid name of an existing cluster that has cross-region snapshot copy enabled.</p>
  ##   RetentionPeriod: int (required)
  ##                  : <p>The number of days to retain automated snapshots in the destination AWS Region after they are copied from the source AWS Region.</p> <p>By default, this only changes the retention period of copied automated snapshots. </p> <p>If you decrease the retention period for automated snapshots that are copied to a destination AWS Region, Amazon Redshift deletes any existing automated snapshots that were copied to the destination AWS Region and that fall outside of the new retention period.</p> <p>Constraints: Must be at least 1 and no more than 35 for automated snapshots. </p> <p>If you specify the <code>manual</code> option, only newly copied manual snapshots will have the new retention period. </p> <p>If you specify the value of -1 newly copied manual snapshots are retained indefinitely.</p> <p>Constraints: The number of days must be either -1 or an integer between 1 and 3,653 for manual snapshots.</p>
  ##   Version: string (required)
  var query_775924 = newJObject()
  add(query_775924, "Manual", newJBool(Manual))
  add(query_775924, "Action", newJString(Action))
  add(query_775924, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_775924, "RetentionPeriod", newJInt(RetentionPeriod))
  add(query_775924, "Version", newJString(Version))
  result = call_775923.call(nil, query_775924, nil, nil, nil)

var getModifySnapshotCopyRetentionPeriod* = Call_GetModifySnapshotCopyRetentionPeriod_775907(
    name: "getModifySnapshotCopyRetentionPeriod", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=ModifySnapshotCopyRetentionPeriod",
    validator: validate_GetModifySnapshotCopyRetentionPeriod_775908, base: "/",
    url: url_GetModifySnapshotCopyRetentionPeriod_775909,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostModifySnapshotSchedule_775961 = ref object of OpenApiRestCall_772581
proc url_PostModifySnapshotSchedule_775963(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_PostModifySnapshotSchedule_775962(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies a snapshot schedule. Any schedule associated with a cluster is modified asynchronously.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_775964 = query.getOrDefault("Action")
  valid_775964 = validateParameter(valid_775964, JString, required = true,
                                 default = newJString("ModifySnapshotSchedule"))
  if valid_775964 != nil:
    section.add "Action", valid_775964
  var valid_775965 = query.getOrDefault("Version")
  valid_775965 = validateParameter(valid_775965, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_775965 != nil:
    section.add "Version", valid_775965
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_775966 = header.getOrDefault("X-Amz-Date")
  valid_775966 = validateParameter(valid_775966, JString, required = false,
                                 default = nil)
  if valid_775966 != nil:
    section.add "X-Amz-Date", valid_775966
  var valid_775967 = header.getOrDefault("X-Amz-Security-Token")
  valid_775967 = validateParameter(valid_775967, JString, required = false,
                                 default = nil)
  if valid_775967 != nil:
    section.add "X-Amz-Security-Token", valid_775967
  var valid_775968 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_775968 = validateParameter(valid_775968, JString, required = false,
                                 default = nil)
  if valid_775968 != nil:
    section.add "X-Amz-Content-Sha256", valid_775968
  var valid_775969 = header.getOrDefault("X-Amz-Algorithm")
  valid_775969 = validateParameter(valid_775969, JString, required = false,
                                 default = nil)
  if valid_775969 != nil:
    section.add "X-Amz-Algorithm", valid_775969
  var valid_775970 = header.getOrDefault("X-Amz-Signature")
  valid_775970 = validateParameter(valid_775970, JString, required = false,
                                 default = nil)
  if valid_775970 != nil:
    section.add "X-Amz-Signature", valid_775970
  var valid_775971 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_775971 = validateParameter(valid_775971, JString, required = false,
                                 default = nil)
  if valid_775971 != nil:
    section.add "X-Amz-SignedHeaders", valid_775971
  var valid_775972 = header.getOrDefault("X-Amz-Credential")
  valid_775972 = validateParameter(valid_775972, JString, required = false,
                                 default = nil)
  if valid_775972 != nil:
    section.add "X-Amz-Credential", valid_775972
  result.add "header", section
  ## parameters in `formData` object:
  ##   ScheduleDefinitions: JArray (required)
  ##                      : An updated list of schedule definitions. A schedule definition is made up of schedule expressions, for example, "cron(30 12 *)" or "rate(12 hours)".
  ##   ScheduleIdentifier: JString (required)
  ##                     : A unique alphanumeric identifier of the schedule to modify.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ScheduleDefinitions` field"
  var valid_775973 = formData.getOrDefault("ScheduleDefinitions")
  valid_775973 = validateParameter(valid_775973, JArray, required = true, default = nil)
  if valid_775973 != nil:
    section.add "ScheduleDefinitions", valid_775973
  var valid_775974 = formData.getOrDefault("ScheduleIdentifier")
  valid_775974 = validateParameter(valid_775974, JString, required = true,
                                 default = nil)
  if valid_775974 != nil:
    section.add "ScheduleIdentifier", valid_775974
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_775975: Call_PostModifySnapshotSchedule_775961; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Modifies a snapshot schedule. Any schedule associated with a cluster is modified asynchronously.
  ## 
  let valid = call_775975.validator(path, query, header, formData, body)
  let scheme = call_775975.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_775975.url(scheme.get, call_775975.host, call_775975.base,
                         call_775975.route, valid.getOrDefault("path"))
  result = hook(call_775975, url, valid)

proc call*(call_775976: Call_PostModifySnapshotSchedule_775961;
          ScheduleDefinitions: JsonNode; ScheduleIdentifier: string;
          Action: string = "ModifySnapshotSchedule"; Version: string = "2012-12-01"): Recallable =
  ## postModifySnapshotSchedule
  ## Modifies a snapshot schedule. Any schedule associated with a cluster is modified asynchronously.
  ##   ScheduleDefinitions: JArray (required)
  ##                      : An updated list of schedule definitions. A schedule definition is made up of schedule expressions, for example, "cron(30 12 *)" or "rate(12 hours)".
  ##   Action: string (required)
  ##   ScheduleIdentifier: string (required)
  ##                     : A unique alphanumeric identifier of the schedule to modify.
  ##   Version: string (required)
  var query_775977 = newJObject()
  var formData_775978 = newJObject()
  if ScheduleDefinitions != nil:
    formData_775978.add "ScheduleDefinitions", ScheduleDefinitions
  add(query_775977, "Action", newJString(Action))
  add(formData_775978, "ScheduleIdentifier", newJString(ScheduleIdentifier))
  add(query_775977, "Version", newJString(Version))
  result = call_775976.call(nil, query_775977, nil, formData_775978, nil)

var postModifySnapshotSchedule* = Call_PostModifySnapshotSchedule_775961(
    name: "postModifySnapshotSchedule", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=ModifySnapshotSchedule",
    validator: validate_PostModifySnapshotSchedule_775962, base: "/",
    url: url_PostModifySnapshotSchedule_775963,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetModifySnapshotSchedule_775944 = ref object of OpenApiRestCall_772581
proc url_GetModifySnapshotSchedule_775946(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_GetModifySnapshotSchedule_775945(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies a snapshot schedule. Any schedule associated with a cluster is modified asynchronously.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ScheduleDefinitions: JArray (required)
  ##                      : An updated list of schedule definitions. A schedule definition is made up of schedule expressions, for example, "cron(30 12 *)" or "rate(12 hours)".
  ##   Action: JString (required)
  ##   ScheduleIdentifier: JString (required)
  ##                     : A unique alphanumeric identifier of the schedule to modify.
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `ScheduleDefinitions` field"
  var valid_775947 = query.getOrDefault("ScheduleDefinitions")
  valid_775947 = validateParameter(valid_775947, JArray, required = true, default = nil)
  if valid_775947 != nil:
    section.add "ScheduleDefinitions", valid_775947
  var valid_775948 = query.getOrDefault("Action")
  valid_775948 = validateParameter(valid_775948, JString, required = true,
                                 default = newJString("ModifySnapshotSchedule"))
  if valid_775948 != nil:
    section.add "Action", valid_775948
  var valid_775949 = query.getOrDefault("ScheduleIdentifier")
  valid_775949 = validateParameter(valid_775949, JString, required = true,
                                 default = nil)
  if valid_775949 != nil:
    section.add "ScheduleIdentifier", valid_775949
  var valid_775950 = query.getOrDefault("Version")
  valid_775950 = validateParameter(valid_775950, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_775950 != nil:
    section.add "Version", valid_775950
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_775951 = header.getOrDefault("X-Amz-Date")
  valid_775951 = validateParameter(valid_775951, JString, required = false,
                                 default = nil)
  if valid_775951 != nil:
    section.add "X-Amz-Date", valid_775951
  var valid_775952 = header.getOrDefault("X-Amz-Security-Token")
  valid_775952 = validateParameter(valid_775952, JString, required = false,
                                 default = nil)
  if valid_775952 != nil:
    section.add "X-Amz-Security-Token", valid_775952
  var valid_775953 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_775953 = validateParameter(valid_775953, JString, required = false,
                                 default = nil)
  if valid_775953 != nil:
    section.add "X-Amz-Content-Sha256", valid_775953
  var valid_775954 = header.getOrDefault("X-Amz-Algorithm")
  valid_775954 = validateParameter(valid_775954, JString, required = false,
                                 default = nil)
  if valid_775954 != nil:
    section.add "X-Amz-Algorithm", valid_775954
  var valid_775955 = header.getOrDefault("X-Amz-Signature")
  valid_775955 = validateParameter(valid_775955, JString, required = false,
                                 default = nil)
  if valid_775955 != nil:
    section.add "X-Amz-Signature", valid_775955
  var valid_775956 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_775956 = validateParameter(valid_775956, JString, required = false,
                                 default = nil)
  if valid_775956 != nil:
    section.add "X-Amz-SignedHeaders", valid_775956
  var valid_775957 = header.getOrDefault("X-Amz-Credential")
  valid_775957 = validateParameter(valid_775957, JString, required = false,
                                 default = nil)
  if valid_775957 != nil:
    section.add "X-Amz-Credential", valid_775957
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_775958: Call_GetModifySnapshotSchedule_775944; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Modifies a snapshot schedule. Any schedule associated with a cluster is modified asynchronously.
  ## 
  let valid = call_775958.validator(path, query, header, formData, body)
  let scheme = call_775958.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_775958.url(scheme.get, call_775958.host, call_775958.base,
                         call_775958.route, valid.getOrDefault("path"))
  result = hook(call_775958, url, valid)

proc call*(call_775959: Call_GetModifySnapshotSchedule_775944;
          ScheduleDefinitions: JsonNode; ScheduleIdentifier: string;
          Action: string = "ModifySnapshotSchedule"; Version: string = "2012-12-01"): Recallable =
  ## getModifySnapshotSchedule
  ## Modifies a snapshot schedule. Any schedule associated with a cluster is modified asynchronously.
  ##   ScheduleDefinitions: JArray (required)
  ##                      : An updated list of schedule definitions. A schedule definition is made up of schedule expressions, for example, "cron(30 12 *)" or "rate(12 hours)".
  ##   Action: string (required)
  ##   ScheduleIdentifier: string (required)
  ##                     : A unique alphanumeric identifier of the schedule to modify.
  ##   Version: string (required)
  var query_775960 = newJObject()
  if ScheduleDefinitions != nil:
    query_775960.add "ScheduleDefinitions", ScheduleDefinitions
  add(query_775960, "Action", newJString(Action))
  add(query_775960, "ScheduleIdentifier", newJString(ScheduleIdentifier))
  add(query_775960, "Version", newJString(Version))
  result = call_775959.call(nil, query_775960, nil, nil, nil)

var getModifySnapshotSchedule* = Call_GetModifySnapshotSchedule_775944(
    name: "getModifySnapshotSchedule", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=ModifySnapshotSchedule",
    validator: validate_GetModifySnapshotSchedule_775945, base: "/",
    url: url_GetModifySnapshotSchedule_775946,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostPurchaseReservedNodeOffering_775996 = ref object of OpenApiRestCall_772581
proc url_PostPurchaseReservedNodeOffering_775998(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_PostPurchaseReservedNodeOffering_775997(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Allows you to purchase reserved nodes. Amazon Redshift offers a predefined set of reserved node offerings. You can purchase one or more of the offerings. You can call the <a>DescribeReservedNodeOfferings</a> API to obtain the available reserved node offerings. You can call this API by providing a specific reserved node offering and the number of nodes you want to reserve. </p> <p> For more information about reserved node offerings, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_775999 = query.getOrDefault("Action")
  valid_775999 = validateParameter(valid_775999, JString, required = true, default = newJString(
      "PurchaseReservedNodeOffering"))
  if valid_775999 != nil:
    section.add "Action", valid_775999
  var valid_776000 = query.getOrDefault("Version")
  valid_776000 = validateParameter(valid_776000, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_776000 != nil:
    section.add "Version", valid_776000
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_776001 = header.getOrDefault("X-Amz-Date")
  valid_776001 = validateParameter(valid_776001, JString, required = false,
                                 default = nil)
  if valid_776001 != nil:
    section.add "X-Amz-Date", valid_776001
  var valid_776002 = header.getOrDefault("X-Amz-Security-Token")
  valid_776002 = validateParameter(valid_776002, JString, required = false,
                                 default = nil)
  if valid_776002 != nil:
    section.add "X-Amz-Security-Token", valid_776002
  var valid_776003 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_776003 = validateParameter(valid_776003, JString, required = false,
                                 default = nil)
  if valid_776003 != nil:
    section.add "X-Amz-Content-Sha256", valid_776003
  var valid_776004 = header.getOrDefault("X-Amz-Algorithm")
  valid_776004 = validateParameter(valid_776004, JString, required = false,
                                 default = nil)
  if valid_776004 != nil:
    section.add "X-Amz-Algorithm", valid_776004
  var valid_776005 = header.getOrDefault("X-Amz-Signature")
  valid_776005 = validateParameter(valid_776005, JString, required = false,
                                 default = nil)
  if valid_776005 != nil:
    section.add "X-Amz-Signature", valid_776005
  var valid_776006 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_776006 = validateParameter(valid_776006, JString, required = false,
                                 default = nil)
  if valid_776006 != nil:
    section.add "X-Amz-SignedHeaders", valid_776006
  var valid_776007 = header.getOrDefault("X-Amz-Credential")
  valid_776007 = validateParameter(valid_776007, JString, required = false,
                                 default = nil)
  if valid_776007 != nil:
    section.add "X-Amz-Credential", valid_776007
  result.add "header", section
  ## parameters in `formData` object:
  ##   ReservedNodeOfferingId: JString (required)
  ##                         : The unique identifier of the reserved node offering you want to purchase.
  ##   NodeCount: JInt
  ##            : <p>The number of reserved nodes that you want to purchase.</p> <p>Default: <code>1</code> </p>
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ReservedNodeOfferingId` field"
  var valid_776008 = formData.getOrDefault("ReservedNodeOfferingId")
  valid_776008 = validateParameter(valid_776008, JString, required = true,
                                 default = nil)
  if valid_776008 != nil:
    section.add "ReservedNodeOfferingId", valid_776008
  var valid_776009 = formData.getOrDefault("NodeCount")
  valid_776009 = validateParameter(valid_776009, JInt, required = false, default = nil)
  if valid_776009 != nil:
    section.add "NodeCount", valid_776009
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_776010: Call_PostPurchaseReservedNodeOffering_775996;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Allows you to purchase reserved nodes. Amazon Redshift offers a predefined set of reserved node offerings. You can purchase one or more of the offerings. You can call the <a>DescribeReservedNodeOfferings</a> API to obtain the available reserved node offerings. You can call this API by providing a specific reserved node offering and the number of nodes you want to reserve. </p> <p> For more information about reserved node offerings, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_776010.validator(path, query, header, formData, body)
  let scheme = call_776010.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_776010.url(scheme.get, call_776010.host, call_776010.base,
                         call_776010.route, valid.getOrDefault("path"))
  result = hook(call_776010, url, valid)

proc call*(call_776011: Call_PostPurchaseReservedNodeOffering_775996;
          ReservedNodeOfferingId: string; NodeCount: int = 0;
          Action: string = "PurchaseReservedNodeOffering";
          Version: string = "2012-12-01"): Recallable =
  ## postPurchaseReservedNodeOffering
  ## <p>Allows you to purchase reserved nodes. Amazon Redshift offers a predefined set of reserved node offerings. You can purchase one or more of the offerings. You can call the <a>DescribeReservedNodeOfferings</a> API to obtain the available reserved node offerings. You can call this API by providing a specific reserved node offering and the number of nodes you want to reserve. </p> <p> For more information about reserved node offerings, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   ReservedNodeOfferingId: string (required)
  ##                         : The unique identifier of the reserved node offering you want to purchase.
  ##   NodeCount: int
  ##            : <p>The number of reserved nodes that you want to purchase.</p> <p>Default: <code>1</code> </p>
  ##   Action: string (required)
  ##   Version: string (required)
  var query_776012 = newJObject()
  var formData_776013 = newJObject()
  add(formData_776013, "ReservedNodeOfferingId",
      newJString(ReservedNodeOfferingId))
  add(formData_776013, "NodeCount", newJInt(NodeCount))
  add(query_776012, "Action", newJString(Action))
  add(query_776012, "Version", newJString(Version))
  result = call_776011.call(nil, query_776012, nil, formData_776013, nil)

var postPurchaseReservedNodeOffering* = Call_PostPurchaseReservedNodeOffering_775996(
    name: "postPurchaseReservedNodeOffering", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=PurchaseReservedNodeOffering",
    validator: validate_PostPurchaseReservedNodeOffering_775997, base: "/",
    url: url_PostPurchaseReservedNodeOffering_775998,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetPurchaseReservedNodeOffering_775979 = ref object of OpenApiRestCall_772581
proc url_GetPurchaseReservedNodeOffering_775981(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_GetPurchaseReservedNodeOffering_775980(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Allows you to purchase reserved nodes. Amazon Redshift offers a predefined set of reserved node offerings. You can purchase one or more of the offerings. You can call the <a>DescribeReservedNodeOfferings</a> API to obtain the available reserved node offerings. You can call this API by providing a specific reserved node offering and the number of nodes you want to reserve. </p> <p> For more information about reserved node offerings, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ReservedNodeOfferingId: JString (required)
  ##                         : The unique identifier of the reserved node offering you want to purchase.
  ##   Action: JString (required)
  ##   NodeCount: JInt
  ##            : <p>The number of reserved nodes that you want to purchase.</p> <p>Default: <code>1</code> </p>
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `ReservedNodeOfferingId` field"
  var valid_775982 = query.getOrDefault("ReservedNodeOfferingId")
  valid_775982 = validateParameter(valid_775982, JString, required = true,
                                 default = nil)
  if valid_775982 != nil:
    section.add "ReservedNodeOfferingId", valid_775982
  var valid_775983 = query.getOrDefault("Action")
  valid_775983 = validateParameter(valid_775983, JString, required = true, default = newJString(
      "PurchaseReservedNodeOffering"))
  if valid_775983 != nil:
    section.add "Action", valid_775983
  var valid_775984 = query.getOrDefault("NodeCount")
  valid_775984 = validateParameter(valid_775984, JInt, required = false, default = nil)
  if valid_775984 != nil:
    section.add "NodeCount", valid_775984
  var valid_775985 = query.getOrDefault("Version")
  valid_775985 = validateParameter(valid_775985, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_775985 != nil:
    section.add "Version", valid_775985
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_775986 = header.getOrDefault("X-Amz-Date")
  valid_775986 = validateParameter(valid_775986, JString, required = false,
                                 default = nil)
  if valid_775986 != nil:
    section.add "X-Amz-Date", valid_775986
  var valid_775987 = header.getOrDefault("X-Amz-Security-Token")
  valid_775987 = validateParameter(valid_775987, JString, required = false,
                                 default = nil)
  if valid_775987 != nil:
    section.add "X-Amz-Security-Token", valid_775987
  var valid_775988 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_775988 = validateParameter(valid_775988, JString, required = false,
                                 default = nil)
  if valid_775988 != nil:
    section.add "X-Amz-Content-Sha256", valid_775988
  var valid_775989 = header.getOrDefault("X-Amz-Algorithm")
  valid_775989 = validateParameter(valid_775989, JString, required = false,
                                 default = nil)
  if valid_775989 != nil:
    section.add "X-Amz-Algorithm", valid_775989
  var valid_775990 = header.getOrDefault("X-Amz-Signature")
  valid_775990 = validateParameter(valid_775990, JString, required = false,
                                 default = nil)
  if valid_775990 != nil:
    section.add "X-Amz-Signature", valid_775990
  var valid_775991 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_775991 = validateParameter(valid_775991, JString, required = false,
                                 default = nil)
  if valid_775991 != nil:
    section.add "X-Amz-SignedHeaders", valid_775991
  var valid_775992 = header.getOrDefault("X-Amz-Credential")
  valid_775992 = validateParameter(valid_775992, JString, required = false,
                                 default = nil)
  if valid_775992 != nil:
    section.add "X-Amz-Credential", valid_775992
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_775993: Call_GetPurchaseReservedNodeOffering_775979;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Allows you to purchase reserved nodes. Amazon Redshift offers a predefined set of reserved node offerings. You can purchase one or more of the offerings. You can call the <a>DescribeReservedNodeOfferings</a> API to obtain the available reserved node offerings. You can call this API by providing a specific reserved node offering and the number of nodes you want to reserve. </p> <p> For more information about reserved node offerings, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_775993.validator(path, query, header, formData, body)
  let scheme = call_775993.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_775993.url(scheme.get, call_775993.host, call_775993.base,
                         call_775993.route, valid.getOrDefault("path"))
  result = hook(call_775993, url, valid)

proc call*(call_775994: Call_GetPurchaseReservedNodeOffering_775979;
          ReservedNodeOfferingId: string;
          Action: string = "PurchaseReservedNodeOffering"; NodeCount: int = 0;
          Version: string = "2012-12-01"): Recallable =
  ## getPurchaseReservedNodeOffering
  ## <p>Allows you to purchase reserved nodes. Amazon Redshift offers a predefined set of reserved node offerings. You can purchase one or more of the offerings. You can call the <a>DescribeReservedNodeOfferings</a> API to obtain the available reserved node offerings. You can call this API by providing a specific reserved node offering and the number of nodes you want to reserve. </p> <p> For more information about reserved node offerings, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   ReservedNodeOfferingId: string (required)
  ##                         : The unique identifier of the reserved node offering you want to purchase.
  ##   Action: string (required)
  ##   NodeCount: int
  ##            : <p>The number of reserved nodes that you want to purchase.</p> <p>Default: <code>1</code> </p>
  ##   Version: string (required)
  var query_775995 = newJObject()
  add(query_775995, "ReservedNodeOfferingId", newJString(ReservedNodeOfferingId))
  add(query_775995, "Action", newJString(Action))
  add(query_775995, "NodeCount", newJInt(NodeCount))
  add(query_775995, "Version", newJString(Version))
  result = call_775994.call(nil, query_775995, nil, nil, nil)

var getPurchaseReservedNodeOffering* = Call_GetPurchaseReservedNodeOffering_775979(
    name: "getPurchaseReservedNodeOffering", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=PurchaseReservedNodeOffering",
    validator: validate_GetPurchaseReservedNodeOffering_775980, base: "/",
    url: url_GetPurchaseReservedNodeOffering_775981,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostRebootCluster_776030 = ref object of OpenApiRestCall_772581
proc url_PostRebootCluster_776032(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_PostRebootCluster_776031(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## Reboots a cluster. This action is taken as soon as possible. It results in a momentary outage to the cluster, during which the cluster status is set to <code>rebooting</code>. A cluster event is created when the reboot is completed. Any pending cluster modifications (see <a>ModifyCluster</a>) are applied at this reboot. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_776033 = query.getOrDefault("Action")
  valid_776033 = validateParameter(valid_776033, JString, required = true,
                                 default = newJString("RebootCluster"))
  if valid_776033 != nil:
    section.add "Action", valid_776033
  var valid_776034 = query.getOrDefault("Version")
  valid_776034 = validateParameter(valid_776034, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_776034 != nil:
    section.add "Version", valid_776034
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_776035 = header.getOrDefault("X-Amz-Date")
  valid_776035 = validateParameter(valid_776035, JString, required = false,
                                 default = nil)
  if valid_776035 != nil:
    section.add "X-Amz-Date", valid_776035
  var valid_776036 = header.getOrDefault("X-Amz-Security-Token")
  valid_776036 = validateParameter(valid_776036, JString, required = false,
                                 default = nil)
  if valid_776036 != nil:
    section.add "X-Amz-Security-Token", valid_776036
  var valid_776037 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_776037 = validateParameter(valid_776037, JString, required = false,
                                 default = nil)
  if valid_776037 != nil:
    section.add "X-Amz-Content-Sha256", valid_776037
  var valid_776038 = header.getOrDefault("X-Amz-Algorithm")
  valid_776038 = validateParameter(valid_776038, JString, required = false,
                                 default = nil)
  if valid_776038 != nil:
    section.add "X-Amz-Algorithm", valid_776038
  var valid_776039 = header.getOrDefault("X-Amz-Signature")
  valid_776039 = validateParameter(valid_776039, JString, required = false,
                                 default = nil)
  if valid_776039 != nil:
    section.add "X-Amz-Signature", valid_776039
  var valid_776040 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_776040 = validateParameter(valid_776040, JString, required = false,
                                 default = nil)
  if valid_776040 != nil:
    section.add "X-Amz-SignedHeaders", valid_776040
  var valid_776041 = header.getOrDefault("X-Amz-Credential")
  valid_776041 = validateParameter(valid_776041, JString, required = false,
                                 default = nil)
  if valid_776041 != nil:
    section.add "X-Amz-Credential", valid_776041
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : The cluster identifier.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_776042 = formData.getOrDefault("ClusterIdentifier")
  valid_776042 = validateParameter(valid_776042, JString, required = true,
                                 default = nil)
  if valid_776042 != nil:
    section.add "ClusterIdentifier", valid_776042
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_776043: Call_PostRebootCluster_776030; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Reboots a cluster. This action is taken as soon as possible. It results in a momentary outage to the cluster, during which the cluster status is set to <code>rebooting</code>. A cluster event is created when the reboot is completed. Any pending cluster modifications (see <a>ModifyCluster</a>) are applied at this reboot. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. 
  ## 
  let valid = call_776043.validator(path, query, header, formData, body)
  let scheme = call_776043.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_776043.url(scheme.get, call_776043.host, call_776043.base,
                         call_776043.route, valid.getOrDefault("path"))
  result = hook(call_776043, url, valid)

proc call*(call_776044: Call_PostRebootCluster_776030; ClusterIdentifier: string;
          Action: string = "RebootCluster"; Version: string = "2012-12-01"): Recallable =
  ## postRebootCluster
  ## Reboots a cluster. This action is taken as soon as possible. It results in a momentary outage to the cluster, during which the cluster status is set to <code>rebooting</code>. A cluster event is created when the reboot is completed. Any pending cluster modifications (see <a>ModifyCluster</a>) are applied at this reboot. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. 
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : The cluster identifier.
  ##   Version: string (required)
  var query_776045 = newJObject()
  var formData_776046 = newJObject()
  add(query_776045, "Action", newJString(Action))
  add(formData_776046, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_776045, "Version", newJString(Version))
  result = call_776044.call(nil, query_776045, nil, formData_776046, nil)

var postRebootCluster* = Call_PostRebootCluster_776030(name: "postRebootCluster",
    meth: HttpMethod.HttpPost, host: "redshift.amazonaws.com",
    route: "/#Action=RebootCluster", validator: validate_PostRebootCluster_776031,
    base: "/", url: url_PostRebootCluster_776032,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetRebootCluster_776014 = ref object of OpenApiRestCall_772581
proc url_GetRebootCluster_776016(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_GetRebootCluster_776015(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Reboots a cluster. This action is taken as soon as possible. It results in a momentary outage to the cluster, during which the cluster status is set to <code>rebooting</code>. A cluster event is created when the reboot is completed. Any pending cluster modifications (see <a>ModifyCluster</a>) are applied at this reboot. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : The cluster identifier.
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_776017 = query.getOrDefault("Action")
  valid_776017 = validateParameter(valid_776017, JString, required = true,
                                 default = newJString("RebootCluster"))
  if valid_776017 != nil:
    section.add "Action", valid_776017
  var valid_776018 = query.getOrDefault("ClusterIdentifier")
  valid_776018 = validateParameter(valid_776018, JString, required = true,
                                 default = nil)
  if valid_776018 != nil:
    section.add "ClusterIdentifier", valid_776018
  var valid_776019 = query.getOrDefault("Version")
  valid_776019 = validateParameter(valid_776019, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_776019 != nil:
    section.add "Version", valid_776019
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_776020 = header.getOrDefault("X-Amz-Date")
  valid_776020 = validateParameter(valid_776020, JString, required = false,
                                 default = nil)
  if valid_776020 != nil:
    section.add "X-Amz-Date", valid_776020
  var valid_776021 = header.getOrDefault("X-Amz-Security-Token")
  valid_776021 = validateParameter(valid_776021, JString, required = false,
                                 default = nil)
  if valid_776021 != nil:
    section.add "X-Amz-Security-Token", valid_776021
  var valid_776022 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_776022 = validateParameter(valid_776022, JString, required = false,
                                 default = nil)
  if valid_776022 != nil:
    section.add "X-Amz-Content-Sha256", valid_776022
  var valid_776023 = header.getOrDefault("X-Amz-Algorithm")
  valid_776023 = validateParameter(valid_776023, JString, required = false,
                                 default = nil)
  if valid_776023 != nil:
    section.add "X-Amz-Algorithm", valid_776023
  var valid_776024 = header.getOrDefault("X-Amz-Signature")
  valid_776024 = validateParameter(valid_776024, JString, required = false,
                                 default = nil)
  if valid_776024 != nil:
    section.add "X-Amz-Signature", valid_776024
  var valid_776025 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_776025 = validateParameter(valid_776025, JString, required = false,
                                 default = nil)
  if valid_776025 != nil:
    section.add "X-Amz-SignedHeaders", valid_776025
  var valid_776026 = header.getOrDefault("X-Amz-Credential")
  valid_776026 = validateParameter(valid_776026, JString, required = false,
                                 default = nil)
  if valid_776026 != nil:
    section.add "X-Amz-Credential", valid_776026
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_776027: Call_GetRebootCluster_776014; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Reboots a cluster. This action is taken as soon as possible. It results in a momentary outage to the cluster, during which the cluster status is set to <code>rebooting</code>. A cluster event is created when the reboot is completed. Any pending cluster modifications (see <a>ModifyCluster</a>) are applied at this reboot. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. 
  ## 
  let valid = call_776027.validator(path, query, header, formData, body)
  let scheme = call_776027.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_776027.url(scheme.get, call_776027.host, call_776027.base,
                         call_776027.route, valid.getOrDefault("path"))
  result = hook(call_776027, url, valid)

proc call*(call_776028: Call_GetRebootCluster_776014; ClusterIdentifier: string;
          Action: string = "RebootCluster"; Version: string = "2012-12-01"): Recallable =
  ## getRebootCluster
  ## Reboots a cluster. This action is taken as soon as possible. It results in a momentary outage to the cluster, during which the cluster status is set to <code>rebooting</code>. A cluster event is created when the reboot is completed. Any pending cluster modifications (see <a>ModifyCluster</a>) are applied at this reboot. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. 
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : The cluster identifier.
  ##   Version: string (required)
  var query_776029 = newJObject()
  add(query_776029, "Action", newJString(Action))
  add(query_776029, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_776029, "Version", newJString(Version))
  result = call_776028.call(nil, query_776029, nil, nil, nil)

var getRebootCluster* = Call_GetRebootCluster_776014(name: "getRebootCluster",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=RebootCluster", validator: validate_GetRebootCluster_776015,
    base: "/", url: url_GetRebootCluster_776016,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostResetClusterParameterGroup_776065 = ref object of OpenApiRestCall_772581
proc url_PostResetClusterParameterGroup_776067(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_PostResetClusterParameterGroup_776066(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Sets one or more parameters of the specified parameter group to their default values and sets the source values of the parameters to "engine-default". To reset the entire parameter group specify the <i>ResetAllParameters</i> parameter. For parameter changes to take effect you must reboot any associated clusters. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_776068 = query.getOrDefault("Action")
  valid_776068 = validateParameter(valid_776068, JString, required = true, default = newJString(
      "ResetClusterParameterGroup"))
  if valid_776068 != nil:
    section.add "Action", valid_776068
  var valid_776069 = query.getOrDefault("Version")
  valid_776069 = validateParameter(valid_776069, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_776069 != nil:
    section.add "Version", valid_776069
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_776070 = header.getOrDefault("X-Amz-Date")
  valid_776070 = validateParameter(valid_776070, JString, required = false,
                                 default = nil)
  if valid_776070 != nil:
    section.add "X-Amz-Date", valid_776070
  var valid_776071 = header.getOrDefault("X-Amz-Security-Token")
  valid_776071 = validateParameter(valid_776071, JString, required = false,
                                 default = nil)
  if valid_776071 != nil:
    section.add "X-Amz-Security-Token", valid_776071
  var valid_776072 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_776072 = validateParameter(valid_776072, JString, required = false,
                                 default = nil)
  if valid_776072 != nil:
    section.add "X-Amz-Content-Sha256", valid_776072
  var valid_776073 = header.getOrDefault("X-Amz-Algorithm")
  valid_776073 = validateParameter(valid_776073, JString, required = false,
                                 default = nil)
  if valid_776073 != nil:
    section.add "X-Amz-Algorithm", valid_776073
  var valid_776074 = header.getOrDefault("X-Amz-Signature")
  valid_776074 = validateParameter(valid_776074, JString, required = false,
                                 default = nil)
  if valid_776074 != nil:
    section.add "X-Amz-Signature", valid_776074
  var valid_776075 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_776075 = validateParameter(valid_776075, JString, required = false,
                                 default = nil)
  if valid_776075 != nil:
    section.add "X-Amz-SignedHeaders", valid_776075
  var valid_776076 = header.getOrDefault("X-Amz-Credential")
  valid_776076 = validateParameter(valid_776076, JString, required = false,
                                 default = nil)
  if valid_776076 != nil:
    section.add "X-Amz-Credential", valid_776076
  result.add "header", section
  ## parameters in `formData` object:
  ##   ParameterGroupName: JString (required)
  ##                     : The name of the cluster parameter group to be reset.
  ##   Parameters: JArray
  ##             : <p>An array of names of parameters to be reset. If <i>ResetAllParameters</i> option is not used, then at least one parameter name must be supplied. </p> <p>Constraints: A maximum of 20 parameters can be reset in a single request.</p>
  ##   ResetAllParameters: JBool
  ##                     : <p>If <code>true</code>, all parameters in the specified parameter group will be reset to their default values. </p> <p>Default: <code>true</code> </p>
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ParameterGroupName` field"
  var valid_776077 = formData.getOrDefault("ParameterGroupName")
  valid_776077 = validateParameter(valid_776077, JString, required = true,
                                 default = nil)
  if valid_776077 != nil:
    section.add "ParameterGroupName", valid_776077
  var valid_776078 = formData.getOrDefault("Parameters")
  valid_776078 = validateParameter(valid_776078, JArray, required = false,
                                 default = nil)
  if valid_776078 != nil:
    section.add "Parameters", valid_776078
  var valid_776079 = formData.getOrDefault("ResetAllParameters")
  valid_776079 = validateParameter(valid_776079, JBool, required = false, default = nil)
  if valid_776079 != nil:
    section.add "ResetAllParameters", valid_776079
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_776080: Call_PostResetClusterParameterGroup_776065; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Sets one or more parameters of the specified parameter group to their default values and sets the source values of the parameters to "engine-default". To reset the entire parameter group specify the <i>ResetAllParameters</i> parameter. For parameter changes to take effect you must reboot any associated clusters. 
  ## 
  let valid = call_776080.validator(path, query, header, formData, body)
  let scheme = call_776080.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_776080.url(scheme.get, call_776080.host, call_776080.base,
                         call_776080.route, valid.getOrDefault("path"))
  result = hook(call_776080, url, valid)

proc call*(call_776081: Call_PostResetClusterParameterGroup_776065;
          ParameterGroupName: string; Parameters: JsonNode = nil;
          Action: string = "ResetClusterParameterGroup";
          ResetAllParameters: bool = false; Version: string = "2012-12-01"): Recallable =
  ## postResetClusterParameterGroup
  ## Sets one or more parameters of the specified parameter group to their default values and sets the source values of the parameters to "engine-default". To reset the entire parameter group specify the <i>ResetAllParameters</i> parameter. For parameter changes to take effect you must reboot any associated clusters. 
  ##   ParameterGroupName: string (required)
  ##                     : The name of the cluster parameter group to be reset.
  ##   Parameters: JArray
  ##             : <p>An array of names of parameters to be reset. If <i>ResetAllParameters</i> option is not used, then at least one parameter name must be supplied. </p> <p>Constraints: A maximum of 20 parameters can be reset in a single request.</p>
  ##   Action: string (required)
  ##   ResetAllParameters: bool
  ##                     : <p>If <code>true</code>, all parameters in the specified parameter group will be reset to their default values. </p> <p>Default: <code>true</code> </p>
  ##   Version: string (required)
  var query_776082 = newJObject()
  var formData_776083 = newJObject()
  add(formData_776083, "ParameterGroupName", newJString(ParameterGroupName))
  if Parameters != nil:
    formData_776083.add "Parameters", Parameters
  add(query_776082, "Action", newJString(Action))
  add(formData_776083, "ResetAllParameters", newJBool(ResetAllParameters))
  add(query_776082, "Version", newJString(Version))
  result = call_776081.call(nil, query_776082, nil, formData_776083, nil)

var postResetClusterParameterGroup* = Call_PostResetClusterParameterGroup_776065(
    name: "postResetClusterParameterGroup", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=ResetClusterParameterGroup",
    validator: validate_PostResetClusterParameterGroup_776066, base: "/",
    url: url_PostResetClusterParameterGroup_776067,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetResetClusterParameterGroup_776047 = ref object of OpenApiRestCall_772581
proc url_GetResetClusterParameterGroup_776049(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_GetResetClusterParameterGroup_776048(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Sets one or more parameters of the specified parameter group to their default values and sets the source values of the parameters to "engine-default". To reset the entire parameter group specify the <i>ResetAllParameters</i> parameter. For parameter changes to take effect you must reboot any associated clusters. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ParameterGroupName: JString (required)
  ##                     : The name of the cluster parameter group to be reset.
  ##   Parameters: JArray
  ##             : <p>An array of names of parameters to be reset. If <i>ResetAllParameters</i> option is not used, then at least one parameter name must be supplied. </p> <p>Constraints: A maximum of 20 parameters can be reset in a single request.</p>
  ##   Action: JString (required)
  ##   ResetAllParameters: JBool
  ##                     : <p>If <code>true</code>, all parameters in the specified parameter group will be reset to their default values. </p> <p>Default: <code>true</code> </p>
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `ParameterGroupName` field"
  var valid_776050 = query.getOrDefault("ParameterGroupName")
  valid_776050 = validateParameter(valid_776050, JString, required = true,
                                 default = nil)
  if valid_776050 != nil:
    section.add "ParameterGroupName", valid_776050
  var valid_776051 = query.getOrDefault("Parameters")
  valid_776051 = validateParameter(valid_776051, JArray, required = false,
                                 default = nil)
  if valid_776051 != nil:
    section.add "Parameters", valid_776051
  var valid_776052 = query.getOrDefault("Action")
  valid_776052 = validateParameter(valid_776052, JString, required = true, default = newJString(
      "ResetClusterParameterGroup"))
  if valid_776052 != nil:
    section.add "Action", valid_776052
  var valid_776053 = query.getOrDefault("ResetAllParameters")
  valid_776053 = validateParameter(valid_776053, JBool, required = false, default = nil)
  if valid_776053 != nil:
    section.add "ResetAllParameters", valid_776053
  var valid_776054 = query.getOrDefault("Version")
  valid_776054 = validateParameter(valid_776054, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_776054 != nil:
    section.add "Version", valid_776054
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_776055 = header.getOrDefault("X-Amz-Date")
  valid_776055 = validateParameter(valid_776055, JString, required = false,
                                 default = nil)
  if valid_776055 != nil:
    section.add "X-Amz-Date", valid_776055
  var valid_776056 = header.getOrDefault("X-Amz-Security-Token")
  valid_776056 = validateParameter(valid_776056, JString, required = false,
                                 default = nil)
  if valid_776056 != nil:
    section.add "X-Amz-Security-Token", valid_776056
  var valid_776057 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_776057 = validateParameter(valid_776057, JString, required = false,
                                 default = nil)
  if valid_776057 != nil:
    section.add "X-Amz-Content-Sha256", valid_776057
  var valid_776058 = header.getOrDefault("X-Amz-Algorithm")
  valid_776058 = validateParameter(valid_776058, JString, required = false,
                                 default = nil)
  if valid_776058 != nil:
    section.add "X-Amz-Algorithm", valid_776058
  var valid_776059 = header.getOrDefault("X-Amz-Signature")
  valid_776059 = validateParameter(valid_776059, JString, required = false,
                                 default = nil)
  if valid_776059 != nil:
    section.add "X-Amz-Signature", valid_776059
  var valid_776060 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_776060 = validateParameter(valid_776060, JString, required = false,
                                 default = nil)
  if valid_776060 != nil:
    section.add "X-Amz-SignedHeaders", valid_776060
  var valid_776061 = header.getOrDefault("X-Amz-Credential")
  valid_776061 = validateParameter(valid_776061, JString, required = false,
                                 default = nil)
  if valid_776061 != nil:
    section.add "X-Amz-Credential", valid_776061
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_776062: Call_GetResetClusterParameterGroup_776047; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Sets one or more parameters of the specified parameter group to their default values and sets the source values of the parameters to "engine-default". To reset the entire parameter group specify the <i>ResetAllParameters</i> parameter. For parameter changes to take effect you must reboot any associated clusters. 
  ## 
  let valid = call_776062.validator(path, query, header, formData, body)
  let scheme = call_776062.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_776062.url(scheme.get, call_776062.host, call_776062.base,
                         call_776062.route, valid.getOrDefault("path"))
  result = hook(call_776062, url, valid)

proc call*(call_776063: Call_GetResetClusterParameterGroup_776047;
          ParameterGroupName: string; Parameters: JsonNode = nil;
          Action: string = "ResetClusterParameterGroup";
          ResetAllParameters: bool = false; Version: string = "2012-12-01"): Recallable =
  ## getResetClusterParameterGroup
  ## Sets one or more parameters of the specified parameter group to their default values and sets the source values of the parameters to "engine-default". To reset the entire parameter group specify the <i>ResetAllParameters</i> parameter. For parameter changes to take effect you must reboot any associated clusters. 
  ##   ParameterGroupName: string (required)
  ##                     : The name of the cluster parameter group to be reset.
  ##   Parameters: JArray
  ##             : <p>An array of names of parameters to be reset. If <i>ResetAllParameters</i> option is not used, then at least one parameter name must be supplied. </p> <p>Constraints: A maximum of 20 parameters can be reset in a single request.</p>
  ##   Action: string (required)
  ##   ResetAllParameters: bool
  ##                     : <p>If <code>true</code>, all parameters in the specified parameter group will be reset to their default values. </p> <p>Default: <code>true</code> </p>
  ##   Version: string (required)
  var query_776064 = newJObject()
  add(query_776064, "ParameterGroupName", newJString(ParameterGroupName))
  if Parameters != nil:
    query_776064.add "Parameters", Parameters
  add(query_776064, "Action", newJString(Action))
  add(query_776064, "ResetAllParameters", newJBool(ResetAllParameters))
  add(query_776064, "Version", newJString(Version))
  result = call_776063.call(nil, query_776064, nil, nil, nil)

var getResetClusterParameterGroup* = Call_GetResetClusterParameterGroup_776047(
    name: "getResetClusterParameterGroup", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=ResetClusterParameterGroup",
    validator: validate_GetResetClusterParameterGroup_776048, base: "/",
    url: url_GetResetClusterParameterGroup_776049,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostResizeCluster_776104 = ref object of OpenApiRestCall_772581
proc url_PostResizeCluster_776106(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_PostResizeCluster_776105(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## <p>Changes the size of the cluster. You can change the cluster's type, or change the number or type of nodes. The default behavior is to use the elastic resize method. With an elastic resize, your cluster is available for read and write operations more quickly than with the classic resize method. </p> <p>Elastic resize operations have the following restrictions:</p> <ul> <li> <p>You can only resize clusters of the following types:</p> <ul> <li> <p>dc2.large</p> </li> <li> <p>dc2.8xlarge</p> </li> <li> <p>ds2.xlarge</p> </li> <li> <p>ds2.8xlarge</p> </li> </ul> </li> <li> <p>The type of nodes that you add must match the node type for the cluster.</p> </li> </ul>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_776107 = query.getOrDefault("Action")
  valid_776107 = validateParameter(valid_776107, JString, required = true,
                                 default = newJString("ResizeCluster"))
  if valid_776107 != nil:
    section.add "Action", valid_776107
  var valid_776108 = query.getOrDefault("Version")
  valid_776108 = validateParameter(valid_776108, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_776108 != nil:
    section.add "Version", valid_776108
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_776109 = header.getOrDefault("X-Amz-Date")
  valid_776109 = validateParameter(valid_776109, JString, required = false,
                                 default = nil)
  if valid_776109 != nil:
    section.add "X-Amz-Date", valid_776109
  var valid_776110 = header.getOrDefault("X-Amz-Security-Token")
  valid_776110 = validateParameter(valid_776110, JString, required = false,
                                 default = nil)
  if valid_776110 != nil:
    section.add "X-Amz-Security-Token", valid_776110
  var valid_776111 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_776111 = validateParameter(valid_776111, JString, required = false,
                                 default = nil)
  if valid_776111 != nil:
    section.add "X-Amz-Content-Sha256", valid_776111
  var valid_776112 = header.getOrDefault("X-Amz-Algorithm")
  valid_776112 = validateParameter(valid_776112, JString, required = false,
                                 default = nil)
  if valid_776112 != nil:
    section.add "X-Amz-Algorithm", valid_776112
  var valid_776113 = header.getOrDefault("X-Amz-Signature")
  valid_776113 = validateParameter(valid_776113, JString, required = false,
                                 default = nil)
  if valid_776113 != nil:
    section.add "X-Amz-Signature", valid_776113
  var valid_776114 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_776114 = validateParameter(valid_776114, JString, required = false,
                                 default = nil)
  if valid_776114 != nil:
    section.add "X-Amz-SignedHeaders", valid_776114
  var valid_776115 = header.getOrDefault("X-Amz-Credential")
  valid_776115 = validateParameter(valid_776115, JString, required = false,
                                 default = nil)
  if valid_776115 != nil:
    section.add "X-Amz-Credential", valid_776115
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterType: JString
  ##              : The new cluster type for the specified cluster.
  ##   ClusterIdentifier: JString (required)
  ##                    : The unique identifier for the cluster to resize.
  ##   NumberOfNodes: JInt (required)
  ##                : The new number of nodes for the cluster.
  ##   Classic: JBool
  ##          : A boolean value indicating whether the resize operation is using the classic resize process. If you don't provide this parameter or set the value to <code>false</code>, the resize type is elastic. 
  ##   NodeType: JString
  ##           : The new node type for the nodes you are adding. If not specified, the cluster's current node type is used.
  section = newJObject()
  var valid_776116 = formData.getOrDefault("ClusterType")
  valid_776116 = validateParameter(valid_776116, JString, required = false,
                                 default = nil)
  if valid_776116 != nil:
    section.add "ClusterType", valid_776116
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_776117 = formData.getOrDefault("ClusterIdentifier")
  valid_776117 = validateParameter(valid_776117, JString, required = true,
                                 default = nil)
  if valid_776117 != nil:
    section.add "ClusterIdentifier", valid_776117
  var valid_776118 = formData.getOrDefault("NumberOfNodes")
  valid_776118 = validateParameter(valid_776118, JInt, required = true, default = nil)
  if valid_776118 != nil:
    section.add "NumberOfNodes", valid_776118
  var valid_776119 = formData.getOrDefault("Classic")
  valid_776119 = validateParameter(valid_776119, JBool, required = false, default = nil)
  if valid_776119 != nil:
    section.add "Classic", valid_776119
  var valid_776120 = formData.getOrDefault("NodeType")
  valid_776120 = validateParameter(valid_776120, JString, required = false,
                                 default = nil)
  if valid_776120 != nil:
    section.add "NodeType", valid_776120
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_776121: Call_PostResizeCluster_776104; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Changes the size of the cluster. You can change the cluster's type, or change the number or type of nodes. The default behavior is to use the elastic resize method. With an elastic resize, your cluster is available for read and write operations more quickly than with the classic resize method. </p> <p>Elastic resize operations have the following restrictions:</p> <ul> <li> <p>You can only resize clusters of the following types:</p> <ul> <li> <p>dc2.large</p> </li> <li> <p>dc2.8xlarge</p> </li> <li> <p>ds2.xlarge</p> </li> <li> <p>ds2.8xlarge</p> </li> </ul> </li> <li> <p>The type of nodes that you add must match the node type for the cluster.</p> </li> </ul>
  ## 
  let valid = call_776121.validator(path, query, header, formData, body)
  let scheme = call_776121.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_776121.url(scheme.get, call_776121.host, call_776121.base,
                         call_776121.route, valid.getOrDefault("path"))
  result = hook(call_776121, url, valid)

proc call*(call_776122: Call_PostResizeCluster_776104; ClusterIdentifier: string;
          NumberOfNodes: int; ClusterType: string = "";
          Action: string = "ResizeCluster"; Classic: bool = false;
          Version: string = "2012-12-01"; NodeType: string = ""): Recallable =
  ## postResizeCluster
  ## <p>Changes the size of the cluster. You can change the cluster's type, or change the number or type of nodes. The default behavior is to use the elastic resize method. With an elastic resize, your cluster is available for read and write operations more quickly than with the classic resize method. </p> <p>Elastic resize operations have the following restrictions:</p> <ul> <li> <p>You can only resize clusters of the following types:</p> <ul> <li> <p>dc2.large</p> </li> <li> <p>dc2.8xlarge</p> </li> <li> <p>ds2.xlarge</p> </li> <li> <p>ds2.8xlarge</p> </li> </ul> </li> <li> <p>The type of nodes that you add must match the node type for the cluster.</p> </li> </ul>
  ##   ClusterType: string
  ##              : The new cluster type for the specified cluster.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : The unique identifier for the cluster to resize.
  ##   NumberOfNodes: int (required)
  ##                : The new number of nodes for the cluster.
  ##   Classic: bool
  ##          : A boolean value indicating whether the resize operation is using the classic resize process. If you don't provide this parameter or set the value to <code>false</code>, the resize type is elastic. 
  ##   Version: string (required)
  ##   NodeType: string
  ##           : The new node type for the nodes you are adding. If not specified, the cluster's current node type is used.
  var query_776123 = newJObject()
  var formData_776124 = newJObject()
  add(formData_776124, "ClusterType", newJString(ClusterType))
  add(query_776123, "Action", newJString(Action))
  add(formData_776124, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_776124, "NumberOfNodes", newJInt(NumberOfNodes))
  add(formData_776124, "Classic", newJBool(Classic))
  add(query_776123, "Version", newJString(Version))
  add(formData_776124, "NodeType", newJString(NodeType))
  result = call_776122.call(nil, query_776123, nil, formData_776124, nil)

var postResizeCluster* = Call_PostResizeCluster_776104(name: "postResizeCluster",
    meth: HttpMethod.HttpPost, host: "redshift.amazonaws.com",
    route: "/#Action=ResizeCluster", validator: validate_PostResizeCluster_776105,
    base: "/", url: url_PostResizeCluster_776106,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetResizeCluster_776084 = ref object of OpenApiRestCall_772581
proc url_GetResizeCluster_776086(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_GetResizeCluster_776085(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## <p>Changes the size of the cluster. You can change the cluster's type, or change the number or type of nodes. The default behavior is to use the elastic resize method. With an elastic resize, your cluster is available for read and write operations more quickly than with the classic resize method. </p> <p>Elastic resize operations have the following restrictions:</p> <ul> <li> <p>You can only resize clusters of the following types:</p> <ul> <li> <p>dc2.large</p> </li> <li> <p>dc2.8xlarge</p> </li> <li> <p>ds2.xlarge</p> </li> <li> <p>ds2.8xlarge</p> </li> </ul> </li> <li> <p>The type of nodes that you add must match the node type for the cluster.</p> </li> </ul>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : The unique identifier for the cluster to resize.
  ##   Classic: JBool
  ##          : A boolean value indicating whether the resize operation is using the classic resize process. If you don't provide this parameter or set the value to <code>false</code>, the resize type is elastic. 
  ##   NumberOfNodes: JInt (required)
  ##                : The new number of nodes for the cluster.
  ##   NodeType: JString
  ##           : The new node type for the nodes you are adding. If not specified, the cluster's current node type is used.
  ##   Version: JString (required)
  ##   ClusterType: JString
  ##              : The new cluster type for the specified cluster.
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_776087 = query.getOrDefault("Action")
  valid_776087 = validateParameter(valid_776087, JString, required = true,
                                 default = newJString("ResizeCluster"))
  if valid_776087 != nil:
    section.add "Action", valid_776087
  var valid_776088 = query.getOrDefault("ClusterIdentifier")
  valid_776088 = validateParameter(valid_776088, JString, required = true,
                                 default = nil)
  if valid_776088 != nil:
    section.add "ClusterIdentifier", valid_776088
  var valid_776089 = query.getOrDefault("Classic")
  valid_776089 = validateParameter(valid_776089, JBool, required = false, default = nil)
  if valid_776089 != nil:
    section.add "Classic", valid_776089
  var valid_776090 = query.getOrDefault("NumberOfNodes")
  valid_776090 = validateParameter(valid_776090, JInt, required = true, default = nil)
  if valid_776090 != nil:
    section.add "NumberOfNodes", valid_776090
  var valid_776091 = query.getOrDefault("NodeType")
  valid_776091 = validateParameter(valid_776091, JString, required = false,
                                 default = nil)
  if valid_776091 != nil:
    section.add "NodeType", valid_776091
  var valid_776092 = query.getOrDefault("Version")
  valid_776092 = validateParameter(valid_776092, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_776092 != nil:
    section.add "Version", valid_776092
  var valid_776093 = query.getOrDefault("ClusterType")
  valid_776093 = validateParameter(valid_776093, JString, required = false,
                                 default = nil)
  if valid_776093 != nil:
    section.add "ClusterType", valid_776093
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_776094 = header.getOrDefault("X-Amz-Date")
  valid_776094 = validateParameter(valid_776094, JString, required = false,
                                 default = nil)
  if valid_776094 != nil:
    section.add "X-Amz-Date", valid_776094
  var valid_776095 = header.getOrDefault("X-Amz-Security-Token")
  valid_776095 = validateParameter(valid_776095, JString, required = false,
                                 default = nil)
  if valid_776095 != nil:
    section.add "X-Amz-Security-Token", valid_776095
  var valid_776096 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_776096 = validateParameter(valid_776096, JString, required = false,
                                 default = nil)
  if valid_776096 != nil:
    section.add "X-Amz-Content-Sha256", valid_776096
  var valid_776097 = header.getOrDefault("X-Amz-Algorithm")
  valid_776097 = validateParameter(valid_776097, JString, required = false,
                                 default = nil)
  if valid_776097 != nil:
    section.add "X-Amz-Algorithm", valid_776097
  var valid_776098 = header.getOrDefault("X-Amz-Signature")
  valid_776098 = validateParameter(valid_776098, JString, required = false,
                                 default = nil)
  if valid_776098 != nil:
    section.add "X-Amz-Signature", valid_776098
  var valid_776099 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_776099 = validateParameter(valid_776099, JString, required = false,
                                 default = nil)
  if valid_776099 != nil:
    section.add "X-Amz-SignedHeaders", valid_776099
  var valid_776100 = header.getOrDefault("X-Amz-Credential")
  valid_776100 = validateParameter(valid_776100, JString, required = false,
                                 default = nil)
  if valid_776100 != nil:
    section.add "X-Amz-Credential", valid_776100
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_776101: Call_GetResizeCluster_776084; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Changes the size of the cluster. You can change the cluster's type, or change the number or type of nodes. The default behavior is to use the elastic resize method. With an elastic resize, your cluster is available for read and write operations more quickly than with the classic resize method. </p> <p>Elastic resize operations have the following restrictions:</p> <ul> <li> <p>You can only resize clusters of the following types:</p> <ul> <li> <p>dc2.large</p> </li> <li> <p>dc2.8xlarge</p> </li> <li> <p>ds2.xlarge</p> </li> <li> <p>ds2.8xlarge</p> </li> </ul> </li> <li> <p>The type of nodes that you add must match the node type for the cluster.</p> </li> </ul>
  ## 
  let valid = call_776101.validator(path, query, header, formData, body)
  let scheme = call_776101.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_776101.url(scheme.get, call_776101.host, call_776101.base,
                         call_776101.route, valid.getOrDefault("path"))
  result = hook(call_776101, url, valid)

proc call*(call_776102: Call_GetResizeCluster_776084; ClusterIdentifier: string;
          NumberOfNodes: int; Action: string = "ResizeCluster"; Classic: bool = false;
          NodeType: string = ""; Version: string = "2012-12-01";
          ClusterType: string = ""): Recallable =
  ## getResizeCluster
  ## <p>Changes the size of the cluster. You can change the cluster's type, or change the number or type of nodes. The default behavior is to use the elastic resize method. With an elastic resize, your cluster is available for read and write operations more quickly than with the classic resize method. </p> <p>Elastic resize operations have the following restrictions:</p> <ul> <li> <p>You can only resize clusters of the following types:</p> <ul> <li> <p>dc2.large</p> </li> <li> <p>dc2.8xlarge</p> </li> <li> <p>ds2.xlarge</p> </li> <li> <p>ds2.8xlarge</p> </li> </ul> </li> <li> <p>The type of nodes that you add must match the node type for the cluster.</p> </li> </ul>
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : The unique identifier for the cluster to resize.
  ##   Classic: bool
  ##          : A boolean value indicating whether the resize operation is using the classic resize process. If you don't provide this parameter or set the value to <code>false</code>, the resize type is elastic. 
  ##   NumberOfNodes: int (required)
  ##                : The new number of nodes for the cluster.
  ##   NodeType: string
  ##           : The new node type for the nodes you are adding. If not specified, the cluster's current node type is used.
  ##   Version: string (required)
  ##   ClusterType: string
  ##              : The new cluster type for the specified cluster.
  var query_776103 = newJObject()
  add(query_776103, "Action", newJString(Action))
  add(query_776103, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_776103, "Classic", newJBool(Classic))
  add(query_776103, "NumberOfNodes", newJInt(NumberOfNodes))
  add(query_776103, "NodeType", newJString(NodeType))
  add(query_776103, "Version", newJString(Version))
  add(query_776103, "ClusterType", newJString(ClusterType))
  result = call_776102.call(nil, query_776103, nil, nil, nil)

var getResizeCluster* = Call_GetResizeCluster_776084(name: "getResizeCluster",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=ResizeCluster", validator: validate_GetResizeCluster_776085,
    base: "/", url: url_GetResizeCluster_776086,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostRestoreFromClusterSnapshot_776165 = ref object of OpenApiRestCall_772581
proc url_PostRestoreFromClusterSnapshot_776167(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_PostRestoreFromClusterSnapshot_776166(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a new cluster from a snapshot. By default, Amazon Redshift creates the resulting cluster with the same configuration as the original cluster from which the snapshot was created, except that the new cluster is created with the default cluster security and parameter groups. After Amazon Redshift creates the cluster, you can use the <a>ModifyCluster</a> API to associate a different security group and different parameter group with the restored cluster. If you are using a DS node type, you can also choose to change to another DS node type of the same size during restore.</p> <p>If you restore a cluster into a VPC, you must provide a cluster subnet group where you want the cluster restored.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_776168 = query.getOrDefault("Action")
  valid_776168 = validateParameter(valid_776168, JString, required = true, default = newJString(
      "RestoreFromClusterSnapshot"))
  if valid_776168 != nil:
    section.add "Action", valid_776168
  var valid_776169 = query.getOrDefault("Version")
  valid_776169 = validateParameter(valid_776169, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_776169 != nil:
    section.add "Version", valid_776169
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_776170 = header.getOrDefault("X-Amz-Date")
  valid_776170 = validateParameter(valid_776170, JString, required = false,
                                 default = nil)
  if valid_776170 != nil:
    section.add "X-Amz-Date", valid_776170
  var valid_776171 = header.getOrDefault("X-Amz-Security-Token")
  valid_776171 = validateParameter(valid_776171, JString, required = false,
                                 default = nil)
  if valid_776171 != nil:
    section.add "X-Amz-Security-Token", valid_776171
  var valid_776172 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_776172 = validateParameter(valid_776172, JString, required = false,
                                 default = nil)
  if valid_776172 != nil:
    section.add "X-Amz-Content-Sha256", valid_776172
  var valid_776173 = header.getOrDefault("X-Amz-Algorithm")
  valid_776173 = validateParameter(valid_776173, JString, required = false,
                                 default = nil)
  if valid_776173 != nil:
    section.add "X-Amz-Algorithm", valid_776173
  var valid_776174 = header.getOrDefault("X-Amz-Signature")
  valid_776174 = validateParameter(valid_776174, JString, required = false,
                                 default = nil)
  if valid_776174 != nil:
    section.add "X-Amz-Signature", valid_776174
  var valid_776175 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_776175 = validateParameter(valid_776175, JString, required = false,
                                 default = nil)
  if valid_776175 != nil:
    section.add "X-Amz-SignedHeaders", valid_776175
  var valid_776176 = header.getOrDefault("X-Amz-Credential")
  valid_776176 = validateParameter(valid_776176, JString, required = false,
                                 default = nil)
  if valid_776176 != nil:
    section.add "X-Amz-Credential", valid_776176
  result.add "header", section
  ## parameters in `formData` object:
  ##   PreferredMaintenanceWindow: JString
  ##                             : <p>The weekly time range (in UTC) during which automated cluster maintenance can occur.</p> <p> Format: <code>ddd:hh24:mi-ddd:hh24:mi</code> </p> <p> Default: The value selected for the cluster from which the snapshot was taken. For more information about the time blocks for each region, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-maintenance-windows">Maintenance Windows</a> in Amazon Redshift Cluster Management Guide. </p> <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p> <p>Constraints: Minimum 30-minute window.</p>
  ##   EnhancedVpcRouting: JBool
  ##                     : <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p> <p>Default: false</p>
  ##   Port: JInt
  ##       : <p>The port number on which the cluster accepts connections.</p> <p>Default: The same port as the original cluster.</p> <p>Constraints: Must be between <code>1115</code> and <code>65535</code>.</p>
  ##   VpcSecurityGroupIds: JArray
  ##                      : <p>A list of Virtual Private Cloud (VPC) security groups to be associated with the cluster.</p> <p>Default: The default VPC security group is associated with the cluster.</p> <p>VPC security groups only apply to clusters in VPCs.</p>
  ##   AdditionalInfo: JString
  ##                 : Reserved.
  ##   AvailabilityZone: JString
  ##                   : <p>The Amazon EC2 Availability Zone in which to restore the cluster.</p> <p>Default: A random, system-chosen Availability Zone.</p> <p>Example: <code>us-east-1a</code> </p>
  ##   SnapshotClusterIdentifier: JString
  ##                            : The name of the cluster the source snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.
  ##   ClusterSecurityGroups: JArray
  ##                        : <p>A list of security groups to be associated with this cluster.</p> <p>Default: The default cluster security group for Amazon Redshift.</p> <p>Cluster security groups only apply to clusters outside of VPCs.</p>
  ##   HsmConfigurationIdentifier: JString
  ##                             : Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
  ##   OwnerAccount: JString
  ##               : The AWS customer account used to create or copy the snapshot. Required if you are restoring a snapshot you do not own, optional if you own the snapshot.
  ##   HsmClientCertificateIdentifier: JString
  ##                                 : Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM.
  ##   PubliclyAccessible: JBool
  ##                     : If <code>true</code>, the cluster can be accessed from a public network. 
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The identifier of the cluster that will be created from restoring the snapshot.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul>
  ##   IamRoles: JArray
  ##           : <p>A list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services. You must supply the IAM roles in their Amazon Resource Name (ARN) format. You can supply up to 10 IAM roles in a single request.</p> <p>A cluster can have up to 10 IAM roles associated at any time.</p>
  ##   SnapshotScheduleIdentifier: JString
  ##                             : A unique identifier for the snapshot schedule.
  ##   ClusterParameterGroupName: JString
  ##                            : <p>The name of the parameter group to be associated with this cluster.</p> <p>Default: The default Amazon Redshift cluster parameter group. For information about the default parameter group, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Working with Amazon Redshift Parameter Groups</a>.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   KmsKeyId: JString
  ##           : The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster that you restore from a shared snapshot.
  ##   SnapshotIdentifier: JString (required)
  ##                     : <p>The name of the snapshot from which to create the new cluster. This parameter isn't case sensitive.</p> <p>Example: <code>my-snapshot-id</code> </p>
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The default number of days to retain a manual snapshot. If the value is -1, the snapshot is retained indefinitely. This setting doesn't change the retention period of existing snapshots.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  ##   ElasticIp: JString
  ##            : The elastic IP (EIP) address for the cluster.
  ##   AllowVersionUpgrade: JBool
  ##                      : <p>If <code>true</code>, major version upgrades can be applied during the maintenance window to the Amazon Redshift engine that is running on the cluster. </p> <p>Default: <code>true</code> </p>
  ##   AutomatedSnapshotRetentionPeriod: JInt
  ##                                   : <p>The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p> <p>Default: The value selected for the cluster from which the snapshot was taken.</p> <p>Constraints: Must be a value from 0 to 35.</p>
  ##   NodeType: JString
  ##           : <p>The node type that the restored cluster will be provisioned with.</p> <p>Default: The node type of the cluster from which the snapshot was taken. You can modify this if you are using any DS node type. In that case, you can choose to restore into another DS node type of the same size. For example, you can restore ds1.8xlarge into ds2.8xlarge, or ds1.xlarge into ds2.xlarge. If you have a DC instance type, you must restore into that same instance type and size. In other words, you can only restore a dc1.large instance type into another dc1.large instance type or dc2.large instance type. You can't restore dc1.8xlarge to dc2.8xlarge. First restore to a dc1.8xlareg cluster, then resize to a dc2.8large cluster. For more information about node types, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-about-clusters-and-nodes"> About Clusters and Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ##   MaintenanceTrackName: JString
  ##                       : The name of the maintenance track for the restored cluster. When you take a snapshot, the snapshot inherits the <code>MaintenanceTrack</code> value from the cluster. The snapshot might be on a different track than the cluster that was the source for the snapshot. For example, suppose that you take a snapshot of a cluster that is on the current track and then change the cluster to be on the trailing track. In this case, the snapshot and the source cluster are on different tracks.
  ##   ClusterSubnetGroupName: JString
  ##                         : <p>The name of the subnet group where you want to cluster restored.</p> <p>A snapshot of cluster in VPC can be restored only in VPC. Therefore, you must provide subnet group name where you want the cluster restored.</p>
  section = newJObject()
  var valid_776177 = formData.getOrDefault("PreferredMaintenanceWindow")
  valid_776177 = validateParameter(valid_776177, JString, required = false,
                                 default = nil)
  if valid_776177 != nil:
    section.add "PreferredMaintenanceWindow", valid_776177
  var valid_776178 = formData.getOrDefault("EnhancedVpcRouting")
  valid_776178 = validateParameter(valid_776178, JBool, required = false, default = nil)
  if valid_776178 != nil:
    section.add "EnhancedVpcRouting", valid_776178
  var valid_776179 = formData.getOrDefault("Port")
  valid_776179 = validateParameter(valid_776179, JInt, required = false, default = nil)
  if valid_776179 != nil:
    section.add "Port", valid_776179
  var valid_776180 = formData.getOrDefault("VpcSecurityGroupIds")
  valid_776180 = validateParameter(valid_776180, JArray, required = false,
                                 default = nil)
  if valid_776180 != nil:
    section.add "VpcSecurityGroupIds", valid_776180
  var valid_776181 = formData.getOrDefault("AdditionalInfo")
  valid_776181 = validateParameter(valid_776181, JString, required = false,
                                 default = nil)
  if valid_776181 != nil:
    section.add "AdditionalInfo", valid_776181
  var valid_776182 = formData.getOrDefault("AvailabilityZone")
  valid_776182 = validateParameter(valid_776182, JString, required = false,
                                 default = nil)
  if valid_776182 != nil:
    section.add "AvailabilityZone", valid_776182
  var valid_776183 = formData.getOrDefault("SnapshotClusterIdentifier")
  valid_776183 = validateParameter(valid_776183, JString, required = false,
                                 default = nil)
  if valid_776183 != nil:
    section.add "SnapshotClusterIdentifier", valid_776183
  var valid_776184 = formData.getOrDefault("ClusterSecurityGroups")
  valid_776184 = validateParameter(valid_776184, JArray, required = false,
                                 default = nil)
  if valid_776184 != nil:
    section.add "ClusterSecurityGroups", valid_776184
  var valid_776185 = formData.getOrDefault("HsmConfigurationIdentifier")
  valid_776185 = validateParameter(valid_776185, JString, required = false,
                                 default = nil)
  if valid_776185 != nil:
    section.add "HsmConfigurationIdentifier", valid_776185
  var valid_776186 = formData.getOrDefault("OwnerAccount")
  valid_776186 = validateParameter(valid_776186, JString, required = false,
                                 default = nil)
  if valid_776186 != nil:
    section.add "OwnerAccount", valid_776186
  var valid_776187 = formData.getOrDefault("HsmClientCertificateIdentifier")
  valid_776187 = validateParameter(valid_776187, JString, required = false,
                                 default = nil)
  if valid_776187 != nil:
    section.add "HsmClientCertificateIdentifier", valid_776187
  var valid_776188 = formData.getOrDefault("PubliclyAccessible")
  valid_776188 = validateParameter(valid_776188, JBool, required = false, default = nil)
  if valid_776188 != nil:
    section.add "PubliclyAccessible", valid_776188
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_776189 = formData.getOrDefault("ClusterIdentifier")
  valid_776189 = validateParameter(valid_776189, JString, required = true,
                                 default = nil)
  if valid_776189 != nil:
    section.add "ClusterIdentifier", valid_776189
  var valid_776190 = formData.getOrDefault("IamRoles")
  valid_776190 = validateParameter(valid_776190, JArray, required = false,
                                 default = nil)
  if valid_776190 != nil:
    section.add "IamRoles", valid_776190
  var valid_776191 = formData.getOrDefault("SnapshotScheduleIdentifier")
  valid_776191 = validateParameter(valid_776191, JString, required = false,
                                 default = nil)
  if valid_776191 != nil:
    section.add "SnapshotScheduleIdentifier", valid_776191
  var valid_776192 = formData.getOrDefault("ClusterParameterGroupName")
  valid_776192 = validateParameter(valid_776192, JString, required = false,
                                 default = nil)
  if valid_776192 != nil:
    section.add "ClusterParameterGroupName", valid_776192
  var valid_776193 = formData.getOrDefault("KmsKeyId")
  valid_776193 = validateParameter(valid_776193, JString, required = false,
                                 default = nil)
  if valid_776193 != nil:
    section.add "KmsKeyId", valid_776193
  var valid_776194 = formData.getOrDefault("SnapshotIdentifier")
  valid_776194 = validateParameter(valid_776194, JString, required = true,
                                 default = nil)
  if valid_776194 != nil:
    section.add "SnapshotIdentifier", valid_776194
  var valid_776195 = formData.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_776195 = validateParameter(valid_776195, JInt, required = false, default = nil)
  if valid_776195 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_776195
  var valid_776196 = formData.getOrDefault("ElasticIp")
  valid_776196 = validateParameter(valid_776196, JString, required = false,
                                 default = nil)
  if valid_776196 != nil:
    section.add "ElasticIp", valid_776196
  var valid_776197 = formData.getOrDefault("AllowVersionUpgrade")
  valid_776197 = validateParameter(valid_776197, JBool, required = false, default = nil)
  if valid_776197 != nil:
    section.add "AllowVersionUpgrade", valid_776197
  var valid_776198 = formData.getOrDefault("AutomatedSnapshotRetentionPeriod")
  valid_776198 = validateParameter(valid_776198, JInt, required = false, default = nil)
  if valid_776198 != nil:
    section.add "AutomatedSnapshotRetentionPeriod", valid_776198
  var valid_776199 = formData.getOrDefault("NodeType")
  valid_776199 = validateParameter(valid_776199, JString, required = false,
                                 default = nil)
  if valid_776199 != nil:
    section.add "NodeType", valid_776199
  var valid_776200 = formData.getOrDefault("MaintenanceTrackName")
  valid_776200 = validateParameter(valid_776200, JString, required = false,
                                 default = nil)
  if valid_776200 != nil:
    section.add "MaintenanceTrackName", valid_776200
  var valid_776201 = formData.getOrDefault("ClusterSubnetGroupName")
  valid_776201 = validateParameter(valid_776201, JString, required = false,
                                 default = nil)
  if valid_776201 != nil:
    section.add "ClusterSubnetGroupName", valid_776201
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_776202: Call_PostRestoreFromClusterSnapshot_776165; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a new cluster from a snapshot. By default, Amazon Redshift creates the resulting cluster with the same configuration as the original cluster from which the snapshot was created, except that the new cluster is created with the default cluster security and parameter groups. After Amazon Redshift creates the cluster, you can use the <a>ModifyCluster</a> API to associate a different security group and different parameter group with the restored cluster. If you are using a DS node type, you can also choose to change to another DS node type of the same size during restore.</p> <p>If you restore a cluster into a VPC, you must provide a cluster subnet group where you want the cluster restored.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_776202.validator(path, query, header, formData, body)
  let scheme = call_776202.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_776202.url(scheme.get, call_776202.host, call_776202.base,
                         call_776202.route, valid.getOrDefault("path"))
  result = hook(call_776202, url, valid)

proc call*(call_776203: Call_PostRestoreFromClusterSnapshot_776165;
          ClusterIdentifier: string; SnapshotIdentifier: string;
          PreferredMaintenanceWindow: string = ""; EnhancedVpcRouting: bool = false;
          Port: int = 0; VpcSecurityGroupIds: JsonNode = nil;
          AdditionalInfo: string = ""; AvailabilityZone: string = "";
          SnapshotClusterIdentifier: string = "";
          ClusterSecurityGroups: JsonNode = nil;
          HsmConfigurationIdentifier: string = "";
          Action: string = "RestoreFromClusterSnapshot"; OwnerAccount: string = "";
          HsmClientCertificateIdentifier: string = "";
          PubliclyAccessible: bool = false; IamRoles: JsonNode = nil;
          SnapshotScheduleIdentifier: string = "";
          ClusterParameterGroupName: string = ""; KmsKeyId: string = "";
          ManualSnapshotRetentionPeriod: int = 0; ElasticIp: string = "";
          AllowVersionUpgrade: bool = false;
          AutomatedSnapshotRetentionPeriod: int = 0; Version: string = "2012-12-01";
          NodeType: string = ""; MaintenanceTrackName: string = "";
          ClusterSubnetGroupName: string = ""): Recallable =
  ## postRestoreFromClusterSnapshot
  ## <p>Creates a new cluster from a snapshot. By default, Amazon Redshift creates the resulting cluster with the same configuration as the original cluster from which the snapshot was created, except that the new cluster is created with the default cluster security and parameter groups. After Amazon Redshift creates the cluster, you can use the <a>ModifyCluster</a> API to associate a different security group and different parameter group with the restored cluster. If you are using a DS node type, you can also choose to change to another DS node type of the same size during restore.</p> <p>If you restore a cluster into a VPC, you must provide a cluster subnet group where you want the cluster restored.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   PreferredMaintenanceWindow: string
  ##                             : <p>The weekly time range (in UTC) during which automated cluster maintenance can occur.</p> <p> Format: <code>ddd:hh24:mi-ddd:hh24:mi</code> </p> <p> Default: The value selected for the cluster from which the snapshot was taken. For more information about the time blocks for each region, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-maintenance-windows">Maintenance Windows</a> in Amazon Redshift Cluster Management Guide. </p> <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p> <p>Constraints: Minimum 30-minute window.</p>
  ##   EnhancedVpcRouting: bool
  ##                     : <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p> <p>Default: false</p>
  ##   Port: int
  ##       : <p>The port number on which the cluster accepts connections.</p> <p>Default: The same port as the original cluster.</p> <p>Constraints: Must be between <code>1115</code> and <code>65535</code>.</p>
  ##   VpcSecurityGroupIds: JArray
  ##                      : <p>A list of Virtual Private Cloud (VPC) security groups to be associated with the cluster.</p> <p>Default: The default VPC security group is associated with the cluster.</p> <p>VPC security groups only apply to clusters in VPCs.</p>
  ##   AdditionalInfo: string
  ##                 : Reserved.
  ##   AvailabilityZone: string
  ##                   : <p>The Amazon EC2 Availability Zone in which to restore the cluster.</p> <p>Default: A random, system-chosen Availability Zone.</p> <p>Example: <code>us-east-1a</code> </p>
  ##   SnapshotClusterIdentifier: string
  ##                            : The name of the cluster the source snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.
  ##   ClusterSecurityGroups: JArray
  ##                        : <p>A list of security groups to be associated with this cluster.</p> <p>Default: The default cluster security group for Amazon Redshift.</p> <p>Cluster security groups only apply to clusters outside of VPCs.</p>
  ##   HsmConfigurationIdentifier: string
  ##                             : Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
  ##   Action: string (required)
  ##   OwnerAccount: string
  ##               : The AWS customer account used to create or copy the snapshot. Required if you are restoring a snapshot you do not own, optional if you own the snapshot.
  ##   HsmClientCertificateIdentifier: string
  ##                                 : Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM.
  ##   PubliclyAccessible: bool
  ##                     : If <code>true</code>, the cluster can be accessed from a public network. 
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The identifier of the cluster that will be created from restoring the snapshot.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul>
  ##   IamRoles: JArray
  ##           : <p>A list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services. You must supply the IAM roles in their Amazon Resource Name (ARN) format. You can supply up to 10 IAM roles in a single request.</p> <p>A cluster can have up to 10 IAM roles associated at any time.</p>
  ##   SnapshotScheduleIdentifier: string
  ##                             : A unique identifier for the snapshot schedule.
  ##   ClusterParameterGroupName: string
  ##                            : <p>The name of the parameter group to be associated with this cluster.</p> <p>Default: The default Amazon Redshift cluster parameter group. For information about the default parameter group, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Working with Amazon Redshift Parameter Groups</a>.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   KmsKeyId: string
  ##           : The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster that you restore from a shared snapshot.
  ##   SnapshotIdentifier: string (required)
  ##                     : <p>The name of the snapshot from which to create the new cluster. This parameter isn't case sensitive.</p> <p>Example: <code>my-snapshot-id</code> </p>
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The default number of days to retain a manual snapshot. If the value is -1, the snapshot is retained indefinitely. This setting doesn't change the retention period of existing snapshots.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  ##   ElasticIp: string
  ##            : The elastic IP (EIP) address for the cluster.
  ##   AllowVersionUpgrade: bool
  ##                      : <p>If <code>true</code>, major version upgrades can be applied during the maintenance window to the Amazon Redshift engine that is running on the cluster. </p> <p>Default: <code>true</code> </p>
  ##   AutomatedSnapshotRetentionPeriod: int
  ##                                   : <p>The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p> <p>Default: The value selected for the cluster from which the snapshot was taken.</p> <p>Constraints: Must be a value from 0 to 35.</p>
  ##   Version: string (required)
  ##   NodeType: string
  ##           : <p>The node type that the restored cluster will be provisioned with.</p> <p>Default: The node type of the cluster from which the snapshot was taken. You can modify this if you are using any DS node type. In that case, you can choose to restore into another DS node type of the same size. For example, you can restore ds1.8xlarge into ds2.8xlarge, or ds1.xlarge into ds2.xlarge. If you have a DC instance type, you must restore into that same instance type and size. In other words, you can only restore a dc1.large instance type into another dc1.large instance type or dc2.large instance type. You can't restore dc1.8xlarge to dc2.8xlarge. First restore to a dc1.8xlareg cluster, then resize to a dc2.8large cluster. For more information about node types, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-about-clusters-and-nodes"> About Clusters and Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ##   MaintenanceTrackName: string
  ##                       : The name of the maintenance track for the restored cluster. When you take a snapshot, the snapshot inherits the <code>MaintenanceTrack</code> value from the cluster. The snapshot might be on a different track than the cluster that was the source for the snapshot. For example, suppose that you take a snapshot of a cluster that is on the current track and then change the cluster to be on the trailing track. In this case, the snapshot and the source cluster are on different tracks.
  ##   ClusterSubnetGroupName: string
  ##                         : <p>The name of the subnet group where you want to cluster restored.</p> <p>A snapshot of cluster in VPC can be restored only in VPC. Therefore, you must provide subnet group name where you want the cluster restored.</p>
  var query_776204 = newJObject()
  var formData_776205 = newJObject()
  add(formData_776205, "PreferredMaintenanceWindow",
      newJString(PreferredMaintenanceWindow))
  add(formData_776205, "EnhancedVpcRouting", newJBool(EnhancedVpcRouting))
  add(formData_776205, "Port", newJInt(Port))
  if VpcSecurityGroupIds != nil:
    formData_776205.add "VpcSecurityGroupIds", VpcSecurityGroupIds
  add(formData_776205, "AdditionalInfo", newJString(AdditionalInfo))
  add(formData_776205, "AvailabilityZone", newJString(AvailabilityZone))
  add(formData_776205, "SnapshotClusterIdentifier",
      newJString(SnapshotClusterIdentifier))
  if ClusterSecurityGroups != nil:
    formData_776205.add "ClusterSecurityGroups", ClusterSecurityGroups
  add(formData_776205, "HsmConfigurationIdentifier",
      newJString(HsmConfigurationIdentifier))
  add(query_776204, "Action", newJString(Action))
  add(formData_776205, "OwnerAccount", newJString(OwnerAccount))
  add(formData_776205, "HsmClientCertificateIdentifier",
      newJString(HsmClientCertificateIdentifier))
  add(formData_776205, "PubliclyAccessible", newJBool(PubliclyAccessible))
  add(formData_776205, "ClusterIdentifier", newJString(ClusterIdentifier))
  if IamRoles != nil:
    formData_776205.add "IamRoles", IamRoles
  add(formData_776205, "SnapshotScheduleIdentifier",
      newJString(SnapshotScheduleIdentifier))
  add(formData_776205, "ClusterParameterGroupName",
      newJString(ClusterParameterGroupName))
  add(formData_776205, "KmsKeyId", newJString(KmsKeyId))
  add(formData_776205, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(formData_776205, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  add(formData_776205, "ElasticIp", newJString(ElasticIp))
  add(formData_776205, "AllowVersionUpgrade", newJBool(AllowVersionUpgrade))
  add(formData_776205, "AutomatedSnapshotRetentionPeriod",
      newJInt(AutomatedSnapshotRetentionPeriod))
  add(query_776204, "Version", newJString(Version))
  add(formData_776205, "NodeType", newJString(NodeType))
  add(formData_776205, "MaintenanceTrackName", newJString(MaintenanceTrackName))
  add(formData_776205, "ClusterSubnetGroupName",
      newJString(ClusterSubnetGroupName))
  result = call_776203.call(nil, query_776204, nil, formData_776205, nil)

var postRestoreFromClusterSnapshot* = Call_PostRestoreFromClusterSnapshot_776165(
    name: "postRestoreFromClusterSnapshot", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=RestoreFromClusterSnapshot",
    validator: validate_PostRestoreFromClusterSnapshot_776166, base: "/",
    url: url_PostRestoreFromClusterSnapshot_776167,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetRestoreFromClusterSnapshot_776125 = ref object of OpenApiRestCall_772581
proc url_GetRestoreFromClusterSnapshot_776127(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_GetRestoreFromClusterSnapshot_776126(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a new cluster from a snapshot. By default, Amazon Redshift creates the resulting cluster with the same configuration as the original cluster from which the snapshot was created, except that the new cluster is created with the default cluster security and parameter groups. After Amazon Redshift creates the cluster, you can use the <a>ModifyCluster</a> API to associate a different security group and different parameter group with the restored cluster. If you are using a DS node type, you can also choose to change to another DS node type of the same size during restore.</p> <p>If you restore a cluster into a VPC, you must provide a cluster subnet group where you want the cluster restored.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ClusterSecurityGroups: JArray
  ##                        : <p>A list of security groups to be associated with this cluster.</p> <p>Default: The default cluster security group for Amazon Redshift.</p> <p>Cluster security groups only apply to clusters outside of VPCs.</p>
  ##   ClusterSubnetGroupName: JString
  ##                         : <p>The name of the subnet group where you want to cluster restored.</p> <p>A snapshot of cluster in VPC can be restored only in VPC. Therefore, you must provide subnet group name where you want the cluster restored.</p>
  ##   HsmClientCertificateIdentifier: JString
  ##                                 : Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM.
  ##   PreferredMaintenanceWindow: JString
  ##                             : <p>The weekly time range (in UTC) during which automated cluster maintenance can occur.</p> <p> Format: <code>ddd:hh24:mi-ddd:hh24:mi</code> </p> <p> Default: The value selected for the cluster from which the snapshot was taken. For more information about the time blocks for each region, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-maintenance-windows">Maintenance Windows</a> in Amazon Redshift Cluster Management Guide. </p> <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p> <p>Constraints: Minimum 30-minute window.</p>
  ##   MaintenanceTrackName: JString
  ##                       : The name of the maintenance track for the restored cluster. When you take a snapshot, the snapshot inherits the <code>MaintenanceTrack</code> value from the cluster. The snapshot might be on a different track than the cluster that was the source for the snapshot. For example, suppose that you take a snapshot of a cluster that is on the current track and then change the cluster to be on the trailing track. In this case, the snapshot and the source cluster are on different tracks.
  ##   IamRoles: JArray
  ##           : <p>A list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services. You must supply the IAM roles in their Amazon Resource Name (ARN) format. You can supply up to 10 IAM roles in a single request.</p> <p>A cluster can have up to 10 IAM roles associated at any time.</p>
  ##   AvailabilityZone: JString
  ##                   : <p>The Amazon EC2 Availability Zone in which to restore the cluster.</p> <p>Default: A random, system-chosen Availability Zone.</p> <p>Example: <code>us-east-1a</code> </p>
  ##   AllowVersionUpgrade: JBool
  ##                      : <p>If <code>true</code>, major version upgrades can be applied during the maintenance window to the Amazon Redshift engine that is running on the cluster. </p> <p>Default: <code>true</code> </p>
  ##   EnhancedVpcRouting: JBool
  ##                     : <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p> <p>Default: false</p>
  ##   VpcSecurityGroupIds: JArray
  ##                      : <p>A list of Virtual Private Cloud (VPC) security groups to be associated with the cluster.</p> <p>Default: The default VPC security group is associated with the cluster.</p> <p>VPC security groups only apply to clusters in VPCs.</p>
  ##   ClusterParameterGroupName: JString
  ##                            : <p>The name of the parameter group to be associated with this cluster.</p> <p>Default: The default Amazon Redshift cluster parameter group. For information about the default parameter group, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Working with Amazon Redshift Parameter Groups</a>.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   HsmConfigurationIdentifier: JString
  ##                             : Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
  ##   SnapshotScheduleIdentifier: JString
  ##                             : A unique identifier for the snapshot schedule.
  ##   AdditionalInfo: JString
  ##                 : Reserved.
  ##   ElasticIp: JString
  ##            : The elastic IP (EIP) address for the cluster.
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The identifier of the cluster that will be created from restoring the snapshot.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul>
  ##   OwnerAccount: JString
  ##               : The AWS customer account used to create or copy the snapshot. Required if you are restoring a snapshot you do not own, optional if you own the snapshot.
  ##   Action: JString (required)
  ##   KmsKeyId: JString
  ##           : The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster that you restore from a shared snapshot.
  ##   PubliclyAccessible: JBool
  ##                     : If <code>true</code>, the cluster can be accessed from a public network. 
  ##   SnapshotClusterIdentifier: JString
  ##                            : The name of the cluster the source snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.
  ##   Port: JInt
  ##       : <p>The port number on which the cluster accepts connections.</p> <p>Default: The same port as the original cluster.</p> <p>Constraints: Must be between <code>1115</code> and <code>65535</code>.</p>
  ##   SnapshotIdentifier: JString (required)
  ##                     : <p>The name of the snapshot from which to create the new cluster. This parameter isn't case sensitive.</p> <p>Example: <code>my-snapshot-id</code> </p>
  ##   AutomatedSnapshotRetentionPeriod: JInt
  ##                                   : <p>The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p> <p>Default: The value selected for the cluster from which the snapshot was taken.</p> <p>Constraints: Must be a value from 0 to 35.</p>
  ##   NodeType: JString
  ##           : <p>The node type that the restored cluster will be provisioned with.</p> <p>Default: The node type of the cluster from which the snapshot was taken. You can modify this if you are using any DS node type. In that case, you can choose to restore into another DS node type of the same size. For example, you can restore ds1.8xlarge into ds2.8xlarge, or ds1.xlarge into ds2.xlarge. If you have a DC instance type, you must restore into that same instance type and size. In other words, you can only restore a dc1.large instance type into another dc1.large instance type or dc2.large instance type. You can't restore dc1.8xlarge to dc2.8xlarge. First restore to a dc1.8xlareg cluster, then resize to a dc2.8large cluster. For more information about node types, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-about-clusters-and-nodes"> About Clusters and Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ##   Version: JString (required)
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The default number of days to retain a manual snapshot. If the value is -1, the snapshot is retained indefinitely. This setting doesn't change the retention period of existing snapshots.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  section = newJObject()
  var valid_776128 = query.getOrDefault("ClusterSecurityGroups")
  valid_776128 = validateParameter(valid_776128, JArray, required = false,
                                 default = nil)
  if valid_776128 != nil:
    section.add "ClusterSecurityGroups", valid_776128
  var valid_776129 = query.getOrDefault("ClusterSubnetGroupName")
  valid_776129 = validateParameter(valid_776129, JString, required = false,
                                 default = nil)
  if valid_776129 != nil:
    section.add "ClusterSubnetGroupName", valid_776129
  var valid_776130 = query.getOrDefault("HsmClientCertificateIdentifier")
  valid_776130 = validateParameter(valid_776130, JString, required = false,
                                 default = nil)
  if valid_776130 != nil:
    section.add "HsmClientCertificateIdentifier", valid_776130
  var valid_776131 = query.getOrDefault("PreferredMaintenanceWindow")
  valid_776131 = validateParameter(valid_776131, JString, required = false,
                                 default = nil)
  if valid_776131 != nil:
    section.add "PreferredMaintenanceWindow", valid_776131
  var valid_776132 = query.getOrDefault("MaintenanceTrackName")
  valid_776132 = validateParameter(valid_776132, JString, required = false,
                                 default = nil)
  if valid_776132 != nil:
    section.add "MaintenanceTrackName", valid_776132
  var valid_776133 = query.getOrDefault("IamRoles")
  valid_776133 = validateParameter(valid_776133, JArray, required = false,
                                 default = nil)
  if valid_776133 != nil:
    section.add "IamRoles", valid_776133
  var valid_776134 = query.getOrDefault("AvailabilityZone")
  valid_776134 = validateParameter(valid_776134, JString, required = false,
                                 default = nil)
  if valid_776134 != nil:
    section.add "AvailabilityZone", valid_776134
  var valid_776135 = query.getOrDefault("AllowVersionUpgrade")
  valid_776135 = validateParameter(valid_776135, JBool, required = false, default = nil)
  if valid_776135 != nil:
    section.add "AllowVersionUpgrade", valid_776135
  var valid_776136 = query.getOrDefault("EnhancedVpcRouting")
  valid_776136 = validateParameter(valid_776136, JBool, required = false, default = nil)
  if valid_776136 != nil:
    section.add "EnhancedVpcRouting", valid_776136
  var valid_776137 = query.getOrDefault("VpcSecurityGroupIds")
  valid_776137 = validateParameter(valid_776137, JArray, required = false,
                                 default = nil)
  if valid_776137 != nil:
    section.add "VpcSecurityGroupIds", valid_776137
  var valid_776138 = query.getOrDefault("ClusterParameterGroupName")
  valid_776138 = validateParameter(valid_776138, JString, required = false,
                                 default = nil)
  if valid_776138 != nil:
    section.add "ClusterParameterGroupName", valid_776138
  var valid_776139 = query.getOrDefault("HsmConfigurationIdentifier")
  valid_776139 = validateParameter(valid_776139, JString, required = false,
                                 default = nil)
  if valid_776139 != nil:
    section.add "HsmConfigurationIdentifier", valid_776139
  var valid_776140 = query.getOrDefault("SnapshotScheduleIdentifier")
  valid_776140 = validateParameter(valid_776140, JString, required = false,
                                 default = nil)
  if valid_776140 != nil:
    section.add "SnapshotScheduleIdentifier", valid_776140
  var valid_776141 = query.getOrDefault("AdditionalInfo")
  valid_776141 = validateParameter(valid_776141, JString, required = false,
                                 default = nil)
  if valid_776141 != nil:
    section.add "AdditionalInfo", valid_776141
  var valid_776142 = query.getOrDefault("ElasticIp")
  valid_776142 = validateParameter(valid_776142, JString, required = false,
                                 default = nil)
  if valid_776142 != nil:
    section.add "ElasticIp", valid_776142
  assert query != nil,
        "query argument is necessary due to required `ClusterIdentifier` field"
  var valid_776143 = query.getOrDefault("ClusterIdentifier")
  valid_776143 = validateParameter(valid_776143, JString, required = true,
                                 default = nil)
  if valid_776143 != nil:
    section.add "ClusterIdentifier", valid_776143
  var valid_776144 = query.getOrDefault("OwnerAccount")
  valid_776144 = validateParameter(valid_776144, JString, required = false,
                                 default = nil)
  if valid_776144 != nil:
    section.add "OwnerAccount", valid_776144
  var valid_776145 = query.getOrDefault("Action")
  valid_776145 = validateParameter(valid_776145, JString, required = true, default = newJString(
      "RestoreFromClusterSnapshot"))
  if valid_776145 != nil:
    section.add "Action", valid_776145
  var valid_776146 = query.getOrDefault("KmsKeyId")
  valid_776146 = validateParameter(valid_776146, JString, required = false,
                                 default = nil)
  if valid_776146 != nil:
    section.add "KmsKeyId", valid_776146
  var valid_776147 = query.getOrDefault("PubliclyAccessible")
  valid_776147 = validateParameter(valid_776147, JBool, required = false, default = nil)
  if valid_776147 != nil:
    section.add "PubliclyAccessible", valid_776147
  var valid_776148 = query.getOrDefault("SnapshotClusterIdentifier")
  valid_776148 = validateParameter(valid_776148, JString, required = false,
                                 default = nil)
  if valid_776148 != nil:
    section.add "SnapshotClusterIdentifier", valid_776148
  var valid_776149 = query.getOrDefault("Port")
  valid_776149 = validateParameter(valid_776149, JInt, required = false, default = nil)
  if valid_776149 != nil:
    section.add "Port", valid_776149
  var valid_776150 = query.getOrDefault("SnapshotIdentifier")
  valid_776150 = validateParameter(valid_776150, JString, required = true,
                                 default = nil)
  if valid_776150 != nil:
    section.add "SnapshotIdentifier", valid_776150
  var valid_776151 = query.getOrDefault("AutomatedSnapshotRetentionPeriod")
  valid_776151 = validateParameter(valid_776151, JInt, required = false, default = nil)
  if valid_776151 != nil:
    section.add "AutomatedSnapshotRetentionPeriod", valid_776151
  var valid_776152 = query.getOrDefault("NodeType")
  valid_776152 = validateParameter(valid_776152, JString, required = false,
                                 default = nil)
  if valid_776152 != nil:
    section.add "NodeType", valid_776152
  var valid_776153 = query.getOrDefault("Version")
  valid_776153 = validateParameter(valid_776153, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_776153 != nil:
    section.add "Version", valid_776153
  var valid_776154 = query.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_776154 = validateParameter(valid_776154, JInt, required = false, default = nil)
  if valid_776154 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_776154
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_776155 = header.getOrDefault("X-Amz-Date")
  valid_776155 = validateParameter(valid_776155, JString, required = false,
                                 default = nil)
  if valid_776155 != nil:
    section.add "X-Amz-Date", valid_776155
  var valid_776156 = header.getOrDefault("X-Amz-Security-Token")
  valid_776156 = validateParameter(valid_776156, JString, required = false,
                                 default = nil)
  if valid_776156 != nil:
    section.add "X-Amz-Security-Token", valid_776156
  var valid_776157 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_776157 = validateParameter(valid_776157, JString, required = false,
                                 default = nil)
  if valid_776157 != nil:
    section.add "X-Amz-Content-Sha256", valid_776157
  var valid_776158 = header.getOrDefault("X-Amz-Algorithm")
  valid_776158 = validateParameter(valid_776158, JString, required = false,
                                 default = nil)
  if valid_776158 != nil:
    section.add "X-Amz-Algorithm", valid_776158
  var valid_776159 = header.getOrDefault("X-Amz-Signature")
  valid_776159 = validateParameter(valid_776159, JString, required = false,
                                 default = nil)
  if valid_776159 != nil:
    section.add "X-Amz-Signature", valid_776159
  var valid_776160 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_776160 = validateParameter(valid_776160, JString, required = false,
                                 default = nil)
  if valid_776160 != nil:
    section.add "X-Amz-SignedHeaders", valid_776160
  var valid_776161 = header.getOrDefault("X-Amz-Credential")
  valid_776161 = validateParameter(valid_776161, JString, required = false,
                                 default = nil)
  if valid_776161 != nil:
    section.add "X-Amz-Credential", valid_776161
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_776162: Call_GetRestoreFromClusterSnapshot_776125; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a new cluster from a snapshot. By default, Amazon Redshift creates the resulting cluster with the same configuration as the original cluster from which the snapshot was created, except that the new cluster is created with the default cluster security and parameter groups. After Amazon Redshift creates the cluster, you can use the <a>ModifyCluster</a> API to associate a different security group and different parameter group with the restored cluster. If you are using a DS node type, you can also choose to change to another DS node type of the same size during restore.</p> <p>If you restore a cluster into a VPC, you must provide a cluster subnet group where you want the cluster restored.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_776162.validator(path, query, header, formData, body)
  let scheme = call_776162.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_776162.url(scheme.get, call_776162.host, call_776162.base,
                         call_776162.route, valid.getOrDefault("path"))
  result = hook(call_776162, url, valid)

proc call*(call_776163: Call_GetRestoreFromClusterSnapshot_776125;
          ClusterIdentifier: string; SnapshotIdentifier: string;
          ClusterSecurityGroups: JsonNode = nil;
          ClusterSubnetGroupName: string = "";
          HsmClientCertificateIdentifier: string = "";
          PreferredMaintenanceWindow: string = "";
          MaintenanceTrackName: string = ""; IamRoles: JsonNode = nil;
          AvailabilityZone: string = ""; AllowVersionUpgrade: bool = false;
          EnhancedVpcRouting: bool = false; VpcSecurityGroupIds: JsonNode = nil;
          ClusterParameterGroupName: string = "";
          HsmConfigurationIdentifier: string = "";
          SnapshotScheduleIdentifier: string = ""; AdditionalInfo: string = "";
          ElasticIp: string = ""; OwnerAccount: string = "";
          Action: string = "RestoreFromClusterSnapshot"; KmsKeyId: string = "";
          PubliclyAccessible: bool = false; SnapshotClusterIdentifier: string = "";
          Port: int = 0; AutomatedSnapshotRetentionPeriod: int = 0;
          NodeType: string = ""; Version: string = "2012-12-01";
          ManualSnapshotRetentionPeriod: int = 0): Recallable =
  ## getRestoreFromClusterSnapshot
  ## <p>Creates a new cluster from a snapshot. By default, Amazon Redshift creates the resulting cluster with the same configuration as the original cluster from which the snapshot was created, except that the new cluster is created with the default cluster security and parameter groups. After Amazon Redshift creates the cluster, you can use the <a>ModifyCluster</a> API to associate a different security group and different parameter group with the restored cluster. If you are using a DS node type, you can also choose to change to another DS node type of the same size during restore.</p> <p>If you restore a cluster into a VPC, you must provide a cluster subnet group where you want the cluster restored.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   ClusterSecurityGroups: JArray
  ##                        : <p>A list of security groups to be associated with this cluster.</p> <p>Default: The default cluster security group for Amazon Redshift.</p> <p>Cluster security groups only apply to clusters outside of VPCs.</p>
  ##   ClusterSubnetGroupName: string
  ##                         : <p>The name of the subnet group where you want to cluster restored.</p> <p>A snapshot of cluster in VPC can be restored only in VPC. Therefore, you must provide subnet group name where you want the cluster restored.</p>
  ##   HsmClientCertificateIdentifier: string
  ##                                 : Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM.
  ##   PreferredMaintenanceWindow: string
  ##                             : <p>The weekly time range (in UTC) during which automated cluster maintenance can occur.</p> <p> Format: <code>ddd:hh24:mi-ddd:hh24:mi</code> </p> <p> Default: The value selected for the cluster from which the snapshot was taken. For more information about the time blocks for each region, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-maintenance-windows">Maintenance Windows</a> in Amazon Redshift Cluster Management Guide. </p> <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p> <p>Constraints: Minimum 30-minute window.</p>
  ##   MaintenanceTrackName: string
  ##                       : The name of the maintenance track for the restored cluster. When you take a snapshot, the snapshot inherits the <code>MaintenanceTrack</code> value from the cluster. The snapshot might be on a different track than the cluster that was the source for the snapshot. For example, suppose that you take a snapshot of a cluster that is on the current track and then change the cluster to be on the trailing track. In this case, the snapshot and the source cluster are on different tracks.
  ##   IamRoles: JArray
  ##           : <p>A list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services. You must supply the IAM roles in their Amazon Resource Name (ARN) format. You can supply up to 10 IAM roles in a single request.</p> <p>A cluster can have up to 10 IAM roles associated at any time.</p>
  ##   AvailabilityZone: string
  ##                   : <p>The Amazon EC2 Availability Zone in which to restore the cluster.</p> <p>Default: A random, system-chosen Availability Zone.</p> <p>Example: <code>us-east-1a</code> </p>
  ##   AllowVersionUpgrade: bool
  ##                      : <p>If <code>true</code>, major version upgrades can be applied during the maintenance window to the Amazon Redshift engine that is running on the cluster. </p> <p>Default: <code>true</code> </p>
  ##   EnhancedVpcRouting: bool
  ##                     : <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p> <p>Default: false</p>
  ##   VpcSecurityGroupIds: JArray
  ##                      : <p>A list of Virtual Private Cloud (VPC) security groups to be associated with the cluster.</p> <p>Default: The default VPC security group is associated with the cluster.</p> <p>VPC security groups only apply to clusters in VPCs.</p>
  ##   ClusterParameterGroupName: string
  ##                            : <p>The name of the parameter group to be associated with this cluster.</p> <p>Default: The default Amazon Redshift cluster parameter group. For information about the default parameter group, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Working with Amazon Redshift Parameter Groups</a>.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   HsmConfigurationIdentifier: string
  ##                             : Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
  ##   SnapshotScheduleIdentifier: string
  ##                             : A unique identifier for the snapshot schedule.
  ##   AdditionalInfo: string
  ##                 : Reserved.
  ##   ElasticIp: string
  ##            : The elastic IP (EIP) address for the cluster.
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The identifier of the cluster that will be created from restoring the snapshot.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul>
  ##   OwnerAccount: string
  ##               : The AWS customer account used to create or copy the snapshot. Required if you are restoring a snapshot you do not own, optional if you own the snapshot.
  ##   Action: string (required)
  ##   KmsKeyId: string
  ##           : The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster that you restore from a shared snapshot.
  ##   PubliclyAccessible: bool
  ##                     : If <code>true</code>, the cluster can be accessed from a public network. 
  ##   SnapshotClusterIdentifier: string
  ##                            : The name of the cluster the source snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.
  ##   Port: int
  ##       : <p>The port number on which the cluster accepts connections.</p> <p>Default: The same port as the original cluster.</p> <p>Constraints: Must be between <code>1115</code> and <code>65535</code>.</p>
  ##   SnapshotIdentifier: string (required)
  ##                     : <p>The name of the snapshot from which to create the new cluster. This parameter isn't case sensitive.</p> <p>Example: <code>my-snapshot-id</code> </p>
  ##   AutomatedSnapshotRetentionPeriod: int
  ##                                   : <p>The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p> <p>Default: The value selected for the cluster from which the snapshot was taken.</p> <p>Constraints: Must be a value from 0 to 35.</p>
  ##   NodeType: string
  ##           : <p>The node type that the restored cluster will be provisioned with.</p> <p>Default: The node type of the cluster from which the snapshot was taken. You can modify this if you are using any DS node type. In that case, you can choose to restore into another DS node type of the same size. For example, you can restore ds1.8xlarge into ds2.8xlarge, or ds1.xlarge into ds2.xlarge. If you have a DC instance type, you must restore into that same instance type and size. In other words, you can only restore a dc1.large instance type into another dc1.large instance type or dc2.large instance type. You can't restore dc1.8xlarge to dc2.8xlarge. First restore to a dc1.8xlareg cluster, then resize to a dc2.8large cluster. For more information about node types, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-about-clusters-and-nodes"> About Clusters and Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ##   Version: string (required)
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The default number of days to retain a manual snapshot. If the value is -1, the snapshot is retained indefinitely. This setting doesn't change the retention period of existing snapshots.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  var query_776164 = newJObject()
  if ClusterSecurityGroups != nil:
    query_776164.add "ClusterSecurityGroups", ClusterSecurityGroups
  add(query_776164, "ClusterSubnetGroupName", newJString(ClusterSubnetGroupName))
  add(query_776164, "HsmClientCertificateIdentifier",
      newJString(HsmClientCertificateIdentifier))
  add(query_776164, "PreferredMaintenanceWindow",
      newJString(PreferredMaintenanceWindow))
  add(query_776164, "MaintenanceTrackName", newJString(MaintenanceTrackName))
  if IamRoles != nil:
    query_776164.add "IamRoles", IamRoles
  add(query_776164, "AvailabilityZone", newJString(AvailabilityZone))
  add(query_776164, "AllowVersionUpgrade", newJBool(AllowVersionUpgrade))
  add(query_776164, "EnhancedVpcRouting", newJBool(EnhancedVpcRouting))
  if VpcSecurityGroupIds != nil:
    query_776164.add "VpcSecurityGroupIds", VpcSecurityGroupIds
  add(query_776164, "ClusterParameterGroupName",
      newJString(ClusterParameterGroupName))
  add(query_776164, "HsmConfigurationIdentifier",
      newJString(HsmConfigurationIdentifier))
  add(query_776164, "SnapshotScheduleIdentifier",
      newJString(SnapshotScheduleIdentifier))
  add(query_776164, "AdditionalInfo", newJString(AdditionalInfo))
  add(query_776164, "ElasticIp", newJString(ElasticIp))
  add(query_776164, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_776164, "OwnerAccount", newJString(OwnerAccount))
  add(query_776164, "Action", newJString(Action))
  add(query_776164, "KmsKeyId", newJString(KmsKeyId))
  add(query_776164, "PubliclyAccessible", newJBool(PubliclyAccessible))
  add(query_776164, "SnapshotClusterIdentifier",
      newJString(SnapshotClusterIdentifier))
  add(query_776164, "Port", newJInt(Port))
  add(query_776164, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_776164, "AutomatedSnapshotRetentionPeriod",
      newJInt(AutomatedSnapshotRetentionPeriod))
  add(query_776164, "NodeType", newJString(NodeType))
  add(query_776164, "Version", newJString(Version))
  add(query_776164, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  result = call_776163.call(nil, query_776164, nil, nil, nil)

var getRestoreFromClusterSnapshot* = Call_GetRestoreFromClusterSnapshot_776125(
    name: "getRestoreFromClusterSnapshot", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=RestoreFromClusterSnapshot",
    validator: validate_GetRestoreFromClusterSnapshot_776126, base: "/",
    url: url_GetRestoreFromClusterSnapshot_776127,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostRestoreTableFromClusterSnapshot_776229 = ref object of OpenApiRestCall_772581
proc url_PostRestoreTableFromClusterSnapshot_776231(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_PostRestoreTableFromClusterSnapshot_776230(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a new table from a table in an Amazon Redshift cluster snapshot. You must create the new table within the Amazon Redshift cluster that the snapshot was taken from.</p> <p>You cannot use <code>RestoreTableFromClusterSnapshot</code> to restore a table with the same name as an existing table in an Amazon Redshift cluster. That is, you cannot overwrite an existing table in a cluster with a restored table. If you want to replace your original table with a new, restored table, then rename or drop your original table before you call <code>RestoreTableFromClusterSnapshot</code>. When you have renamed your original table, then you can pass the original name of the table as the <code>NewTableName</code> parameter value in the call to <code>RestoreTableFromClusterSnapshot</code>. This way, you can replace the original table with the table created from the snapshot.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_776232 = query.getOrDefault("Action")
  valid_776232 = validateParameter(valid_776232, JString, required = true, default = newJString(
      "RestoreTableFromClusterSnapshot"))
  if valid_776232 != nil:
    section.add "Action", valid_776232
  var valid_776233 = query.getOrDefault("Version")
  valid_776233 = validateParameter(valid_776233, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_776233 != nil:
    section.add "Version", valid_776233
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_776234 = header.getOrDefault("X-Amz-Date")
  valid_776234 = validateParameter(valid_776234, JString, required = false,
                                 default = nil)
  if valid_776234 != nil:
    section.add "X-Amz-Date", valid_776234
  var valid_776235 = header.getOrDefault("X-Amz-Security-Token")
  valid_776235 = validateParameter(valid_776235, JString, required = false,
                                 default = nil)
  if valid_776235 != nil:
    section.add "X-Amz-Security-Token", valid_776235
  var valid_776236 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_776236 = validateParameter(valid_776236, JString, required = false,
                                 default = nil)
  if valid_776236 != nil:
    section.add "X-Amz-Content-Sha256", valid_776236
  var valid_776237 = header.getOrDefault("X-Amz-Algorithm")
  valid_776237 = validateParameter(valid_776237, JString, required = false,
                                 default = nil)
  if valid_776237 != nil:
    section.add "X-Amz-Algorithm", valid_776237
  var valid_776238 = header.getOrDefault("X-Amz-Signature")
  valid_776238 = validateParameter(valid_776238, JString, required = false,
                                 default = nil)
  if valid_776238 != nil:
    section.add "X-Amz-Signature", valid_776238
  var valid_776239 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_776239 = validateParameter(valid_776239, JString, required = false,
                                 default = nil)
  if valid_776239 != nil:
    section.add "X-Amz-SignedHeaders", valid_776239
  var valid_776240 = header.getOrDefault("X-Amz-Credential")
  valid_776240 = validateParameter(valid_776240, JString, required = false,
                                 default = nil)
  if valid_776240 != nil:
    section.add "X-Amz-Credential", valid_776240
  result.add "header", section
  ## parameters in `formData` object:
  ##   SourceSchemaName: JString
  ##                   : The name of the source schema that contains the table to restore from. If you do not specify a <code>SourceSchemaName</code> value, the default is <code>public</code>.
  ##   SourceDatabaseName: JString (required)
  ##                     : The name of the source database that contains the table to restore from.
  ##   SourceTableName: JString (required)
  ##                  : The name of the source table to restore from.
  ##   ClusterIdentifier: JString (required)
  ##                    : The identifier of the Amazon Redshift cluster to restore the table to.
  ##   TargetDatabaseName: JString
  ##                     : The name of the database to restore the table to.
  ##   SnapshotIdentifier: JString (required)
  ##                     : The identifier of the snapshot to restore the table from. This snapshot must have been created from the Amazon Redshift cluster specified by the <code>ClusterIdentifier</code> parameter.
  ##   TargetSchemaName: JString
  ##                   : The name of the schema to restore the table to.
  ##   NewTableName: JString (required)
  ##               : The name of the table to create as a result of the current request.
  section = newJObject()
  var valid_776241 = formData.getOrDefault("SourceSchemaName")
  valid_776241 = validateParameter(valid_776241, JString, required = false,
                                 default = nil)
  if valid_776241 != nil:
    section.add "SourceSchemaName", valid_776241
  assert formData != nil, "formData argument is necessary due to required `SourceDatabaseName` field"
  var valid_776242 = formData.getOrDefault("SourceDatabaseName")
  valid_776242 = validateParameter(valid_776242, JString, required = true,
                                 default = nil)
  if valid_776242 != nil:
    section.add "SourceDatabaseName", valid_776242
  var valid_776243 = formData.getOrDefault("SourceTableName")
  valid_776243 = validateParameter(valid_776243, JString, required = true,
                                 default = nil)
  if valid_776243 != nil:
    section.add "SourceTableName", valid_776243
  var valid_776244 = formData.getOrDefault("ClusterIdentifier")
  valid_776244 = validateParameter(valid_776244, JString, required = true,
                                 default = nil)
  if valid_776244 != nil:
    section.add "ClusterIdentifier", valid_776244
  var valid_776245 = formData.getOrDefault("TargetDatabaseName")
  valid_776245 = validateParameter(valid_776245, JString, required = false,
                                 default = nil)
  if valid_776245 != nil:
    section.add "TargetDatabaseName", valid_776245
  var valid_776246 = formData.getOrDefault("SnapshotIdentifier")
  valid_776246 = validateParameter(valid_776246, JString, required = true,
                                 default = nil)
  if valid_776246 != nil:
    section.add "SnapshotIdentifier", valid_776246
  var valid_776247 = formData.getOrDefault("TargetSchemaName")
  valid_776247 = validateParameter(valid_776247, JString, required = false,
                                 default = nil)
  if valid_776247 != nil:
    section.add "TargetSchemaName", valid_776247
  var valid_776248 = formData.getOrDefault("NewTableName")
  valid_776248 = validateParameter(valid_776248, JString, required = true,
                                 default = nil)
  if valid_776248 != nil:
    section.add "NewTableName", valid_776248
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_776249: Call_PostRestoreTableFromClusterSnapshot_776229;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Creates a new table from a table in an Amazon Redshift cluster snapshot. You must create the new table within the Amazon Redshift cluster that the snapshot was taken from.</p> <p>You cannot use <code>RestoreTableFromClusterSnapshot</code> to restore a table with the same name as an existing table in an Amazon Redshift cluster. That is, you cannot overwrite an existing table in a cluster with a restored table. If you want to replace your original table with a new, restored table, then rename or drop your original table before you call <code>RestoreTableFromClusterSnapshot</code>. When you have renamed your original table, then you can pass the original name of the table as the <code>NewTableName</code> parameter value in the call to <code>RestoreTableFromClusterSnapshot</code>. This way, you can replace the original table with the table created from the snapshot.</p>
  ## 
  let valid = call_776249.validator(path, query, header, formData, body)
  let scheme = call_776249.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_776249.url(scheme.get, call_776249.host, call_776249.base,
                         call_776249.route, valid.getOrDefault("path"))
  result = hook(call_776249, url, valid)

proc call*(call_776250: Call_PostRestoreTableFromClusterSnapshot_776229;
          SourceDatabaseName: string; SourceTableName: string;
          ClusterIdentifier: string; SnapshotIdentifier: string;
          NewTableName: string; SourceSchemaName: string = "";
          Action: string = "RestoreTableFromClusterSnapshot";
          TargetDatabaseName: string = ""; TargetSchemaName: string = "";
          Version: string = "2012-12-01"): Recallable =
  ## postRestoreTableFromClusterSnapshot
  ## <p>Creates a new table from a table in an Amazon Redshift cluster snapshot. You must create the new table within the Amazon Redshift cluster that the snapshot was taken from.</p> <p>You cannot use <code>RestoreTableFromClusterSnapshot</code> to restore a table with the same name as an existing table in an Amazon Redshift cluster. That is, you cannot overwrite an existing table in a cluster with a restored table. If you want to replace your original table with a new, restored table, then rename or drop your original table before you call <code>RestoreTableFromClusterSnapshot</code>. When you have renamed your original table, then you can pass the original name of the table as the <code>NewTableName</code> parameter value in the call to <code>RestoreTableFromClusterSnapshot</code>. This way, you can replace the original table with the table created from the snapshot.</p>
  ##   SourceSchemaName: string
  ##                   : The name of the source schema that contains the table to restore from. If you do not specify a <code>SourceSchemaName</code> value, the default is <code>public</code>.
  ##   SourceDatabaseName: string (required)
  ##                     : The name of the source database that contains the table to restore from.
  ##   SourceTableName: string (required)
  ##                  : The name of the source table to restore from.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : The identifier of the Amazon Redshift cluster to restore the table to.
  ##   TargetDatabaseName: string
  ##                     : The name of the database to restore the table to.
  ##   SnapshotIdentifier: string (required)
  ##                     : The identifier of the snapshot to restore the table from. This snapshot must have been created from the Amazon Redshift cluster specified by the <code>ClusterIdentifier</code> parameter.
  ##   TargetSchemaName: string
  ##                   : The name of the schema to restore the table to.
  ##   NewTableName: string (required)
  ##               : The name of the table to create as a result of the current request.
  ##   Version: string (required)
  var query_776251 = newJObject()
  var formData_776252 = newJObject()
  add(formData_776252, "SourceSchemaName", newJString(SourceSchemaName))
  add(formData_776252, "SourceDatabaseName", newJString(SourceDatabaseName))
  add(formData_776252, "SourceTableName", newJString(SourceTableName))
  add(query_776251, "Action", newJString(Action))
  add(formData_776252, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_776252, "TargetDatabaseName", newJString(TargetDatabaseName))
  add(formData_776252, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(formData_776252, "TargetSchemaName", newJString(TargetSchemaName))
  add(formData_776252, "NewTableName", newJString(NewTableName))
  add(query_776251, "Version", newJString(Version))
  result = call_776250.call(nil, query_776251, nil, formData_776252, nil)

var postRestoreTableFromClusterSnapshot* = Call_PostRestoreTableFromClusterSnapshot_776229(
    name: "postRestoreTableFromClusterSnapshot", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=RestoreTableFromClusterSnapshot",
    validator: validate_PostRestoreTableFromClusterSnapshot_776230, base: "/",
    url: url_PostRestoreTableFromClusterSnapshot_776231,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetRestoreTableFromClusterSnapshot_776206 = ref object of OpenApiRestCall_772581
proc url_GetRestoreTableFromClusterSnapshot_776208(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_GetRestoreTableFromClusterSnapshot_776207(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a new table from a table in an Amazon Redshift cluster snapshot. You must create the new table within the Amazon Redshift cluster that the snapshot was taken from.</p> <p>You cannot use <code>RestoreTableFromClusterSnapshot</code> to restore a table with the same name as an existing table in an Amazon Redshift cluster. That is, you cannot overwrite an existing table in a cluster with a restored table. If you want to replace your original table with a new, restored table, then rename or drop your original table before you call <code>RestoreTableFromClusterSnapshot</code>. When you have renamed your original table, then you can pass the original name of the table as the <code>NewTableName</code> parameter value in the call to <code>RestoreTableFromClusterSnapshot</code>. This way, you can replace the original table with the table created from the snapshot.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   SourceDatabaseName: JString (required)
  ##                     : The name of the source database that contains the table to restore from.
  ##   SourceTableName: JString (required)
  ##                  : The name of the source table to restore from.
  ##   SourceSchemaName: JString
  ##                   : The name of the source schema that contains the table to restore from. If you do not specify a <code>SourceSchemaName</code> value, the default is <code>public</code>.
  ##   ClusterIdentifier: JString (required)
  ##                    : The identifier of the Amazon Redshift cluster to restore the table to.
  ##   Action: JString (required)
  ##   TargetDatabaseName: JString
  ##                     : The name of the database to restore the table to.
  ##   NewTableName: JString (required)
  ##               : The name of the table to create as a result of the current request.
  ##   SnapshotIdentifier: JString (required)
  ##                     : The identifier of the snapshot to restore the table from. This snapshot must have been created from the Amazon Redshift cluster specified by the <code>ClusterIdentifier</code> parameter.
  ##   Version: JString (required)
  ##   TargetSchemaName: JString
  ##                   : The name of the schema to restore the table to.
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `SourceDatabaseName` field"
  var valid_776209 = query.getOrDefault("SourceDatabaseName")
  valid_776209 = validateParameter(valid_776209, JString, required = true,
                                 default = nil)
  if valid_776209 != nil:
    section.add "SourceDatabaseName", valid_776209
  var valid_776210 = query.getOrDefault("SourceTableName")
  valid_776210 = validateParameter(valid_776210, JString, required = true,
                                 default = nil)
  if valid_776210 != nil:
    section.add "SourceTableName", valid_776210
  var valid_776211 = query.getOrDefault("SourceSchemaName")
  valid_776211 = validateParameter(valid_776211, JString, required = false,
                                 default = nil)
  if valid_776211 != nil:
    section.add "SourceSchemaName", valid_776211
  var valid_776212 = query.getOrDefault("ClusterIdentifier")
  valid_776212 = validateParameter(valid_776212, JString, required = true,
                                 default = nil)
  if valid_776212 != nil:
    section.add "ClusterIdentifier", valid_776212
  var valid_776213 = query.getOrDefault("Action")
  valid_776213 = validateParameter(valid_776213, JString, required = true, default = newJString(
      "RestoreTableFromClusterSnapshot"))
  if valid_776213 != nil:
    section.add "Action", valid_776213
  var valid_776214 = query.getOrDefault("TargetDatabaseName")
  valid_776214 = validateParameter(valid_776214, JString, required = false,
                                 default = nil)
  if valid_776214 != nil:
    section.add "TargetDatabaseName", valid_776214
  var valid_776215 = query.getOrDefault("NewTableName")
  valid_776215 = validateParameter(valid_776215, JString, required = true,
                                 default = nil)
  if valid_776215 != nil:
    section.add "NewTableName", valid_776215
  var valid_776216 = query.getOrDefault("SnapshotIdentifier")
  valid_776216 = validateParameter(valid_776216, JString, required = true,
                                 default = nil)
  if valid_776216 != nil:
    section.add "SnapshotIdentifier", valid_776216
  var valid_776217 = query.getOrDefault("Version")
  valid_776217 = validateParameter(valid_776217, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_776217 != nil:
    section.add "Version", valid_776217
  var valid_776218 = query.getOrDefault("TargetSchemaName")
  valid_776218 = validateParameter(valid_776218, JString, required = false,
                                 default = nil)
  if valid_776218 != nil:
    section.add "TargetSchemaName", valid_776218
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_776219 = header.getOrDefault("X-Amz-Date")
  valid_776219 = validateParameter(valid_776219, JString, required = false,
                                 default = nil)
  if valid_776219 != nil:
    section.add "X-Amz-Date", valid_776219
  var valid_776220 = header.getOrDefault("X-Amz-Security-Token")
  valid_776220 = validateParameter(valid_776220, JString, required = false,
                                 default = nil)
  if valid_776220 != nil:
    section.add "X-Amz-Security-Token", valid_776220
  var valid_776221 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_776221 = validateParameter(valid_776221, JString, required = false,
                                 default = nil)
  if valid_776221 != nil:
    section.add "X-Amz-Content-Sha256", valid_776221
  var valid_776222 = header.getOrDefault("X-Amz-Algorithm")
  valid_776222 = validateParameter(valid_776222, JString, required = false,
                                 default = nil)
  if valid_776222 != nil:
    section.add "X-Amz-Algorithm", valid_776222
  var valid_776223 = header.getOrDefault("X-Amz-Signature")
  valid_776223 = validateParameter(valid_776223, JString, required = false,
                                 default = nil)
  if valid_776223 != nil:
    section.add "X-Amz-Signature", valid_776223
  var valid_776224 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_776224 = validateParameter(valid_776224, JString, required = false,
                                 default = nil)
  if valid_776224 != nil:
    section.add "X-Amz-SignedHeaders", valid_776224
  var valid_776225 = header.getOrDefault("X-Amz-Credential")
  valid_776225 = validateParameter(valid_776225, JString, required = false,
                                 default = nil)
  if valid_776225 != nil:
    section.add "X-Amz-Credential", valid_776225
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_776226: Call_GetRestoreTableFromClusterSnapshot_776206;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Creates a new table from a table in an Amazon Redshift cluster snapshot. You must create the new table within the Amazon Redshift cluster that the snapshot was taken from.</p> <p>You cannot use <code>RestoreTableFromClusterSnapshot</code> to restore a table with the same name as an existing table in an Amazon Redshift cluster. That is, you cannot overwrite an existing table in a cluster with a restored table. If you want to replace your original table with a new, restored table, then rename or drop your original table before you call <code>RestoreTableFromClusterSnapshot</code>. When you have renamed your original table, then you can pass the original name of the table as the <code>NewTableName</code> parameter value in the call to <code>RestoreTableFromClusterSnapshot</code>. This way, you can replace the original table with the table created from the snapshot.</p>
  ## 
  let valid = call_776226.validator(path, query, header, formData, body)
  let scheme = call_776226.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_776226.url(scheme.get, call_776226.host, call_776226.base,
                         call_776226.route, valid.getOrDefault("path"))
  result = hook(call_776226, url, valid)

proc call*(call_776227: Call_GetRestoreTableFromClusterSnapshot_776206;
          SourceDatabaseName: string; SourceTableName: string;
          ClusterIdentifier: string; NewTableName: string;
          SnapshotIdentifier: string; SourceSchemaName: string = "";
          Action: string = "RestoreTableFromClusterSnapshot";
          TargetDatabaseName: string = ""; Version: string = "2012-12-01";
          TargetSchemaName: string = ""): Recallable =
  ## getRestoreTableFromClusterSnapshot
  ## <p>Creates a new table from a table in an Amazon Redshift cluster snapshot. You must create the new table within the Amazon Redshift cluster that the snapshot was taken from.</p> <p>You cannot use <code>RestoreTableFromClusterSnapshot</code> to restore a table with the same name as an existing table in an Amazon Redshift cluster. That is, you cannot overwrite an existing table in a cluster with a restored table. If you want to replace your original table with a new, restored table, then rename or drop your original table before you call <code>RestoreTableFromClusterSnapshot</code>. When you have renamed your original table, then you can pass the original name of the table as the <code>NewTableName</code> parameter value in the call to <code>RestoreTableFromClusterSnapshot</code>. This way, you can replace the original table with the table created from the snapshot.</p>
  ##   SourceDatabaseName: string (required)
  ##                     : The name of the source database that contains the table to restore from.
  ##   SourceTableName: string (required)
  ##                  : The name of the source table to restore from.
  ##   SourceSchemaName: string
  ##                   : The name of the source schema that contains the table to restore from. If you do not specify a <code>SourceSchemaName</code> value, the default is <code>public</code>.
  ##   ClusterIdentifier: string (required)
  ##                    : The identifier of the Amazon Redshift cluster to restore the table to.
  ##   Action: string (required)
  ##   TargetDatabaseName: string
  ##                     : The name of the database to restore the table to.
  ##   NewTableName: string (required)
  ##               : The name of the table to create as a result of the current request.
  ##   SnapshotIdentifier: string (required)
  ##                     : The identifier of the snapshot to restore the table from. This snapshot must have been created from the Amazon Redshift cluster specified by the <code>ClusterIdentifier</code> parameter.
  ##   Version: string (required)
  ##   TargetSchemaName: string
  ##                   : The name of the schema to restore the table to.
  var query_776228 = newJObject()
  add(query_776228, "SourceDatabaseName", newJString(SourceDatabaseName))
  add(query_776228, "SourceTableName", newJString(SourceTableName))
  add(query_776228, "SourceSchemaName", newJString(SourceSchemaName))
  add(query_776228, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_776228, "Action", newJString(Action))
  add(query_776228, "TargetDatabaseName", newJString(TargetDatabaseName))
  add(query_776228, "NewTableName", newJString(NewTableName))
  add(query_776228, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_776228, "Version", newJString(Version))
  add(query_776228, "TargetSchemaName", newJString(TargetSchemaName))
  result = call_776227.call(nil, query_776228, nil, nil, nil)

var getRestoreTableFromClusterSnapshot* = Call_GetRestoreTableFromClusterSnapshot_776206(
    name: "getRestoreTableFromClusterSnapshot", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=RestoreTableFromClusterSnapshot",
    validator: validate_GetRestoreTableFromClusterSnapshot_776207, base: "/",
    url: url_GetRestoreTableFromClusterSnapshot_776208,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostRevokeClusterSecurityGroupIngress_776272 = ref object of OpenApiRestCall_772581
proc url_PostRevokeClusterSecurityGroupIngress_776274(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_PostRevokeClusterSecurityGroupIngress_776273(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Revokes an ingress rule in an Amazon Redshift security group for a previously authorized IP range or Amazon EC2 security group. To add an ingress rule, see <a>AuthorizeClusterSecurityGroupIngress</a>. For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_776275 = query.getOrDefault("Action")
  valid_776275 = validateParameter(valid_776275, JString, required = true, default = newJString(
      "RevokeClusterSecurityGroupIngress"))
  if valid_776275 != nil:
    section.add "Action", valid_776275
  var valid_776276 = query.getOrDefault("Version")
  valid_776276 = validateParameter(valid_776276, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_776276 != nil:
    section.add "Version", valid_776276
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_776277 = header.getOrDefault("X-Amz-Date")
  valid_776277 = validateParameter(valid_776277, JString, required = false,
                                 default = nil)
  if valid_776277 != nil:
    section.add "X-Amz-Date", valid_776277
  var valid_776278 = header.getOrDefault("X-Amz-Security-Token")
  valid_776278 = validateParameter(valid_776278, JString, required = false,
                                 default = nil)
  if valid_776278 != nil:
    section.add "X-Amz-Security-Token", valid_776278
  var valid_776279 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_776279 = validateParameter(valid_776279, JString, required = false,
                                 default = nil)
  if valid_776279 != nil:
    section.add "X-Amz-Content-Sha256", valid_776279
  var valid_776280 = header.getOrDefault("X-Amz-Algorithm")
  valid_776280 = validateParameter(valid_776280, JString, required = false,
                                 default = nil)
  if valid_776280 != nil:
    section.add "X-Amz-Algorithm", valid_776280
  var valid_776281 = header.getOrDefault("X-Amz-Signature")
  valid_776281 = validateParameter(valid_776281, JString, required = false,
                                 default = nil)
  if valid_776281 != nil:
    section.add "X-Amz-Signature", valid_776281
  var valid_776282 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_776282 = validateParameter(valid_776282, JString, required = false,
                                 default = nil)
  if valid_776282 != nil:
    section.add "X-Amz-SignedHeaders", valid_776282
  var valid_776283 = header.getOrDefault("X-Amz-Credential")
  valid_776283 = validateParameter(valid_776283, JString, required = false,
                                 default = nil)
  if valid_776283 != nil:
    section.add "X-Amz-Credential", valid_776283
  result.add "header", section
  ## parameters in `formData` object:
  ##   EC2SecurityGroupName: JString
  ##                       : The name of the EC2 Security Group whose access is to be revoked. If <code>EC2SecurityGroupName</code> is specified, <code>EC2SecurityGroupOwnerId</code> must also be provided and <code>CIDRIP</code> cannot be provided. 
  ##   CIDRIP: JString
  ##         : The IP range for which to revoke access. This range must be a valid Classless Inter-Domain Routing (CIDR) block of IP addresses. If <code>CIDRIP</code> is specified, <code>EC2SecurityGroupName</code> and <code>EC2SecurityGroupOwnerId</code> cannot be provided. 
  ##   EC2SecurityGroupOwnerId: JString
  ##                          : <p>The AWS account number of the owner of the security group specified in the <code>EC2SecurityGroupName</code> parameter. The AWS access key ID is not an acceptable value. If <code>EC2SecurityGroupOwnerId</code> is specified, <code>EC2SecurityGroupName</code> must also be provided. and <code>CIDRIP</code> cannot be provided. </p> <p>Example: <code>111122223333</code> </p>
  ##   ClusterSecurityGroupName: JString (required)
  ##                           : The name of the security Group from which to revoke the ingress rule.
  section = newJObject()
  var valid_776284 = formData.getOrDefault("EC2SecurityGroupName")
  valid_776284 = validateParameter(valid_776284, JString, required = false,
                                 default = nil)
  if valid_776284 != nil:
    section.add "EC2SecurityGroupName", valid_776284
  var valid_776285 = formData.getOrDefault("CIDRIP")
  valid_776285 = validateParameter(valid_776285, JString, required = false,
                                 default = nil)
  if valid_776285 != nil:
    section.add "CIDRIP", valid_776285
  var valid_776286 = formData.getOrDefault("EC2SecurityGroupOwnerId")
  valid_776286 = validateParameter(valid_776286, JString, required = false,
                                 default = nil)
  if valid_776286 != nil:
    section.add "EC2SecurityGroupOwnerId", valid_776286
  assert formData != nil, "formData argument is necessary due to required `ClusterSecurityGroupName` field"
  var valid_776287 = formData.getOrDefault("ClusterSecurityGroupName")
  valid_776287 = validateParameter(valid_776287, JString, required = true,
                                 default = nil)
  if valid_776287 != nil:
    section.add "ClusterSecurityGroupName", valid_776287
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_776288: Call_PostRevokeClusterSecurityGroupIngress_776272;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Revokes an ingress rule in an Amazon Redshift security group for a previously authorized IP range or Amazon EC2 security group. To add an ingress rule, see <a>AuthorizeClusterSecurityGroupIngress</a>. For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>. 
  ## 
  let valid = call_776288.validator(path, query, header, formData, body)
  let scheme = call_776288.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_776288.url(scheme.get, call_776288.host, call_776288.base,
                         call_776288.route, valid.getOrDefault("path"))
  result = hook(call_776288, url, valid)

proc call*(call_776289: Call_PostRevokeClusterSecurityGroupIngress_776272;
          ClusterSecurityGroupName: string;
          Action: string = "RevokeClusterSecurityGroupIngress";
          EC2SecurityGroupName: string = ""; CIDRIP: string = "";
          Version: string = "2012-12-01"; EC2SecurityGroupOwnerId: string = ""): Recallable =
  ## postRevokeClusterSecurityGroupIngress
  ## Revokes an ingress rule in an Amazon Redshift security group for a previously authorized IP range or Amazon EC2 security group. To add an ingress rule, see <a>AuthorizeClusterSecurityGroupIngress</a>. For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>. 
  ##   Action: string (required)
  ##   EC2SecurityGroupName: string
  ##                       : The name of the EC2 Security Group whose access is to be revoked. If <code>EC2SecurityGroupName</code> is specified, <code>EC2SecurityGroupOwnerId</code> must also be provided and <code>CIDRIP</code> cannot be provided. 
  ##   CIDRIP: string
  ##         : The IP range for which to revoke access. This range must be a valid Classless Inter-Domain Routing (CIDR) block of IP addresses. If <code>CIDRIP</code> is specified, <code>EC2SecurityGroupName</code> and <code>EC2SecurityGroupOwnerId</code> cannot be provided. 
  ##   Version: string (required)
  ##   EC2SecurityGroupOwnerId: string
  ##                          : <p>The AWS account number of the owner of the security group specified in the <code>EC2SecurityGroupName</code> parameter. The AWS access key ID is not an acceptable value. If <code>EC2SecurityGroupOwnerId</code> is specified, <code>EC2SecurityGroupName</code> must also be provided. and <code>CIDRIP</code> cannot be provided. </p> <p>Example: <code>111122223333</code> </p>
  ##   ClusterSecurityGroupName: string (required)
  ##                           : The name of the security Group from which to revoke the ingress rule.
  var query_776290 = newJObject()
  var formData_776291 = newJObject()
  add(query_776290, "Action", newJString(Action))
  add(formData_776291, "EC2SecurityGroupName", newJString(EC2SecurityGroupName))
  add(formData_776291, "CIDRIP", newJString(CIDRIP))
  add(query_776290, "Version", newJString(Version))
  add(formData_776291, "EC2SecurityGroupOwnerId",
      newJString(EC2SecurityGroupOwnerId))
  add(formData_776291, "ClusterSecurityGroupName",
      newJString(ClusterSecurityGroupName))
  result = call_776289.call(nil, query_776290, nil, formData_776291, nil)

var postRevokeClusterSecurityGroupIngress* = Call_PostRevokeClusterSecurityGroupIngress_776272(
    name: "postRevokeClusterSecurityGroupIngress", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=RevokeClusterSecurityGroupIngress",
    validator: validate_PostRevokeClusterSecurityGroupIngress_776273, base: "/",
    url: url_PostRevokeClusterSecurityGroupIngress_776274,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetRevokeClusterSecurityGroupIngress_776253 = ref object of OpenApiRestCall_772581
proc url_GetRevokeClusterSecurityGroupIngress_776255(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_GetRevokeClusterSecurityGroupIngress_776254(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Revokes an ingress rule in an Amazon Redshift security group for a previously authorized IP range or Amazon EC2 security group. To add an ingress rule, see <a>AuthorizeClusterSecurityGroupIngress</a>. For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ClusterSecurityGroupName: JString (required)
  ##                           : The name of the security Group from which to revoke the ingress rule.
  ##   EC2SecurityGroupOwnerId: JString
  ##                          : <p>The AWS account number of the owner of the security group specified in the <code>EC2SecurityGroupName</code> parameter. The AWS access key ID is not an acceptable value. If <code>EC2SecurityGroupOwnerId</code> is specified, <code>EC2SecurityGroupName</code> must also be provided. and <code>CIDRIP</code> cannot be provided. </p> <p>Example: <code>111122223333</code> </p>
  ##   Action: JString (required)
  ##   CIDRIP: JString
  ##         : The IP range for which to revoke access. This range must be a valid Classless Inter-Domain Routing (CIDR) block of IP addresses. If <code>CIDRIP</code> is specified, <code>EC2SecurityGroupName</code> and <code>EC2SecurityGroupOwnerId</code> cannot be provided. 
  ##   EC2SecurityGroupName: JString
  ##                       : The name of the EC2 Security Group whose access is to be revoked. If <code>EC2SecurityGroupName</code> is specified, <code>EC2SecurityGroupOwnerId</code> must also be provided and <code>CIDRIP</code> cannot be provided. 
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `ClusterSecurityGroupName` field"
  var valid_776256 = query.getOrDefault("ClusterSecurityGroupName")
  valid_776256 = validateParameter(valid_776256, JString, required = true,
                                 default = nil)
  if valid_776256 != nil:
    section.add "ClusterSecurityGroupName", valid_776256
  var valid_776257 = query.getOrDefault("EC2SecurityGroupOwnerId")
  valid_776257 = validateParameter(valid_776257, JString, required = false,
                                 default = nil)
  if valid_776257 != nil:
    section.add "EC2SecurityGroupOwnerId", valid_776257
  var valid_776258 = query.getOrDefault("Action")
  valid_776258 = validateParameter(valid_776258, JString, required = true, default = newJString(
      "RevokeClusterSecurityGroupIngress"))
  if valid_776258 != nil:
    section.add "Action", valid_776258
  var valid_776259 = query.getOrDefault("CIDRIP")
  valid_776259 = validateParameter(valid_776259, JString, required = false,
                                 default = nil)
  if valid_776259 != nil:
    section.add "CIDRIP", valid_776259
  var valid_776260 = query.getOrDefault("EC2SecurityGroupName")
  valid_776260 = validateParameter(valid_776260, JString, required = false,
                                 default = nil)
  if valid_776260 != nil:
    section.add "EC2SecurityGroupName", valid_776260
  var valid_776261 = query.getOrDefault("Version")
  valid_776261 = validateParameter(valid_776261, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_776261 != nil:
    section.add "Version", valid_776261
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_776262 = header.getOrDefault("X-Amz-Date")
  valid_776262 = validateParameter(valid_776262, JString, required = false,
                                 default = nil)
  if valid_776262 != nil:
    section.add "X-Amz-Date", valid_776262
  var valid_776263 = header.getOrDefault("X-Amz-Security-Token")
  valid_776263 = validateParameter(valid_776263, JString, required = false,
                                 default = nil)
  if valid_776263 != nil:
    section.add "X-Amz-Security-Token", valid_776263
  var valid_776264 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_776264 = validateParameter(valid_776264, JString, required = false,
                                 default = nil)
  if valid_776264 != nil:
    section.add "X-Amz-Content-Sha256", valid_776264
  var valid_776265 = header.getOrDefault("X-Amz-Algorithm")
  valid_776265 = validateParameter(valid_776265, JString, required = false,
                                 default = nil)
  if valid_776265 != nil:
    section.add "X-Amz-Algorithm", valid_776265
  var valid_776266 = header.getOrDefault("X-Amz-Signature")
  valid_776266 = validateParameter(valid_776266, JString, required = false,
                                 default = nil)
  if valid_776266 != nil:
    section.add "X-Amz-Signature", valid_776266
  var valid_776267 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_776267 = validateParameter(valid_776267, JString, required = false,
                                 default = nil)
  if valid_776267 != nil:
    section.add "X-Amz-SignedHeaders", valid_776267
  var valid_776268 = header.getOrDefault("X-Amz-Credential")
  valid_776268 = validateParameter(valid_776268, JString, required = false,
                                 default = nil)
  if valid_776268 != nil:
    section.add "X-Amz-Credential", valid_776268
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_776269: Call_GetRevokeClusterSecurityGroupIngress_776253;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Revokes an ingress rule in an Amazon Redshift security group for a previously authorized IP range or Amazon EC2 security group. To add an ingress rule, see <a>AuthorizeClusterSecurityGroupIngress</a>. For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>. 
  ## 
  let valid = call_776269.validator(path, query, header, formData, body)
  let scheme = call_776269.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_776269.url(scheme.get, call_776269.host, call_776269.base,
                         call_776269.route, valid.getOrDefault("path"))
  result = hook(call_776269, url, valid)

proc call*(call_776270: Call_GetRevokeClusterSecurityGroupIngress_776253;
          ClusterSecurityGroupName: string; EC2SecurityGroupOwnerId: string = "";
          Action: string = "RevokeClusterSecurityGroupIngress"; CIDRIP: string = "";
          EC2SecurityGroupName: string = ""; Version: string = "2012-12-01"): Recallable =
  ## getRevokeClusterSecurityGroupIngress
  ## Revokes an ingress rule in an Amazon Redshift security group for a previously authorized IP range or Amazon EC2 security group. To add an ingress rule, see <a>AuthorizeClusterSecurityGroupIngress</a>. For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>. 
  ##   ClusterSecurityGroupName: string (required)
  ##                           : The name of the security Group from which to revoke the ingress rule.
  ##   EC2SecurityGroupOwnerId: string
  ##                          : <p>The AWS account number of the owner of the security group specified in the <code>EC2SecurityGroupName</code> parameter. The AWS access key ID is not an acceptable value. If <code>EC2SecurityGroupOwnerId</code> is specified, <code>EC2SecurityGroupName</code> must also be provided. and <code>CIDRIP</code> cannot be provided. </p> <p>Example: <code>111122223333</code> </p>
  ##   Action: string (required)
  ##   CIDRIP: string
  ##         : The IP range for which to revoke access. This range must be a valid Classless Inter-Domain Routing (CIDR) block of IP addresses. If <code>CIDRIP</code> is specified, <code>EC2SecurityGroupName</code> and <code>EC2SecurityGroupOwnerId</code> cannot be provided. 
  ##   EC2SecurityGroupName: string
  ##                       : The name of the EC2 Security Group whose access is to be revoked. If <code>EC2SecurityGroupName</code> is specified, <code>EC2SecurityGroupOwnerId</code> must also be provided and <code>CIDRIP</code> cannot be provided. 
  ##   Version: string (required)
  var query_776271 = newJObject()
  add(query_776271, "ClusterSecurityGroupName",
      newJString(ClusterSecurityGroupName))
  add(query_776271, "EC2SecurityGroupOwnerId", newJString(EC2SecurityGroupOwnerId))
  add(query_776271, "Action", newJString(Action))
  add(query_776271, "CIDRIP", newJString(CIDRIP))
  add(query_776271, "EC2SecurityGroupName", newJString(EC2SecurityGroupName))
  add(query_776271, "Version", newJString(Version))
  result = call_776270.call(nil, query_776271, nil, nil, nil)

var getRevokeClusterSecurityGroupIngress* = Call_GetRevokeClusterSecurityGroupIngress_776253(
    name: "getRevokeClusterSecurityGroupIngress", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=RevokeClusterSecurityGroupIngress",
    validator: validate_GetRevokeClusterSecurityGroupIngress_776254, base: "/",
    url: url_GetRevokeClusterSecurityGroupIngress_776255,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostRevokeSnapshotAccess_776310 = ref object of OpenApiRestCall_772581
proc url_PostRevokeSnapshotAccess_776312(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_PostRevokeSnapshotAccess_776311(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Removes the ability of the specified AWS customer account to restore the specified snapshot. If the account is currently restoring the snapshot, the restore will run to completion.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_776313 = query.getOrDefault("Action")
  valid_776313 = validateParameter(valid_776313, JString, required = true,
                                 default = newJString("RevokeSnapshotAccess"))
  if valid_776313 != nil:
    section.add "Action", valid_776313
  var valid_776314 = query.getOrDefault("Version")
  valid_776314 = validateParameter(valid_776314, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_776314 != nil:
    section.add "Version", valid_776314
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_776315 = header.getOrDefault("X-Amz-Date")
  valid_776315 = validateParameter(valid_776315, JString, required = false,
                                 default = nil)
  if valid_776315 != nil:
    section.add "X-Amz-Date", valid_776315
  var valid_776316 = header.getOrDefault("X-Amz-Security-Token")
  valid_776316 = validateParameter(valid_776316, JString, required = false,
                                 default = nil)
  if valid_776316 != nil:
    section.add "X-Amz-Security-Token", valid_776316
  var valid_776317 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_776317 = validateParameter(valid_776317, JString, required = false,
                                 default = nil)
  if valid_776317 != nil:
    section.add "X-Amz-Content-Sha256", valid_776317
  var valid_776318 = header.getOrDefault("X-Amz-Algorithm")
  valid_776318 = validateParameter(valid_776318, JString, required = false,
                                 default = nil)
  if valid_776318 != nil:
    section.add "X-Amz-Algorithm", valid_776318
  var valid_776319 = header.getOrDefault("X-Amz-Signature")
  valid_776319 = validateParameter(valid_776319, JString, required = false,
                                 default = nil)
  if valid_776319 != nil:
    section.add "X-Amz-Signature", valid_776319
  var valid_776320 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_776320 = validateParameter(valid_776320, JString, required = false,
                                 default = nil)
  if valid_776320 != nil:
    section.add "X-Amz-SignedHeaders", valid_776320
  var valid_776321 = header.getOrDefault("X-Amz-Credential")
  valid_776321 = validateParameter(valid_776321, JString, required = false,
                                 default = nil)
  if valid_776321 != nil:
    section.add "X-Amz-Credential", valid_776321
  result.add "header", section
  ## parameters in `formData` object:
  ##   AccountWithRestoreAccess: JString (required)
  ##                           : The identifier of the AWS customer account that can no longer restore the specified snapshot.
  ##   SnapshotClusterIdentifier: JString
  ##                            : The identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.
  ##   SnapshotIdentifier: JString (required)
  ##                     : The identifier of the snapshot that the account can no longer access.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `AccountWithRestoreAccess` field"
  var valid_776322 = formData.getOrDefault("AccountWithRestoreAccess")
  valid_776322 = validateParameter(valid_776322, JString, required = true,
                                 default = nil)
  if valid_776322 != nil:
    section.add "AccountWithRestoreAccess", valid_776322
  var valid_776323 = formData.getOrDefault("SnapshotClusterIdentifier")
  valid_776323 = validateParameter(valid_776323, JString, required = false,
                                 default = nil)
  if valid_776323 != nil:
    section.add "SnapshotClusterIdentifier", valid_776323
  var valid_776324 = formData.getOrDefault("SnapshotIdentifier")
  valid_776324 = validateParameter(valid_776324, JString, required = true,
                                 default = nil)
  if valid_776324 != nil:
    section.add "SnapshotIdentifier", valid_776324
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_776325: Call_PostRevokeSnapshotAccess_776310; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Removes the ability of the specified AWS customer account to restore the specified snapshot. If the account is currently restoring the snapshot, the restore will run to completion.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_776325.validator(path, query, header, formData, body)
  let scheme = call_776325.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_776325.url(scheme.get, call_776325.host, call_776325.base,
                         call_776325.route, valid.getOrDefault("path"))
  result = hook(call_776325, url, valid)

proc call*(call_776326: Call_PostRevokeSnapshotAccess_776310;
          AccountWithRestoreAccess: string; SnapshotIdentifier: string;
          SnapshotClusterIdentifier: string = "";
          Action: string = "RevokeSnapshotAccess"; Version: string = "2012-12-01"): Recallable =
  ## postRevokeSnapshotAccess
  ## <p>Removes the ability of the specified AWS customer account to restore the specified snapshot. If the account is currently restoring the snapshot, the restore will run to completion.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   AccountWithRestoreAccess: string (required)
  ##                           : The identifier of the AWS customer account that can no longer restore the specified snapshot.
  ##   SnapshotClusterIdentifier: string
  ##                            : The identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.
  ##   Action: string (required)
  ##   SnapshotIdentifier: string (required)
  ##                     : The identifier of the snapshot that the account can no longer access.
  ##   Version: string (required)
  var query_776327 = newJObject()
  var formData_776328 = newJObject()
  add(formData_776328, "AccountWithRestoreAccess",
      newJString(AccountWithRestoreAccess))
  add(formData_776328, "SnapshotClusterIdentifier",
      newJString(SnapshotClusterIdentifier))
  add(query_776327, "Action", newJString(Action))
  add(formData_776328, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_776327, "Version", newJString(Version))
  result = call_776326.call(nil, query_776327, nil, formData_776328, nil)

var postRevokeSnapshotAccess* = Call_PostRevokeSnapshotAccess_776310(
    name: "postRevokeSnapshotAccess", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=RevokeSnapshotAccess",
    validator: validate_PostRevokeSnapshotAccess_776311, base: "/",
    url: url_PostRevokeSnapshotAccess_776312, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetRevokeSnapshotAccess_776292 = ref object of OpenApiRestCall_772581
proc url_GetRevokeSnapshotAccess_776294(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_GetRevokeSnapshotAccess_776293(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Removes the ability of the specified AWS customer account to restore the specified snapshot. If the account is currently restoring the snapshot, the restore will run to completion.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   AccountWithRestoreAccess: JString (required)
  ##                           : The identifier of the AWS customer account that can no longer restore the specified snapshot.
  ##   Action: JString (required)
  ##   SnapshotClusterIdentifier: JString
  ##                            : The identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.
  ##   SnapshotIdentifier: JString (required)
  ##                     : The identifier of the snapshot that the account can no longer access.
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `AccountWithRestoreAccess` field"
  var valid_776295 = query.getOrDefault("AccountWithRestoreAccess")
  valid_776295 = validateParameter(valid_776295, JString, required = true,
                                 default = nil)
  if valid_776295 != nil:
    section.add "AccountWithRestoreAccess", valid_776295
  var valid_776296 = query.getOrDefault("Action")
  valid_776296 = validateParameter(valid_776296, JString, required = true,
                                 default = newJString("RevokeSnapshotAccess"))
  if valid_776296 != nil:
    section.add "Action", valid_776296
  var valid_776297 = query.getOrDefault("SnapshotClusterIdentifier")
  valid_776297 = validateParameter(valid_776297, JString, required = false,
                                 default = nil)
  if valid_776297 != nil:
    section.add "SnapshotClusterIdentifier", valid_776297
  var valid_776298 = query.getOrDefault("SnapshotIdentifier")
  valid_776298 = validateParameter(valid_776298, JString, required = true,
                                 default = nil)
  if valid_776298 != nil:
    section.add "SnapshotIdentifier", valid_776298
  var valid_776299 = query.getOrDefault("Version")
  valid_776299 = validateParameter(valid_776299, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_776299 != nil:
    section.add "Version", valid_776299
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_776300 = header.getOrDefault("X-Amz-Date")
  valid_776300 = validateParameter(valid_776300, JString, required = false,
                                 default = nil)
  if valid_776300 != nil:
    section.add "X-Amz-Date", valid_776300
  var valid_776301 = header.getOrDefault("X-Amz-Security-Token")
  valid_776301 = validateParameter(valid_776301, JString, required = false,
                                 default = nil)
  if valid_776301 != nil:
    section.add "X-Amz-Security-Token", valid_776301
  var valid_776302 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_776302 = validateParameter(valid_776302, JString, required = false,
                                 default = nil)
  if valid_776302 != nil:
    section.add "X-Amz-Content-Sha256", valid_776302
  var valid_776303 = header.getOrDefault("X-Amz-Algorithm")
  valid_776303 = validateParameter(valid_776303, JString, required = false,
                                 default = nil)
  if valid_776303 != nil:
    section.add "X-Amz-Algorithm", valid_776303
  var valid_776304 = header.getOrDefault("X-Amz-Signature")
  valid_776304 = validateParameter(valid_776304, JString, required = false,
                                 default = nil)
  if valid_776304 != nil:
    section.add "X-Amz-Signature", valid_776304
  var valid_776305 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_776305 = validateParameter(valid_776305, JString, required = false,
                                 default = nil)
  if valid_776305 != nil:
    section.add "X-Amz-SignedHeaders", valid_776305
  var valid_776306 = header.getOrDefault("X-Amz-Credential")
  valid_776306 = validateParameter(valid_776306, JString, required = false,
                                 default = nil)
  if valid_776306 != nil:
    section.add "X-Amz-Credential", valid_776306
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_776307: Call_GetRevokeSnapshotAccess_776292; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Removes the ability of the specified AWS customer account to restore the specified snapshot. If the account is currently restoring the snapshot, the restore will run to completion.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_776307.validator(path, query, header, formData, body)
  let scheme = call_776307.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_776307.url(scheme.get, call_776307.host, call_776307.base,
                         call_776307.route, valid.getOrDefault("path"))
  result = hook(call_776307, url, valid)

proc call*(call_776308: Call_GetRevokeSnapshotAccess_776292;
          AccountWithRestoreAccess: string; SnapshotIdentifier: string;
          Action: string = "RevokeSnapshotAccess";
          SnapshotClusterIdentifier: string = ""; Version: string = "2012-12-01"): Recallable =
  ## getRevokeSnapshotAccess
  ## <p>Removes the ability of the specified AWS customer account to restore the specified snapshot. If the account is currently restoring the snapshot, the restore will run to completion.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   AccountWithRestoreAccess: string (required)
  ##                           : The identifier of the AWS customer account that can no longer restore the specified snapshot.
  ##   Action: string (required)
  ##   SnapshotClusterIdentifier: string
  ##                            : The identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.
  ##   SnapshotIdentifier: string (required)
  ##                     : The identifier of the snapshot that the account can no longer access.
  ##   Version: string (required)
  var query_776309 = newJObject()
  add(query_776309, "AccountWithRestoreAccess",
      newJString(AccountWithRestoreAccess))
  add(query_776309, "Action", newJString(Action))
  add(query_776309, "SnapshotClusterIdentifier",
      newJString(SnapshotClusterIdentifier))
  add(query_776309, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_776309, "Version", newJString(Version))
  result = call_776308.call(nil, query_776309, nil, nil, nil)

var getRevokeSnapshotAccess* = Call_GetRevokeSnapshotAccess_776292(
    name: "getRevokeSnapshotAccess", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=RevokeSnapshotAccess",
    validator: validate_GetRevokeSnapshotAccess_776293, base: "/",
    url: url_GetRevokeSnapshotAccess_776294, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostRotateEncryptionKey_776345 = ref object of OpenApiRestCall_772581
proc url_PostRotateEncryptionKey_776347(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_PostRotateEncryptionKey_776346(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Rotates the encryption keys for a cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_776348 = query.getOrDefault("Action")
  valid_776348 = validateParameter(valid_776348, JString, required = true,
                                 default = newJString("RotateEncryptionKey"))
  if valid_776348 != nil:
    section.add "Action", valid_776348
  var valid_776349 = query.getOrDefault("Version")
  valid_776349 = validateParameter(valid_776349, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_776349 != nil:
    section.add "Version", valid_776349
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_776350 = header.getOrDefault("X-Amz-Date")
  valid_776350 = validateParameter(valid_776350, JString, required = false,
                                 default = nil)
  if valid_776350 != nil:
    section.add "X-Amz-Date", valid_776350
  var valid_776351 = header.getOrDefault("X-Amz-Security-Token")
  valid_776351 = validateParameter(valid_776351, JString, required = false,
                                 default = nil)
  if valid_776351 != nil:
    section.add "X-Amz-Security-Token", valid_776351
  var valid_776352 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_776352 = validateParameter(valid_776352, JString, required = false,
                                 default = nil)
  if valid_776352 != nil:
    section.add "X-Amz-Content-Sha256", valid_776352
  var valid_776353 = header.getOrDefault("X-Amz-Algorithm")
  valid_776353 = validateParameter(valid_776353, JString, required = false,
                                 default = nil)
  if valid_776353 != nil:
    section.add "X-Amz-Algorithm", valid_776353
  var valid_776354 = header.getOrDefault("X-Amz-Signature")
  valid_776354 = validateParameter(valid_776354, JString, required = false,
                                 default = nil)
  if valid_776354 != nil:
    section.add "X-Amz-Signature", valid_776354
  var valid_776355 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_776355 = validateParameter(valid_776355, JString, required = false,
                                 default = nil)
  if valid_776355 != nil:
    section.add "X-Amz-SignedHeaders", valid_776355
  var valid_776356 = header.getOrDefault("X-Amz-Credential")
  valid_776356 = validateParameter(valid_776356, JString, required = false,
                                 default = nil)
  if valid_776356 != nil:
    section.add "X-Amz-Credential", valid_776356
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of the cluster that you want to rotate the encryption keys for.</p> <p>Constraints: Must be the name of valid cluster that has encryption enabled.</p>
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_776357 = formData.getOrDefault("ClusterIdentifier")
  valid_776357 = validateParameter(valid_776357, JString, required = true,
                                 default = nil)
  if valid_776357 != nil:
    section.add "ClusterIdentifier", valid_776357
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_776358: Call_PostRotateEncryptionKey_776345; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Rotates the encryption keys for a cluster.
  ## 
  let valid = call_776358.validator(path, query, header, formData, body)
  let scheme = call_776358.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_776358.url(scheme.get, call_776358.host, call_776358.base,
                         call_776358.route, valid.getOrDefault("path"))
  result = hook(call_776358, url, valid)

proc call*(call_776359: Call_PostRotateEncryptionKey_776345;
          ClusterIdentifier: string; Action: string = "RotateEncryptionKey";
          Version: string = "2012-12-01"): Recallable =
  ## postRotateEncryptionKey
  ## Rotates the encryption keys for a cluster.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of the cluster that you want to rotate the encryption keys for.</p> <p>Constraints: Must be the name of valid cluster that has encryption enabled.</p>
  ##   Version: string (required)
  var query_776360 = newJObject()
  var formData_776361 = newJObject()
  add(query_776360, "Action", newJString(Action))
  add(formData_776361, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_776360, "Version", newJString(Version))
  result = call_776359.call(nil, query_776360, nil, formData_776361, nil)

var postRotateEncryptionKey* = Call_PostRotateEncryptionKey_776345(
    name: "postRotateEncryptionKey", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=RotateEncryptionKey",
    validator: validate_PostRotateEncryptionKey_776346, base: "/",
    url: url_PostRotateEncryptionKey_776347, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetRotateEncryptionKey_776329 = ref object of OpenApiRestCall_772581
proc url_GetRotateEncryptionKey_776331(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_GetRotateEncryptionKey_776330(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Rotates the encryption keys for a cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of the cluster that you want to rotate the encryption keys for.</p> <p>Constraints: Must be the name of valid cluster that has encryption enabled.</p>
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_776332 = query.getOrDefault("Action")
  valid_776332 = validateParameter(valid_776332, JString, required = true,
                                 default = newJString("RotateEncryptionKey"))
  if valid_776332 != nil:
    section.add "Action", valid_776332
  var valid_776333 = query.getOrDefault("ClusterIdentifier")
  valid_776333 = validateParameter(valid_776333, JString, required = true,
                                 default = nil)
  if valid_776333 != nil:
    section.add "ClusterIdentifier", valid_776333
  var valid_776334 = query.getOrDefault("Version")
  valid_776334 = validateParameter(valid_776334, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_776334 != nil:
    section.add "Version", valid_776334
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_776335 = header.getOrDefault("X-Amz-Date")
  valid_776335 = validateParameter(valid_776335, JString, required = false,
                                 default = nil)
  if valid_776335 != nil:
    section.add "X-Amz-Date", valid_776335
  var valid_776336 = header.getOrDefault("X-Amz-Security-Token")
  valid_776336 = validateParameter(valid_776336, JString, required = false,
                                 default = nil)
  if valid_776336 != nil:
    section.add "X-Amz-Security-Token", valid_776336
  var valid_776337 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_776337 = validateParameter(valid_776337, JString, required = false,
                                 default = nil)
  if valid_776337 != nil:
    section.add "X-Amz-Content-Sha256", valid_776337
  var valid_776338 = header.getOrDefault("X-Amz-Algorithm")
  valid_776338 = validateParameter(valid_776338, JString, required = false,
                                 default = nil)
  if valid_776338 != nil:
    section.add "X-Amz-Algorithm", valid_776338
  var valid_776339 = header.getOrDefault("X-Amz-Signature")
  valid_776339 = validateParameter(valid_776339, JString, required = false,
                                 default = nil)
  if valid_776339 != nil:
    section.add "X-Amz-Signature", valid_776339
  var valid_776340 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_776340 = validateParameter(valid_776340, JString, required = false,
                                 default = nil)
  if valid_776340 != nil:
    section.add "X-Amz-SignedHeaders", valid_776340
  var valid_776341 = header.getOrDefault("X-Amz-Credential")
  valid_776341 = validateParameter(valid_776341, JString, required = false,
                                 default = nil)
  if valid_776341 != nil:
    section.add "X-Amz-Credential", valid_776341
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_776342: Call_GetRotateEncryptionKey_776329; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Rotates the encryption keys for a cluster.
  ## 
  let valid = call_776342.validator(path, query, header, formData, body)
  let scheme = call_776342.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_776342.url(scheme.get, call_776342.host, call_776342.base,
                         call_776342.route, valid.getOrDefault("path"))
  result = hook(call_776342, url, valid)

proc call*(call_776343: Call_GetRotateEncryptionKey_776329;
          ClusterIdentifier: string; Action: string = "RotateEncryptionKey";
          Version: string = "2012-12-01"): Recallable =
  ## getRotateEncryptionKey
  ## Rotates the encryption keys for a cluster.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of the cluster that you want to rotate the encryption keys for.</p> <p>Constraints: Must be the name of valid cluster that has encryption enabled.</p>
  ##   Version: string (required)
  var query_776344 = newJObject()
  add(query_776344, "Action", newJString(Action))
  add(query_776344, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_776344, "Version", newJString(Version))
  result = call_776343.call(nil, query_776344, nil, nil, nil)

var getRotateEncryptionKey* = Call_GetRotateEncryptionKey_776329(
    name: "getRotateEncryptionKey", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=RotateEncryptionKey",
    validator: validate_GetRotateEncryptionKey_776330, base: "/",
    url: url_GetRotateEncryptionKey_776331, schemes: {Scheme.Https, Scheme.Http})
proc sign(recall: var Recallable; query: JsonNode; algo: SigningAlgo = SHA256) =
  let
    date = makeDateTime()
    access = os.getEnv("AWS_ACCESS_KEY_ID", "")
    secret = os.getEnv("AWS_SECRET_ACCESS_KEY", "")
    region = os.getEnv("AWS_REGION", "")
  assert secret != "", "need secret key in env"
  assert access != "", "need access key in env"
  assert region != "", "need region in env"
  var
    normal: PathNormal
    url = normalizeUrl(recall.url, query, normalize = normal)
    scheme = parseEnum[Scheme](url.scheme)
  assert scheme in awsServers, "unknown scheme `" & $scheme & "`"
  assert region in awsServers[scheme], "unknown region `" & region & "`"
  url.hostname = awsServers[scheme][region]
  case awsServiceName.toLowerAscii
  of "s3":
    normal = PathNormal.S3
  else:
    normal = PathNormal.Default
  recall.headers["Host"] = url.hostname
  recall.headers["X-Amz-Date"] = date
  let
    algo = SHA256
    scope = credentialScope(region = region, service = awsServiceName, date = date)
    request = canonicalRequest(recall.meth, $url, query, recall.headers, recall.body,
                             normalize = normal, digest = algo)
    sts = stringToSign(request.hash(algo), scope, date = date, digest = algo)
    signature = calculateSignature(secret = secret, date = date, region = region,
                                 service = awsServiceName, sts, digest = algo)
  var auth = $algo & " "
  auth &= "Credential=" & access / scope & ", "
  auth &= "SignedHeaders=" & recall.headers.signedHeaders & ", "
  auth &= "Signature=" & signature
  recall.headers["Authorization"] = auth
  echo recall.headers
  recall.headers.del "Host"
  recall.url = $url

method hook(call: OpenApiRestCall; url: string; input: JsonNode): Recallable {.base.} =
  let headers = massageHeaders(input.getOrDefault("header"))
  result = newRecallable(call, url, headers, "")
  result.sign(input.getOrDefault("query"), SHA256)
